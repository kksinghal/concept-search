73.75, tensor(0.0247), Description: Replace all digits adjacent to '1' with '8' in a grid. 
:: def cfhbcgffgadgeecficeabifceiaajbei(I):
  """
  Replaces digits adjacent to '1' with '8' in a grid.
  """
  # Find indices of all '1's in the grid.
  ones_indices = ofcolor(I, 1)

  # Find all neighbor indices of the '1's.
  neighbor_indices = mapply(dneighbors, ones_indices)

  # Filter out indices that are out of bounds of the grid.
  h, w = len(I), len(I[0])
  valid_indices = lambda x: 0 <= x[0] < h and 0 <= x[1] < w
  filtered_indices = sfilter(neighbor_indices, valid_indices)

  # Fill the grid at filtered indices with '8'.
  O = fill(I, 8, filtered_indices)

  return O
 
17.0, tensor(1.1065), Description: Replace all '1's in the grid with '8's. 
:: def aadjdjfgbagjebfdjiieeddcgejadeai(I):
    O = replace(I, ONE, EIGHT)
    return O 
 
23.75, tensor(1.0963), Description: Replace all single-colored squares and squares with two colored squares with '8' in the grid. 
:: def afjbfadibaddecbcaejjiaaaejcehfjd(I):
  x1 = objects(I, T, F, T)  # Extract objects, not considering diagonal connections
  x2 = sizefilter(x1, ONE)  # Filter for objects of size 1
  x3 = sizefilter(x1, TWO)  # Filter for objects of size 2
  x4 = merge((x2, x3))       # Combine objects of size 1 and 2
  O = fill(I, EIGHT, merge(apply(toindices, x4)))  # Fill combined objects with 8
  return O 
 
28.25, tensor(1.0608), Description: Replace all '1's that are within the border of the grid with '8's. 
:: def iddeaebdjcffebaibdjgibaedhagbffb(I):
    # Find objects, excluding background
    objs = objects(I, True, False, True) 
    # Filter for objects touching the border
    border_objs = sfilter(objs, lambda obj: bordering(obj, I))  
    # Combine all border objects into a single patch
    border_patch = merge(border_objs) 
    # Replace '1's within the border patch with '8's
    O = fill(I, 8, toindices(sfilter(border_patch, lambda x: x[0] == 1))) 
    return O
 
138.0, tensor(1.0608), Description: Replace all the objects that are not touching the border of the grid with '8's. The rest of the grid should be filled with '8's. 
:: def fcadffbiccffebiaafggaddbfbhadbeg(I):
    # Create a canvas of the same size as the input, filled with '8's
    canvas_8 = canvas(8, shape(I))  
    # Find objects, excluding background
    objs = objects(I, True, False, True)  
    # Filter for objects NOT touching the border
    non_border_objs = sfilter(objs, lambda obj: not bordering(obj, I)) 
    # Paint the non-border objects onto the canvas of '8's
    O = paint(canvas_8, merge(non_border_objs))  
    return O
 
14.5, tensor(1.0608), Description: Replace all '1's that are not on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def fgeidffibhfjeeeaihdccdihfjadaijf(I):
    # Get the background color of the input grid
    bg = mostcolor(I)  
    # Create a function to check if a location is on the border
    is_border = rbind(bordering, I) 
    # Create a function to check if a location is a '1' and not on the border
    is_inner_1 = lambda loc: index(I, loc) == 1 and not is_border({loc})  
    # Create a new grid by applying the check to each location
    O = tuple(tuple(8 if is_inner_1((i, j)) else I[i][j] for j in range(len(I[0]))) for i in range(len(I))) 
    return O
 
79.5, tensor(0.0249), Description: Replace all digits adjacent to '1' that are the same color as the background with '8' in a grid. 
:: def efddhiaeeabaefbfafcddgagabjeagbf(I):
  bg = mostcolor(I)
  ones = ofcolor(I, 1)
  neighbors = mapply(dneighbors, ones)
  valid_neighbors = sfilter(neighbors, lambda x: 0 <= x[0] < len(I) and 0 <= x[1] < len(I[0]) and index(I, x) == bg)
  O = fill(I, 8, valid_neighbors)
  return O
 
36.25, tensor(0.0249), Description: Replace all digits adjacent to '1' that are the same color as the background with '8' in a grid. 
:: def daejecacbhgceiacjgfachbffaafebia(I):
  objs = objects(I, True, False, False)
  target_obj = extract(objs, lambda obj: color(obj) == 1)
  neighbors = mapply(dneighbors, toindices(target_obj))
  bg = mostcolor(I)
  valid_neighbors = sfilter(neighbors, lambda x: 0 <= x[0] < len(I) and 0 <= x[1] < len(I[0]) and index(I, x) == bg)
  O = fill(I, 8, valid_neighbors)
  return O
 
22.75, tensor(1.0607), Description: Replace all objects that touch the top border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def djhebggbihhdedddibdbbbaacfedchdf(I):
    objs = objects(I, True, False, True)
    top_objs = sfilter(objs, lambda obj: uppermost(obj) == 0)
    O = fill(I, 8, merge(top_objs))
    return O
 
50.25, tensor(1.1482), Description: Replace the left neighbor of each '1' in the grid with '8', except for the leftmost '1' in each object. The rest of the grid should remain unchanged. 
:: def cdcjdcfacjfdeaccbiebccehacbejedf(I):
  # Iterate through each cell in the grid
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      # If the current cell is '1' and not the leftmost '1' in its object:
      if I[i][j] == ONE and (j == 0 or I[i][j-1] != ONE): 
        O = fill(O, EIGHT, {(i, j-1)})  # Fill its left neighbor with '8'
      else:
        O = fill(O, I[i][j], {(i, j)}) # Otherwise, copy the original cell
  return O
 
47.75, tensor(0.0229), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. 
:: def caaffejebefcejgeaeidejdaaebbadgg(I):
  O = I
  for obj in objects(I, True, False, True):  # Iterate over objects, excluding background
    O = fill(O, 8, delta(toindices(obj))) # Fill the outline of each object with 8
  return O
 
64.75, tensor(0.0144), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. 
:: def hdgfghhacccceabaacebejacdieeebad(I):
  bg = mostcolor(I)  # Identify background color
  O = canvas(bg, shape(I)) # Create a canvas filled with background color
  for obj in objects(I, True, False, True):  # Iterate over objects, excluding background
    O = paint(O, recolor(8, delta(toindices(obj))))  # Paint outline with color 8 on the canvas
  return O
 
16.75, tensor(0.0255), Description: Replace all non-background cells that have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def dihhcacjhfjeeaiijcffdihcbeehbhfh(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i, j)) != mostcolor(I) and any(index(I, n) == mostcolor(I) for n in dneighbors((i, j))):
        O = fill(O, 8, {(i, j)})  # Fill the cell with 8 if it's not background and has a background neighbor
  return O
 
16.75, tensor(1.1066), Description: Replace all '1's in the grid with '8's, except for '1's that are the only cell in their object (i.e., single-colored squares). 
:: def difbecffdiefeabdibaaaeaaigfhigfb(I):
  # Find objects, excluding background and considering diagonals.
  x1 = objects(I, False, True, True) 
  # Isolate objects with only one cell.
  x2 = sizefilter(x1, 1) 
  # Combine the indices of single-cell objects.
  x3 = merge(apply(toindices, x2))
  # Replace '1's with '8's in the input grid, except for the single-cell objects.
  O = fill(replace(I, 1, 8), 1, x3)
  return O
 
17.0, tensor(1.0961), Description: Replace all objects in the grid that are colored '1' with '8's. The rest of the grid should remain unchanged. 
:: def jabdeadacddbejacahaiecbhdheecjjf(I):
    x1 = objects(I, T, F, T)  # Identify objects (connected regions)
    x2 = colorfilter(x1, 1)    # Filter objects with color 1
    O = fill(I, 8, merge(x2)) # Recolor the filtered objects to 8
    return O
 
25.0, tensor(1.0607), Description: Replace all '1's that are on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def bcbcdafdjfhfeccfiddcbbaedejcfcjg(I):
  h, w = len(I), len(I[0])
  border_indices = set()
  # Get indices of all border cells
  for i in range(h):
    border_indices.update({(i, 0), (i, w - 1)})
  for j in range(1, w - 1):
    border_indices.update({(0, j), (h - 1, j)})
  # Get indices of all '1's in the grid
  ones_indices = ofcolor(I, 1)
  # Find the intersection of border indices and '1' indices
  target_indices = border_indices & ones_indices
  # Replace the '1's at the target indices with '8's
  O = fill(I, 8, target_indices)
  return O
 
40.75, tensor(1.5026), Description: Replace the cell to the left of each '1' in the grid with '8', except for '1's that are already adjacent to an '8'. The rest of the grid should remain unchanged. 
:: def dadaiibcffhjefbfbbhajcgfaaeceeee(I):
  # Find indices of all '1's
  ones_indices = ofcolor(I, ONE)
  # Shift each index one position to the left
  shifted_indices = apply(lambda x: (x[0], x[1]-1), ones_indices)
  # Filter out shifted indices that are out of bounds (j < 0)
  valid_indices = sfilter(shifted_indices, lambda x: x[1] >= 0)
  # Fill '8' at the valid indices, only if the original cell is not '8'
  O = underfill(I, EIGHT, valid_indices)
  return O
 
36.25, tensor(1.5026), Description: Replace the cell to the left of each '1' in the grid with '8', except for '1's that are already adjacent to an '8'. The rest of the grid should remain unchanged. 
:: def feaaddffgdjfeadcabaaadbicabcddbg(I):
  O = I  # Start with a copy of the input grid
  h, w = len(I), len(I[0])  # Get grid dimensions
  for i in range(h):
    for j in range(w):
      # If current cell is '1' and not at the beginning of the row
      if I[i][j] == ONE and j > 0:
        # If the cell to the left is not '8', replace it with '8'
        if O[i][j-1] != EIGHT:
          O = fill(O, EIGHT, {(i, j-1)})
  return O
 
48.25, tensor(1.0608), Description: Replace all digits adjacent to '1' that are within the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def cajcgcedfcceeehaababbbfiahabggba(I):
  # Find all objects in the grid, excluding background
  objs = objects(I, True, False, True)
  
  # Identify objects touching the border
  border_objs = sfilter(objs, lambda obj: bordering(obj, I))
  
  # Create a set of target indices for replacement
  target_indices = frozenset()
  for obj in border_objs:
    for v, (i, j) in obj:
      if v == 1:
        target_indices = target_indices | dneighbors((i, j))
  
  # Fill the target indices with '8'
  O = fill(I, 8, target_indices)
  return O
 
33.75, tensor(1.0608), Description: Replace all digits adjacent to '1' that are on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def bieaeaehhficehjfjigggcgfbffefbfc(I):
  h, w = len(I), len(I[0])
  O = I
  for i in range(h):
    for j in range(w):
      if I[i][j] == 1 and ((i == 0 or i == h-1) or (j == 0 or j == w-1)):
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
          ni, nj = i+di, j+dj
          if 0 <= ni < h and 0 <= nj < w:
            O = fill(O, 8, {(ni, nj)})
  return O
 
126.5, tensor(1.1065), Description: Replace all '1's in the grid with '8's, except for '1's that are the only cell in their object (i.e., single-colored squares). Then, replace all '9's with '8's. Finally, restore the original color of the single-colored squares. 
:: def gcgbcebdfgbdecjbjjibaijheaahjgah(I):
    # Find single-cell objects
    x1 = objects(I, True, False, True)
    x2 = sizefilter(x1, 1)
    # Create a mask by filling the areas of single-cell objects with a unique value
    x3 = fill(I, 7, merge(apply(toindices, x2)))
    # Recolor everything to 8
    x4 = replace(x3, 1, 8)
    x5 = replace(x4, 9, 8)
    x6 = replace(x5, 7, 1)
    # Use the mask to restore the original color of single-cell objects
    O = x6
    return O
 
31.0, tensor(1.0607), Description: Replace all '1's that are on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def ccbeaegfbfcjeeacjhbccggfaedhccfd(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1 and ((i == 0 or i == len(I) - 1) or (j == 0 or j == len(I[0]) - 1)):
        # Found a border '1', now fill its neighbors
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] != 1:
            I = fill(I, 8, {(ni, nj)})
  return I
 
44.5, tensor(1.1476), Description: Replace the cell directly above each '1' in the grid with '8', except for '1's that are already adjacent to an '8'. The rest of the grid should remain unchanged. 
:: def abeabcccbdbaebfejfjcdfjjaiaefifg(I):
  for i in range(1, len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        if 0 <= i - 1 and I[i - 1][j] == mostcolor(I):
          I = fill(I, EIGHT, {(i - 1, j)})
  return I
 
132.5, tensor(1.1066), Description: Replace all '1's that are part of a connected component larger than 1 cell with '8's. The rest of the grid should remain unchanged. 
:: def gbcbjbajfcabejgbifdafcbcddececcc(I):
  # Create a mask of larger connected components
  mask = fill(canvas(0, shape(I)), 1, merge(apply(toindices, sfilter(objects(I, True, False, True), lambda obj: size(obj) > 1))))
  # Combine the input grid with the mask, replacing '1's in the mask's area with '8's
  O = cellwise(I, mask, 8)
  return O
 
11.25, tensor(1.0608), Description: Replace all '1's that are not on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def ddjadhfdcgccebfjjediddgeeiejhijf(I):
  for obj in objects(I, True, False, True): 
    if color(obj) == 1 and not bordering(obj, I):
      I = fill(I, 8, obj)
  return I
 
40.75, tensor(1.1476), Description: Replace the cell directly above each '1' in the grid with '8', except for '1's that are already adjacent to an '8'. The rest of the grid should remain unchanged. 
:: def ahgfbffchiacegccicaebehebeehbedd(I):
  return fill(I, EIGHT, frozenset((i-1,j) for i, j in ofcolor(I, ONE) if i > 0))
 
16.75, tensor(1.1480), Description: Replace all '1's in the grid with '8's, except for '1's that are the only cell in their object (i.e., single-colored squares). Then, replace all '9's with '8's. Finally, restore the original color of the single-colored squares. 
:: def jfhffifacidjeceejcagbfdchcgfefcj(I):
  def is_valid_up(loc):
    i, j = loc
    return 0 <= i-1 < len(I) and I[i][j] == ONE
  return fill(I, EIGHT, sfilter(asindices(I), is_valid_up)) 
 
96.5, tensor(0.0249), Description: Replace all digits adjacent to '1' that are the same color as the background with '8' in a grid. The rest of the grid should remain unchanged. 
:: def fabahddihbjceeafjdfehbbeggcdfjce(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, True, False, True):
    if color(obj) == 1:
      neighbors = mapply(dneighbors, toindices(obj))
      valid_neighbors = sfilter(neighbors, lambda x: 0 <= x[0] < len(I) and 0 <= x[1] < len(I[0]) and index(I, x) == bg)
      O = paint(O, recolor(8, valid_neighbors))
  return O
 
27.75, tensor(0.0184), Description: Replace the outline of the object colored '1' with '8's. The rest of the grid should remain unchanged. 
:: def decfdccdaiefefbeihheafaccbbegdej(I):
  target_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 1)
  outline = delta(toindices(target_obj))
  return fill(I, 8, outline)
 
22.75, tensor(1.1065), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to a '9'. The rest of the grid should remain unchanged. 
:: def fihcdjibhceeebdaicebgaejcgabaedi(I):
  def is_adjacent_to_nine(loc: IntegerTuple) -> Boolean:
    return any(index(I, add(loc, d)) == NINE for d in {UP, DOWN, LEFT, RIGHT})
  
  ones = ofcolor(I, ONE)
  filtered_ones = sfilter(ones, is_adjacent_to_nine)
  O = paint(replace(I, ONE, EIGHT), toobject(filtered_ones, I))
  return O
 
37.5, tensor(1.1476), Description: Replace the cell directly above each '1' in the grid with '8', except for '1's that are already adjacent to an '8'. The rest of the grid should remain unchanged. 
:: def chedcedehfdfeedaadddcbhfjdiadcic(I):
  h, w = len(I), len(I[0])
  return tuple(tuple(8 if 0 < i and I[i-1][j] == 1 else I[i][j] for j in range(w)) for i in range(h))
 
39.25, tensor(0.0184), Description: Replace the outline of the object colored '1' with '8's. The rest of the grid should remain unchanged. 
:: def dahcacfcdbjdeaefieaccgdhhdjigdah(I):
  target = extract(objects(I, True, False, True), lambda o: color(o) == 1)
  shifted_right = shift(target, RIGHT)
  shifted_down = shift(target, DOWN)
  shifted_left = shift(target, LEFT)
  shifted_up = shift(target, UP)
  outline = (toindices(shifted_right) | toindices(shifted_down) | 
             toindices(shifted_left) | toindices(shifted_up)) - toindices(target)
  return fill(I, 8, outline)
 
16.75, tensor(1.0961), Description: Replace all objects in the grid that have more than one cell with '8's. The rest of the grid should remain unchanged. 
:: def cdbjebibbbfjeiagjeabfacidhdbfhcd(I):
  x1 = objects(I, T, F, T)
  x2 = sfilter(x1, lambda x: size(x) > 1)
  x3 = merge(x2)
  O = fill(I, EIGHT, x3)
  return O
 
126.75, tensor(1.0961), Description: Replace all connected components (objects) in the grid that have more than one cell with '8's. The rest of the grid should remain unchanged. 
:: def gibefeddcfhbejadabadihdcjjhicfda(I):
  x1 = partition(I)
  x2 = mfilter(x1, lambda x: size(x) > 1)
  O = fill(I, EIGHT, x2)
  return O
 
15.25, tensor(1.0607), Description: Replace all objects in the grid that are colored '1' and are not touching the border with '8's. The rest of the grid should remain unchanged. 
:: def aedjhacdbdccebeiaidaecfbbieiejjd(I):
  """Finds objects of '1' not touching the border and recolors them to '8'."""
  objs = objects(I, True, False, False)  # Find all objects of '1'
  non_border_objs = sfilter(objs, lambda obj: not bordering(toindices(obj), I))  # Filter for non-border objects
  recolored_objs = apply(lambda obj: recolor(8, obj), non_border_objs)  # Recolor to '8'
  O = I  # Initialize output grid
  for obj in recolored_objs:
    O = paint(O, obj)  # Paint each object onto the output grid
  return O
 
19.25, tensor(1.0607), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should be filled with the background color. 
:: def dbfgcbafacffedacjaadgdcabfdcbddj(I):
  """Iterates through the grid, recoloring '1's not on the border to '8'."""
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))  # Create an empty grid
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if I[i][j] == 1:  # Check for '1'
        O = paint(O, {(8, (i, j))})  # Recolor to '8'
      else:
        O = paint(O, {(I[i][j], (i, j))}) # Keep original color
  return O 
 
17.0, tensor(1.0608), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def bjfdhbibfiadebjgifddgfadfahahfbf(I):
  """Identifies and recolors non-border cells of value '1' to '8'."""
  indices = asindices(I)
  border = outbox(indices)  # Find border indices
  non_border_indices = indices - border # Get non-border indices
  O = I
  for i, j in non_border_indices:
    if I[i][j] == 1:
      O = paint(O, {(8, (i, j))})  # Recolor '1' to '8'
  return O
 
20.5, tensor(1.1478), Description: Replace all '1's in the grid that are directly below a '9' with '8's. The rest of the grid should remain unchanged. 
:: def ffaefhefeibgeaabaagdababadgibaeb(I):
  h = height(I)
  w = width(I)
  for i in range(h-1):
    for j in range(w):
      if I[i][j] == NINE and I[i+1][j] == ONE:
        I = fill(I, EIGHT, {(i+1,j)})
  return I
 
20.5, tensor(1.1065), Description: Replace all '1's in the grid with '8's, except for '1's that are directly above or below a '9'. The rest of the grid should remain unchanged. 
:: def jccbhiijbdfcehfeijdgffbfffcbcecc(I):
  # Replace '1's not adjacent to '9' vertically with '8's
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE and not ((i > 0 and I[i - 1][j] == NINE) or (i < len(I) - 1 and I[i + 1][j] == NINE)):
        O = fill(O, EIGHT, {(i, j)})
  return O
 
125.5, tensor(1.0961), Description: Replace all objects in the grid that have more than one cell with '8's. The rest of the grid should remain unchanged. 
:: def jicacbcjdfafedfcibefahaffbabeafa(I):
  x1 = objects(I, T, F, F)  # Extract all objects, including background
  x2 = sfilter(x1, lambda x: size(x) > 1)  # Filter for objects larger than one cell
  x3 = mapply(lambda x: toindices(x), x2)  # Extract indices of larger objects
  O = fill(I, EIGHT, x3)  # Fill the indices of larger objects with '8'
  return O
 
18.75, tensor(1.1480), Description: Replace all '1's in the grid with '8's, except for '1's that are directly above another '1'. The rest of the grid should remain unchanged. 
:: def hcigdbicaccheegfbedjbhjeebhgfcaj(I):
  def condition(x):
    return index(I, x) == ONE and 0 <= x[0] + 1 < len(I) and index(I, (x[0] + 1, x[1])) == ONE
  return fill(I, EIGHT, sfilter(asindices(I), condition))
 
18.75, tensor(1.1480), Description: Replace all '1's in the grid with '8's, except for '1's that are directly above another '1'. The rest of the grid should remain unchanged. 
:: def cecebgdhhgggeaejihiiidbfccfjjeaf(I):
  def is_one_above(loc):
    i, j = loc
    return 0 <= i-1 < len(I) and I[i-1][j] == ONE 
  ones = ofcolor(I, ONE)
  return fill(I, EIGHT, sfilter(ones, is_one_above))
 
23.25, tensor(0.0018), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to a '9'. The rest of the grid should remain unchanged. 
:: def bjdjcehjfaijecjcibhjhdajadiaeeef(I):
  h, w = len(I), len(I[0])
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if I[i][j] == 1 and all(I[i + di][j + dj] != 9 for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        I = fill(I, 8, {(i, j)})
  return I
 
9.25, tensor(0.0020), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def fidahcffbdjgedejidaddbeddbhehdbc(grid):
  objs = objects(grid, True, False, True)
  for obj in objs:
    if color(obj) == 1:
      indices = toindices(obj)
      if all(0 not in index and len(grid) - 1 not in index and 0 not in (j for i, j in indices) and len(grid[0]) - 1 not in (j for i, j in indices) for index in zip(*indices)):
        grid = fill(grid, 8, indices)
  return grid
 
17.0, tensor(1.0496), Description: Replace all objects in the grid that are colored '1' with '8's. The rest of the grid should be filled with the background color. 
:: def iejedajjgadfedacjfaffbaadfcjffeb(I):
    O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
    for obj in objects(I, T, F, T):
        if color(obj) == ONE:
            O = paint(O, recolor(EIGHT, obj))
        else:
            O = paint(O, obj)
    return O
 
16.75, tensor(1.0497), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to a '9'. The rest of the grid should remain unchanged. 
:: def ccffhagfcbhfeajgjdjbheicidacciia(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        adjacent_values = [index(I, (i + di, j + dj)) for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if 0 <= i + di < height(I) and 0 <= j + dj < width(I)]
        if any(v != NINE for v in adjacent_values):
          O = fill(O, EIGHT, {(i, j)})
  return O
 
63.0, tensor(0.0086), Description: Replace the inner outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The inner outline is defined as the background cells that are directly adjacent to the object's cells. 
:: def fbadfhebaihbedchbaadfaeeehccacae(I):
  bg = mostcolor(I) 
  O = canvas(bg, shape(I)) 
  for obj in objects(I, True, False, True):
    outline = delta(toindices(obj))
    inner_outline = sfilter(outline, lambda loc: any(n in toindices(obj) for n in dneighbors(loc)) and index(I, loc) == bg)
    O = paint(O, recolor(8, inner_outline))
  return O 
 
22.5, tensor(0.0151), Description: Replace all background cells that are adjacent to a non-background cell with '8's. The rest of the grid should remain unchanged. 
:: def jdddacabfjedeabgbbdhdefdbajagihg(I):
  O = I
  bg = mostcolor(I)
  for obj in objects(I, True, False, True):
    for c in toindices(obj):
      if index(I, c) == bg and any(index(I, n) != bg for n in dneighbors(c)):
        O = fill(O, 8, {c})
  return O
 
79.5, tensor(0.0069), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The outline is defined as the background cells that are directly adjacent to the object's cells. 
:: def abecediadecfeeffaehefbbfcibbiaed(I):
    bg = mostcolor(I)
    obj_indices = mapply(toindices, objects(I, True, False, True))
    outline = sfilter(asindices(I), lambda loc: index(I, loc) == bg and any(n in obj_indices for n in dneighbors(loc)))
    return fill(I, 8, outline)
 
67.25, tensor(0.0151), Description: Replace all background cells that are adjacent to a non-background cell with '8's. The rest of the grid should remain unchanged. 
:: def hddibdggbgbfehcdjdcgbdbjfajedbha(I):
    O = I
    bg = mostcolor(I)
    for i in range(1, len(I) - 1):
      for j in range(1, len(I[0]) - 1):
        if I[i][j] == bg and (I[i-1][j] != bg or I[i+1][j] != bg or I[i][j-1] != bg or I[i][j+1] != bg):
          O = fill(O, 8, {(i, j)})
    return O
 
17.0, tensor(0.0996), Description: Replace all '1's in the grid with '8's. 
:: def aidcahedgabfebddbbigbgbihbiaefcd(I):
  O = replace(I, ONE, EIGHT)
  return O
 
79.5, tensor(0.0033), Description: Replace all '9's in the grid with '8's if they are adjacent to a '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def bejedgiehjabecgfjchbciihifddcgcf(I):
  return tuple(
      tuple(
          8 if (
              (i > 0 and I[i-1][j] == 1) or  # Check above
              (i < len(I)-1 and I[i+1][j] == 1) or  # Check below
              (j > 0 and I[i][j-1] == 1) or  # Check left
              (j < len(I[0])-1 and I[i][j+1] == 1)  # Check right
          ) and I[i][j] == 9 else I[i][j] 
          for j in range(len(I[0]))
      ) 
      for i in range(len(I))
  )
 
22.5, tensor(0.0033), Description: Replace all '9's in the grid with '8's if they are adjacent to a '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def bbbdgbegffhbeacajdaicfgeeiecaeab(I):
  ones = objects(I, True, False, True)
  nines = objects(I, True, False, True)
  affected = frozenset()
  for one in ones:
    for nine in nines:
      if color(one) == 1 and color(nine) == 9 and adjacent(one, nine):
        affected = affected | nine
  return fill(I, 8, toindices(affected))
 
67.25, tensor(0.0033), Description: Replace all '9's in the grid with '8's if they are adjacent to a '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def beghgfdbgjcdecgbiffecfdaegddhfii(I):
  return paint(I, 
               frozenset(
                   (8, (i,j)) 
                   for i in range(1, len(I)-1) 
                   for j in range(1, len(I[0])-1) 
                   if (I[i][j] == 9 and (I[i-1][j] == 1 or I[i+1][j] == 1 or I[i][j-1] == 1 or I[i][j+1] == 1))
               )) 
 
132.25, tensor(1.0496), Description: Replace all cells in the grid that are not '1' with '8's. 
:: def ddjdjecbaecdeddjadbafheffdhadbfe(I):
    dummy_grid = canvas(ONE, shape(I))  # Create a grid filled with '1's
    return cellwise(I, dummy_grid, EIGHT) # Replace non-matching cells with '8's
 
16.75, tensor(0.0156), Description: Replace all cells in the grid that are part of an object and have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def bfcgdfgidcbhecebahfgedcefbcigged(I):
  bg = mostcolor(I) # Identify the background color
  O = paint(canvas(bg, shape(I)), asobject(I)) # Initialize output with the input grid
  for obj in objects(I, True, False, True): # Loop through objects, excluding background
    for c in toindices(obj):
      if any(index(I, n) == bg for n in dneighbors(c)):
        O = fill(O, 8, {c}) # If a cell in the object has a background neighbor, fill it with 8
  return O
 
39.5, tensor(0.0070), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The outline is defined as the cells that are directly adjacent to the object's cells. 
:: def iefbcgeafcabeecbbdbcfeeejffgabdf(I):
  bg = mostcolor(I) # Find the background color
  return paint(canvas(bg, shape(I)),  # Create a blank canvas 
               merge(apply(lambda obj: recolor(8, intersection(toindices(obj),  # For each object, recolor intersection of object and
                                                           delta(toindices(obj)))), objects(I, True, False, True)))) #  its delta (outer boundary) with 8
 
17.75, tensor(0.0154), Description: Replace all non-background cells that have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def efbeahdifbbcecgeadjeddejecbffjeg(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for x, y in product(range(len(I)), range(len(I[0]))):
    if I[x][y] != bg and any(index(I,(x + dx, y + dy)) == bg for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
      O = fill(O, 8, {(x, y)})
  return O
 
18.5, tensor(0.0034), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. 
:: def bbcahifdbiaaeecajefhccaaaffjfddf(I):
  return paint(I, 
               frozenset(
                   (8, (i, j))
                   for obj in objects(I, True, False, True) 
                   for (i, j) in toindices(obj)
                   if any(n in delta(obj) for n in dneighbors((i, j)))
               ))
 
16.25, tensor(0.0038), Description: Replace all cells in the grid that are part of an object and have a neighbor of a different color with '8's. The rest of the grid should remain unchanged. 
:: def bbiffafgfecheidfbhhdaedeeaedaadf(I):
  return fill(I, 8, 
              frozenset(
                (i, j)
                for obj in objects(I, True, False, True)
                for (i, j) in toindices(obj) 
                if any(index(I, n) != index(I, (i, j)) for n in dneighbors((i, j)))
              ))
 
39.5, tensor(0.0042), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. The background of the grid should be the same color as the original background. 
:: def fhacdbehbdijedadbfjheefdjfefbeaa(I):
  return cellwise(I, 
                  paint(canvas(mostcolor(I), shape(I)), 
                        frozenset(
                          (8, (i, j)) 
                          for obj in objects(I, True, False, True) 
                          for (i, j) in toindices(obj) 
                          if any(n in delta(obj) for n in dneighbors((i, j))))),
                 I[0][0])
 
73.75, tensor(0.0033), Description: Replace all cells in the grid with '8's if they have a neighbor of a different color (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def bddacjfddjdfecbfijfebfaajhacfeba(I):
  return tuple(
    tuple(
        8 if (i > 0 and I[i - 1][j] != I[i][j]) or
           (i < len(I) - 1 and I[i + 1][j] != I[i][j]) or
           (j > 0 and I[i][j - 1] != I[i][j]) or
           (j < len(I[0]) - 1 and I[i][j + 1] != I[i][j]) 
           else I[i][j]
        for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
18.0, tensor(0.0019), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to another '1' diagonally. The rest of the grid should remain unchanged. 
:: def dfcdijjgfiieejebbcfjbfjcjidigagd(grid):
  h, w = len(grid), len(grid[0])
  for i in range(h):
    for j in range(w):
      if grid[i][j] == 1 and 1 < i < h - 1 and 1 < j < w - 1:
        if all(grid[x][y] != 1 for x, y in dneighbors((i,j)) - {(i-1,j),(i+1,j),(i,j-1),(i,j+1)} for _ in range(1)):
          grid = fill(grid, 8, {(i, j)})
  return grid
 
17.0, tensor(0.0020), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def ebebebchcffheabgbfcdbbeiedhcjhii(grid):
  non_bordering_ones = asindices(grid) - outbox(asindices(grid))
  return paint(grid, recolor(8, toobject(intersection(non_bordering_ones, ofcolor(grid, 1)), grid)))
 
17.5, tensor(0.0020), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def jfcaeaaiadcaedibbfcaagbcdfdjcebc(grid):
  for obj in objects(grid, True, False, True):
    if color(obj) == 1:
      if all(index(grid, loc) != 1 for loc in outbox(obj)):
        grid = paint(grid, recolor(8, obj))
  return grid
 
23.75, tensor(0.0156), Description: Replace all cells in the grid that are part of an object and have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def dbbdbifgeebeeabdafdcegbegchdahja(I):
  bg = mostcolor(I) # Identify the background color
  O = paint(canvas(bg, shape(I)), asobject(I)) # Initialize output with the input grid
  for obj in objects(I, True, False, True): # Loop through objects, excluding background
    perimeter_cells = toindices(obj) & (inbox(obj) | outbox(obj)) # Find perimeter cells
    for c in perimeter_cells:
      if any(index(I, n) == bg for n in dneighbors(c)):
        O = fill(O, 8, {c}) # If a cell has a background neighbor, fill it with 8
  return O
 
35.5, tensor(0.0070), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The outline is defined as the cells that are directly adjacent to the object's cells. 
:: def ejejifccdjcjeddeahhdffajccecfigh(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, True):
    O = underpaint(O, recolor(8, toindices(obj) & (inbox(obj) | outbox(obj))))
  return O
 
23.75, tensor(0.0997), Description: Replace all horizontal lines of '1's in the grid with '8's. The rest of the grid should remain unchanged. 
:: def eedbibbeiidfedecaeaefhdcchidehjd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)  # Extract connected objects
  filtered_objs = sfilter(objs, lambda obj: hline(obj) and color(obj) == ONE) # Filter for horizontal lines of '1'
  O = I 
  for obj in filtered_objs:
    O = paint(O, recolor(EIGHT, obj)) # Recolor the filtered objects
  return O
 
17.25, tensor(0.1001), Description: Replace all consecutive '1's in a row with '8's. The rest of the grid should remain unchanged. 
:: def gdfjejfbeegaeahejfabehbbbaiahaca(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])-1):
      if I[i][j] == ONE and I[i][j+1] == ONE:
        O = paint(O, {(EIGHT, (i, j)), (EIGHT, (i, j+1))}) # Replace consecutive '1's in a row with '8's
  return O
 
18.0, tensor(0.0997), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. The rest of the grid should remain unchanged. 
:: def bhcccbaddeaieicbagdfjbaadfbhfaee(I):
  rows = tuple(row for row in I) # Get rows of the grid
  modified_rows = tuple(
      tuple(EIGHT if j > 0 and row[j-1] == ONE and v == ONE else v for j, v in enumerate(row)) 
      for row in rows
  ) # Replace '1's that have a '1' to their left with '8's
  O = modified_rows
  return O
 
28.25, tensor(0.0035), Description: Replace all cells in the grid that are part of an object and are touching the border with '8's. The rest of the grid should remain unchanged. 
:: def jaacheaiffggegjdihbadagbfgdfdiac(I):
  return paint(I, 
               frozenset(
                   (8, (i, j))
                   for obj in objects(I, True, False, True)
                   if bordering(obj, I) 
                   for (i, j) in toindices(obj)
               )) 
 
16.75, tensor(0.0033), Description: Replace all '1's in the grid with '8's if they are adjacent to a '9' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def bfjbabgicidjeagbihddceceafechdia(I):
  return tuple(
      tuple(
          8 if I[i][j] == 1 and any(index(I, (i + di, j + dj)) == 9 for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)))
          else I[i][j] 
          for j in range(len(I[0]))
      ) for i in range(len(I))
  )
 
22.5, tensor(0.0018), Description: Replace all '1's in the grid with '8's, except for '1's that are surrounded by '9's (horizontally and vertically). The rest of the grid should remain unchanged. 
:: def bihbcddeccbceffdafgceachcaifebeb(grid):
  h, w = len(grid), len(grid[0])
  border = set()
  for i in range(h):
    for j in range(w):
      if grid[i][j] == 9:
        border.add((i, j))
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if grid[i][j] == 1 and is_surrounded(grid, (i, j), border):
        grid = fill(grid, 8, {(i, j)})
  return grid
 
38.5, tensor(0.0024), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. Then, replace all '9's in the grid with '8's. The rest of the grid should remain unchanged. 
:: def ebdcfaaiaeeaebebbbhhaddbajidcecc(grid):
  grid = expand_border(grid, 9)
  grid = expand_border(grid, 8) 
  return grid
 
16.75, tensor(0.0996), Description: Replace all horizontal lines of '1's in the grid with '8's. The rest of the grid should be filled with '9's. 
:: def fjhgeajadjfeegcabiadaeedidbdhiai(I):
  O = canvas(NINE, shape(I))
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  for obj in objs:
    if color(obj) == ONE and width(obj) > 1:
      O = paint(O, recolor(EIGHT, obj))
    else:
      O = paint(O, obj)
  return O
 
23.0, tensor(0.1001), Description: Replace all groups of consecutive '1's in a row with '8's. The rest of the grid should be filled with '9's. 
:: def hacfeciehafdeddcbchegcadidgdfabg(I):
  O = canvas(NINE, shape(I))
  for i, row in enumerate(I):
    j = 0
    while j < len(row):
      if row[j] == ONE:
        group_end = j + 1
        while group_end < len(row) and row[group_end] == ONE:
          group_end += 1
        if group_end - j > 1:
          O = paint(O, {(EIGHT, (i, k)) for k in range(j, group_end)})
        j = group_end
      else:
        j += 1
  return O
 
25.0, tensor(0.0033), Description: Replace all '1's in the grid with '8's if they are on the border of the grid. The rest of the grid should remain unchanged. 
:: def fffcdebcffcjeehgjbibgcfcijbejbee(I):
  return tuple(
      tuple(
          8 if I[i][j] == 1 and (i == 0 or i == len(I)-1 or j == 0 or j == len(I[0])-1)
          else I[i][j]
          for j in range(len(I[0])))
      for i in range(len(I))
  )
 
14.5, tensor(0.0020), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def hcaaiebbhijfeijcjcebcafedaccafib(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
          8 if 0 < i < h - 1 and 0 < j < w - 1 and v == 1 else v 
          for j, v in enumerate(row)
      ) 
      for i, row in enumerate(grid)
  )
 
17.0, tensor(0.0020), Description: Replace all '1's in the grid with '8's, except for '1's that are on the border of the grid. The rest of the grid should remain unchanged. 
:: def egdediacfeaeejfjabjcibchejdieabh(grid):
  return paint(grid, recolor(8, toobject(sfilter(ofcolor(grid, 1), lambda loc: all(0 < i < len(grid) - 1 and 0 < j < len(grid[0]) - 1 for i, j in neighbors(loc))), grid)))
 
18.5, tensor(0.0070), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The outline is defined as the cells that are directly adjacent to the object's cells. 
:: def cgafjabcgjageaaeageebhiccibdghjb(I):
  bg = mostcolor(I)
  O = paint(canvas(bg, shape(I)), asobject(I))
  for obj in objects(I, True, False, True):
    obj_indices = toindices(obj)
    outline = frozenset(c for c in obj_indices if any(n in delta(obj_indices) for n in dneighbors(c)))
    O = fill(O, 8, outline) 
  return O
 
17.0, tensor(0.0156), Description: Replace all cells in the grid that are part of an object and have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def cfacaeefafhcefceajchbafcefbjdedd(I):
  bg = mostcolor(I)
  O = I
  for obj in objects(I, True, False, True):
    for c in toindices(obj):
      if any(index(I, n) == bg for n in dneighbors(c)):
        O = replace(O, index(I, c), 8)
  return O
 
18.0, tensor(0.0998), Description: Replace all '1's in the grid with '8's, except for '1's that are the last '1' in their row. The rest of the grid should remain unchanged. 
:: def cbcffabfghgaecdcieiefecbabjbeaaj(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == ONE:
      for (i, j) in toindices(obj):
        if j < len(I[0]) - 1 and (ONE, (i, j + 1)) in obj:
          O = paint(O, {(EIGHT, (i, j))}) 
  return O
 
73.75, tensor(0.0037), Description: Replace all cells adjacent to objects colored '1' with '8's. The rest of the grid should remain unchanged. 
:: def fedhajaadbafeihabhajeedcbdaebffe(I):
  target_color = 1
  recolor_value = 8
  target_objects = frozenset(obj for obj in objects(I, True, False, True) if color(obj) == target_color)
  adjacent_cells = frozenset(
      (i, j)
      for obj in target_objects
      for (a, b) in toindices(obj)
      for (i, j) in dneighbors((a, b))
  )
  return fill(I, recolor_value, adjacent_cells)
 
132.25, tensor(0.0154), Description: Replace all non-background cells that have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def hafdcfjjcjddeehajeibheebjfhajjfc(I):
  return cellwise(I, canvas(1, shape(I)), lambda a, b: 8 if a != mostcolor(I) and any(index(I, n) == mostcolor(I) for n in dneighbors((a, b))) else a)
 
18.25, tensor(0.0998), Description: Replace all '1's in the grid with '8's, except for the rightmost '1' in each row. The rest of the grid should be filled with '9's. 
:: def bfacffbidajeejfejdadbbacecccdghe(I):
  O = canvas(NINE, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == ONE:
      for (i, j) in toindices(obj):
        if j == rightmost(obj):
          O = paint(O, {(ONE, (i, j))})
        else:
          O = paint(O, {(EIGHT, (i, j))})
  return O
 
13.25, tensor(0.0999), Description: Replace all '1's in the grid with '8's, except for the rightmost '1' in each row. The rest of the grid should remain unchanged. 
:: def jgcjfcjbaifaefbejgbedefdfggjgccd(I):
  O = I
  for i, row in enumerate(I):
    ones_indices = frozenset((i, j) for j, v in enumerate(row) if v == ONE)
    if ones_indices:
      O = paint(O, recolor(EIGHT, ones_indices - { (i, max(j for i,j in ones_indices)) }))
  return O
 
16.75, tensor(0.0999), Description: Replace all '1's in the grid with '8's, except for the rightmost '1' in each row. The rest of the grid should remain unchanged. 
:: def gicbbfieebgcecgejaejebfhdeeegjcf(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == ONE:
      for i in range(uppermost(obj), lowermost(obj)+1):
        row_obj = frozenset((v, (a, b)) for v, (a, b) in obj if a == i)
        if len(row_obj) > 1:
          O = paint(O, recolor(EIGHT, toindices(row_obj) - {(i, rightmost(row_obj))}))
  return O
 
19.25, tensor(0.0035), Description: Replace all non-'9' cells in the grid with '8's if they are within a 3x3 subgrid that contains at least one '9'. The rest of the grid should remain unchanged. 
:: def ahcaagacccidefjjiccfgdffcajiaidd(I):
    output = canvas(9, shape(I))
    for i in range(1, len(I) - 1):
        for j in range(1, len(I[0]) - 1):
            if I[i][j] != 9:
                sub = crop(I, (i-1, j-1), (3, 3))
                if any(v == 9 for r in sub for v in r):
                    output = paint(output, {(8, (i, j))})
                else:
                    output = paint(output, {(I[i][j], (i, j))})
    return output
 
22.75, tensor(1.0497), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to a '9'. The rest of the grid should remain unchanged. 
:: def jdcdfgdceeagedjbijiahfchbfbaadge(I):
  O = I
  ones = ofcolor(I, ONE)
  for loc in ones:
    if all(index(I, n) != NINE for n in dneighbors(loc)):
        O = fill(O, EIGHT, {loc})
  return O
 
39.5, tensor(0.0154), Description: Replace all non-background cells that have a background neighbor with '8's. The rest of the grid should remain unchanged. 
:: def dbdeadgeddccededafadcbhbfddbbgcb(I):
  bg = mostcolor(I)
  return cellwise(I, canvas(bg, shape(I)), lambda a, b: 8 if a != bg and any(n in ofcolor(I, bg) for n in dneighbors((a, b))) else a)
 
76.75, tensor(0.0997), Description: Replace all horizontal lines of '1's in the grid with '8's. The rest of the grid should remain unchanged. 
:: def eefejebbgabeefceihcbeebaiadhbefe(I):
  objs = objects(I, False, False, False)
  for obj in objs:
    if color(obj) == 1 and width(obj) > 1:
      I = paint(I, recolor(8, obj))
  return I
 
16.75, tensor(0.0035), Description: Replace all non-'9' cells in the grid with '8's if they are adjacent to a '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def icdhfghaaebaeebdjcgebggacabdbhbh(I):
  return tuple(
      tuple(
          8 if I[i][j] != 9 and any(index(I, (i + di, j + dj)) == 1 for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1))) 
          else I[i][j]
          for j in range(len(I[0]))
      ) for i in range(len(I))
  )
 
21.75, tensor(0.0017), Description: Replace all objects in the grid that are colored '1' and are not touching the border with '8's. The rest of the grid should be filled with '9's. 
:: def ffbecdchcbiaedijbfffcbdechjbdihi(grid):
    h, w = len(grid), len(grid[0])
    return paint(canvas(9, (h, w)), 
                 recolor(8, 
                         mfilter(objects(grid, True, False, True), 
                                 lambda obj: color(obj) == 1 and not bordering(obj, grid))))
 
125.75, tensor(0.0151), Description: Replace all cells in the grid that are adjacent to a background cell with '8's. The rest of the grid should remain unchanged. 
:: def bccebbhigehaedabjedeadjddbbgeeja(I):
  bg = mostcolor(I)
  outline = frozenset()
  for i, j in ofcolor(I, bg):
    outline |= {(i+di, j+dj) for di, dj in [(0,1),(0,-1),(1,0),(-1,0),(1,1),(1,-1),(-1,1),(-1,-1)]}
  return paint(I, recolor(8, outline & asindices(I)))
 
17.0, tensor(0.0035), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to a '9'. The rest of the grid should remain unchanged. 
:: def cbdfchdhfajfecbcbefebaedddbedded(I):
  target_cells = set((i, j) for obj in objects(I, True, False, False) if color(obj) == 1 for _, (i, j) in obj)
  return tuple(
      tuple(
          8 if (i, j) in target_cells and cell != 9
          else cell
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
30.0, tensor(0.0020), Description: Replace all cells in the grid with '8's if they are within a 3x3 subgrid that contains at least one '1'. The rest of the grid should remain unchanged. 
:: def gaffibffeifieghcbafccibfdidbedgb(grid):
  return tuple(
      tuple(
          8 if any([grid[k][j] == 1 for k in range(max(0, i-1), min(height(grid), i+2))])
          and any([grid[i][l] == 1 for l in range(max(0, j-1), min(width(grid), j+2))])
          else v for j, v in enumerate(row)
      ) for i, row in enumerate(grid)
  )
 
11.75, tensor(0.0996), Description: Replace all '1's in the grid with '8's, except for '1's that have more than one adjacent '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def jdhdehbbheebedibafddjhhbbabjgece(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == ONE:
      for (i, j) in toindices(obj):
        if len({(i-1, j), (i+1, j), (i, j-1), (i, j+1)} & toindices(obj)) > 1:
          O = paint(O, {(EIGHT, (i, j))})
  return O
 
22.75, tensor(0.0033), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to another '1' (horizontally or vertically). The rest of the grid should remain unchanged. 
:: def iaeebdbadeddebdejhcbbgfgaehdcihh(I):
  def is_isolated(i, j):
    if I[i][j] != 1:
      return False
    for di, dj in dneighbors((0, 0)):
      ni, nj = i + di, j + dj
      if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 1 and (ni, nj) != (i, j):
        return False
    return True

  return tuple(
    tuple(
      8 if is_isolated(i, j) else I[i][j]
      for j in range(len(I[0])))
    for i in range(len(I))
  )
 
126.75, tensor(0.0021), Description: Replace all objects in the grid that are colored '1' with '8's. The rest of the grid should remain unchanged. 
:: def abfefiefbhddeeajbcbdcebdcfcbhdci(grid):
  return paint(grid, recolor(8, merge(objects(grid, univalued=True, diagonal=False, without_bg=False)))) 
 
47.75, tensor(0.0115), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. The background of the grid should be the same color as the original background. 
:: def hbbcdgefcagaedahagdfbddehfgcdeci(I):
  O = I  # Create a copy of the input grid
  bg = mostcolor(I) # Identify the background color
  for obj in objects(I, True, False, True): # Iterate through each object (excluding background)
    for i, j in delta(toindices(obj)): # Iterate over outline indices
        if 0 <= i < len(I) and 0 <= j < len(I[0]): # Check if index is within grid bounds
            O = fill(O, 8, {(i, j)})  # Fill the outline cell with color '8'
  return O 
 
18.75, tensor(0.0995), Description: Replace all '1's in the grid with '8's, except for '1's that are adjacent to another '1' horizontally. The rest of the grid should be filled with '9's. 
:: def agecbhefdjfgeacejeechibbaeegbffd(I):
  O = canvas(NINE, shape(I))
  ones = ofcolor(I, ONE)
  for i, j in ones:
    if (i, j - 1) not in ones or (i, j + 1) not in ones:
      O = paint(O, {(ONE, (i, j))})
    else:
      O = paint(O, {(EIGHT, (i, j))})
  return O
 
118.25, tensor(0.0997), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. The rest of the grid should remain unchanged. 
:: def hbffgibbcifhecedbdbgheifcbdfejgi(I):
  O = I
  for i, row in enumerate(I):
    O = paint(O, {(EIGHT if len(set(row[j:j+2])) == 1 and row[j] == ONE else ONE, (i, j)) for j in range(len(row)-1)})
  return O
 
81.75, tensor(0.0995), Description: Copy the input grid. Then, find the smallest colored object and shift it one space to the right. Combine the original and shifted objects. Finally, paint the combined object onto a blank canvas with the same dimensions as the input grid, filled with the background color, and recolor the combined object to '8'. 
:: def fibeehbifjdaeefbiddfeacdadibifde(I):
    # Identify objects in the input grid, excluding background.
    objs = objects(I, T, F, T)

    # Isolate the object with the smallest size.
    min_obj = argmin(objs, size)

    # Determine the color of the smallest object.
    color_min = color(min_obj)

    # Create a shifted version of the smallest object, moved one unit to the right.
    shifted_obj = shift(min_obj, RIGHT)

    # Combine the original and shifted objects.
    combined_obj = combine(min_obj, shifted_obj)

    # Generate the output grid by painting the combined object onto a blank canvas
    # with the same dimensions as the input grid, filled with the background color.
    O = paint(canvas(mostcolor(I), shape(I)), recolor(8, combined_obj))
    return O 
 
75.5, tensor(0.1110), Description: Copy the input grid. Then, find the object with the smallest width and shift it one space to the right. Combine the original and shifted objects. Finally, paint the combined object onto a blank canvas with the same dimensions as the input grid, filled with the background color, and recolor the combined object to the original color. 
:: def dbgdabfciaaaeajdjcjfeaiaeffhgace(I):
    # Identify objects in the input grid, excluding the background.
    objs = objects(I, T, F, T)

    # Find the object with the minimum width among the identified objects.
    min_width_obj = argmin(objs, width)

    # Determine the color of the object with the minimum width.
    target_color = color(min_width_obj)

    # Extract the indices of the object with the minimum width.
    target_indices = toindices(min_width_obj)

    # Generate a set of indices by shifting the target indices one position to the right.
    shifted_indices = shift(target_indices, RIGHT)

    # Calculate the union of the target indices and shifted indices.
    union_indices = combine(target_indices, shifted_indices) 

    # Create a new grid by filling the input grid with the background color
    # and then painting the union of indices with the target color.
    O = paint(fill(I, mostcolor(I), union_indices), recolor(target_color, union_indices)) 
    return O
 
62.25, tensor(1.1257), Description: For each object in the grid, extend it to the right with '8's. The extension length should be 3 minus the object's width if the width is less than or equal to 3, otherwise, extend by 1. The background of the grid should be the same color as the original background. 
:: def daefbdhejideedjaajedfedgiehddbea(I):
    objs = fgpartition(I)  # Identify objects excluding background '9'
    bg = mostcolor(I)  
    new_objs = set()
    for obj in objs:
        w = width(obj)
        extension = (3 - w) if w <= 3 else 1
        new_obj = set()
        for _, (i, j) in obj:
            for k in range(extension):
                new_obj.add((8, (i, j+k)))
        new_objs.add(frozenset(new_obj))
    O = paint(canvas(bg, shape(I)), merge(new_objs)) 
    return O
 
74.0, tensor(0.1313), Description: Copy the input grid. Then, shift all single-colored squares two spaces to the right. For each of the larger shapes, create a new shape that is the same size and shape as the original shape, but with the background color. Then, paint this new shape onto the grid, ensuring it covers the original shape. The result should be a grid with the single-colored squares shifted to the right, and the larger shapes replaced with their background color. 
:: def aafbajaadghiehcfaceabceegdedfeef(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    small_objs = sizefilter(objs, 1) 
    large_objs = difference(objs, small_objs)
    shifted_small_objs = mapply(lambda obj: shift(obj, (0, 2)), small_objs)
    extended_large_objs = mapply(lambda obj: toobject(backdrop(obj), I), large_objs)
    O = paint(paint(canvas(bg, shape(I)), shifted_small_objs), extended_large_objs)
    return O 
 
84.25, tensor(1.3058), Description: For each object in the grid, extend it to the right with '8's. The extension length should be 3 minus the object's width if the width is less than 4, otherwise, extend by 1. The background of the grid should be the same color as the original background. 
:: def dfcdfabbjdcceeffibccdbahgbfahjfe(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    extension = lambda obj: (0, 3 - width(obj)) if width(obj) < 4 else (0, 1)
    extended_objs = mapply(lambda obj: shift(obj, extension(obj)), objs)
    O = paint(canvas(bg, shape(I)), extended_objs)
    return O
 
73.25, tensor(1.2969), Description: For each object in the grid, extend it to the right with '8's. The extension length should be 3 if the object's width is less than 4, otherwise, extend by 1. The background of the grid should be the same color as the original background. 
:: def dafahajaeeahehdhbibbfagdffecegbi(I):
    objs = fgpartition(I)
    bg = mostcolor(I)
    modified_objs = set()
    for obj in objs:
        if len(obj) < 4:  # Small object
            rightmost_col = rightmost(obj)
            new_cells = {(8, (i, j)) for _, (i, j) in obj for j in range(rightmost_col + 1, rightmost_col + 4)}
            modified_objs.add(obj | new_cells)
        else:  # Large object
            modified_objs.add(obj)
    O = paint(canvas(bg, shape(I)), merge(modified_objs))
    return O 
 
112.25, tensor(1.9762), Description: Replace all cells adjacent to the least common color in the grid with '8's. The rest of the grid should remain unchanged. 
:: def fegjcfcjbcejecbcjefbaafhgeacbcbh(I):
    target_color = leastcolor(I)
    target_indices = ofcolor(I, target_color)
    expanded_indices = mapply(dneighbors, target_indices) - target_indices
    expanded_object = recolor(EIGHT, toobject(expanded_indices, I))
    O = underpaint(I, expanded_object)
    return O
 
76.5, tensor(0.6193), Description: Replace all cells that are part of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right. 
:: def fjcchcdicfijeajebaccfdfbgcibaegc(I):
  target_color = leastcolor(I)
  obj = objects(I, True, False, True)
  obj = extract(obj, lambda o: color(o) == target_color)
  left_border = {(i, leftmost(obj) - 1) for i in range(uppermost(obj), lowermost(obj) + 1)}
  right_border = {(i, rightmost(obj) + 1) for i in range(uppermost(obj), lowermost(obj) + 1)}
  expanded_obj = combine(combine(toindices(obj), left_border), right_border)
  O = paint(cover(I, obj), recolor(EIGHT, toobject(expanded_obj, I)))
  return O
 
87.5, tensor(1.9762), Description: Replace all cells adjacent to the least common color in the grid with '8's. The rest of the grid should remain unchanged. 
:: def dgacdchbiegbeaifjffbeecjbcecbdhj(I):
    target_color = leastcolor(I)
    h, w = len(I), len(I[0])
    O = list(list(row) for row in I)
    for i in range(h):
        for j in range(w):
            if I[i][j] == target_color:
                if j > 0:
                    O[i][j - 1] = EIGHT
                if j < w - 1:
                    O[i][j + 1] = EIGHT
    return tuple(tuple(row) for row in O)
 
81.0, tensor(1.7717), Description: Replace all '1's in the grid with '8's. Expand each object containing '1' by one layer of cells, filling the expanded area with '8's. Then, restore the original background color and replace any remaining '1's with '8's. 
:: def jdaahfibacgdefdbacdiefiaebdbgajg(I):
  objs = objects(I, True, False, True)  # Find objects of '1'
  bg = mostcolor(I)                    # Identify background color
  for obj in objs:
    expanded_obj = toindices(obj)
    for cell in toindices(obj):
      expanded_obj = expanded_obj | dneighbors(cell) # Expand each object by one layer
    I = fill(I, 8, expanded_obj)     # Fill expanded area with '8'
  I = replace(I, 8, bg)              # Restore original background
  I = replace(I, 1, 8)                # Replace remaining '1' with '8'
  return I 
 
77.25, tensor(1.7717), Description: Replace all cells in the grid that are within one layer of the bounding box of an object with '8's. The rest of the grid should be filled with the background color. The bounding box is defined as the smallest rectangle that encloses the object. 
:: def gbdbcbiifbdcehbbbdhbgdbibigajedh(I):
  objs = objects(I, True, False, True) # Find objects of '1'
  bg = mostcolor(I)                   # Identify background color
  O = canvas(bg, shape(I))            # Create output grid with background color
  for obj in objs:
    for cell in backdrop(obj):         # Iterate over bounding box of each object
      if manhattan(initset(cell), obj) <= 1: # Check if cell is within one layer
        O = fill(O, 8, initset(cell))  # Fill cell with '8' if within range
  return O
 
112.25, tensor(1.7719), Description: Replace all cells adjacent to '1' that are the same color as the background with '8' in a grid. The rest of the grid should remain unchanged. 
:: def hdadjjcbchcdeihhiachfdfdjfbeidja(I):
  O = I                               # Initialize output as input
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1:                # If cell is '1'
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]: # Check surrounding cells
          new_i, new_j = i + di, j + dj
          if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]): # Bounds check
            if O[new_i][new_j] == mostcolor(I): # If surrounding cell is background
              O = fill(O, 8, initset((new_i, new_j))) # Fill with '8'
  return O
 
101.25, tensor(1.7718), Description: Replace all cells adjacent to '1' that are on the border of the grid with '8's. The rest of the grid should remain unchanged. 
:: def geddceiabdacehafibfbbhhefgeicbfj(I):
  padded_I = canvas(mostcolor(I), (height(I) + 2, width(I) + 2)) # Padded grid
  padded_I = paint(padded_I, shift(asobject(I), (1,1))) # Place input in center
  O = canvas(mostcolor(I), shape(I))                 # Output grid
  for i in range(1, len(padded_I) - 1):
    for j in range(1, len(padded_I[0]) - 1):
      if padded_I[i][j] == 1:                       # If cell is '1'
        O = fill(O, 8, dneighbors((i-1,j-1)))      # Fill neighbors in output
  return O
 
68.25, tensor(1.9827), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. The rest of the grid should remain unchanged. 
:: def habebbiecbjbefbebfjgdchafdefhede(I):
    target_color = 1
    extension_color = 8
    def process_row(row_index):
        row = I[row_index]
        new_row = list(row) 
        for j in range(len(row)):
            if row[j] == target_color:
                for k in range(j-1, -1, -1):
                    if row[k] != target_color:
                        new_row[k+1:j+1] = [extension_color]*(j-k)
                        break
                break
        return tuple(new_row)
    O = tuple(process_row(i) for i in range(len(I)))
    return O 
 
62.25, tensor(1.4761), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def ceajefcgdajceggaiejbcaehaaaffaab(I):
  O = canvas(9, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        for k in range(j-1, -1, -1):
          if row[k] != 1:
            O = fill(O, 8, connect((i, k+1), (i, j)))
            break
        else:
          O = fill(O, 8, {(i, j)}) 
  return O
 
73.25, tensor(0.0984), Description: Shift all objects in the grid one cell to the right, but only if the shifted area is entirely background. The rest of the grid should remain unchanged. 
:: def ceajccccadcceeefaebjadbdfbabdicd(I):
  # Identify objects, including diagonals, without background
  objs = objects(I, T, T, T)

  # Create a set to store modified objects
  modified_objs = set()
  for obj in objs:
    # Shift the object one cell to the right
    shifted_obj = shift(obj, RIGHT)

    # Get the intersection between the shifted object and the input grid
    intersection = toobject(toindices(shifted_obj), I)

    # Check if the intersection is empty (meaning the shifted area is background)
    if len(intersection) == 0:
      # If empty, add the shifted object to the modified objects set
      modified_objs.add(shifted_obj)

  # Paint all modified objects onto a copy of the input grid
  O = I
  for obj in modified_objs:
    O = paint(O, obj)

  # Return the modified grid
  return O
 
84.75, tensor(1.9829), Description: Replace all cells in the grid with '8's if they are directly to the right of a non-background cell and are the same color as the background. The rest of the grid should remain unchanged. 
:: def cfcgecjebaebeeadadffeaajhfjbched(I):
  # Get background color
  bg_color = mostcolor(I)

  # Get all object indices, excluding background
  obj_indices = difference(asindices(I), ofcolor(I, bg_color))

  # Identify indices to be filled
  fill_indices = frozenset((i, j + 1) for i, j in obj_indices if j + 1 < width(I) and I[i][j+1] == bg_color)

  # Fill identified indices with their corresponding object colors
  O = fill(I, 8, fill_indices)
  return O
 
75.75, tensor(0.7903), Description: For each object in the grid, extend it to the right with '8's. The extension length should be 1 if the object's width is less than or equal to 2, otherwise, extend by 2. The background of the grid should be the same color as the original background. 
:: def badaedagagjeejdgbecchgfhbcedcceb(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    extended_objs = set()
    for obj in objs:
        if len(obj) <= 2:
            right_edge_loc = (uppermost(obj), rightmost(obj))
            extension = {(8, (right_edge_loc[0], right_edge_loc[1] + 1))}
        else:
            extension = {(8, (i, rightmost(obj) + j)) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(1, 3)}
        extended_objs.add(obj | extension)
    O = paint(canvas(bg, (height(I), width(I) + 2)), merge(extended_objs))
    return O 
 
72.25, tensor(0.9247), Description: For each object in the grid, extend it to the right with '8's. The extension length should be 2 if the object's width is less than or equal to 2, otherwise, extend by 2. The background of the grid should be the same color as the original background. 
:: def fdaccfdfcddeeehajcifbgffijcfhcga(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    O = canvas(bg, (height(I), width(I) + 2))
    for obj in objs:
        O = paint(O, obj | {(8, (i, j)) for i in range(uppermost(obj), lowermost(obj) + 1)
                        for j in range(rightmost(obj) + 1, rightmost(obj) + (2 if len(obj) > 2 else 2))})
    return O
 
85.75, tensor(0.6193), Description: Replace all cells that are part of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right. 
:: def fieiajacdhffehhfacfcfebbgefcahif(I):
    target_color = leastcolor(I)
    target_indices = ofcolor(I, target_color)
    expanded_indices =  frozenset({(i, j + dj) for i, j in target_indices for dj in (-1, 1)})
    expanded_object = toobject(combine(target_indices, expanded_indices), I)
    O = paint(cover(I, recolor(target_color, target_indices)), recolor(EIGHT, expanded_object))
    return O
 
77.5, tensor(0.5139), Description: Replace all cells that are part of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The object is shifted one cell up and one cell down. 
:: def hdbfbeidcibcedecjhcgaebehbccihbd(I):
  c = leastcolor(I)
  obj = extract(objects(I, True, False, True), lambda o: color(o) == c)
  shifted_objs = (shift(obj,(0,-1)), shift(obj,(0,1)))
  O = paint(paint(cover(I, obj),recolor(EIGHT, obj)), recolor(EIGHT, merge(shifted_objs)))
  return O
 
115.5, tensor(1.7714), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. 
:: def cbbjedehcgcbeicebiebhcffhcdbdjhi(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        O = fill(O, 8, outbox(toindices(obj)))
    return O
 
85.75, tensor(1.0974), Description: Copy the input grid and shift each object one space to the right and one space down. The background of the grid should be the same color as the original background. 
:: def ehaeeaacefefehfbbbbbcfeffehjafgc(I):
  O = canvas(mostcolor(I), (height(I) + 2, width(I) + 2)) 
  for obj in objects(I, T, F, T):
    O = underpaint(O, shift(recolor(index(I, first(toindices(obj))), obj), (1,1)))
  return O
 
113.25, tensor(1.0936), Description: Copy the input grid and shift each object one space to the right and one space down. Then, replace the outline of each shifted object with '8's. The background of the grid should be the same color as the original background. 
:: def cchhcefbdfdfecbhjcbaajeeedijhfec(I):
    objs = objects(I, T, F, T)
    O = canvas(mostcolor(I), (height(I) + 2, width(I) + 2))
    for obj in objs:
        shifted_obj = shift(obj, (1, 1))
        O = paint(O, shifted_obj)
        O = fill(O, 8, outbox(toindices(shifted_obj)))
    return O
 
112.5, tensor(1.7712), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. The background of the grid should be the same color as the original background. 
:: def hbffgggafddfefgcbcgbbbeehfeehcac(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I)):
            if index(I, (i, j)) != mostcolor(I):
                O = fill(O, 8, outbox(frozenset({(i, j)})))
    return O
 
109.5, tensor(1.9827), Description: Replace all '1's in the grid with '8's, except for '1's that are the last '1' in their row. The rest of the grid should remain unchanged. 
:: def edeedcfaefacedifiehbcdbdcfhaeefg(I):
    target_color = 1
    extension_color = 8
    def process_row(row):
        new_row = list(row)
        extending = False
        for j in range(len(row) - 1, -1, -1):
            if new_row[j] == target_color:
                extending = True
            elif extending:
                if new_row[j] == 9:
                    new_row[j] = extension_color
                else:
                    extending = False
        return tuple(new_row)
    O = tuple(process_row(row) for row in I)
    return O
 
84.75, tensor(0.1067), Description: For each object in the grid, extend it to the right with the background color if the cell to the right is the background color. The rest of the grid should remain unchanged. 
:: def ffedhcjdabceecejjfhiaiddegbajeif(I):
  # Get background color.
  bg = mostcolor(I)
  
  # Find all objects.
  objs = objects(I, T, F, T)
  
  # Expand each object to the right if bordering background.
  for obj in objs:
    expanded_obj = shift(obj, RIGHT)
    for cell in expanded_obj:
      i, j = cell[1]
      if 0 <= i < height(I) and 0 <= j < width(I) and I[i][j] == bg:
        I = paint(I, {cell})
  return I
 
111.25, tensor(1.9829), Description: Replace all cells in the grid with '8's if they are directly to the right of a non-background cell and are the same color as the background, except for the rightmost column. The rest of the grid should remain unchanged. 
:: def hgdhgeacfadaegfdaibgadbdicfhdfaf(I):
  bg = mostcolor(I)
  return tuple(tuple(bg if j == width(I) else (I[i][j] if j + 1 == width(I) or I[i][j+1] != bg else 8)
                   for j in range(width(I) + 1)) for i in range(height(I)))
 
143.25, tensor(1.9810), Description: Add a column of the background color to the right of the input grid. Then, replace all background color cells in the extended grid with '8's. 
:: def ahicccifahdbehjiacbfjfehjfbficii(I):
  bg = mostcolor(I)
  extended_grid = []
  for row in I:
    new_row = list(row) + [bg]
    extended_grid.append(new_row)
  extended_grid = tuple(tuple(row) for row in extended_grid)
  O = replace(extended_grid, bg, 8)
  return O
 
66.25, tensor(1.9811), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. 
:: def cefegbhbccbfegdeajefhehfdabfaicc(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = canvas(bg, (height(I), width(I) + 1))
  for obj in objs:
    for v, (i, j) in obj:
      O = paint(O, {(8, (i, j))})
      if j < width(I) - 1:
        O = paint(O, {(8, (i, j + 1))})
  return O
 
78.0, tensor(0.6193), Description: Replace all cells that are part of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right. 
:: def eccdgddebaicehicbfcjccbbeacgjdai(I):
  min_color = leastcolor(I)
  obj = extract(objects(I, True, False, True), matcher(color, min_color))
  h = height(obj)
  expanded_obj = toobject(frozenset((i,j) for i in range(uppermost(obj), uppermost(obj)+h) for j in range(leftmost(obj)-1, rightmost(obj)+2)), I) # Explicitly define expansion range
  O = paint(cover(I, obj), recolor(EIGHT, expanded_obj))
  return O
 
89.5, tensor(0.8378), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find all cells in the expanded output grid that are within one Manhattan distance of the object's shifted position. Replace these cells with '8's. The background of the grid should be the same color as the original background. 
:: def fdaagefcafgeehbdiadebfbjdceffeba(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 2))
  for i in range(height(I)):
    for j in range(width(I)):
      O = fill(O, I[i][j], {(i + 1, j + 1)})
  for obj in objects(I, T, F, T):
    for di in range(-1, width(obj) + 1):
      for dj in range(-1, height(obj) + 1):
        loc = add(ulcorner(obj), (di, dj))
        loc = add(loc, (1, 1)) # Adjust for output grid expansion
        if manhattan(initset(loc), shift(obj, (1, 1))) == 1:
          O = fill(O, 8, {loc})
  return O
 
97.25, tensor(1.4761), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def digdibaacegaefhgacjdggdbgacdjafa(I):
  O = canvas(9, shape(I)) # Initialize output grid with background color
  objs = objects(I, True, False, True) # Get all objects in the input grid (excluding background)
  target_color = 1
  extension_color = 8
  for obj in objs:
    if color(obj) == target_color: # Only process target_color objects
      for i in range(uppermost(obj), lowermost(obj) + 1): # Iterate through rows of the object
        for j in range(leftmost(obj) - 1, -1, -1): # Iterate leftward from the object's left edge
          if index(I, (i, j)) != target_color and index(I, (i,j)) != 9: # Stop at non-target and non-background colors
            break
          O = fill(O, extension_color, {(i, j)}) # Fill the output grid with extension_color
        O = paint(O, obj) # Paint the original object onto the output grid 
  return O
 
73.25, tensor(1.4761), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def cbhebigcahfjecidjfgiajbhjbbgijaa(I):
  O = canvas(9, shape(I)) 
  h, w = shape(I)
  target_color = 1
  extension_color = 8
  for i in range(h):
    current_obj_start = None
    for j in range(w):
      if I[i][j] == target_color and current_obj_start is None:
        current_obj_start = j
      elif current_obj_start is not None and (I[i][j] != target_color and I[i][j] != 9):
        O = fill(O, extension_color, {(i, k) for k in range(current_obj_start - 1, j)})
        current_obj_start = None
    if current_obj_start is not None:
      O = fill(O, extension_color, {(i, k) for k in range(current_obj_start - 1, -1, -1)})
  O = paint(O, asobject(I)) 
  return O
 
145.5, tensor(1.9830), Description: Replace all cells in the grid with '8's if they are to the left of a non-background cell in the same row. The rest of the grid should remain unchanged. 
:: def iaeaadbiddcfeiijibcbgdgdffefdeja(I):
  bg = mostcolor(I) 
  return hconcat(I, tuple(tuple(8 if any(v != bg for v in I[i][:j]) else bg for j in range(width(I))) 
                            for i in range(height(I))))
 
104.0, tensor(0.1106), Description: For each object in the grid, extend it to the right with the background color until it reaches the right edge of the grid. The background of the grid should be the same color as the original background. 
:: def acdfhcjedbefeahejhaabaeaaggfcafe(I):
  def right_expand(obj):
    return frozenset((color(obj), (i, j + k)) for i, j in toindices(obj)
                   for k in range(width(I) - j) if k == 0 or I[i][j + k] == mostcolor(I))
  return paint(canvas(mostcolor(I), shape(I)), merge(apply(right_expand, objects(I, T, F, T)))) 
 
98.25, tensor(0.1072), Description: For each row in the grid, extend the first non-background cell to the right with '8's until the end of the row. The rest of the grid should remain unchanged. 
:: def hiebbfdcagcgeaebidhidfdjfabjcdde(I):
  def extend_right(row):
    extended = list(row)
    for j in range(len(row)):
      if extended[j] != mostcolor(I):
        extended[j+1:] = [8] * (len(row) - j - 1) 
        break
    return tuple(extended)
  return tuple(extend_right(row) for row in I)
 
99.5, tensor(1.9830), Description: Replace all cells in the grid with '8's if they are to the left of a non-background cell in the same row. The rest of the grid should remain unchanged. 
:: def ccaaghgbfefeeifbiaabceeccaggccjb(I):
  def right_fill(i, j):
    return 8 if any(I[i][k] != mostcolor(I) for k in range(j)) else mostcolor(I)
  return tuple(tuple(right_fill(i, j) for j in range(width(I))) for i in range(height(I)))
 
73.75, tensor(1.9811), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. 
:: def eccbdjgjfcfhedbfafbfecefjifdehhb(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  extended_objs = mapply(lambda obj: toobject(combine(toindices(obj), {(i, j + 1) for i, j in toindices(obj) if j < width(I) - 1 and I[i][j + 1] == bg}), I), objs)
  O = paint(canvas(bg, shape(I)), recolor(8, extended_objs))
  return O
 
80.5, tensor(0.6193), Description: Replace all cells that are part of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right. 
:: def cfejbdbgdjbdehiajadbbdaadadefcfj(I):
  target_obj = argmin(objects(I, True, False, True), size)
  expanded_indices = frozenset((i,j) for i in range(uppermost(target_obj), lowermost(target_obj)+1) for j in range(leftmost(target_obj)-1, rightmost(target_obj)+2))
  expanded_obj = toobject(expanded_indices, I)
  O = paint(cover(I, target_obj), recolor(EIGHT, expanded_obj))
  return O
 
77.75, tensor(1.9762), Description: Replace the outline of the smallest object in the grid with '8's, except for the cells that are two rows above the object. The rest of the grid should remain unchanged. 
:: def daedhjhcdhedeghdbijbegcaeddjfedb(I):
  objs = objects(I, True, False, True)
  target_obj = argmin(objs, lambda obj: width(obj) * height(obj))
  O = paint(I, recolor(EIGHT, toobject(outbox(target_obj) - outbox(shift(target_obj, (0, -2))), I)))
  return O
 
80.0, tensor(0.2079), Description: Copy the input grid. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the object one space to the left and one space up. Then, paint the bounding box of the shifted object onto the output grid, using the background color. The result should be a grid with each object shifted one space to the left and one space up, and the bounding box of the shifted object painted with the background color. 
:: def dhhffecfjebjedchidaccffddabcdabc(I):
  for obj in sorted(objects(I, True, False, True), key=size):
    return paint(cover(I, obj), recolor(EIGHT, toobject(backdrop(shift(obj, (-1, -1))), I)))
 
79.75, tensor(0.2118), Description: Replace all cells that are part of the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right, and two cells to the right. 
:: def dfibiefaaeafedbdaaecbhjeffbfbeci(I):
  min_obj = min(objects(I, True, False, True), key=lambda o: len(o))
  return paint(I, recolor(EIGHT, toobject(
      frozenset((i, j + k) for i, j in toindices(min_obj) for k in (-1, 0, 1, 2)), 
      I
  )))
 
77.25, tensor(0.2118), Description: Replace all cells that are part of the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell to the left and right, and two cells to the right. 
:: def dbefibfjbjccedbibjfgdeaccicjgdah(I):
  min_obj = min(objects(I, True, False, True), key=len)
  shifted_obj = shift(min_obj, (0, -1))
  expansion = difference(
      mapply(lambda idx: frozenset({(idx[0], idx[1] + k) for k in range(-1, 3)}), toindices(min_obj)), 
      toindices(shifted_obj)
  )
  return paint(I, recolor(EIGHT, toobject(expansion, I))) 
 
73.75, tensor(0.8378), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find all cells in the expanded output grid that are within one Manhattan distance of the object's shifted position. Replace these cells with '8's. The background of the grid should be the same color as the original background. 
:: def ejcgdbfffcehedbcaijaebiheecfjbhh(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 2)) # Create canvas with border
  for i, j in prapply(lambda i, j: (i + 1, j + 1), range(height(I)), range(width(I))):
    O = fill(O, index(I, (i, j)), {(i, j)}) # Place input on canvas
  for obj in objects(I, T, F, T):
    O = fill(O, 8, shift(delta(backdrop(obj)), (1, 1))) # Draw shifted delta
  return O 
 
88.0, tensor(1.0908), Description: Copy the input grid. For each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. 
:: def dfechbbdaidfeeffbgegeccebihfbiab(I):
  bg = mostcolor(I)
  O = I
  for obj in objects(I, T, F, T):
    shifted_box = shift(box(toindices(obj)), (1, 1))  # Calculate shifted box
    O = fill(O, 8, sfilter(shifted_box, lambda ij: 0 <= ij[0] < height(I) and 0 <= ij[1] < width(I)))
  return O
 
100.75, tensor(1.0949), Description: Copy the input grid. For each object in the input grid, find the four corners of the object. Shift each corner one space to the right and one space down. Then, fill the neighbors of the shifted corners with '8's. The result should be a grid with the neighbors of each object's shifted corners filled with '8's. 
:: def bciefdeeaiccehjajdbcfbaedifhabgb(I):
  O = I
  for obj in objects(I, T, F, T):
    for corner in corners(obj):
      O = fill(O, 8, neighbors(add(corner, (1, 1))))  # Fill neighbors of shifted corners
  return O
 
104.0, tensor(1.4761), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def hhieaedfdaegeifdaeeciadhefcebjfa(I):
  O = canvas(9, shape(I)) # Initialize output grid with background
  objs = objects(I, True, False, True)
  target_color = 1
  extension_color = 8
  for obj in objs:
    if color(obj) == target_color:
      for j in range(leftmost(obj), width(I)): # Iterate through columns from object's leftmost
        extension_area = frozenset((i, k) for i in range(uppermost(obj), lowermost(obj) + 1) for k in range(j-1, leftmost(obj)-1, -1) if index(I, (i, k)) == 9)
        if len(extension_area) > 0:
          O = fill(O, extension_color, extension_area)
        O = paint(O, obj) # Paint original object on the grid
  return O
 
146.25, tensor(1.9900), Description: Copy the input grid and double its width. For each non-background cell in the original grid, place an '8' in the corresponding cell in the second half of the new grid. The rest of the new grid should be filled with the background color. 
:: def djacgeahigdfeebaieedgdadfdffdcib(I):
  bg = mostcolor(I)
  new_grid = canvas(bg, (height(I), 2 * width(I)))
  for i in range(height(I)):
    for j in range(width(I)):
      new_grid = fill(new_grid, I[i][j], {(i, j)})
      if I[i][j] != bg:
        new_grid = fill(new_grid, 8, {(i, j + width(I))})
  return new_grid
 
250.0, tensor(0.1032), Description: For each object in the grid, extend it to the right with '8's. The extension length should be the same as the width of the object. The background of the grid should be the same color as the original background. 
:: def facfgdcihddgedbdjfeedjadfccdffba(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  extended_grid = I
  for obj in objs:
    extended_grid = hconcat(extended_grid, canvas(8 if obj else bg, shape(obj)))
  return extended_grid 
 
157.0, tensor(0.1586), Description: Double the width of the input grid. For each row, if any cell in the original half of the row is not the background color, fill the corresponding cell in the second half of the row with '8'. Otherwise, fill the cell in the second half of the row with the background color. 
:: def ciebbcedjefbeedcbecihhcbieddigcc(I):
  bg = mostcolor(I)
  return tuple(
    tuple(
      I[i][j] if j < width(I) else (8 if any(I[i][k] != bg for k in range(width(I))) else bg)
      for j in range(2 * width(I))
    )
    for i in range(height(I))
  )
 
92.5, tensor(1.9810), Description: Replace all cells in the grid with '8's if they are directly to the right of a non-background cell and are the same color as the background. The rest of the grid should remain unchanged. 
:: def haeabffbiecdeddiiijhehfbeifadgja(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != bg and j < width(I) - 1 and I[i][j + 1] == bg:
        O = paint(O, {(8, (i, j + 1))})
  return O
 
78.5, tensor(1.9762), Description: Replace all cells adjacent to the smallest object in the grid with '8's. The rest of the grid should remain unchanged. 
:: def cjaaifcbbbeiediiibecdeccfidahcjb(I):
  target_obj = argmin(objects(I, True, False, True), size)
  expansion = mapply(lambda idx: dneighbors(idx), toindices(target_obj))
  return paint(I, recolor(EIGHT, toobject(expansion - toindices(target_obj), I)))
 
81.0, tensor(1.9764), Description: Replace all cells adjacent to the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell in each direction (horizontally and vertically). 
:: def ciciaddfcheheabcbfhdhbdafhcedhee(I):
  smallest_object = min(objects(I, True, False, True), key=lambda obj: len(obj))
  expanded_area = set()
  for i, j in toindices(smallest_object):
    for di in range(-1, 2):
      for dj in range(-1, 2):
        expanded_area.add((i + di, j + dj))
  return paint(I, recolor(EIGHT, toobject(frozenset(expanded_area) - toindices(smallest_object), I)))
 
73.25, tensor(1.9763), Description: Replace the outline of the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells. The bounding box is defined as the smallest rectangle that encloses the object. 
:: def cheddigeechieigfjaafbgfaggiabaaa(I):
  min_obj = argmin(objects(I, True, False, True), size)
  return paint(I, recolor(EIGHT, toobject(delta(backdrop(min_obj)), I)))
 
80.0, tensor(1.9765), Description: Replace all cells that are part of the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell in each direction (horizontally and vertically). 
:: def aaaadfgfidhaedifiaaefcdfcafcbejh(I):
  min_obj = argmin(objects(I, True, False, True), lambda obj: len(toindices(obj)))
  shifted_objs = [shift(min_obj, d) for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]]
  expansion =  set().union(*[toindices(obj) for obj in shifted_objs])
  return paint(I, recolor(EIGHT, toobject(expansion, I)))
 
82.5, tensor(1.9764), Description: Replace all cells adjacent to the smallest object in the grid with '8's. The rest of the grid should remain unchanged. The object is expanded by one cell in each direction (horizontally and vertically). 
:: def abfdhfcdgdaheehdiffecbagddjbecja(I):
    small_obj = argmin(objects(I, True, False, True), size)
    expanded_area = frozenset({(i + di, j + dj) 
                               for i, j in toindices(small_obj)
                               for di in [-1, 0, 1] 
                               for dj in [-1, 0, 1] 
                               if (di, dj) != (0, 0)}) 
    return paint(I, recolor(EIGHT, toobject(expanded_area, I)))
 
88.25, tensor(1.0921), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. 
:: def fcdjjaecfhidecgfjjgedaiddgaibifd(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 2))  # Create canvas with border
  O = paint(O, shift(asobject(I), (1, 1)))  # Place input onto canvas
  for obj in objects(I, T, F, T):
    O = fill(O, 8, shift(box(toindices(obj)), (1, 1)))  # Draw shifted box
  return O
 
101.75, tensor(1.0921), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. 
:: def hjcffafadcjcecccjaajdcbgcejfdacb(I):
  bg = mostcolor(I)
  O = canvas(bg, add(shape(I), (2, 2))) # Canvas with added border dimensions
  for i, j in prapply(lambda i, j: (i + 1, j + 1), range(height(I)), range(width(I))):
    O = fill(O, index(I, (i, j)), {(i, j)}) # Place input on canvas
  for obj in objects(I, T, F, T):
    O = fill(O, 8, shift(outbox(obj), (1, 1))) # Draw shifted outbox
  return O
 
89.75, tensor(1.0755), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8', but only for the cells that are not part of the shifted object itself. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8', except for the cells that were originally part of the object. 
:: def gdddbbfajdedejcciffcdafdeibgefha(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 2))  # Create canvas with border
  O = paint(O, shift(asobject(I), (1, 1)))  # Place input onto canvas
  for obj in objects(I, T, F, T):
    box_indices = shift(box(toindices(obj)), (1, 1)) # Pre-calculate shifted box indices
    for i, j in box_indices:
        if (i, j) not in toindices(shift(obj, (1, 1))):  # Only fill if not part of the shifted object
            O = fill(O, 8, {(i, j)})  # Draw '8' at the box index
  return O
 
97.75, tensor(1.7000), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def hgadffbcgcefedjcigcchcjbegiefdcd(I):
    target_color = 1
    extension_color = 8
    objs = objects(I, True, False, True) # Identify objects
    for obj in objs:
        if color(obj) == target_color: # Target color objects
            min_j = leftmost(obj) # Leftmost column
            for i, j in toindices(obj):
                for k in range(j - 1, -1, -1): # Extend leftwards
                    if index(I, (i, k)) not in (9, target_color):
                        break
                    I = fill(I, extension_color, {(i, k)}) # Fill extension
    return I
 
84.0, tensor(1.7000), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def bjfggcdeeediebcibddjfcajigffbadb(I):
  def extend_obj(obj):
    if color(obj) != 1:
      return frozenset()
    min_j = leftmost(obj)
    return frozenset((8, (i, k)) for i, j in toindices(obj) for k in range(j - 1, min_j - 1, -1) if index(I, (i, k)) == 9)
  return paint(I, merge(apply(extend_obj, objects(I, True, False, True))))
 
96.0, tensor(0.1102), Description: Copy the input grid. For each object in the input grid, shift the object one space to the right and one space down, and paint the shifted object with the color '8'. Then, shift the object one space to the right and paint the shifted object with the color '8'. Finally, shift the object one space down and paint the shifted object with the color '8'. The result should be a grid with each object shifted one space to the right and one space down, and the shifted object painted with the color '8'. 
:: def cfeecihafiebeadbaeibfbebicfjdafh(I):
  objs = objects(I, T, F, T)
  painted_grid = I
  for obj in objs:
    painted_grid = underpaint(painted_grid, shift(recolor(8, toindices(obj)), (1, 1)))
    painted_grid = underpaint(painted_grid, shift(recolor(8, toindices(obj)), (1, 0)))
    painted_grid = underpaint(painted_grid, shift(recolor(8, toindices(obj)), (0, 1)))
  return painted_grid
 
94.0, tensor(1.9829), Description: Replace all cells in the grid with '8's if they are directly below or to the right of a cell that is part of an object. The rest of the grid should remain unchanged. 
:: def jdbjfdcbifadefaiicjhedaejhbjdcgd(I):
  painted_grid = I
  for obj in objects(I, T, F, T):
    for i, j in toindices(obj):
      if i + 1 < height(I):
        painted_grid = underfill(painted_grid, 8, {(i + 1, j)})
      if j + 1 < width(I):
        painted_grid = underfill(painted_grid, 8, {(i, j + 1)})
  return painted_grid
 
77.25, tensor(1.9811), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. 
:: def badfabacfeccecfeafeddebaffbijffh(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  O = canvas(bg, (height(I), width(I) + 1))
  for obj in objs:
    for c, (i, j) in obj:
      O = fill(O, c, {(i, j)})
      if j < width(I) - 1 and I[i][j + 1] == bg:
        O = fill(O, 8, {(i, j + 1)})
  return O
 
65.75, tensor(1.9811), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. 
:: def icbfgjffgbggefecaefadfdajbbgcbia(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I), width(I) + 1))
  for i in range(height(I)):
    for j in range(width(I)):
      O = fill(O, I[i][j], {(i,j)})
      if j < width(I) - 1 and I[i][j + 1] == bg:
        O = fill(O, 8, {(i, j + 1)})
  return O
 
75.5, tensor(0.1183), Description: Copy the input grid and add a column to the right. Shift all objects one space to the right in the new grid. Then, replace all cells in the shifted objects with '8's. The background of the grid should be the same color as the original background. 
:: def afbfacicbcdbecfbiebdebfbfdaffhdf(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  shifted_objs = frozenset(shift(obj, (0,1)) for obj in objs)
  O = paint(canvas(bg, (height(I), width(I) + 1)), recolor(8, merge(shifted_objs)))
  return O
 
78.5, tensor(0.2054), Description: For each object in the grid, draw a vertical line of '8's to the left of the object, starting from the topmost cell of the object and extending down to the bottommost cell. The background of the grid should be the same color as the original background. 
:: def ijfbebgijfdgegeiadecbddeecgcjcbg(I):
  return paint(I, merge(prapply(lambda i, obj: frozenset({(EIGHT, (i - 1, leftmost(obj))) for i in range(uppermost(obj), lowermost(obj) + 1)}), range(len(I)), objects(I, True, False, True))))
 
84.25, tensor(0.2054), Description: For each object in the grid, draw a vertical line of '8's to the left of the object, starting from the topmost cell of the object and extending down to the bottommost cell. The background of the grid should be the same color as the original background. 
:: def bcccaeabbjeaefafihfbehjhdfebfdca(I):
  return paint(I, merge(apply(lambda obj: recolor(EIGHT, shift(frozenset((i, 0) for i in range(height(obj))), (uppermost(obj), leftmost(obj) - 1))), objects(I, True, False, True))))
 
98.5, tensor(1.0921), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. 
:: def ieabbcbaebbaefdbicagaebdhbcebiea(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I), width(I)))  # Initialize output grid
  for obj in objects(I, T, F, T):  
    O = paint(O, shift(recolor(8, outbox(toindices(obj))), (1, 1))) # Draw outline
  return O
 
95.5, tensor(1.7686), Description: Replace the outline of each object in the grid with '8's. The background of the grid should be the same color as the original background. The outline is defined as the cells that are directly adjacent to the object's cells and are also adjacent to a cell that is part of the object. 
:: def fdaichbfgegeeebcicjeijaaaeaifefe(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, T, F, T):
    for cell in delta(toindices(obj)):
      if any(adjacent(initset(neighbor), toindices(obj)) for neighbor in dneighbors(cell)):
        O = fill(O, 8, {cell}) 
  return O
 
99.75, tensor(1.0513), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box two spaces to the right and two spaces down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted two spaces to the right and two spaces down, and the bounding box painted with the color '8'. Finally, trim the output grid to remove any extra border cells. 
:: def ggfibceafeggeaafjfjeaecbgahhgeec(I):
  bg = mostcolor(I)
  O = canvas(bg, add(shape(I), (2,2)))
  O = paint(O, shift(asobject(I), (1,1)))
  for obj in objects(I, T, F, T):
    O = underfill(O, 8, shift(outbox(toindices(obj)), (2, 2)))
  return trim(O)
 
81.0, tensor(1.9827), Description: Replace all non-'9' cells in the grid with '8's if they are in the same row as the first non-'9' cell. The rest of the grid should be filled with '9's. 
:: def cdaaddjfehfeedjbadbbgeeagidbbhcd(I):
    O = canvas(9, shape(I)) # Create a canvas of 9s with the same shape as input
    for i in range(height(I)):
        for j in range(width(I)):
            if I[i][j] != 9:  # Find the first non-9 cell (object)
                O = fill(O, 8, ((i, j), (i, width(I)-1))) # Fill horizontally from object to the right edge
                break # Move to the next row
    O = cellwise(I, O, I[0][0]) # Merge the original objects onto the canvas
    return O
 
82.25, tensor(0.1323), Description: For each object in the grid, draw a horizontal line of '8's from the leftmost column of the object to the right edge of the grid. The rest of the grid should remain unchanged. 
:: def egfhdcbbbhcaebcbjdhaibbcfcdaccia(I):
  objs = objects(I,T,F,T) # Get all objects in the grid
  O = I
  for obj in objs:
    leftmost_j = leftmost(obj) # Find the leftmost column of the object
    for i in range(uppermost(obj), lowermost(obj)+1): # For each row the object occupies
      O = fill(O, 8, ((i, leftmost_j), (i, width(I)-1))) # Fill from leftmost column to right edge
  return O 
 
74.25, tensor(1.9827), Description: Replace all non-'9' cells in the grid with '8's if they are in the same row as the first non-'9' cell. The rest of the grid should be filled with '9's. 
:: def bfifbcfbjecfeadeadibejeacibdafgb(I):
    O = I
    for i, row in enumerate(I):
        try:
            first_obj_index = row.index(next(filter(lambda x: x != 9, row))) # Find first non-9 cell
            O = fill(O, 8, ((i, first_obj_index), (i, width(I)-1))) # Fill to the right
        except StopIteration: # Handle rows with no objects
            pass
    return O
 
82.75, tensor(0.1024), Description: Replace the outline of each object in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells, shifted one space to the right and one space down. 
:: def jcddfcfebceaegeeaddedgbiaacbjcec(I):
  def border_indices(obj):
    return combine(shift(toindices(obj), RIGHT), shift(toindices(obj), DOWN))
  return paint(I, recolor(8, merge(apply(border_indices, objects(I, T, F, T))))) 
 
74.5, tensor(0.1207), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. The grid is expanded by one cell to the right and two cells to the bottom. 
:: def bfcaefeaddegejddieaiafdddabcedei(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = canvas(bg, (height(I) + 2, width(I) + 3)) 
  for obj in objs:
    for v, (i, j) in obj:
      O = paint(O, {(v, (i, j))})
      if j < width(I) - 1 and I[i][j + 1] == bg:
        O = paint(O, {(8, (i, j + 1))})
  return O
 
63.0, tensor(0.1203), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. The grid is expanded by one cell to the right and three cells to the bottom. 
:: def achbajgdcedaecgeidbabcjicdgeadee(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 3))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      O = paint(O, {(v, (i, j))})
      if j < width(I) - 1 and I[i][j + 1] == bg:
        O = paint(O, {(8, (i, j + 1))})
  return O
 
125.0, tensor(0.1242), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. The grid is expanded by three cells to the right and two cells to the bottom. 
:: def bbeiedfbdfbfechhabefdecjebhacddf(I):
  bg = mostcolor(I)
  extended_grid = hconcat(I, canvas(bg, (height(I), 3)))
  O = vconcat(extended_grid, canvas(bg, (2, width(extended_grid))))
  return paint(O, recolor(8, {(i, j + 1) for i, r in enumerate(I) for j, v in enumerate(r) if j < width(I) - 1 and I[i][j + 1] == bg}))
 
67.5, tensor(0.1203), Description: Replace all cells in the grid with '8's if they are part of an object and have a neighbor to the right that is the same color as the background. The rest of the grid should be filled with the background color. The grid is expanded by one cell to the right and three cells to the bottom. 
:: def cageffdjddbdeadcicicededdfadaddf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = canvas(bg, (height(I) + 2, width(I) + 3))
  for obj in objs:
    O = paint(O, obj)
    right_neighbors = {(i, j + 1) for v, (i, j) in obj if j < width(I) - 1}
    extension = toobject(intersection(right_neighbors, asindices(I)), I)
    O = paint(O, recolor(8, extension)) 
  return O
 
93.75, tensor(1.0936), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. The background of the grid should be the same color as the original background. 
:: def fdfgjfdddaededfeifffgeefccafeddc(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))  # Initialize canvas with input shape
  for obj in objects(I, True, False, True):
    O = paint(O, obj) # Paint object on the canvas
    O = underfill(O, 8, shift(backdrop(toindices(obj)), (1, 1))) # Draw shifted backdrop
  return O
 
113.0, tensor(1.0770), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8', but only for the cells that are not part of the shifted object itself. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8', except for the cells that were originally part of the object. The background of the grid should be the same color as the original background. 
:: def dfcdjdfjbfeeejgijbiecagegbcjifhb(I):
  bg = mostcolor(I)
  O = canvas(bg, (height(I) + 2, width(I) + 2))  # Canvas with a 2-cell border
  for i, r in enumerate(I):
    for j, v in enumerate(r):
      O = fill(O, v, {(i + 1, j + 1)}) # Place input onto canvas cell by cell
  for obj in objects(I, True, False, True):
    shifted_box = shift(outbox(toindices(obj)), (1, 1))
    for i, j in shifted_box:
      if 0 <= i < height(O) and 0 <= j < width(O) and O[i][j] == bg:
        O = fill(O, 8, {(i, j)})  # Fill only if within bounds and background
  return O
 
102.5, tensor(1.7000), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def aadaeecbgddhedggbbddceiiceehcgge(I):
  def extend_left(obj):
    if color(obj) != 1:
      return frozenset()
    min_j = leftmost(obj)
    return frozenset((8, (i, k)) for i, j in toindices(obj) for k in range(min_j - 1, -1, -1) if index(I, (i, k)) == 9)
  return paint(I, merge(apply(extend_left, objects(I, True, False, True)))) 
 
98.75, tensor(1.7000), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def eacdddbgbaheejajbgfcfajheaidhaah(I):
  objs = objects(I, True, False, True)
  new_cells = set()
  for obj in objs:
    if color(obj) == 1:
      for i in range(uppermost(obj), lowermost(obj) + 1):
        for j in range(leftmost(obj) - 1, -1, -1):
          if index(I, (i, j)) == 9:
            new_cells.add((8, (i, j)))
          else:
            break
  return paint(I, frozenset(new_cells))
 
93.5, tensor(1.9828), Description: Replace all '9's in the grid with '8's if they are to the left of a '1' in the same row. The rest of the grid should remain unchanged. 
:: def bebgccehbbededcdicchffhcibadhfef(I):
  h, w = len(I), len(I[0])
  def fill_row(i):
    for j in range(w):
      if I[i][j] == 1:
        return tuple(8 if v == 9 else v for v in I[i][:j]) + I[i][j:]
    return I[i]
  return tuple(fill_row(i) for i in range(h))
 
80.5, tensor(0.1191), Description: Copy the input grid and shift all objects one space to the right. Then, replace all cells in the original objects with '8's. The background of the grid should be the same color as the original background. 
:: def ddededaiehfcedddacdjbheaeaaieicf(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, True, False, True)  # Extract connected objects (excluding background)
  shifted_objs = frozenset(shift(obj, (0,1)) for obj in objs)  # Shift each object to the right
  recolored_objs = frozenset(recolor(8, obj) for obj in objs) # Recolor original objects to 8
  O = paint(canvas(bg, shape(I)), merge(shifted_objs | recolored_objs))  # Paint shifted and recolored objects onto a blank canvas
  return O
 
74.25, tensor(1.9762), Description: Replace the outline of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells and are not part of the object itself. 
:: def gfjbddfegceaeijiacggbhedcgaccaea(I):
  c = leastcolor(I)  # Find the least common color 
  objs = objects(I, True, False, True)  # Identify objects, excluding background
  obj = extract(objs, lambda o: color(o) == c)  # Extract the object with the least common color
  outline = difference(box(obj), toindices(obj))  # Calculate the outline indices
  O = paint(I, recolor(EIGHT, outline)) # Paint the outline with 8
  return O
 
62.0, tensor(1.9762), Description: Replace all cells adjacent to the least common color in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells and are not part of the object itself. 
:: def ejeeibgbcfchecfdaiacdiadfiefcfec(I):
  target_color = leastcolor(I)
  padded_grid = canvas(mostcolor(I), (len(I) + 2, len(I[0]) + 2)) # Create a padded grid with background color
  padded_grid = paint(padded_grid, shift(asobject(I), (1, 1))) # Place the input grid in the center of the padded grid

  outline_indices = set()
  for i in range(1, len(padded_grid) - 1):
    for j in range(1, len(padded_grid[0]) - 1):
      if padded_grid[i][j] == target_color:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          if padded_grid[i + di][j + dj] != target_color:
            outline_indices.add((i - 1, j - 1))  # Adjust indices back to the original grid

  O = fill(I, EIGHT, frozenset(outline_indices)) # Fill outline indices in the original grid with 8
  return O
 
94.0, tensor(1.0953), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. Finally, paint the original objects on top of the shifted bounding boxes. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8', with the original objects on top. The background of the grid should be the same color as the original background. 
:: def cbdjhfadecgdebdeiaaadbgciaidfdfb(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    O = canvas(bg, shape(I))
    for obj in objs:
        O = paint(O, shift(recolor(8, outbox(toindices(obj))), (1, 1))) # Recolor and then shift the outbox
    O = paint(O, shift(asobject(I), (1, 1)))  # Finally, paint the original objects on top
    return O
 
109.5, tensor(1.0936), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. The background of the grid should be the same color as the original background. 
:: def gfehcecabjdgeahgbecefhehbegfjcef(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    O = canvas(bg, (height(I) + 2, width(I) + 2))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != bg:
                O = fill(O, val, {(i + 1, j + 1)}) # Place non-background cells 
    for obj in objs:
        for di, dj in [(0, 1), (1, 0), (1, 1), (1, 2), (2, 1), (0, -1), (-1, 0), (-1, -1), (-1, 1), (1, -1)]: # Define relative outbox offsets
            O = underfill(O, 8, shift(obj, (di, dj)))  # Draw the outbox by shifting the object itself
    return O
 
80.5, tensor(0.1046), Description: Copy the input grid. For each object in the input grid, find the outline of the object. Shift the outline one space to the right. Then, paint the shifted outline onto the output grid, using the color '8'. The result should be a grid with each object's outline shifted one space to the right, and the outline painted with the color '8'. The background of the grid should remain unchanged. 
:: def aehdicffdjeheideibfiafgebaedbdhb(I):
  objs = objects(I, T, F, T)  # Identify objects without background
  borders = mapply(lambda obj: delta(toindices(obj)), objs) # Calculate border indices
  shifted_borders = shift(borders, RIGHT) # Shift border indices to the right
  return underpaint(I, recolor(8, shifted_borders)) # Paint shifted borders on the grid
 
81.0, tensor(0.1292), Description: For each object in the grid, extend it to the right with '8's. The extension length should be one more than the object's width. The background of the grid should be the same color as the original background. The grid is expanded by three cells to the right. 
:: def caiecaabbfdceeedihabiegbhdcbggdg(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    O = canvas(bg, (height(I), width(I) + 3))  # Wider canvas
    for obj in objs:
        extension_width = width(obj) + 1  # Extension width based on object width
        O = paint(O, obj | {(8, (i, j)) for i in range(uppermost(obj), lowermost(obj) + 1)
                        for j in range(rightmost(obj) + 1, rightmost(obj) + 1 + extension_width)})
    return O
 
164.0, tensor(0.1939), Description: For each object in the grid, extend it to the right with '8's until the right edge of the grid is reached. The background of the grid should be the same color as the original background. The grid is expanded to the right by the maximum width of any object plus one. 
:: def afdgdabbacacegdcidhfiacgbcichdeg(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    O = canvas(bg, (height(I), width(I) + max(width(obj) for obj in objs) + 1))
    for obj in objs:
        O = paint(O, obj)
        O = underfill(O, 8, {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(rightmost(obj) + 1, width(O))})
    return O
 
82.25, tensor(1.9762), Description: Replace the outline of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells and are not part of the object itself. 
:: def cediicifgbabejafaejfdfafbafccbbc(I):
  least_color = leastcolor(I)  # Find the least common color
  objs = objects(I, True, False, True) # Extract all objects
  target_obj = extract(objs, lambda obj: color(obj) == least_color) # Find the object with the least common color
  outline = outbox(target_obj) # Find the outbox of the object
  O = paint(I, recolor(EIGHT, outline)) # Paint the outline on the grid
  return O
 
115.5, tensor(1.9762), Description: Replace the outline of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells and are not part of the object itself. 
:: def ajfchbddbehbeaiebgfhaiaaaffbcheb(I):
  target_color = leastcolor(I)
  objs = objects(I, True, False, True)
  def outline_obj(obj):
    if color(obj) == target_color:
      return recolor(EIGHT, outbox(obj))
    else:
      return obj
  outlined_objects = apply(outline_obj, objs)
  O = paint(I, merge(outlined_objects))
  return O
 
107.5, tensor(0.6791), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Paint the bounding box of the object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box painted with the color '8'. The background of the grid should be the same color as the original background. 
:: def hiefbebcbdeeeijdjdfjceeeibfcdbdd(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  O = canvas(bg, add(shape(I), (1, 1))) # Canvas with one extra row and column
  O = paint(O, shift(asobject(I), (0, 0)))  # Place input directly onto canvas
  for obj in objs:
    O = underfill(O, 8, outbox(toindices(obj)))  # Draw the outbox directly
  return O
 
102.75, tensor(1.0216), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Paint the bounding box of the object onto the output grid, using the color '8', but only for the cells that are not part of the shifted object itself. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8', except for the cells that were originally part of the object. The background of the grid should be the same color as the original background. 
:: def bbeeacdjdcbeeeceacfdadcfaigbgjej(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  O = canvas(bg, (height(I) + 1, width(I) + 1))  # Create canvas
  for i in range(height(I)):
    for j in range(width(I)):
      O = fill(O, I[i][j], {(i, j)})  # Place input cell by cell
  for obj in objs:
    for i, j in outbox(toindices(obj)):
      if 0 <= i < height(O) and 0 <= j < width(O):  # Check boundary conditions
        O = underfill(O, 8, {(i, j)})  # Draw '8' at the outbox index
  return O
 
105.25, tensor(1.0936), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8'. The background of the grid should be the same color as the original background. 
:: def ddbccceeeeadedfjibgahfiiigebhdei(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    O = canvas(bg, (height(I) + 1, width(I) + 1)) # Create an expanded canvas
    for i in range(height(I)):
        for j in range(width(I)):
            O = fill(O, I[i][j], {(i, j)}) # Place the input grid onto the expanded canvas
    for obj in objs:
        for di in [-1, 0, 1]:
            for dj in [-1, 0, 1]:
                if (di != 0 or dj != 0): # Exclude the object itself
                    O = underfill(O, 8, shift(toindices(obj), (di, dj)))  # Draw the shifted outbox for each object
    return O
 
73.0, tensor(1.7000), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the leftmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def cbejeaciaddeedefafdcdhdafcbcjeaf(I):
  obj = next(iter(objects(I, True, False, True)))
  fill_ranges = {}
  for v, (i, j) in obj:
    if v == 1:
      start = j
      while start > 0 and (1, (i, start-1)) in obj:
        start -= 1
      fill_ranges[(i, j)] = start
  filled_cells = frozenset((8, (i, k)) for (i, j), start in fill_ranges.items() for k in range(start, j))
  return paint(I, filled_cells)
 
97.0, tensor(1.9827), Description: Replace all '1's in the grid with '8's if they are also '9's in the horizontally mirrored version of the grid. The rest of the grid should remain unchanged. 
:: def dgfhefcheheheechaebebacdcdehddcf(I):
  obj = next(iter(objects(I, True, False, True)))
  mirrored_I = hmirror(I)
  def fill_condition(i, j):
    return 8 if (1, (i, j)) in obj and mirrored_I[i][j] == 9 else I[i][j]
  return hmirror(tuple(tuple(fill_condition(i, j) for j in range(len(I[0]))) for i in range(len(I))))
 
133.25, tensor(0.1285), Description: Copy the input grid and expand it to the right by the maximum height of any object in the grid. Then, for each object, shift it down by the maximum height of any object in the grid. Finally, replace the cells to the right of each object with '8's, starting from the rightmost column of the original object and extending to the right edge of the grid, but only for the cells that are within the maximum height of the object. The background of the grid should be the same color as the original background. 
:: def dafdbiciebahegdjjbacfihbiefdfehd(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  O = canvas(bg, (height(I), width(I) + max(height(obj) for obj in objs)))
  for obj in objs:
    O = paint(O, shift(obj, (0, max(height(obj) for obj in objs))))
    O = paint(O, recolor(8, {(i, j + 1) for v, (i, j) in obj if j < width(I) - 1 and j >= width(I) + max(height(obj) for obj in objs) - width(obj) - 1}))
  return O
 
135.5, tensor(0.1285), Description: Copy the input grid and expand it to the right by the maximum height of any object in the grid. Then, for each object, shift it down by the maximum height of any object in the grid. Finally, replace the cells to the right of each object with '8's, starting from the rightmost column of the original object and extending to the right edge of the grid, but only for the cells that are within the maximum height of the object. The background of the grid should be the same color as the original background. 
:: def fgifcaceffiaefecbdegcjafaafdhbfe(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  max_height = max(height(obj) for obj in objs)
  O = canvas(bg, (height(I), width(I) + max_height))
  for obj in objs:
    O = paint(O, shift(obj, (0, max_height)))
    extension = recolor(8, {(i, j) for v, (i, j) in shift(obj, (0, max_height)) if j >= width(I) and j < width(I) + height(obj)})
    O = paint(O, extension)
  return O
 
86.75, tensor(1.9762), Description: Replace the outline of the object with the least common color in the grid with '8's. The rest of the grid should remain unchanged. The outline is defined as the cells that are directly adjacent to the object's cells and are not part of the object itself. 
:: def efchdahcbdafeabbaijeefacediabcgb(I):
  min_color = leastcolor(I) # Find the least common color
  # Get indices of cells with the least common color
  object_idx = frozenset((i, j) for i, row in enumerate(I) for j, val in enumerate(row) if val == min_color) 
  # Calculate the outbox and recolor it to 8
  outlined_idx = recolor(EIGHT, outbox(object_idx)) 
  O = paint(I, outlined_idx) # Paint the outlines onto the original grid
  return O
 
93.5, tensor(1.0953), Description: Copy the input grid and expand it by one cell in each direction. Then, for each object in the input grid, find the smallest rectangle that encloses the object (the bounding box). Shift the bounding box one space to the right and one space down. Then, paint the bounding box of the shifted object onto the output grid, using the color '8'. Finally, paint the original objects on top of the shifted bounding boxes. The result should be a grid with each object's bounding box shifted one space to the right and one space down, and the bounding box painted with the color '8', with the original objects on top. The background of the grid should be the same color as the original background. 
:: def cffjjffgfbaeehaeabdiafdjdfabbife(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  O = canvas(bg, add(shape(I), (2, 2)))
  for obj in objs:
    O = underfill(O, 8, shift(outbox(toindices(obj)), (1, 1)))  # Draw outbox first
  for i in range(height(I)):
    for j in range(width(I)):
      O = fill(O, I[i][j], {(i + 1, j + 1)})  # Then place input grid onto canvas
  return O
 
65.75, tensor(1.9828), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the rightmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def bhhfjbibceeeeecgacfgfiifahcfidda(I):
  O = canvas(9, (height(I), width(I) + 1)) # Create a canvas one column wider than input
  for i, row in enumerate(I): # Iterate through rows
    for j, value in enumerate(row):
      O = fill(O, value, ((i, j), (i, j))) # Copy input values to output
      if value == 1: # If the current cell is part of the object
        for k in range(j + 1, width(O)): # Check from next column to the right edge
          if index(I, (i, k)) != 9: # Stop if another object is encountered
            break
          O = fill(O, 8, ((i, k), (i, k))) # Fill with extension color
  return O
 
94.5, tensor(1.9827), Description: Replace all '1's in the grid with '8's, except for '1's that are the last '1' in their row. For each '1' that is not the last in its row, draw a horizontal line of '8's from the '1' to the rightmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def hbahibbffbacejidbhbbbeeadfaefecj(I):
  O = canvas(9, shape(I)) # Initialize output grid with background
  for obj in objects(I, True, False, True): # Iterate through objects
    if color(obj) == 1: # Process only objects with target color
      for i in range(uppermost(obj), lowermost(obj) + 1): # For each row occupied by the object
        j = rightmost(obj) + 1 # Start from the column right of the object
        while j < width(I) and index(I, (i, j)) == 9: # Extend right until a non-background cell
          O = fill(O, 8, ((i, j), (i, j))) # Fill with extension color
          j += 1
    O = paint(O, obj) # Paint the original object on the modified grid
  return O
 
104.0, tensor(1.9827), Description: Replace all '1's in the grid with '8's, except for '1's that are the last '1' in their row. For each '1' that is not the last in its row, draw a horizontal line of '8's from the '1' to the rightmost non-'1' cell in that row. The rest of the grid should remain unchanged. 
:: def ghcacadbfegjefhebfbajhfgbdjgaecc(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        k = j + 1
        while k < width(I) and index(I, (i, k)) == 9:
          O = fill(O, 8, ((i, k), (i, k)))
          k += 1
  return O
 
80.5, tensor(1.9828), Description: Replace all '1's in the grid with '8's, except for '1's that are the first '1' in their row. For each '1' that is not the first in its row, draw a horizontal line of '8's from the '1' to the rightmost non-'1' cell in that row. The rest of the grid should be filled with '9's. 
:: def bafabjidgfbfeedhjgebbidcebhdjeed(I):
  O = canvas(9, shape(I))
  objs = objects(I, True, False, True)
  for obj in objs:
    if color(obj) == 1:
      min_row, max_row = uppermost(obj), lowermost(obj)
      leftmost_col = leftmost(obj)
      for i in range(min_row, max_row + 1):
        for j in range(leftmost_col, width(I)):
          if index(I, (i, j)) == 9:
            O = fill(O, 8, ((i, j), (i, j)))
          else:
            break
    O = paint(O, obj) 
  return O
 
