18.333333333333332, tensor(0.3532), Description: Copy the input grid. Then, for each colored square, draw a black square of the same size and shape around it. The black square should be one square away from the colored square. If the colored square is on the edge of the grid, then the black square should be partially off the grid. 
:: def ajcefebhaecfeeddjahecacjgdbjjcca(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  inverted_objs = frozenset(recolor(ZERO, obj) for obj in objs)
  O = paint(fill(I, bg, asindices(I)), merge(inverted_objs))
  return O
 
7.666666666666667, tensor(0.0811), Description: Copy the input grid. Then, identify the largest object (by area) and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def bgeajaaddgacejabideebafcchceaech(I):
    # Identify all connected objects, excluding background
    x1 = objects(I, T, T, T) 
    
    # Find the largest object
    x2 = argmax(x1, size)
    
    # Cover the input grid with '0' 
    x3 = canvas(0, shape(I))  
    
    # Paint the largest object onto the '0' canvas
    O = paint(x3, x2)  
    
    return O
 
7.666666666666667, tensor(0.0811), Description: Copy the input grid. Then, identify the largest object (by area) and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def ddfjacddjfageegcjaedjdhcdfjceehc(I):
    # Find all connected objects
    x1 = objects(I, T, T, F)
    
    # Sort objects by size in descending order
    x2 = order(x1, size)
    
    # Get the largest object (first element after sorting)
    x3 = first(x2)
    
    # Create a blank canvas
    x4 = canvas(0, shape(I))
    
    # Paint the largest object onto the canvas
    O = paint(x4, x3)
    return O
 
18.333333333333332, tensor(0.0811), Description: Copy the input grid. Then, identify the largest object (by area) and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def hgdgfdafdcdgeechicebdeiaehihacdh(I):
    # Partition the grid based on color, effectively separating objects
    x1 = partition(I) 
    
    # Find the largest object based on its size
    x2 = argmax(x1, size)
    
    # Create a blank canvas of 0s
    x3 = canvas(0, shape(I))  
    
    # Overlay the largest object on the canvas
    O = paint(x3, x2)  
    
    return O
 
8.666666666666666, tensor(0.0791), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, change the cell's color to black. Otherwise, keep the cell's color the same. 
:: def cbfgehbbdheaedbajaaijhjiehfbfeeb(I):
    # Directly find the background color
    bg = mostcolor(I)
    
    # Create a lambda function to check for non-background colors
    is_not_bg = lambda x: x != bg
    
    # Apply the lambda function to each cell in the grid
    O = apply(lambda row: tuple(0 if not is_not_bg(cell) else cell for cell in row), I)
    
    return O
 
18.666666666666668, tensor(0.1578), Description: Copy the input grid. Then, find the largest object (by area) that is not a single-colored square and draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def iibhfechjaehedfcjcdhbcjdfdedahfb(I):
    x1 = objects(I, False, False, True) # Extract objects, not univalued, no diagonals, without background
    x2 = argmax(x1, size) # Find the largest object by size
    x3 = toindices(x2) # Get the indices of the largest object
    x4 = outbox(x3) # Get the indices of the outer box around the object
    O = fill(I, 0, x4) # Fill the outer box indices with 0
    return O
 
12.333333333333334, tensor(0.5566), Description: Copy the input grid. Then, identify the object with the most non-background colors (i.e., the object with the most colors other than the background color). Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def cebfcjffieebecfdjeidbhfcefgjaadd(I):
    x1 = mostcolor(I) # Find the most common color (background)
    x2 = objects(I, True, True, True) # Extract objects, univalued, with diagonals, without background
    x3 = lambda obj: colorcount(obj, other(palette(obj), x1)) # Function to count non-background colors in an object
    x4 = argmax(x2, x3) # Find object with the most non-background cells
    x5 = toindices(x4) # Get indices of the largest object
    x6 = box(x5) # Get the indices of the box surrounding the object 
    O = fill(I, 0, x6) # Fill the box indices with 0
    return O
 
14.666666666666666, tensor(1.1644), Description: Copy the input grid. Then, identify the object with the largest delta (the number of cells that are adjacent to the object but not part of the object). Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def ihcafhhgeicjecjfjhfdaegagfjbeihe(I):
    x1 = objects(I, False, False, True)  # Extract objects, not univalued, no diagonals, without background
    x2 = lambda obj: len(delta(toindices(obj)))  # Function to calculate the number of cells in the delta of an object
    x3 = argmax(x1, x2)  # Find the object with the largest delta
    x4 = toindices(x3) # Get the indices of the object with largest delta
    x5 = delta(x4) # Get the indices of the delta 
    O = fill(I, 0, x5) # Fill the delta indices with 0
    return O
 
16.0, tensor(1.1645), Description: Copy the input grid. Then, identify the largest object (by number of cells) that is not a single-colored square and draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def dbbaefdefbfeedffacehfgchbejdcgbe(I):
    x1 = objects(I, False, False, True)  # Extract objects, not univalued, no diagonals, without background
    x2 = argmax(x1, len)  # Find the largest object by number of cells
    x3 = toindices(x2) # Get the indices of the largest object
    x4 = box(x3) # Get the indices of the box surrounding the object
    x5 = x4 - x3 # Get the indices of the outline (box - object)
    O = fill(I, 0, x5) # Fill the outline indices with 0
    return O
 
14.666666666666666, tensor(0.1555), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square and draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def debhbcibajdcebbdbcfbjecdagcabdbj(I):
    x1 = objects(I, False, False, True)  # Extract objects, not univalued, no diagonals, without background
    x2 = argmax(x1, size) # Find the largest object by size
    x3 = toindices(x2) # Get the indices of the largest object
    x4 = rbind(contained, x3) # Create a function to check if an index is in the object
    x5 = asindices(I)  # Get all indices of the input grid
    x6 = sfilter(x5, lambda loc: any(x4(n) for n in neighbors(loc)))  # Filter for indices whose neighbors intersect the object
    x7 = x6 - x3 # Get the indices that are neighbors of the object but not part of it
    O = fill(I, 0, x7) # Fill those indices with 0
    return O
 
8.666666666666666, tensor(1.9820), Description: Copy the input grid. Then, replace all instances of the most common color (the background color) with black. 
:: def bddjiaecbhddefbhiahjfifbdiiefcci(I):
    bg = mostcolor(I)  # Identify the background color
    O = replace(I, bg, 0) # Replace background color with 0
    return O 
 
13.333333333333334, tensor(1.7838), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def eaecffdibhedejggbddfbfdbcfdiaegf(I):
  bg = mostcolor(I)
  O = canvas(0, shape(I)) # Create a canvas of 0s with the same shape as input
  objs = objects(I, False, False, False) # Get all objects in the grid
  for obj in objs:
    if color(obj) != bg: # If object is not the background color
      O = paint(O, obj) # Paint the object onto the canvas
  return O
 
7.666666666666667, tensor(1.8423), Description: Copy the input grid. Then, draw a cross shape in the center of the grid using the color of the center cell. The cross should be one cell thick and should extend to the edges of the grid. 
:: def jdbbcdabagiaeaahaedacecgeeiaaaab(I):
  # Find the center of the grid
  h, w = len(I), len(I[0])
  center = (h // 2, w // 2)

  # Get the value at the center
  center_value = I[center[0]][center[1]]

  # Create a canvas of zeros with the same shape as the input
  O = canvas(0, (h, w))

  # Fill in the cross shape
  O = fill(O, center_value, {center})  # Center
  O = fill(O, center_value, {(center[0], center[1] - 1)})  # Left
  O = fill(O, center_value, {(center[0], center[1] + 1)})  # Right
  O = fill(O, center_value, {(center[0] - 1, center[1])})  # Up
  O = fill(O, center_value, {(center[0] + 1, center[1])})  # Down

  return O
 
13.666666666666666, tensor(0.1976), Description: Copy the input grid. Then, identify the object that contains the center of the grid and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def dagjbehgejcjecejiebdfbhddihiihfa(I):
  # Partition the grid into objects
  objs = partition(I)

  # Find the object containing the center
  center_obj = extract(objs, lambda obj: centerofmass(obj) == centerofmass(asindices(I)))

  # Create a blank canvas
  O = canvas(0, shape(I))

  # Paint the center object onto the canvas
  O = paint(O, center_obj)

  return O
 
10.333333333333334, tensor(1.8428), Description: Copy the input grid. Then, draw a horizontal line across the center row and a vertical line down the center column using the color of the center cell. The lines should be one cell thick and should extend to the edges of the grid. 
:: def gbjfebeaefdaeibbjhchgddchddefaai(I):
  # Find the center of the grid
  h, w = len(I), len(I[0])
  center = (h // 2, w // 2)

  # Get the value at the center
  center_value = I[center[0]][center[1]]

  # Create a canvas of zeros 
  O = canvas(0, (h, w))

  # Fill the central row and column
  O = fill(O, center_value, {(i, center[1]) for i in range(h)})
  O = fill(O, center_value, {(center[0], j) for j in range(w)})

  return O
 
10.333333333333334, tensor(1.8424), Description: Copy the input grid. Then, draw a 3x3 square in the center of the grid using the color of the center cell. The square should be one cell thick and should extend to the edges of the grid. 
:: def deaadjjfbcaaefebjejhdjddceaefdee(I):
  h, w = len(I), len(I[0])
  center = (h // 2, w // 2)
  center_value = I[center[0]][center[1]]
  return tuple(
      tuple(
          center_value if abs(i - center[0]) <= 1 and abs(j - center[1]) <= 1 else 0 
          for j in range(w)
      ) 
      for i in range(h)
  )
 
16.666666666666668, tensor(1.4649), Description: Copy the input grid. Then, for each object in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def bdhbdgbefcgiejfdbedcgghceedfcddb(I):
  # 1. Partition the grid into objects.
  x1 = partition(I)
  # 2.  For each object, get its outline indices.
  x2 = mapply(box, x1) 
  # 3.  Fill the outline indices with the background color.
  O = fill(I, mostcolor(I), x2)
  return O
 
18.333333333333332, tensor(1.9811), Description: Copy the input grid. Then, remove all the colored squares, leaving only the black squares. Then, paint the colored squares back onto the grid, but only the outlines of the squares. The output grid should have only the outlines of the colored squares on a black background. 
:: def efigibjhfjfdebaebbafjccbccfcgbcd(I):
  # 1. Get all object outlines in the grid.
  x1 = frontiers(I)
  # 2.  Remove the object outlines from the grid. 
  x2 = compress(I)
  # 3.  Paint the object outlines back onto the compressed grid.
  O = paint(x2, merge(x1))
  return O
 
16.0, tensor(0.2551), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as its row and column number and it's not the background color, keep the cell's color the same. Otherwise, change the cell's color to the background color. 
:: def egejhgdeceaeejfdjajfjfdddfdajieh(I):
  bg = mostcolor(I)
  return tuple(
    tuple(
      I[i][j] if i == j and I[i][j] != bg else bg 
      for j in range(len(I[0]))
    ) 
    for i in range(len(I))
  )
 
16.0, tensor(1.7667), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. Then, for each object, paint a diagonal line of the same color from the top left corner to the bottom right corner. The diagonal line should be one cell thick and should extend to the edges of the grid. 
:: def cedfjjcdjadeebdbadbjbibagdfdhegi(I):
    bg = mostcolor(I)
    objs = objects(I, True, True, True)
    diag_objs = frozenset({(color(obj), (i, i)) for obj in objs for _, (i, i) in obj if i < len(I[0]) and i < len(I)})
    return paint(canvas(bg, shape(I)), diag_objs) 
 
8.0, tensor(0.2256), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as its row and column number and it's not the background color, keep the cell's color the same. Otherwise, change the cell's color to the background color. 
:: def jbceaafabafgecegjcefbegcahhddbca(I):
  bg = mostcolor(I)
  return tuple(
      tuple(
          0 if i != j or cell == bg else cell
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
18.0, tensor(0.1556), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def efcciaeacaddejcbabecbejcbedajgae(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, False, False, True)  # Extract objects without background
  for obj in objs:
    outline = box(toindices(obj))  # Find the outline of each object
    to_fill = difference(toindices(obj), outline)  # Cells to fill are those inside the outline
    I = fill(I, bg, to_fill)  # Fill those cells with the background color
  return I
 
14.0, tensor(0.2098), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a hollow version of the object by filling the inside with the background color and leaving only the outline. Paint these hollow objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def jjbbeideedgdehbfieihcbffaeibfahg(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  hollow_objs = apply(lambda obj: recolor(bg, difference(toindices(obj), box(toindices(obj)))), objs)
  return paint(canvas(bg, shape(I)), merge(hollow_objs))
 
17.0, tensor(1.1597), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are adjacent to the object's outline. Recolor this new object with the original object's color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def gdehddccbiffeeagbcdaejaehajbbega(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(color(obj), sfilter(toindices(obj), lambda ind: any(n in delta(toindices(obj)) for n in neighbors(ind)))), objs))) 
 
8.666666666666666, tensor(1.0121), Description: Copy the input grid. Then, replace all instances of the most common color (the background color) with black. 
:: def acdecafcibciegccaeafejegeficfbdj(I):
  # Find indices of all cells with the most common color (background).
  x1 = ofcolor(I, mostcolor(I))
  # Fill those indices with zeros in the original grid.
  O = fill(I, ZERO, x1)
  return O
 
18.0, tensor(1.5104), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color, change the cell's color to a different color that is not the background color. Otherwise, keep the cell's color the same. 
:: def dhcbdcebffdieeecihhcfhchbecbcied(I):
  # Find the most common color (background)
  bg = mostcolor(I)
  # Get all indices of the grid
  indices = asindices(I)
  # Filter indices to get those with the background color
  bg_indices = sfilter(indices, lambda loc: index(I, loc) == bg)
  # Invert the colors by filling background indices with a non-background color
  O = fill(I, other(palette(I), bg), bg_indices)
  return O
 
12.333333333333334, tensor(1.5072), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, invert the color of the object and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def ecdhhahicgebebefjbegbgciafdeeedj(I):
  # Invert colors using object representation
  objs = objects(I, T, F, F)
  inverted_objs = frozenset(recolor(other(palette(I), color(obj)), obj) for obj in objs)
  O = paint(canvas(mostcolor(I), shape(I)), merge(inverted_objs))
  return O
 
17.333333333333332, tensor(1.1546), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the outline of the original object. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def dccedbacjceaejhfacbcegjjfcddaadb(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  frame = lambda obj: obj - toobject(inbox(obj), I) #Removes inner cells by subtracting the 'inbox' area from the object
  return paint(canvas(bg, shape(I)), merge(apply(frame, objs))) 
 
19.666666666666668, tensor(1.1546), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the outline of the original object. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def ffbhacfadccbeacdbiajbcgcacjiabec(I):
    bg = mostcolor(I)
    objs = objects(I, T, T, T)
    def get_frame(obj):
        obj_indices = toindices(obj)
        return frozenset((color(obj), loc) for loc in obj_indices if any(n not in obj_indices for n in dneighbors(loc)))
    return paint(canvas(bg, shape(I)), merge(apply(get_frame, objs)))
 
15.666666666666666, tensor(0.1556), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def dbifffdgabebecdcjfbafjffbhhgcbdj(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, False, False, True)  # Extract objects without background
  for obj in objs:
    outline = box(toindices(obj))  # Find the outline of each object
    I = fill(I, bg, outline)  # Fill the outline with the background color
  return I
 
8.666666666666666, tensor(0.1920), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid and the object is not bordering any other object, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def gfificijdbfjeajfagdfbbjjcfhhgacg(I):
  bg = mostcolor(I)
  O = replace(I, bg, ZERO)
  for obj in objects(I, T, F, F):
    if not bordering(obj, I):
      O = cover(O, obj)
  return O
 
16.666666666666668, tensor(0.1850), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def fdidgeaffdeeegbjjaebccgegeajfbbd(I):
  outer = box(asindices(I))
  O = canvas(ZERO, shape(I))
  for i, j in outer:
    O = fill(O, I[i][j], {(i, j)})
  return O
 
19.666666666666668, tensor(1.0064), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid and the object is bordering any other object, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. If the object is not bordering any other object, paint only the cells of the object that are within the outer box of the object onto the blank canvas. 
:: def afidefebgjffefecbaijbadcefbcjjcb(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, F):
    if bordering(obj, I):
      O = paint(O, obj) 
    else:
      for cell in obj:
        if contained(cell[1], outbox(obj)): 
          O = paint(O, {cell}) 
  return O
 
19.333333333333332, tensor(0.1916), Description: Copy the input grid. Then, for each cell in the grid, if the cell is on the edge of the grid or if the cell's color is different from any of its diagonal neighbors, keep the cell's color the same. Otherwise, change the cell's color to black. 
:: def gjbdfgideddfehadbcdcjjeeaidaahee(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for i in range(h):
    for j in range(w):
      if i == 0 or i == h - 1 or j == 0 or j == w - 1 or any(I[i][j] != I[k][l] for k, l in dneighbors((i, j))):
        O = fill(O, I[i][j], {(i, j)})
  return O
 
8.666666666666666, tensor(1.5522), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def igcfcfehcachebhhbachgfcgibcedjdd(I):
  # Identify objects 
  objs = objects(I, T, F, T)

  # Create a canvas of zeros
  O = canvas(ZERO, shape(I))

  # Paint objects onto the canvas
  for obj in objs:
    O = paint(O, obj)

  return O
 
14.666666666666666, tensor(0.3933), Description: Copy the input grid. Then, for each colored object in the grid, fill the cells surrounding the object with black. The surrounding cells should be one square away from the object. If the object is on the edge of the grid, then the surrounding cells should be partially off the grid. 
:: def egfbggcdjhhieaddibcafddcbjadaeff(I):
    # Identify objects
    objs = objects(I, T, F, T)

    # Create a set of all cells in the grid
    all_cells = asindices(I)

    # Iterate over objects, finding surrounding cells
    for obj in objs:
        surrounding_cells = difference(backdrop(obj), toindices(obj))
        # Fill surrounding cells with zeros
        I = fill(I, ZERO, surrounding_cells)
    
    O = I
    return O 
 
14.0, tensor(1.1546), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid and the object has cells that are adjacent to its own outline, create a new object that consists of only the outline of the original object. Recolor this new object with the background color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def acaccedefgjeeedbbahebcabbegecfjb(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  frames =  mfilter(objs, lambda obj: toindices(obj) & delta(toindices(obj)))
  return paint(canvas(bg, shape(I)), merge(apply(compose(rbind(recolor, bg), identity), frames)))
 
14.333333333333334, tensor(1.1601), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are adjacent to the object's outline. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def jheeadcjcafdebaaabifgfedddbicecd(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj:  toobject(delta(obj), I), objs)))
 
18.0, tensor(1.0090), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the background color. 
:: def ecefdcidbdcieidibdicbiebdcdideff(I):
  bg = mostcolor(I) # Identify the background color
  objs = objects(I, False, False, True) # Extract objects, excluding background
  largest_obj = argmax(objs, size) # Find the largest object
  bounding_box = backdrop(toindices(largest_obj)) # Get the bounding box indices
  return fill(I, bg, difference(asindices(I), bounding_box)) # Fill outside the box with background
 
19.666666666666668, tensor(1.3647), Description: Copy the input grid. Then, identify the smallest rectangle that completely encloses all the non-background colored cells. Fill all cells outside this rectangle with the background color. 
:: def ecefgacafefbefeaijiefdjbdbbbefbi(I):
  bg = mostcolor(I) # Identify the background color
  h, w = len(I), len(I[0]) # Get grid dimensions
  min_row, min_col, max_row, max_col = h, w, 0, 0
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg: # Find bounding box limits
        min_row = min(min_row, i)
        max_row = max(max_row, i)
        min_col = min(min_col, j)
        max_col = max(max_col, j)
  return tuple(tuple(bg if i < min_row or i > max_row or j < min_col or j > max_col else I[i][j] for j in range(w)) for i in range(h)) # Fill outside the bounding box
 
17.333333333333332, tensor(1.7670), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Move this object to the top left corner of the grid, so that its upper left corner is at the top left corner of the grid. The background of the output grid should be the most common color. 
:: def bcdbdeedagcbeegaajfaifjaiadcddjg(I):
  bg = mostcolor(I) # Identify the background color
  objs = objects(I, False, False, True) # Extract objects
  largest_obj = argmax(objs, size) # Find largest object
  ul = ulcorner(toindices(largest_obj))
  return paint(canvas(bg, shape(I)), shift(largest_obj, (-ul[0], -ul[1])))
 
14.0, tensor(0.3271), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid and the object is touching the outer border of the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ecicfcacjhfiejgfjaedhhcfffcfjdeg(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F) 
  filtered_objs = sfilter(objs, lambda obj: size(intersection(toindices(obj), outbox(obj))) > 0) # Keep only objects touching the outbox
  frames = mapply(box, filtered_objs)  # Get the boxes (outlines) of the remaining objects
  filled = canvas(bg, shape(I)) 
  O = paint(filled, merge(frames))
  return O 
 
16.666666666666668, tensor(1.0025), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, identify the cells that are on the outer edge of the object (those with less than 8 neighboring cells of the same color). Fill all cells except those outer edge cells with the background color. 
:: def dhfddaffjfabedeajaaaicfccfcbebaf(I):
  bg = mostcolor(I) 
  objs = objects(I, T, F, F) 
  non_bg_indices = merge(apply(toindices, objs)) # Get all indices belonging to non-background objects
  outer_indices = sfilter(non_bg_indices, lambda idx: len(intersection(neighbors(idx), non_bg_indices)) < 8) # Find indices with less than 8 neighbor indices, indicating an outer edge
  O = fill(I, bg, difference(asindices(I), outer_indices)) # Fill everything except the outer edge indices with the background color
  return O
 
19.333333333333332, tensor(1.0073), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint only the cells of the object that are touching the border of the grid onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def bjgicbacabfeedaiiiedjagahbaebgec(I):
  bg = mostcolor(I) 
  filled = canvas(bg, shape(I))  # Start with a canvas filled with the background color
  for obj in objects(I, T, F, F):
      for idx in toindices(obj):
          if any(bordering(initset(n), I) for n in neighbors(idx)):  # Check if any neighbor of the current index is on the grid border
              filled = paint(filled, {(I[idx[0]][idx[1]], idx)}) # If so, paint the cell at that index onto the canvas 
  return filled
 
7.333333333333333, tensor(1.5189), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with black. 
:: def eefbbebeaedhecfejeajcabccecdjedd(I):
  # 1. Directly find the outline of all objects (boxes, excluding background)
  objs = objects(I, T, F, T)
  outlines = mapply(box, objs)

  # 2. Combine all outlines
  outline_indices = merge(outlines)

  # 3. Fill the outlines with the object color
  O = I
  for obj in objs:
    O = fill(O, color(obj), intersection(outline_indices, toindices(obj))) 

  # 4. Fill the rest with 0
  O = fill(O, 0, difference(asindices(I), outline_indices))
  return O
 
15.666666666666666, tensor(1.6798), Description: Copy the input grid. Then, for each object in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def gegcjbececgbeieebfchdcddfdeajcdh(I):
  # 1. Get all objects in the grid, including background
  objs = objects(I, T, F, F)
  
  # 2. Create an empty canvas
  O = canvas(0, shape(I))

  # 3. Iterate over objects and draw their outlines
  for obj in objs:
    outline = box(obj)
    O = paint(O, recolor(color(obj), outline))

  return O
 
16.0, tensor(1.5690), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. 
:: def diahhbdaddjiehaejhcedhdbdebabfef(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, False, False, True)  # Extract objects
  largest_obj = argmax(objs, size)  # Find the largest object
  inner_obj = toindices(largest_obj)  # Get indices of the largest object
  outline = box(inner_obj) - inner_obj  # Get indices of the outline
  return fill(I, bg, inner_obj - outline) # Fill inside of outline with background
 
19.666666666666668, tensor(1.0090), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the background color. 
:: def jcfdabjecfddefbhbbfaidfghbcdeefj(I):
    bg = mostcolor(I)
    objs = objects(I, False, False, True)
    largest_obj = argmax(objs, size)
    outline = box(toindices(largest_obj))
    return cellwise(I, canvas(bg, shape(I)), lambda cell: I[cell[0]][cell[1]] if cell in outline else bg)
 
18.0, tensor(0.5325), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Fill the entire object with the background color. Then, draw a border around the object using a different color that is not the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def djaaecfeeeceeeaijcgfhbbgcieiedif(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  filled_grid = fill(I, bg, toindices(largest_obj)) # Fill the entire object with bg
  return paint(filled_grid, recolor(other(palette(I), bg), box(toindices(largest_obj)))) # Paint the outline
 
19.666666666666668, tensor(1.7649), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Shift this object diagonally one square to the right and down. Draw a border around the shifted object using a different color that is not the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def dcefbdieabeeeccbbdcefdfafbbcaada(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  shifted_obj = shift(largest_obj, (1, 1))  # Shift the object diagonally
  return underpaint(I, recolor(other(palette(I), bg), box(toindices(shifted_obj)))) # Underpaint the outline on the shifted object
 
19.666666666666668, tensor(0.1722), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using a different color that is not the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ebeadebgajedebffjbfgfaeedebjbbha(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  outline = box(toindices(largest_obj))
  return tuple(
        tuple(
            other(palette(I), bg) if (i, j) in outline else I[i][j] for j in range(len(I[0]))
        )
        for i in range(len(I))
    ) # Iterate and replace based on outline
 
18.333333333333332, tensor(1.8628), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace the original objects with black. The background of the output grid should be the most common color. 
:: def aaffecdhdebaehfaidbfifbhfdjdeaje(I):
  # 1. Identify the non-background objects
  objs = objects(I, T, F, T)

  # 2. Get the outline of each object and combine them
  outline_indices = merge(apply(box, objs))

  # 3. Fill the outline with 1, only overwriting the background
  O = underfill(I, 1, outline_indices)

  # 4. Replace the original objects with 0
  O = fill(O, 0, merge(apply(toindices, objs)))
  return O
 
18.333333333333332, tensor(1.8195), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the color of the first object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace the original objects with black. The background of the output grid should be the most common color. 
:: def bhcfjeeabffhecaciacjabbdieaajiaf(I):
  # 1. Identify the non-background objects
  objs = objects(I, T, F, T)

  # 2. Get the delta (outline) of each object and combine them
  outline_indices = merge(apply(delta, objs))

  # 3. Fill the outline with the color of the first object
  O = fill(I, color(first(objs)), outline_indices)

  # 4. Replace the original objects with 0
  O = fill(O, 0, merge(apply(toindices, objs)))
  return O
 
18.333333333333332, tensor(1.8195), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the color of the first object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace the original objects with black. The background of the output grid should be the most common color. 
:: def efadeadbjhbeededifhbeigjdjdbchbd(I):
  # 1. Identify the non-background objects
  objs = objects(I, T, F, T)

  # 2. Get the outline by subtracting object indices from their bounding box
  outline_indices = difference(
      merge(apply(box, objs)), merge(apply(toindices, objs))
  )

  # 3. Fill the outline with the color of the first object
  O = fill(I, color(first(objs)), outline_indices)

  # 4. Replace the original objects with 0
  O = fill(O, 0, merge(apply(toindices, objs)))
  return O
 
15.666666666666666, tensor(1.0086), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are inside the object's outline. Recolor this new object with the original object's color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def bideifadheddedcdbfcaceahhafabicd(I):
  bg = mostcolor(I) 
  objs = objects(I, T, F, F) 
  filled = canvas(bg, shape(I)) 
  for obj in objs:
    outer = box(obj)
    inner = toindices(obj) - outer 
    filled = paint(filled, recolor(color(obj), inner))
  O = filled
  return O
 
16.666666666666668, tensor(0.1809), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ddeejghfggfcecfjadbjjajcgchjdcda(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    outer_layer = box(obj) - toindices(obj)
    O = fill(O, bg, outer_layer)
  return O
 
13.666666666666666, tensor(1.9810), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace all instances of the most common color (the background color) with black. 
:: def ieebecddggafegcfjhjjeibicjabbaca(I):
  # 1. Get the background color
  bg = mostcolor(I)

  # 2. Identify non-background objects and recolor their outlines
  O = I
  for obj in objects(I, T, F, T):
    outline = delta(toindices(obj))
    O = underfill(O, color(obj), outline)

  # 3. Replace all non-background colors with 0
  O = replace(O, bg, 0)
  return O
 
12.333333333333334, tensor(1.6691), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def ehcadfcijfieejbajaidbecbejcbgajc(I):
  # 1. Create a blank canvas with the same dimensions as the input
  O = canvas(0, shape(I))

  # 2. Identify non-background objects 
  for obj in objects(I, T, F, T):
    # 3.  Paint the object outline onto the canvas
    O = paint(O, recolor(color(obj), box(toindices(obj)))) 
  return O
 
16.0, tensor(0.4435), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. 
:: def bahhbeaaijbieceejghdffbfegdjeiac(I):
  # 1. Find the largest object (excluding background)
  x1 = objects(I, False, False, True)
  x2 = argmax(x1, size)
  # 2. Get object's indices and color 
  obj_indices = toindices(x2)
  obj_color = color(x2)
  # 3. Find indices adjacent to the object
  adjacent_indices = mapply(dneighbors, obj_indices)
  # 4. Filter out indices that belong to the object itself
  outline_indices = adjacent_indices - obj_indices
  # 5. Fill the outline with background color (0)
  x3 = fill(I, 0, outline_indices)
  # 6. Fill the object's interior with background color (0)
  O = fill(x3, 0, obj_indices)
  return O 
 
15.666666666666666, tensor(0.3697), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. 
:: def gjdabddcbcfdegddaejebjdfachbedaj(I):
  # 1. Find the largest object (excluding background)
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  # 2. Get the outline indices directly using 'box' function
  outline_indices = box(toindices(largest_obj)) 
  # 3. Fill the outline with background color (0)
  x1 = fill(I, 0, outline_indices)
  # 4. Fill the interior with background color (0)
  O = fill(x1, 0, toindices(largest_obj)) 
  return O
 
19.333333333333332, tensor(0.3697), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. 
:: def ddehdbdggbfiecdejgebabdacdjeijaf(I):
  # 1. Define a function to check if an index is on the border of an object
  def is_border(obj, idx):
    return contained(idx, toindices(obj)) and any(n not in toindices(obj) for n in dneighbors(idx)) 
  # 2. Find the largest object (excluding background)
  x1 = objects(I, False, False, True)
  x2 = argmax(x1, size)
  # 3. Get all indices of the grid
  x3 = asindices(I)
  # 4. Filter for indices on the border of the largest object
  x4 = sfilter(x3, lambda loc: is_border(x2, loc))
  # 5. Fill the border indices and the object's interior with background color
  O = fill(fill(I, 0, x4), 0, toindices(x2))
  return O
 
18.0, tensor(0.6878), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, fill the inside of the object with the background color, leaving only the outline of the object. The background of the output grid should be the most common color. 
:: def acbefdeefacfedecjcjbddieacaffhgf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  O = I  # Start with the original grid
  for obj in objs:
    O = fill(O, bg, difference(toindices(obj), box(obj)))  # Fill the inside of each object with the background color
  return O
 
14.333333333333334, tensor(1.9810), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace all instances of the most common color (the background color) with black. 
:: def ageejegafjgjeegfjfbebiaifdibddcd(I):
  # 1. Find the background color.
  bg = mostcolor(I)
  
  # 2. Replace background with 0.
  O = replace(I, bg, 0)
  
  # 3. Get objects, excluding the background.
  objs = objects(I, True, False, True)
  
  # 4. For each object, create an outline and paint it.
  for obj in objs:
    outline = mapply(dneighbors, toindices(obj))
    O = fill(O, color(obj), outline)
  return O
 
13.0, tensor(1.1636), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid and the cell has a diagonal neighbor that is the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. 
:: def dbbhajdiiccbegaejehfbbagddbeffga(I):
  # 1. Find the background color
  bg = mostcolor(I)

  # 2. Get non-background indices
  non_bg_indices = difference(asindices(I), ofcolor(I, bg))

  # 3. Replace background with 0s
  O = fill(I, 0, asindices(I))

  # 4. Paint outline using original color
  for idx in non_bg_indices:
    for n in dneighbors(idx):
      if index(I, n) == bg:
        O = fill(O, index(I, idx), {n}) 
  return O
 
9.333333333333334, tensor(1.6691), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def bddcfaebdafaeggejjhdedcgbddfbgda(I):
  # 1. Get all objects
  objs = objects(I, True, False, False)

  # 2. Create a canvas filled with 0s
  O = canvas(0, shape(I))

  # 3. For each object, paint its outline on the canvas
  for obj in objs:
    outline = difference(mapply(dneighbors, toindices(obj)), toindices(obj))
    O = underpaint(O, recolor(color(obj), outline))

  return O
 
13.0, tensor(1.5626), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, paint its diagonal neighbors with the same color. The background of the output grid should be black. 
:: def gbcbecfdaaadedfdabchaiaecbeiaaej(I):
  # 1. Create a blank canvas of the same size as the input grid.
  O = canvas(0, shape(I))

  # 2. Iterate through each cell of the input grid.
  for i in range(height(I)):
    for j in range(width(I)):
      # 3. If the current cell is not the background color, 
      #    paint its direct neighbors on the canvas with the current cell's color.
      if index(I, (i, j)) != mostcolor(I):
        for neighbor in dneighbors((i, j)):
          O = fill(O, index(I, (i, j)), {neighbor})
  
  return O
 
17.0, tensor(1.1546), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the outline of the original object. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def jjhjjgcedecceebfiaiifgbdifdcdaab(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  def frame(obj):
    return toobject(box(toindices(obj)), I)
  return paint(canvas(bg, shape(I)), merge(apply(frame, objs)))
 
7.333333333333333, tensor(1.6233), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Dilate this object by one cell in all directions (up, down, left, right). If the dilated object overlaps with any other objects, keep the color of the dilated object. Finally, fill the background with black. 
:: def eggbbbbdfecdegfdibdjgfiaaceajggg(I):
  # 1. Find the largest object 
  largest_obj = argmax(objects(I, False, False, True), size)
  # 2. Get the object's color
  obj_color = color(largest_obj)
  # 3.  Dilate the object by one cell in all directions
  dilated = paint(canvas(0, shape(I)), shift(largest_obj, (1, 0)))
  dilated = paint(dilated, shift(largest_obj, (-1, 0)))
  dilated = paint(dilated, shift(largest_obj, (0, 1)))
  dilated = paint(dilated, shift(largest_obj, (0, -1)))
  # 4. Combine the original grid with the dilated one, prioritizing the dilated color
  O = cellwise(dilated, I, obj_color)
  # 5. Fill the background with 0
  O = replace(O, mostcolor(O), 0)
  return O
 
10.333333333333334, tensor(0.3811), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def aieafaafebabefagaabbhhfbcbagdbab(I):
  # 1. Find the largest object
  largest_obj = argmax(objects(I, False, False, True), size)
  # 2. Get the object's color
  obj_color = color(largest_obj)
  # 3. Create an empty canvas
  O = canvas(0, shape(I))
  # 4. Paint the outline directly by shifting the object in four directions
  O = paint(O, shift(largest_obj, (1, 0)))
  O = paint(O, shift(largest_obj, (-1, 0)))
  O = paint(O, shift(largest_obj, (0, 1)))
  O = paint(O, shift(largest_obj, (0, -1)))
  # 5. Paint the original object back onto the outline
  O = paint(O, largest_obj)
  return O
 
11.333333333333334, tensor(0.3981), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def dfjdaajcghceefceihidafcdagdieajf(I):
  # 1. Find the largest object
  largest_obj = argmax(objects(I, False, False, True), size)
  # 2. Get the object's color
  obj_color = color(largest_obj)
  # 3. Get the indices of the outline using the 'box' function
  outline_indices = box(toindices(largest_obj))
  # 4. Create an empty canvas
  O = canvas(0, shape(I))
  # 5. Fill the outline indices with the object's color
  O = fill(O, obj_color, outline_indices)
  # 6. Paint the original object back onto the outline
  O = paint(O, largest_obj)
  return O 
 
9.666666666666666, tensor(0.3981), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def edcaffcceaegebahaeficbjbeicefhfa(I):
  # 1. Find the largest object
  largest_obj = argmax(objects(I, False, False, True), size)
  # 2. Get the object's color
  obj_color = color(largest_obj)
  # 3. Calculate the outline indices using 'delta' and 'backdrop' functions
  outline_indices =  delta(toindices(largest_obj)) - backdrop(shift(toindices(largest_obj), (-1, -1)))
  # 4. Create an empty canvas
  O = canvas(0, shape(I))
  # 5. Fill the outline indices with the object's color
  O = fill(O, obj_color, outline_indices)
  # 6. Paint the original object back onto the outline
  O = paint(O, largest_obj)
  return O
 
17.666666666666668, tensor(0.7185), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def eadadfchagbgecgfagdbdecehecfjcfb(I):
  objs = objects(I, T, F, F)
  O = I  # Start with the original grid
  for obj in objs:
    O = cover(O, obj)  # Replace the object with background
    O = paint(O, recolor(color(obj), box(toindices(obj))))  # Paint the outline
  return O
 
18.0, tensor(0.7185), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ceehechifiggedfejggigcfahbcfjaad(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I)) # Start with a background-filled canvas
  for obj in objects(I, T, F, F):
    outline = box(toindices(obj))  # Get the object's outline
    O = underpaint(O, recolor(color(obj), outline)) # Paint only if background
  return O
 
15.666666666666666, tensor(1.5716), Description: Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def gceefiidbdjgebfjibbcfabcjghabege(I):
  # 1. Identify objects, excluding the background.
  objs = objects(I, T, F, T)

  # 2.  Get outlines of each object.
  outlines = mapply(box, objs)

  # 3. Fill the outline with the background color.
  O = fill(I, mostcolor(I), outlines)
  return O
 
17.333333333333332, tensor(1.9813), Description: Copy the input grid. For each cell in the grid, if the cell's color is not the most common color in the grid, count the number of its 4-neighbor cells that are also not the most common color. If this count is greater than 1, change the cell's color to the most common color (background). Otherwise, keep the cell's color the same. 
:: def daadgdgcebjjebdcjdedabcbcgfdicbb(I):
  # 1. Generate a grid where each cell is its 4-neighbor count of non-background cells.
  O = canvas(0, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i, j)) != mostcolor(I):
        for n in dneighbors((i, j)):
          if 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]):
            O = fill(O, index(O, n) + 1, {n})

  # 2. Set cells with a count greater than 1 to the background color.
  for i in range(len(O)):
    for j in range(len(O[0])):
      if index(O, (i, j)) > 1:
        O = fill(O, mostcolor(I), {(i, j)})
      else:
        O = fill(O, index(I, (i, j)), {(i, j)})
  return O
 
16.0, tensor(1.7167), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. 
:: def eefedffcfaabeecfifcjdabibfeddcae(I):
  # 1. Identify the background color
  bg = mostcolor(I)
  # 2. Extract objects without background
  objs = objects(I, False, False, True) 
  # 3. Find the largest object
  largest_obj = argmax(objs, size)
  # 4. Find the outline of the largest object
  outline = box(toindices(largest_obj))
  # 5. Fill the outline with the object's color
  I = fill(I, color(largest_obj), outline)
  # 6. Replace the original object with the background color
  I = fill(I, bg, toindices(largest_obj)) 
  return I
 
16.0, tensor(1.7193), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. 
:: def aaefbbhiifafeaceiijffheeafceafbf(I):
  # 1. Identify the background color
  bg = mostcolor(I) 
  # 2. Find the largest object
  largest_obj = argmax(objects(I, False, False, True), size) 
  # 3. Get the outline indices using delta 
  outline_indices = delta(toindices(largest_obj))
  # 4. Fill the outline indices with the object's color
  I = fill(I, color(largest_obj), outline_indices)
  # 5. Replace the original object with the background color 
  I = fill(I, bg, toindices(largest_obj))
  return I 
 
19.666666666666668, tensor(0.2065), Description: Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def iaddfdabcacceiggbaeicaccdegbcbae(I):
  # 1. Find the largest object 
  largest_obj = argmax(objects(I, False, False, True), size)
  # 2. Get the outline indices 
  outline_indices = delta(toindices(largest_obj))
  # 3. Fill the outline with the object's color, only on background cells
  return underfill(I, color(largest_obj), outline_indices)
 
14.333333333333334, tensor(0.1834), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def dacedbiadacdecdiagjabceiagfcjadb(I):
  # 1. Identify the background color
  bg = mostcolor(I)
  # 2. Find the largest object
  largest_obj = argmax(objects(I, False, False, True), size)
  # 3. Create a canvas filled with the background color
  O = canvas(bg, shape(I))
  # 4. Paint the outline of the largest object on the canvas
  O = paint(O, recolor(color(largest_obj), delta(toindices(largest_obj)))) 
  return O
 
16.0, tensor(1.8040), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def dbjfhdgbedaaefcjadjcfecefcgfciea(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  O = I  # Start with the original grid
  for obj in objs:
    outline = box(obj) - toindices(obj) # Find outline for each object
    O = fill(O, bg, toindices(obj)) # Fill object interior with background
    O = paint(O, recolor(leastcolor(I), outline)) # Paint the outline
  return O
 
17.0, tensor(1.8040), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def decfgggdbfchefhdbjjdfadfgejhbaca(I):
  least_color = leastcolor(I)
  return paint(canvas(mostcolor(I), shape(I)), 
               recolor(least_color, 
                       merge(apply(lambda obj: box(obj) - toindices(obj), 
                                   objects(I, T, F, F)))))
 
16.333333333333332, tensor(0.3474), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bafghdedhdabeedfjbbehdheecjeafae(I):
  O = canvas(mostcolor(I), shape(I)) # Background canvas
  for obj in objects(I, T, F, F):
    O = underpaint(O, recolor(leastcolor(I), box(obj) - toindices(obj)))
  return O
 
19.333333333333332, tensor(1.5704), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def icidfajgccaeeefbbbffgedcbafeeeaj(I):
  # 1. Get all objects in the grid.
  objs = objects(I, T, F, T)

  # 2. For each object, get its delta (surrounding cells).
  deltas = mapply(delta, objs)
  
  # 3. Fill the deltas with the background color.
  O = fill(I, mostcolor(I), deltas)
  return O
 
14.333333333333334, tensor(0.0759), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color and the cell has at least one neighbor that is not the background color, change the cell's color to black. Otherwise, keep the cell's color the same. 
:: def cefedhbedcehechgabbiddcfcgbdaihd(I):
  bg = mostcolor(I)
  return tuple(tuple(bg if any(I[i + di][j + dj] != bg for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)] if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0])) and I[i][j] == bg else 0 for j in range(len(I[0]))) for i in range(len(I))) 
 
16.333333333333332, tensor(0.1834), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def hfhccadddigbegbaachbcbecegbaadcf(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, False, False, True)  # Extract all objects excluding the background
  largest_obj = argmax(objs, size)  # Find the largest object by size
  outline = box(toindices(largest_obj))  # Get the outline indices of the largest object
  O = paint(canvas(bg, shape(I)), recolor(color(largest_obj), outline))  # Paint the outline with the object's color on a blank canvas
  return O
 
15.666666666666666, tensor(1.1645), Description: Copy the input grid. Then, identify the largest object (by number of cells) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def iijdaahfbbidehggbdifeegceiaeefed(I):
    bg = mostcolor(I) 
    objs = objects(I, False, False, True)
    largest_obj = argmax(objs, lambda obj: len(obj))
    filled_obj = recolor(color(largest_obj), toindices(largest_obj))
    outline = difference(toindices(filled_obj), inbox(filled_obj))
    O = paint(canvas(bg, shape(I)), recolor(color(largest_obj), outline)) 
    return O
 
17.666666666666668, tensor(1.1645), Description: Copy the input grid. Then, identify the largest object (by number of cells) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def cafjbbjahhieeccaiaeedaaddhjcgiaf(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  largest_obj = next(obj for obj in objs if len(obj) == max(len(o) for o in objs))
  outline = set()
  for _, (i, j) in largest_obj:
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        if (i + di, j + dj) not in toindices(largest_obj):
            outline.add((i, j))
  O = paint(canvas(bg, shape(I)), recolor(color(largest_obj), frozenset(outline)))
  return O
 
18.0, tensor(1.1686), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the least common color. 
:: def hfbeccgcdfheebagbghajhfgidceaadd(I):
  inverted = replace(I, mostcolor(I), leastcolor(I))  # Invert background and least frequent colors
  objs = objects(inverted, T, F, T)  # Extract objects from the inverted grid
  O = fill(canvas(leastcolor(I), shape(I)), mostcolor(I), mapply(delta, objs))  # Fill the delta of each object
  return O
 
19.666666666666668, tensor(0.0994), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Replace all instances of this most common color with black. Then, replace all instances of black with the most common color. The result will be a grid where the most common color is the only color present. 
:: def dbcaeehgfgaaeeedahdahaccebfhddbg(I):
  """
  Identifies the central object using 'objects' and 'mostcommon' and 
  replaces everything else with '0' using 'replace'. 
  """
  central_color = mostcommon([v for r in I for v in r])
  O = replace(I, central_color, 0)
  O = replace(O, 0, central_color)
  return O
 
18.333333333333332, tensor(0.0994), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Replace all instances of this most common color with black. Then, replace all instances of black with the most common color. The result will be a grid where the most common color is the only color present. 
:: def acdaffchgceeeehgagfafcccfdhddeeg(I):
  """
  Iterates through the grid and checks if each cell's value 
  matches the central object's color.
  """
  central_color = mostcolor(I)
  O = tuple(
      tuple(v if v == central_color else 0 for v in row) for row in I
  )
  return O
 
7.666666666666667, tensor(1.0807), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def bbfbaghcgjageaccbedcfddecfabcfef(I):
  """
  Uses 'objects' to extract all objects and filters them by size 
  assuming the central object is the largest. 
  """
  objs = objects(I, T, F, T)
  central_object = argmax(objs, size)
  O = paint(canvas(0, shape(I)), central_object)
  return O
 
7.666666666666667, tensor(0.0940), Description: Copy the input grid. Then, identify the color of the cell in the center of the grid. Create a new object consisting of only that single cell with the identified color and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def jadhifhjefeeehgfjhacjcgjgeecjche(I):
  """
  Finds the central cell's location and color, then paints 
  a new object with that color on an empty canvas.
  """
  center_i, center_j = len(I) // 2, len(I[0]) // 2
  central_color = I[center_i][center_j]
  central_object = {(central_color, (center_i, center_j))}
  O = paint(canvas(0, shape(I)), central_object)
  return O
 
7.666666666666667, tensor(0.0686), Description: Copy the input grid. Then, identify the object that is not the background color and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def ddfaahcbabhdefbdbeabdaiacbefifbj(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, T, T, T)  # Extract all objects
  central_obj = extract(objs, lambda obj: color(obj) != bg)  # Extract the non-background object
  O = paint(canvas(0, shape(I)), central_obj)  # Paint the object onto a blank canvas filled with 0s
  return O
 
8.666666666666666, tensor(1.1594), Description: Copy the input grid. Then, identify the least common color in the grid (likely the color of the central object). Paint only the cells with that color onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def bfdjjdehbfcceebaaccfaibjfhjgccha(I):
  bg = mostcolor(I)  # Find the background color
  fg = leastcolor(replace(I, bg, 9)) # Temporarily replace bg, find least common (central object color)
  O = paint(canvas(0, shape(I)), recolor(fg, ofcolor(I, fg)))  # Create a blank canvas, recolor and paint the central object
  return O
 
7.666666666666667, tensor(0.4145), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Fill the entire object with the color of the object. The background of the output grid should be black. 
:: def cddcadfeafcaedjfiecifccfaebcicdj(grid):
  bg = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, size)
  return tuple(
    tuple(
      color(largest_obj) if (i,j) in toindices(largest_obj) else 0
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
18.0, tensor(0.1199), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def caejcbbajfjiecifigacabcgehfbbbbj(I):
  # 1. Get all objects in the grid, excluding background
  objs = objects(I, T, F, T)
  
  # 2. Create a canvas filled with the background color
  O = canvas(mostcolor(I), shape(I))

  # 3. Iterate over objects and draw their outlines
  for obj in objs:
    outline = box(obj)
    O = paint(O, recolor(color(obj), outline))

  return O
 
19.666666666666668, tensor(0.7758), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). For each cell in the grid, if the cell's color is not the most common color and the cell has at least one neighbor that is the most common color, change the cell's color to the most common color. Otherwise, keep the cell's color the same. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def jfbbjadeaajbeadjiibhceaehecbaacb(I):
  # 1. Get indices of all non-background colors
  non_bg_indices = difference(asindices(I), ofcolor(I, mostcolor(I)))

  # 2. Identify outline indices by checking for adjacent background cells
  outline_indices = sfilter(non_bg_indices, lambda loc: any(n in ofcolor(I, mostcolor(I)) for n in dneighbors(loc)))

  # 3. Create output grid by keeping only colors at outline indices
  O = canvas(mostcolor(I), shape(I))
  return fill(O, index(I, first(outline_indices)), outline_indices) 
 
14.333333333333334, tensor(0.7964), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bfabefcfadfdedgbbdhebjgcibfbebda(I):
  # 1. Get all objects, excluding background
  objs = objects(I, T, F, T)

  # 2. Create a background-filled canvas
  O = canvas(mostcolor(I), shape(I))

  # 3. For each object, paint its delta (outline) onto the canvas
  for obj in objs:
    O = underpaint(O, recolor(color(obj), delta(obj))) 
  return O
 
14.0, tensor(0.7964), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def abhgfafeighbeiaajcbhafiecebdijdd(I):
  # 1. Create a background-filled canvas
  O = canvas(mostcolor(I), shape(I))

  # 2. Get all frontiers of the input grid
  ftiers = frontiers(I)

  # 3. Paint each frontier onto the canvas
  for ftier in ftiers:
    O = underpaint(O, ftier)
  return O 
 
17.333333333333332, tensor(0.0727), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def jjfifdaacfbfebaeadiaibbeechadfaa(I):
  bg = mostcolor(I)
  filled = canvas(bg, shape(I)) # Create a canvas filled with the background color
  objs = objects(I, False, False, True) 
  painted = apply(lambda obj: paint(filled, obj), objs)  # Paint each object onto the filled canvas
  O = last(painted) if painted else filled  # If objects exist, return the last painted grid, otherwise, return the filled canvas
  return O
 
18.0, tensor(0.0588), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). For each cell in the grid, if the cell's color is the same as the most common color and the cell is on the edge of the grid or has a neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to black. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def bhebffibfdhheddaicgejdjdbechbaee(I):
  """
  Iterates through each cell and checks if it's part of 
  the outermost layer of the most common color.
  """
  mc = mostcolor(I)
  O = canvas(0, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == mc and (i == 0 or j == 0 or i == len(I)-1 or j == len(I[0])-1 or I[i-1][j] != mc or I[i+1][j] != mc or I[i][j-1] != mc or I[i][j+1] != mc):
        O = paint(O, {(mc, (i, j))})
  return O
 
15.666666666666666, tensor(0.7692), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Starting from the top left corner, perform a flood fill, marking all cells that are not the background color as "visited". After the flood fill, paint all cells that were not visited and have the background color onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def aeidadcebfhgefjeaaibcfcfceajegaf(I):
  """
  Uses a flood-fill approach to identify the outer layer.
  """
  mc = mostcolor(I)
  h, w = len(I), len(I[0])
  visited = set()
  queue = [(0, 0)]
  while queue:
    i, j = queue.pop(0)
    if (i, j) in visited:
      continue
    visited.add((i, j))
    if 0 <= i < h and 0 <= j < w and I[i][j] != mc:
      queue += [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if (i, j) not in visited and I[i][j] == mc:
        O = paint(O, {(mc, (i, j))})
  return O
 
19.666666666666668, tensor(1.0867), Description: Copy the input grid. Then, identify all objects in the grid, including the background. For each object, if the object's color is the same as the most common color (likely the background color) and the object is touching the border of the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def dbajiefbfdcbeaadaiadagddacjecfhi(I):
  """
  Exploits the fact that the outer layer forms connected components 
  when considering 4-connectivity.
  """
  mc = mostcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  outer_objs = sfilter(objs, lambda obj: any(bordering({(0, loc)}, I) for _, loc in obj))
  O = canvas(0, shape(I))
  for obj in outer_objs:
    O = paint(O, obj)
  return O
 
8.666666666666666, tensor(1.1606), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, remove the outer layer of cells from the object, leaving only the inner cells. Replace the color of the remaining inner cells with black. The background of the output grid should be black. 
:: def jdffebbdfdafedadbebiagiacdjgabbd(I):
    bg = mostcolor(I)  # Identify the most common color (background)
    x1 = objects(I, T, T, T)  # Extract all objects
    x2 = apply(lambda o: sfilter(o, lambda c: index(I, c[1]) != bg), x1)  # Remove background cells from objects
    x3 = apply(toindices, x2) # Extract indices of each object
    x4 = apply(lambda idxs: sfilter(idxs, lambda idx: any(n in idxs for n in dneighbors(idx))), x3) # Filter out the outer layer of indices
    x5 = apply(lambda idxs: recolor(0, idxs), x4) # Recolor the remaining indices to 0
    x6 = paint(replace(I, bg, 0), merge(x5)) # Paint the modified objects onto a grid with the background replaced by 0
    O = x6
    return O
 
7.333333333333333, tensor(1.7639), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, shift each cell of the object one step inward towards the center of the object. If the object is on the edge of the grid, then the cells on the edge will be shifted off the grid. The background of the output grid should be black. 
:: def fiahjedaahgcegcbbdabbdhgbdfddgid(I):
    bg = mostcolor(I)  # Identify background color
    x1 = replace(I, bg, 0)  # Replace background with 0
    x2 = objects(x1, T, T, T)  # Extract objects
    x3 = apply(lambda o: frozenset((0, (i + sign(i - uppermost(o)) * (-1), j + sign(j - leftmost(o)) * (-1))) for _, (i, j) in o), x2)  # Shift object's indices inward
    O = paint(x1, merge(x3))  # Paint the shifted objects onto the grid
    return O
 
19.666666666666668, tensor(0.1267), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as its row and column number and it's not the background color, keep the cell's color the same. Otherwise, change the cell's color to the background color. 
:: def eajafiejbgibeicfbaffeccjfgffiaac(grid):
  bg = mostcolor(grid)
  return tuple(
    tuple(
      bg if i != j and grid[i][j] == bg else grid[i][j]
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
14.0, tensor(1.2573), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, change the cell's color to the most common color. Otherwise, keep the cell's color the same. Then, for each cell in the grid, if the cell's color is the most common color, change the cell's color to the least common color. Otherwise, keep the cell's color the same. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def ahfhbeahcfccehgdifdacgcbgicefdcb(grid):
  bg = mostcolor(grid)
  return paint(
    fill(grid, bg, delta(asindices(grid))),
    recolor(bg, asindices(grid))
  )
 
14.333333333333334, tensor(0.8015), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the color of the cell at the center of mass of the object with that color, keep the cell's color the same. Otherwise, change the cell's color to the background color. The result will be a grid where only the cells at the center of mass of each object are colored, and the rest are the background color. 
:: def faggaegdfaaeejecbgjaghadcfadjhfd(grid):
  bg = mostcolor(grid)
  return tuple(
    tuple(
      v if (i, j) == centerofmass(ofcolor(grid, v)) else bg
      for j, v in enumerate(row)
    )
    for i, row in enumerate(grid)
  )
 
19.333333333333332, tensor(1.7022), Description: Copy the input grid. Then, for each cell in the grid, if the absolute difference between the cell's row number and column number is less than or equal to half the grid size, keep the cell's color the same. Otherwise, change the cell's color to the background color. The result will be a grid with a diagonal band of colors, extending from the top left to the bottom right, with the rest of the grid filled with the background color. 
:: def gdhhibidjbdgeeccjaidbidbffddefga(grid):
  bg = mostcolor(grid)
  size = len(grid)
  return tuple(
    tuple(
      grid[i][j] if abs(i - j) <= size // 2 else bg 
      for j in range(size)
    )
    for i in range(size)
  )
 
14.333333333333334, tensor(0.1199), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def fbgbddicfaececceadbjifdhdbfedfad(I):
  # 1. Create an empty canvas.
  O = canvas(0, shape(I)) 
  
  # 2. Get all non-background colors.
  colors = palette(I) - {mostcolor(I)}
  
  # 3. Draw outline for each color.
  for c in colors:
    O = paint(O, recolor(c, box(ofcolor(I, c))))
  
  return O
 
14.0, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def feefdjcbcgdcefjfbeicchebcbcchhdc(I):
  """
  Finds the central object and directly constructs the output 
  by iterating through the grid and checking for outline indices.
  """
  c = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline = toindices(box(central_obj))
  O = tuple(
      tuple(0 if (i,j) not in outline else c for j in range(width(I))) 
      for i in range(height(I))
  )
  return O
 
7.333333333333333, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def caeggcigbegjeajcibfhcecahfajaebe(I):
  """
  Creates a mask of the central object's bounding box, 
  then subtracts the object itself to leave only the outline. 
  """
  c = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  mask = canvas(1, shape(I))
  mask = fill(mask, 0, toindices(central_obj)) 
  outline = difference(toindices(box(central_obj)), toindices(central_obj)) 
  O = paint(mask, recolor(c, outline)) 
  return O
 
14.0, tensor(0.6383), Description: Copy the input grid. Then, identify the object that is not the background color and draw a border around it using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ahgbiahccbhaeeagaejjfeccbhgbedba(I):
  x1 = mostcolor(I) # Identify the background color
  x2 = objects(I, T, T, T)  # Extract all objects
  x3 = extract(x2, lambda obj: color(obj) != x1)  # Extract the non-background object
  x4 = box(x3)  # Get the outline of the object
  x5 = fill(canvas(x1, shape(I)), x1, x4)  # Fill the outline on a canvas filled with background color
  return x5
 
14.666666666666666, tensor(0.3785), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def ebgigecdajfgecdgjebjjbcchhbfcaae(I):
  x1 = objects(I, T, T, T) # Extract all objects
  x2 = argmax(x1, size) # Get the largest object by size
  x3 = box(x2) # Calculate the outline of the largest object
  x4 = recolor(color(x2), x3) # Color the outline with the color of the largest object
  O = paint(canvas(0, shape(I)), x4) # Paint the colored outline onto a blank canvas
  return O
 
17.666666666666668, tensor(1.7041), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a diagonal line of the same color from the top left corner to the bottom right corner of the object. The diagonal line should be one cell thick and should extend to the edges of the object. The background of the output grid should be the most common color. 
:: def ghigijbhijiheacbjcdadaejbadaaced(grid):
  bg = mostcolor(grid)
  objs = objects(grid, univalued=True, diagonal=False, without_bg=True)
  new_grid = canvas(bg, shape(grid))
  for obj in objs:
    ul = ulcorner(obj)
    for i in range(min(height(obj), width(obj))):
      new_grid = fill(new_grid, color(obj), {(ul[0] + i, ul[1] + i)})
  return new_grid
 
8.666666666666666, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def ccfdcdicbeiaecbdabbaigeaibedgjbb(I):
  """
  Finds the central object, replaces the background, 
  and paints a border around the central object.
  """
  c = mostcolor(I) # Find the most common color
  objs = objects(I, univalued=False, diagonal=False, without_bg=False) # Find all objects
  central_obj = argmax(objs, lambda obj: colorcount(obj, c)) # Find the object with the most common color
  O = replace(I, c, 0)  # Replace the background 
  O = paint(O, toobject(outbox(central_obj), I)) # Paint the border
  return O
 
8.666666666666666, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def edbabebbbaafeccgibeibjedghccbfbf(I):
  """
  Uses a temporary color to isolate the central object,
  then outlines and restores it.
  """
  temp = 10
  c = mostcolor(I)
  O = replace(I, c, temp)
  objs = objects(O, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, temp))
  O = paint(canvas(0, shape(I)), toobject(box(central_obj), replace(I, c, 0)))
  O = replace(O, temp, c)
  return O
 
16.666666666666668, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def fachefejbfjgeffcicjcdbacdddiahcd(I):
    """
    This program identifies the central object, replaces the 
    background with 0, and draws a bounding box around it.
    """
    c = mostcolor(I)
    O = replace(I, c, 0)
    objs = objects(I, univalued=False, diagonal=False, without_bg=False)
    central_obj = argmax(objs, lambda obj: colorcount(obj, c))
    O = paint(O, toobject(box(central_obj), I))
    return O
 
16.666666666666668, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def iaacjajieecfebfajaeddfdgfjdabfed(I):
  """
  Identifies the central object and paints its outline 
  while keeping other elements unchanged.
  """
  c = mostcolor(I) 
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  O = paint(canvas(0, shape(I)), toobject(box(central_obj), I)) 
  return O
 
8.666666666666666, tensor(1.1207), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def biibbdaddagdeceabebdccgdejbhcedf(I):
  """
  Finds the central object, creates a canvas with its color, 
  and paints the outline of the object on top.
  """
  c = mostcolor(I) 
  objs = objects(I, univalued=False, diagonal=False, without_bg=False) 
  central_obj = argmax(objs, lambda obj: colorcount(obj, c)) 
  O = canvas(c, shape(I))  # Create canvas filled with the central color
  O = paint(O, toobject(box(central_obj), replace(I, c, 0))) 
  return O
 
7.333333333333333, tensor(0.3344), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Draw a border around the object with the most common color using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def dccdeahcegedefjdabccfcdfiafcjfjh(I):
  x1 = mostcolor(I) # Find the most common color
  x2 = objects(I, T, T, T) # Extract all objects
  x3 = next((obj for obj in x2 if color(obj) == x1), None) # Safely find the dominant object
  x4 = box(x3) if x3 else frozenset() # Get outline, handle potential missing object
  O = paint(canvas(0, shape(I)), recolor(x1, x4)) # Paint on a blank canvas
  return O
 
11.333333333333334, tensor(0.3344), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Draw a border around the object with the most common color using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def fidcbidjahcjegdcadafjjheggdiccfg(I):
  dom_color = mostcommon(totuple(palette(I))) # Find the most common color
  outline = box(next((obj for obj in objects(I, T, T, T) if color(obj) == dom_color), frozenset())) # Find dominant object and get outline
  return paint(canvas(0, shape(I)), recolor(dom_color, outline)) # Paint the outline on a blank canvas
 
16.666666666666668, tensor(1.7018), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as its row number or if the sum of its row and column number equals the width of the grid minus 1, keep the cell's color the same. Otherwise, change the cell's color to the background color. The result will be a grid with two diagonal lines of colors, extending from the top left to the bottom right and from the top right to the bottom left, with the rest of the grid filled with the background color. 
:: def effabdjfbfhheehfbcccfdhdcibehcdd(grid):
  bg = mostcolor(grid)
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
          grid[i][j] if i == j or i + j == w - 1 else bg
          for j in range(w)
      )
      for i in range(h)
  )
 
10.333333333333334, tensor(0.2312), Description: Copy the input grid. Then, identify the least common color in the grid. Find the bounding box of the object with that color. Fill all cells outside the bounding box with black. The background of the output grid should be black. 
:: def ejjhjbhfgacdejccahfddcfabajecddf(I):
    # 1. Identify the color of the target object
    target_color = leastcolor(I) 

    # 2. Find all occurrences of the target color
    target_indices = ofcolor(I, target_color)

    # 3. Calculate the bounding box of the target object
    bounding_box = backdrop(target_indices)

    # 4. Create the frame by setting cells outside the object to 0
    O = fill(I, 0, bounding_box - target_indices)
    return O
 
19.333333333333332, tensor(0.1260), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def addgfdjjdfabeacgadgegafffeicgbbb(I):
  bg = mostcolor(I)  # Find the background color
  objs = objects(I, False, False, True)  # Get all non-background objects
  modified_objs = apply(lambda obj: delta(obj), objs)  # Get the outline of each object
  O = fill(I, bg, merge(modified_objs))  # Fill the outline with the background color
  return O
 
17.666666666666668, tensor(1.4501), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def efdgbebbeficeaafiabejcdbjfacccfj(I):
  """
  Calculates the delta (outline) of each object and paints it onto a blank grid.
  """
  mc = mostcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  O = canvas(mc, shape(I))
  for obj in objs:
      O = underpaint(O, toobject(delta(toindices(obj)), I))
  return O
 
9.333333333333334, tensor(1.7642), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the center of the object with the most common color. Draw a cross shape using the most common color, centered on the object's center. The cross should be one cell thick and should extend to the edges of the grid. The background of the output grid should be black. 
:: def cedceiifeahcedgjacdfcggjacjceiee(I):
  x1 = mostcommon(totuple(palette(I))) # Find the most common color
  x2 = ofcolor(I, x1) # Get indices of the most common color
  x3 = (uppermost(x2) + height(x2) // 2, leftmost(x2) + width(x2) // 2) # Find the center of the object
  x4 = sfilter(x2, lambda ij: ij[0] == x3[0] or ij[1] == x3[1]) # Keep only cross indices
  O = paint(canvas(0, shape(I)), recolor(x1, x4)) # Paint the cross on a blank canvas
  return O
 
12.666666666666666, tensor(1.6010), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. The border should be expanded by one square in each direction for each iteration. 
:: def efdgdfegdfeaecadbibdagihcbccgaee(grid):
  bg = mostcolor(grid)
  obj = toobject(ofcolor(grid, other(palette(grid), bg)), grid)
  outline = toindices(obj)
  for _ in range(width(obj)):
    outline = mapply(dneighbors, outline) - toindices(obj)
    outline = sfilter(outline, lambda loc: 0 <= loc[0] < len(grid) and 0 <= loc[1] < len(grid[0]))
  return paint(canvas(bg, shape(grid)), recolor(color(obj), outline))
 
18.333333333333332, tensor(0.2140), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color and the cell has at least one neighbor that is not the background color, change the cell's color to a different color that is not the background color. Otherwise, keep the cell's color the same. 
:: def dfieabfcbbadecebjjabidghdidfiibd(grid):
  bg = mostcolor(grid)
  return tuple(
    tuple(
      other(palette(grid), bg) if any(grid[max(0, min(i+di, len(grid)-1))][max(0, min(j+dj, len(grid[0])-1))] != bg for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]) and grid[i][j] == bg
      else grid[i][j] 
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
19.666666666666668, tensor(0.7964), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def edddecfdabhbebfbbgadfjbaadahcfej(I):
  # 1. Identify all objects in the grid
  objs = objects(I, T, F, T)

  # 2. Initialize the output grid with the input grid
  O = I 

  # 3. Iterate over each object
  for obj in objs:
    # 4. Get the bounding box of the object
    bounding_box = backdrop(obj)

    # 5. Fill the bounding box with the object's color, 
    #    excluding the object itself
    O = fill(O, color(obj), bounding_box - toindices(obj))

  return O
 
12.666666666666666, tensor(0.7964), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def djddjjabcbaeefacijaacadaadeaafeg(I):
  # 1. Get the background color
  bg_color = mostcolor(I)

  # 2. Create a canvas filled with the background color
  O = canvas(bg_color, shape(I))

  # 3. Iterate over all possible colors in the grid
  for c in palette(I):
    # 4. Skip if the color is the background
    if c == bg_color:
      continue

    # 5. Get indices of the current color
    indices = ofcolor(I, c)

    # 6. Draw the frame using the current color
    O = fill(O, c, box(indices) - indices) 
  return O
 
12.333333333333334, tensor(0.3040), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint the object onto a blank canvas of the same size as the input grid. The background of the output grid should be black. Then, draw a border around the object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. 
:: def ieaigafgeccgebbbbbajfdccagcdaifh(I):
  # 1. Create an empty canvas with the same shape as the input
  O = canvas(0, shape(I))

  # 2. Get all objects, excluding background
  objs = objects(I, T, F, T)

  # 3. Iterate over each object
  for obj in objs:
    # 4. Paint the object onto the canvas
    O = paint(O, obj)

    # 5. Get the bounding box of the object
    bounding_box = backdrop(obj)

    # 6. Fill the bounding box outline with the object's color 
    O = fill(O, color(obj), box(bounding_box) - toindices(obj)) 
  return O
 
19.666666666666668, tensor(0.7964), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def iaehfiehciiheejeaehidaddgghchbia(I):
  # 1. Get all objects
  objs = objects(I, T, F, T) 

  # 2. Initialize output as a copy of the input
  O = [list(row) for row in I] 

  # 3. Iterate over each object
  for obj in objs:
    # 4. Find the bounding box of the object
    min_row = min(i for _, (i, _) in obj)
    max_row = max(i for _, (i, _) in obj)
    min_col = min(j for _, (_, j) in obj)
    max_col = max(j for _, (_, j) in obj)

    # 5. Draw the frame
    for i in range(min_row, max_row + 1):
      for j in range(min_col, max_col + 1):
        if (i == min_row or i == max_row or j == min_col or j == max_col) and ((I[i][j], (i, j)) not in obj):
          O[i][j] = color(obj)
  
  return tuple(tuple(row) for row in O)
 
18.333333333333332, tensor(1.8263), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color and the cell has at least one neighbor that is not the background color, change the cell's color to the color of that neighbor. Otherwise, keep the cell's color the same. The result will be a grid where the background color is replaced with the color of the nearest non-background object. 
:: def edcccdjcgiiiedaciaijehfecfecfgfb(I):
  # 1. Get all object indices, excluding background
  object_indices =  set(
        (i, j)
        for i, row in enumerate(I)
        for j, val in enumerate(row)
        if val != mostcolor(I)
    )
  
  # 2. Initialize the output grid
  O = [[v for v in row] for row in I]

  # 3. Iterate over each cell in the grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # 4. Check if the cell is adjacent to an object cell
      if (i, j) not in object_indices and any(((i + di, j + dj) in object_indices 
                                                for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)])):
        # 5. Find the color of the adjacent object
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          if (i + di, j + dj) in object_indices:
            O[i][j] = I[i + di][j + dj]
            break  

  return tuple(tuple(row) for row in O)
 
14.0, tensor(0.7692), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Starting from the top left corner, perform a flood fill, marking all cells that are not the background color as "visited". After the flood fill, paint all cells that were not visited and have the background color onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def bebcibfceabaeeibbhbeefabhidebeed(I):
    """
    Employs a recursive approach to identify and outline the central object.
    """
    def flood_fill(grid, i, j, target_color, replacement_color):
        if i < 0 or i >= height(grid) or j < 0 or j >= width(grid) or grid[i][j] != target_color or grid[i][j] == replacement_color:
            return grid
        grid = fill(grid, replacement_color, {(i, j)})
        for (ni, nj) in dneighbors((i, j)):
            grid = flood_fill(grid, ni, nj, target_color, replacement_color)
        return grid

    c = mostcolor(I)
    O = canvas(0, shape(I))
    for i in range(height(I)):
        for j in range(width(I)):
            if I[i][j] == c:
                O = flood_fill(O, i, j, 0, c)
    return O 
 
11.333333333333334, tensor(1.7645), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the object with the most common color and its center of mass. Draw a cross shape using the most common color, centered on the object's center of mass. The cross should be one cell thick and should extend to the edges of the grid. The background of the output grid should be black. 
:: def hdjfdajcbbheefejbdbeaecacdhdbjfc(I):
  x1 = objects(I, T, T, T) # Extract all objects 
  x2 = mostcommon(totuple(apply(color, x1))) # Find the most common object color
  x3 = extract(x1, lambda obj: color(obj) == x2) # Find the object with the most common color
  x4 = centerofmass(x3) # Get the center of mass of the object
  x5 = toindices(x3) # Get the indices of the object
  x6 = {(i, x4[1]) for i, j in x5} # Keep only indices with same column index as center 
  x7 = {(x4[0], j) for i, j in x5} # Keep only indices with same row index as center
  O = paint(canvas(0, shape(I)), recolor(x2, x6 | x7)) # Paint the cross on a blank canvas
  return O
 
12.333333333333334, tensor(0.2269), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def fbcdfgffcgfheccebhcfhheeccdfgafe(I):
  # 1. Identify all objects in the grid excluding background
  objs = objects(I, T, F, T)
  
  # 2. Create a canvas filled with 0
  O = canvas(0, shape(I))

  # 3. Iterate over objects and draw outlines with least common color
  for obj in objs:
    outline = box(obj)
    O = paint(O, recolor(leastcolor(obj), outline))

  return O
 
17.666666666666668, tensor(0.2978), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the least common color. 
:: def dgabbagefbddejabibcdadfehcfabaae(I):
  # 1. Identify the object (assuming only one object exists)
  obj = next(iter(objects(I, T, F, T)))

  # 2. Find the least common color in the grid
  least_color = leastcolor(I)

  # 3. Create a canvas with the outline color
  O = canvas(least_color, shape(I))

  # 4. Fill the object's interior with 0
  O = fill(O, 0, toindices(obj))
  return O
 
12.666666666666666, tensor(0.4267), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the least common color in the grid. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ehjeaffdebaaeebfifcjacfbgibfhhej(I):
  # 1. Get object indices and background color
  objs = objects(I, T, F, T)
  bg = mostcolor(I)

  # 2. Initialize output grid with background color
  O = canvas(bg, shape(I))

  # 3. Iterate through objects and paint outlines
  for obj in objs:
    for i, j in toindices(obj):
      for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
        ni, nj = i + di, j + dj
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == bg:
          O = fill(O, leastcolor(I), {(ni, nj)})
  return O
 
3.0, tensor(0.3815), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color) and the least common color. Swap these two colors in the grid. Then, fill the areas that were originally the background color with black. The result will be a grid where the original background color is replaced with black, the original least common color is replaced with the original background color, and the rest of the grid remains unchanged. 
:: def aefdbciiiaebebdaiccfbcaeefehaach(I):
  # 1. Get background color
  bg = mostcolor(I)

  # 2. Invert the grid: swap background with least common color
  O = replace(I, bg, leastcolor(I))
  O = replace(O, leastcolor(I), bg)

  # 3. Fill original object areas with 0 
  O = fill(O, 0, ofcolor(I, bg))

  return O
 
16.666666666666668, tensor(0.0712), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color) and the cell has at least one neighbor that is the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def ebfbjbicaabjefddjhaefihffbdjcffb(I):
  bg = mostcolor(I)
  O = I  # Start with the original grid
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] != bg and any(I[i+di][j+dj] == bg for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]):
        O = fill(O, bg, {(i, j)}) # Fill with background if a neighboring cell is background
  return O
 
17.666666666666668, tensor(0.0656), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). For each cell in the grid, if the cell's color is the same as the most common color and the cell has at least one neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to black. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def adbebhagffciecjaiegdjeiieccceefa(I):
  """
  This version iterates through each cell and checks its neighbors to determine if it's on the outline.
  """
  c = mostcolor(I)
  O = canvas(0, shape(I))
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      if I[i][j] == c and any(I[k][l] != c for k, l in neighbors((i, j)) if 0 <= k < h and 0 <= l < w):
        O = paint(O, {(c, (i, j))})
  return O
 
7.333333333333333, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def eadebfffbfdcebchjagacabcbffggadb(I):
  """
  This version leverages the 'inbox' function to directly identify the outline indices.
  """
  c = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline = inbox(toindices(central_obj))
  O = paint(canvas(0, shape(I)), recolor(c, outline))
  return O
 
17.0, tensor(1.6655), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def jiheaiggidcieabcbcfadeecghabbceh(grid):
  bg = mostcolor(grid)
  obj_color = other(palette(grid), bg)
  obj = toobject(ofcolor(grid, obj_color), grid)
  outline = toobject(box(obj), grid)
  inner = difference(obj, outline)
  return paint(grid, recolor(bg, inner))
 
17.333333333333332, tensor(0.7547), Description: Copy the input grid. Then, identify the least common color and the most common color in the grid. Draw a border around the object that is not the background color using the most common color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. The background of the output grid should be the least common color. 
:: def cdcafhcafbcfefeaabccfecaaaefcjhf(I):
  # 1. Find the least and most common colors
  least_color = leastcolor(I)
  most_color = mostcolor(I)

  # 2. Create a canvas filled with the least common color
  O = canvas(least_color, shape(I))

  # 3. Get the object (assuming single object)
  obj = next(iter(objects(I, T, F, T)))

  # 4. Draw the object outline with the most common color
  O = underfill(O, most_color, box(toindices(obj)))

  # 5. Fill the object's interior with 0
  O = fill(O, 0, toindices(obj))
  return O
 
15.666666666666666, tensor(0.9065), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the least common color and the cell has at least one neighbor that is the least common color, change the cell's color to the most common color. Otherwise, change the cell's color to black. The result will be a grid where the least common color is the only color present, except for the outlines of the original objects, which will be filled with the most common color. The background of the output grid should be the least common color. 
:: def cbbjdgjgcabiecbcjdhcaabcgdcfdacc(I):
  # 1. Identify the least common color
  least_color = leastcolor(I)

  # 2. Create the output grid with the outline color
  O = canvas(least_color, shape(I))

  # 3. Iterate through each cell in the input grid
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != least_color:
        # 4. If a cell doesn't match the least common color, check its neighbors
        if any(0 <= i + di < height(I) and 0 <= j + dj < width(I) and I[i + di][j + dj] == least_color for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]):
          # 5. If a neighbor has the least common color, fill the current cell with the most common color
          O = fill(O, mostcolor(I), {(i, j)})
        else:
          # 6. Otherwise, fill the cell with 0
          O = fill(O, 0, {(i, j)})
  return O
 
14.0, tensor(0.1260), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def cefciaabhhhjeagiibacbfbabcabbdcc(I):
  bg = mostcolor(I) 
  objs = objects(I, False, False, True) 
  outlines = frozenset({(i,j) 
                       for obj in objs 
                       for (i,j) in backdrop(obj) 
                       if any((i + di, j + dj) not in toindices(obj) for di, dj in [(0,1),(1,0),(-1,0),(0,-1)])})
  O = fill(I, bg, outlines)
  return O
 
16.666666666666668, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def jdcbbddcehaaedibbjiedcfgaadfhidc(I):
  """
  This version identifies the central object and its bounding box,
  then iterates through the grid to paint the outline.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline = box(central_obj)
  O = canvas(bg, shape(I))
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      if (i, j) in outline:
        O = paint(O, {(c, (i, j))})
  return O
 
19.333333333333332, tensor(1.1207), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bjcebibjfjbdehagbidbbhiidbbcbdca(I):
  """
  This version leverages 'cellwise' to directly compare the grid
  with a modified version where only the outline is present.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline_grid = paint(canvas(bg, shape(I)), recolor(c, box(central_obj)))
  O = cellwise(I, outline_grid, bg)
  return O
 
18.0, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def fbdbbcfdcgijecjdjeifjfifcddgbdjb(I):
  """
  This version utilizes the 'delta' function to directly obtain 
  the outline indices of the central object.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline_indices = delta(toindices(central_obj))
  O = paint(canvas(bg, shape(I)), recolor(c, outline_indices))
  return O
 
18.333333333333332, tensor(0.2789), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using a different color that is not the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def hbjajejbjjaeefjaicbdabdiffibiiif(grid):
  bg = mostcolor(grid)
  obj_indices = ofcolor(grid, other(palette(grid), bg))
  return tuple(
    tuple(
      grid[i][j] if (i, j) not in box(obj_indices) else other(palette(grid), bg)
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
15.666666666666666, tensor(1.6680), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def ddefifaegbgbedcgabbbificaaefiaff(grid):
  bg = mostcolor(grid)
  obj_color = other(palette(grid), bg)
  obj_indices = ofcolor(grid, obj_color)
  return tuple(
    tuple(
      obj_color if (i, j) in box(obj_indices) else bg if (i, j) in obj_indices else grid[i][j] 
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
16.666666666666668, tensor(0.7903), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the least common color in the grid, draw a border around it using the most common color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. The background of the output grid should be the least common color. 
:: def bfhjjhfehigcecdjjceeaieihgdbgjei(I):
  # 1. Find the least and most common colors
  bg_color = leastcolor(I)
  outline_color = mostcolor(I)
  
  # 2. Create a canvas filled with the background color
  O = canvas(bg_color, shape(I))
  
  # 3. Get all the objects in the input
  objs = objects(I, T, F, T)
  
  # 4. For each object, draw its outline on the canvas
  for obj in objs:
    O = fill(O, outline_color, box(toindices(obj)))
  
  # 5. Fill the interior of each object with 0
  for obj in objs:
    O = fill(O, 0, toindices(obj))
  
  # 6. Return the final output grid
  return O
 
19.333333333333332, tensor(0.9086), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). For each cell in the grid, if the cell's color is the same as the most common color and the cell has at least one neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to black. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def edjbfefhbigjegchaghbfdjddidcaeif(I):
  # 1. Find the outline and background colors
  outline_color = mostcolor(I)
  bg_color = leastcolor(I)
  
  # 2. Create a canvas with the background color
  O = canvas(bg_color, shape(I))

  # 3. Get the indices of the outline
  outline_indices = set()
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == outline_color and any(0 <= i + di < height(I) and 0 <= j + dj < width(I) and I[i + di][j + dj] != outline_color for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]):
        outline_indices.add((i, j))

  # 4. Paint the outline onto the canvas
  for i, j in outline_indices:
    O = paint(O, {(outline_color, (i, j))})

  return O
 
7.333333333333333, tensor(1.1294), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace all instances of the most common color (the background color) with black. 
:: def ffgaddjcaaefecaijadieadeidfifejg(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  outlines =  frozenset({(i, j) for obj in objs for (i, j) in backdrop(obj) if any((i + di, j + dj) not in toindices(obj) for di, dj in [(0,1),(1,0),(-1,0),(0,-1)])}) 
  O = fill(I, bg, outlines)
  return replace(O, bg, 0)
 
16.333333333333332, tensor(0.1264), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def ffdgedbjagbfebcebbfffjejfababfjb(I):
  """
  Identifies the outline of the central object and paints it.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  outline = toindices(central_obj) - inbox(central_obj)
  O = paint(canvas(bg, shape(I)), recolor(c, outline))
  return O
 
19.333333333333332, tensor(0.0656), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). For each cell in the grid, if the cell's color is the same as the most common color and the cell has at least one neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to black. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects. 
:: def gcdcdfabgaaaefafbbhjhbbfhefadada(I):
  """
  Iterates through the grid and checks for neighboring cells.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  h, w = len(I), len(I[0])
  O = canvas(bg, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] == c and any(I[ni][nj] != c for ni, nj in dneighbors((i, j)) if 0 <= ni < h and 0 <= nj < w):
        O = fill(O, c, {(i, j)})
  return O
 
14.0, tensor(0.2496), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the object with the most common color and its bounding box. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def iafehcddfafbeeeejdbgddfceaffcace(I):
  c = mostcolor(I) # Find the dominant color
  objs = partition(I) # Partition the grid into objects based on color
  obj = extract(objs, lambda o: color(o) == c) # Extract the dominant object
  dilated = box(toindices(obj)) # Get the bounding box indices
  O = fill(canvas(0, shape(I)), c, dilated) # Fill the bounding box on a blank canvas 
  return O
 
18.333333333333332, tensor(0.2667), Description: Copy the input grid. Then, identify the object that is not the background color. For each cell in the grid, if the cell is part of the object and it does not have any neighbors that are also part of the object, change the cell's color to the background color. Otherwise, keep the cell's color the same. The result will be a grid where the object is filled with the background color, except for the outline of the object, which will remain the original color. The background of the output grid should be the most common color. 
:: def cdcgcdjcggeeefgfjefggdbabebafgeb(grid):
  bg = mostcolor(grid)
  obj_color = other(palette(grid), bg)
  obj_indices = ofcolor(grid, obj_color)
  new_grid = canvas(bg, shape(grid))
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if (i, j) in obj_indices and all((i + di, j + dj) not in obj_indices for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        new_grid = fill(new_grid, bg, {(i, j)})
      else:
        new_grid = fill(new_grid, grid[i][j], {(i, j)})
  return new_grid
 
16.666666666666668, tensor(0.2808), Description: Copy the input grid. Then, identify the object that is not the background color. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def hafagbaeigbbehcbiafbehfbeeecbhfc(grid):
  bg = mostcolor(grid)
  obj_color = other(palette(grid), bg)
  outline = box(ofcolor(grid, obj_color))
  return tuple(
    tuple(
      bg if (i, j) in outline else grid[i][j]
      for j in range(len(grid[0]))
    )
    for i in range(len(grid))
  )
 
15.666666666666666, tensor(0.2599), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, paint its diagonal neighbors with the same color. The background of the output grid should be black. 
:: def idfebahdjbbcedbiaaeaccdaaafjaede(I):
  # 1. Create a canvas filled with the background color
  O = canvas(mostcolor(I), shape(I))

  # 2. Iterate over all cells in the input grid
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      # 3. If a cell belongs to an object (not background)
      if value != mostcolor(I):
        # 4. Paint its neighbors (potential outline) with its color
        O = underfill(O, value, dneighbors((i, j)))
  return O
 
16.666666666666668, tensor(1.8237), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, paint its direct neighbors (up, down, left, right) with the same color. The background of the output grid should be the most common color. 
:: def jaaiiafdadaaedcaiedegcbdecebbccb(I):
  # 1. Create a canvas with the same shape as the input filled with background color
  O = canvas(mostcolor(I), shape(I))

  # 2. Get all objects from the input grid
  objs = objects(I, T, F, T)

  # 3. Iterate over each object
  for obj in objs:
    # 4. For each cell in the object:
    for value, (i, j) in obj:
      # 5. Fill its direct neighbors with object's color if they are background
      O = underfill(O, value, dneighbors((i, j)))

  return O
 
16.666666666666668, tensor(0.9714), Description: Copy the input grid. Then, identify the object with the most cells that are the same color as the background. Find the corners of the bounding box of this object. Paint those corners with the background color. The background of the output grid should be black. 
:: def cdjfefaaifcgecegjagceffeacjebhfa(I):
  """
  Identifies the central object and highlights its bounding box corners.
  """
  c = mostcolor(I)
  bg = other(palette(I), c)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  central_obj = argmax(objs, lambda obj: colorcount(obj, c))
  corners_indices = corners(central_obj) 
  O = paint(canvas(bg, shape(I)), recolor(c, corners_indices))
  return O 
 
16.333333333333332, tensor(0.2942), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the object with the most common color and its outline. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def chjfiefcbaaaefbbbeibjfecafciigdj(I):
  dom_color = mostcolor(I) 
  objs = objects(I, T, T, T)
  dom_obj = argmax(objs, lambda obj: colorcount(obj, dom_color))
  outline = delta(toindices(dom_obj))
  O = paint(canvas(0, shape(I)), recolor(dom_color, outline))
  return O 
 
19.0, tensor(0.2942), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the object with the most common color and its outline. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def jefdaceicbhhejdbihfdadeacgdfeheh(I):
  c = mostcolor(I)
  grid_indices = asindices(I)
  object_indices = toindices(argmax(objects(I, T, T, T), lambda o: colorcount(o, c)))
  outline = grid_indices - object_indices 
  O = paint(canvas(0, shape(I)), recolor(c, outline))
  return O
 
11.333333333333334, tensor(1.1557), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the object with the most common color and its bounding box. Draw a border around this object using the same color. The border should be one square thick and should only be drawn on the edges of the grid. The background of the output grid should be black. 
:: def ceaehcbadcdbecfjjfeeccbhbcaccabb(I):
  mc = mostcolor(I)
  objs = objects(I, T, T, T)
  obj = argmax(objs, lambda o: colorcount(o, mc))
  h, w = shape(I) 
  top_bottom = {(i, j) for i in (0, h - 1) for j in range(w)}
  left_right = {(i, j) for j in (0, w - 1) for i in range(h)}
  frame = top_bottom | left_right
  inner_outline =  box(toindices(obj)) 
  outline = inner_outline & frame
  O = paint(canvas(0, (h, w)), recolor(mc, outline))  
  return O
 
17.0, tensor(1.6498), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, paint its direct neighbors (up, down, left, right) with the same color. The background of the output grid should be the most common color. 
:: def cdjiddibbbieefaeafebcahdagbdcfaf(grid):
  bg = mostcolor(grid)
  obj_color = other(palette(grid), bg)
  outlined_grid = canvas(bg, shape(grid))
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val == obj_color:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          outlined_grid = fill(outlined_grid, obj_color, {(i+di, j+dj)})
  return outlined_grid
 
16.666666666666668, tensor(0.1736), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color and the cell has at least one neighbor that is not the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. Then, switch the background color with the least common color in the grid. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects, which will be filled with the least common color. The background of the output grid should be the least common color. 
:: def eaafiaccheaieaffiejbdedaifbjaage(I):
  bg = mostcolor(I)
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if any(index(I, (i + di, j + dj)) != bg  for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)] if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0])):
        O = fill(O, bg, {(i, j)})
  return switch(O, bg, leastcolor(O)) 
 
18.0, tensor(0.8859), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color) and the least common color. Swap these two colors in the grid. The result will be a grid where the original background color is replaced with the least common color, and the original least common color is replaced with the original background color. The rest of the grid remains unchanged. 
:: def djaebjegfaaaefiejfjhbafhafceiefh(I):
  return replace(I, mostcolor(I), leastcolor(I))
 
14.0, tensor(0.0028), Description: Copy the input grid. Then, identify the least common color in the grid. Replace all instances of the least common color with the most common color. Then, paint the resulting grid onto a blank canvas of the same size as the input grid, with the background color set to the least common color. The result will be a grid where the least common color is the only color present, except for the original objects, which will be painted with the most common color. 
:: def ggaefcdgbhfgeejfiiidjfhddeieiefe(I):
  return paint(canvas(leastcolor(I), shape(I)), asobject(replace(I, leastcolor(I), mostcolor(I))))
 
19.0, tensor(1.9912), Description: Copy the input grid. Then, identify the least common color in the grid. Find the object with that color and its outline. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the most common color. The background of the output grid should be the most common color. 
:: def fbefebfbfdfaeibcbhjjdbigjiecgcbh(I):
  """
  Leverages 'delta' to directly obtain the outline indices. 
  """
  dom_color = leastcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  dom_obj = extract(objs, lambda obj: color(obj) == dom_color)
  outline = delta(toindices(dom_obj))
  O = fill(I, mostcolor(I), toindices(dom_obj))
  O = fill(O, dom_color, outline)
  return O
 
17.0, tensor(0.0305), Description: Copy the input grid. Then, identify the least common color in the grid. For each cell in the grid, if the cell's color is the same as the least common color and the cell has at least one neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to the most common color. The result will be a grid where the least common color is the only color present, except for the outlines of the original objects, which will be filled with the most common color. The background of the output grid should be the least common color. 
:: def fchfecifccbbebgdaicbhajcbbejaaig(I):
  """
   Uses nested loops to directly find and outline the dominant object.
  """
  bg_color = mostcolor(I)
  dom_color = leastcolor(I)
  h, w = len(I), len(I[0])
  O = [[bg_color for _ in range(w)] for _ in range(h)]
  for i in range(1, h-1):
    for j in range(1, w-1):
      if I[i][j] == dom_color and any(I[i+di][j+dj] != dom_color for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]):
        O[i][j] = dom_color
  return tuple(tuple(row) for row in O)
 
7.333333333333333, tensor(0.0323), Description: Description: Copy the input grid. Then, identify the least common color in the grid. For each cell in the grid, if the cell's color is the same as the least common color and the cell has at least one neighbor with a different color, keep the cell's color the same. Otherwise, change the cell's color to the most common color. The result will be a grid where the least common color is the only color present, except for the outlines of the original objects, which will be filled with the most common color. The background of the output grid should be the least common color. 
:: def cegefcdabccceeeijfceijegigdbeadf(I):
  """
  Applies a convolution-like operation to detect and outline the dominant object.
  """
  dom_color = leastcolor(I)
  kernel = ((0,1,0),(1,0,1),(0,1,0))
  h, w = len(I), len(I[0])
  O = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(1, h-1):
    for j in range(1, w-1):
      if I[i][j] == dom_color and any(I[i+di-1][j+dj-1] != dom_color for di in range(3) for dj in range(3) if kernel[di][dj] == 1):
        O[i][j] = dom_color
  return tuple(tuple(row) for row in O)
 
16.666666666666668, tensor(0.1222), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bccchhgagfbfefccbgbjhgfaijbbceab(I):
    objs = objects(I, T, T, T)  # Extract all objects (excluding background)
    O = I 
    for obj in objs:
        O = fill(O, mostcolor(I),  box(obj)) #Fill bounding box with background color
    return O
 
14.0, tensor(0.1006), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color and the cell has at least one neighbor that is not the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def ffdebfbdfafheeididchfcjihcibfcbf(I):
  return  tuple(
      tuple(
          mostcolor(I) if any(I[k][l] != mostcolor(I) for k in range(max(0, i-1), min(len(I), i+2)) for l in range(max(0, j-1), min(len(I[0]), j+2))) else I[i][j]
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
14.0, tensor(0.0069), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are adjacent to the object's outline. Recolor this new object with the background color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def adfghibibcdfeiacigbjfecdeceejbeh(I):
    bg = mostcolor(I)
    objs = objects(I, False, False, True)
    return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(bg, delta(toindices(obj))), objs)))
 
19.666666666666668, tensor(1.1707), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color in the grid, create a new object that is a diamond shape, with the same color as the original object, and with the same center as the original object. The diamond should be as large as possible while still containing all the cells of the original object. Paint these new diamond objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def fbjfbgadhfjjeaiabfaedbejfbfdadef(I):
    objs = objects(I, False, False, True)
    bg = mostcolor(I)
    canvas_size = shape(I)
    O = canvas(bg, canvas_size)
    for obj in objs:
        indices = toindices(obj)
        center_i, center_j = center(indices)
        sorted_indices = sorted(indices, key=lambda x: abs(x[0] - center_i) + abs(x[1] - center_j))
        diamond_indices = set()
        current_distance = 0
        for i, (x, y) in enumerate(sorted_indices):
            if abs(x - center_i) + abs(y - center_j) > current_distance:
                current_distance += 1
            diamond_indices.add((x, y))
            if len(diamond_indices) == len(indices):
                break
        diamond_obj = toobject(frozenset(diamond_indices), I)
        O = paint(O, diamond_obj)
    return O
 
3.0, tensor(0.8859), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color) and the least common color. Swap these two colors in the grid. The result will be a grid where the original background color is replaced with the least common color, and the original least common color is replaced with the original background color. The rest of the grid remains unchanged. 
:: def dbdiacgbiiicebfjicjejgiieiiegdfc(I):
  return replace(replace(I, mostcolor(I), 0), leastcolor(I), mostcolor(I)) 
 
19.666666666666668, tensor(1.1668), Description: Copy the input grid. Then, identify the object with the smallest size (likely the cross). Paint this object onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def bcffbdhaeaeieeghbeajcfcbbbfbhcec(I):
  objs = partition(I)  # Partition grid into objects based on color
  cross = argmin(objs, size) # Find the object with the smallest size (the cross)
  return paint(canvas(mostcolor(I), shape(I)), cross) # Paint the cross on a canvas of the background color
 
14.666666666666666, tensor(1.9212), Description: Copy the input grid. Then, identify the least common color in the grid. Find the object with that color and its bounding box. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the most common color. The background of the output grid should be the most common color. 
:: def aagjdgccfccbeijdjdcgjchdbdcibdfd(I):
  """
  Identifies the dominant object, outlines it with the background 
  color, and fills the rest of the grid with the background color.
  """
  bg_color = mostcolor(I)
  dom_color = leastcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  dom_obj = extract(objs, lambda obj: color(obj) == dom_color)
  outline = box(dom_obj)
  O = fill(I, bg_color, asindices(I))
  O = fill(O, dom_color, outline)
  return O
 
13.333333333333334, tensor(1.9887), Description: Copy the input grid. Then, identify the least common color in the grid. Find the object with that color and its outline. Expand the outline by one square in each direction. Draw a border around this object using the same color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the most common color. The background of the output grid should be the most common color. 
:: def ddhddffdhhhceahdjeebeehcddhdiccd(I):
  """
  Iteratively expands the dominant object to find its outline.
  """
  bg_color = mostcolor(I)
  dom_color = leastcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  dom_obj = extract(objs, lambda obj: color(obj) == dom_color)
  outline = toindices(dom_obj)
  O = fill(I, bg_color, asindices(I))
  for _ in range(1):
    outline = mapply(dneighbors, outline) - outline
    outline = sfilter(outline, lambda loc: 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]))
    outline = sfilter(outline, lambda loc: I[loc[0]][loc[1]] == bg_color)
  O = fill(O, dom_color, outline)
  return O
 
8.666666666666666, tensor(1.1021), Description: Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Replace all instances of this most common color with black. The result will be a grid where the most common color is replaced with black, and the rest of the grid remains unchanged. 
:: def bcdfgbefbcabeaabjbfadjafdhdfjccd(I):
  """
  Identifies the background color and replaces it with 0 while preserving other colors.
  """
  bg = mostcolor(I)
  return tuple(tuple(0 if v == bg else v for v in r) for r in I)
 
7.666666666666667, tensor(0.0556), Description: Description: Copy the input grid. Then, identify the object that is not the background color and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def aibjaddcdabaedcajfhefcgfjhfeafcf(I):
  """
  Extracts the foreground object and paints it onto a canvas initialized with 0s. 
  """
  obj = next(iter(objects(I, univalued=False, diagonal=False, without_bg=True)))  # Extract the foreground object
  return paint(canvas(0, shape(I)), obj) # Paint the object onto a 0-filled canvas
 
19.666666666666668, tensor(1.0838), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid and the cell has at least one neighbor that is not the same color, change the cell's color to the background color. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def deigdbdjhbjfeadfbgdaejbfegcaajfb(I):
  bg = mostcolor(I)
  return paint(I, prapply(lambda i, j: (bg, (i, j)) if any(n in delta(toindices(asobject(crop(I, (i, j), UNITY)))) for n in neighbors((i, j))) else (I[i][j], (i, j)), interval(0, height(I), 1), interval(0, width(I), 1))) 
 
15.0, tensor(0.8238), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color) and the cell has at least one neighbor (left or right) that is not the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. Then, for each cell in the grid, if the cell's color is the same as the background color, change the cell's color to the least common color. Otherwise, keep the cell's color the same. The result will be a grid where the most common color is the only color present, except for the outlines of the original objects, which will be filled with the least common color. The background of the output grid should be the least common color. 
:: def fefccecejfbeecafbfbgeiibagjacfje(I):
    bg = mostcolor(I)
    return cellwise(I, apply(lambda row: tuple(bg if any(v != bg for v in [row[(j + k) % len(row)] for k in [-1, 1]]) else row[j] for j in range(len(row))), I), bg)
 
17.666666666666668, tensor(1.1707), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color in the grid, create a new object that is a diamond shape, with the same color as the original object, and with the same center as the original object. The diamond should be as large as possible while still containing all the cells of the original object. Paint these new diamond objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def ajedddbffjhfecdabedjgcadbbbdjjeb(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    center_i, center_j = center(toindices(obj))
    diamond = frozenset((i, j) for i, j in toindices(obj) if abs(i - center_i) + abs(j - center_j) <= min(height(obj), width(obj)) // 2)
    O = paint(O, toobject(diamond, I))
  return O 
 
18.333333333333332, tensor(1.1734), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color in the grid, create a new object that is a diamond shape, with the same color as the original object, and with the same center as the original object. The diamond should be as large as possible while still containing half of the cells of the original object. Paint these new diamond objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def addheabffddbefgcbccaegcjhibfbabe(I):
  objs = objects(I, False, False, True)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    indices = sorted(toindices(obj), key=lambda x: (abs(x[0] - center(toindices(obj))[0]) + abs(x[1] - center(toindices(obj))[1])))
    diamond = frozenset(indices[:len(indices)//2+1])
    O = underpaint(O, toobject(diamond, I))
  return O
 
19.666666666666668, tensor(0.0052), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Replace all instances of this most common color with the color 1. Then, paint the resulting grid onto a blank canvas of the same size as the input grid, with the background color set to black. The result will be a grid where the most common color is replaced with the color 1, and the rest of the grid is black. 
:: def fccebeecheaaebjcjjfdeaaeefjiiedc(I):
  return paint(canvas(ZERO, shape(I)), asobject(replace(I, mostcolor(I), ONE)))
 
7.333333333333333, tensor(1.1338), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color in the grid, change the cell's color to black. Otherwise, keep the cell's color the same. 
:: def cicgjfjddbaaeeieaegjgeeeicfbfdae(I):
  return cellwise(I, canvas(ZERO, shape(I)), ZERO) 
 
14.333333333333334, tensor(0.0158), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the largest object that is not the background color and its outline. Fill all cells except those in the outline with the background color. The background of the output grid should be the most common color. 
:: def igjfbjadabfjeafbaaijgddedhabifai(I):
  """
  Finds the outline of the largest object formed by the most common color.
  """
  bg_color = mostcolor(I)  # Find the background color
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)  # Get all objects excluding background
  dom_obj = argmax(objs, size)  # Find the largest object
  outline = delta(toindices(dom_obj))  # Get the outline indices
  O = fill(I, bg_color, asindices(I)-outline) # Set everything but the outline to background
  return O
 
14.333333333333334, tensor(1.1141), Description: Copy the input grid. Then, identify the least common color in the grid. Find the largest object that is not the background color and its outline. Draw a border around this object using the least common color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def acbdcfdiadfbefhdadcdeadcceafbbde(I):
  """
  Paints the outline directly on a blank canvas.
  """
  bg_color = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  dom_obj = argmax(objs, size)
  outline = delta(toindices(dom_obj))
  O = canvas(bg_color, shape(I)) # Create a blank canvas filled with bg_color
  O = paint(O, recolor(leastcolor(I), outline)) # Paint the outline 
  return O
 
19.333333333333332, tensor(0.1222), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ddjgcebedgdaeadjiiegajedbabbfbdg(I):
  objs = objects(I, T, T, T)  # Extract all objects (excluding background)
  O = I
  for obj in objs:
    O = fill(O, mostcolor(I), difference(box(obj), toindices(obj))) # Fill inside of the bounding box with background color
  return O 
 
17.0, tensor(0.6196), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ffdjbfcjfdabehjjibdebaeheddehceb(I):
  objs = objects(I, T, T, T)
  O = canvas(mostcolor(I), shape(I))  # Create a canvas filled with background color
  for obj in objs:
    O = paint(O, toobject(box(obj), I)) # Paint the bounding box outline onto the canvas
  return O
 
17.0, tensor(0.6196), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def hebebcgbcbafeaeejgfgjaaeefgheeic(I):
  O = I
  for obj in objects(I, T, T, T):
    O = underfill(cover(O, obj), color(obj), box(obj)) # Cover object, then underfill bounding box
  return O
 
19.666666666666668, tensor(0.5572), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. The border should be drawn only on cells that are directly adjacent to the object. 
:: def gcdbebccfeacefeejcefeahdhiecdfad(I):
  O = I
  for obj in objects(I, T, T, T):
    for i, j in difference(box(obj), toindices(obj)):
      if any((i + di, j + dj) in toindices(obj) for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]):
        O = paint(O, {(color(obj), (i,j))}) # Paint only if a directly adjacent cell belongs to the object
  return O
 
16.666666666666668, tensor(0.0068), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are not adjacent to the object's outline. Recolor this new object with the original object's color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def eabcgegbjaibebbabchcjdaaffjhjedd(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(color(obj), sfilter(toindices(obj), lambda ind: not any(n in delta(toindices(obj)) for n in neighbors(ind)))), objs)))
 
8.666666666666666, tensor(0.9598), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def cdaiebddhacaeadabcfdeicfdbebcbfa(I):
  # Replace background color with 0
  O = replace(I, mostcolor(I), ZERO)
  # Get objects without background
  objs = fgpartition(O)
  # Create a canvas of 0s
  canvas_grid = canvas(ZERO, shape(I))
  # Paint the outline of each object onto the canvas
  for obj in objs:
    canvas_grid = paint(canvas_grid, toobject(box(obj), O))
  return canvas_grid
 
15.666666666666666, tensor(0.9598), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def cafceaagdjcbedjajdfgiaffieccedec(I):
  # Directly paint object outlines onto a canvas of 0s
  return paint(canvas(ZERO, shape(I)), toobject(
    merge([box(obj) for obj in fgpartition(I)]), I))
 
15.666666666666666, tensor(0.9598), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def eigdiddcadjfebdbjedajfbcdceadhib(I):
  # Create a grid with 1s where the background color was
  bg_mask = replace(I, mostcolor(I), ONE)
  # Subtract the background mask from the original grid
  O = cellwise(I, bg_mask, ZERO)
  # Paint object outlines onto the modified grid
  return paint(O, toobject(merge([box(obj) for obj in fgpartition(I)]), I))
 
12.0, tensor(0.9196), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the largest object that is not the background color and its outline. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def jagdgjjibgeaeaifbhjdggjfchdhjbhb(I):
  """
  Uses object detection and manipulation to identify and outline the 
  dominant object.
  """
  bg_color = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  dom_obj = argmax(objs, size)
  outline = delta(toindices(dom_obj))
  O = fill(canvas(0, shape(I)), bg_color, outline)
  return O
 
3.0, tensor(1.1222), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color) and the cell has at least one neighbor that is the background color, change the cell's color to the background color. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def hjigedddfdhfebjdjhabdheeadbfaejh(I):
  """
  Iterates over each cell and checks its neighbors to determine if 
  it's part of the outline.
  """
  bg_color = mostcolor(I)
  O = canvas(0, shape(I))
  h, w = shape(I)
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg_color and any(index(I, (i+di, j+dj)) == bg_color for di, dj in [(0,1),(0,-1),(1,0),(-1,0)] if 0<=i+di<h and 0<=j+dj<w):
        O = fill(O, bg_color, {(i, j)})
  return O
 
13.333333333333334, tensor(1.1195), Description: Copy the input grid. Then, identify the most common color in the grid (likely the background color). Find the largest object that is not the background color and its outline. Draw a border around this object using the background color. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with black. The background of the output grid should be black. 
:: def ehidecfbabicedbeigecgefeefidcgea(I):
  """
  Employs a two-step process: first marking the outline with a 
  temporary color, then restoring the background.
  """
  bg_color = mostcolor(I)
  temp_color = 1 if bg_color != 1 else 0  # Choose a temporary color
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  dom_obj = argmax(objs, size)
  O = fill(I, temp_color, delta(toindices(dom_obj)))
  O = replace(O, bg_color, 0)
  O = replace(O, temp_color, bg_color)
  return O
 
18.333333333333332, tensor(1.1720), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color in the grid, create a new object that is a diamond shape, with the same color as the original object, and with the same center of mass as the original object. The diamond should be as large as possible while still containing all the cells of the original object. Paint these new diamond objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def jggaceehbdacedgbigbbcbjddgbccicb(I):
  objs = objects(I, False, False, True)  # Extract objects (excluding background)
  O = canvas(mostcolor(I), shape(I))    # Create a canvas filled with the background color
  for obj in objs:
    center_i, center_j = centerofmass(obj)  # Find the center of mass of the object
    diamond = frozenset({(I[i][j], (i, j)) for i, j in toindices(obj) if abs(i - center_i) + abs(j - center_j) <= width(obj) // 2}) # Extract diamond shape
    O = paint(O, diamond)  # Paint the diamond onto the canvas
  return O
 
17.0, tensor(1.6229), Description: Copy the input grid. Then, draw a circle in the center of the grid using the colors from the input grid. The circle should be as large as possible while still fitting within the grid. The background of the output grid should be the most common color. 
:: def cfheghebcbdeefiajdcecjcccgaijdee(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if abs(i - height(I)//2) + abs(j - width(I)//2) <= width(I)//2:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
16.666666666666668, tensor(1.9823), Description: Copy the input grid. Then, rotate the grid 270 degrees, trim any empty rows or columns, and then rotate it back 90 degrees. This effectively shifts the entire grid one step down and to the right. Finally, replace the background color with black. 
:: def fdacdedafjeiebfgjbhhecijefhiieja(I):
  bg = mostcolor(I)  # Find the background color
  shifted_grid = rot90(trim(rot270(I))) # Shift the grid by rotating, trimming, and rotating back
  O = replace(shifted_grid, bg, 0) # Replace the background color with 0
  return O
 
8.0, tensor(1.9830), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, shift the object one square to the left and up. Paint these shifted objects onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def fgcfaageeccfebcgbbaiaebccebhgefd(I):
  objs = objects(I, univalued=False, diagonal=True, without_bg=True) # Extract objects
  shifted_objs = frozenset({shift(obj, (-1,-1)) for obj in objs}) # Shift each object
  O = paint(canvas(0, shape(I)), merge(shifted_objs)) # Paint onto a blank canvas
  return O
 
15.0, tensor(1.9820), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is the same as the background color, shift the cell one square down and to the right. If the shifted cell is within the bounds of the grid, fill the cell that was one square to the left and up from the shifted cell with the color of the original cell. The background of the output grid should be black. 
:: def cachaacdacbcedefaeeceicccdfdhfaa(I):
  bg = mostcolor(I)
  indices = ofcolor(I, bg) # Get indices of background color
  shifted_indices = shift(indices, (1, 1)) # Shift indices down-right
  O = I # Start with the original grid
  O = fill(O, 0, indices) # Replace background with 0
  for i, j in shifted_indices: # Iterate over shifted indices
    if 0 <= i < len(I) and 0 <= j < len(I[0]): # Check boundaries
      O = fill(O, I[i][j], {(i-1, j-1)}) # Fill the top-left position
  return O
 
7.666666666666667, tensor(1.8024), Description: Copy the input grid. Then, for each cell in the grid, if the cell is not on the top row or the leftmost column, and its top-left neighbor is not the background color, fill the cell with the color of its top-left neighbor. Otherwise, fill the cell with black. The result will be a grid where the top row and leftmost column are black, and the rest of the grid is filled with the colors of the top-left neighbors of each cell, except where the top-left neighbor is the background color. 
:: def eahadiabdbbhebhfbhieicbfajhbdbfh(I):
  bg = mostcolor(I)
  O = tuple(tuple(0 if j==0 or i==0 else I[i-1][j-1] if I[i-1][j-1]!=bg else 0 for j in range(len(I[0]))) for i in range(len(I)))
  return O
 
8.666666666666666, tensor(0.0014), Description: Copy the input grid. Then, identify the most frequent color in the grid (likely the background color). Replace all instances of this most frequent color with black. The result will be a grid where the most common color is replaced with black, and the rest of the grid remains unchanged. 
:: def eddfaaddfgcdecbebbhhcafecdfifbeg(I):
  """
  Replaces all occurrences of the most frequent color with 0, 
  effectively highlighting the cross formed by the least frequent color.
  """
  dom_color = mostcolor(I)  # Identify the most frequent color
  O = replace(I, dom_color, 0)  # Replace all occurrences with 0
  return O
 
7.666666666666667, tensor(1.1176), Description: Copy the input grid. Then, identify the least frequent color in the grid. Find the object with that color and paint it onto a blank canvas of the same size as the input grid. The background of the output grid should be black. 
:: def afjefagehbcieejgicddfbbhabjabbaa(I):
  """
  Extracts the object formed by the least frequent color, 
  paints it on a blank canvas, and returns the canvas.
  """
  least_color = leastcolor(I)  # Identify the least frequent color
  objs = objects(I, univalued=True, diagonal=False, without_bg=True) 
  target_obj = extract(objs, lambda obj: color(obj) == least_color)  # Extract the object
  O = canvas(0, shape(I))  # Create a blank canvas
  O = paint(O, target_obj)  # Paint the extracted object onto the canvas
  return O
 
14.333333333333334, tensor(1.7774), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def eaifecaffjbeedaeacbibeccdfbccjja(I):
  O = canvas(mostcolor(I), shape(I)) # Create a canvas with background color
  for obj in objects(I, T, T, T): # Iterate over all objects
    O = paint(O, toobject(box(obj), I)) # Paint the outline directly onto the canvas
    O = fill(O, mostcolor(I), toindices(obj)) # Fill the object's interior with background color
  return O
 
18.0, tensor(1.4883), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def edbfhacebfebedffaafajbbeiibbajfj(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(color(obj), box(toindices(obj))), objs)))
 
16.666666666666668, tensor(0.0134), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the outline of the original object. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def aagadccffjgbeccfiiegabibhebefcgf(I):
  bg = mostcolor(I)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(color(obj), difference(box(toindices(obj)),  inbox(toindices(obj)))), objects(I, False, False, True))))
 
18.0, tensor(1.9904), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the rest of the grid with the most common color. The background of the output grid should be the most common color. 
:: def aeadgdcbeghfebaebbjbeddehdeciffb(I):
  bg = mostcolor(I)
  return cellwise(I, paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(color(obj), box(toindices(obj))), objects(I, False, False, True)))), bg)
 
18.0, tensor(1.4886), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def dadfbeggcbebegbgacfidfaebififjbf(I):
    objs = objects(I, False, False, True)  # Extract objects from the input grid
    O = canvas(mostcolor(I), shape(I))    # Create a canvas filled with the background color
    for obj in objs:
        boundary = box(toindices(obj))  # Find the bounding box indices
        O = underpaint(O, toobject(boundary, I)) # Paint the boundary on the canvas
    return O
 
14.333333333333334, tensor(1.4886), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def cdfbgbedadddeeebieejjhhdbefjaach(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    border = delta(toindices(obj)) # Find indices within the bounding box but not part of the object
    O = paint(O, toobject(border, I))  # Paint the border onto the canvas
  return O
 
8.0, tensor(1.0641), Description: Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color) and the cell has at least one neighbor (including diagonal neighbors) that is not the background color, change the cell's color to black. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def eeaeaddihfaeeafdbdbeabdefejfdibf(I):
  """
  Creates a frame of zeros around cells that don't have the most frequent color.
  """
  most_common = mostcolor(I)
  return tuple(
      tuple(
          0 if any(I[k][l] != most_common for k in range(max(0, i-1), min(len(I), i+2)) for l in range(max(0, j-1), min(len(I[0]), j+2))) else I[i][j]
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
19.333333333333332, tensor(1.0992), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def fbdagfbbcaadefdcjcddbbbjbifbdajg(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True) 
  border_cells =  merge(apply(lambda obj: difference(box(toindices(obj)), toindices(obj)), objs))
  return paint(I, recolor(bg, border_cells))
 
16.0, tensor(1.1442), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, identify the cells that are on the outer edge of the object (those with only one neighboring cell of the same color). Fill those outer edge cells with the background color. The background of the output grid should be the most common color. 
:: def ffgbchdegjcgegdaacecbfigccaiabee(I):
    O = I
    for obj in objects(I, F, F, T):
        for i, j in toindices(obj):
            if len(intersection(toindices(obj), dneighbors((i, j)))) == 1:
                continue
            else:
                O = fill(O, mostcolor(I), {(i, j)})
    return O
 
15.0, tensor(1.9862), Description: Copy the input grid. Then, identify the most common color (likely the background color) and the least common color. Replace the most common color with black. Fill the entire grid with the least common color. Then, restore the original background color to the four corners of the grid. Finally, draw a vertical line of the background color down the center of the grid, excluding the top and bottom cells, and a horizontal line across the center of the grid, excluding the leftmost and rightmost cells. The result will be a grid with a cross shape formed by the background color in the center, with the rest of the grid filled with the least common color. 
:: def feefjaedbcdceabaiccedaecdidjccgb(I):
    bg = mostcolor(I)
    lc = leastcolor(I)
    O = replace(I, bg, 0)  # Use 0 as temporary placeholder
    O = fill(O, lc, asindices(O))  # Fill everything with least common color
    h, w = len(I), len(I[0])
    O = fill(O, bg, {(0, 0), (0, w-1), (h-1, 0), (h-1, w-1)})  # Restore corners
    O = fill(O, bg, connect((1, w // 2), (h-2, w // 2))) # Vertical line (excluding ends)
    O = fill(O, bg, connect((h // 2, 1), (h // 2, w-2))) # Horizontal line (excluding ends)
    return O
 
17.333333333333332, tensor(1.9851), Description: Copy the input grid. Then, identify the least common color in the grid. Fill the entire grid with the least common color. Then, restore the original colors of the top-left, top-right, bottom-left, and bottom-right corners of the grid. Finally, draw a vertical line of the color of the center cell down the center of the grid, excluding the top and bottom cells, and a horizontal line across the center of the grid, excluding the leftmost and rightmost cells. The result will be a grid with a cross shape formed by the color of the center cell in the center, with the rest of the grid filled with the least common color. 
:: def aaacbgddccaaechebbgeedcfedbdceff(I):
  lc = leastcolor(I)
  O = canvas(lc, shape(I))  # Create canvas with least common color
  h, w = len(I), len(I[0])
  O = fill(O, I[0][0], {(0, 0)}) # Restore top-left corner from input
  O = fill(O, I[0][w-1], {(0, w-1)}) # Restore top-right corner
  O = fill(O, I[h-1][0], {(h-1, 0)}) # Restore bottom-left corner
  O = fill(O, I[h-1][w-1], {(h-1, w-1)}) # Restore bottom-right corner
  O = fill(O, I[h//2][w//2], connect((1, w // 2), (h-2, w // 2))) # Vertical line
  return fill(O, I[h//2][w//2], connect((h // 2, 1), (h // 2, w-2))) # Horizontal line
 
19.333333333333332, tensor(1.1072), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def geagecjffbddecjbifjaabedaaceggbb(grid):
  """
  Finds the outbox of the largest object and fills it with background color.
  """
  bg_color = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  dom_obj = argmax(objs, size)
  outline = outbox(toindices(dom_obj)) # Use outbox for direct outline
  return fill(grid, bg_color, outline) 
 
31.333333333333332, tensor(0.1378), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color (the background color), keep the cell's color the same if it has both a right and a down neighbor that are also part of the object. Otherwise, change the cell's color to the background color. The result will be a grid where the background color is the only color present, except for the outlines of the original objects. 
:: def feehcedcjjjaeadajabhbcfbaaajafde(I):
    mc = mostcolor(I)
    return tuple(
        tuple(
            I[i][j] if any((i + di, j + dj) in toindices(obj) and (i - di, j - dj) in toindices(obj) for di, dj in [(0, 1), (1, 0)]) else mc
            for j in range(len(I[0]))
        )
        for i in range(len(I))
        for obj in objects(I, T, T, T)
    )
 
7.666666666666667, tensor(1.9824), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color), shift the cell one square down and to the right. If the shifted cell is within the bounds of the grid, fill the cell that was one square to the left and up from the shifted cell with the color of the original cell. The background of the output grid should be black. 
:: def baieccfefjideeefibdfdhbdbbifjefg(I):
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        if i+1 < h and j+1 < w:
          O = paint(O, {(I[i][j], (i+1, j+1))})
  return O
 
17.666666666666668, tensor(1.9824), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color), shift the cell one square down and to the right. If the shifted cell is within the bounds of the grid, fill the cell that was one square to the left and up from the shifted cell with the color of the original cell. The background of the output grid should be black. 
:: def ciccdjbaceggehfeaeffdfbjfhieadac(I):
  shifted = canvas(mostcolor(I), shape(I))
  for i in range(height(I)-1):
    for j in range(width(I)-1):
      shifted = paint(shifted, {(I[i][j], (i+1, j+1))})
  O = cellwise(I, shifted, 0)
  return O
 
8.333333333333334, tensor(1.9851), Description: Copy the input grid. Then, identify the least common color in the grid. Fill the entire grid with the least common color. Then, restore the original colors of the top-left, top-right, bottom-left, and bottom-right corners of the grid. Finally, draw a vertical line of the color of the center cell down the center of the grid, excluding the top and bottom cells, and a horizontal line across the center of the grid, excluding the leftmost and rightmost cells. The result will be a grid with a cross shape formed by the color of the center cell in the center, with the rest of the grid filled with the least common color. 
:: def bdfbhdggaadhejchjdfcfdhejbfgibfb(I):
  h, w = len(I), len(I[0])
  lc = leastcolor(I)
  O = fill(canvas(lc, (h, w)), 0, backdrop(asindices(I))) # Frame
  O = fill(O, lc, connect((1, w // 2), (h-2, w // 2))) # Vertical line
  return fill(O, lc, connect((h // 2, 1), (h // 2, w-2))) # Horizontal line
 
18.0, tensor(1.9851), Description: Copy the input grid. Then, identify the least common color in the grid. Fill the entire grid with the least common color. Then, restore the original colors of the top-left, top-right, bottom-left, and bottom-right corners of the grid. Finally, draw a vertical line of the color of the center cell down the center of the grid, excluding the top and bottom cells, and a horizontal line across the center of the grid, excluding the leftmost and rightmost cells. The result will be a grid with a cross shape formed by the color of the center cell in the center, with the rest of the grid filled with the least common color. 
:: def jhchceedafeceachieccacebjeeehafe(I):
  h, w = len(I), len(I[0])
  lc = leastcolor(I)
  O = fill(I, lc, {(i, 0) for i in range(h)} | {(i, w-1) for i in range(h)}) # Vertical frame
  O = fill(O, lc, {(0, j) for j in range(w)} | {(h-1, j) for j in range(w)}) # Horizontal frame
  O = fill(O, lc, connect((1, w // 2), (h-2, w // 2)))
  return fill(O, lc, connect((h // 2, 1), (h // 2, w-2)))
 
19.333333333333332, tensor(1.2086), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, paint the original object back onto the grid. The background of the output grid should be the most common color. 
:: def bffjdjgfbcaieaggbahdcbbhhaaigjdd(grid):
  """
  Identifies the largest object and outlines it with the background color.
  """
  bg = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, size)
  outline = delta(toindices(largest_obj))
  return paint(fill(grid, bg, outline), largest_obj)
 
14.0, tensor(1.1072), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bjgegcffdicceedajficcecbaadddieh(grid):
  """
  Directly identifies and outlines the largest object using nested loops.
  """
  bg = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, size)
  h, w = shape(grid)
  output = [[bg for _ in range(w)] for _ in range(h)]
  for i, j in toindices(largest_obj):
    if any((i + di, j + dj) not in toindices(largest_obj) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
      output[i][j] = bg
    else:
      output[i][j] = grid[i][j]
  return tuple(tuple(row) for row in output)
 
16.0, tensor(1.1072), Description: Copy the input grid. Then, identify the largest object (by area) that is not a single-colored square. Draw a black border around this object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def ehgfagdeegiaeaggbgfachibfbaadfee(grid):
  """
  Iterates through the grid, identifying and outlining cells belonging to the largest object.
  """
  bg = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, size)
  h, w = shape(grid)
  output = [[grid[i][j] for j in range(w)] for i in range(h)]
  for i in range(h):
    for j in range(w):
      if (i, j) in toindices(largest_obj) and any((i + di, j + dj) not in toindices(largest_obj) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        output[i][j] = bg
  return tuple(tuple(row) for row in output)
 
16.666666666666668, tensor(0.2028), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be black. 
:: def baefabecedbdedcjacabcfcabeibifba(I):
  O = canvas(0, shape(I)) # Initialize output grid with 0s
  for obj in objects(I, T, T, T):
    O = paint(O, recolor(color(obj), delta(obj))) # Paint the delta (border) of each object with its original color
  return O
 
18.333333333333332, tensor(1.1947), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with black. The background of the output grid should be the most common color. 
:: def cdcdcdbiaijeegaiabfdgjjfdaajadbe(I):
  O = I
  for obj in objects(I, T, T, T):
    O = fill(O, 0, toindices(obj)) # Fill the object itself with 0s
    O = underfill(O, color(obj), box(obj)) # Fill the bounding box with object color, but only where it was originally background
  return O
 
7.333333333333333, tensor(1.0944), Description: Copy the input grid. For each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should only be drawn on the cells that are directly adjacent to the outline of another object. The background of the output grid should be black. 
:: def ddjachceeefjechbjgcadhbigdfeeeid(I):
  objs = objects(I, T, T, T)
  O = canvas(0, shape(I))
  for obj in objs:
    for other_obj in objs:
      if other_obj != obj and adjacent(obj, other_obj):
        O = paint(O, recolor(color(obj), intersection(box(obj), delta(other_obj))))
  return O
 
17.333333333333332, tensor(0.0605), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, replace the object with black. Then, for each object, paint the cells that are directly adjacent to the object's center of mass with the object's original color. The background of the output grid should be the most common color. 
:: def efegbachcbhhefbfajffeebefedcdgbc(I):
  O = I
  for obj in objects(I, T, T, T):
    surrounding = difference(neighbors(centerofmass(obj)), toindices(obj)) # Find neighboring indices not part of the object
    O = fill(O, 0, toindices(obj)) # Replace object with 0s
    O = underfill(O, color(obj), surrounding) # Fill surrounding cells with object's color if they were originally background
  return O
 
14.0, tensor(0.5572), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. The border should be drawn only on cells that are directly adjacent to the object. 
:: def fgciebjaadabeidfabeeddbdcdchcaif(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in objects(I, T, T, T):
    border = difference(box(obj), toindices(obj)) # Find border indices
    for i, j in border:
      if any((i + di, j + dj) in toindices(obj) for di, dj in [(0,1), (1,0), (0,-1), (-1,0)]): # Check if the border cell is adjacent to the object
        O = paint(O, {(color(obj), (i, j))}) # Paint the border cell only if adjacent to the object
  return O
 
18.333333333333332, tensor(0.0069), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are adjacent to the object's outline. Recolor this new object with the original object's color. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def dfdiffadhbbbeabebaiheifibjdajdji(I):
    bg = mostcolor(I)
    return paint(canvas(bg, shape(I)), 
                 merge(apply(
                     lambda obj: recolor(
                         color(obj),
                         sfilter(
                             toindices(obj),
                             lambda ind: any(
                                 neighbor in toindices(
                                     recolor(bg, obj)) for neighbor in neighbors(ind)))),
                     objects(I, False, False, True))))
 
18.0, tensor(1.0996), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def icjejhbbggcbejiaijdejeacjaffffha(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    O = fill(O, mostcolor(I), difference(outbox(toindices(obj)),toindices(obj)))
  return O
 
13.666666666666666, tensor(0.0030), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace all instances of the most common color (the background color) with black. The background of the output grid should be black. 
:: def cigdedacejfjefafidbcfhfhdbffhfba(I):
  O = replace(I, mostcolor(I), ZERO)
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    O = fill(O, color(obj), delta(obj))
  return O
 
18.0, tensor(1.9868), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, fill the inside of the object with the background color. The background of the output grid should be the most common color. 
:: def djfgccbdabhfejbhibaiabjbhgdhejfa(I):
  O = I
  bg = mostcolor(I)
  for obj in objects(I, False, False, True):
    O = paint(fill(O, bg, obj), recolor(color(obj), box(obj)))
  return O
 
14.333333333333334, tensor(0.5572), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. The border should be drawn only on cells that are directly adjacent to the object. 
:: def cegfhbhgbceceibjibfgcbbbchccgada(I):
  O = canvas(mostcolor(I), shape(I)) # Create background canvas
  for obj in objects(I, T, T, T):
    indices = toindices(obj)
    O = fill(O, color(obj), backdrop(indices) - indices) # Fill delta
  return O
 
19.666666666666668, tensor(0.5572), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. The border should be drawn only on cells that are directly adjacent to the object. 
:: def iaechefedbfeeieajeffgafiieidddhe(I):
  O = I                                 # Initialize with input
  for obj in objects(I, T, T, T):
    O = underfill(O, color(obj), box(obj)) # Fill under the object
  return O
 
9.333333333333334, tensor(0.0066), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the cells that are adjacent to the object's outline. Recolor this new object with black. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def cfcchdcefcdcecebbhffacbdbcdfadbg(I):
  bg = mostcolor(I)  # Identify the background color
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(0, delta(toindices(obj))), objects(I, False, False, True))))
 
13.0, tensor(0.0222), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, create a new object that consists of only the outline of the original object. Recolor this new object with black. Paint these new objects onto a blank canvas of the same size as the input grid. The background of the output grid should be the most common color. 
:: def hhjbcccdeedbedecbdafeabgdhcfhbef(I):
  return paint(I, merge(apply(lambda obj: recolor(0, difference(outbox(toindices(obj)), toindices(obj))), objects(I, False, False, True))))
 
14.666666666666666, tensor(0.1510), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, change the color of the cells that are adjacent to the object's outline to black. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects, which will be filled with black. 
:: def adbbeacfajbfeccdacfedhdefecgegea(I):
  objs = objects(I, False, False, True)
  return tuple(tuple(0 if any((i,j) in delta(toindices(obj)) for obj in objs) else I[i][j] for j in range(width(I))) for i in range(height(I)))
 
10.0, tensor(1.0996), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def efffffjeejaeeaaeifgjjebfibabeibf(I):
  O = canvas(mostcolor(I), shape(I))  # Create a canvas filled with the background color
  for obj in objects(I, True, False, True):  # Iterate over objects (without background)
    O = underpaint(O, recolor(0, difference(outbox(toindices(obj)), toindices(obj)))) # Outline the object with '0's
  return O
 
12.666666666666666, tensor(1.0996), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a black border around it. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def gcieabfhgjecebacjhjhgbaedafeaacf(I):
  O = I 
  bg = mostcolor(I)
  for obj in objects(I, True, False, True):
    for i, j in toindices(obj):
      for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        ni, nj = i + di, j + dj
        if 0 <= ni < height(I) and 0 <= nj < width(I) and I[ni][nj] == bg:
          O = paint(O, {(0, (ni, nj))})
  return O
 
7.0, tensor(0.0718), Description: Copy the input grid. Then, for each cell in the grid, if the cell's color is not the most common color (the background color) and the cell is one square away from any object (using Manhattan distance), change the cell's color to black. Otherwise, keep the cell's color the same. The result will be a grid where the background color is the only color present, except for the outlines of the original objects, which will be filled with black. 
:: def dadbaacaccefehhhjbhacjcdjaegcbbh(I):
  O = canvas(mostcolor(I), shape(I))
  objs = objects(I, True, False, True)
  for i in range(height(I)):
    for j in range(width(I)):
      if any(manhattan({(i, j)}, toindices(obj)) == 1 for obj in objs):
        O = paint(O, {(0, (i, j))})
  return O
 
15.666666666666666, tensor(1.4902), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def bcehigebjjehedjcaafecgcagebdibbc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    O = underpaint(O, recolor(color(obj), box(obj)))
  return O
 
18.333333333333332, tensor(0.0029), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. Then, replace all instances of the most common color (the background color) with black. The background of the output grid should be the most common color. 
:: def fejedicgaaedececbffghjdabffcbfef(I):
  bg = mostcolor(I)
  O = replace(I, bg, 0)
  for obj in fgpartition(I):
    O = underpaint(O, recolor(color(obj), box(obj)))
  return replace(O, 0, bg)
 
12.333333333333334, tensor(1.4902), Description: Copy the input grid. Then, for each object in the grid, if the object's color is not the most common color in the grid, draw a border around it using the same color as the object. The border should be one square thick and should not overlap with any other objects. If the object is on the edge of the grid, then the border should be partially off the grid. The background of the output grid should be the most common color. 
:: def jaibfegjaceeeihcbffcfgfeeebbefbb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in partition(I):
    if color(obj) != mostcolor(I):
      O = paint(O, recolor(color(obj), delta(obj)))
  return O
 
