15.333333333333334, tensor(0.0164), Description: Copy the input grid. Then, for each gray square, find the gray square that is the same distance away from the top of the grid, but on the opposite side of the grid.  Then, fill in the space between the two gray squares with gray squares. 
:: def cjdgjjjfebjeeffbiadcdicfdeichcjc(I):
    obj_indices = ofcolor(I, 5)
    top_row = uppermost(obj_indices)
    reflected_grid = I
    for i, row in enumerate(I):
      if i < top_row:
        for j, val in enumerate(row):
          if val == 5:
            reflected_grid = fill(reflected_grid, 5, {(2 * top_row - i, j)})
      else:
        break
    return reflected_grid
 
18.0, tensor(0.0138), Description: Copy the input grid. Then, find the gray shape and mirror it horizontally. Place the mirrored shape to the left of the original gray shape. The mirrored shape should be touching the original shape. 
:: def egiebdcabfceeffiifbdgeabcfihiddb(I):
  target_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  reflected_obj = shift(hmirror(target_obj), (-height(target_obj), 0))
  return paint(paint(I, target_obj), reflected_obj)
 
22.333333333333332, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position.  The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def aaajdeehefeaeeaaabgbcbfaibjeigaf(I):
    objs = objects(I, True, False, False)
    target_objs = colorfilter(objs, 5)
    bg = mostcolor(I)
    moved_objs = frozenset()
    for obj in target_objs:
        upper = uppermost(obj)
        while upper > 0 and index(I, (upper-1, leftmost(obj))) == bg:
            upper -= 1
        moved_objs = insert(shift(obj, (upper - uppermost(obj), 0)), moved_objs)
    O = paint(I, merge(moved_objs))
    return O
 
14.666666666666666, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def bgceeddaccbdebbfieeeddbidcedfbcc(I):
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 5)
  bg = mostcolor(I)
  moved_grid = I
  for obj in target_objs:
    for j in range(leftmost(obj), rightmost(obj) + 1):
      for i in range(uppermost(obj), -1, -1):
        if index(I, (i,j)) == 5:
          moved_grid = fill(moved_grid, bg, {(i,j)})
          moved_grid = fill(moved_grid, 5, {(uppermost(obj)-1,j)})
  O = moved_grid
  return O
 
16.333333333333332, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position.  The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def aabgidbaeeceedacbdajjgdiibefbcfj(I):
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 5)
  bg = mostcolor(I)
  moved_objs = frozenset()
  for obj in target_objs:
      above = {(i - 1, j) for i, j in toindices(obj) if i > 0}
      while not any(index(I, loc) != bg for loc in above):
          obj = shift(obj, (-1, 0))
          above = {(i - 1, j) for i, j in toindices(obj) if i > 0}
      moved_objs = insert(obj, moved_objs)
  O = paint(I, merge(moved_objs))
  return O
 
15.333333333333334, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position.  The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def bhachhcfacacefebaddjbbbcfcffcdee(I):
    objs = objects(I, True, False, False)
    target_objs = colorfilter(objs, 5)
    bg = mostcolor(I)
    moved_grid = I
    for obj in target_objs:
        upper_limit = min((i for i in range(uppermost(obj)) if index(I, (i, leftmost(obj))) != bg), default=0)
        moved_grid = paint(cover(moved_grid, obj), shift(obj, (upper_limit - uppermost(obj), 0)))
    O = moved_grid
    return O
 
14.333333333333334, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position.  The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def afcaddebedffefdhjhichaffidfcecje(I):
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 5)
  bg = mostcolor(I)
  new_grid = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 5:
      upper = uppermost(obj)
      while upper > 0 and index(I, (upper - 1, leftmost(obj))) == bg:
        upper -= 1
      obj = shift(obj, (upper - uppermost(obj), 0))
    new_grid = paint(new_grid, obj)
  O = new_grid
  return O
 
12.666666666666666, tensor(0.0208), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def fcidbfcbdacdeccdjhbigdhfdicbedci(I):
  obj = first(colorfilter(objects(I, T, T, T), 5))
  center_i = height(I) // 2
  center_j = width(I) // 2
  offset = subtract((center_i, center_j), centerofmass(obj))
  O = paint(cover(I, obj), shift(obj, offset))
  return O
 
8.0, tensor(0.0142), Description: Copy the input grid. Then, for each gray square, move it to the center of the grid. Keep the original gray square in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def gjdjjcahfggeeagbahcdaaeafeadhbec(I):
  obj_indices = ofcolor(I, 5)
  center_loc = (height(I) // 2, width(I) // 2)
  O = I
  for loc in obj_indices:
    O = paint(cover(O, {(5, loc)}), {(5, center_loc)})
  return O
 
18.333333333333332, tensor(0.0156), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def afefhdebeacbeicfjdjfdhbdaacdadda(I):
  obj = normalize(first(colorfilter(objects(I, T, T, T), 5)))
  center_offset = subtract((height(I) // 2, width(I) // 2), ulcorner(obj))
  O = paint(cover(I, shift(obj, center_offset)), shift(obj, center_offset))
  return O
 
11.333333333333334, tensor(0.0136), Description: Copy the input grid. Then, move the gray shape to the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def adfjjjebecaeegbajidicbedcbdaidfj(I):
  five_indices = toindices(first(colorfilter(objects(I, T, T, T), 5)))
  center_i, center_j = height(I) // 2, width(I) // 2
  O = canvas(mostcolor(I), shape(I))
  for i, j in asindices(I):
    if (i, j) in five_indices:
      O = paint(O, {(5, (center_i, center_j))})
    else:
      O = paint(O, {(I[i][j], (i, j))})
  return O
 
18.0, tensor(0.0142), Description: Copy the input grid. Then, move the gray shapes three spaces to the right. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes three spaces to the right. 
:: def cgdibehgcfeieehhjfihcfbeabfacebd(I):
  fives = extract(objects(I, T, F, T), lambda obj: color(obj) == 5)
  twos = extract(objects(I, T, F, T), lambda obj: color(obj) == 2)
  moved_fives = shift(fives, (3, 0))
  return paint(paint(canvas(0, shape(I)), moved_fives), twos)
 
12.666666666666666, tensor(0.0163), Description: Copy the input grid. For each gray square, move it one square diagonally towards the center of the grid. If the gray square is already in the center, do not move it. The output grid should have the original gray squares in their original positions, and the moved gray squares one square diagonally towards the center. 
:: def bicggeiadcbiebebabbjegiajchebajg(I):
  O = I
  for i, row in enumerate(I): # Iterate through rows
    for j, value in enumerate(row): # Iterate through columns
      if value == 5: # Check for '5'
        center_i, center_j = centerofmass(asindices(I)) # Calculate grid center
        di = sign(center_i - i)
        dj = sign(center_j - j)
        if 0 <= i + di < len(I) and 0 <= j + dj < len(row): # Boundary check
          O = fill(O, 0, ((i, j),)) # Clear original '5'
          O = fill(O, 5, ((i + di, j + dj),)) # Fill new '5' position
  return O
 
30.0, tensor(0.0166), Description: Copy the input grid. Then, for each gray shape, move it one square diagonally towards the center of the grid. If the gray square is already in the center, do not move it. The output grid should have the original gray squares in their original positions, and the moved gray squares one square diagonally towards the center. 
:: def ihedbfidjjfaeeabjciafccccdidbbga(I):
  O = canvas(0, shape(I)) # Create an empty canvas
  for obj in colorfilter(objects(I, True, False, False), 5): # Iterate through '5' objects
    center_i, center_j = centerofmass(asindices(I)) # Calculate grid center
    obj_center_i, obj_center_j = centerofmass(obj)
    shift_i = sign(center_i - obj_center_i) 
    shift_j = sign(center_j - obj_center_j) 
    O = paint(O, shift(obj, (shift_i, shift_j))) # Paint the shifted object on the canvas
  return O
 
20.333333333333332, tensor(0.0164), Description: Copy the input grid. Then, for each gray square, find the gray square that is the same distance away from the top of the grid, but on the opposite side of the grid.  Then, fill in the space between the two gray squares with gray squares. 
:: def ddhacfceafccejccaccgeeffbejfdbef(I):
  target_indices = ofcolor(I, 5)  # Find indices of '5'
  top_row = uppermost(target_indices) # Find the uppermost row containing a '5'
  reflected_indices = frozenset((2 * top_row - i, j) for i, j in target_indices) # Calculate reflected indices
  return fill(I, 5, reflected_indices) # Fill the reflected indices with '5'
 
15.333333333333334, tensor(0.0146), Description: Copy the input grid. For each gray shape, move the top row of the shape one row down. The output grid should have the original gray shapes in their original positions, and the moved gray shapes below them. 
:: def ccfbbdfdbbageggbiadaggbaeafaadii(I):
  objs = objects(I, True, False, False) # Identify all objects in the grid
  target_objs = colorfilter(objs, 5) # Filter for objects made of '5'
  bg = mostcolor(I) # Get the background color
  moved_grid = I # Initialize the output grid
  for obj in target_objs: 
    upper = uppermost(obj) # Get the top row of the object
    for j in range(leftmost(obj), rightmost(obj) + 1): # Iterate over columns of the object
      for i in range(upper - 1, -1, -1): # Iterate upwards from above the object
        if index(moved_grid, (i, j)) == 5: # If current cell is part of the object
          moved_grid = fill(moved_grid, bg, {(i, j)}) # Clear the current cell
          moved_grid = fill(moved_grid, 5, {(i + 1, j)}) # Fill the cell below with '5'
  O = moved_grid
  return O
 
15.333333333333334, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def dacbaedecjfgeeahibegdebebihifbbi(I):
  objs = objects(I, True, False, False)
  fives = colorfilter(objs, 5)
  moved = I
  for five in fives:
    for x, y in toindices(five):
      for i in range(x-1, -1, -1):
        if index(moved, (i, y)) != 0:
          break
        moved = fill(moved, 0, {(i+1, y)})
        moved = fill(moved, 5, {(i, y)})
  O = moved
  return O
 
15.333333333333334, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def afhceccfeccfeaaeibaccdabejeceieb(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)-1, -1, -1):
      if index(O, (i, j)) == 5:
        k = i
        while k > 0 and index(O, (k - 1, j)) == 0:
          k -= 1
        O = fill(O, 0, {(i, j)})
        O = fill(O, 5, {(k, j)})
  return O
 
15.333333333333334, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def fchbjificeeceibhigfafiahcacfbcde(I):
  moved = I
  for i in range(1, height(I)):
    for j in range(width(I)):
      if index(moved, (i, j)) == 5 and index(moved, (i - 1, j)) == 0:
        moved = fill(moved, 0, {(i, j)})
        moved = fill(moved, 5, {(i - 1, j)})
  O = moved
  return O
 
15.333333333333334, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def djdbbefhbaebeahdbdchcjcjjbigdgfc(I):
  shifted = I
  for _ in range(height(I)): 
    for i in range(1, height(I)):
      for j in range(width(I)):
        if index(shifted, (i,j)) == 5 and index(shifted, (i - 1, j)) == 0:
          shifted = fill(shifted, 0, {(i, j)})
          shifted = fill(shifted, 5, {(i - 1, j)})
  O = shifted
  return O
 
15.333333333333334, tensor(0.0156), Description: Copy the input grid. Then, move the gray shape down so that its top row is one row below the bottom row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row below the red shape. 
:: def ceejgjechijheffhjeabcbacdadcfhbe(I):
  obj_2 = first(colorfilter(objects(I, T, T, T), 2))
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  target_i = lowermost(obj_2) + 1
  offset = (target_i - uppermost(obj_5), 0)
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
15.333333333333334, tensor(0.0166), Description: Copy the input grid. Then, move the gray shape so that its center is in the same location as the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of the red shape. 
:: def eabdbbihecadecdiadjeicbeceeehbci(I):
  obj_2 = first(colorfilter(objects(I, T, T, T), 2))
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  target_loc = center(obj_2)
  offset = subtract(target_loc, center(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
15.333333333333334, tensor(0.0191), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def bjbhebbjjffdeccgjgbfibgdffgefeib(I):
  obj_2 = first(colorfilter(objects(I, T, T, T), 2))
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  h_offset = subtract(centerofmass(obj_2), centerofmass(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, h_offset))
  return O
 
29.666666666666668, tensor(0.0161), Description: Copy the input grid. Then, take the top half of the grid and move it to the bottom half of the grid. Take the bottom half of the grid and move it to the top half of the grid. The output grid should have the top and bottom halves of the input grid swapped. 
:: def caeidbfccaddebfcjifaejifhaagidgj(I):
  fives_top = replace(tophalf(I), 5, 0)
  fives_bottom = replace(bottomhalf(I), 5, 0)
  moved_fives = vconcat(fives_bottom, fives_top)
  return paint(replace(I, 5, 0), asobject(moved_fives)) 
 
37.333333333333336, tensor(0.0162), Description: Copy the input grid. Then, move the bottom `shift_amount` rows to the top of the grid. The output grid should have the bottom `shift_amount` rows moved to the top, and the rest of the grid should remain in its original position. 
:: def djdbjacjbjcaecadifccgbaadcjdhiff(I):
  shift_amount = 3
  top_part = crop(I, (0, 0), (len(I) - shift_amount, len(I[0])))
  bottom_part = crop(I, (len(I) - shift_amount, 0), (shift_amount, len(I[0])))
  return vconcat(bottom_part, top_part)
 
18.333333333333332, tensor(0.0138), Description: Copy the input grid. Then, find the gray shape and mirror it horizontally. Place the mirrored shape to the left of the original gray shape. The mirrored shape should be touching the original shape. 
:: def iacfeabegbbdedfaabcdicdcefhdgebb(I):
  five_obj = toobject(ofcolor(I, 5), I)  # Extract '5' object
  top_row = uppermost(five_obj)  # Find the uppermost row
  reflected_obj = shift(hmirror(five_obj), (-height(five_obj) + 2 * top_row, 0)) # Reflect and shift
  return paint(I, reflected_obj)  # Paint reflected object on original grid
 
21.666666666666668, tensor(0.0164), Description: Copy the input grid. Then, for each gray square, find the gray square that is the same distance away from the top of the grid, but on the opposite side of the grid.  Then, fill in the space between the two gray squares with gray squares. 
:: def cbafbcfeihdfeibbbfigdffaicdeafhj(I):
  five_indices = ofcolor(I, 5) # Get '5' indices
  top_row = uppermost(five_indices) # Find the uppermost row
  reflected_grid = list(list(row) for row in I) # Create a mutable copy of the grid
  for i, j in five_indices:
    reflected_grid[2 * top_row - i][j] = 5 # Set reflected indices to '5'
  return tuple(tuple(row) for row in reflected_grid) # Convert back to immutable tuple
 
14.0, tensor(0.0148), Description: Copy the input grid. For each gray shape, move the top row of the shape one row up. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def habbddfhcgaeeeebiiedijcdbafdefjh(I):
  objs = objects(I, True, False, False)
  fives = colorfilter(objs, 5)
  bg = mostcolor(I)
  O = I
  for five in fives:
    for j in range(leftmost(five), rightmost(five) + 1):
      for i in range(uppermost(five), -1, -1):
        if index(O, (i, j)) == 5:
          O = fill(O, bg, {(i, j)})
          O = fill(O, 5, {(i - 1, j)})
  return O
 
30.0, tensor(0.0223), Description: Copy the input grid. Then, for each gray square in a column, move it upwards so that it is the k-th gray square in that column, where k is its original position in the column. For example, if the gray square is the 3rd gray square in its column, move it up so that it is the 3rd gray square in the column in the output grid. The output grid should have the original gray squares in their original positions, and the moved gray squares in their new positions. 
:: def dciecafaibabedifbhagdibbdejfiddj(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    fives = tuple((i, j) for i in range(height(I)) if index(I, (i, j)) == 5)
    for k, (i, _) in enumerate(fives):
      O = fill(O, 5, {(k, j)})
  return O
 
15.333333333333334, tensor(0.0170), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row below the bottom row of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row below the red shape and in the same column. 
:: def eejficjdfacaeibebceaebiaaaahffeg(I):
  obj_2 = toindices(first(colorfilter(objects(I, T, T, T), 2)))
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  target_loc = (uppermost(obj_2) + height(obj_2), leftmost(obj_2))
  offset = subtract(target_loc, ulcorner(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
12.666666666666666, tensor(0.0171), Description: Copy the input grid. Then, move the gray shape so that it is as close as possible to the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape as close as possible to the red shape. 
:: def caeeeedffgcceajcbfeaaeajhcbdfhaf(I):
  obj_2 = first(colorfilter(objects(I, T, T, T), 2))
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  O = paint(cover(I, obj_5), shift(obj_5, gravitate(obj_5, obj_2)))
  return O
 
7.666666666666667, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def gaabheddceddedhgijfcfcbidcccicbd(I):
  fives = ofcolor(I, 5)
  return paint(
      paint(
          canvas(0, shape(I)),
          recolor(5, frozenset(((i + 3) % height(I), j) for i, j in fives))
      ),
      asobject(replace(I, 5, 0))
  )
 
15.333333333333334, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def dgeeccdcicegedfdjecfjgagfibagfid(I):
  h, w = shape(I)
  return tuple(
      tuple(
          5 if (i - 3) % h in [idx[0] for idx in ofcolor(I, 5) if idx[1] == j] else 
          2 if I[i][j] == 2 else 0
          for j in range(w)
      )
      for i in range(h)
  )
 
9.666666666666666, tensor(0.0163), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the top left corner of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the top left corner of the red shape. 
:: def hjcgiefbddeiebfcjbeddhifgecbdacc(I):
  five_obj = toobject(ofcolor(I, 5), I)
  two_obj = toobject(ofcolor(I, 2), I)
  target_center = center(two_obj)
  offset = subtract(target_center, ulcorner(five_obj))
  return paint(cover(I, five_obj), shift(five_obj, offset))
 
15.333333333333334, tensor(0.0194), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def ajeacdbahabfehcjididedeciabhagfd(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  two_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  h_offset = subtract(centerofmass(two_obj)[1], centerofmass(five_obj)[1])
  v_offset = subtract(centerofmass(two_obj)[0], centerofmass(five_obj)[0])
  return move(I, five_obj, (v_offset, h_offset)) 
 
14.333333333333334, tensor(0.0191), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def ccfdjeefbcffeecfbegedecbfcbccfih(I):
  obj_2 = toobject(ofcolor(I, 2), I)
  obj_5 = toobject(ofcolor(I, 5), I)
  offset = subtract(centerofmass(obj_2), centerofmass(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
15.333333333333334, tensor(0.0191), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def bfeaicfffgbbedabjaccehaadfdaffce(I):
  objs = objects(I, T, T, T)
  obj_2 = extract(objs, lambda obj: color(obj) == 2)
  obj_5 = extract(objs, lambda obj: color(obj) == 5)
  O = paint(cover(I, obj_5), shift(obj_5, subtract(centerofmass(obj_2), centerofmass(obj_5))))
  return O
 
15.333333333333334, tensor(0.0191), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def bebbifjfccbeeadfaifciffcifebecch(I):
  obj_2 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 5))
  O = paint(cover(I, obj_5), shift(obj_5, subtract(centerofmass(obj_2), centerofmass(obj_5))))
  return O
 
22.333333333333332, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def iebefaaaefadegeaibcabcbifcbadfaa(I):
  h = height(I)
  shifted_fives = frozenset(((i + 3) % h, j) for i, j in ofcolor(I, 5))
  return tuple(
        tuple(
            5 if (i, j) in shifted_fives else
            I[i][j] 
            for j in range(width(I)))
        for i in range(h))
 
15.0, tensor(0.0168), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def ehabddcdbcafeefdiffhihhdbccggeha(I):
  fives = colorfilter(objects(I, True, False, False), 5)
  target_y = uppermost(argmin(colorfilter(objects(I, True, False, False), 2), lambda o: leftmost(o)))
  O = I
  for five in fives:
    O = paint(cover(O, five), shift(five, (target_y - uppermost(five), 0)))
  return O
 
15.333333333333334, tensor(0.0171), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same row as the center of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center of the red shape and in the same column. 
:: def edfaagfgdejieggibfdddebbbfdbcecd(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  two_center_row = center(toobject(ofcolor(I, 2), I))[0]
  five_ulcorner_row = ulcorner(five_obj)[0]
  move_vec = (two_center_row - five_ulcorner_row, 0)
  return paint(fill(I, 0, five_obj), shift(five_obj, move_vec)) 
 
14.333333333333334, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it down so that its top row is in the same row as the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center of the red shape. 
:: def affdfceeaggcehfaaijaedfbcgchdbaf(I):
  five_indices = ofcolor(I, 5)
  two_center_row = center(ofcolor(I, 2))[0]
  return paint(fill(I, 0, five_indices), 
               frozenset((5, (two_center_row + i - uppermost(five_indices), j)) 
                        for i, j in five_indices))
 
14.666666666666666, tensor(0.0169), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the center of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center of the red shape and in the same column. 
:: def baegicgddfchecbfibeagaadcdefecbb(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  two_center_row = center(extract(objects(I, True, False, True), lambda obj: color(obj) == 2))[0]
  return paint(fill(I, 0, five_obj), 
               shift(five_obj, (two_center_row - uppermost(five_obj), 0)))
 
15.333333333333334, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position.  The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def dbjagaidgjedehjbjchacbjdfechcdfa(I):
  objs = objects(I, True, False, False) # Get all objects in the grid
  movable_objs = colorfilter(objs, 5) # Filter for objects with color 5
  for obj in movable_objs: 
    upper = uppermost(obj) # Find the topmost row of the object
    while upper > 0 and index(I, (upper - 1, leftmost(obj))) == 0: # Check for space above
      I = fill(I, 0, toindices(obj)) # Clear the current position of the object
      upper -= 1 # Move one row up
      obj = shift(obj, (-1, 0)) # Update the object's position
      I = paint(I, obj) # Paint the object at the new position
  O = I
  return O
 
12.0, tensor(0.0136), Description: Copy the input grid. Then, move the gray shape to the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def bcjbfjedjdajefefifjhebbdcfbdgjah(I):
  twos = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 2))
  fives = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 5))
  center_i, center_j = center(toindices(twos))
  O = cover(I, fives)
  for i, j in asindices(I):
    if (i, j) == (center_i, center_j):
      O = paint(O, {(5, (center_i, center_j))})
  return O
 
16.0, tensor(0.0148), Description: Copy the input grid. Then, move the gray shape to the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep the red shape in its original position. 
:: def edhddeiagbffefggacececffdgeggcjh(I):
  five_indices = toindices(first(colorfilter(objects(I, T, T, T), 5)))
  two_indices = toindices(first(colorfilter(objects(I, T, T, T), 2)))
  center_i, center_j = center(two_indices)
  O = canvas(mostcolor(I), shape(I))
  for i, j in asindices(I):
    if (i, j) in five_indices:
      O = paint(O, {(5, (center_i, center_j))})
    elif (i, j) in two_indices:
      O = paint(O, {(2, (i, j))})
  return O
 
12.0, tensor(0.0148), Description: Copy the input grid. Then, move the gray shape to the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep the red shape in its original position. 
:: def baecfaacajcaejfdifcaghdfibefecba(I):
  fives = first(colorfilter(objects(I, T, T, T), 5))
  twos = first(colorfilter(objects(I, T, T, T), 2))
  center_i, center_j = center(toindices(twos))
  O = I
  for v, (i, j) in fives:
    O = paint(cover(O, {(v, (i, j))}), {(5, (center_i, center_j))})
  return O
 
26.666666666666668, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def bcidijccbaeeefcfbibefgheifgcbacd(I):
  h = height(I)
  return tuple(
      tuple(
          5 if any(I[(i - 3 + k) % h][j] == 5 for k in range(3)) else I[i][j]
          for j in range(width(I))
      )
      for i in range(h)
  )
 
11.333333333333334, tensor(0.0178), Description: Copy the input grid. Then, for each gray square, move it down so that its top row is in the same row as the top row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the red shape. 
:: def badhfbchffacejfdaaciceebgaeedjdc(I):
  fives_indices = ofcolor(I, 5)
  target_row = min(i for i, row in enumerate(I) if 2 in row)
  moved_fives = frozenset(((target_row, j) for i, j in fives_indices))
  O = fill(fill(I, 0, fives_indices), 5, moved_fives)
  return O
 
15.333333333333334, tensor(0.0160), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first red shape above it. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def fhgeadcjffhaefgjicdagedbcjfdiddb(I):
  objs = objects(I, True, False, False)
  fives = colorfilter(objs, 5)
  moved = I
  for five in fives:
    for x, y in toindices(five):
      for i in range(x-1, -1, -1):
        if index(moved, (i, y)) == 2:
          break
        if index(moved, (i, y)) == 0:
          moved = fill(moved, 0, {(i+1, y)})
          moved = fill(moved, 5, {(i, y)})
          break
  O = moved
  return O
 
16.333333333333332, tensor(0.0160), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first red shape above it. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def ahheaaicfjeheaacajibbabjhcddebdb(I):
    objs = objects(I, True, False, False)
    fives = colorfilter(objs, 5)
    grid = I
    for five in fives:
        upper = uppermost(five)
        left = leftmost(five)
        width = rightmost(five) - left + 1
        for i in range(upper - 1, -1, -1):
            if index(grid, (i, left)) == 2:
                break
            if all(index(grid, (i, j)) == 0 for j in range(left, left + width)):
                grid = fill(grid, 0, {(i + 1, j) for j in range(left, left + width)})
                grid = fill(grid, 5, {(i, j) for j in range(left, left + width)})
                break
    O = grid
    return O
 
16.333333333333332, tensor(0.0160), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first red shape above it. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def ceebfjgbedfbeagaiafdecdjjcjfhfdb(I):
    fives = colorfilter(objects(I, True, False, False), 5)
    moved = I
    for five in fives:
        for i in range(uppermost(five), -1, -1):
            if any(index(moved, (i - 1, j)) == 2 for j in range(leftmost(five), rightmost(five) + 1)):
                break
            if all(index(moved, (i - 1, j)) == 0 for j in range(leftmost(five), rightmost(five) + 1)):
                moved = fill(moved, 5, {(i - 1, j) for j in range(leftmost(five), rightmost(five) + 1)})
                moved = fill(moved, 0, {(i, j) for j in range(leftmost(five), rightmost(five) + 1)})
    O = moved
    return O
 
14.0, tensor(0.0170), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column. 
:: def acahfccdfcahefiiiebggehibjjcgdaj(I):
  obj_2 = first(colorfilter(objects(I, T, T, T), 2)) 
  obj_5 = first(colorfilter(objects(I, T, T, T), 5))
  target_loc = (uppermost(obj_2) - height(obj_5), leftmost(obj_2))
  offset = subtract(target_loc, ulcorner(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
15.333333333333334, tensor(0.0191), Description: Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def eaafieecchbeehceaefcjcbabahciddg(I):
  obj_2 = argmax(objects(I, T, T, T), lambda obj: 1 if color(obj) == 2 else 0)
  obj_5 = argmax(objects(I, T, T, T), lambda obj: 1 if color(obj) == 5 else 0)
  target_i = uppermost(obj_2) - height(obj_5)
  offset = (target_i - uppermost(obj_5), leftmost(obj_2) - leftmost(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
11.0, tensor(0.0167), Description: Copy the input grid. Then, move the gray shapes three spaces to the right. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes three spaces to the right. If the gray shape is already in the rightmost three columns, do not move it. 
:: def hddeabacbacfefjgahhbdeefgcacbcce(I):
  fives = extract(objects(I, T, F, T), lambda obj: color(obj) == 5)
  moved_fives = shift(fives, (3, 0))
  h = height(I)
  cropped_fives = frozenset((v, (i, j)) for v, (i, j) in moved_fives if i < h)
  return paint(replace(I, 5, 0), cropped_fives)
 
36.0, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def fgdfaecjdedjeiecbfjchhhgacgdhdge(I):
  return tuple(
      tuple(
        0 if v == 5 else
        I[(i - 3) % height(I)][j] if 0 <= (i - 3)  < height(I) else 0
        for j, v in enumerate(row)
      ) for i, row in enumerate(I)
  )
 
8.0, tensor(0.0164), Description: Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def edgffcdaccececbijfajbeifbeeaghaf(I):
  h = height(I)
  return tuple(
      tuple(
        I[i][j] if I[i][j] != 5 else 
        I[(i - 3) % h][j] if 0 <= (i - 3) < h else 0 
        for j in range(width(I))
      ) for i in range(h)
  )
 
14.333333333333334, tensor(0.0160), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, do not move it. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down. 
:: def dgcffahfebhdedeebjcahdbcedcajbcd(I):
  fives = ofcolor(I, 5)
  shifted_fives = frozenset(((i + 3) % height(I), j) for i, j in fives if (i + 3) < height(I))
  return fill(replace(I, 5, 0), 5, shifted_fives)
 
12.333333333333334, tensor(0.0167), Description: Copy the input grid. Then, move the gray shapes three spaces to the right. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes three spaces to the right. If the gray shape is already in the rightmost three columns, do not move it. 
:: def heggechghgbfeahbachgdafjfccbcjdb(I):
  objs = objects(I, T, F, F)
  moved_objs = frozenset(shift(obj, (3, 0)) if color(obj) == 5 else obj for obj in objs)
  h = height(I)
  cropped_objs = frozenset(frozenset((v, (i, j)) for v, (i, j) in obj if i < h) for obj in moved_objs)
  return paint(canvas(0, shape(I)), merge(cropped_objs))
 
8.666666666666666, tensor(0.0189), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same row as the center of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center of the red shape and in the same column as the leftmost column of the red shape. 
:: def deiiifcbcfdfeadbbjgiaaaijacffaee(I):
  five_obj = toobject(ofcolor(I, 5), I)
  two_obj = toobject(ofcolor(I, 2), I)
  return paint(cover(I, five_obj), 
               shift(five_obj, (center(two_obj)[0] - center(five_obj)[0], center(two_obj)[1] - leftmost(five_obj)))) 
 
10.333333333333334, tensor(0.0161), Description: Copy the input grid. For each gray shape, move it upwards until it touches the first non-background color above it. Then, move the gray shape horizontally so that it is centered within the grid. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them and centered horizontally. 
:: def abfaigcdicceebfajccjdbfdegcbaeac(I):
  objs = objects(I, True, False, False)
  bg = mostcolor(I)
  new_grid = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 5:
      upper = uppermost(obj)
      while upper > 0 and index(I, (upper - 1, leftmost(obj))) == bg:
        upper -= 1
      obj = shift(obj, (upper - uppermost(obj), 0))
      left_shift = (width(I) - width(obj)) // 2
      obj = shift(obj, (0, left_shift))
    new_grid = paint(new_grid, obj)
  O = new_grid
  return O
 
39.666666666666664, tensor(0.0155), Description: Copy the input grid. Then, take the gray shape and center it horizontally within the top half of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape centered horizontally in the top half of the grid. Keep the bottom half of the grid the same. 
:: def aajbaadejaeceiejibfbfbcbhdbiffgc(I):
    five_obj = extract(objects(I, True, False, False), lambda x: color(x) == 5)
    bg = mostcolor(I)
    empty_grid = canvas(bg, (height(I) // 2, width(I)))
    centered_five = shift(five_obj, (0, (width(I) - width(five_obj)) // 2))
    O = vconcat(paint(empty_grid, centered_five), bottomhalf(I))
    return O
 
18.333333333333332, tensor(0.0177), Description: Copy the input grid. Then, move the gray shape so that it is in the same row as the red shape. If the red shape is horizontal, move the gray shape one space to the left. If the red shape is vertical, move the gray shape one space up. If the red shape is neither horizontal nor vertical, move the gray shape to the left by half the height of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in its new position. 
:: def eeejcdhhbjbeeehaidajachfjcceaeha(I):
  twos = first(colorfilter(objects(I, T, T, T), 2))
  fives = first(colorfilter(objects(I, T, T, T), 5))
  O = cover(I, fives) 
  if hline(twos):
    O = paint(O, shift(recolor(5, twos), (-1, 0)))
  elif vline(twos):
    O = paint(O, shift(recolor(5, twos), (0, 1)))
  else: 
    O = paint(O, shift(recolor(5, twos), (- height(twos) // 2, 0)))
  return O
 
18.333333333333332, tensor(0.0177), Description: Copy the input grid. Then, move the gray shape so that it is in the same row as the red shape. If the red shape is horizontal, move the gray shape one space to the left. If the red shape is vertical, move the gray shape one space up. If the red shape is neither horizontal nor vertical, move the gray shape to the left by half the height of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in its new position. 
:: def aciahehiddfgeaceacifafaaciadaeha(I):
  twos = first(colorfilter(objects(I, T, T, T), 2))
  fives = first(colorfilter(objects(I, T, T, T), 5))
  return paint(cover(I, fives), 
               shift(
                   recolor(5, twos), 
                   (-int(hline(twos)) - (height(twos) // 2) * int(width(twos) > 1), int(vline(twos)))
               )
  )
 
22.333333333333332, tensor(0.0182), Description: Copy the input grid. Then, for each red shape, move it to the left by one space if it is horizontal, move it up by one space if it is vertical, and move it to the left by half its height if it is neither horizontal nor vertical. Then, change the color of the moved red shape to gray. Keep the original red shape in its original position. The output grid should have the original red shapes in their original positions, and the moved gray shapes in their new positions. 
:: def cafbbgigdfdhedefbhdafgabhfhahafa(I):
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) == 5:
      O = cover(O, obj)
    elif color(obj) == 2:
      offset = (
        -1 if hline(obj) else (-height(obj) // 2 if width(obj) > 1 else 0),
        1 if vline(obj) else 0
      )
      O = paint(O, shift(recolor(5, obj), offset))
  return O
 
9.0, tensor(0.0162), Description: Copy the input grid. Then, for each gray square, move it three rows down. If the gray square is already in the bottom three rows, move it to the top of the grid. The output grid should have the original gray squares in their original positions, and the moved gray squares three rows down or at the top of the grid. 
:: def efdeccdaficcebdibeadhfebdhedhahb(I):
  new_grid = canvas(0, shape(I))
  for i, row in enumerate(I):
      for j, val in enumerate(row):
          if val == 5:
              new_i = (i + 3) % height(I)
              new_grid = fill(new_grid, 5, {(new_i, j)})
          else:
              new_grid = fill(new_grid, val, {(i, j)})
  return new_grid
 
14.333333333333334, tensor(0.0178), Description: Copy the input grid. Then, for each gray square, move it down so that its top row is in the same row as the top row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the red shape. 
:: def fcagcadhedccefjdjaacccfcdafhefgg(I):
  target_row = next((i for i, row in enumerate(I) if 2 in row), 0) # Find the first row with '2'
  fives_indices = ofcolor(I, 5) # Get indices of all '5' cells
  moved_fives = frozenset((5, (i + target_row - uppermost(fives_indices), j)) for i, j in fives_indices) # Move indices
  O = paint(cover(I, fives_indices), moved_fives) # Clear and paint based on indices
  return O
 
13.666666666666666, tensor(0.0168), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def agdfdbchhfciebbaadfdccfbajcbfdcg(I):
  twos = colorfilter(objects(I, True, False, False), 2) # Find all '2' objects
  target_row = min(uppermost(obj) for obj in twos) # Find topmost row of '2' objects
  O = canvas(0, shape(I)) # Create empty canvas
  for obj in objects(I, True, False, False): # Iterate through all objects
    if color(obj) == 5: # If object is a '5'
      O = paint(O, shift(obj, (target_row - uppermost(obj), 0))) # Move and paint to canvas
    else: 
      O = paint(O, obj) # Otherwise, paint as is
  return O
 
13.333333333333334, tensor(0.0163), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the top left corner of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the top left corner of the red shape. 
:: def ecdbiaieihefebfgbaaedjgiaabbcibc(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  two_center = center(ofcolor(I, 2))
  offset = subtract(two_center, ulcorner(five_obj))
  return paint(fill(I, 0, five_obj), shift(five_obj, offset)) 
 
12.0, tensor(0.0163), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of the red shape. 
:: def egecfdffgadeebgcijiacjadfeechgag(I):
  five_obj = extract(objects(I, True, False, True), matcher(color, 5))
  two_center = center(ofcolor(I, 2))
  return paint(
      fill(I, 0, toindices(five_obj)), 
      toobject(shift(toindices(five_obj), subtract(two_center, ulcorner(five_obj))), I)
  )
 
11.333333333333334, tensor(0.0178), Description: Copy the input grid. Then, for each gray shape, move it so that its center is one space to the left and one space down from the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes one space to the left and one space down from the center of the red shape. 
:: def bbhfcjheedejedjbjcfbjcgceahidfej(I):
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 5)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 5:
      target_center = center(extract(objects(I, True, False, False), lambda x: color(x) == 2))
      obj_center = center(obj)
      O = paint(O, shift(obj, (target_center[0] - obj_center[0] - 1, target_center[1] - obj_center[1]))) 
    else:
      O = paint(O, obj)
  return O
 
16.333333333333332, tensor(0.0180), Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. Keep the red shape in its original position. 
:: def dahjfcdcbdjeecfcbciecedfhbejdhdb(I):
  five_obj = extract(objects(I, True, False, False), lambda x: color(x) == 5)
  two_obj = extract(objects(I, True, False, False), lambda x: color(x) == 2)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  O = paint(O, shift(five_obj, (uppermost(two_obj) - height(five_obj) - 1, (width(I) - width(five_obj)) // 2)))
  O = paint(O, two_obj)
  return O
 
16.333333333333332, tensor(0.0182), Description: Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. Keep the red shape in its original position. 
:: def cijcbfdecccbeiafaficefjcchjbaffa(I):
  five_obj = extract(objects(I, True, False, False), lambda x: color(x) == 5)
  two_obj = extract(objects(I, True, False, False), lambda x: color(x) == 2)
  bg = mostcolor(I)
  O = paint(canvas(bg, shape(I)), two_obj)
  return paint(O, shift(five_obj, (uppermost(two_obj) - height(five_obj), (width(O) - width(five_obj)) // 2)))
 
17.333333333333332, tensor(0.0182), Description: Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. Keep the red shape in its original position. 
:: def daaiiiddebjieaaabbebdaaeccedbchd(I):
  bg = mostcolor(I)
  five_obj = extract(objects(I, True, False, False), lambda x: color(x) == 5)
  two_obj = extract(objects(I, True, False, False), lambda x: color(x) == 2)
  return paint(fill(canvas(bg, shape(I)), 5, shift(toindices(five_obj), (uppermost(two_obj) - uppermost(five_obj) - 1, (width(I) - width(five_obj)) // 2))), two_obj)
 
15.333333333333334, tensor(0.0165), Description: Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the top left corner of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the top left corner of the red shape. 
:: def haahebcefagheejcadacdeafbfbeajaa(I):
  objs = objects(I, T, T, T)
  obj_2 = extract(objs, lambda obj: color(obj) == 2)
  obj_5 = extract(objs, lambda obj: color(obj) == 5)
  offset = subtract((uppermost(obj_2), leftmost(obj_2)), ulcorner(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
11.0, tensor(0.0165), Description: Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the top left corner of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the top left corner of the red shape. 
:: def bcdidgjbcjcfefdfbeededjbdhacfcaj(I):
  obj_2 = toobject(ofcolor(I, 2), I)
  obj_5 = toobject(ofcolor(I, 5), I)
  target = ulcorner(obj_2)
  offset = subtract(target, ulcorner(obj_5))
  O = paint(cover(I, obj_5), shift(obj_5, offset))
  return O
 
13.333333333333334, tensor(0.0192), Description: Copy the input grid. Then, move the gray shape so that its center is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def efdheiceajfaeccbbgcaefcaaeeacfac(I):
  objs = objects(I, T, F, F)
  target_obj = extract(objs, lambda obj: color(obj) == 5)
  target_center = center(target_obj)
  grid_center =  (len(I) // 2, len(I[0]) // 2) 
  offset = subtract(grid_center, target_center)
  O = move(I, target_obj, offset)
  return O
 
224.33333333333334, tensor(0.0183), Description: Copy the input grid. Then, split the gray shape in half vertically. Place the left half of the gray shape on the left side of the output grid, and the right half of the gray shape on the right side of the output grid. The two halves of the gray shape should be touching. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the two halves of the gray shape on the left and right sides of the grid. 
:: def bjjbhdieeaadecdgjdigfcghcfdafhcb(I):
  objs = objects(I, T, F, F)
  target_obj = extract(objs, lambda obj: color(obj) == 5)
  target_indices = toindices(target_obj)
  h, w = shape(target_obj)
  left_part = crop(I, ulcorner(target_indices), (h, w // 2))
  right_part = crop(I, (ulcorner(target_indices)[0], ulcorner(target_indices)[1] + w // 2 ), (h, w // 2))
  O = hconcat(left_part, right_part) 
  return O
 
16.0, tensor(0.0173), Description: Copy the input grid. Then, find the gray shape and mirror it horizontally. Place the mirrored shape to the right of the original gray shape. The mirrored shape should be touching the original shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the mirrored gray shape to the right of it. 
:: def eecgcfiaebeaeeehbfibdaedgbhgcebc(I):
  objs = objects(I, T, F, F)
  target_obj = extract(objs, lambda obj: color(obj) == 5) 
  mirrored_obj = hmirror(target_obj)
  combined_obj = combine(target_obj, mirrored_obj)
  O = paint(I, combined_obj)
  return O
 
15.333333333333334, tensor(0.0194), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same row as the top row of the gray shape and in the same column as the center column of the gray shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the gray shape and in the same column as the center column of the gray shape. 
:: def ehcbhdebfcdbejefibgcgdfgejeacbha(I):
  objs = objects(I, T, F, F)
  target_obj = extract(objs, lambda obj: color(obj) == 5)
  top_center = (uppermost(target_obj), centerofmass(target_obj)[1])
  offset = subtract(top_center, centerofmass(target_obj))
  O = move(I, target_obj, offset)
  return O
 
14.0, tensor(0.0168), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def fgigcdacdhfiecdfjfddjgjfdgaifdij(I):
  fives = colorfilter(objects(I, True, False, False), 5)
  twos = colorfilter(objects(I, True, False, False), 2)
  target_row = min(uppermost(obj) for obj in twos)
  O = I
  for five in fives:
    i, j = ulcorner(five)
    while i > target_row:  # Move up until target row
      if index(I, (i - 1, j)) == 0: # Check if the path is clear
        O = paint(cover(O, toobject(((i, j),), I)), toobject(((i - 1, j),), I))
        i -= 1
      else:
        break  
  return O
 
15.0, tensor(0.0176), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Also, move the gray shape horizontally so that its center is in the same column as the horizontal center of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def hhdcacgcdibgeggjibddafdjcccjecaa(I):
  fives = colorfilter(objects(I, True, False, False), 5)
  twos = colorfilter(objects(I, True, False, False), 2)
  target_row = min(uppermost(obj) for obj in twos)
  center_j = centerofmass(merge(twos))[1] # Find horizontal center of '2' objects
  O = I
  for five in fives:
    new_i = target_row - uppermost(five)
    new_j = sign(center_j - centerofmass(five)[1]) # Move towards '2' center
    O = paint(cover(O, five), shift(five, (new_i, new_j))) 
  return O
 
13.333333333333334, tensor(0.0163), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of the red shape. 
:: def hjehdafbafceebibjaefebeiiicbadff(I):
  fives = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  twos_center = center(toindices(extract(objects(I, True, False, True), lambda obj: color(obj) == 2)))
  offset = subtract(twos_center, ulcorner(fives))
  return paint(fill(I, 0, toindices(fives)), shift(fives, offset)) 
 
17.0, tensor(0.0164), Description: Copy the input grid. For each gray shape, move it downwards until it touches the first non-background color below it. If the gray shape is already at the bottom of the grid, do not move it. The output grid should have the original gray shapes in their original positions, and the moved gray shapes below them. 
:: def abcddedahbdbeehdjfbibcfdbacdbfgi(I):
  objs = objects(I, True, False, False) # Identify all objects
  target_objs = colorfilter(objs, 5) # Filter for objects of '5'
  moved_grid = I # Initialize the output grid
  for obj in target_objs:
    for j in range(leftmost(obj), rightmost(obj) + 1): # For each column of '5' object
      for i in range(lowermost(obj), height(I)): # Check downwards from object's bottom
        if index(moved_grid, (i, j)) != 0: # If obstacle found below
          moved_grid = move(moved_grid, obj, (i - lowermost(obj), 0)) # Move '5' above obstacle
          break
      else: # If no obstacle below
        moved_grid = move(moved_grid, obj, (height(I) - lowermost(obj) - 1, 0)) # Move to the bottom
  O = moved_grid
  return O
 
79.0, tensor(0.0641), Description: Copy the input grid. Then, for each gray square, find the nearest gray square above it and swap their positions. The output grid should have the original gray squares in their original positions, and the moved gray squares swapped with the nearest gray square above them. 
:: def cejgdchdcjjeebjaaccbcdchbieddfef(I):
  moved_grid = paint(canvas(0, shape(I)), asobject(I)) # Create an empty canvas and paint the input
  for i in range(height(I) - 1, -1, -1): # Iterate rows from bottom to top
    for j in range(width(I)): # Iterate columns
      if index(moved_grid, (i, j)) == 0: # Find empty spaces
        for k in range(i - 1, -1, -1): # Search upwards for a '5'
          if index(moved_grid, (k, j)) == 5:
            moved_grid = switch(moved_grid, 5, 0) # Swap '5' and '0'
            break
  O = moved_grid
  return O
 
8.333333333333334, tensor(0.0164), Description: Copy the input grid. For each gray shape, move it downwards until it touches the first non-background color below it. If the gray shape is already at the bottom of the grid, do not move it. The output grid should have the original gray shapes in their original positions, and the moved gray shapes below them. 
:: def eahagajcajecebbdjebbeggcfdiabbha(I):
  objs = objects(I, True, False, False) # Identify all objects
  moved_grid = I # Initialize output grid
  for obj in objs:
    if color(obj) == 5: # Check if the object is made of '5'
      down_shift = (height(I) - 1, 0) # Maximum downward shift
      for other_obj in objs:
        if other_obj != obj and color(other_obj) != 0 and vmatching(obj, other_obj):
          obstacle_bottom = lowermost(other_obj) 
          obj_bottom = uppermost(obj) + height(obj) - 1
          potential_shift = (obstacle_bottom - obj_bottom - 1, 0)
          if  0 <= potential_shift[0] < down_shift[0]:
            down_shift = potential_shift
      moved_grid = move(moved_grid, obj, down_shift) # Move the object
  O = moved_grid
  return O
 
15.333333333333334, tensor(0.0662), Description: Description: Copy the input grid. Then, for each gray square, find the nearest gray square above it and swap their positions. The output grid should have the original gray squares in their original positions, and the moved gray squares swapped with the nearest gray square above them. 
:: def fjihbcfdcdacegafjecgabebdjebabag(I):
  moved = I 
  for i in range(height(I) - 1, 0, -1): # Iterate rows from bottom to top
    for j in range(width(I)): # Iterate columns
      if index(moved, (i, j)) == 0: # Find empty space
        above_values = [index(moved, (k, j)) for k in range(i - 1, -1, -1)] # Get values above
        if 5 in above_values:
          five_index = i - above_values.index(5) - 1
          moved = fill(moved, 0, {(five_index, j)})
          moved = fill(moved, 5, {(i, j)})
  O = moved
  return O
 
13.333333333333334, tensor(0.0163), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the top left corner of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the top left corner of the red shape. 
:: def cehgceefihbaecaiaegiceafdfgcdafc(I):
  objs = objects(I, T, T, T) # Extract all objects from the grid
  obj_2 = extract(objs, lambda obj: color(obj) == 2) # Extract the object made of '2's
  obj_5 = extract(objs, lambda obj: color(obj) == 5) # Extract the object made of '5's
  return paint(cover(I, obj_5), shift(obj_5, subtract(center(obj_2), ulcorner(obj_5)))) # Calculate the offset to align upper-left corners and apply the shift.
 
15.333333333333334, tensor(0.0190), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same row as the center of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center of the red shape and in the same column as the leftmost column of the red shape. 
:: def fgbcccfjdbcaeaiijjcfbegfbjceeifd(I):
  obj_2 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 2)) # Find the object with the most '2's
  obj_5 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 5)) # Find the object with the most '5's
  offset = subtract(centerofmass(obj_2), centerofmass(obj_5)) # Calculate offset between their centers of mass
  adjusted_offset = subtract(offset, (halve(height(obj_5)) - 1, 0)) # Adjust to align upper-left corner
  return paint(cover(I, obj_5), shift(obj_5, adjusted_offset)) # Erase, shift, and repaint the '5' object
 
12.666666666666666, tensor(0.0176), Description: Description: Copy the input grid. Then, move the gray shape so that it is as close as possible to the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape as close as possible to the red shape. 
:: def fdhdiehejbffedcciafhgdhfeabbdaie(I):
  obj_2 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, T, T), lambda obj: colorcount(obj, 5))
  return paint(cover(I, obj_5), shift(obj_5, gravitate(obj_5, obj_2))) # Use 'gravitate' function to calculate and apply the shift
 
15.333333333333334, tensor(0.0185), Description: Copy the input grid. Then, move the gray shape so that it is as close as possible to the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape as close as possible to the red shape. 
:: def dfeageejdccceabfiefacaafahdicgga(I):
  fives = extract(objects(I, T, F, F), lambda obj: color(obj) == 5)
  twos = extract(objects(I, T, F, F), lambda obj: color(obj) == 2)
  move_vector = gravitate(toindices(fives), toindices(twos))
  O = paint(cover(I, fives), shift(fives, move_vector))
  return O 
 
12.666666666666666, tensor(0.0191), Description: Description: Copy the input grid. Then, move the gray shape so that it is as close as possible to the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape as close as possible to the red shape. 
:: def edfdcdagciifeecebddbbhefeffebdic(I):
  five_indices = toindices(extract(objects(I, T, F, F), matcher(color, 5)))
  two_indices = toindices(extract(objects(I, T, F, F), matcher(color, 2)))
  move_direction = gravitate(five_indices, two_indices)
  moved_fives = shift(five_indices, move_direction)
  O = paint(cover(I, five_indices), toobject(moved_fives, I))
  return O
 
20.0, tensor(0.0168), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def ccchjbabgcdfecfiiebhebaecfeffjbc(I):
  two_indices = toindices(merge(colorfilter(objects(I, True, False, False), 2)))
  target_row = min(i for i, j in two_indices)
  O = I
  for five in colorfilter(objects(I, True, False, False), 5):
    O = paint(O, shift(five, (target_row - uppermost(five), 0)))
  return O
 
15.0, tensor(0.0168), Description: Copy the input grid. Then, for each gray shape, move it upwards until its top row is in the same row as the top row of the red shape. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def bbcccfgfeiigecdfbdeccfccgfaabdhf(I):
  target_row = uppermost(extract(objects(I, True, False, False), lambda obj: color(obj) == 2))
  O = I
  for obj in objects(I, True, False, False):
    if color(obj) == 5:
      O = paint(cover(O, obj), shift(obj, (target_row - uppermost(obj), 0)))
  return O
 
11.333333333333334, tensor(0.0168), Description: Copy the input grid. Then, move the gray shape so that its center is in the same location as the center of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of the red shape. 
:: def gbificcjbibdedefjcadcadgbcdeacaf(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  two_center = center(toobject(ofcolor(I, 2), I))
  return paint(fill(I, 0, five_obj), 
               shift(five_obj, subtract(two_center, center(five_obj))))
 
14.333333333333334, tensor(0.0197), Description: Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def fhejeeeefaccedjcjbagfefjbadaeibf(I):
  five_obj = toobject(ofcolor(I, 5), I)
  two_obj = toobject(ofcolor(I, 2), I)
  diff = subtract(centerofmass(two_obj), centerofmass(five_obj))
  return paint(fill(I, 0, five_obj), shift(five_obj, diff))
 
40.0, tensor(0.0810), Description: Copy the input grid. Then, for each non-background square, find the nearest non-background square above it and swap their positions. The output grid should have the original squares in their original positions, and the moved squares swapped with the nearest non-background square above them. 
:: def gdbfbfdcegagebbaahjbfgdbaaaddaci(I):
    O = I
    for j in range(width(I)):
        for i in range(1, height(I)):
            if index(O, (i, j)) != 0 and index(O, (i - 1, j)) == 0:
                k = i
                while k > 0 and index(O, (k - 1, j)) == 0:
                    k -= 1
                O = fill(O, 0, {(i, j)})
                O = fill(O, index(I, (i, j)), {(k, j)})
    return O 
 
30.0, tensor(0.0163), Description: Copy the input grid. Then, for each gray shape, move it upwards until it touches the first non-background color above it. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes above them. 
:: def bbcehffgccjceibbjbchdddebfjfibdf(I):
    O = I
    for obj in objects(I, False, False, True):
        i = uppermost(obj)
        while i > 0 and index(O, (i - 1, leftmost(obj))) == 0:
            O = move(O, obj, (-1, 0))
            i -= 1
    return O
 
8.666666666666666, tensor(0.0159), Description: Copy the input grid. Then, move the gray shape to the center of the grid. Keep the original gray shape in its original position. Keep the red shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep the red shape in its original position. 
:: def eagfdjcacccdebdhabfgbgahbdagjbag(I):
  O = canvas(mostcolor(I), shape(I))
  for i, j in asindices(I):
    if I[i][j] == 2:
      O = paint(O, {(2, (i, j))})
    elif I[i][j] == 5:
      center_i, center_j = center(toindices(first(colorfilter(objects(I, T, T, T), 2))))
      O = paint(O, {(5, (center_i, center_j))})
  return O
 
16.666666666666668, tensor(0.0052), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the rightmost column of the red shape and in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the rightmost column of the red shape and in the same row as the bottom row of the grid. Keep the red shape in its original position. 
:: def ighafjaebacbebefbdfdbecfcaefffbf(I):
  objs = objects(I, True, False, True)
  fives = colorfilter(objs, 5)
  twos = colorfilter(objs, 2)
  target = astuple(len(I)-1, (len(I[0]) - width(first(fives))) // 2)
  moved_fives = shift(first(fives), subtract(target, ulcorner(first(fives))))
  O = paint(paint(canvas(0, shape(I)), moved_fives), first(twos))
  return O 
 
22.333333333333332, tensor(0.0043), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the bottom row of the grid. 
:: def jdfcaadfedceehhejaacaaebcddaccbg(I):
  objs = objects(I, True, False, True)
  fives = first(colorfilter(objs, 5))
  target_j = (len(I[0]) - width(fives)) // 2
  O = paint(canvas(0, shape(I)), shift(fives, (len(I)-height(fives), target_j)))
  return O
 
26.666666666666668, tensor(0.0043), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the bottom row of the grid. 
:: def acbefcbfdhcbebdgbecffecebbjceiab(I):
  fives = normalize(first(colorfilter(objects(I, True, False, True), 5)))
  h, w = shape(I)
  target = (h - height(fives), (w - width(fives)) // 2)
  O = paint(canvas(0, (h, w)), shift(fives, target))
  return O
 
15.333333333333334, tensor(0.0038), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def hdbccbfabeaaebjficejbihbecabacja(I):
  obj_2 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 5))
  offset_i = uppermost(obj_2) - uppermost(obj_5) - height(obj_5)
  offset_j = leftmost(obj_2) - leftmost(obj_5)
  moved_obj = shift(obj_5, (offset_i, offset_j))
  O = underpaint(cover(I, obj_5), moved_obj)
  return O
 
12.0, tensor(0.0039), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def dfbgbbhffaabeefajfbjdiejacaffeaf(I):
  twos = ofcolor(I, 2)
  fives = ofcolor(I, 5)
  target_i = minimum(apply(lambda idx: idx[0], twos))
  offset = (target_i - minimum(apply(lambda idx: idx[0], fives)) - height(fives), leftmost(fives) - leftmost(twos))
  moved_fives = shift(fives, offset)
  O = fill(fill(I, 0, fives), 5, moved_fives)
  return O
 
22.333333333333332, tensor(0.0053), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same location as the bottom left corner of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the bottom left corner of the grid. Fill the rest of the grid with the most common color. 
:: def eeegagcdcbffedagbafciedhfffbcfee(I):
  five_indices = ofcolor(I, 5) # Get indices of all '5' cells
  other_indices = difference(asindices(I), five_indices) # Get indices of all non-'5' cells
  bottom_row_start = (len(I) - 1, 0)
  shifted_five_indices = shift(five_indices, subtract(bottom_row_start, ulcorner(five_indices))) # Calculate and apply the shift to the bottom row
  O = fill(fill(canvas(0, shape(I)), 5, shifted_five_indices), mostcolor(I), other_indices) # Fill empty canvas with moved '5', then fill other cells 
  return O
 
13.333333333333334, tensor(0.0046), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the bottom row of the grid. 
:: def ecbejddhhejdefiabebffgegdhdiajaa(I):
  five_obj = extract(objects(I, False, True, True), lambda obj: color(obj) == 5) # Directly extract the '5' object
  O = paint(cover(I, five_obj), shift(five_obj, (height(I) - 1 - uppermost(five_obj), 0))) # Cover the '5' object in the original grid and paint it on the shifted position
  return O
 
23.666666666666668, tensor(0.0052), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the bottom row of the grid. Fill the rest of the grid with the most common color. 
:: def ijgfdbdfigafeigiiajgiiebgaieejbi(I):
  five_patch = toindices(extract(objects(I, False, True, True), lambda obj: color(obj) == 5)) # Directly extract the '5' patch
  moved_five_patch = shift(five_patch, (height(I) - 1 - uppermost(five_patch), 0)) # Calculate and apply the shift to the bottom row
  O = fill(fill(canvas(0, shape(I)), 5, moved_five_patch), mostcolor(I), difference(asindices(I), moved_five_patch)) # Fill an empty canvas with the moved '5' patch, then fill the remaining with the original background color.
  return O
 
12.0, tensor(0.0052), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the bottom row of the grid. Fill the rest of the grid with the most common color. 
:: def jgaabfihafihedceaccdecajdcddbdec(I):
    five_obj = extract(objects(I, False, True, True), lambda obj: color(obj) == 5) # Directly extract the '5' object
    new_grid = canvas(mostcolor(I), shape(I))  # Create new grid filled with background color
    for v, (i, j) in five_obj:
        new_grid = paint(new_grid, {(v, (len(I) - 1, j))}) # Paint '5's at the bottom row
    O = paint(new_grid, difference(asobject(I), five_obj)) # Paint the rest of the objects from original grid
    return O
 
25.333333333333332, tensor(0.0044), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the middle row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the middle row of the grid. 
:: def bghigffbaidjefgfaicbdifbebgbjaci(I):
  objs = objects(I, True, False, True)
  fives = colorfilter(objs, 5)
  target_j = (len(I[0]) - width(first(fives))) // 2 
  target = astuple(len(I) // 2, target_j) 
  moved_fives = shift(first(fives), subtract(target, ulcorner(first(fives))))
  O = paint(canvas(0, shape(I)), moved_fives)
  return O
 
26.0, tensor(0.0044), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the middle row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the middle row of the grid. 
:: def eafbfacfjajbebccaaffbhgdfdbdajef(I):
  five_indices = ofcolor(I, 5)
  target_j = (len(I[0]) - width(five_indices)) // 2
  target_i = len(I) // 2
  moved_fives = frozenset({(5, (target_i, j + target_j)) for i, j in five_indices}) 
  O = paint(canvas(0, shape(I)), moved_fives)
  return O
 
24.0, tensor(0.0243), Description: Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def ehidfbeeedbeebdjacededdfhhaeedhg(I):
  fives = first(colorfilter(objects(I, True, False, True), 5))
  target = astuple(len(I) // 2, (len(I[0]) - width(fives)) // 2)
  O = paint(canvas(0, shape(I)), shift(fives, subtract(target, centerofmass(fives))))
  return O
 
29.0, tensor(0.0044), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the middle row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the middle row of the grid. 
:: def cjfbddffifbgedbfbeefcccdefacgfdf(I):
  five_obj = first(colorfilter(partition(I), 5))
  target_i = len(I) // 2
  target_j = (len(I[0]) - width(five_obj)) // 2
  moved = frozenset((5, (i + target_i - uppermost(five_obj), j + target_j - leftmost(five_obj))) for v, (i, j) in five_obj)
  O = paint(canvas(0, shape(I)), moved)
  return O
 
15.0, tensor(0.0038), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def bbhaabjacfidebbbjfedgccejceaehaf(I):
    obj2 = argmax(objects(I, T, F, T), lambda obj: color(obj) == 2)
    obj5 = argmax(objects(I, T, F, T), lambda obj: color(obj) == 5)
    h_diff = height(obj5) 
    new_obj5 = shift(obj5, (uppermost(obj2) - lowermost(obj5) - h_diff, leftmost(obj2) - leftmost(obj5)))
    O = paint(cover(I, obj5), new_obj5)
    return O
 
25.333333333333332, tensor(0.0066), Description: Copy the input grid. Then, for each colored shape in each row, move it horizontally so that its center is in the same column as the center column of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered horizontally in each row. 
:: def ccbiigbefgdeeibcaifafcgbedgdfchh(I):
  O = canvas(mostcolor(I), shape(I))  # Create blank canvas
  for i, row in enumerate(I):
    for obj in objects(tuple([row]), False, True, True):  # Iterate objects in row
      center_col = width(I) // 2  # Center column of the grid
      obj_center_col = (leftmost(obj) + rightmost(obj)) // 2  # Center col of object
      offset = (0, center_col - obj_center_col)  # Calculate horizontal offset
      O = paint(O, shift(toobject(obj, tuple([row])), offset))  # Paint shifted object
  return O
 
28.0, tensor(0.0066), Description: Copy the input grid. Then, for each colored shape in each row, move it horizontally so that its center is in the same column as the center column of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered horizontally in each row. 
:: def ejbafadihcaaefaejadbacjacfjaabae(I):
  new_grid = list(list(row) for row in I)  # Create a mutable copy of the grid
  for i, row in enumerate(I):
    for obj in objects(tuple([row]), False, True, True):
      center_col = len(row) // 2
      obj_center_col = (leftmost(obj) + rightmost(obj)) // 2
      offset = center_col - obj_center_col
      for j in range(leftmost(obj), rightmost(obj) + 1):
          new_grid[i][j + offset] = I[i][j]  # Move object pixels
          if offset > 0: 
              new_grid[i][j] = mostcolor(I)  # Clear trailing space
  return tuple(tuple(row) for row in new_grid) # Convert back to immutable tuples
 
14.0, tensor(0.0070), Description: Copy the input grid. Then, for each gray shape, move it down so that its bottom row is in the same row as the bottom row of the largest non-gray shape. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def cbehbbaeadaaebaeaafjgaijiegajiaf(I):
  # 1. Identify Objects
  objs = objects(I, False, True, True)
  five_objs = colorfilter(objs, 5) 
  other_objs = difference(objs, five_objs)

  # 2. Find the target object 
  target_obj = argmax(other_objs, size)

  # 3. Determine target positions
  target_positions = set()
  for five_obj in five_objs:
    target_i = lowermost(target_obj)
    target_j = leftmost(five_obj) + (width(five_obj) // 2)
    target_positions.add((target_i, target_j))

  # 4. Move '5' objects
  I = cover(I, merge(five_objs)) 
  for target_position, five_obj in zip(target_positions, five_objs):
    five_obj_center = centerofmass(five_obj)
    offset = subtract(target_position, five_obj_center)
    I = paint(I, shift(five_obj, offset))
  return I 
 
15.333333333333334, tensor(0.0056), Description: Copy the input grid. Then, for each gray square within the largest colored shape, move it down so that it is in the same row as the bottom row of the largest colored shape. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def aebhfheiffahedjcjgebigebdfccegda(I):
  # 1. Identify the target area
  target_obj = argmax(objects(I, False, True, True), size)
  target_area = toindices(target_obj)

  # 2. Move '5' objects within the target area
  for i, j in asindices(I):
    if I[i][j] == 5 and (i, j) in target_area:
      target_i = lowermost(target_area)
      I = paint(cover(I, {(5, (i, j))}), {(5, (target_i, j))}) 
  return I
 
11.333333333333334, tensor(0.0066), Description: Copy the input grid. Then, for each gray shape, move it down so that its bottom row is in the same row as the bottom row of the largest colored shape. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def gacddabechadeiacaefhdachfacbahaa(I):
  # 1. Identify Objects and Target Row
  fives = colorfilter(objects(I, F, T, T), 5)
  target_row = lowermost(argmax(objects(I, F, T, T), size)) 

  # 2. Clear Existing '5' Objects
  I = cover(I, merge(fives))

  # 3. Repaint '5' Objects on Target Row
  for obj in fives:
    for _, (i, j) in obj:
      I = paint(I, {(5, (target_row, j))})
  return I
 
15.0, tensor(0.0078), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its bottom row is in the same row as the top row of the largest colored shape. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def fjdfhfhdbaigecefagjegaedbeeggfgf(I):
  five_objs = colorfilter(objects(I, F, T, T), 5)
  other_objs = difference(objects(I, F, T, T), five_objs)
  target_obj = argmax(other_objs, size)
  target_bottom = lowermost(target_obj)

  new_fives = set()
  for obj in five_objs:
    for _, (i, j) in obj:
      new_fives.add((5, (target_bottom - (i - uppermost(obj)), j)))

  I = cover(I, merge(five_objs))
  return paint(I, frozenset(new_fives))
 
14.333333333333334, tensor(0.0109), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its bottom row is in the same row as the top row of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def iafeaadjigdcebebbiejadfiagdiebef(I):
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  target_obj = argmax(objs, lambda obj: len(obj) if color(obj) != 5 else 0)
  target_bottom = lowermost(target_obj)

  for five in fives:
    I = cover(I, five)
    I = paint(I, shift(five, (target_bottom - uppermost(five), 0)))

  return I
 
13.0, tensor(0.0110), Description: Copy the input grid. Then, for each gray shape in each row, move it horizontally so that it is centered within the row. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes centered horizontally in each row. 
:: def ecbhdbgeedfjebciiefcjbdehfgbagah(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    five_indices = frozenset((i, j) for j, v in enumerate(row) if v == 5)
    if five_indices:
      centered_fives = shift(five_indices, (0, (len(row) - width(five_indices)) // 2 - leftmost(five_indices)))
      O = paint(O, recolor(5, centered_fives))
    O = paint(O, toobject(asindices(I) - ofcolor(I, 5), I))
  return O
 
9.666666666666666, tensor(0.0148), Description: Copy the input grid. Then, for each gray shape, move it horizontally so that it is centered within the grid. Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes centered horizontally. 
:: def afhahbjdbebceibcacfdeeheicigjadd(I):
  O = I
  for obj in colorfilter(objects(I, True, False, True), 5):
    O = move(O, obj, (0, (len(I[0]) - width(obj)) // 2 - leftmost(obj)))
  return O
 
23.0, tensor(0.0110), Description: Copy the input grid. Then, for each gray shape in each row, move it horizontally so that it is centered within the row. Keep the original gray shapes in their original positions. The output grid should have the original gray shapes in their original positions, and the moved gray shapes centered horizontally in each row. 
:: def edgdbehbeceheibhbbbfeggbjbfibaac(I):
  rows = tuple(row for row in I)
  for i, row in enumerate(rows):
    if 5 in row:
      five_start = row.index(5)
      five_end = len(row) - row[::-1].index(5)
      offset = (len(I[0]) - (five_end - five_start)) // 2 - five_start
      rows = rows[:i] + (tuple(0 for _ in range(len(row))),) + rows[i+1:]
      rows = rows[:i] + (tuple(5 if j >= offset and j < offset + (five_end - five_start) else 0 for j in range(len(row))),) + rows[i+1:]
  return rows
 
15.333333333333334, tensor(0.0049), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column. 
:: def cjcijafdebjheeieidaebgecciebhfeb(I):
  objs = objects(I, T, F, T)
  obj_2 = extract(objs, lambda obj: color(obj) == 2)
  obj_5 = extract(objs, lambda obj: color(obj) == 5)
  target_loc = subtract(ulcorner(obj_2), (height(obj_5) + 1, 0)) 
  moved_obj = shift(obj_5, subtract(target_loc, ulcorner(obj_5)))
  O = paint(cover(I, obj_5), moved_obj) 
  return O
 
15.333333333333334, tensor(0.0053), Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column. 
:: def gaebdiagcjedebecibggebfhbdghfefe(I):
  obj_2 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 5))
  O = paint(cover(I, obj_5), shift(obj_5, (uppermost(obj_2) - lowermost(obj_5) - 1, 0)))
  return O
 
15.333333333333334, tensor(0.0053), Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column. 
:: def dfgeiebecdececjabdbgibdccaebjbcg(I):
  objs = objects(I, T, F, T)
  obj_2, obj_5 = next((a, b) for a in objs for b in objs if color(a) == 2 and color(b) == 5)
  O = paint(cover(I, obj_5), shift(obj_5, (uppermost(obj_2) - lowermost(obj_5) - 1, 0)))
  return O
 
86.0, tensor(0.0066), Description: Copy the input grid. Then, for each colored shape in each row, move it horizontally so that its center is in the same column as the center column of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered horizontally in each row. 
:: def fehagbabacceeefajbaaibefeaiebagc(I):
  return tuple(
    tuple(
      branch(
        j >= leftmost(obj) + (len(row) // 2 - (leftmost(obj) + rightmost(obj)) // 2) and j <= rightmost(obj) + (len(row) // 2 - (leftmost(obj) + rightmost(obj)) // 2),
        index(tuple([row]), (0, j - (len(row) // 2 - (leftmost(obj) + rightmost(obj)) // 2))),
        mostcolor(I)
      )
      for j in range(len(row))
    )
    for row in I
    for obj in objects(tuple([row]), False, True, True)
  )
 
123.66666666666667, tensor(0.0070), Description: Copy the input grid. Then, for each non-background square in each row, move it horizontally so that it is centered within the row. Keep the original squares in their original positions. The output grid should have the original squares in their original positions, and the moved squares centered horizontally in each row. 
:: def ebgdcbdejheeeaaabgaiddhffadfgfdc(I):
  return tuple(
    papply(
      lambda v, j: branch(
        v != mostcolor(I),
        v,
        index(tuple([row]), (0, j - (len(row) - sum(1 for x in row if x != mostcolor(I))) // 2 + j))
      ),
      row,
      tuple(range(len(row)))
    )
    for row in I
  )
 
12.666666666666666, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def eadiajedfiffeigcahbcbdaafeagbecg(I):
  # 1. Identify Objects 
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  other_objs = difference(objs, fives)
  target_obj = argmax(other_objs, size)

  # 2. Calculate Target Positions
  target_center_j = centerofmass(target_obj)[1]

  # 3. Clear Existing '5' Objects
  I = cover(I, merge(fives))

  # 4. Repaint '5' Objects at Target Positions
  for i, obj in enumerate(fives):
    target_i = uppermost(target_obj) - len(fives) + i
    I = paint(I, shift(obj, (target_i - uppermost(obj), target_center_j - leftmost(obj))))
  return I
 
12.0, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def gaabchbfhffiehcaaadecfbfbehgefag(I):
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  largest_obj = argmax(difference(objs, fives), size)
  target_row = uppermost(largest_obj) - len(fives)
  I = cover(I, merge(fives))
  target_col = leftmost(largest_obj) + width(largest_obj) // 2
  for obj in fives:
    I = paint(I, shift(obj, (target_row - uppermost(obj), target_col - leftmost(obj))))
    target_row += 1
  return I
 
12.666666666666666, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def icififfcgeigefddaahheafjedeadfbi(I):
  fives = colorfilter(objects(I, F, T, T), 5)
  other_objs = difference(objects(I, F, T, T), fives)
  target = argmax(other_objs, lambda o: (size(o), -uppermost(o)))
  target_i = uppermost(target) - size(fives)
  target_j = leftmost(target) + width(target) // 2 
  I = cover(I, merge(fives))
  for i, obj in enumerate(fives):
    I = paint(I, shift(obj, (target_i + i - uppermost(obj), target_j - leftmost(obj))))
  return I
 
30.0, tensor(0.0114), Description: Copy the input grid. Then, move the gray shape horizontally so that its leftmost column is in the same column as the center column of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid. 
:: def diceibdhgdbieahbjdfhgdaeabchdece(I):
  five_indices = ofcolor(I, 5)
  target_j = (len(I[0]) - width(five_indices)) // 2
  moved_indices = frozenset((i, j + target_j - leftmost(five_indices)) for i, j in five_indices)
  O = fill(canvas(0, shape(I)), 5, moved_indices)
  return O
 
15.0, tensor(0.0136), Description: Copy the input grid. Then, move the gray shape horizontally so that it is centered within the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape centered horizontally. 
:: def cebcaebihafeecbdafgadfifiddedgjd(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  offset = ((len(I[0]) - width(five_obj)) // 2 - leftmost(five_obj), 0)
  O = move(I, five_obj, offset)
  return O 
 
11.333333333333334, tensor(0.0039), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def dbededaaafjiedbfijaacaaabccgjabe(I):
  twos = ofcolor(I, 2)
  fives = ofcolor(I, 5)
  target_j = minimum(apply(lambda idx: idx[1], twos)) 
  offset = (minimum(apply(lambda idx: idx[0], twos)) - (maximum(apply(lambda idx: idx[0], fives)) + 1), target_j - minimum(apply(lambda idx: idx[1], fives)))
  moved_fives = shift(fives, offset)
  O = fill(fill(I, 0, fives), 5, moved_fives)
  return O
 
14.333333333333334, tensor(0.0180), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. 
:: def aifddbfccicceihgifaidcafhaeciead(I):
  twos = ofcolor(I, 2)
  fives = ofcolor(I, 5)
  center_two = centerofmass(twos)
  center_five = centerofmass(fives)
  offset = subtract(center_two, center_five)
  moved_fives = shift(fives, offset)
  O = fill(fill(I, 0, fives), 5, moved_fives)
  return O 
 
14.0, tensor(0.0182), Description: Description: Copy the input grid. Then, move the gray shape so that it is as close as possible to the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape as close as possible to the red shape. 
:: def ibicgebbbcahejjeifedeaifegadjbij(I):
  objs = objects(I, T, F, T)
  obj_2 = extract(objs, lambda obj: color(obj) == 2)
  obj_5 = extract(objs, lambda obj: color(obj) == 5)
  offset = gravitate(obj_5, obj_2)
  moved_obj = shift(obj_5, offset)
  O = paint(cover(I, obj_5), moved_obj)
  return O
 
14.666666666666666, tensor(0.0227), Description: Copy the input grid. Then, for each gray shape, move it so that its center of mass is in the center of the shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the shape. 
:: def cffecabiaiccedacbdedjedhhbiebfji(I):
  five_objs = colorfilter(objects(I, False, True, True), 5) # Identify objects containing '5'
  O = I
  for obj in five_objs:
    obj_indices = toindices(obj)  # Get indices of the current object
    center_obj = center(obj_indices) # Calculate center of the object
    center_mass = centerofmass(obj)  # Calculate center of mass of the object
    diff = subtract(center_obj, center_mass)  # Calculate the shift needed
    O = paint(cover(O, obj), shift(obj, diff)) # Cover old object, shift and paint the new one
  return O
 
12.0, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def cdidchiaefeaeiefacbchdcgeeaddijb(I):
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  rest = difference(objs, fives)
  largest_obj = argmax(rest, size)
  
  I = cover(I, merge(fives))  
  
  for i, obj in enumerate(fives):
    target_loc = add(ulcorner(largest_obj), (-i-1, width(largest_obj) // 2))  # Calculate top-left corner of the target location
    offset = subtract(target_loc, ulcorner(obj))  # Calculate offset from current to target location
    I = paint(I, shift(obj, offset))
  return I
 
29.666666666666668, tensor(0.0072), Description: Copy the input grid. Then, move the gray shape horizontally so that its center is in the same column as the center column of the grid. Then, move the gray shape vertically so that its center of mass is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape centered horizontally and vertically. 
:: def biadeecgggbeefhaibeaadfhdfcaejdd(I):
  five_indices = ofcolor(I, 5)
  target_j = len(I[0]) // 2 
  shift_amount = target_j - (leftmost(five_indices) + width(five_indices) // 2)
  moved_five = shift(recolor(5, five_indices), (0, shift_amount))
  centered_five = shift(moved_five, (len(I) // 2 - centerofmass(moved_five)[0], 0))
  O = paint(canvas(0, shape(I)), centered_five)
  return O
 
23.0, tensor(0.0235), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def ieaebafdhfdjececjfdaegcebfcdggfb(I):
  five_obj = extract(objects(I, True, False, True), lambda obj: 5 in palette(obj))
  grid_center = (len(I) // 2, len(I[0]) // 2)
  obj_center = centerofmass(five_obj)
  move_vector = subtract(grid_center, obj_center)
  moved_obj = shift(five_obj, move_vector)
  O = paint(canvas(0, shape(I)), moved_obj)
  return O
 
19.666666666666668, tensor(0.0038), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def fidddiffdfjhejafaejejedadcbdejga(I):
  obj_2 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 5))
  O = paint(I, shift(obj_5, (uppermost(obj_2) - lowermost(obj_5) - 1, leftmost(obj_2) - leftmost(obj_5))))
  return O
 
14.333333333333334, tensor(0.0040), Description: Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def aafaedcdaacgeadcjahaggcadceaaedf(I):
  obj_2 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 2))
  obj_5 = argmax(objects(I, T, F, T), lambda obj: colorcount(obj, 5))
  O = paint(cover(I, obj_5), shift(obj_5, (uppermost(obj_2) - height(obj_5), leftmost(obj_2) - leftmost(obj_5))))
  return O
 
9.333333333333334, tensor(0.0226), Description: Copy the input grid. Then, for each gray shape, move it so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def ghbjadeegdddehdebagebbbafcdgeaee(I):
  fives = ofcolor(I, 5)  # Find indices of all "5" cells
  objs = objects(I, False, True, True) # Find all objects on the grid
  five_objs = colorfilter(objs, 5) # Extract objects containing "5"

  moved_objs = frozenset()
  for obj in five_objs:
    center_obj = centerofmass(obj)  # Center of mass of the object
    center_grid = center(asindices(I))  # Center of the grid
    shift_amount = subtract(center_grid, center_obj)  # Shift amount

    moved_objs = combine(moved_objs, shift(obj, shift_amount))  # Shift & accumulate

  O = paint(cover(I, fives), moved_objs)  # Cover & paint
  return O
 
17.0, tensor(0.0226), Description: Copy the input grid. Then, for each gray shape, move it so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def checcbfehhbcecbgajgecejhcbbccfcb(I):
  objs = objects(I, False, True, True)
  return paint(
      I, 
      merge(
        apply(
          lambda obj: recolor(
              5, 
              shift(
                  toindices(obj), 
                  subtract(center(asindices(I)), centerofmass(obj))
              )
          ), 
          colorfilter(objs, 5)
        )
      )
  )
 
42.0, tensor(0.0090), Description: Copy the input grid. Then, for each colored shape, move it so that its center is in the center of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered horizontally and vertically. 
:: def dibdabajjgdgefhjjhacbceaffbaheba(I):
  return paint(
      canvas(mostcolor(I), shape(I)), 
      shift(
          merge(objects(I, False, True, True)), 
          subtract(
              divide(shape(I), 2), 
              divide(shape(merge(objects(I, False, True, True))), 2)
          )
      )
  )
 
32.666666666666664, tensor(0.0090), Description: Copy the input grid. Then, for each colored shape, move it so that its center is in the center of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered horizontally and vertically. 
:: def chdabejjfbgceebcaffahiehfcbegbbb(I):
    objs = order(objects(I, False, True, True), size)
    result = canvas(mostcolor(I), shape(I))
    for obj in objs:
        offset = subtract(divide(shape(I), 2), divide(shape(obj), 2))
        result = paint(result, shift(obj, offset))
    return result
 
9.333333333333334, tensor(0.0094), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the center row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def befhbcgbjcbfebffjiffgdaecjcgcfae(I):
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  target_obj = argmax(objs, lambda obj: size(obj) if color(obj) != 5 else 0) # Find largest non-5 object
  target_loc = center(target_obj) # Calculate target location based on center of largest object
  I = cover(I, merge(fives))
  for i, obj in enumerate(fives):
    offset = (height(target_obj) // 2 + height(obj) * (i - len(fives) // 2), 0) # Calculate offset based on object index and size
    I = paint(I, shift(obj, add(target_loc, offset))) # Paint object at offset from target location
  return I
 
12.0, tensor(0.0115), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def cfibfdhhjgffeieeagjdacjjeffbbdde(I):
  objs = objects(I, F, T, T)
  fives = colorfilter(objs, 5)
  largest_obj = argmax(objs, size)
  fives_merged = merge(fives) # Merge '5' objects into a single object for easier manipulation
  target_row = uppermost(largest_obj) - height(fives_merged)
  target_col = leftmost(largest_obj) + width(largest_obj) // 2 - width(fives_merged) // 2
  I = cover(I, fives_merged)
  I = paint(I, shift(fives_merged, (target_row - uppermost(fives_merged), target_col - leftmost(fives_merged)))) # Move the merged '5' object
  return I
 
15.333333333333334, tensor(0.0038), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. 
:: def hgdaceghjaagedcfjfcbcehdafdbbhhh(I):
  objs = objects(I, T, F, T)  # Extract objects from the input
  obj_2 = extract(objs, lambda obj: color(obj) == 2) # Find object with color 2
  obj_5 = extract(objs, lambda obj: color(obj) == 5) # Find object with color 5
  new_5_pos = (uppermost(obj_2) - height(obj_5), (leftmost(obj_2) + width(obj_2) // 2) - (width(obj_5) // 2)) # Calculate the new top-left corner position for the '5' object
  O = paint(cover(I, obj_5), shift(obj_5, subtract(new_5_pos, ulcorner(obj_5)))) # Paint the moved object onto the grid
  return O
 
15.333333333333334, tensor(0.0039), Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. 
:: def acadfgccciciejcciahhgffgffbihfcf(I):
  objs = objects(I, T, F, T)
  obj_2 = argmax(objs,  lambda obj: color(obj) == 2)
  obj_5 = argmax(objs,  lambda obj: color(obj) == 5)
  target_pos = (uppermost(obj_2) - height(obj_5), leftmost(obj_2) + width(obj_2) // 2) # Calculate the target position for the '5' object's center
  offset = subtract(target_pos, center(obj_5)) # Calculate the offset needed to move the '5' object
  O = paint(cover(I, obj_5), shift(obj_5, offset))  # Move the '5' object and paint it onto the grid
  return O
 
15.0, tensor(0.0039), Description: Copy the input grid. Then, move the gray shape so that its top row is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. 
:: def aggdjdcjcacceiebaffcdfafcbafeccd(I):
  objs = objects(I, T, F, T)
  obj_2 = next((obj for obj in objs if color(obj) == 2), None)
  obj_5 = next((obj for obj in objs if color(obj) == 5), None)
  O = paint(
    cover(I, obj_5), 
    shift(obj_5, (uppermost(obj_2) - height(obj_5) - lowermost(obj_5), (leftmost(obj_2) + width(obj_2) // 2) - (leftmost(obj_5) + width(obj_5) // 2)))
  )
  return O
 
26.0, tensor(0.0071), Description: Copy the input grid. Then, for each gray square, move it vertically so that it is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center row of the grid. Fill the rest of the grid with the most common color. 
:: def iehiibjidfcbeegfidfjhcbdffefdaef(I):
  fives = ofcolor(I, 5)
  moved_fives = frozenset()
  for i, j in fives:
    center_grid = height(I) // 2
    shift_amount = center_grid - i
    moved_fives = combine(moved_fives, {(i + shift_amount, j)})
  O = fill(fill(canvas(0, shape(I)), 5, moved_fives), mostcolor(I), difference(asindices(I), moved_fives))
  return O
 
15.333333333333334, tensor(0.0047), Description: Copy the input grid. Then, move the gray shape vertically so that its center of mass is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center row of the grid. 
:: def efdgefeefdieedcjjccabchhcaiidgbd(I):
  five_obj = extract(objects(I, False, True, True), lambda obj: color(obj) == 5)
  shift_amount = (height(I) // 2) - centerofmass(five_obj)[0]
  moved_obj = shift(five_obj, (shift_amount, 0))
  O = paint(cover(I, five_obj), moved_obj)
  return O
 
15.0, tensor(0.0047), Description: Copy the input grid. Then, move the gray shape vertically so that its center of mass is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center row of the grid. 
:: def fjceeeejcjifedbabhgdjcefcefbfbde(I):
  return paint(
      cover(I, ofcolor(I, 5)), 
      shift(
          toobject(
              ofcolor(I, 5),
              I
          ),
          ((height(I) // 2) - centerofmass(toobject(ofcolor(I, 5), I))[0], 0)
      )
  )
 
697.3333333333334, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def gehbhhcbdcgdegfhiahaadccfdcbgedf(I):
  objs = objects(I, False, True, True)
  center_row = height(I) // 2
  return tuple(
      tuple(
          next((v for (v, (oi, oj)) in obj if oi == i - center_row + uppermost(obj) + height(obj) // 2 and oj == j), mostcolor(I))
          for j in range(width(I))
      )
      for i in range(height(I))
      for obj in objs
  )
 
29.0, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def eebicebaecddecbdajffhbadadadaceh(I):
  return tuple(
      tuple(
          next((v for obj in objects(I, False, True, True) for (v, (oi, oj)) in obj 
                if oi == i - (height(I) // 2) + uppermost(obj) + height(obj) // 2 and oj == j), mostcolor(I))
          for j in range(width(I))
      )
      for i in range(height(I))
  )
 
29.333333333333332, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def bhffdadjfjggeghgabajbcbdabdddfff(I):
    objs = objects(I, False, True, True)
    new_grid = list(list(row) for row in canvas(mostcolor(I), shape(I)))
    for obj in objs:
        center_row = height(I) // 2
        obj_center_row = uppermost(obj) + height(obj) // 2
        shift_amount = center_row - obj_center_row
        for v, (i, j) in obj:
            new_i = i + shift_amount
            if 0 <= new_i < height(I):
                new_grid[new_i][j] = v
    return tuple(tuple(row) for row in new_grid)
 
35.666666666666664, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def jccdgcaddcgcebjbbiddehfcecgbefeb(I):
    return tuple(
        tuple(
            next(
                (
                    v
                    for obj in objects(I, False, True, True)
                    for (v, (oi, oj)) in obj
                    if oi == i + (height(obj) // 2) - (height(I) // 2) and oj == j
                ),
                mostcolor(I),
            )
            for j in range(width(I))
        )
        for i in range(height(I))
    )
 
7.666666666666667, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def jdhcgdfgegeeeagdabaacdachdjcccde(I):
  objs = objects(I, F, T, T) # Identify all objects
  fives = colorfilter(objs, 5) # Extract '5' objects
  other_objs = difference(objs, fives) # Objects excluding '5'
  largest_obj = argmax(other_objs, size) # Largest object (excluding '5')
  target_row = uppermost(largest_obj) - height(merge(fives)) # Target row
  target_col = leftmost(largest_obj) + width(largest_obj) // 2 - width(merge(fives)) // 2 # Target column
  I = cover(I, merge(fives)) # Clear original '5' objects
  for i, obj in enumerate(fives): # Place '5' objects
    I = paint(I, shift(obj, (target_row + i * height(obj) - uppermost(obj), target_col - leftmost(obj))))
  return I
 
12.666666666666666, tensor(0.0689), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep all other shapes in their original positions. 
:: def cijhgbfhghaeeaceacbeedbgcchbfbgb(I):
  five = first(colorfilter(objects(I, True, False, True), 5))
  new_grid = canvas(0, shape(I))
  for obj in objects(I, True, False, True):
    if obj != five:
      new_grid = paint(new_grid, obj)
  new_grid = paint(new_grid, shift(five, subtract(divide(shape(I), 2), centerofmass(five))))
  return new_grid
 
14.333333333333334, tensor(0.0038), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the leftmost column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the leftmost column of the red shape. 
:: def ddagadabhedhedfejfacjcddadebbgcj(I):
  objs = objects(I, T, F, T)
  obj_2, obj_5 = argmin(objs, lambda obj: uppermost(obj)), argmax(objs, lambda obj: uppermost(obj))
  offset_y = uppermost(obj_2) - lowermost(obj_5) - 1
  offset_x = leftmost(obj_2) - leftmost(obj_5)
  O = paint(cover(I, obj_5), shift(obj_5, (offset_y, offset_x)))
  return O
 
11.333333333333334, tensor(0.0045), Description: Copy the input grid. Then, for each gray square, move it vertically so that it is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center row of the grid. 
:: def fjjebfiidfidefgjaedbahdcjhehdjda(I):
  five_indices = ofcolor(I, 5)
  mid_row = height(I) // 2
  shifted_indices = frozenset((mid_row, j) for i, j in five_indices)
  return fill(cover(I, five_indices), 5, shifted_indices)
 
15.0, tensor(0.0107), Description: Copy the input grid. Then, for each gray shape, move it vertically so that its center of mass is in the same row as the center row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the center row of the grid. Keep all other shapes in their original positions. 
:: def bjahgjahagcaeiehifgacaebjfacdced(I):
  return paint(
      cover(I, ofcolor(I, 5)),
      mapply(
          lambda obj: shift(obj, ((height(I) // 2) - centerofmass(obj)[0], 0)) 
              if color(obj) == 5 else obj, 
          objects(I, False, True, True)
      )
  )
 
25.666666666666668, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def cbdffaaigdibeecaicfcccffdjdcifga(I):
  objs = objects(I, False, True, True)
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    new_grid = paint(new_grid, shift(obj, (height(I) // 2 - centerofmass(obj)[0], 0)))
  return new_grid
 
11.666666666666666, tensor(0.0115), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def aeabdbbfijiaehajaiedeideeaabfebj(I):
  five_objs = colorfilter(objects(I, F, T, T), 5)
  other_objs = difference(objects(I, F, T, T), five_objs)
  largest = argmax(other_objs, size)
  I = cover(I, merge(five_objs))
  merged_five = merge(five_objs)
  target = (uppermost(largest), leftmost(largest) + width(largest) // 2 - width(merged_five) // 2)
  return paint(I, shift(merged_five, subtract(target, ulcorner(merged_five))))
 
17.0, tensor(0.0689), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep all other shapes in their original positions. 
:: def fibdfcfjfcadebgdjeaaegafjbddaecb(I):
  five_obj = first(colorfilter(objects(I, True, False, True), 5))
  grid_center = divide(shape(I), 2)
  offset = subtract(grid_center, centerofmass(five_obj))
  shifted_five = shift(five_obj, offset)
  O = paint(canvas(0, shape(I)), shifted_five)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (val, (i, j)) not in shifted_five and val != 0:
        O = paint(O, {(val, (i, j))})
  return O
 
16.0, tensor(0.0689), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. Keep all other shapes in their original positions. 
:: def gdcfdjfajadhefdcahdaiggcebbcfbbj(I):
  five_obj = next(obj for obj in objects(I, True, False, True) if color(obj) == 5)
  new_grid = canvas(0, shape(I))
  five_center = centerofmass(five_obj)
  grid_center = divide(shape(I), 2)
  move_vector = subtract(grid_center, five_center)
  moved_five = shift(five_obj, move_vector)
  new_grid = paint(new_grid, moved_five)
  for i in range(height(I)):
    for j in range(width(I)):
      if (I[i][j], (i, j)) not in moved_five and I[i][j] != 0:
        new_grid = paint(new_grid, {(I[i][j], (i, j))})
  return new_grid
 
25.333333333333332, tensor(0.0115), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def fbacaabecdhbebcgibcbcbibagceefaa(I):
  # 1. Identify '5' objects and their bounding box
  fives = merge(colorfilter(objects(I, F, T, T), 5))
  fives_box = backdrop(fives)

  # 2. Find the largest object
  largest = argmax(objects(cover(I, fives), F, T, T), size)

  # 3. Calculate target bounding box
  target_box = shift(
      fives_box, 
      subtract(
          (uppermost(largest), leftmost(largest) + width(largest) // 2 - width(fives) // 2), 
          ulcorner(fives)
      )
  )

  # 4. Move the '5' objects
  return paint(cover(I, fives), toobject(target_box, replace(I, 0, 5)))
 
11.666666666666666, tensor(0.0115), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def cbjehjhffeehecafajbgececjdddefcb(I):
  # 1. Find largest object and '5' objects
  objs = objects(I, F, T, T)
  largest = argmax(objs, size)
  fives = colorfilter(objs, 5)

  # 2. Calculate target position for combined '5' objects
  target_ul = (uppermost(largest), leftmost(largest) + width(largest) // 2 - width(merge(fives)) // 2)

  # 3. Move the combined '5' objects
  return paint(cover(I, merge(fives)), shift(merge(fives), subtract(target_ul, ulcorner(merge(fives)))))
 
15.333333333333334, tensor(0.0288), Description: Copy the input grid. For each gray shape, move it so that it is as close as possible to the nearest red shape. Keep the original gray and red shapes in their original positions. The output grid should have the original gray and red shapes in their original positions, and the moved gray shapes as close as possible to the red shapes. 
:: def eagahfgdgaffebchaddchdheadabcbdf(I):
  two_objs = objects(I, True, False, True)
  five_objs = objects(I, True, False, True) - two_objs
  moved_fives = set()
  for five_obj in five_objs:
    closest_two_obj = argmin(two_objs, lambda two_obj: manhattan(five_obj, two_obj))
    move_vector = gravitate(five_obj, closest_two_obj)
    moved_fives.add(shift(five_obj, move_vector))
  O = paint(canvas(0, shape(I)), merge({recolor(5, obj) for obj in moved_fives} | {recolor(2, obj) for obj in two_objs}))
  return O
 
16.333333333333332, tensor(0.0049), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. Keep the red shape in its original position. 
:: def dcgabajbhcfeehbibhigeaaecgbegfha(I):
  two_obj = extract(objects(I, True, False, True), lambda obj: 2 in palette(obj))
  five_indices = ofcolor(I, 5)
  target_j = leftmost(two_obj) + (width(two_obj) - width(five_indices)) // 2
  target_i = uppermost(two_obj) - height(five_indices) - 1
  moved_fives = frozenset({(5, (target_i, j + target_j)) for i, j in five_indices})
  O = paint(canvas(0, shape(I)), moved_fives | recolor(2, two_obj))
  return O
 
17.666666666666668, tensor(0.0202), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the same location as the center of mass of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same location as the center of mass of the red shape. Keep the red shape in its original position. 
:: def ggjajcciifejeaffijdeecaijcajaceg(I):
  two_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  five_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 5)
  center_two = centerofmass(two_obj)
  center_five = centerofmass(five_obj)
  move_vector = subtract(center_two, center_five)
  moved_five = shift(five_obj, move_vector)
  O = paint(canvas(0, shape(I)), moved_five | two_obj)
  return O 
 
15.333333333333334, tensor(0.0041), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. 
:: def hbafeddefgbeebhajahcadbcfajbbbeb(I):
  two_obj = extract(objects(I, True, False, True), lambda obj: 2 in palette(obj))
  five_obj = extract(objects(I, True, False, True), lambda obj: 5 in palette(obj))
  target_i = uppermost(two_obj) - height(five_obj) - 1
  target_j = leftmost(two_obj) + (width(two_obj) - width(five_obj)) // 2
  moved_five = shift(five_obj, (target_i - uppermost(five_obj), target_j - leftmost(five_obj)))
  O = paint(fill(I, 0, toindices(five_obj)), moved_five)
  return O
 
11.0, tensor(0.0049), Description: Copy the input grid. Then, move the gray shape so that its top left corner is one row above the top row of the red shape and in the same column as the center column of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape one row above the red shape and in the same column as the center column of the red shape. Keep the red shape in its original position. 
:: def ceabbjbhbceceegfbdgddegebeeaafcb(I):
  twos = ofcolor(I, 2)
  fives = ofcolor(I, 5)
  min_i_two, min_j_two = ulcorner(twos)
  max_i_two, max_j_two = lrcorner(twos)
  target_i = min_i_two - height(fives) - 1
  target_j = min_j_two + (max_j_two - min_j_two - width(fives)) // 2
  moved_fives = frozenset({(5, (target_i + i - min_i_two, target_j + j - min_j_two)) for i, j in fives})
  O = paint(canvas(0, shape(I)), moved_fives | recolor(2, twos))
  return O
 
3171.6666666666665, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def hbcgacbidiaaeaggbbaifgjaadeedidd(grid):
  return tuple(
    tuple(
        next(
          (grid[i2][j] 
          for obj in objects(grid, False, True, True)
          if j in range(leftmost(obj), rightmost(obj) + 1) and i == i2 + height(grid) // 2 - uppermost(obj) - height(obj) // 2), 
          mostcolor(grid)
        )
        for j in range(width(grid))
      )
      for i, row in enumerate(grid) for i2 in range(height(grid))
    )
 
10.0, tensor(0.0115), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def fjibfbeafbcjeabbbccdjgbccebahbdj(I):
  # 1.  Extract '5' objects and other objects
  fives = colorfilter(objects(I, F, T, T), 5)
  others = difference(objects(I, F, T, T), fives)

  # 2. Find the largest object and calculate target location
  largest = argmax(others, size)
  target = (uppermost(largest) - height(merge(fives)), leftmost(largest) + width(largest) // 2 - width(merge(fives)) // 2)

  # 3.  Move the '5' objects as one merged object
  return paint(cover(I, merge(fives)), shift(merge(fives), subtract(target, ulcorner(merge(fives)))))
 
11.0, tensor(0.0095), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is in the same row as the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def dgeeffgbcegaeggdacejehdbfadgfhbe(I):
  # 1.  Find largest object and '5' objects
  largest = argmax(difference(objects(I, F, T, T), colorfilter(objects(I, F, T, T), 5)), size)
  fives = colorfilter(objects(I, F, T, T), 5)

  # 2.  Create a function to move objects to the target
  def move_to_target(obj):
    target_i = uppermost(largest) - height(obj)
    target_j = leftmost(largest) + width(largest) // 2 - width(obj) // 2
    return shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj)))

  # 3. Move each '5' object and merge them 
  moved_fives = merge(apply(move_to_target, fives))

  # 4. Paint the moved '5' objects onto the original grid
  return paint(cover(I, merge(fives)), moved_fives)
 
24.0, tensor(0.0235), Description: Copy the input grid. Then, move the gray shape so that its center of mass is in the center of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the center of the grid. 
:: def ciefebddideaefhgidbcabjdhccacegg(I):
  five_obj = first(colorfilter(objects(I, True, False, True), 5))
  grid_center = divide(shape(I), 2)
  offset = subtract(grid_center, centerofmass(five_obj))
  O = paint(canvas(0, shape(I)), shift(five_obj, offset))
  return O
 
30.0, tensor(0.0043), Description: Copy the input grid. Then, move the gray shape so that its top left corner is in the same column as the center column of the grid and in the same row as the bottom row of the grid. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same column as the center column of the grid and in the same row as the bottom row of the grid. 
:: def ecfccbaggaaaefdgbdibebcaajeedccd(I):
  five_obj = toobject(ofcolor(I, 5), I)
  center_i = (len(I) - height(five_obj)) // 2
  center_j = (len(I[0]) - width(five_obj)) // 2
  O = paint(canvas(0, shape(I)), shift(five_obj, (center_i - uppermost(five_obj), center_j - leftmost(five_obj))))
  return O
 
15.333333333333334, tensor(0.0077), Description: Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the red shape. 
:: def dbhccjejehaiejcijcebdcefeeagjjja(I):
  obj_2 = extract(objects(I, T, F, T), lambda obj: color(obj) == 2) # Find the '2' object
  obj_5 = extract(objects(I, T, F, T), lambda obj: color(obj) == 5) # Find the '5' object
  target_row = uppermost(obj_2)  # Get the row index of the top of the '2' object
  offset = (target_row - uppermost(obj_5), 0)  # Calculate vertical offset, no horizontal shift
  moved_obj = shift(obj_5, offset) # Move the '5' object
  O = paint(cover(I, obj_5), moved_obj) # Paint the moved object onto a cleared grid
  return O 
 
18.0, tensor(0.0071), Description: Copy the input grid. Then, move the gray shape vertically so that its top row is in the same row as the top row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the red shape. 
:: def hahdeebjddacehchacfahdgebhjhbdjd(I):
  five_obj = extract(objects(I, True, False, True), lambda o: color(o) == 5)
  two_obj = extract(objects(I, True, False, True), lambda o: color(o) == 2)
  v_shift = uppermost(two_obj) - uppermost(five_obj)
  O = paint(I, shift(five_obj, (v_shift, 0)))
  return O
 
14.666666666666666, tensor(0.0076), Description: Copy the input grid. Then, move the gray shape so that its top row is in the same row as the top row of the red shape. Keep the original gray shape in its original position. The output grid should have the original gray shape in its original position, and the moved gray shape in the same row as the top row of the red shape. 
:: def gaffbhibddghehcajdfgjeaaehcbfdfd(I):
  fives = ofcolor(I, 5) 
  min_row_2 = minimum(apply(lambda idx: idx[0], ofcolor(I, 2)))
  new_fives = frozenset((5, (min_row_2 - height(fives) + i, j)) for i, j in fives)
  O = paint(cover(I, fives), new_fives)
  return O
 
39.333333333333336, tensor(0.0062), Description: Copy the input grid. Then, for each colored shape in each row, move it vertically so that its center is in the same row as the center row of the grid. Keep the original colored shapes in their original positions. The output grid should have the original colored shapes in their original positions, and the moved colored shapes centered vertically in each row. 
:: def fiadefafcggaecbdihgbeadfbiiciahc(grid):
  objs = objects(grid, False, True, True)
  return tuple(
    tuple(
      index(
        grid,
        (i - height(grid) // 2 + uppermost(extract(objs, lambda obj: j in set(k for _, (k, _) in obj))) + height(extract(objs, lambda obj: j in set(k for _, (k, _) in obj))) // 2, j)
      ) if any(j in set(k for _, (k, _) in obj) for obj in objs) else mostcolor(grid)
      for j in range(width(grid))
    ) for i in range(height(grid))
  )
 
11.0, tensor(0.0079), Description: Copy the input grid. Then, for each gray shape, move it upwards so that its top row is one row above the top row of the largest colored shape (excluding gray shapes). Also, move the gray shape horizontally so that its center is in the same column as the center column of the largest colored shape (excluding gray shapes). Keep the original gray shape in its original position. The output grid should have the original gray shapes in their original positions, and the moved gray shapes in their new positions. 
:: def iaafbeeacfcbeadejedafdhfjebfaadc(I):
  # 1. Find the largest non-5 object
  largest_non_five = argmax(
      difference(objects(I, F, T, T), colorfilter(objects(I, F, T, T), 5)), 
      size
  )

  # 2. Calculate the target location for the center of '5' objects
  target_row = uppermost(largest_non_five) - 1
  target_col = leftmost(largest_non_five) + width(largest_non_five) // 2

  # 3. Identify and move '5' objects
  five_objects = colorfilter(objects(I, F, T, T), 5)
  moved_fives = frozenset(
      shift(obj, (target_row - uppermost(obj), target_col - leftmost(obj) - width(obj) // 2)) 
      for obj in five_objects
  )

  # 4. Paint the moved '5' objects onto the original grid
  return paint(cover(I, merge(five_objects)), merge(moved_fives))
 
69.0, tensor(1.7484), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. 
:: def ejdaiecbdajbeehgiefebcdbcjgfcfee(I):
  O = canvas(0, (15, 15))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      O = fill(O, 5 if val == 8 else val, backdrop(((i*3, j*3), (i*3+2, j*3+2))))
  return O
 
14164.666666666666, tensor(1.6523), Description: Copy the input grid. Then, replace the most common color with a space. Then, upscale the grid by a factor of 3. 
:: def ebffcfebaachecfcjbffahhfcbbffhcg(I):
    return upscale(replace(I, mostcommon(I), ' '), THREE)
 
42.333333333333336, tensor(1.9378), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Then, move the entire grid three spaces to the right and three spaces down. 
:: def dbficafedafieidebbjjgagejhbgbecc(I):
  upscaled_replaced = tuple(
      tuple(5 if v == 8 else v for v in upscale((row,), 3)[0])
      for row in I
  )
  shifted = shift(asobject(upscaled_replaced), (3, 3))
  O = paint(canvas(0, (15, 15)), shifted)
  return O
 
52.0, tensor(1.7484), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. 
:: def dfdbjdehbbgeecafbgeddidheffdjfid(I):
  O = canvas(0, (15, 15))
  for i in range(len(I)):
    for j in range(len(I[0])):
      value = 5 if I[i][j] == 8 else I[i][j]
      O = fill(O, value, backdrop(((i*3+3, j*3+3), (i*3+5, j*3+5))))
  return O
 
27.0, tensor(1.7484), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. 
:: def ffhdhgaffgaeedggjaccfffffdjbcebc(I):
  shifted_indices = frozenset((i * 3 + 3, j * 3 + 3) for j in range(len(I[0])) for i in range(len(I)))
  replace_function = lambda x, y: 5 if I[x][y] == 8 else I[x][y]
  filled_canvas = prapply(lambda x, y: fill(canvas(0, (15, 15)), replace_function(x, y), backdrop(((x*3+3, y*3+3), (x*3+5, y*3+5)))), range(len(I)), range(len(I[0])))
  O = list(filled_canvas)[0] 
  return O
 
39.0, tensor(0.6813), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color.  Red squares should remain red. 
:: def ccdhfieifjaeecddaihgfbhadfjaabdi(I):
  # Handle non-numeric grids by creating a blank canvas
  if not isinstance(I[0][0], int): 
    return canvas(0, (15, 15))
  
  O = canvas(0, (15, 15)) # Initialize output grid with zeros
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 2: # Keep '2' values as '2'
        O = fill(O, 2, toindices(shift(upscale(initset((0, (0, 0))), 3), (3 * i, 3 * j))))
      elif I[i][j] == 8: # Change '8' values to '5'
        O = fill(O, 5, toindices(shift(upscale(initset((0, (0, 0))), 3), (3 * i, 3 * j))))
  return O
 
81.66666666666667, tensor(0.6813), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. 
:: def bjcafifafecdegghaedefchahiebgccb(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  O = upscale(replace(replace(I, 2, 1), 8, 2), 3) # Upscale after replacing values
  return replace(replace(O, 1, 2), 2, 5) # Replace back to original values
 
82.66666666666667, tensor(0.6813), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. 
:: def bbcgefefbbabeddhagebgebadajbdbgd(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  return tuple(
    tuple(
      v for k in range(3) for v in repeat(2 if I[i][j] == 2 else (5 if I[i][j] == 8 else 0), 3)
    ) for i in range(height(I)) for j in range(width(I))
  )
 
80.33333333333333, tensor(0.6813), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. 
:: def gedfjcfcceajeddajcfcdfdhbaagfieb(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  O = canvas(0, shape(upscale(I, 3))) # Create canvas with upscaled dimensions
  for obj in objects(I, T, T, F):
    if color(obj) == 2:
      O = paint(O, shift(upscale(recolor(2, normalize(obj)), 3), multiply(3, ulcorner(obj))))
    elif color(obj) == 8:
      O = paint(O, shift(upscale(recolor(5, normalize(obj)), 3), multiply(3, ulcorner(obj))))
  return O
 
37.0, tensor(1.3121), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and four spaces down. Move the gray squares six spaces to the right and five spaces down. 
:: def aedihdjafdbbeccdijijabaegjifcfda(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  O = canvas(0, (15, 15))
  for obj in objects(I, T, T, F):
    if color(obj) == 2:
      O = paint(O, shift(upscale(obj, 3), (3, 4)))
    elif color(obj) == 8:
      O = paint(O, shift(upscale(recolor(5, obj), 3), (6, 5)))
  return O
 
35.333333333333336, tensor(1.3121), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and four spaces down. Move the gray squares six spaces to the right and five spaces down. 
:: def gijgdjhaddfbeahcbadceffjabdbccei(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  O = canvas(0, (15, 15))
  obj2 = extract(objects(I, T, T, F), lambda obj: color(obj) == 2)
  obj8 = extract(objects(I, T, T, F), lambda obj: color(obj) == 8)
  O = paint(O, shift(upscale(obj2, 3), (3, 4)))
  O = paint(O, shift(upscale(recolor(5, obj8), 3), (6, 5)))
  return O
 
34.0, tensor(1.3121), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and four spaces down. Move the gray squares six spaces to the right and five spaces down. 
:: def ghbajhebeehbeeaejhgchdfcceaagafc(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  obj2 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 2))
  obj8 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 8))
  return paint(
      paint(
          canvas(0, (15, 15)),
          shift(upscale(obj2, 3), add((3, 4), multiply(3, ulcorner(obj2))))
      ),
      shift(upscale(recolor(5, obj8), 3), add((6, 5), multiply(3, ulcorner(obj8))))
  )
 
54.0, tensor(1.7484), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. 
:: def jaafebeejecjebejihcifgfdceceifid(I):
    O = canvas(0, (15, 15))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            for k in range(3):
                for l in range(3):
                    if 0 <= i * 3 + k + 9 < 15 and 0 <= j * 3 + l < 15:
                        O = tuple(O[:i * 3 + k + 9] + (tuple(O[i * 3 + k + 9][:j * 3 + l] + (5 if val == 8 else val,) + O[i * 3 + k + 9][j * 3 + l + 1:]),) + O[i * 3 + k + 9 + 1:])
    return O
 
28.0, tensor(1.3122), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and six spaces down. Move the gray squares nine spaces to the right and two spaces down. 
:: def edecdeddebbbebbgicaciaebcicfddbe(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  obj2 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 2))
  obj8 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 8))
  return paint(
      paint(
          canvas(0, (15, 15)),
          shift(upscale(obj2, 2), (3, 6))  
      ),
      shift(upscale(recolor(5, obj8), 3), (9, 2))  
  )
 
64.66666666666667, tensor(1.3134), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and two spaces down. Move the gray squares four spaces to the right and one space down. 
:: def jhddfbdddejcedfhaieeeafdfbdidbfc(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  obj2 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 2))
  obj8 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 8))
  return paint(
      paint(
          canvas(0, shape(upscale(I, 3))),  
          shift(upscale(obj2, 3), multiply((3, 2), shape(obj2))) 
      ),
      shift(upscale(recolor(5, obj8), 2), multiply((4, 1), shape(obj8)))  
  )
 
34.333333333333336, tensor(0.4394), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Then, remove all the squares in the bottom 6 rows. 
:: def ecdjjecibacdegdjafhgchafejhchhaa(I):
  O = canvas(0, (15, 15))
  for i in range(len(I)):
    for j in range(len(I[0])):
      O = fill(O, 5 if I[i][j] == 8 else I[i][j], product(interval(i*3, i*3+3, 1), interval(j*3, j*3+3, 1)))
  O = tuple(tuple(O[i][j] if i >= 9 else 0 for j in range(15)) for i in range(15))
  return O
 
217.33333333333334, tensor(1.7166), Description: Upscale the input grid by a factor of 3, replacing the least common color with gray. If there are multiple colors in the input, also replace the background color with gray. Then, shift the resulting grid 3 spaces to the right and 3 spaces down. 
:: def debchdccajdeeefiadabfidicggbajjc(I):
  min_color = min(set(v for row in I for v in row)) # Find minimum color
  obj_indices = frozenset((i, j) for i, row in enumerate(I) for j, v in enumerate(row) if v == min_color)
  obj = toobject(obj_indices, I) 
  O = paint(canvas(0, (15, 15)), shift(upscale(obj, 3), (3, 3))) 
  O = branch(len(set(merge(I))) > 1, replace(O, 0, 5), O) 
  return O
 
34.0, tensor(1.3120), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and three spaces down. Move the gray squares six spaces to the right and nine spaces down. 
:: def addaeedcdbddejjbjhdddbbdbbbaajec(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  obj2 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 2))
  obj8 = normalize(extract(objects(I, T, T, F), lambda obj: color(obj) == 8))
  return paint(
      paint(
          canvas(0, (15, 15)),
          shift(upscale(obj2, 3), (3, 3))
      ),
      shift(upscale(recolor(5, obj8), 3), (6, 9))
  )
 
35.333333333333336, tensor(1.3120), Description: Copy the input grid. Then, for each light blue square, replace it with a 3x3 block of gray squares. If the light blue square is on the edge of the grid, then the gray block should only extend as far as the edge of the grid.  If the light blue square is not on the edge of the grid, then the gray block should be a full 3x3 block.  All other squares should remain the same color. Red squares should remain red. Then, move the red squares three spaces to the right and three spaces down. Move the gray squares six spaces to the right and nine spaces down. 
:: def ieaidgheeffeedaaaecdbhehddcfbfee(I):
  if not isinstance(I[0][0], int):
    return canvas(0, (15, 15))
  return paint(
      paint(
          canvas(0, (15, 15)),
          shift(upscale(recolor(2, extract(objects(I, T, T, F), lambda obj: color(obj) == 2)), 3), (3, 3))
      ),
      shift(upscale(recolor(5, extract(objects(I, T, T, F), lambda obj: color(obj) == 8)), 3), (6, 9))
  )
 
