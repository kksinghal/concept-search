12.0, tensor(1.9823), Description: Find the first object in the input that is colored with color 2. Move that object one space to the left. Change the color of the moved object to color 3. Paint the moved and recolored object onto a blank canvas the same size as the input. 
:: def gbcffeaeafbcehjgicafaedffchbdfbd(I):
  target_color = 2
  target_object = first(colorfilter(objects(I, True, False, False), target_color))
  new_location = subtract(ulcorner(target_object), (1, 0))
  shifted_object = shift(target_object, subtract(new_location, ulcorner(target_object)))
  recolored_object = recolor(3, shifted_object)
  O = paint(canvas(0, shape(I)), recolored_object)
  return O
 
15.333333333333334, tensor(1.9822), Description: Find the first object in the input that is colored with color 2. Move that object one space to the left and one space up. Change the color of the moved object to color 3. Paint the moved and recolored object onto a blank canvas the same size as the input. 
:: def bgacghgfbjfeecdcbbeibbaefjiaegjf(I):
  obj = first(colorfilter(partition(I), 2))
  new_ulcorner = subtract(ulcorner(obj), (1, -1))
  O = paint(canvas(0, shape(I)), recolor(3, shift(obj, subtract(new_ulcorner, ulcorner(obj)))))
  return O
 
11.333333333333334, tensor(1.9822), Description: Find the first object in the input that is colored with color 2. Move that object one space to the left and one space up. Change the color of the moved object to color 3. Paint the moved and recolored object onto a blank canvas the same size as the input. 
:: def dafdheifeafieehaabdcfeibcjcejief(I):
  obj = first(colorfilter(objects(I, True, False, False), 2))
  offset = (-1, 1)
  moved_obj = shift(obj, offset)
  O = paint(canvas(0, shape(I)), recolor(3, moved_obj))
  return O
 
20.0, tensor(0.0654), Description: For each connected object in the input, draw a vertical line of color 3 in the center column of the object. The original object should be removed. 
:: def fcdcahcdbhjiedadiecfbdcadhgcbbhg(I):
  objs = objects(I, T, F, T)  # Extract connected objects
  for obj in objs:
    min_j = leftmost(obj) 
    max_j = rightmost(obj)
    center_j = (min_j + max_j) // 2 # Find central column
    I = cover(I, obj) # Remove the original object
    I = fill(I, 3, frozenset((i, center_j) for i in range(len(I)))) # Draw the vertical line
  O = I
  return O
 
34.0, tensor(0.0654), Description: For each connected object in the input, draw a vertical line of color 3 in the center column of the object. The original object should be removed. 
:: def afcbdfdhehajefgaiefahdfaccicjcac(I):
  objs = objects(I, T, F, T)
  vlines = frozenset()
  for obj in objs:
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    vlines = vlines | frozenset((i, center_j) for i in range(len(I)))  # Accumulate vertical lines
  O = fill(I, 3, vlines) # Fill all vertical lines at once
  return O
 
140.33333333333334, tensor(0.8764), Description: Find the least common color in the input grid. Create a blank canvas the same size as the input grid and fill it with the least common color. Then, find the center of mass of each object in the input grid and paint a color 3 pixel at that location on the canvas. Return the canvas. 
:: def fgcbaicahfbheebaafadjbeidacfeade(I):
  x1 = leastcolor(I)
  x2 = objects(I, univalued=False, diagonal=False, without_bg=True)
  x3 = lambda x: tuple(map(lambda y: sum(y) // len(x), zip(*toindices(x))))  # Define centerofmass function
  x4 = apply(x3, x2)
  O = fill(canvas(x1, shape(I)), 3, x4)
  return O 
 
140.33333333333334, tensor(0.8764), Description: Find the least common color in the input grid. Create a blank canvas the same size as the input grid and fill it with the least common color. Then, find the center of mass of each object in the input grid and paint a color 3 pixel at that location on the canvas. Return the canvas. 
:: def bcgafgeccajeeiecicedaaccffhgcadd(I):
    background = leastcolor(I)
    object_list = objects(I, univalued=False, diagonal=False, without_bg=True)
    center_points = frozenset((
        (uppermost(obj) + height(obj) // 2, leftmost(obj) + width(obj) // 2) 
        for obj in object_list
    ))
    return paint(canvas(background, shape(I)), recolor(3, center_points)) 
 
21.0, tensor(0.0654), Description: For each connected object in the input, draw a horizontal line of color 3 through the vertical center of the object. The original object should be removed. 
:: def jgbedjaadfieejdbafcegehdedhafajd(I):
    objs = objects(I, T, F, T)  # Extract objects
    lines = []
    for obj in objs:
        center_i = (uppermost(obj) + lowermost(obj)) // 2  # Vertical center
        left_j = leftmost(obj)  # Leftmost column
        right_j = rightmost(obj)  # Rightmost column
        line = frozenset({(center_i, j) for j in range(left_j, right_j + 1)})  # Horizontal line indices
        lines.append(line)
    O = fill(I, 3, merge(lines))  # Draw lines on the grid
    return O
 
8.666666666666666, tensor(0.0110), Description: Create a horizontal line of color 3, two rows from the bottom of the grid, with a length equal to the width of the first object in the input grid. The rest of the grid should be filled with color 0. 
:: def efdafgfddagdechbieccdfjddddcafif(I):
  obj_width = width(first(objects(I, F, F, T))) # Get width of the first object
  O = fill(canvas(ZERO, shape(I)), THREE,  # Fill with '3's 
           {(height(I) - 2, j) for j in range(obj_width)}) # at indices forming the line
  return O 
 
8.666666666666666, tensor(0.0110), Description: Create a horizontal line of color 3, two rows from the bottom of the grid, with a length equal to the width of the first object in the input grid. The rest of the grid should be filled with color 0. 
:: def cdacecadedhfeddjjgcfjibdjddgbfji(I):
  line_y = height(I) - 2 # Y-coordinate of the line
  obj_x = leftmost(first(objects(I, F, F, T))) # Get leftmost x-coordinate of the first object
  obj_width = width(first(objects(I, F, F, T))) # Get width of the first object
  O = canvas(ZERO, shape(I)) # Create empty grid
  for j in range(obj_x, obj_x + obj_width): # Iterate through line's x-coordinates
    O = paint(O, {(THREE, (line_y, j))}) # Paint '3' at each coordinate on the line
  return O
 
12.0, tensor(1.9911), Description: Find the first color in the input grid that is greater than 0. Find the first object in the input grid that has that color. Move that object two spaces to the right. Change the color of the moved object to color 3. Paint the moved and recolored object onto a blank canvas the same size as the input. 
:: def ffabaicdhgchedihbfaehacdcceddadc(I):
  color_to_move = next(c for c in sorted(palette(I)) if c > 0)
  original_indices = ofcolor(I, color_to_move)
  new_width = 3 if width(original_indices) > 1 else 1
  new_height = 3
  start_pos = add(lrcorner(original_indices), (2, 0))
  new_indices = {(i, j) for i in range(start_pos[0], start_pos[0] + new_height) 
                  for j in range(start_pos[1], start_pos[1] + new_width)}
  O = fill(canvas(0, shape(I)), color_to_move, new_indices)
  return O
 
23.666666666666668, tensor(0.0653), Description: For each connected object in the input, draw a horizontal line of color 3 in the second row of the object. The original object should be removed. 
:: def aefibjcccfeaecaijjafbdcffhfffaed(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = fill(O, 3, frozenset(((2, j) for j in range(leftmost(obj), rightmost(obj) + 1))))
  return O
 
14.333333333333334, tensor(1.9820), Description: Find the smallest color in the input grid that is greater than 0. Find the first object in the input grid that has that color. If the object is wider than 1, create a 3x3 square with that color, otherwise create a 3x1 rectangle. Move the new shape two spaces to the right from the original object's position. Paint the moved shape onto a blank canvas the same size as the input. 
:: def ibcedbadgjcaejddbaeidijbdfabfhah(I):
  target_color = min(sfilter(palette(I), lambda x: x > 0))
  target_object = first(colorfilter(objects(I, T, F, F), target_color))
  new_obj_shape = (3, 3) if width(target_object) > 1 else (3, 1)
  new_obj_pos = add(lrcorner(target_object), (2, 0))
  new_obj_indices = shift(asindices(canvas(0, new_obj_shape)), new_obj_pos)
  O = fill(canvas(0, shape(I)), target_color, new_obj_indices)
  return O
 
8.666666666666666, tensor(1.9808), Description: Find the first object in the input that is not black. Create a horizontal line of color 3 with a length equal to the width of that object. If the object is in the top half of the grid, place the line two rows from the bottom. Otherwise, place the line three rows from the bottom. The line should be aligned with the left edge of the object. The rest of the grid should be filled with color 0. 
:: def fgbhfecdjdidehedigbijgbdjchdegei(I):
  obj = extract(objects(I, F, F, T), lambda o: color(o) != ZERO)
  line_width = width(obj)
  line = {(THREE, (0, j)) for j in range(line_width)}
  offset = (height(I) - 2) if uppermost(obj) < height(I) // 2 else (height(I) - 3)
  shifted_line = shift(line, (0, leftmost(obj)))
  O = paint(canvas(ZERO, shape(I)), shift(shifted_line, (offset, 0)))
  return O
 
20.333333333333332, tensor(0.0042), Description: For each object in the input grid, draw a vertical line of color 3 through the center column of the object. The original object should be removed. 
:: def aechfaidiccceefabdagbbhebbabbbda(I):
  bg = leastcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  modified_grid = I
  for obj in objs:
    left, right = leftmost(obj), rightmost(obj)
    center_col = (left + right) // 2
    for i in range(uppermost(obj), lowermost(obj) + 1):
      modified_grid = fill(modified_grid, 3, {(i, center_col)})
  return modified_grid
 
138.66666666666666, tensor(0.0042), Description: For each object in the input grid, draw a vertical line of color 3 through the center column of the object. The original object should be removed. 
:: def bgdaebdaffjiehgdiceebdcfaifhfaag(I):
  bg = leastcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  return paint(canvas(bg, shape(I)), merge(apply(lambda obj: recolor(3, frozenset(((i, leftmost(obj) + width(obj) // 2)) for i in range(uppermost(obj), lowermost(obj) + 1))), objs)))
 
138.66666666666666, tensor(0.0042), Description: For each object in the input grid, draw a vertical line of color 3 through the center column of the object. The original object should be removed. 
:: def bbgbcaidaihbegbcjbdddidaiheaebfe(I):
  bg = leastcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  center_indices = set()
  for obj in objs:
    center_col = (leftmost(obj) + rightmost(obj)) // 2
    for row in range(uppermost(obj), lowermost(obj) + 1):
      center_indices.add((row, center_col))
  return fill(canvas(bg, shape(I)), 3, frozenset(center_indices))
 
22.0, tensor(0.0632), Description: For each connected object in the input, draw a horizontal line of color 3 two rows above the bottom of the object. The original object should be removed. 
:: def fbedaaeiecjeejeiaafadeedfagdebcd(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    row_index = lowermost(obj) - 2
    O = fill(O, 3, frozenset(((row_index, j) for j in range(leftmost(obj), rightmost(obj) + 1))))
  return O
 
10.0, tensor(1.9816), Description: Create a horizontal line of color 3, two rows from the bottom of the grid if the largest object is in the top half of the grid, otherwise place the line three rows from the bottom. The line should be aligned with the left edge of the object. The rest of the grid should be filled with color 0. 
:: def cjbeeeaeaehbecacibheibfjfehcbedi(I):
  obj = argmax(objects(I, F, F, T), size)
  line_width = width(obj)
  offset = 2 if uppermost(obj) < height(I) // 2 else 3
  line = {(height(I) - offset, j) for j in range(line_width)}
  O = fill(canvas(ZERO, shape(I)), THREE, line)
  return O
 
8.666666666666666, tensor(1.9816), Description: Create a horizontal line of color 3, two rows from the bottom of the grid if the largest object is in the top half of the grid, otherwise place the line three rows from the bottom. The line should be aligned with the left edge of the object. The rest of the grid should be filled with color 0. 
:: def dcjaaeajegcdeijeieabdcadbijcgdbb(I):
  obj = argmax(objects(I, F, F, T), size)
  offset = (height(I) - 2, leftmost(obj)) if uppermost(obj) < height(I) // 2 else (height(I) - 3, leftmost(obj))
  line = {(offset[0], offset[1] + j) for j in range(width(obj))}
  O = fill(canvas(ZERO, shape(I)), THREE, line)
  return O
 
23.333333333333332, tensor(0.0627), Description: For each connected object in the input, draw a horizontal line of color 3 three rows above the top of the object. The original object should be removed. 
:: def bdfbedfebfecehdfbbcbheahgcgfbicb(I):
  objs = objects(I, T, F, T)
  return fill(I, 3, merge(apply(lambda obj: frozenset(((uppermost(obj) + 3, j) for j in range(leftmost(obj), rightmost(obj) + 1))), objs)))
 
141.66666666666666, tensor(0.0040), Description: For each object in the input grid, draw a vertical line of color 3 through the center column of the object. The original object should be removed. The background color should remain the same. 
:: def ffdgcejaajdcegahjceffhicddbjdiha(I):
  bg = leastcolor(I)
  return paint(
      canvas(bg, shape(I)),
      merge(apply(
          lambda obj: toobject(
              connect(
                  (uppermost(obj), leftmost(obj) + width(obj) // 2), 
                  (lowermost(obj), leftmost(obj) + width(obj) // 2)
              ),
              replace(I, bg, 3)
          ),
          objects(I, univalued=False, diagonal=False, without_bg=True)
      ))
  )
 
28.0, tensor(1.9654), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3 across the entire row, starting three rows above the current row. The original color 2 cells should remain in the output. 
:: def adfadcicdfajefbajfbheeaidhdfbceh(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 2:
                O = fill(O, 3, frozenset(((i - 3, k) for k in range(len(I[0])) if I[i][k] == 2)))
    return O
 
30.666666666666668, tensor(1.9654), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3 across the entire row, starting three rows above the current row. The original color 2 cells should remain in the output. 
:: def aafafaeccecgedffacdabjdfegichica(I):
    lines = []
    for i, row in enumerate(I):
        if 2 in row:
            start_j = row.index(2)
            end_j = len(row) - 1 - row[::-1].index(2)
            lines.append(frozenset(((i - 3, j) for j in range(start_j, end_j + 1))))
    return fill(I, 3, merge(lines))
 
11.666666666666666, tensor(1.9818), Description: Find the smallest color in the input grid that is greater than 0. Find the first object in the input grid that has that color. If the object is wider than 1, create a 3x3 square with that color, otherwise create a 3x1 rectangle. Move the new shape two spaces to the right and two spaces down from the original object's position. Paint the moved shape onto a blank canvas the same size as the input. 
:: def ibbgacceafafecifideefahaeedcadad(I):
    target_color = next(iter(sorted(palette(I) - {0}))) 
    target_obj = extract(objects(I, univalued=True, diagonal=False, without_bg=True), lambda obj: color(obj) == target_color)
    new_width = 3 if width(target_obj) > 1 else 1
    new_height = 3
    offset_i = lowermost(target_obj) + 2
    offset_j = rightmost(target_obj) + 2 
    new_obj = {(target_color, (i + offset_i, j + offset_j)) for i in range(new_height) for j in range(new_width)}
    O = paint(canvas(0, shape(I)), new_obj)
    return O
 
25.333333333333332, tensor(0.0645), Description: Draw a horizontal line of color 3, three rows above the top of the topmost connected object in the input grid. The original object should be removed. 
:: def faadifbgjdffeccaafcdgddcfdehdifg(I):
    objs = objects(I, T, F, T)  # Extract non-background objects
    top_obj = argmax(objs, uppermost)  # Find the topmost object
    line = frozenset(((uppermost(top_obj) - 3, j) for j in range(leftmost(top_obj), rightmost(top_obj) + 1)))  # Generate line indices
    return fill(I, 3, line)  # Draw the line on the grid 
 
26.333333333333332, tensor(1.9921), Description: Find the first object in the input that is not black. Move that object three spaces to the left. Change the color of the moved object to color 3. Paint the moved and recolored object onto a blank canvas the same size as the input. 
:: def cijeidfffeeieichahihcecffacafafa(I):
  return paint(I, recolor(3, shift(extract(objects(I, T, F, T), lambda obj: color(obj) != 0), (-3, 0)))) 
 
10.0, tensor(1.9818), Description: Find the smallest color in the input grid that is greater than 0. Find the first object in the input grid that has that color. If the object is wider than 1, create a 3x3 square with that color, otherwise create a 3x1 rectangle. Move the new shape two spaces to the right and two spaces down from the original object's position. Paint the moved shape onto a blank canvas the same size as the input. 
:: def habahhefggecedegjbbhcahfaidfbcde(I):
  target_color = min(sfilter(palette(I), lambda x: x > 0))
  obj_indices = ofcolor(I, target_color)
  is_multi_column = width(obj_indices) > 1
  new_shape = (3, 3) if is_multi_column else (3, 1)
  offset = (lowermost(obj_indices) + 2, rightmost(obj_indices) + 2)
  new_indices = {(i, j) for i in range(offset[0], offset[0] + new_shape[0]) for j in range(offset[1], offset[1] + new_shape[1])}
  O = fill(canvas(0, shape(I)), target_color, new_indices)
  return O
 
35.666666666666664, tensor(0.0626), Description: Draw a horizontal line of color 3 three rows above the top of the topmost connected object in the input grid. Also draw a horizontal line of color 3 at the bottom of the bottommost connected object in the input grid. The original objects should be removed. 
:: def fgeijaecchaaebdcjcajcdffhibcddie(I):
  objs = objects(I, T, F, T)
  topmost_obj = argmax(objs, lambda obj: uppermost(obj))
  I = fill(I, 3, frozenset((uppermost(topmost_obj) - 3, j) for j in range(len(I[0]))))
  bottommost_obj = argmin(objs, lambda obj: lowermost(obj))
  I = fill(I, 3, frozenset((lowermost(bottommost_obj), j) for j in range(len(I[0]))))
  return I
 
32.0, tensor(0.0626), Description: Draw a horizontal line of color 3 three rows above the top of the topmost connected object in the input grid. Also draw a horizontal line of color 3 at the bottom of the bottommost connected object in the input grid. The original objects should be removed. 
:: def ajgdhaeiheibedjbaccbiejbefebgdcf(I):
  objs = objects(I, T, F, T)
  top_row = min(uppermost(obj) for obj in objs)
  bottom_row = max(lowermost(obj) for obj in objs)
  I = fill(I, 3, frozenset((top_row - 3, j) for j in range(len(I[0]))))
  I = fill(I, 3, frozenset((bottom_row, j) for j in range(len(I[0]))))
  return I
 
42.0, tensor(0.0629), Description: For each connected object in the input, draw a horizontal line of color 3 three rows above the top of the object. Also draw a horizontal line of color 3 at the bottom of the object. The original objects should be removed. 
:: def adecdcdibifgecfjbdjhhebifaecgfaa(I):
  for obj in objects(I, T, F, T):
    I = fill(I, 3, frozenset((uppermost(obj) - 3, j) for j in range(len(I[0]))))
    I = fill(I, 3, frozenset((lowermost(obj), j) for j in range(len(I[0]))))
  return I
 
23.0, tensor(0.4510), Description: For each object in the input grid, move the center of the object one row up and paint a color 3 pixel at the new location. The original object should remain in the output. 
:: def ceaffciccegbeffiadgacdgbbecbbcaj(I):
    objs = objects(I, T, T, T)  # Identify all non-background objects
    centers = frozenset(centerofmass(obj) for obj in objs) # Find the center of each object
    shifted_centers = frozenset((i-1, j) for i, j in centers)  # Shift each center one row up
    O = fill(I, 3, shifted_centers)  # Fill the shifted centers with color '3'
    return O
 
6.333333333333333, tensor(1.6700), Description: For each object in the input grid, replace the object with color 0 (black). Then, if the center of mass of the object is not in the top row, paint a color 3 pixel one row above the center of mass. The original background color should remain the same. 
:: def bfhcdacgeccaegfdibbdchhedeefcadd(I):
  objs = objects(I, T, T, T) # Find all objects
  O = I 
  for obj in objs:
    center_i, center_j = centerofmass(obj) # Find center of mass
    O = fill(O, 0, toindices(obj)) # Replace object with 0
    if center_i > 0:
      O = fill(O, 3, {(center_i - 1, center_j)}) # Fill one row above with 3
  return O
 
7.666666666666667, tensor(0.2081), Description: For each object in the input grid, if the object is not in the top row, paint a color 3 pixel one row above the horizontal center of the object. The original object should remain in the output. The background color should remain the same. 
:: def caadecabgjdfeajbjfceddibbdbgefcb(I):
  O = canvas(0, shape(I)) # Create an empty canvas
  for obj in objects(I, T, T, T):
    uppermost_i = uppermost(obj) # Find the uppermost row of the object
    center_j = leftmost(obj) + width(obj) // 2  # Calculate the horizontal center
    if uppermost_i > 0: 
      O = fill(O, 3, {(uppermost_i - 1, center_j)}) # Fill with '3' one row above the center
  return O
 
114.0, tensor(0.3252), Description: Shift all cells in the input grid one row up. Create a blank canvas the same size as the input grid. Paint the intersection of the shifted grid and the original grid with color 3. Return the canvas. 
:: def ifbgedaaffadeaafbdibeejddhbdcfbe(I):
  shifted = shift(asobject(I), (-1, 0)) # Shift all cells one row up
  O = canvas(0, shape(I))  # Create an empty canvas
  return paint(O, recolor(3, intersection(shifted, asobject(I)))) # Paint intersection with color '3' 
 
23.333333333333332, tensor(1.9836), Description: For each connected object in the input, draw a horizontal line of color 3 connecting the upper left and upper right corners of the object. The original object should be removed. 
:: def cbaeghgffbccebabjeadhbjacjfhcafd(I):
  obj = first(objects(I, T, F, T))  
  upper_left = ulcorner(obj)
  upper_right = urcorner(obj)
  line = connect(upper_left, upper_right)
  O = fill(I, THREE, line)
  return O
 
26.666666666666668, tensor(1.9837), Description: Draw a horizontal line of color 3 at the topmost row of the input grid, starting from the leftmost column of the first non-black object and ending at the rightmost column of that object. The original object should be removed. 
:: def ebhbaheaifdbedggifecbbjcaefhjgcf(I):
  obj = asobject(I)
  obj = sfilter(obj, lambda cell: cell[0] != ZERO)
  upper_row = minimum(frozenset(i for _, (i, _) in obj))
  left_col = minimum(frozenset(j for _, (_, j) in obj))
  right_col = maximum(frozenset(j for _, (_, j) in obj))
  line = frozenset((upper_row, j) for j in range(left_col, right_col + 1))
  O = fill(I, THREE, line)
  return O
 
23.333333333333332, tensor(1.9659), Description: Draw a vertical line of color 3 starting from the upper-left corner of the first non-background object and extending downwards for a length equal to half the object's height plus half its width. The original object should be removed. 
:: def dajjejaabbhbeeababjffbgebcahdaic(I):
  obj = first(objects(I, T, T, T))  # Extract the non-background object
  start = ulcorner(obj)  # Get the upper-left corner of the object
  line_width = width(obj)  # Calculate the width of the object
  line_height = min(height(obj), line_width) // 2 + line_width // 2 # Determine line height
  line_indices = frozenset((start[0] + i, start[1]) for i in range(line_height))  # Generate line indices
  O = fill(I, THREE, line_indices)  # Fill the grid with '3's at line indices
  return O
 
25.666666666666668, tensor(1.9728), Description: Draw a diagonal line of color 3 starting from the upper-left corner of the first non-background object and extending downwards for a length equal to the maximum of the object's width and half its height. The original object should be removed. 
:: def aggffafbjaeceecaiajbjdeajedibifg(I):
  obj = first(fgpartition(I)) # Extract the first non-background object
  line_start = (uppermost(obj), leftmost(obj)) # Define the starting point of the line
  line_length = width(obj) if width(obj) > height(obj) else height(obj) // 2 # Calculate the line length
  line_indices = connect(line_start, (line_start[0] + line_length - 1, line_start[1]))  # Generate the indices for the line
  O = fill(I, THREE, line_indices)  # Fill the grid with the value 3 along the line
  return O 
 
23.333333333333332, tensor(1.9427), Description: Draw a vertical line of color 3 starting from the upper-left corner of the largest object in the input grid and extending downwards for a length equal to half the object's height plus half its width. The original object should be removed. 
:: def bdgjfcgibhfgeegdiffjjhbiacabdffj(I):
  obj = argmax(objects(I, T, T, T), size) # Get the largest object (assumes it's not the background)
  w = width(obj) # Calculate the width of the object
  h = height(obj) # Calculate the height of the object
  line_height = h if w > h else h // 2  # Determine the height of the line based on object dimensions
  line_start = ulcorner(obj) # Get the upper-left corner of the object for line placement
  line_indices = frozenset((line_start[0] + i, line_start[1]) for i in range(line_height)) # Generate indices for the line
  O = fill(I, 3, line_indices)  # Fill the grid with '3's at the line's indices
  return O
 
29.0, tensor(1.9317), Description: Draw a vertical line of color 3 starting from the upper-left corner of the largest object in the input grid and extending downwards for a length equal to half the object's height. The original object should be removed. 
:: def aifcfhjebcieecddiabdadeceagjdhib(I):
  obj = argmax(objects(I, T, T, T), len)  # Extract the largest object (assuming background is not the largest)
  top_half = crop(I, ulcorner(obj), (height(obj) // 2, width(obj))) # Extract the top half of the object
  line_indices = asindices(top_half)  # Get the indices of the top half
  O = fill(I, THREE, line_indices)  # Fill the grid with '3's at the extracted indices 
  return O
 
23.333333333333332, tensor(1.9729), Description: Draw a vertical line of color 3 starting from the upper-left corner of the first non-background object and extending downwards for a length equal to the maximum of the object's width and half its height. The original object should be removed. 
:: def cdaegaedejfgeaabbbcfjeadgiagieja(I):
  obj = first(objects(I, T, T, T)) # Extract the first non-background object
  line_start = ulcorner(obj) # Get the upper-left corner of the object for line placement
  condition = width(obj) > height(obj) # Check if the object is wider than it is tall
  line_height = height(obj) if condition else height(obj) // 2 # Set the line height based on the condition
  line_indices = frozenset((line_start[0] + i, line_start[1]) for i in range(line_height))  # Generate the indices for the line
  O = fill(I, THREE, line_indices)  # Fill the input grid with '3's at the line's indices
  return O
 
8.666666666666666, tensor(0.0095), Description: Create a horizontal line of color 3, two rows from the bottom of the grid, with a length equal to the width of the first object in the input grid. The rest of the grid should be filled with color 0. 
:: def hgghhcgfeecfeddbbeaafccbijjeeibc(I):
    obj = first(objects(I, False, False, True)) # Get the first non-background object
    obj_width = width(obj) # Get width of the object
    O = fill(canvas(ZERO, shape(I)), THREE,  # Fill with '3's 
            {(height(I) - 2, j) for j in range(leftmost(obj), leftmost(obj) + obj_width)}) # at indices forming the line
    return O
 
6.0, tensor(1.9415), Description: For each object in the input grid, draw a horizontal line of color 3, two rows below the top of the object, with a length of 2 cells. The original object should be removed. The background color should remain the same. 
:: def djhaaeiaceafefhfjfgaiehagheeebdb(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    O = canvas(0, shape(I))
    for obj in objs:
        i = uppermost(obj) + 2
        j = (leftmost(obj) + rightmost(obj)) // 2 
        line = {(i, j), (i, j + 1)}
        O = paint(O, recolor(3, line))
    return O
 
31.0, tensor(1.9463), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3, two rows below the current row, with a length of 2 cells. The original color 2 cells should remain in the output. 
:: def fdcejcbibfhbebfjaieacfbcfgfaaehd(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        k = j
        while k < len(I[0]) and I[i][k] == 2:
          k += 1
        O = fill(O, 3, frozenset(((i+2, (j+k)//2), (i+2, (j+k)//2 - 1))))
  return O
 
6.666666666666667, tensor(1.9415), Description: For each object in the input grid, draw a horizontal line of color 3, two rows below the top of the object, with a length of 2 cells. The original object should be removed. The background color should remain the same. 
:: def jchifadcjjcaeeadbcfiddiefhfaaaai(I):
  objs = objects(I, True, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    top_i = uppermost(obj)
    line = connect((top_i + 2, center_j - 1), (top_i + 2, center_j))
    O = paint(O, recolor(3, line))
  return O
 
18.0, tensor(1.9463), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3, two rows below the current row, with a length of 2 cells. The original color 2 cells should remain in the output. 
:: def adbdcfdefideefgajaahcddbehceaaeh(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        if (j > 0 and row[j-1] != 2) or j == 0: # Detect left edge of an object
          k = j
          while k < len(row) and row[k] == 2:
            k += 1
          center = (j + k) // 2
          O = fill(O, 3, frozenset(((i + 2, center - 1), (i + 2, center))))
  return O
 
7.333333333333333, tensor(1.9416), Description: For each object in the input grid that is colored with color 2, draw a horizontal line of color 3, two rows below the top of the object, with a length of 2 cells. The original object should be removed. The background color should remain the same. 
:: def ifacbadjeejhefdcahhdbbafcgiccfcb(I):
  objs = partition(I)
  O = canvas(0, shape(I))
  for obj in objs:
    if color(obj) == 2:
      line_i = min([i for _, (i, _) in obj]) + 2
      line_j = (min([j for _, (_, j) in obj]) + max([j for _, (_, j) in obj])) // 2
      O = fill(O, 3, frozenset({(line_i, line_j - 1), (line_i, line_j)}))
  return O
 
26.666666666666668, tensor(0.4276), Description: For each object in the input grid, move the object two rows up and paint the moved object with color 3. The original object should remain in the output. 
:: def fgcebabjcaieegiejijiacbebcfidggc(I):
    shifted_indices = merge(apply(lambda obj: toindices(shift(obj, (-2, 0))), objects(I, T, T, T)))
    O = fill(I, 3, shifted_indices)
    return O
 
15.666666666666666, tensor(0.4276), Description: For each object in the input grid, move the object two rows up and paint the moved object with color 3. The original object should remain in the output. 
:: def ddeggcabeeefehccjdicbgfhdbeffbjb(I):
  O = I
  for obj in objects(I, T, T, T):
    O = paint(cover(O, obj), recolor(3, shift(obj, (-2, 0))))
  return O
 
23.333333333333332, tensor(1.9836), Description: Find the largest object in the input grid that is colored with color 2. Replace that object with color 3. Leave the rest of the grid unchanged. 
:: def hbcgdbhbaebfeccabccacfidbejeaifg(I):
  target_color = 2
  new_color = 3
  
  objs = objects(I, T, F, F)
  target_objs = colorfilter(objs, target_color)
  largest_obj = argmax(target_objs, size)
  
  O = fill(I, new_color, toindices(largest_obj))
  return O
 
23.333333333333332, tensor(1.7703), Description: Find the first object in the input grid that is colored with color 2. Change the color of that object to color 3. Paint the recolored object onto a blank canvas the same size as the input. 
:: def agbeaghdhadcefefiadhfeabaajiadef(I):
  target_color = 2
  new_color = 3
  
  objs = partition(I)
  target_obj = extract(objs, lambda obj: color(obj) == target_color)
  
  O = paint(canvas(0, shape(I)), recolor(new_color, target_obj))
  return O
 
23.333333333333332, tensor(1.8237), Description: Find the first object in the input grid that is colored with color 2 and has a size greater than 1. Change the color of that object to color 3. Paint the recolored object onto the input grid, keeping the original colors of the other objects. 
:: def jfegbafbdgfgeeacbibeaifcfdfjfffb(I):
  target_color = 2
  new_color = 3

  def is_target_object(obj):
    return color(obj) == target_color and size(obj) > 1

  objs = objects(I, T, F, F)
  target_obj = extract(objs, is_target_object)

  O = underpaint(I, recolor(new_color, target_obj))
  return O
 
24.0, tensor(0.7741), Description: Draw a vertical line of color 3 starting from the upper-left corner of the first non-background object and extending downwards for a length equal to half the object's height plus half its width if the object is not in the top row. Otherwise, extend the line downwards for a length equal to half the object's height plus one. The original object should be removed. 
:: def jfehcaffacdaeccibjddacdacgadjeba(I):
  obj = first(objects(I, T, T, T))
  line_start = ulcorner(obj)
  line_height = height(obj) if uppermost(obj) > 1 else height(obj) // 2 + (uppermost(obj) == 1) * 1
  line_start = (line_start[0] - 2 if uppermost(obj) > 1 else line_start[0], line_start[1])
  line_indices = frozenset((line_start[0] + i, line_start[1]) for i in range(line_height))
  O = fill(I, THREE, line_indices)
  return O
 
24.0, tensor(0.4489), Description: Draw a vertical line of color 3 starting from the upper-left corner of the first non-background object and extending downwards for a length equal to half the object's height if the object is in the top row. Otherwise, extend the line downwards for a length equal to the object's height. The original object should be removed. 
:: def bdddaggcaeebeebjbfjeecbjfebgdfej(I):
  obj = first(objects(I, T, T, T))
  offset = (NEG_TWO, ZERO) if uppermost(obj) > ONE else (ZERO, ZERO)
  start = add(ulcorner(obj), offset)
  height_factor = halve(height(obj)) if uppermost(obj) <= ONE else height(obj)
  indices = frozenset((start[0] + i, start[1]) for i in range(height_factor))
  O = fill(I, THREE, indices)
  return O
 
12.666666666666666, tensor(1.9812), Description: Draw a vertical line of color 3 from the top of the first non-background object to the bottom of the grid, passing through the center column of the object. The rest of the grid should be filled with color 0. 
:: def achdefcggcceecfhjhcceahdebabcbff(I):
  obj = first(objects(I, False, False, True))  # Find the first non-background object
  center_j = (leftmost(obj) + rightmost(obj)) // 2  # Calculate the column index of the center
  start = (uppermost(obj), center_j)  # Define the starting point for the line
  line = connect(start, (height(I) - 1, center_j))  # Generate indices for a vertical line
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))  # Draw the line on a blank canvas
  return O 
 
27.333333333333332, tensor(1.9852), Description: Draw a vertical line of color 3 from the top of the first non-background object to the bottom of the grid, passing through the center column of the object. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def ffbggbcifabaeibcabcegafaffebcdbj(I):
  obj = first(objects(I, False, False, True)) # Get the non-background object
  line_width = width(obj) # Get the width of the object
  top_row = uppermost(obj) # Get the row index of the uppermost cell
  center_j = (leftmost(obj) + rightmost(obj)) // 2  # Calculate the column index of the center
  O = fill(canvas(ZERO, shape(I)), THREE, 
           {(i, j) for i in range(top_row, height(I)) for j in range(center_j - line_width // 2, center_j + line_width // 2 + (line_width % 2))})
  return O
 
15.0, tensor(0.0071), Description: Find the first non-background object in the input grid. Calculate the center of the top row of the object. Create a vertical frontier (a vertical line) from that center point. Paint this vertical frontier onto a blank canvas the same size as the input grid, using color 3. Return the canvas. 
:: def addjidfeciccejgjbjjbbhacbcdhdeae(I):
  obj = first(objects(I, False, False, True))
  top_center = centerofmass(crop(I, ulcorner(obj), (1, width(obj))))  # Find the center of the top row of the object
  vf = vfrontier(top_center)  # Create a vertical frontier from the center
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, vf))  # Paint the vertical frontier onto a blank canvas
  return O
 
14.0, tensor(1.9430), Description: Find all the cells in the input grid that are colored with color 2. Draw a horizontal line of color 3, two rows below the top row of the object, with a length of 2 cells. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def afficfdaeahbecbfabcecabicdbhedef(I):
  target_indices = ofcolor(I, TWO)
  top_row = uppermost(target_indices)
  O = fill(canvas(ZERO, shape(I)), THREE, {(top_row, j) for i, j in target_indices})
  O = fill(O, THREE, {(top_row + 1, j) for i, j in target_indices})
  return O
 
10.0, tensor(0.9816), Description: Find the first object in the input grid that is not black. Create a 2x(width of object) rectangle with color 3. Place this rectangle at the top left corner of the object. Paint the rectangle onto a blank canvas the same size as the input. 
:: def acdfjcdbadceebababchjfccjbehjfbd(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  corner = ulcorner(obj)
  new_obj = recolor(THREE, frozenset((ZERO, (i, j)) for i in range(TWO) for j in range(width(obj))))
  O = paint(canvas(ZERO, shape(I)), shift(new_obj, corner))
  return O
 
16.666666666666668, tensor(1.9417), Description: Find the first object in the input grid that is colored with color 2. Draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. The original object should be removed. The background color should remain the same. 
:: def jacaecaifafcebdbjbgaagdjbddbhehf(I):
  obj_indices = ofcolor(I, TWO)
  min_row, min_col = ulcorner(obj_indices)
  max_col = rightmost(obj_indices)
  O = canvas(ZERO, shape(I))
  for j in range(min_col, max_col + 1):
    O = fill(O, THREE, {(min_row, j), (min_row + 1, j)})
  return O
 
25.0, tensor(0.3955), Description: Draw a horizontal line of color 3 starting from the center row of the first non-background object and extending to the right for a length equal to the width of the object. The line should be aligned with the left edge of the object. The original object should be removed. 
:: def haadejcifciieichjabdjgcdehbaaega(I):
  obj = first(fgpartition(I))  # Extract the first non-background object
  center_j = (leftmost(obj) + rightmost(obj)) // 2  # Calculate the central column
  line_start = (centerofmass(obj)[0], center_j - width(obj) // 2)  # Define the starting point of the line
  line_length = width(obj)  # Calculate the line length
  line_indices = connect(line_start, (line_start[0], line_start[1] + line_length - 1))  # Generate the indices for the line
  O = fill(I, THREE, line_indices)  # Fill the grid with the value 3 along the line
  return O
 
24.666666666666668, tensor(1.9730), Description: Draw a horizontal line of color 3 through the center row of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. 
:: def eacighcjbbcfeefajffhcficadajffjj(I):
  obj = first(fgpartition(I))  # Extract the first non-background object
  center_j = (leftmost(obj) + rightmost(obj)) // 2  # Find central column
  line = frozenset({(centerofmass(obj)[0], j) for j in range(center_j - width(obj) // 2, center_j + width(obj) // 2)}) # Directly generate line indices
  O = fill(I, THREE, line)  # Fill the grid with "3" at the line indices
  return O
 
22.666666666666668, tensor(1.9730), Description: Draw a horizontal line of color 3 through the center row of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. 
:: def bccfcbecjggdefbbbfaegafbbehgjdah(I):
    obj = first(objects(I, T, T, T)) # Extract the first non-background object
    min_j = leftmost(obj) 
    max_j = rightmost(obj)
    center_j = (min_j + max_j) // 2  # Find central column
    line = frozenset((centerofmass(obj)[0], j) for j in range(center_j - (max_j - min_j) // 2, center_j + (max_j - min_j) // 2 + 1))
    O = fill(I, THREE, line) # Fill the grid with 3 along the line
    return O
 
24.666666666666668, tensor(1.9730), Description: Draw a horizontal line of color 3 through the center row of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. 
:: def edhbhcafbggdedcfjeaeacbfhfacagcb(I):
  obj = first(fgpartition(I)) # Extract the first non-background object
  c = centerofmass(obj) # Get the center of mass of the object
  w = width(obj) # Calculate the width of the object
  O = fill(I, THREE, connect((c[0], c[1] - w // 2), (c[0], c[1] + w // 2))) # Draw a horizontal line centered at the object's center
  return O
 
8.0, tensor(1.9415), Description: Find the first object in the input grid that is not black. Create a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. The original object should be removed. The background color should remain the same. 
:: def bdbebcdddffeefacadafgaiifbehhafj(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True)) # Extract the object
  corner = ulcorner(obj) # Find the top-left corner
  obj_width = width(obj) # Calculate object width
  start = add(corner, (2, 0))  # Shift starting point two rows down
  line = {(start[0], start[1] + i) for i in range(obj_width)} # Create indices for the horizontal line
  O = fill(canvas(ZERO, shape(I)), THREE, line) # Draw the line on a blank canvas
  return O
 
17.0, tensor(1.9416), Description: Find the first object in the input grid that is not black. Draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. The original object should be removed. The background color should remain the same. 
:: def cfeabcaehibfefbcacfdgidiaggddjec(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  i, j = ulcorner(obj) # Get top-left corner coordinates
  line = hfrontier((i + 2, j)) # Create a horizontal frontier starting from the shifted corner
  O = fill(canvas(ZERO, shape(I)), THREE, intersection(line, asindices(I))) # Fill the valid indices of the frontier on a blank canvas
  return O
 
28.0, tensor(0.4474), Description: For each object in the input grid, create a 2x2 square of color 3, shifted two rows up and two columns to the left from the object's top-left corner. The original objects should remain in the output. 
:: def hhcehgdeeghdefiaicgfeegddjbdecbc(I):
    objs = objects(I, T, T, T)  
    top_left_corners = apply(lambda obj: ulcorner(obj), objs) 
    shifted_corners = apply(lambda cell: (cell[0] - 2, cell[1]), top_left_corners)  
    squares = apply(lambda cell: frozenset({(cell[0] + i, cell[1] + j) for i in range(2) for j in range(2)}), shifted_corners)  
    O = fill(I, 3, merge(squares))  
    return O
 
16.333333333333332, tensor(0.5265), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the middle column. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def dddddffcgdddehbcahcebgdjecdecjgd(I):
  target_color = 2
  new_color = 3
  
  # Find the largest object with the target color
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Shrink horizontally by removing the middle column
  left_half = crop(subgrid(largest_obj, I), (0, 0), (height(largest_obj), width(largest_obj)//2))
  right_half = crop(subgrid(largest_obj, I), (0, width(largest_obj)//2 + (width(largest_obj)%2)), (height(largest_obj), width(largest_obj)//2))
  shrunk_obj = hconcat(left_half, right_half) 

  # Shift down and paint on a blank canvas
  shifted_obj = shift(asobject(shrunk_obj), (2, 0))
  O = paint(canvas(0, shape(I)), shifted_obj)
  return O 
 
12.0, tensor(0.4065), Description: Find the largest connected object in the input grid. Shrink the object horizontally by removing the middle column. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def hccjcafagfddehaaaeacafcgdeedfgbh(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Calculate shrink offset based on object's width
  shrink_offset = width(largest_obj) // 2  + (width(largest_obj) % 2) 

  # Shrink by shifting the right part left
  shrunk_obj = frozenset((c, (i, j - shrink_offset if j >= leftmost(largest_obj) + shrink_offset else j)) 
                         for c, (i, j) in largest_obj)

  # Shift down and paint on a blank canvas
  O = paint(canvas(0, shape(I)), shift(shrunk_obj, (2, 0)))
  return O
 
13.333333333333334, tensor(0.5265), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the middle column. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def beahfaecfacdeibaiidbdefcbhdicgef(I):
  target_color = 2
  new_color = 3

  # Identify target object and its bounding box
  objs = objects(I, T, F, T)
  target_obj = argmax(objs, lambda obj: size(obj) if color(obj) == target_color else 0)
  bbox = backdrop(target_obj)
  
  # Create a shrunk bounding box
  shrunk_bbox = {(i, j) for i, j in bbox if j < leftmost(bbox) + width(bbox) // 2 
                 or j >= rightmost(bbox) - width(bbox) // 2}
  
  # Shift the shrunk bounding box down
  shifted_bbox = shift(shrunk_bbox, (2, 0))
  
  # Paint the new object within the shifted bounding box
  O = paint(canvas(0, shape(I)), recolor(new_color, shifted_bbox & toindices(target_obj)))
  return O 
 
14.0, tensor(0.9167), Description: Find the largest connected object in the input grid. Shrink the object horizontally by removing every other column. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def bgbjajcdiffeeacgbffeffihajbfcecj(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Shrink horizontally by mapping column indices
  shrunk_obj = frozenset((v, (i, j // 2 + j % 2)) for v, (i, j) in largest_obj)

  # Shift down and paint
  O = paint(canvas(0, shape(I)), shift(shrunk_obj, (2, 0)))
  return O
 
25.666666666666668, tensor(0.4210), Description: Draw a vertical line of color 3 from the row below the top of the first non-background object to the row above the bottom of the object, passing through the center column of the object. The original object should be removed. 
:: def jjfafgaajdcjedfibgciecegiiffbhdd(I):
  obj = first(fgpartition(I))  # First non-background object
  top = uppermost(obj)  # Top row of the object
  bottom = lowermost(obj)  # Bottom row of the object
  center_j = leftmost(obj) + width(obj) // 2  # Center column of the object
  line = frozenset({(i, center_j) for i in range(top + 1, bottom)})  # Vertical line indices
  O = fill(I, THREE, line)  # Fill the line with '3's
  return O
 
7.0, tensor(0.2872), Description: Find the first object in the input grid that is not black. Create a 1x2 rectangle with color 3. If the object is in the top half of the grid, place the rectangle two rows below the top of the object. Otherwise, place the rectangle two rows below the bottom of the object. Paint the rectangle onto a blank canvas the same size as the input. 
:: def cbeicajdjbehefbdbfhdebdfgiaffebd(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  corner = ulcorner(obj)
  line = recolor(THREE, crop(canvas(ZERO, (1, 2)), ORIGIN, (1, 2)))
  target = add(corner, (2, 0)) if uppermost(obj) >= len(I) // 2 else add(corner, (height(obj) + 2, 0))
  O = paint(canvas(ZERO, shape(I)), shift(line, target))
  return O
 
8.0, tensor(1.9414), Description: Find the first object in the input grid that is not black. If the object is in the top half of the grid, draw a horizontal line of color 3, two rows below the top of the object, with a length of 2 cells. Otherwise, draw the line two rows below the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def gfghagdaeaffecedjbdiahgfeefahaei(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  target_i = uppermost(obj) + 2 if uppermost(obj) >= len(I) // 2 else uppermost(obj) + height(obj) + 2
  target = (target_i, leftmost(obj))
  line = {(THREE, (target[0], target[1])), (THREE, (target[0], target[1] + 1))}
  O = paint(canvas(ZERO, shape(I)), frozenset(line))
  return O
 
8.0, tensor(1.9780), Description: For each object in the input grid, draw a horizontal line of color 3, two rows above the top of the object, with a length equal to the width of the object. The original object should be removed. The background color should remain the same. 
:: def dbacfaeeeddaeccbaefbdigaigchebhg(I):
  O = canvas(0, shape(I)) # Initialize an empty output grid
  for obj in objects(I, T, T, T): # Iterate over each object
    start_row = uppermost(obj) - 2  # Calculate the starting row for the line
    start_col = leftmost(obj)  # Calculate the starting column for the line
    for j in range(width(obj)):  # Iterate over the width of the object
      if 0 <= start_row < height(I) and 0 <= start_col + j < width(I): # Check for valid indices
        O = fill(O, 3, {(start_row, start_col + j)})  # Fill with '3'
  return O
 
9.666666666666666, tensor(0.4850), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def dcfabeidfaehehhabddcddfibfdchdca(I):
  # Find the largest object with color 2
  target_obj = argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)

  # Calculate the width of the left half
  half_width = width(target_obj) // 2

  # Create the shrunk object by filtering indices
  shrunk_obj = frozenset((v, (i, j)) for v, (i, j) in target_obj if j < leftmost(target_obj) + half_width)

  # Shift the shrunk object down
  shifted_obj = shift(shrunk_obj, (2, 0))

  # Paint the shifted object with color 3 on a blank canvas
  O = paint(canvas(0, shape(I)), recolor(3, shifted_obj))
  return O
 
29.333333333333332, tensor(0.7540), Description: Find all cells in the input grid that are colored with color 2. Create a mask of the same size as the input grid, where cells with color 2 are painted with color 1 and the rest are 0. Shrink the mask horizontally by removing the right half. Shift the shrunk mask two rows down. Paint color 3 onto a blank canvas the same size as the input, where the shifted mask has color 1. Return the canvas. 
:: def gjaddeeheieieadhifhbibddiafbfcaj(I):
  # Find indices of target color
  target_indices = ofcolor(I, 2)

  # Create a mask from the indices
  mask = paint(canvas(0, shape(I)), recolor(1, target_indices))

  # Split the mask and concatenate the left half
  shrunk_mask = hsplit(hconcat(hsplit(mask, 2)[0], hsplit(mask, 2)[1]), 2)[0]

  # Shift the shrunk mask down
  shifted_mask = shift(asobject(shrunk_mask), (2, 0))

  # Paint color 3 where the shifted mask is 1 on a blank canvas
  O = paint(canvas(0, shape(I)), recolor(3, toindices(asobject(shifted_mask))))
  return O
 
8.0, tensor(0.4850), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def afhfafbeeebdeaddafcejccbhiedehac(I):
  # Find the leftmost and rightmost columns of the target object
  target_obj = argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)
  left_col = leftmost(target_obj)
  right_col = left_col + width(target_obj) // 2

  # Create a new object by filtering cells within the left half
  new_obj = frozenset((3, (i, j + 2)) for v, (i, j) in target_obj if left_col <= j < right_col)

  # Paint the new object onto a blank canvas
  O = paint(canvas(0, shape(I)), new_obj)
  return O
 
13.333333333333334, tensor(0.4850), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def cdeahafgaibaejbfiefgbjgbdeiefdhf(I):
  # Find the target object and calculate its half width
  obj = argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)
  half_width = width(obj) // 2

  # Create a horizontal split line at the half width
  split_line =  frozenset((0, (i, leftmost(obj) + half_width)) for i in range(height(I)))

  # Remove everything right of the split line from the object
  left_half_obj = difference(obj, toobject(shoot((0, leftmost(obj) + half_width), (0, 1)), I))

  # Shift the left half down and paint it with color 3 on a blank canvas
  O = paint(canvas(0, shape(I)), recolor(3, shift(left_half_obj, (2, 0))))
  return O
 
25.333333333333332, tensor(0.3955), Description: Draw a horizontal line of color 3 starting from the center row of the first non-background object and extending to the right for a length equal to the width of the object. The line should be aligned with the left edge of the object. The original object should be removed. 
:: def fgfbbfahdhjfeieabefafiibcbbabdcb(I):
  obj = first(fgpartition(I))
  center_j = (leftmost(obj) + rightmost(obj)) // 2
  line_start_i = (uppermost(obj) + lowermost(obj)) // 2 - (height(obj) % 2 == 0) 
  line_start = (line_start_i, center_j - width(obj) // 2)
  line_length = width(obj)
  line_indices = connect(line_start, (line_start[0], line_start[1] + line_length - 1))
  O = fill(I, THREE, line_indices)
  return O
 
25.333333333333332, tensor(1.9730), Description: Draw a horizontal line of color 3, one row above the center row of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. 
:: def efjchcbafchaefcfbcgaeccjegdadaba(I):
  obj = first(fgpartition(I))
  line_start = (centerofmass(obj)[0] - (height(obj) % 2 == 0), leftmost(obj))
  line_indices = {(line_start[0], j) for j in range(leftmost(obj), rightmost(obj) + 1)}
  O = fill(I, THREE, line_indices)
  return O
 
25.0, tensor(1.9730), Description: Draw a horizontal line of color 3, one row above the center row of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. 
:: def bhcbafhjiifbedjeaidffjcbffdffihe(I):
  obj = first(fgpartition(I))
  h, w = shape(obj)
  center_i, center_j = centerofmass(obj)
  line_i = center_i - (h % 2 == 0)
  line_indices = frozenset((line_i, j) for j in range(center_j - w // 2, center_j + (w + 1) // 2))
  O = fill(I, THREE, line_indices)
  return O
 
8.0, tensor(0.9108), Description: Create a horizontal line of color 3, two rows above the bottom of the first non-background object in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def hedbbhigedhaefcabfaadcedbiddhbjf(I):
  obj = first(objects(I, False, False, True))
  line_start = (lowermost(obj) - 2, leftmost(obj)) 
  line_end = (lowermost(obj) - 2, rightmost(obj))
  line_indices = connect(line_start, line_end)
  O = fill(canvas(ZERO, shape(I)), THREE, line_indices)
  return O
 
7.333333333333333, tensor(0.0885), Description: Draw a horizontal line of color 3 through the center row of the first non-background object in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def gceiaebbcfacebefiefehjfefdcdaifb(I):
  obj = first(objects(I, False, False, True))
  target_row = (uppermost(obj) + lowermost(obj)) // 2
  O = fill(canvas(ZERO, shape(I)), THREE, 
           {(target_row, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return O
 
21.333333333333332, tensor(1.9440), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3, two rows above the current row, with a length equal to the width of the object. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def geceecaibafaeceijheffiefiehfdcfe(I):
  # Find the index of the first row containing a '2'.
  row_index = next((i for i, row in enumerate(I) if 2 in row), len(I))
  
  # Create a canvas filled with '0's.
  O = canvas(0, shape(I))
  
  # If a row with '2's was found:
  if row_index < len(I):
    # Replace '2's with '3's in the identified row.
    new_row = tuple(3 if v == 2 else 0 for v in I[row_index])
    # Insert the modified row at two positions above its original location.
    O = vconcat(vconcat((new_row,), O[:max(0, row_index - 2)]), O[max(0, row_index - 2):])
  
  return O
 
151.33333333333334, tensor(1.9440), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3, two rows above the current row, with a length equal to the width of the object. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def gabaajbcbjiheabbjheceajdddefbfcc(I):
  # Find the row index of the first occurrence of '2' in the grid.
  row_index = next((i for i, r in enumerate(I) for v in r if v == 2), len(I)) 
  
  # Create a blank canvas of the same size as the input.
  O = canvas(0, shape(I)) 
  
  # If a row with '2' is found, create a new row with '3's at the same positions.
  new_row = tuple(3 if I[row_index][j] == 2 else 0 for j in range(len(I[0]))) if row_index < len(I) else None
  
  # Combine the new row with the blank canvas, placing the new row two rows above. 
  O = tuple((new_row,) + O[:row_index - 2] + O[row_index - 1:]) if new_row is not None else O
  return O
 
18.666666666666668, tensor(1.9440), Description: For each row in the input grid, if a cell in that row is colored with color 2, draw a horizontal line of color 3, two rows above the current row, with a length equal to the width of the object. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def gifdhjcedcibeeeaiebheaaieijhdbbb(I):
  # Create a mask by checking each cell for the value 2
  mask = tuple(tuple(1 if v == 2 else 0 for v in row) for row in I)
  # Find the row index of the first occurrence of 2 in the grid.
  row_index = next((i for i, row in enumerate(mask) if 1 in row), len(mask))
  
  # Create a blank canvas filled with 0s.
  O = canvas(0, shape(I))
  
  # If a row with 2 was found:
  if row_index < len(I):
    # Shift the mask two rows up by slicing and concatenating.
    shifted_mask = mask[row_index:] + ((0,) * len(I[0]),) * min(2, row_index)
    # Combine the shifted mask with the blank canvas, replacing 0s with 3s where the mask is 1.
    O = tuple(tuple(3 if m else 0 for m in mask_row) for mask_row in shifted_mask)
  
  return O
 
29.333333333333332, tensor(1.9413), Description: For each row in the input grid, if a cell in that row is colored with color 2, replace that entire row with a row of color 3. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def fddifiedaibaehiajeiebdfifdfieccb(I):
  # Find the index of the topmost row containing a '2'.
  row_index = next((i for i, r in enumerate(I) if 2 in r), len(I))
  
  # Replace the target row with a row of '3's if it exists, otherwise keep the original row.
  modified_row = tuple(3 for _ in range(len(I[0]))) if row_index < len(I) else I[row_index]
  
  # Create the output grid by concatenating the modified row with a canvas of 0s,
  # positioned two rows above the original row.
  O = vconcat(vconcat((modified_row,), canvas(0, (max(0, row_index - 2), len(I[0])))), canvas(0, (len(I) - max(0, row_index - 1), len(I[0]))))

  return O
 
6.333333333333333, tensor(0.3433), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half and vertically by removing the bottom half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def ccfeedgcfdddehibjadageeccdhebdaj(I):
  # Find the target object's indices
  indices = toindices(argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0))

  # Filter for indices in the top half and left half
  filtered_indices = {(i, j) for i, j in indices if i < height(indices) // 2 and j < width(indices) // 2}

  # Shift the filtered indices and paint the object
  O = paint(canvas(0, shape(I)), recolor(3, shift(filtered_indices, (2, 0))))
  return O
 
6.666666666666667, tensor(0.3335), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally and vertically by removing the outer quarters. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def geddhfabbedaecbfbahecfeacdibcafc(I):
  # Find the target object
  obj = argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)

  # Calculate center and dimensions of the target object
  center_i, center_j = centerofmass(obj)
  obj_height, obj_width = height(obj), width(obj)

  # Create a blank canvas
  O = canvas(0, shape(I))

  # Iterate through the canvas, painting the shifted and shrunk object
  for i in range(len(O)):
    for j in range(len(O[0])):
      if abs(i - center_i - 2) < obj_height // 4 and abs(j - center_j) < obj_width // 4:
        O = fill(O, 3, {(i, j)})
  return O
 
23.333333333333332, tensor(1.9730), Description: Draw a horizontal line of color 3 across the bottom two rows of the largest object in the input grid. The original object should be removed. 
:: def eeefaccdfiheebgbicbhafccjbedcbic(I):
  obj = argmax(objects(I, T, T, T), size) # Find the largest object
  bottom = lowermost(obj)  # Find the lowermost row of the object
  O = fill(I, THREE, frozenset((i, j) for i, j in toindices(obj) if i >= bottom - 1)) # Fill the two bottom rows of the object with 3
  return O
 
23.333333333333332, tensor(1.9725), Description: Draw a vertical line of color 3 starting from the middle row of the largest object in the input grid and extending downwards for a length equal to half the object's height. The original object should be removed. 
:: def cadaddddfdcdefjjihacbcceibadaeej(I):
  obj = argmax(objects(I, T, T, T), size) # Find largest object
  height_obj = height(obj)  # Get the height of the object
  start = add(ulcorner(obj), (height_obj // 2, 0)) # Calculate the starting point for the fill
  indices = frozenset((start[0] + i, start[1]) for i in range(height_obj // 2)) # Generate indices for the bottom half
  O = fill(I, THREE, indices)  # Fill the bottom half with 3
  return O
 
18.0, tensor(1.9725), Description: Draw a vertical line of color 3 starting from the middle row of the largest object in the input grid and extending downwards for a length equal to half the object's height. The original object should be removed. 
:: def eifjjcfadgceecgaaechjfbaabicefdf(I):
  obj = argmax(objects(I, T, T, T), size) # Find largest object
  bottom_half = frozenset((v, (i, j)) for v, (i, j) in obj if i >= centerofmass(obj)[0]) # Get the bottom half of the object
  O = paint(cover(I, obj), recolor(THREE, bottom_half)) # Replace the bottom half with '3's
  return O
 
28.333333333333332, tensor(1.9725), Description: Draw a vertical line of color 3 starting from the middle row of the largest object in the input grid and extending downwards for a length equal to half the object's height. The original object should be removed. 
:: def bcaaiabcagaiejcdigacabagcceagahi(I):
  obj = argmax(objects(I, T, T, T), size)  # Find the largest object
  h = height(obj) # Calculate the height of the object
  O = I
  for i in range(h // 2, h): # Iterate over the bottom half of the object
    O = fill(O, THREE, frozenset((i + uppermost(obj), j) for j in range(width(obj)))) # Fill each row with 3
  return O
 
14.0, tensor(1.9730), Description: Draw a horizontal line of color 3 across the middle two rows of the largest object in the input grid. The original object should be removed. 
:: def ehbddafdagecefcajddedcageeacaibb(I):
  obj = argmax(objects(I, T, T, T), size) # Find largest object
  middle_row = centerofmass(obj)[0] # Find the row index of the center of mass
  rows = tuple((v, (i, j)) for v, (i, j) in obj if i == middle_row or i == middle_row + 1) # Extract the middle two rows
  O = paint(cover(I, obj), recolor(THREE, rows)) # Replace the middle two rows with '3's
  return O
 
6.666666666666667, tensor(0.7857), Description: Create a horizontal line of color 3, two rows above the top of the first non-background object in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def edbdfacecdifeggcaajeadbhidahbdfd(I):
  obj = first(objects(I, False, False, True))  # First non-background object
  line_row = uppermost(obj) - 2  # Row two above the object
  obj_width = width(obj)  # Object's width
  O = fill(canvas(ZERO, shape(I)), THREE, 
           {(line_row, j) for j in range(leftmost(obj), leftmost(obj) + obj_width)})
  return O
 
8.333333333333334, tensor(1.6055), Description: Draw a horizontal line of color 3, two rows from the bottom of the grid, with a length of 3 cells, centered on the horizontal center of the first non-background object in the top half of the input grid. The rest of the grid should be filled with color 0. 
:: def adfagfjeedhcecfdicgdbcfehjjffhff(I):
  h = height(I) // 2
  obj = toobject(asindices(tophalf(I)), I)
  if len(obj) == 0:
    return canvas(0, shape(I))
  j = (leftmost(obj) + rightmost(obj)) // 2
  line = {(h * 2 - 2, j - 1), (h * 2 - 2, j), (h * 2 - 2, j + 1)}
  return paint(canvas(0, shape(I)), recolor(3, line))
 
6.0, tensor(1.9411), Description: Draw a horizontal line of color 3, two rows from the bottom of the grid, with a length of 3 cells, centered on each non-black cell in the top row of the input grid. The rest of the grid should be filled with color 0. 
:: def cghaaabfgfjeefiaaeebeccahcaccbhc(I):
    O = canvas(0, shape(I))
    for j in range(width(I)):
        if index(I, (0, j)) != 0:
            O = paint(O, recolor(3, {(height(I) - 2, j - 1), (height(I) - 2, j), (height(I) - 2, j + 1)}))
    return O
 
8.333333333333334, tensor(1.9411), Description: Draw a horizontal line of color 3, two rows from the bottom of the grid, with a length of 3 cells, centered on each object in the top half of the input grid. The rest of the grid should be filled with color 0. 
:: def caedfddjfcfhehhbicjifbbihaahdcaa(I):
    O = canvas(0, shape(I))
    for obj in objects(tophalf(I), univalued=False, diagonal=True, without_bg=False):
        center_j = (leftmost(obj) + rightmost(obj)) // 2
        O = paint(O, recolor(3, {(height(I) - 2, center_j - 1), (height(I) - 2, center_j), (height(I) - 2, center_j + 1)}))
    return O
 
9.0, tensor(1.9411), Description: Draw a horizontal line of color 3, two rows from the bottom of the grid, with a length of 3 cells, centered on the first non-black cell in the top half of the input grid. The rest of the grid should be filled with color 0. 
:: def cadffdgabbeheccabicbacfiabgfefcf(I):
    O = canvas(0, shape(I))
    top_indices = asindices(tophalf(I))
    for i, j in top_indices:
        if index(I, (i, j)) != 0:
            target_i = height(I) - 2
            O = paint(O, recolor(3, {(target_i, j-1), (target_i, j), (target_i, j+1)}))
            break 
    return O
 
23.333333333333332, tensor(1.9410), Description: Draw a horizontal line of color 3, two rows from the bottom of the grid, with a length of 3 cells, centered on the first non-black cell in the top row of the input grid. The rest of the grid should be filled with color 0. 
:: def abfagiaajjfeeedjjabeiiafjfbgacgd(I):
    O = I
    for j in range(width(I)):
        if index(I, (0, j)) != 0:
            O = fill(O, 0, asindices(O))
            O = paint(O, recolor(3, {(height(I) - 2, j - 1), (height(I) - 2, j), (height(I) - 2, j + 1)}))
            break
    return O
 
18.333333333333332, tensor(0.7654), Description: Find the largest object in the left half of the input grid that is colored with color 2. Shift that object two rows down and change its color to 3. Paint the shifted and recolored object onto a blank canvas the same size as the left half of the input grid. Concatenate the resulting canvas with a blank canvas the same size as the right half of the input grid. Return the concatenated grid. 
:: def jcadadffjdaeebjbbfedbahiaiddcaca(I):
  # Split the input grid vertically
  left_half, right_half = hsplit(I, 2)

  # Find the target object in the left half
  obj = argmax(objects(left_half, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)

  # Shift and recolor the object
  transformed_obj = recolor(3, shift(obj, (2, 0)))

  # Combine the transformed object with a blank right half
  O = hconcat(paint(canvas(0, shape(left_half)), transformed_obj), canvas(0, shape(right_half)))
  return O
 
10.0, tensor(0.4850), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def fdifcffceeegebhjiaecifgafaffcabe(I):
  # Find the target object's bounding box
  bbox = backdrop(toindices(argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)))

  # Calculate half width
  half_width = (rightmost(bbox) - leftmost(bbox) + 1) // 2

  # Shrink the bounding box horizontally
  shrunk_bbox = frozenset((i, j) for i, j in bbox if j <= leftmost(bbox) + half_width - 1)

  # Shift the shrunk bounding box down
  shifted_bbox = shift(shrunk_bbox, (2, 0))

  # Paint the area within the shifted bounding box with color 3
  O = paint(canvas(0, shape(I)), recolor(3, toobject(shifted_bbox, I)))
  return O
 
23.333333333333332, tensor(1.9730), Description: Draw a horizontal line of color 3 through the middle row of the first non-background object in the input grid. The line should be 2 cells wide, centered on the horizontal center of the object. The original object should be removed. 
:: def dddefbdefgaaehbaaabdffdhadhahbdf(I):
  obj = first(fgpartition(I)) # Extract the first non-background object
  middle_row = uppermost(obj) + height(obj) // 2 # Calculate the middle row index
  start_col = leftmost(obj) + width(obj) // 2 - (1 - width(obj) % 2) // 2 # Calculate the starting column index
  end_col = start_col + 1 + (1 - width(obj) % 2)  # Calculate the ending column index
  indices = frozenset({(middle_row, j) for j in range(start_col, end_col)}) # Create a set of indices to be filled
  O = fill(I, THREE, indices)  # Fill the specified indices with '3'
  return O
 
23.666666666666668, tensor(1.9730), Description: Draw a horizontal line of color 3 through the middle row of the first non-background object in the input grid. The line should be 2 cells wide, centered on the horizontal center of the object. The original object should be removed. 
:: def jciafhdgcdffeabhjgfhcibfbdfcbegc(I):
    obj = first(fgpartition(I))
    mr = uppermost(obj) + height(obj) // 2
    mc = leftmost(obj) + width(obj) // 2
    fill_range = interval(mc, mc + 2, 2 - width(obj) % 2) # Adjust step based on even/odd width
    indices = frozenset((mr, j) for j in fill_range)
    return fill(I, THREE, indices) 
 
6.0, tensor(0.1543), Description: Draw a horizontal line of color 3, two rows above the top of the object with the highest top edge in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def fcjbcfbbgdfbedhfjhaefcedadfgafei(I):
  obj = min(objects(I, False, False, True), key=lambda x: uppermost(x)) # Object with highest top edge
  offset = (uppermost(obj) - 2, 0) # Calculate vertical offset for the line
  line = recolor(THREE, {(0, j) for j in range(width(obj))})  # Create a horizontal line of '3's
  O = paint(canvas(ZERO, shape(I)), shift(line, offset))  # Paint the shifted line onto a blank canvas
  return O
 
12.333333333333334, tensor(1.9416), Description: Find the first object in the input grid that is colored with color 2. If the object is in the top half of the grid, draw a vertical line of color 3, two rows below the top of the object, with a length equal to the height of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def giacdjdfhcedeaehiafdggfebifebidh(I):
  obj_indices = ofcolor(I, TWO)
  min_row, min_col = ulcorner(obj_indices)
  line_height = height(obj_indices)
  target_row = min_row + 2 if min_row < len(I) // 2 else min_row - line_height - 2
  O = canvas(ZERO, shape(I))
  for i in range(line_height):
    O = fill(O, THREE, {(target_row + i, min_col)})
  return O
 
9.0, tensor(1.9415), Description: Find the first object in the input grid that is not black. If the object is in the top half of the grid, draw a vertical line of color 3, two rows below the top of the object, with a length equal to the height of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def jfghbbccdfghejffiifjghfecfcjagjh(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  start = add(ulcorner(obj), (2, 0)) if uppermost(obj) < len(I) // 2 else add(ulcorner(obj), (-2, 0))
  end = add(start, (height(obj) - 1, 0)) if uppermost(obj) < len(I) // 2 else add(start, (- height(obj) + 1, 0))
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, connect(start, end)))
  return O
 
9.0, tensor(1.9415), Description: Find the first object in the input grid that is not black. If the object is in the top half of the grid, draw a vertical line of color 3, two rows below the top of the object, with a length equal to the height of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def hehfjgjaehjdedbiidghdcgegeeaiage(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  h = height(obj) 
  offset = 2 if uppermost(obj) < len(I) // 2 else -h - 2
  target = add(ulcorner(obj), (offset, 0))
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, frozenset((target[0] + i, target[1]) for i in range(h))))
  return O
 
14.0, tensor(0.4850), Description: Find the largest object in the input grid that is colored with color 2. Shrink the object horizontally by removing the right half. Shift the shrunk object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def gcacbeeefgdeefbajjeaigjaffhbfbaf(I):
  # Find the target object
  obj = argmax(objects(I, T, F, T), lambda obj: size(obj) if color(obj) == 2 else 0)

  # Shrink object horizontally using hsplit
  shrunk_obj = toobject(asindices(hsplit(subgrid(obj, I), 2)[0]), I)

  # Shift and recolor the shrunk object
  transformed_obj = recolor(3, shift(shrunk_obj, (2, 0)))

  # Paint on canvas
  O = paint(canvas(0, shape(I)), transformed_obj)
  return O
 
22.333333333333332, tensor(1.9729), Description: Draw a horizontal line of color 3 through the middle row of the largest object in the input grid. The line should be 2 cells wide if the object's width is even, and 1 cell wide if the object's width is odd. The line should be centered on the horizontal center of the object. The original object should be removed. 
:: def dfcacdbgdfbceafcjbddhgjfiffeeicc(I):
  obj = argmax(objects(I, T, T, T), size)  # Find the largest object
  middle_row = uppermost(obj) + height(obj) // 2  # Calculate middle row
  center_col = leftmost(obj) + width(obj) // 2  # Calculate center column
  line_length = 2 if even(width(obj)) else 1  # Determine line length based on parity
  line_indices = connect((middle_row, center_col), (middle_row, center_col + line_length - 1))  # Generate line indices
  O = fill(I, THREE, line_indices)  # Fill with '3'
  return O
 
23.666666666666668, tensor(1.9729), Description: Draw a horizontal line of color 3 through the middle row of the largest non-background object in the input grid. The line should be 2 cells wide if the object's width is even, and 1 cell wide if the object's width is odd. The line should be centered on the horizontal center of the object. The original object should be removed. 
:: def dddebaadibgeecgcjahcfibhffdbadfc(I):
  obj = argmax(fgpartition(I), size)  # Find largest foreground object
  mid_row = (uppermost(obj) + lowermost(obj)) // 2 # Calculate middle row
  mid_col = leftmost(obj) + width(obj) // 2  # Calculate center column
  line_indices = {(mid_row, mid_col), (mid_row, mid_col + (width(obj) % 2))} # Generate indices for the line
  O = fill(I, THREE, line_indices) # Fill with '3'
  return O
 
22.0, tensor(1.9729), Description: Draw a horizontal line of color 3 through the center row of the largest object in the input grid. The line should be 2 cells wide if the object's width is even, and 1 cell wide if the object's width is odd. The line should be centered on the horizontal center of the object. The original object should be removed. 
:: def eageehbgcbdfegabiachhcegjeehbbaf(I):
  obj = argmax(objects(I, True, True, True), size)  # Find the largest object
  center_i, center_j = centerofmass(obj)  # Find center of mass
  offset = 1 if even(width(obj)) else 0  # Calculate offset based on width
  line_indices = {(center_i, center_j), (center_i, center_j + offset)}  # Create indices for the line
  O = fill(I, THREE, line_indices)  # Fill with '3'
  return O
 
6.666666666666667, tensor(1.5715), Description: Draw a horizontal line of color 3, three rows above the top of the first non-background object in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def bjajcaadfbcgehffijfddgcbjibcdbad(I):
  obj = next(iter(objects(I, False, False, True)))
  top_edge = uppermost(obj)
  O = fill(canvas(ZERO, shape(I)), THREE, 
           {(top_edge - 3, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return O
 
9.666666666666666, tensor(1.9414), Description: Find the first row in the input grid that contains color 2. If that row is in the top half of the grid, draw a horizontal line of color 3, two rows above that row, with a length equal to the number of consecutive color 2 cells in that row. If the row is in the bottom half of the grid, draw a horizontal line of color 3, one row below the bottom of the object formed by the color 2 cells, with a length equal to the number of consecutive color 2 cells in that row. The original color 2 cells should remain in the output. The background color should remain the same. 
:: def eeieaaegcabceabbidfigijbbffbcadh(I):
  for i, row in enumerate(I):
    if TWO in row:
      top_row = i
      start_col = row.index(TWO)
      line_width = len(sfilter(row[start_col:], lambda x: x == TWO))
      break
  target_row = (top_row - 2) % len(I) if top_row < len(I) // 2 else (top_row + len(sfilter(tuple(r[start_col] for r in I[top_row:]), lambda x: x == TWO)) + 1) % len(I)
  O = fill(canvas(ZERO, shape(I)), THREE, {(target_row, j) for j in range(start_col, start_col + line_width)})
  return O
 
8.666666666666666, tensor(1.9415), Description: Find the first object in the input grid that is not black. If the object is in the top half of the grid, draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def gccgeeidihfaebcjafddcaacediccjae(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  corner = ulcorner(obj)
  target_row = corner[0] + (height(obj) + 2) * (corner[0] >= len(I) // 2) - 2
  target_row %= len(I)
  line = {(target_row, j) for j in range(corner[1], corner[1] + width(obj))}
  O = fill(canvas(ZERO, shape(I)), THREE, line)
  return O
 
15.0, tensor(0.0308), Description: Find the largest connected object in the input grid. Shift that object two rows down. Paint the shifted object onto a blank canvas the same size as the input. The color of the object should remain the same. 
:: def cfhicihfdjfheaahjfaffddaaeecfehf(I):
  obj = argmax(objects(I, T, F, T), lambda obj: size(obj))
  bbox = backdrop(obj)
  shifted_bbox = shift(bbox, (2, 0))
  O = paint(canvas(0, shape(I)), recolor(3, toobject(shifted_bbox, I)))
  return O
 
24.333333333333332, tensor(1.7864), Description: Draw a horizontal line of color 3, one row below the top of the first non-background object in the input grid. The line should be as wide as the object. The original object should be removed. Also draw a horizontal line of color 3, two rows below the bottom of the object. The line should be as wide as the object. The original object should be removed. 
:: def fjhcfcbjhiaaecbfibgafdhhdfeadhcc(I):
  obj = first(objects(I, T, T, T))
  offset = (ONE, ZERO) if uppermost(obj) <= ONE else (ZERO, ZERO)
  start = add(ulcorner(obj), offset)
  width_factor = halve(width(obj)) if uppermost(obj) <= ONE else width(obj)
  indices_top = frozenset((start[0], start[1] + j) for j in range(width_factor))
  indices_bottom = shift(indices_top, (TWO, TWO))
  O = fill(I, THREE, indices_top)
  O = fill(O, THREE, indices_bottom)
  return O
 
26.0, tensor(1.4071), Description: Draw two horizontal lines of color 3, one row below the top of the first non-background object and one row above the bottom of the object. The lines should be as wide as the object, but if the object is in the top row, the top line should be only half the width of the object. The original object should be removed. 
:: def afbhefajfdfeeeefibieiacedgdhacag(I):
  top_obj = first(objects(I, T, T, T))
  is_at_top = uppermost(top_obj) == ZERO
  start_j = leftmost(top_obj)
  line_width = width(top_obj) // (ONE + is_at_top) 
  modified_grid = tuple(
      tuple(
          THREE if (i == int(is_at_top) or i == int(is_at_top) + TWO) and j >= start_j and j < start_j + line_width else v 
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
  return modified_grid
 
24.0, tensor(1.7264), Description: Draw a horizontal line of color 3, one row below the top of the object with the highest top edge in the input grid. The line should be as wide as the object. Also draw a horizontal line of color 3, two rows below the bottom of the object. The line should be as wide as the object. The original object should be removed. 
:: def cgedefabcchheddajiihcfaaidhhffei(I):
  obj = argmax(objects(I, T, T, T), lambda o: -uppermost(o))
  is_top_row = uppermost(obj) == ZERO
  line_start = (int(is_top_row), leftmost(obj))
  line_length = width(obj) if is_top_row else halve(width(obj))
  line = connect(line_start, (line_start[0], line_start[1] + line_length - 1))
  return paint(I, recolor(THREE, combine(line, shift(line, (TWO, TWO)))))
 
8.666666666666666, tensor(1.9415), Description: Find the first object in the input grid that is not black. If the object is in the top half of the grid, draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def idcdchcgeaajebccadfcfbfbfbdhgfci(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  row_index = next((i for i, row in enumerate(I) if TWO in row), None)
  if row_index is not None:
    target_row = (row_index - 2) % len(I) if row_index < len(I) // 2 else (row_index + height(obj) + 1) % len(I)
    line_indices = product({target_row}, range(leftmost(obj), leftmost(obj) + width(obj)))
    O = paint(canvas(ZERO, shape(I)), recolor(THREE, line_indices))
  else:
    O = canvas(ZERO, shape(I))
  return O
 
8.666666666666666, tensor(1.9416), Description: Find the first object in the input grid that is not black and has color 2. If the object is in the top half of the grid, draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def bcbbdeeeacbdejebadgfjaadiccdhajc(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  row_index = next((uppermost(obj) for obj in objects(I, univalued=True, diagonal=False, without_bg=True) if color(obj) == TWO), None)
  if row_index is not None:
    target_row = (row_index - 2) % len(I) if row_index < len(I) // 2 else (row_index + height(obj) + 1) % len(I)
    O = paint(canvas(ZERO, shape(I)), recolor(THREE, {(target_row, j) for j in range(leftmost(obj), leftmost(obj) + width(obj))}))
  else:
    O = canvas(ZERO, shape(I))
  return O
 
13.666666666666666, tensor(0.4963), Description: Find the smallest non-background object in the input grid. Shift the bounding box of that object two rows down. Paint the shifted bounding box with color 3 onto a blank canvas the same size as the input. 
:: def gfgfdhedbeidebabaidciecciddeadae(I):
  # Find the smallest non-background object
  obj = argmin(objects(I, T, F, T), lambda obj: size(obj))
  
  # Get the bounding box of the object
  bbox = backdrop(obj)
  
  # Shift the bounding box two rows down
  shifted_bbox = shift(bbox, (2, 0))
  
  # Fill the shifted bounding box with 3 on a canvas
  O = fill(canvas(0, shape(I)), 3, toindices(toobject(shifted_bbox, I)))
  return O
 
25.0, tensor(1.4249), Description: Draw a horizontal line of color 3, one row below the top of the first non-background object in the input grid. The line should be as wide as the object if the object is in the top row. Otherwise, the line should be half the width of the object. The original object should be removed. Also draw a horizontal line of color 3, two rows below the bottom of the object. The line should be as wide as the object. The original object should be removed. 
:: def diibejcjbfhgebjfihgaacfbhhedcefb(I):
  obj = first(objects(I, T, T, T))
  start = ulcorner(obj)
  is_top = uppermost(obj) <= ONE
  offset = (TWO, TWO) if is_top else (ZERO, ZERO)
  line = frozenset((start[0] - TWO + TWO*int(is_top) + offset[0], start[1] + j + offset[1]) for j in range(width(obj) if is_top else halve(width(obj))))
  return fill(I, THREE, line)
 
25.333333333333332, tensor(1.9730), Description: Draw a horizontal line of color 3, two rows above the top of the object with the highest top edge in the input grid. The line should be as wide as the object if the object is in the top row. Otherwise, the line should be half the width of the object. The original object should be removed. 
:: def bccbaaciaafaehafaggdbbccbdfcjgbb(I):
  obj = argmax(objects(I, T, T, T), uppermost)
  line_start = (uppermost(obj) - TWO + TWO*(uppermost(obj) <= ONE), leftmost(obj) + (uppermost(obj) <= ONE)*TWO)
  line_end = (uppermost(obj) - TWO + TWO*(uppermost(obj) <= ONE), leftmost(obj) + width(obj) - ONE + (uppermost(obj) <= ONE)*(width(obj) // TWO - ONE)) 
  line = connect(line_start, line_end)
  return fill(I, THREE, line)
 
25.0, tensor(1.9730), Description: Draw a horizontal line of color 3, two rows above the top of the object with the highest top edge in the input grid. The line should be as wide as the object if the object is in the top row. Otherwise, the line should be half the width of the object. The original object should be removed. 
:: def jeddaaadchfaecfaacihbicegcddddei(I):
  obj = argmax(objects(I, T, T, T), uppermost)
  line_width = width(obj) if uppermost(obj) <= ONE else halve(width(obj)) 
  line = crop(canvas(THREE, (ONE, line_width)), (ZERO, ZERO), (ONE, line_width))
  offset = (uppermost(obj) - TWO + TWO*(uppermost(obj) <= ONE), leftmost(obj) + TWO*(uppermost(obj) <= ONE))
  return paint(I, shift(asobject(line), offset))
 
7.333333333333333, tensor(0.9548), Description: Draw a horizontal line of color 3, two rows above the top of the largest non-background object in the input grid. The line should be as wide as the object. The rest of the grid should be filled with color 0. 
:: def fccdbeffabidecfeaijcbfdbiadhacih(I):
  obj = max(objects(I, False, False, True), key=size)
  line_row = uppermost(obj) - 2
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, {(line_row, j) for j in range(leftmost(obj), rightmost(obj) + 1)}))
  return O
 
8.0, tensor(1.9416), Description: Find the first object in the input grid that is not black and has color 2. If the object is in the top half of the grid, draw a horizontal line of color 3, two rows below the top of the object, with a length equal to the width of the object. Otherwise, draw the line two rows above the bottom of the object. The original object should be removed. The background color should remain the same. 
:: def cdeagcabibceegjeajfbjjcehhefagfa(I):
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  row_index = next((i for i, row in enumerate(I) if TWO in row), None)
  if row_index is None:
    return canvas(ZERO, shape(I))
  target_row = (row_index + 2) % len(I) if row_index < len(I) // 2 else (row_index - height(obj) - 2) % len(I)
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, {(target_row, j) for j in range(leftmost(obj), leftmost(obj) + width(obj))}))
  return O
 
47.666666666666664, tensor(0.2298), Description: Find the largest connected object in the input grid that is colored with color 3. Create a 10x10 canvas filled with 0s. Shift the object to the bottom-center of the canvas, ensuring that the object's center is aligned with the center of the canvas. Paint the shifted object onto the canvas. Return the canvas. 
:: def cedhffibbehbefgfjeefdjcicjdgaeeb(I):
    x1 = objects(I, True, False, False) # Extract connected '3' objects 
    x2 = argmax(x1, size) # Find the largest '3' object
    x3 = shape(x2) # Get the height and width of the object
    x4 = canvas(ZERO, (TEN, TEN)) # Create a 10x10 canvas filled with '0's
    x5 = (FIVE - x3[0] // TWO, FIVE - x3[1] // TWO) # Calculate the upper-left corner for bottom-center placement
    x6 = shift(x2, x5) # Shift the object to the bottom-center
    O = paint(x4, x6) # Paint the object onto the canvas
    return O
 
47.666666666666664, tensor(0.3438), Description: Find the first object in the input grid that is colored with color 3. If the object exists, create a 10x10 canvas filled with 0s and paint the object onto the canvas, shifted down by 5 rows and right by 3 columns. If the object does not exist, return a blank 10x10 canvas filled with 0s. 
:: def jceejddfcaacejgfbadaefafejibgigb(I):
    # 1. Identify the target pattern (assuming '3' for this case)
    target_value = 3
    
    # 2. Find occurrences of the target pattern in the input
    x1 = ofcolor(I, target_value)
    
    # 3. Determine if the pattern exists
    pattern_exists = size(x1) > 0
    
    # 4. Calculate canvas dimensions (10x10 for now)
    canvas_size = (10, 10) 
    
    # 5. Create a blank canvas filled with '0'
    x2 = canvas(0, canvas_size)
    
    # 6.  Position the pattern if it exists
    O = branch(
        pattern_exists, 
        paint(x2, recolor(target_value, shift(x1, (5, 3)))),  # Shift down by 5, right by 3
        x2  # Return blank canvas if pattern not found
    ) 
    return O
 
89.33333333333333, tensor(0.2231), Description: Find the first object in the input grid that is colored with color 3. If the object exists, create a 10x10 canvas filled with 0s and paint the object onto the canvas, shifted down by 5 rows and right by 3 columns. If the object does not exist, return a blank 10x10 canvas filled with 0s. If the height of the input grid is less than 15, duplicate the object and paint it again, shifted one row down and one column to the right from the original position. 
:: def bhifgchgcceheccciaabdfefacjfehee(I):
  # 1. Identify '3' locations and check if they exist
  x1 = ofcolor(I, 3)
  x2 = size(x1) > 0

  # 2. Define canvas size and location based on input height
  x3 = (10, 10) if len(I) < 15 else (15, 15)
  x4 = (5, 5) if len(I) < 15 else (2, 2)

  # 3. Create a blank canvas
  x5 = canvas(0, x3)

  # 4. Conditionally paint the '3' component
  O = branch(x2, paint(x5, recolor(3, shift(x1, x4))), x5)

  # 5. Duplicate and paint if input height is less than 15
  O = branch(len(I) < 15, paint(O, recolor(3, shift(x1, add(x4, (1,1))))), O)
  return O
 
