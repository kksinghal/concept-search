16.25, tensor(1.7412), Description: If the shape is blue, fill the area one square to the right and one square down with yellow. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. 
:: def agaaegacdcaieiffabaccijbdebjgdab(I):
  objs = objects(I, T, T, T)
  for obj in objs:
    c = color(obj)
    if c == 8:
      I = fill(I, 4, backdrop(shift(normalize(obj),(1,1))))
      I = fill(I, 6, difference(backdrop(shift(obj,(2,2))), backdrop(shift(obj,(1,1)))))
      I = fill(I, 1, {(lowermost(obj)+2, rightmost(obj)-1), (lowermost(obj)+2, rightmost(obj)), (lowermost(obj)+2, rightmost(obj)+1)})
      I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
    elif c == 3:
      I = fill(I, 6, backdrop(shift(normalize(obj),(1,1))))
    elif c == 2:
      I = fill(I, 1, backdrop(shift(normalize(obj),(1,1))))
  return I
 
14.0, tensor(1.7412), Description: If the shape is blue, fill the area one square to the right and one square down with yellow. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. 
:: def caecgfbgdfdcejfeagghiefccfcihgad(I):
  for obj in objects(I, T, T, T):
    c = color(obj)
    ul = ulcorner(obj)
    I = fill(I, {8:4, 3:6, 2:1}.get(c, 0), backdrop(shift({(0,0)}, add(ul,(1,1)))))
    if c == 8: 
      I = fill(I, 6, difference(backdrop(shift({(0,0)}, add(ul,(2,2)))), backdrop(shift({(0,0)}, add(ul,(1,1))))))
      I = fill(I, 1, {(ul[0]+2, ul[1]+width(obj)-2),(ul[0]+2, ul[1]+width(obj)-1),(ul[0]+2, ul[1]+width(obj))})
      I = fill(I, 2, {(ul[0]+2, ul[1]+width(obj)-1)})
  return I
 
11.25, tensor(1.6191), Description: If the shape is a single square, fill the area around it with yellow and then fill the square with red. If the shape is not a single square, fill the area around it with orange and then fill the shape with black. 
:: def acafaegeffbfecbabgedjjbjdahgafad(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = I
  for obj in objs:
    if size(obj) == 1:
      O = fill(O, 1, outbox(obj))
      O = fill(O, 2, obj)
    else:
      O = fill(O, 4, delta(obj))
      O = fill(O, 6, backdrop(obj))
  return O
 
12.25, tensor(1.7139), Description: Find the smallest object in the input grid.  Then, fill in a vertical column of yellow squares in the center of the object. Fill in the column to the left of the center column with orange squares. Fill in the column to the right of the center column with a pattern of light blue squares on the top and bottom, and a red square in the middle. 
:: def aadcedddgcabebafbcibafcjbbecfabf(I):
    obj = argmin(objects(I, T, F, F), size)  # Find smallest object
    center_i, center_j = centerofmass(obj)
    box_indices = {(center_i - 1, center_j - 1), (center_i - 1, center_j), (center_i - 1, center_j + 1),
                   (center_i, center_j - 1), (center_i, center_j + 1),
                   (center_i + 1, center_j - 1), (center_i + 1, center_j), (center_i + 1, center_j + 1)}
    O = fill(I, 4, {(center_i - 1, center_j), (center_i, center_j), (center_i + 1, center_j)})  # Central column '4'
    O = fill(O, 6, {(center_i - 1, center_j - 1), (center_i, center_j - 1), (center_i + 1, center_j - 1)})  # Left column '6'
    O = fill(O, 1, {(center_i - 1, center_j + 1), (center_i + 1, center_j + 1)})  # Right column '1' pattern
    O = fill(O, 2, {(center_i, center_j + 1)})  # Right column '2' pattern
    return O
 
15.25, tensor(1.7139), Description: Find the smallest object in the input grid. Then, fill in a vertical column of yellow squares in the center of the object. Fill in the column to the left of the center column with orange squares. Fill in the column to the right of the center column with a pattern of light blue squares on the top and bottom, and a red square in the middle. 
:: def dbfebagfjaeeeadcjcffgejbfgdaddda(I):
    sm_obj = argmin(objects(I, T, F, F), size)
    ci, cj = centerofmass(sm_obj)
    box_p = normalize(shift(sm_obj, (1, 1)))  # Shifted and normalized box pattern
    box = shift(box_p, (ci - 1, cj - 1))  # Position the box
    O = fill(I, 4, {(ci - 1, cj), (ci, cj), (ci + 1, cj)})  # Central column
    O = fill(O, 6, shift(box, (0, -1)))  # Left column
    O = fill(O, 1, {(ci - 1, cj + 1), (ci + 1, cj + 1)})  # Right column '1'
    O = fill(O, 2, {(ci, cj + 1)})  # Right column '2'
    return O
 
4.5, tensor(0.1029), Description: If the shape is light blue or green, fill the area around it with orange. If the shape is red, fill the area around it with yellow, and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. 
:: def efadfifgbgfbeghiagjaiidjhfabhbaf(I):
  key_objects = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in key_objects:
    color_obj = color(obj)
    if color_obj == EIGHT or color_obj == THREE:
      frame = outbox(toindices(obj))
      O = fill(O, SIX, frame)
    if color_obj == TWO:
      frame = outbox(toindices(obj))
      O = fill(O, ONE, frame)
      O = fill(O, color_obj, toindices(obj))
    if color_obj == EIGHT:
      O = fill(O, FOUR, shift(toindices(obj), UP))
      O = fill(O, FOUR, shift(toindices(obj), DOWN))
      O = fill(O, ONE, shift(toindices(obj), (TWO, ONE)))
      O = fill(O, ONE, shift(toindices(obj), (TWO, THREE)))
      O = fill(O, ONE, shift(toindices(obj), (ZERO, THREE)))
      O = fill(O, TWO, shift(toindices(obj), (ONE, THREE)))
  return O 
 
13.25, tensor(0.0924), Description: If the shape is light blue, fill the area around it with orange and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow. 
:: def bcedececafffeabibfebaaceffefbbfc(I):
  key_objects = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(ZERO, shape(I))
  for obj in key_objects:
    obj_color = color(obj)
    if obj_color == EIGHT:
      O = paint(fill(O, SIX, box(shift(toindices(obj), (-ONE, -ONE)))), obj)
      O = fill(O, FOUR, shift(toindices(obj), UP))
      O = fill(O, FOUR, shift(toindices(obj), DOWN))
      O = fill(O, ONE, shift(toindices(obj), (TWO, ONE)))
      O = fill(O, TWO, shift(toindices(obj), (ONE, THREE)))
      O = fill(O, ONE, shift(toindices(obj), (TWO, THREE)))
      O = fill(O, ONE, shift(toindices(obj), (ZERO, THREE)))
    elif obj_color == THREE:
      O = paint(fill(O, SIX, box(shift(toindices(obj), (-ONE, -ONE)))), obj)
    elif obj_color == TWO:
      O = paint(fill(O, ONE, box(shift(toindices(obj), (-ONE, -ONE)))), obj)
  return O
 
3.5, tensor(0.0924), Description: If the shape is light blue, fill the area around it with orange and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow. 
:: def gaffaeheadjfedbeajfcfjedffccaeec(I):
  key_objects = objects(I, True, False, True)
  O = I
  for obj in key_objects:
    if color(obj) == EIGHT:
      O = paint(fill(O, SIX, outbox(toindices(obj))), obj)
      for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        O = fill(O, FOUR, shift(toindices(obj), d))
      O = fill(O, ONE, shift(toindices(obj), (TWO, ONE)))
      O = fill(O, ONE, shift(toindices(obj), (TWO, THREE)))
      O = fill(O, ONE, shift(toindices(obj), (ZERO, THREE)))
      O = fill(O, TWO, shift(toindices(obj), (ONE, THREE)))
    elif color(obj) == THREE:
      O = paint(fill(O, SIX, outbox(toindices(obj))), obj)
    elif color(obj) == TWO:
      O = paint(fill(O, ONE, outbox(toindices(obj))), obj)
  return O
 
16.5, tensor(1.7412), Description: If the shape is blue, fill the area one square to the right and one square down with yellow. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. 
:: def aiajecfhcffdejcbbebjcdafjaidachc(I):
  objs = objects(I, T, T, T)
  for obj in objs:
    val = color(obj)
    if val == 8:
      I = fill(I, 4, backdrop(shift(normalize(obj), (1,1))))
      I = fill(I, 6, difference(backdrop(shift(normalize(obj),(2,2))), backdrop(shift(normalize(obj),(1,1)))))
      I = fill(I, 1, {(lowermost(obj)+2, rightmost(obj)-1), (lowermost(obj)+2, rightmost(obj)), (lowermost(obj)+2, rightmost(obj)+1)})
      I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
    elif val == 3:
      I = fill(I, 6, backdrop(shift(normalize(obj), (1,1))))
    elif val == 2:
      I = fill(I, 1, backdrop(shift(normalize(obj), (1,1))))
  return I
 
8.0, tensor(1.6022), Description: If the shape is a single square, fill the area around it with orange. If the shape is not a single square, fill the area around it with yellow and then fill the shape with the original color. 
:: def ciabdghcahbcecfejdgaaebceiafdggf(I):
  objs = objects(I, T, F, T) # Get all non-background objects
  bg = mostcolor(I) # Identify background color

  # Create a canvas of the same size as the input, filled with the background color
  O = canvas(bg, shape(I)) 

  for obj in objs:
    if size(obj) == 1:  # Special case for single-cell objects
      O = fill(O, 6, outbox(obj))  # Outer expansion with color 6
    else:
      O = fill(O, 4, delta(obj))  # Expand larger objects with color 4
    O = paint(O, obj)  # Maintain the original object color
  return O
 
17.75, tensor(0.1954), Description: Find the first non-zero element in the input grid.  Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def gidjdchdebaiejfejhcaaecfdbaebcch(I):
    non_zero_indices = next(iter(objects(I, T, F, F)))
    ref_i, ref_j = next(iter(non_zero_indices))[1]
    O = I
    for i in range(ref_i - 1, ref_i + 2):
        for j in range(ref_j - 1, ref_j + 2):
            if 0 <= i < len(I) and 0 <= j < len(I[0]):
                if j == ref_j - 1:
                    O = fill(O, 6, {(i, j)})
                elif j == ref_j:
                    O = fill(O, 4, {(i, j)})
                elif j == ref_j + 1 and i != ref_i:
                    O = fill(O, 1, {(i, j)})
                elif j == ref_j + 1 and i == ref_i:
                    O = fill(O, 2, {(i, j)})
    return O
 
18.75, tensor(0.1986), Description: Find the smallest non-zero object in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def ddfaagihdecieafhibdbifacbbbejfed(I):
  obj = argmin(objects(I, T, F, F), size)  # find non-zero object
  ul = ulcorner(obj)
  O = fill(I, 6, shift(
      {(0, 0), (1, 0), (2, 0)}, ul
  ))
  O = fill(O, 4, shift(
      {(0, 1), (1, 1), (2, 1)}, ul
  ))
  O = fill(O, 1, shift(
      {(0, 2), (1, 2), (2, 2)}, ul
  ))
  O = fill(O, 2, shift(
      {(1, 2)}, ul
  ))
  return O
 
15.5, tensor(0.0636), Description: If the shape is light blue, fill the area around it with orange and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow.  Additionally, fill the center four squares of the grid with yellow. 
:: def dbfidcddbigcedbfjeeabbddaaifhhfa(I):
  objs = objects(I, T, T, T)
  bg = mostcolor(I)
  h, w = len(I), len(I[0])

  new_objs = set()
  for obj in objs:
    new_objs.add(
      branch(
        color(obj) == 8, 
        recolor(8, backdrop(obj)), 
        branch(
          color(obj) == 3,
          recolor(6, shift(backdrop(obj), (-1, -1))),
          obj
        )
      )
    )

  obj_2 = first(sfilter(objs, lambda o: color(o) == 2)) if any(color(o) == 2 for o in objs) else None
  if obj_2:
    new_objs.add(recolor(1, shift(backdrop(obj_2), (1, 0))))

  new_objs.add(recolor(4, {(h//2 - 1, w//2), (h//2 + 1, w//2), (h//2, w//2 - 1), (h//2, w//2 + 1)}))

  O = paint(canvas(bg, (h, w)), merge(new_objs))
  return O
 
16.5, tensor(1.7538), Description: If the shape is blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is green or red, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. 
:: def fbabaccbehiaeccaiciccjahajcfacdf(I):
  objs = objects(I, T, T, T)
  for obj in objs:
    v = color(obj)
    I = fill(I, 4 if v == 8 else 6 if v in (3, 2) else 0, backdrop(shift(normalize(obj), (1,1))))
    I = fill(I, 6 if v == 8 else 1 if v == 2 else 0, difference(backdrop(shift(normalize(obj),(2,2))), backdrop(shift(normalize(obj),(1,1)))))
    if v == 8:
      I = fill(I, 1, {(lowermost(obj)+2, j) for j in range(rightmost(obj)-1, rightmost(obj)+2)})
      I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
  return I
 
16.5, tensor(1.7420), Description: If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow. 
:: def fhefggijbafheicfiejicgadcchhbejg(I):
  for obj in objects(I, T, T, T):
    v = color(obj)
    inner_color = branch(v == 8, 4, branch(v == 3, 6, 1))
    outer_color = branch(v == 8, 6, branch(v == 2, 1, 0))
    I = fill(I, inner_color, backdrop(shift(normalize(obj), (1,1))))
    I = fill(I, outer_color, difference(backdrop(shift(normalize(obj),(2,2))), backdrop(shift(normalize(obj),(1,1)))))
    if v == 8:
      I = fill(I, 1, {(lowermost(obj)+2, j) for j in range(rightmost(obj)-1, rightmost(obj)+2)})
      I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
  return I
 
27.25, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def fajjbfedficfebfbjdcbcebbaiccbedb(I):
  # Find the smallest non-zero color
  min_color = min(palette(I) - {0})

  # Find the location of the smallest color
  min_loc = first(ofcolor(I, min_color))

  # Create a 3x3 square patch centered at min_loc
  square_patch = frozenset((min_loc[0] + i - 1, min_loc[1] + j - 1) for i in range(3) for j in range(3))

  # Create the border patch
  border_patch = outbox(square_patch) - square_patch

  # Fill the grid with '4's at the square patch locations
  O = fill(I, 4, square_patch)

  # Fill the grid with '6's at the border patch locations
  O = fill(O, 6, border_patch)

  # Place the '1' and '2' relative to the min_loc
  O = fill(O, 1, frozenset({(min_loc[0] + 2, min_loc[1] + 2)}))
  O = fill(O, 2, frozenset({(min_loc[0] + 2, min_loc[1] + 1)}))
  
  return O
 
19.25, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def ahjfeddbccedeceijefjhbbcedadedeb(I):
  # Find the object containing the smallest color
  min_obj = argmin(objects(I, False, False, True), lambda obj: color(obj))

  # Determine the offset to center the 3x3 square
  offset = subtract((1, 1), ulcorner(min_obj))

  # Create a 3x3 square object
  square_obj = recolor(4, shift(asindices(canvas(0, (3, 3))), offset))

  # Create the border object
  border_obj = recolor(6, difference(outbox(square_obj), toindices(square_obj)))

  # Combine the objects and paint them onto the grid
  O = paint(I, combine(square_obj, border_obj))

  # Place the '1' and '2'
  min_loc = first(toindices(min_obj))
  O = fill(O, 1, frozenset({(min_loc[0] + 2, min_loc[1] + 2)}))
  O = fill(O, 2, frozenset({(min_loc[0] + 2, min_loc[1] + 1)}))

  return O
 
25.0, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def cfjafdfijebfebjejjfgddifjgahdedf(I):
  # Find smallest non-zero color
  c = min(palette(I) - {0})

  # Find location
  loc = first(ofcolor(I, c))

  # Create 3x3 square indices
  square_ind = frozenset((loc[0] + i - 1, loc[1] + j - 1) for i in range(3) for j in range(3))

  # Generate border indices using dneigbors
  border_ind = frozenset(n for p in square_ind for n in dneighbors(p) if n not in square_ind and 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]))

  # Fill grid
  O = fill(I, 4, square_ind) 
  O = fill(O, 6, border_ind)
  O = fill(O, 1, frozenset({(loc[0] + 2, loc[1] + 2)}))
  O = fill(O, 2, frozenset({(loc[0] + 2, loc[1] + 1)}))
  return O
 
15.5, tensor(1.7044), Description: Find the first non-background object in the input grid. Then, fill in a horizontal line of yellow squares in the center of the object. Fill in the vertical line through the center of the object with orange squares. Fill in the squares two squares above and below the center with light blue squares. Fill in the square to the right of the center with a red square. 
:: def jdidhfjheibceccbjafidefidbchfgcf(I):
  obj = next(iter(objects(I, T, F, T) - {mostcolor(asobject(I))}))  # Non-bg object
  ci, cj = centerofmass(obj)
  O = fill(I, 4, connect((ci, cj - 1), (ci, cj + 1)))  # Horizontal '4's
  O = fill(O, 6, connect((ci - 1, cj), (ci + 1, cj)))  # Vertical '6's
  O = fill(O, 1, {(ci, cj - 2), (ci, cj + 2)})  # Corner '1's
  O = fill(O, 2, {(ci, cj + 1)})  # Right marker '2'
  return O
 
14.0, tensor(1.7027), Description: Find the first non-background object in the input grid. Then, fill in a vertical line of orange squares in the center of the object. Fill in the horizontal line through the center of the object with yellow squares. Fill in the squares two squares above and below the center with light blue squares. Fill in the square to the right of the center with a red square. 
:: def ecbbjijhjghaeicbbicijaaajabejbde(I):
  obj = next((obj for obj in objects(I, T, F, T) if len(obj) > 1), None)
  if obj is None:
      return I  # No non-background object found
  top, left = ulcorner(obj)
  bottom, right = lrcorner(obj)
  ci, cj = (top + bottom) // 2, (left + right) // 2
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if abs(i - ci) == 1 and j == cj:
        O = fill(O, 6, {(i, j)})
      elif i == ci and abs(j - cj) == 1:
        O = fill(O, 4, {(i, j)})
      elif i == ci and (j == cj - 2 or j == cj + 2):
        O = fill(O, 1, {(i, j)})
      elif i == ci and j == cj + 1:
        O = fill(O, 2, {(i, j)}) 
  return O
 
4.5, tensor(0.1029), Description: If the shape is light blue or green, fill the area around it with orange. If the shape is red, fill the area around it with yellow, and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. 
:: def hcaaiabgejhbefjfihgeccjejjebjdfa(I):
  O = I
  for obj in objects(I, True, False, True):
    c = color(obj)
    O = paint(fill(O, (SIX if c in (EIGHT, THREE) else ONE if c == TWO else ZERO), outbox(toindices(obj))), obj)
    if c == EIGHT:
      for d in (UP, DOWN):
        O = fill(O, FOUR, shift(toindices(obj), d))
      for offset in ((TWO, ONE), (ONE, THREE), (TWO, THREE), (ZERO, THREE)):
        O = fill(O, ONE, shift(toindices({astuple(*offset)}), ulcorner(toindices(obj))))
  return O
 
15.5, tensor(1.7420), Description: If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow. 
:: def fdfceceffiihejiaaefddhehdbbbfcfb(I):
  def transform_object(I, obj):
    v = color(obj)
    inner_color = {8: 4, 3: 6, 2: 1}.get(v, 0)
    outer_color = {8: 6, 3: 6, 2: 1}.get(v, 0)
    I = fill(I, inner_color, backdrop(shift(normalize(obj), (1,1))))
    I = fill(I, outer_color, difference(backdrop(shift(normalize(obj),(2,2))), backdrop(shift(normalize(obj),(1,1)))))
    if v == 8:
      I = fill(I, 1, {(lowermost(obj)+2, j) for j in range(leftmost(obj), rightmost(obj)+1)})
      I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
    return I
  
  for obj in objects(I, T, T, T):
    I = transform_object(I, obj)
  return I
 
15.75, tensor(1.7420), Description: If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow. 
:: def bcacdbdbfciiefifiihfijddfedadfef(I):
  def border_object(I, obj, inner, outer):
    I = fill(I, inner, backdrop(shift(normalize(obj), (1,1))))
    I = fill(I, outer, difference(backdrop(shift(normalize(obj),(2,2))), backdrop(shift(normalize(obj),(1,1)))))
    return I
  
  for v, inner, outer in [(8, 4, 6), (3, 6, 6), (2, 1, 1)]:
    for obj in colorfilter(objects(I, T, T, T), v):
      I = border_object(I, obj, inner, outer)
      if v == 8:
        I = fill(I, 1, {(lowermost(obj)+2, j) for j in range(leftmost(obj), rightmost(obj)+1)})
        I = fill(I, 2, {(lowermost(obj)+2, rightmost(obj))})
  return I
 
16.0, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def ehijaajecegdeheebdfdhdjadieihgbc(I):
  c = min(palette(I) - {0})
  loc = first(ofcolor(I, c))
  box_start = subtract(loc, (1, 1))
  box_indices = prapply(astuple, interval(box_start[0], box_start[0] + 3, 1), interval(box_start[1], box_start[1] + 3, 1))
  border_indices = difference(box(box_indices), {(box_start[0], box_start[1]), (box_start[0], box_start[1] + 1), (box_start[0], box_start[1] + 2)})
  bottom_decoration = {(loc[0] + 2, loc[1] - 1), (loc[0] + 2, loc[1]), (loc[0] + 2, loc[1] + 1)}
  O = fill(I, 4, box_indices)
  O = fill(O, 6, border_indices)
  O = fill(O, 1, {(loc[0] + 2, loc[1] - 1), (loc[0] + 2, loc[1] + 1)})
  O = fill(O, 2, {(loc[0] + 2, loc[1])})
  return O
 
16.75, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def cjcbcehabfgeefjjbbehbabfcbbjhcig(I):
    c = min(palette(I) - {0})
    loc = first(ofcolor(I, c))
    O = ()
    for i in range(len(I)):
        row = ()
        for j in range(len(I[0])):
            if i == loc[0] - 1 and j >= loc[1] - 1 and j <= loc[1] + 1:
                row += (6,)
            elif i >= loc[0] and i <= loc[0] + 1 and j >= loc[1] - 1 and j <= loc[1] + 1:
                if i == loc[0] + 1:
                    if j == loc[1] - 1 or j == loc[1] + 1:
                        row += (1,)
                    elif j == loc[1]:
                        row += (2,)
                    else:
                        row += (0,)
                else:
                    row += (4,)
            elif (i == loc[0] or i == loc[0] + 1) and (j == loc[1] - 2 or j == loc[1] + 2):
                row += (6,)
            else:
                row += (I[i][j],)
        O += (row,)
    return O
 
14.5, tensor(1.6713), Description: If the shape is light blue, fill the area around it with orange. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow. Additionally, fill the center four squares of the grid with yellow. 
:: def difcdaebefeaeafbabdfahbbbgbeabdf(I):
  objs = objects(I, T, T, T)
  bg = mostcolor(I)
  h, w = len(I), len(I[0])

  new_objs = set()
  for obj in objs:
    if color(obj) == 8:
      new_objs.add(recolor(8, backdrop(obj)))
    elif color(obj) == 3:
      new_objs.add(recolor(6, shift(backdrop(obj), (-1, -1))))
    else:
      new_objs.add(obj)

  obj_2 = next((obj for obj in objs if color(obj) == 2), None) 
  if obj_2:
    i, j = centerofmass(obj_2)
    new_objs.add(recolor(1, {(i+1, j-1), (i+1, j), (i+1, j+1)}))

  center_loc = (h // 2, w // 2)
  cross = {(center_loc[0] - 1, center_loc[1]), (center_loc[0] + 1, center_loc[1]),
           (center_loc[0], center_loc[1] - 1), (center_loc[0], center_loc[1] + 1)}
  new_objs.add(recolor(4, frozenset(cross)))

  O = paint(canvas(bg, (h, w)), merge(new_objs))
  return O
 
2.0, tensor(0.0849), Description: If the shape is light blue or green, fill the area around it with orange. If the shape is red, fill the area around it with yellow, and then fill the shape with light blue. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. Additionally, if the shape is light blue, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. Also, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. 
:: def bfiijebjecceehfcabgjhjghgjbadbea(I):
  O = I
  for obj in objects(I, True, False, True):
    c = color(obj)
    if c == EIGHT or c == THREE:
      O = paint(fill(O, SIX, outbox(toindices(obj))), obj)
    if c == TWO:
      O = paint(fill(O, ONE, outbox(toindices(obj))), obj)
      O = fill(O, ONE, toindices(obj))
    if c == EIGHT:
      O = fill(O, FOUR, difference(inbox(toindices(obj)), toindices(obj)))
      for offset in ((TWO, ONE), (ONE, THREE), (TWO, THREE), (ZERO, THREE)):
        O = fill(O, ONE, shift(toindices(initset(astuple(*offset))), ulcorner(toindices(obj))))
  return O
 
1.5, tensor(0.0862), Description: If the shape is light blue, fill the area around it with orange, then fill the area inside the shape with yellow, and then fill the area one square to the right and one square down with light blue, and then fill the area one square to the left and one square down with light blue, and then fill the area one square to the right and one square up with light blue, and then fill the area one square to the left and one square up with light blue. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow. 
:: def ihegaffcedgeeffhjddeafbjcadaabgb(I):
    def process_color(O, c, fill_color=None, additional_fills=None):
        for obj in colorfilter(objects(I, True, False, True), c):
            O = paint(fill(O, SIX if c in (EIGHT, THREE) else ONE, outbox(toindices(obj))), obj)
            if fill_color:
                O = fill(O, fill_color, difference(inbox(toindices(obj)), toindices(obj)))
            if additional_fills:
                for offset in additional_fills:
                    O = fill(O, ONE, shift(toindices(initset(astuple(*offset))), ulcorner(toindices(obj))))
        return O
    O = I
    O = process_color(O, EIGHT, FOUR, ((TWO, ONE), (ONE, THREE), (TWO, THREE), (ZERO, THREE)))
    O = process_color(O, THREE)
    O = process_color(O, TWO, ONE)
    return O
 
15.25, tensor(1.7420), Description: If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. If the shape is green, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is red, fill the area one square to the right and one square down with yellow. 
:: def bcdbdegjbbgeegdabeeebfdfecbdffgd(I):
  objs = objects(I, T, T, T)
  for obj in objs:
    c = color(obj)
    I = fill(I, branch(c == 8, 4, 1), backdrop(shift(normalize(obj), (1, 1))))
    I = fill(I, branch(c == 8 or c == 3, 6, 0), difference(backdrop(shift(normalize(obj), (2, 2))), backdrop(shift(normalize(obj), (1, 1)))))
    if c == 8:
      I = fill(I, 1, {(lowermost(obj) + 2, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
      I = fill(I, 2, {(lowermost(obj) + 2, rightmost(obj))})
  return I
 
12.75, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def adajffbfccbeebfejaafbfhcbhdfjfig(I):
  c = min(palette(I) - {0})
  loc = first(ofcolor(I, c))

  # Construct frame using nested loops
  frame = frozenset((loc[0] + i - 1, loc[1] + j - 1) for i in range(3) for j in range(3))
  border = difference(box(frame), {(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1]), (loc[0] - 1, loc[1] + 1)})

  # Construct decoration directly
  decoration = {(loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1]), (loc[0] + 1, loc[1] + 1)}

  O = fill(I, 4, frame)
  O = fill(O, 6, border)
  O = fill(O, 1, {d for d in decoration if d != (loc[0] + 1, loc[1])})
  O = fill(O, 2, {(loc[0] + 1, loc[1])}) 
  return O
 
51.5, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def bfdbgajeejaiefjciehafebbgacdffgd(I):
  c = min(palette(I) - {0})
  loc = first(ofcolor(I, c))

  # Frame and border using conditional checks
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if abs(i - loc[0]) <= 1 and abs(j - loc[1]) <= 1:
        O = fill(O, 4, {(i, j)})
      elif abs(i - loc[0]) <= 1 or abs(j - loc[1]) <= 1:
        O = fill(O, 6, {(i, j)})
  
  # Decoration using direct assignment
  O = fill(O, 1, {(loc[0] + 1, loc[1] - 1), (loc[0] + 1, loc[1] + 1)})
  O = fill(O, 2, {(loc[0] + 1, loc[1])})
  return O 
 
12.75, tensor(1.6245), Description: Find the smallest non-zero color in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Left column: orange
* Center column: yellow
* Right column: light blue on the top and bottom, red in the middle. 
:: def efabcdbbfjegecgabdffjgceecfbdcbj(I):
  c = min(palette(I) - {0})
  loc = first(ofcolor(I, c))

  # Frame and border creation using box and difference
  frame = box(shift({(0, 0)}, subtract(loc, (1, 1))))
  border = difference(frame, {(loc[0] - 1, loc[1] - 1), (loc[0] - 1, loc[1]), (loc[0] - 1, loc[1] + 1)})

  # Decoration using shift and tuple unpacking
  decoration_base = {(0, -1), (0, 0), (0, 1)}
  decoration = shift(decoration_base, (loc[0] + 1, loc[1]))

  O = I 
  for i, j in frame:
    O = fill(O, 4, {(i, j)})
  for i, j in border:
    O = fill(O, 6, {(i, j)})
  for i, (di, dj) in enumerate(decoration_base):
    O = fill(O, 1 if i != 1 else 2, {(loc[0] + 1 + di, loc[1] + dj)})

  return O 
 
19.0, tensor(0.2049), Description: Find the largest object in the input grid, assuming it contains the target value. Then, fill in a 3x3 square around the center of the object with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue 
:: def dadafiafeicaebcjbdbcgbfiefccbccd(I):
  obj = argmax(objects(I, T, F, T), size)  # Find the largest object, assuming it contains the target value
  ci, cj = centerofmass(obj)
  O = fill(canvas(mostcolor(I), shape(I)), 6, box({(ci - 1, cj - 2), (ci + 1, cj + 2)}))  # Outer box
  O = fill(O, 4, {(ci - 1, cj - 1), (ci - 1, cj), (ci - 1, cj + 1), (ci, cj - 1), (ci, cj + 1), (ci + 1, cj - 1), (ci + 1, cj), (ci + 1, cj + 1)})  # Horizontal and Vertical '4's
  O = fill(O, 1, {(ci - 1, cj - 2), (ci - 1, cj + 2), (ci + 1, cj - 2), (ci + 1, cj + 2)})  # Corners
  return O
 
19.0, tensor(0.2049), Description: Find the largest object in the input grid, assuming it contains the target value. Then, fill in a 3x3 square around the center of the object with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue 
:: def agbceihdaejeebfibeiaaahhjjadcbcd(I):
  obj = argmax(objects(I, T, F, T), size)
  ci, cj = centerofmass(obj)
  O = canvas(mostcolor(I), shape(I))
  for i in range(ci - 1, ci + 2):
    for j in range(cj - 2, cj + 3):
      if 0 <= i < len(I) and 0 <= j < len(I[0]):
        if abs(i - ci) + abs(j - cj) == 2: # Corners
          O = fill(O, 1, {(i, j)})
        elif abs(i - ci) + abs(j - cj) <= 1: # Center and '4's
          O = fill(O, 4, {(i, j)})
        elif abs(i - ci) + abs(j - cj) == 3: # Outer box 
          O = fill(O, 6, {(i, j)})
  return O
 
19.5, tensor(0.2049), Description: Find the largest object in the input grid, assuming it contains the target value. Then, fill in a 3x3 square around the center of the object with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue 
:: def gadchabaaajieahbbbiebajfaddebeca(I):
  obj = argmax(objects(I, T, F, T), size)
  ci, cj = centerofmass(obj)
  bg = mostcolor(I)
  top = canvas(bg, (1, 5))
  top = fill(top, 6, {(0, 0), (0, 4)})
  top = fill(top, 4, {(0, 1), (0, 3)})
  middle = canvas(bg, (1, 5))
  middle = fill(middle, 6, {(0, 0), (0, 4)})
  middle = fill(middle, 4, {(0, 1), (0, 3)})
  middle = fill(middle, 1, {(0, 2)})
  pattern = vconcat(top, vconcat(middle, top))
  O = canvas(bg, shape(I))
  O = paint(O, shift(asobject(pattern), (ci-1, cj-2)))
  return O
 
19.0, tensor(0.2049), Description: Find the largest object in the input grid, assuming it contains the target value. Then, fill in a 3x3 square around the center of the object with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue 
:: def cicciaacfaafebdcbcbfadcdibhcfecc(I):
  obj = argmax(objects(I, T, F, T), size)
  ci, cj = centerofmass(obj)
  O = canvas(mostcolor(I), shape(I))
  pattern = ((6, 4, 4, 4, 6), (6, 4, 1, 4, 6), (6, 4, 4, 4, 6))
  pi, pj = 1, 2 # Center of the pattern
  for i in range(len(pattern)):
    for j in range(len(pattern[0])):
      if 0 <= ci - pi + i < len(I) and 0 <= cj - pj + j < len(I[0]):
        O = fill(O, pattern[i][j], {(ci - pi + i, cj - pj + j)})
  return O
 
15.0, tensor(1.6713), Description: If the shape is light blue, fill the area around it with orange. If the shape is green, fill the area around it with orange. If the shape is red, fill the area around it with yellow. Additionally, fill the center four squares of the grid with yellow. 
:: def cbhcbdaaeeaeecddbbjaacaagadadjfj(I):
  objs = objects(I, T, T, T)
  bg = mostcolor(I)
  h, w = len(I), len(I[0])

  new_objs = set()
  for obj in objs:
    new_color = 6 if color(obj) == 3 else color(obj)
    new_objs.add(
        recolor(
            new_color, 
            branch(
                color(obj) == 8, 
                backdrop(obj), 
                shift(backdrop(obj), (-1, -1))
            )
        )
    )

  obj_2 = first(sfilter(objs, lambda o: color(o) == 2)) if any(color(o) == 2 for o in objs) else None
  if obj_2:
    i, j = centerofmass(obj_2)
    new_objs.add(recolor(1, {(i + 1, j - 1), (i + 1, j), (i + 1, j + 1)}))

  new_objs.add(recolor(4, {(h//2 - 1, w//2), (h//2 + 1, w//2), (h//2, w//2 - 1), (h//2, w//2 + 1)}))

  O = paint(canvas(bg, (h, w)), merge(new_objs))
  return O
 
11.0, tensor(0.1397), Description: If the shape is light blue, fill the area around it with yellow, then fill the shape with light blue. If the shape is red, fill the area around it with yellow. If the shape is green, fill the area around it with orange. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. Additionally, if the shape is light blue, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. Also, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. 
:: def cjabdabfaddjeceajbegadaaajcfecad(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    if color(obj) == EIGHT:
      O = fill(O, FOUR, difference(inbox(toindices(obj)), toindices(obj)))
      O = paint(fill(O, SIX, outbox(toindices(obj))), recolor(FOUR, obj))
    else:
      O = paint(fill(O, ONE, outbox(toindices(obj))), obj)
    if color(obj) in (TWO, EIGHT):
      O = fill(O, ONE, toindices(obj))
  return O
 
10.5, tensor(0.1161), Description: If the shape is light blue, fill the area around it with yellow, then fill the area inside the shape with light blue. If the shape is red, fill the area around it with yellow. If the shape is green, fill the area around it with orange. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. Additionally, if the shape is light blue, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. Also, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. 
:: def bbgebjchaefdefebjahhabiedeadaabe(I):
  return paint(
      fill(
          I,
          ONE,
          mapply(
              lambda obj: branch(
                  color(obj) == EIGHT,
                  difference(inbox(toindices(obj)), toindices(obj)),
                  outbox(toindices(obj)),
              ),
              objects(I, True, False, True),
          ),
      ),
      recolor(
          FOUR,
          merge(
              sfilter(
                  objects(I, True, False, True),
                  lambda obj: color(obj) == EIGHT,
              )
          ),
      ),
  )
 
16.25, tensor(1.7459), Description: If the shape is light blue, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange, and then fill the area three squares to the right and three squares down with light blue. If the shape is red, fill the area one square to the right and one square down with yellow, and then fill the area two squares to the right and two squares down with orange. If the shape is green, fill the area one square to the right and one square down with yellow. 
:: def dfebafcdbbaeecehaebaaidaegieeeca(I):
    for obj in objects(I, T, T, T):
        c = color(obj)
        I = fill(I, 6, backdrop(shift(normalize(obj), (1, 1))))
        if c == 8:
            I = fill(I, 4, backdrop(obj))
            I = fill(I, 1, {(lowermost(obj) + 2, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
            I = fill(I, 2, {(lowermost(obj) + 2, center(obj)[1])})
        elif c == 2:
            I = fill(I, 1, {(lowermost(obj) + 2, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
            I = fill(I, 2, {(lowermost(obj) + 2, center(obj)[1])})
    return I
 
17.75, tensor(0.2027), Description: Find the largest object in the input grid, assuming it contains the target value. Then, fill in a 3x3 square around the center of the object with the following colors:
* Outer box: orange
* Inner box: yellow
* Corners: light blue
* Arrowhead: red 
:: def chfadcaiacjieidcajhehhjfidjccdfh(I):
    obj = extract(objects(I, T, F, T), lambda obj: size(obj) > 1 or index(I, first(toindices(obj))) != 0)
    ref_i, ref_j = centerofmass(obj)
    O = paint(canvas(0, shape(I)), obj)
    O = fill(O, 6, box(shift(obj, (-1, -1))))  # Outer box
    O = underfill(O, 4, box(obj))  # Inner box
    O = fill(O, 1, {(ref_i - 1, ref_j - 2), (ref_i - 1, ref_j + 2), (ref_i + 1, ref_j - 2), (ref_i + 1, ref_j + 2)})  # Corners
    O = fill(O, 2, {(ref_i, ref_j + 1)})  # Arrowhead
    return O
 
16.5, tensor(0.1942), Description: Find the first non-background object in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Outer box: orange
* Inner box: yellow
* Corners: light blue
* Arrowhead: red 
:: def heeededfefcjechejbdeciiahbfaafec(I):
    obj = extract(objects(I, T, F, T), lambda obj: any(v != 0 for v, _ in obj))
    O = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            if v != 0:
                O = fill(O, 6, box({(i - 1, j - 1), (i + 1, j + 1)}))
                O = underfill(O, 4, box({(i, j)}))
                O = fill(O, 1, {(i - 1, j - 2), (i - 1, j + 2), (i + 1, j - 2), (i + 1, j + 2)})
                O = fill(O, 2, {(i, j + 1)})
    return O
 
17.25, tensor(0.1942), Description: Find the first non-background object in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Outer box: orange
* Inner box: yellow
* Corners: light blue
* Arrowhead: red 
:: def jdiicchefggbehgeijfbgcejffaffdja(I):
    ref_i, ref_j = next((i, j) for i, r in enumerate(I) for j, v in enumerate(r) if v != 0)
    O = paint(canvas(0, shape(I)), {(I[ref_i][ref_j], (ref_i, ref_j))})
    O = fill(O, 6, box({(ref_i - 1, ref_j - 2), (ref_i + 1, ref_j + 2)}))
    O = underfill(O, 4, box({(ref_i, ref_j)}))
    O = fill(O, 1, {(ref_i - 1, ref_j - 2), (ref_i - 1, ref_j + 2), (ref_i + 1, ref_j - 2), (ref_i + 1, ref_j + 2)})
    O = fill(O, 2, {(ref_i, ref_j + 1)})
    return O
 
17.75, tensor(0.2038), Description: Find the first non-background object in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue
* Arrowhead: red 
:: def gcjdbcheefbdebfcjhecccidcfbbbhbd(I):
    obj = extract(objects(I, T, F, F), lambda obj: len(obj) > 0)
    ref_i, ref_j = ulcorner(obj)
    O = paint(canvas(0, shape(I)), obj)
    for di in range(-1, 2):
        for dj in range(-2, 3):
            if (di, dj) != (0, 0):
                value = 6 if abs(di) == 1 and abs(dj) == 2 else (4 if abs(di) + abs(dj) == 1 else (1 if abs(di) == 1 and abs(dj) == 2 else (2 if dj == 1 and di == 0 else 0)))
                O = fill(O, value, {(ref_i + di, ref_j + dj)})
    return O
 
15.25, tensor(0.2038), Description: Find the first non-background object in the input grid. Then, fill in a 3x3 square around that element with the following colors:
* Outer box: orange
* Horizontal and Vertical lines: yellow
* Corners: light blue
* Arrowhead: red 
:: def djfbfdeegfcaebjcajffbcabiddcjgdc(I):
    obj = next(filter(lambda obj: len(obj) > 0, objects(I, T, F, F)))
    min_i, min_j = ulcorner(obj)
    max_i, max_j = lrcorner(obj)
    O = canvas(0, shape(I))
    for i in range(len(I)):
        for j in range(len(I[0])):
            if min_i - 1 <= i <= max_i + 1 and min_j - 2 <= j <= max_j + 2:
                if (i == min_i - 1 or i == max_i + 1) and (j == min_j - 2 or j == max_j + 2):
                    O = fill(O, 1, {(i, j)})
                elif (i == min_i - 1 or i == max_i + 1) or (j == min_j - 2 or j == max_j + 2):
                    O = fill(O, 6, {(i, j)})
                elif min_i <= i <= max_i and min_j <= j <= max_j:
                    O = fill(O, I[i][j], {(i, j)})
                elif i == min_i and j == min_j + 1:
                    O = fill(O, 2, {(i, j)})
                else:
                    O = fill(O, 4, {(i, j)})
    return O
 
0.0, tensor(0.0960), Description: If the shape is red, fill the area around it with yellow, then fill the shape with light blue. If the shape is light blue or green, fill the area around it with orange. If the shape is yellow, fill the area around it with light blue and then fill the shape with red. Additionally, if the shape is light blue, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. Also, fill the area one square above and one square to the right with light blue, one square below and one square to the right with light blue, one square above and one square to the left with light blue, and one square below and one square to the left with light blue. 
:: def igeghefhacgaejdbadaccfgfegcjbcee(I):
  def process_object(O, obj):
    c = color(obj)
    if c == TWO:
      O = fill(O, ONE, toindices(obj))
    elif c in (EIGHT, THREE):
      O = fill(O, SIX, outbox(toindices(obj)))
    if c == EIGHT:
      O = fill(O, FOUR, difference(inbox(toindices(obj)), toindices(obj)))
    return paint(O, obj)

  O = fill(
      I,
      ONE,
      mapply(outbox, apply(toindices, objects(I, True, False, True))),
  )
  for obj in objects(I, True, False, True):
    O = process_object(O, obj)
  return O
 
