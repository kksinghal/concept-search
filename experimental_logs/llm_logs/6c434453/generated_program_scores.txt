28.5, tensor(1.7856), Description: Move each colored shape to the bottom right corner of the grid, keeping the original color. 
:: def hbhfdjacghecejhfjdhdcdecdedbebbe(I):
  objs = objects(I, T, F, T)  # Extract objects, excluding background
  shifted_objs = frozenset(shift(obj, (lowermost(obj), rightmost(obj))) for obj in objs) # Example shift logic, needs refinement
  O = paint(canvas(ZERO, shape(I)), merge(shifted_objs)) # Paint on a blank canvas
  return O
 
26.5, tensor(1.7889), Description: Copy the input grid. Find the two largest objects.  Mirror the second largest object horizontally and place it at the original location of the second largest object. The second largest object should be moved to the center of the largest object.  The colors of the objects should remain the same. 
:: def idhgffheahbgebbbacgabbdcdadeddfa(I):
  # Find the two largest objects
  obj1 = argmax(objects(I, T, F, T), size)
  obj2 = argmax(remove(obj1, objects(I, T, F, T)), size)
  
  # Get the relative position of the second largest object
  rel_pos = position(obj2, obj1)

  # Calculate the new position for the second largest object
  new_pos = add(centerofmass(obj1), multiply(rel_pos, shape(obj2))) 
  
  # Create the new object by mirroring and placing it at the original location
  new_obj = recolor(TWO, shift(hmirror(obj2), centerofmass(obj2)))

  # Construct the output grid
  O = paint(paint(canvas(ZERO, shape(I)), obj1), shift(obj2, subtract(new_pos, centerofmass(obj2))))
  O = paint(O, new_obj)
  return O 
 
22.5, tensor(1.7889), Description: Copy the input grid. Find the two largest objects. Mirror the second largest object horizontally and place it at the original location of the second largest object. The second largest object should be moved to the center of the largest object. The colors of the objects should remain the same. 
:: def cdcibddaafeiebiabhdcecffacebeead(I):
  # Find objects, sort by size, and extract the top two
  objs = order(objects(I, T, F, T), size)
  obj1, obj2 = objs[-1], objs[-2]
  
  # Mirror the second largest object
  mirrored_obj2 = hmirror(obj2)

  # Calculate the offset to position the mirrored object
  offset = subtract(centerofmass(obj1), centerofmass(mirrored_obj2))
  
  # Paint the objects onto the output grid
  O = paint(canvas(ZERO, shape(I)), obj1)
  O = paint(O, shift(obj2, offset))
  O = paint(O, recolor(TWO, shift(mirrored_obj2, offset)))
  return O
 
27.5, tensor(1.7889), Description: Copy the input grid. Find the two largest objects. Mirror the second largest object horizontally and place it at the original location of the second largest object. The second largest object should be moved to the center of the largest object. The colors of the objects should remain the same. 
:: def dghgejdecbceebccjhfabbccaghdddjh(I):
    # Extract objects based on color
    obj1 = extract(objects(I, T, F, T), lambda obj: color(obj) == ONE)
    obj2 = argmax(remove(obj1, objects(I, T, F, T)), size)
    
    # Calculate the new position of the second object
    new_pos = add(centerofmass(obj1), position(obj2, obj1))

    # Create a new object by mirroring the shape of the second object
    new_obj = recolor(TWO, hmirror(shift(obj2, subtract(centerofmass(obj2), (0, width(obj2))))))
    
    # Assemble the final grid
    O = paint(canvas(ZERO, shape(I)), obj1)
    O = paint(O, shift(obj2, subtract(new_pos, centerofmass(obj2))))
    O = paint(O, shift(new_obj, subtract(centerofmass(obj1), centerofmass(new_obj))))
    return O
 
33.5, tensor(1.7893), Description: Copy the input grid. Find the two largest objects. Mirror the second largest object horizontally and place it at the original location of the second largest object. The second largest object should be moved to the top-right corner of the largest object. The colors of the objects should remain the same. 
:: def eheaccigfjehebefbeebddfbcfhfhjec(I):
    # Find largest object and others
    largest_obj = argmax(objects(I, T, F, T), size)
    other_objs = remove(largest_obj, objects(I, T, F, T))
    
    # Find the second largest object
    second_largest_obj = argmax(other_objs, size)

    #  Move the second largest object to the top-right of the largest
    new_pos = add(urcorner(largest_obj), (1, 1))
    moved_obj = shift(second_largest_obj, subtract(new_pos, ulcorner(second_largest_obj)))

    # Create a new object that's a horizontally mirrored version of the second largest
    mirrored_obj = recolor(TWO, hmirror(second_largest_obj))

    # Place the mirrored object at the original location of the second largest
    placed_mirrored_obj = shift(mirrored_obj, subtract(centerofmass(second_largest_obj), centerofmass(mirrored_obj)))
    
    # Combine all the objects onto a blank canvas
    O = paint(canvas(ZERO, shape(I)), largest_obj)
    O = paint(O, moved_obj)
    O = paint(O, placed_mirrored_obj)
    return O
 
27.0, tensor(1.7939), Description: Copy the input grid. For each object in the grid, if it's red, move it down one space. If it's any other color, move it up one space and change its color to red. 
:: def ajdjhbcgeabcebcbahigbbfijcbjddbc(I):
  # Identify non-background objects
  x1 = objects(I, T, F, T)
  
  # Process objects based on color
  O = I
  for obj in x1:
    c = color(obj)
    if c == 2:
      O = underpaint(O, shift(obj, DOWN))
    else:
      O = underpaint(O, recolor(2, shift(obj, UP)))
  return O
 
72.5, tensor(1.7595), Description: Copy the input grid. Find the largest connected object and move it one space to the right. Change the color of the moved object to red. 
:: def geieichcghjbefafafejhagffgbhcehf(I):
  objs = objects(I, True, False, False) # Identify connected objects
  target = argmax(objs, size) if len(objs) > 0 else initset(((0, (0,0)),)) # Find largest object
  moved = shift(target, (0,1)) # Move object right
  O = paint(fill(I, 0, target), recolor(2, moved)) # Paint moved object with color 2
  return O
 
17.0, tensor(1.5409), Description: Copy the input grid. Find the smallest object with the least frequent color (or color 1 if there's only one color). Move that object one space to the right and change its color to red. 
:: def hcabaecaabedeacdjfeaccdieeeejhdg(I):
  target_color = leastcolor(I) if len(palette(I)) > 1 else 1 # Find the least frequent color, default to 1
  target = first(sizefilter(objects(I, True, False, False), 1)) if colorcount(I, target_color) > 0 else initset(((1, (0,0)),)) # Find an object of size 1 with target color
  moved = shift(target, (0,1))
  O = paint(fill(I, 0, target), recolor(2, moved))
  return O
 
17.0, tensor(1.7560), Description: Copy the input grid. Find the smallest connected object and move it one space to the right. Change the color of the moved object to red. 
:: def cdjfjcfdadiceaacigfifddgdbaiefff(I):
  target = argmin(objects(I, True, False, False), size) if len(objects(I, True, False, False)) > 0 else initset(((0, (0,0)),)) # Find smallest object
  right_neighbor = shift(target, (0,1))
  O = paint(fill(I, 0, target), recolor(2, right_neighbor))
  return O
 
16.0, tensor(1.7890), Description: Copy the input grid. Swap the colors of the largest and smallest objects. Move the largest object one space to the right and one space down. The colors of the objects should remain the same. 
:: def diiddibehfabebadicfbjeeeiaefbgjd(I):
  # Identify largest and smallest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  smallest = argmin(objs, size)

  # Swap colors
  I = replace(I, ONE, THREE) # Temporary color to avoid conflicts
  I = replace(I, color(largest), TWO) 
  I = replace(I, color(smallest), ONE)
  I = replace(I, THREE, ONE)

  # Shift largest object 
  I = move(I, recolor(TWO, largest), (ONE, ONE))

  return I
 
15.5, tensor(1.7887), Description: Copy the input grid. Find the largest and smallest objects. Swap the colors of the largest and smallest objects. Move the largest object one space to the right and one space down. The colors of the objects should remain the same. 
:: def hhgbifffbcihedffjjjchaiedjbfbgeh(I):
  # Identify objects based on size
  objs = objects(I, T, F, T)
  largest_size = size(argmax(objs, size))
  smallest_size = size(argmin(objs, size))
  largest = extract(objs, lambda o: size(o) == largest_size)
  smallest = extract(objs, lambda o: size(o) == smallest_size)

  # Direct recoloring without temporary color
  O = canvas(ZERO, shape(I))
  O = paint(O, recolor(TWO, largest))
  O = paint(O, recolor(ONE, smallest))
  O = paint(O, toobject(delta(combine(toindices(largest), toindices(smallest))), I))

  # Shift 
  O = move(O, recolor(TWO, largest), (ONE, ONE))
  return O
 
12.0, tensor(1.7080), Description: Copy the input grid. Find the largest object and change its color to red. Change the color of all other objects to blue. Move the largest object one space to the right and one space down. The colors of the objects should remain the same. 
:: def egicdggbbbdbeagjabedeceffcbdfddj(I):
  # Identify and recolor objects
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, recolor(TWO if size(obj) == size(argmax(objs, size)) else ONE, obj))

  # Extract and shift largest object
  largest = extract(objects(O, T, F, T), lambda o: color(o) == TWO)
  O = move(O, largest, (ONE, ONE))
  return O 
 
22.5, tensor(1.8277), Description: Copy the input grid. Find the most frequent color and fill the output grid with that color. Then, find the object with color 1 and place it in the top left corner of the output grid. Find the object with color 2 and move it one space down. Then, fill the output grid with the most frequent color again, but only in the areas where the color 2 object overlaps with the most frequent color. 
:: def cfdahffcafdaebadibbhaaafcjaafaec(I):
    return cellwise(
        fill(canvas(2, shape(I)), mostcolor(I), shift(ofcolor(I, 1), (0, 0))),
        fill(canvas(mostcolor(I), shape(I)), 2, shift(ofcolor(I, 2), DOWN)),
        mostcolor(I)
    )
 
20.5, tensor(1.7753), Description: Copy the input grid. For each cell with color 1, if it's possible to move it one space to the right (without going out of bounds), remove the original cell and paint the moved cell with color 2. 
:: def bfjjabjchgddebjjafghcibhadfaebbe(I):
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:  # Found a cell with color 1
        if 0 <= i < len(I) and 0 <= j+1 < len(row) and I[i][j+1] == 0: # Check if move is valid
          I = fill(I, 0, ((i,j),))  # Remove the original cell
          I = fill(I, 2, ((i,j+1),)) # Paint the moved cell with color 2
        break  # Stop searching after processing one cell with color 1
  return I
 
16.0, tensor(1.7698), Description: Copy the input grid. Find the top-left most occurrence of color 1 in the grid. If found, remove the original cell and paint the cell to the right with color 2, only if the move is within the grid boundaries. 
:: def dbbebehbddbfebabibbgbjgacijejhea(I):
  # Find the top-left most occurrence of 1 in the grid
  target_loc = next(((i,j) for i, row in enumerate(I) for j, val in enumerate(row) if val == 1), None)
  
  if target_loc:
    i, j = target_loc
    I = fill(I, 0, ((i,j),))  # Clear the original cell
    
    # Paint the moved cell only if it's within the grid boundaries
    if 0 <= i < len(I) and 0 <= j+1 < len(I[0]):
      I = fill(I, 2, ((i, j+1),)) 
  return I
 
22.5, tensor(1.7832), Description: Copy the input grid. For each colored object, normalize its position (move it to the top-left corner of the grid) and change its color to red. Then, shift the normalized object to the top-left corner of its original position in the input grid. 
:: def ejcfdbdaggceeccajijdgdghihbfebji(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    shifted_obj = normalize(obj)
    new_obj = recolor(TWO, shifted_obj)
    O = paint(O, shift(new_obj, ulcorner(toindices(obj))))
  return O
 
24.5, tensor(1.7886), Description: Copy the input grid. For each colored object, move it to the top-left corner of the grid, keeping the original color. 
:: def gffffdfagcfiefjjjfhdcgjjgedcfcfc(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, F, T):
        ul = ulcorner(obj)
        for v, (i, j) in obj:
            O = paint(O, {(TWO, (i - ul[0], j - ul[1]))})
    return O
 
20.0, tensor(1.7590), Description: Copy the input grid. Find the most frequent color and replace it with black. For each colored object, normalize its position (move it to the top-left corner of the grid) and change its color to red. Then, shift the normalized object to the top-left corner of its original position in the input grid. 
:: def hijhjhaebbefeacbaabhfcjdabdiacdd(I):
    objs = objects(I, T, F, T)
    O = replace(I, mostcommon(I), ZERO)
    for obj in objs:
        O = underpaint(O, recolor(TWO, normalize(shift(obj, invert(ulcorner(obj))))))
    return O
 
28.0, tensor(1.7625), Description: Copy the input grid. For each colored object, move it to the top-left corner of the grid, keeping the original color. Then, shift the object back to its original position in the input grid, but change its color to red. 
:: def jdaiaeccbicieaadbifiicbfcaaebfeb(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, F, T):
        offset = subtract(centerofmass(obj), centerofmass(normalize(obj)))
        O = paint(O, recolor(TWO, shift(obj, offset)))
    return O
 
24.5, tensor(1.7811), Description: Copy the input grid. Find the largest and smallest objects. Change the color of both the largest and smallest objects to red. Move the largest object one space to the right and one space down. 
:: def baifdjeabhafeibjbebjjhbfbcjceeed(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  smallest = argmin(objs, size)
  
  # Construct output grid
  O = canvas(ZERO, shape(I))
  O = paint(O, recolor(TWO, shift(largest, (1,1))))
  O = paint(O, recolor(TWO, smallest))
  return O
 
20.0, tensor(1.6358), Description: Copy the input grid. Find the most frequent color and replace it with black. Find the largest object and change its color to red. Move the largest object one space to the right and one space down. Find the smallest object and change its color to red. 
:: def eifbefdcfcabeeiijgaceajhfjjbacgi(I):
  # Modify existing grid
  O = replace(I, mostcommon(I), ZERO)
  O = paint(O, recolor(TWO, shift(argmax(objects(O, T, F, T), size), (1,1))))
  O = paint(O, recolor(TWO, argmin(objects(O, T, F, T), size)))
  return O
 
34.5, tensor(1.3331), Description: Copy the input grid. For each colored object, move it one space down and change its color to red. The background color should remain the same. 
:: def hdgeafhcdfgfeddbiebijfabcjadcebb(I):
  # 1. Extract objects
  objs = objects(I, T, F, T) 

  # 2. Find the background color
  bg_color = mostcolor(I)

  # 3. Create a canvas filled with the background color
  O = canvas(bg_color, shape(I))

  # 4. Iterate through objects, shift down, and paint
  for obj in objs:
    O = paint(O, shift(recolor(2, obj), DOWN)) 

  return O
 
22.0, tensor(1.8261), Description: Copy the input grid. Move the entire input grid down one space. Then, for each colored square in the input grid, replace the corresponding square in the output grid with the original color from the input grid. The background color should remain the same. 
:: def ecjhfcfabfgjefahjfadgehccdbjbefd(I):
  # 1. Create output grid with background color
  O = canvas(mostcolor(I), shape(I))
  
  # 2. Paint all objects onto the output grid
  O = paint(O,  shift(asobject(I), DOWN))

  # 3. Overwrite shifted objects with original colors
  return cellwise(I, O, mostcolor(I))
 
28.0, tensor(1.7664), Description: Copy the input grid. For each colored square, move it one space up. If the square is already in the top row, leave it in place. Change the color of the moved squares to red. 
:: def hcagccciecafefbcafceeaebfjacjccf(I):
  # 1. Find shifted object indices
  shifted_indices = difference(asindices(I), shift(asindices(I), UP))

  # 2. Create output grid by mapping colors based on indices
  return tuple(
      tuple(
          2 if (i, j) in shifted_indices else I[i][j] 
          for j in range(len(I[0]))
      ) 
      for i in range(len(I))
  )
 
33.0, tensor(1.7926), Description: Copy the input grid. For each row, shift the row down by one space, inserting the background color at the beginning and removing the last element. The colors of the objects should remain the same. 
:: def beggcdabgeadefbbbefbabfbeddecijd(I):
    # Create a list to store the modified rows
    modified_rows = []

    # Iterate over each row in the input grid
    for row_index in range(len(I)):
        # Shift the row down by inserting the background color at the beginning
        shifted_row = [mostcolor(I)] + list(I[row_index])[:-1]
        # Append the shifted row to the modified rows list
        modified_rows.append(shifted_row)

    # Convert the modified rows list to a tuple of tuples (grid format)
    return tuple(tuple(row) for row in modified_rows)
 
17.0, tensor(1.6790), Description: Copy the input grid. Find the top-left most single cell with color 1. If found, move it one space to the right and change its color to red. If the move is invalid (goes out of bounds), leave the cell in its original position. 
:: def eabefgacejajeaiaaccdbbcbbdihhibe(I):
  # Identify the target object or create a dummy object
  target = next((frozenset({(1, (i, j))}) for i, row in enumerate(I) for j, v in enumerate(row) if v == 1 and size(frozenset({(i, j)})) == 1), initset(((1, (0, 0)),)))

  # Calculate the new position for the object
  new_pos = add(ulcorner(target), (0, 1))

  # Create the output grid by mapping over input indices
  O = tuple(tuple(2 if (i, j) == new_pos else (1 if (i, j) == ulcorner(target) else v) for j, v in enumerate(row)) for i, row in enumerate(I))
  return O
 
17.5, tensor(1.6790), Description: Copy the input grid. Find the top-left most single cell with color 1. If found, move it one space to the right and change its color to red. If the move is invalid (goes out of bounds), leave the cell in its original position. 
:: def jgdaecjhbaggecbcbjaiddfdeabbgcdc(I):
  # Find locations of color '1'
  ones = ofcolor(I, 1)

  # Filter locations for single-cell objects
  target_locations = sfilter(ones, lambda loc: all(n not in ones for n in dneighbors(loc)))

  # Pick the first target location if it exists, otherwise use (0,0)
  target_loc = next(iter(target_locations), (0, 0))

  # Move the target location to the right
  new_loc = add(target_loc, (0, 1))

  # Create the output grid
  O = tuple(tuple(2 if (i, j) == new_loc else (v if (i, j) != target_loc else 0) for j, v in enumerate(row)) for i, row in enumerate(I))
  return O
 
23.0, tensor(1.6193), Description: Copy the input grid. If a single-cell object of color 1 exists, move it one space to the right and change its color to red. If the move is invalid (goes out of bounds), leave the cell in its original position. If no single-cell object of color 1 exists, leave the grid unchanged. 
:: def beaddaagbfgcefcfabaaacfifbjbfaia(I):
  # Check if a single-cell object of color 1 exists
  object_exists = any(v == 1 and all(n != 1 for n in dneighbors((i, j))) for i, row in enumerate(I) for j, v in enumerate(row))

  # Define a function to transform a single row
  def transform_row(row, i):
    return tuple(
      2 if (object_exists and (i, j-1) == (0, 0)) or ((i, j) != (0, 0) and v == 1 and all(n != 1 for n in dneighbors((i, j)))) else v
      for j, v in enumerate(row)
    )

  # Apply the transformation to each row
  O = tuple(transform_row(row, i) for i, row in enumerate(I))
  return O
 
43.5, tensor(0.9090), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def dhhccdefgaafeabdjbecddfjcehhfhed(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, shift(recolor(TWO, obj), (height(obj), 0)))
  return O 
 
22.5, tensor(0.9090), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def ffdhbbbcaccdefdeacbefifeggfcabfh(I):
  h = height(I)
  return paint(canvas(ZERO, (h, h)), merge(frozenset({shift(recolor(TWO, obj), (h, 0)) for obj in objects(I, T, F, T)})))
 
22.5, tensor(0.0360), Description: Copy the input grid. Find the largest and smallest objects. Change the color of the largest object to red. Change the color of the smallest object to red for any cells that are diagonally adjacent to the largest object. Keep the original colors for all other cells. 
:: def bcdbbbaefcigeabjacgfcaiacigcdjii(I):
  # Identify smallest and largest objects
  objs = objects(I, T, F, T)
  smallest = argmin(objs, size)
  largest = argmax(objs, size)

  # Create output grid
  O = canvas(ZERO, shape(I))

  # Recolor largest object
  O = paint(O, recolor(TWO, largest))

  # Recolor smallest object cells diagonally adjacent to largest object
  for cell in smallest:
    i, j = cell[1]
    if any((i + di, j + dj) in toindices(largest) for di, dj in [(1, 1), (1, -1), (-1, 1), (-1, -1)]):
      O = paint(O, recolor(TWO, {cell}))

  # Combine with original grid
  O = cellwise(I, O, fallback=ZERO)
  return O
 
23.5, tensor(1.1062), Description: Copy the input grid. Find the largest and smallest objects. Change the color of the largest object to red. Change the color of the smallest object to red only for cells that are diagonally adjacent to the largest object. Keep the original colors for all other cells. 
:: def ccdecdfedbcbefegbddfjccbidifahbh(I):
  # Find smallest and largest objects
  objs = objects(I, T, F, T)
  smallest = argmin(objs, size)
  largest = argmax(objs, size)

  # Create a mask for diagonally adjacent cells to the largest object
  mask = mapply(lambda loc: ineighbors(loc), toindices(largest))

  # Recolor the smallest object if it intersects with the mask
  recolored_smallest = branch(
    len(intersection(toindices(smallest), mask)) > 0,
    recolor(TWO, smallest),
    smallest
  )

  # Combine and paint the objects
  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, recolored_smallest)
  return cellwise(I, O, fallback=ZERO)
 
18.0, tensor(0.0217), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's the smallest object and is diagonally adjacent to the largest object, change its color to red. Keep the original colors for all other cells. 
:: def ijidhhbigehcecegbicjigabgdjeacfa(I):
  # Create a function to recolor an object based on its size and diagonal adjacency
  def recolor_object(obj, largest):
    is_smallest = size(obj) == size(argmin(objects(I, T, F, T), size))
    is_adjacent = any(manhattan(obj, {cell}) == 2 for cell in largest)
    return recolor(TWO, obj) if is_smallest and is_adjacent else obj
  
  # Find largest object
  largest_obj = argmax(objects(I, T, F, T), size)

  # Recolor all objects on a blank canvas
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, recolor_object(obj, largest_obj))
    
  return cellwise(I, O, fallback=ZERO)
 
33.0, tensor(1.7101), Description: Copy the input grid. For each colored object, if it touches the top border, change its color to red. Then, move each object one space down. The background color should remain the same. 
:: def abdbhbdaajibebedicjidecicbcecbda(I):
  # 1. Identify objects excluding background
  objs = objects(I, True, False, True)

  # 2. Create a canvas filled with background color
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I))

  # 3. Iterate through objects
  for obj in objs:
    # 4. Recolor objects if they touch the top border
    new_color = 2 if uppermost(obj) == 0 else color(obj)
    # 5. Shift down and paint
    O = paint(O, shift(recolor(new_color, obj), DOWN))

  return O
 
36.0, tensor(1.7115), Description: Copy the input grid. For each object that touches the top border, change its color to red. Then, move all objects one space down. The background color should remain the same. 
:: def fdcbijgbbjfdeecbbhhfebijdichfcee(I):
  # 1. Identify top-row objects
  top_objs = sfilter(objects(I, T, F, T), lambda obj: uppermost(obj) == 0)

  # 2. Shift all objects down
  shifted_objs = apply(lambda obj: shift(obj, DOWN), objects(I, T, F, T))

  # 3. Create a canvas with background color
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I))

  # 4. Paint recolored top objects
  for obj in top_objs:
    O = paint(O, recolor(2, obj))

  # 5. Paint shifted objects
  for obj in shifted_objs:
    O = paint(O, obj)

  return O
 
33.0, tensor(1.3962), Description: Copy the input grid. For each row, shift the row down by one space. If the original cell in the top row is not the background color, change its color to red. The colors of the objects should remain the same. 
:: def ecadejdaadbgecieafcjafcaicbcgcjb(I):
  # 1. Create canvas filled with background color
  O = canvas(mostcolor(I), shape(I))

  # 2. Iterate through rows and columns
  for i in range(1, len(I)):
    for j in range(len(I[0])):
      # 3. Shift values down, recolor top row
      if i == 1:
        O = paint(O, {(2 if I[i-1][j] != mostcolor(I) else mostcolor(I), (i,j))})
      else:
        O = paint(O, {(I[i-1][j], (i,j))})

  return O
 
22.5, tensor(1.6460), Description: Copy the input grid. Find the top-left most single cell with color 1. If found, move it one space to the right and change its color to red. If the move is invalid (goes out of bounds), leave the cell in its original position. If no single-cell object of color 1 exists, leave the grid unchanged. 
:: def ehefddbdebebeajcifeaffddbfjegjfh(I):
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            if v == 1 and size(objects(crop(I, (i, j), (1, 1)), True, True, True)) == 1:
                O = paint(canvas(0, shape(I)), {(2, (i, j + 1))})
                return O
    return paint(canvas(0, shape(I)), {(2, (0, 1))})
 
23.5, tensor(1.7330), Description: Copy the input grid. Find the top-left most single cell with color 1 that has no other cells of color 1 to its right. If found, move it one space to the right and change its color to red. If the move is invalid (goes out of bounds), leave the cell in its original position. If no single-cell object of color 1 exists, leave the grid unchanged. 
:: def fhdageddccdaebeeiffjcaecahgacgce(I):
    target_loc = next(((i, j) for i, row in enumerate(I) for j, v in enumerate(row) if v == 1 and all(c != 1 for c in I[i][j+1:j+2])), None)
    O = paint(canvas(0, shape(I)), {(2, (target_loc[0], target_loc[1] + 1)) if target_loc else (2, (0, 1))})
    return O
 
23.5, tensor(0.0514), Description: Copy the input grid. For each colored object, create a vertical line of red squares with the same height as the object, starting from the top of the grid. The background color should remain the same. 
:: def baeefcihfbbaebfcbdfadfichegecdba(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    h = height(obj)
    O = paint(O, recolor(TWO, product(interval(ZERO, h, ONE), {ZERO})))
  return O
 
29.0, tensor(1.7877), Description: Copy the input grid. For each colored object (not the background color), create a vertical line of red squares, starting from the top of the grid and extending down to the row where the object is located. The background color should remain the same. 
:: def dcccbdbfafdaehfbbieeebafjidcacbe(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        O = fill(O, TWO, product(interval(ZERO, i+ONE, ONE), {ZERO}))
  return O
 
41.0, tensor(0.8651), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies. Change the color of the moved objects to red. The background color should remain the same. 
:: def habcfaebdjfbedfgjdfjfecddcfdefaa(I):
  return replace(paint(canvas(ZERO, shape(I)), 
                        mapply(lambda obj: shift(obj, (height(obj) - 1, 0)), 
                               objects(I, T, F, T))),
                 ONE, TWO) 
 
18.0, tensor(0.9013), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies. Change the color of the moved objects to red. Then, paint the original objects onto the grid, keeping their original colors. The background color should remain the same. 
:: def dfhedbeebcadeebfjfcidibhbehcbefc(I):
    return paint(
        fill(
            canvas(ZERO, shape(I)), 
            TWO, 
            mapply(
                lambda obj: toindices(shift(obj, (height(obj) - 1, 0))), 
                objects(I, T, F, T)
            )
        ),
        asobject(I)
    )
 
22.5, tensor(1.1180), Description: Copy the input grid. Find all objects formed by the digit '1' and change their color to '2'. Keep the original colors for all other cells. 
:: def idabaadecjedehffbdbcjgacbcdbdcef(I):
  # Identify objects formed by the digit '1'.
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 1)

  # Recolor the target objects to '2'.
  recolored_objs = apply(lambda obj: recolor(2, obj), target_objs)

  # Paint the recolored objects onto a blank canvas.
  O = paint(canvas(0, shape(I)), merge(recolored_objs))
  return O 
 
18.0, tensor(1.7013), Description: Copy the input grid. For each object that touches the top border, change its color to red. Then, move each object one space down. The background color should remain the same. 
:: def dbadfagcfbheeficaeicabaieajaaadc(I):
  # 1. Create a canvas with the same dimensions and background color as the input
  O = canvas(mostcolor(I), shape(I))

  # 2. Paint all objects from the input onto the canvas
  for obj in objects(I, T, F, T):
    O = paint(O, obj)

  # 3. Identify top-row objects, shift them down, recolor them, and paint them onto the canvas
  for obj in objects(I, T, F, T):
    if uppermost(obj) == 0:
      O = paint(O, recolor(2, shift(obj, DOWN)))

  return O 
 
18.0, tensor(1.7013), Description: Copy the input grid. For each object that touches the top border, change its color to red. Then, move each object one space down. The background color should remain the same. 
:: def dabacebhahbbefchaebabfchfcejdbhj(I):
  # 1. Create a canvas with the same dimensions and background color as the input
  O = canvas(mostcolor(I), shape(I))

  # 2. Identify top-row objects, shift them down, recolor them, and paint them onto the canvas
  O = paint(O, merge(apply(lambda obj: recolor(2, shift(obj, DOWN)), sfilter(objects(I, T, F, T), lambda obj: uppermost(obj) == 0))))

  # 3. Paint all objects from the input onto the canvas
  O = paint(O, asobject(I))

  return O 
 
16.0, tensor(1.1459), Description: Copy the input grid. For each cell in the top row that is not the background color, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def ibieecacfjbaefbcijjcdfajajgcfdcf(I):
  # 1. Get the background color of the input grid
  bg_color = mostcolor(I)

  # 2. Create a canvas with the same dimensions and background color
  O = canvas(bg_color, shape(I))

  # 3. Iterate through each cell in the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # 4. If the cell is in the top row and not the background color,
      #    shift it down, recolor it to '2', and paint it on the canvas
      if i == 0 and I[i][j] != bg_color:
        O = paint(O, {(2, (i + 1, j))})
      # 5. Otherwise, paint the cell at its original position
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
22.0, tensor(1.4033), Description: Copy the input grid. For each cell in the top row, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def cicdabgecafdecgfiejifhhbcgebbbdf(I):
  # 1. Identify top row indices
  top_indices = sfilter(asindices(I), lambda ind: ind[0] == 0)

  # 2. Shift top indices down 
  shifted_top_indices = shift(top_indices, DOWN)

  # 3. Create a canvas with background color
  O = canvas(mostcolor(I), shape(I))

  # 4. Paint cells according to the transformation
  for i in range(len(I)):
    for j in range(len(I[0])):
        if (i, j) in shifted_top_indices:
            O = paint(O, {(2, (i, j))})
        else:
            O = paint(O, {(I[i][j], (i, j))})
  return O
 
22.5, tensor(1.7753), Description: Copy the input grid. For each cell with color 1, if it's possible to move it one space to the right (without going out of bounds), remove the original cell and paint the moved cell with color 2. 
:: def abadeabeidcfeigdjfeecfedfjbdhcah(I):
  # Create a shifted grid with '2's in place of potential moved objects
  shifted_grid = paint(canvas(0, shape(I)), recolor(2, shift(ofcolor(I, 1), (0, 1))))

  # Combine the shifted grid with the original, prioritizing '2's
  O = cellwise(shifted_grid, I, 0)
  return O
 
36.0, tensor(1.7400), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies and move it left by the number of columns it occupies. Change the color of the moved objects to red. The background color should remain the same. 
:: def hfjaffbdcaeheacaiafdhecedidbbcge(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, shift(recolor(TWO, obj), (height(obj) - 1, -leftmost(obj))))
  return O
 
36.5, tensor(1.7439), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies and move it left by the number of columns it occupies.  Horizontally mirror the object before moving it. Change the color of the moved objects to red. The background color should remain the same. 
:: def ebedaijacjfcebfjiddaeccajddbfgcg(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    new_obj = recolor(TWO, hmirror(obj)) # Horizontal mirroring added
    O = paint(O, shift(new_obj, (height(obj) - 1, -leftmost(obj))))
  return O
 
36.0, tensor(1.7400), Description: Copy the input grid. For each colored object, move it down by the number of rows it occupies and move it left by the number of columns it occupies. Change the color of the moved objects to red. The background color should remain the same. 
:: def adcbbedaddbeeicaadedccdahccadace(I):
  O = I # Initialize O with input grid
  for obj in objects(I, T, F, T):
    O = fill(O, ZERO, toindices(obj)) # Clear original object from output grid
    new_obj = recolor(TWO, shift(obj, (height(obj) - 1, -leftmost(obj)))) 
    O = paint(O, new_obj)
  return O
 
34.5, tensor(1.1266), Description: Copy the input grid. For each colored object, move it up by the number of rows it occupies. Change the color of the moved objects to red. The background color should remain the same. 
:: def bbechaadedceegibifgefgijhfejageg(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  for obj in objects(I, T, F, T): # Iterate over objects
    O = paint(O, shift(obj, (-uppermost(obj), 0))) # Shift each object up and paint
  return replace(O, ONE, TWO) # Replace 1s with 2s
 
30.5, tensor(1.4512), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its bottom right corner is one space above the top left corner of the largest object. Keep the original colors for all other cells. 
:: def cdejedfddfideicgjhfbaedfhhcddfai(I):
  # Identify the largest and second largest objects (excluding background)
  objs = order(objects(I, T, F, T), size)
  largest = objs[-1]
  second_largest = objs[-2]
  
  # Recolor the second largest object to '2'
  recolored = recolor(2, second_largest)
  
  # Calculate the offset to position the recolored object above the largest
  offset = subtract(ulcorner(largest), add(lrcorner(recolored), (1, 0))) 
  
  # Paint the objects onto a blank canvas
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shift(recolored, offset))
  return O
 
32.5, tensor(1.5153), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top left corner is one space below the bottom right corner of the largest object. Keep the original colors for all other cells. 
:: def fibefajcbjfcebdjjdefjdgjadcfcajf(I):
    # Identify objects and sort by size
    objs = order(objects(I, T, F, T), size)
    obj1, obj2 = objs[-1], objs[-2]

    # Calculate the vertical offset for the desired positioning
    v_offset = height(obj1) + 1 

    # Recolor the second largest object
    obj2 = recolor(2, obj2)

    #  Calculate the horizontal offset based on object widths
    h_offset = width(obj1) - width(obj2)

    # Shift the recolored object to its new position
    obj2_shifted = shift(obj2, (v_offset, h_offset))

    # Create the output grid by painting the objects
    O = paint(canvas(0, shape(I)), obj1)
    O = paint(O, obj2_shifted)
    return O 
 
31.0, tensor(1.0188), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-right corner is aligned with the bottom-left corner of the largest object. Keep the original colors for all other cells. 
:: def fccaeddfbcabefhfbacdhfefggaidcfe(I):
    # Find objects, sort by size, get top two
    objs = order(objects(I, T, F, T), size)
    largest = objs[-1]
    second = objs[-2]
    
    # Determine the bottom-left corner of the largest object
    target_x, target_y = llcorner(largest)

    # Recolor the second largest object
    second = recolor(2, second)

    # Calculate offset to align the recolored object's top-right corner
    offset_x = target_x - (rightmost(second) + 1)
    offset_y = target_y - uppermost(second)

    # Shift the recolored object
    shifted_second = shift(second, (offset_y, offset_x))

    # Construct the output grid
    O = paint(canvas(0, shape(I)), largest)
    O = paint(O, shifted_second)
    return O
 
34.0, tensor(0.7318), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top left corner is aligned with the top left corner of the largest object. Keep the original colors for all other cells. 
:: def dhaedafdbicfeeccibedfgdhgdbcaaej(I):
    # Get the objects, sort them by size, and select the top two
    objects_in_grid = objects(I, T, F, T)
    sorted_objects = order(objects_in_grid, size)
    largest_object = sorted_objects[-1]
    second_largest_object = sorted_objects[-2]

    # Recolor the second largest object to '2'
    recolored_object = recolor(2, second_largest_object)

    # Determine the desired position for the recolored object
    desired_position = subtract(ulcorner(largest_object), (height(recolored_object) , 0))

    # Calculate the offset to move the recolored object
    offset_to_move = subtract(desired_position, ulcorner(recolored_object))

    # Apply the offset to the recolored object
    moved_object = shift(recolored_object, offset_to_move)

    # Create the output grid
    output_grid = canvas(0, shape(I))

    # Paint the largest object and the moved object onto the output grid
    output_grid = paint(output_grid, largest_object)
    output_grid = paint(output_grid, moved_object)

    # Return the output grid
    return output_grid
 
22.0, tensor(0.9481), Description: Copy the input grid. For each object that touches the top border, change its color to red and move it down by the number of rows it occupies. The background color should remain the same. 
:: def dcecdeeafffhehdiijdefbdcbeacbced(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if uppermost(obj) == 0:
      O = paint(O, recolor(2, shift(obj, (height(obj), 0))))
    else:
      O = paint(O, obj)
  return O
 
24.0, tensor(0.9389), Description: Copy the input grid. Find the topmost and bottommost objects. Change the color of both objects to red. Move the topmost object down by the number of rows it occupies. Move the bottommost object up by the number of rows it occupies. The background color should remain the same. 
:: def fhfabajebhfdefajibfddffbhccfeddc(I):
  objs = objects(I, T, F, F)
  top_obj = argmax(objs, lambda obj: uppermost(obj))
  bottom_obj = argmax(objs, lambda obj: lowermost(obj))
  recolored_top = recolor(2, top_obj)
  recolored_bottom = recolor(2, bottom_obj)
  shifted_top = shift(recolored_top, (height(top_obj), 0))
  shifted_bottom = shift(recolored_bottom, (-height(bottom_obj), 0))
  O = paint(paint(canvas(0, shape(I)), shifted_top), shifted_bottom)
  return O
 
24.0, tensor(1.7845), Description: Copy the input grid. Find the objects that are above the middle row and the objects that are below the middle row. Change the color of all these objects to red. Move the objects above the middle row to the right by one space if they are on the left side of the grid, and move them to the left by one space if they are on the right side of the grid. The background color should remain the same. 
:: def gcabchdaiffjehhaadefeeafbebddjbb(I):
  h = height(I)
  objs = objects(I, T, F, F)
  top_obj = extract(objs, lambda obj: uppermost(obj) < h // 2)
  bottom_obj = extract(objs, lambda obj: lowermost(obj) >= h // 2)
  recolored_objs = apply(lambda obj: recolor(2, obj), (top_obj, bottom_obj))
  shifted_objs = mapply(lambda obj: shift(obj, (sign(centerofmass(obj)[0] - h // 2), 0)), recolored_objs)
  O = paint(canvas(0, shape(I)), shifted_objs)
  return O
 
28.5, tensor(1.1263), Description: Copy the input grid. For each colored object, move it up by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def difhdbcghabfeidaadbffabfecchffad(I):
  O = I # Start with the input grid
  for obj in objects(I, T, F, T): # For each object excluding the background
    O = underfill(O, ZERO, obj) # Replace the object with background color
    O = paint(O, recolor(TWO, shift(obj, (-uppermost(obj), 0)))) # Paint the shifted and recolored object on the modified grid 
  return O
 
28.5, tensor(1.5153), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top left corner is one space below the bottom right corner of the largest object. Keep the original colors for all other cells. 
:: def ediebigabbdaehheiiabfbcbbfjfejdc(I):
  # Find the two largest objects, excluding the background
  objs = order(objects(I, T, F, T), size)
  largest, second_largest = objs[-1], objs[-2]

  # Calculate the vertical and horizontal offsets
  v_offset = height(largest) + 1 
  h_offset = max(0, width(largest) - width(second_largest))  # Ensures non-negative offset

  # Recolor the second largest object and shift to its new position
  recolored_obj = shift(recolor(2, second_largest), (v_offset, h_offset))

  # Create the output grid
  O = paint(canvas(0, shape(I)), recolored_obj)
  return O
 
29.0, tensor(1.7789), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object. Keep the original colors for all other cells. 
:: def iceegfiagdfdeaffbaffgeiaedfcabjg(I):
    # Find the largest object and its lower-right corner
    largest = argmax(objects(I, T, F, T), size)
    lr_corner = lrcorner(largest)

    # Find the second largest object and recolor it
    second_largest = argmax(difference(objects(I, T, F, T), {largest}), size)
    recolored_obj = recolor(2, second_largest)

    # Calculate the new upper-left corner for the recolored object
    new_ul_corner = (lr_corner[0] + 1, lr_corner[1] - width(second_largest) + 1)

    # Shift the recolored object to its new position
    shifted_obj = shift(recolored_obj, subtract(new_ul_corner, ulcorner(recolored_obj)))

    # Generate output by painting the object on a blank canvas
    O = paint(canvas(0, shape(I)), shifted_obj)
    return O
 
24.5, tensor(1.4807), Description: Copy the input grid. Find the two objects with the most occurrences of their respective colors. Change the color of the second most frequent object to red. Move the second most frequent object so that its top left corner is one space below the bottom right corner of the most frequent object. Keep the original colors for all other cells. 
:: def cfafadeejdccedhbjjdacdcdhababdff(I):
    # Get all objects and find the background color
    objs = objects(I, T, F, T)
    bg_color = mostcommon(merge(I))

    # Find the largest and second largest objects based on color count
    largest = argmax(objs, lambda obj: colorcount(I, color(obj)))
    second_largest = argmax(difference(objs, {largest}), lambda obj: colorcount(I, color(obj)))

    # Calculate shift amounts for precise placement
    v_shift = height(largest) + 1
    h_shift = (width(largest) - width(second_largest)) if width(largest) > width(second_largest) else 0

    # Construct the output grid
    O = canvas(bg_color, shape(I))
    O = paint(O, shift(recolor(2, second_largest), (v_shift, h_shift)))
    return O
 
19.5, tensor(1.3975), Description: Copy the input grid. For each cell in the top row that is color 1, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def iecfifgadfcaecabiedcefhgichcbfbe(I):
  # 1. Get indices of the top row with color 1
  top_indices = sfilter(asindices(I), lambda ind: ind[0] == 0 and I[ind[0]][ind[1]] == 1)
  
  # 2. Shift the indices down by one row
  shifted_indices = shift(top_indices, DOWN)
  
  # 3. Fill the shifted indices with color 2 on a background canvas
  return fill(canvas(mostcolor(I), shape(I)), 2, shifted_indices)
 
30.0, tensor(1.1304), Description: Copy the input grid. For each object with color 1, move it up by the number of rows it occupies. If the moved object overlaps with a black cell, change the color of the moved object to red. The background color should remain the same. 
:: def cfffeifdbeeaebedjgbhcfbafhjbfacd(I):
  O = I
  for obj in objects(I, True, False, False):
    if color(obj) == ONE:
      shifted_obj = shift(obj, (-uppermost(obj), 0))
      for v, (i, j) in shifted_obj:
        if 0 <= i < height(I) and 0 <= j < width(I) and O[i][j] == ZERO:
          O = paint(O, {(TWO, (i, j))})
  return O
 
31.5, tensor(1.7128), Description: Copy the input grid. For each cell with color 1, move it up as many spaces as possible until it reaches another cell with color 1 or the top of the grid. Change the color of the moved cells to red. The background color should remain the same. 
:: def ieiccccffibaedacbebbegbbjadedgcc(I):
  O = I
  ones = ofcolor(I, ONE)
  for i, j in ones:
    k = 0
    while (i - k, j) in ones and i - k >= 0:
      O = paint(cover(O, {(ONE, (i - k, j))}), {(TWO, (i - k - 1, j))})
      k += 1
  return O
 
25.0, tensor(1.7890), Description: Copy the input grid. Find the three largest objects. Mirror the smallest object horizontally and place it at the original location of the smallest object. The second largest object should be moved to the center of the largest object. The smallest object should be moved to the center of the largest object. The colors of the objects should remain the same. 
:: def jjajeicffcgdecdbacdfgfggehcddcfh(I):
  # Extract objects
  obj1 = argmax(objects(I, T, F, T), size)  # Largest object
  obj2 = argmax(remove(obj1, objects(I, T, F, T)), size)  # Second largest
  obj3 = argmin(objects(I, T, F, T), size) # Smallest object
  
  # New position for second largest object
  new_pos2 = add(centerofmass(obj1), position(obj2, obj1))
  
  # Create mirrored object from smallest object
  new_obj = recolor(TWO, hmirror(shift(obj3, subtract(centerofmass(obj3), (0, width(obj3))))))
  
  # Assemble the output grid
  O = paint(canvas(ZERO, shape(I)), obj1) # Place largest object
  O = paint(O, shift(obj2, subtract(new_pos2, centerofmass(obj2)))) # Place second largest at new position
  O = paint(O, shift(new_obj, subtract(centerofmass(obj1), centerofmass(new_obj)))) # Place mirrored object
  return O
 
29.0, tensor(1.7890), Description: Copy the input grid. Find the three largest objects. Mirror the smallest object horizontally and place it at the original location of the smallest object. The second largest object should be moved to the center of the largest object. The smallest object should be moved to the center of the largest object. The colors of the objects should remain the same. 
:: def daffcdicabjbedcjiejecjfjaagafeec(I):
  objs = order(objects(I, T, F, T), size) # Order objects by size
  largest = first(objs)
  second_largest = first(remove(largest, objs))
  smallest = last(objs)

  new_pos = add(centerofmass(largest), position(second_largest, largest))
  
  mirrored = hmirror(shift(smallest, subtract(centerofmass(smallest), (0, width(smallest)))))
  recolored = recolor(TWO, mirrored)
  shifted = shift(recolored, subtract(centerofmass(largest), centerofmass(recolored)))

  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, shift(second_largest, subtract(new_pos, centerofmass(second_largest))))
  O = paint(O, shifted)
  return O
 
30.5, tensor(1.7876), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's the same size as the largest object, leave it unchanged. If it's a single cell, move it to the closest point on the largest object. If it's any other size, mirror it horizontally if the largest object is vertical, or mirror it vertically if the largest object is horizontal, and place it at its original location. The colors of the objects should remain the same. 
:: def jdajcfdgifcbebhabefacaffbbcaaabi(I):
  objs = objects(I, T, F, T)
  main_obj = argmax(objs, size)
  
  def process_obj(obj):
      if size(obj) == size(main_obj):
          return obj
      elif size(obj) == 1:
          return shift(obj, gravitate(obj, main_obj))
      else:
          mirror_direction = hmirror if portrait(main_obj) else vmirror
          return recolor(TWO, mirror_direction(shift(obj, subtract(centerofmass(obj), (0, width(obj))))))
  
  final_objs = apply(process_obj, objs)
  O = canvas(ZERO, shape(I))
  for obj in final_objs:
      O = paint(O, obj)
  return O
 
24.5, tensor(1.0401), Description: Copy the input grid. For each object that touches the top border and has color 1, move it one space down and change its color to red. For all other objects, change their color to the most frequent color in the input grid. The background color should remain the same. 
:: def iddihaiidfaeeeihagdhidcbfedbfeif(I):
  # 1. Define a function to process each object
  def process_object(obj):
    return branch(uppermost(obj) == 0 and color(obj) == 1, 
                 recolor(2, shift(obj, DOWN)), 
                 recolor(mostcolor(I), obj))

  # 2. Apply the function to all objects and paint on canvas
  return paint(canvas(mostcolor(I), shape(I)), 
               merge(apply(process_object, objects(I, T, F, T))))
 
30.0, tensor(0.1005), Description: Copy the input grid. For each cell that is the background color and is directly below a cell with color 1, change its color to red. The colors of the objects should remain the same. 
:: def bcaefcficfaaechfbfibhebdgeedcehf(I):
  return tuple(
      tuple(
          2 if i > 0 and I[i-1][j] == 1 and I[i][j] == mostcolor(I) else I[i][j]
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
91.5, tensor(1.1276), Description: Copy the input grid. For each connected object, move it up by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def ibgaaaeiejgeebciaedadfcebfcfdfea(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, True, False, False):
    shift_amount = uppermost(obj)
    O = underpaint(O, shift(recolor(TWO, obj), (-shift_amount, 0)))
  return O
 
91.5, tensor(1.1276), Description: Copy the input grid. For each connected object, move it up by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def cfccffhefaefeibfaajghhgceedabfaa(I):
  objs = objects(I, True, False, False)
  shifted_objs = frozenset()
  for obj in objs:
    shift_amount = uppermost(obj)
    shifted_objs = shifted_objs.union(frozenset({shift(recolor(TWO, obj), (-shift_amount, 0))}))
  return paint(canvas(ZERO, shape(I)), merge(shifted_objs))
 
91.5, tensor(1.1276), Description: Copy the input grid. For each connected object, move it up by the number of rows it occupies and change its color to red. The background color should remain the same. 
:: def dfighagfgbdaebgejbbbifabbdcdadcc(I):
  O = I
  for obj in objects(I, True, False, False):
    O = paint(cover(O, obj), shift(recolor(TWO, obj), (-uppermost(obj), 0))) 
  return O
 
26.0, tensor(1.7877), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's a single cell, move it to the closest point on the largest object. If it's any other size, mirror it horizontally if the largest object is vertical, or mirror it vertically if the largest object is horizontal, and place it at its original location. The colors of the objects should remain the same. 
:: def dgbediaaeeiceehiaiafgcafabbfcfbj(I):
  objs = objects(I, T, F, T)
  large_obj = argmax(objs, size)
  other_objs = remove(large_obj, objs)
  
  def transform_obj(obj):
    if size(obj) == 1:
      return recolor(TWO, shift(obj, gravitate(obj, large_obj)))
    else:
      mirror_func = hmirror if portrait(large_obj) else vmirror
      shift_direction = subtract((0, width(large_obj)), (0, width(obj))) if portrait(large_obj) else subtract((height(large_obj), 0), (height(obj), 0))
      return recolor(TWO, mirror_func(shift(obj, shift_direction)))

  transformed_objs = apply(transform_obj, other_objs)
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, large_obj))
  for transformed_obj in transformed_objs:
      O = paint(O, transformed_obj)
  return O
 
22.5, tensor(1.7877), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's a single cell, move it to the closest point on the largest object. If it's any other size, mirror it horizontally if the largest object is vertical, or mirror it vertically if the largest object is horizontal, and place it at its original location. The colors of the objects should remain the same. 
:: def bchddfcfiahfeeeajajagccabijcbbbc(I):
  objs = objects(I, T, F, T)
  large_obj = argmax(objs, size)
  small_objs = sfilter(objs, lambda obj: size(obj) == 1)
  other_objs = difference(objs, combine(initset(large_obj), small_objs))
  
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, large_obj))
  for obj in small_objs:
    O = paint(O, recolor(TWO, shift(obj, gravitate(obj, large_obj))))
  
  for obj in other_objs:
    mirror_func = hmirror if portrait(large_obj) else vmirror
    O = paint(O, recolor(TWO, mirror_func(shift(obj, subtract(centerofmass(obj), (0, width(obj)))))))
  return O
 
35.0, tensor(1.7884), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's a single cell, move it to the closest point on the largest object. If it's any other size, mirror it horizontally if the largest object is vertical, or mirror it vertically if the largest object is horizontal, and place it at the center of the largest object. The colors of the objects should remain the same. 
:: def ajcedcadhaageahgabfecdfadbiijhae(I):
  objs = objects(I, T, F, T)
  large_obj = argmax(objs, size)
  
  O = canvas(ZERO, shape(I))
  O = paint(O, recolor(TWO, large_obj))
  
  for obj in objs:
    if obj == large_obj:
      continue
    elif size(obj) == 1:
      O = paint(O, recolor(TWO, shift(obj, gravitate(obj, large_obj))))
    else:
      mirror_func = hmirror if height(large_obj) > width(large_obj) else vmirror
      shift_offset = (-width(obj), 0) if height(large_obj) > width(large_obj) else (0, -height(obj))
      O = paint(O, recolor(TWO, shift(mirror_func(obj), add(centerofmass(large_obj), shift_offset))))
  return O
 
24.0, tensor(1.7884), Description: Copy the input grid. Find the largest object. For each object in the grid, if it's a single cell, move it to the closest point on the largest object. If it's any other size, mirror it horizontally if the largest object is vertical, or mirror it vertically if the largest object is horizontal, and place it at the center of the largest object. The colors of the objects should remain the same. 
:: def cjafefadbaaceaccacdbbdfdhcfjfgee(I):
  objs = objects(I, T, F, T)
  large_obj = argmax(objs, size)
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, large_obj))
  
  for obj in objs:
    if obj != large_obj:
      if size(obj) == 1:
        O = paint(O, recolor(TWO, shift(obj, gravitate(obj, large_obj))))
      else:
        mirror = hmirror if portrait(large_obj) else vmirror
        shifted_obj = shift(obj, subtract((0, width(obj) // 2), (0, width(large_obj) // 2))) if portrait(large_obj) else shift(obj, subtract((height(obj) // 2, 0), (height(large_obj) // 2, 0)))
        O = paint(O, recolor(TWO, mirror(shifted_obj)))
  return O
 
22.5, tensor(1.6084), Description: Copy the input grid. For each object with color 1, move the top row of the object one space down and change its color to red. Then, move the rightmost column of the object one space up and two spaces left, and change its color to red. The background color should remain the same. 
:: def bghdafeegbjfehedbddahicegfffcccg(I):
  # 1. Create a canvas with the background color
  O = canvas(mostcolor(I), shape(I))

  # 2. Iterate through objects with color 1
  for obj in sfilter(objects(I, T, F, T), lambda obj: color(obj) == 1):
    # 3. Shift and recolor the top row
    top_row = sfilter(obj, lambda cell: cell[1][0] == uppermost(obj))
    O = underpaint(O, recolor(2, shift(top_row, DOWN)))
    
    # 4. Shift and recolor the rightmost column
    rightmost_col = sfilter(obj, lambda cell: cell[1][1] == rightmost(obj))
    O = underpaint(O, recolor(2, shift(rightmost_col, (-1, -2))))

  return O
 
21.5, tensor(1.8141), Description: Copy the input grid. For each cell with color 1, apply the following shift:
- If the cell is in the top row, move it one space down.
- If the cell is in the rightmost column, move it one space up and two spaces left.
- Otherwise, leave the cell in its original position.
Change the color of the moved cells to red. The background color should remain the same. 
:: def ggcbfaeghcedecehibidbceehigbcafc(I):
  # 1. Create a blank canvas
  O = canvas(0, shape(I))
  
  # 2. Iterate over each cell in the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # 3. If the cell color is 1
      if I[i][j] == 1:
        # 4. Determine the shift based on cell position
        shift_amount = DOWN if i == 0 else (-1, -2) if j == len(I[0]) - 1 else (0, 0)
        
        # 5. Paint the cell onto the output grid with modifications
        O = paint(O, {(2, add((i, j), shift_amount))})
  return O
 
67.0, tensor(1.7267), Description: Copy the input grid. For each colored object, if it touches the border of the grid, move it to the center of the grid. If it doesn't touch the border, leave it in its original position. Change the color of the moved objects to red. The background color should remain the same. 
:: def fcddedcgbaajehbciiaebibaeijbfbej(I):
  h, w = shape(I)
  objs = objects(I, T, F, F)
  O = canvas(0, (h, w))
  for obj in objs:
    if bordering(obj, I):
      ci, cj = centerofmass(obj)
      target_i = ci - sign(ci - h // 2)
      target_j = cj - sign(cj - w // 2)
      O = paint(O, recolor(2, shift(obj, (target_i - ci, target_j - cj))))
    else:
      O = paint(O, obj)
  return O
 
50.0, tensor(1.6586), Description: Copy the input grid. For each colored object, if it touches the border of the grid, move it one space closer to the center of the grid. If it doesn't touch the border, leave it in its original position. Change the color of the moved objects to red. The background color should remain the same. 
:: def ecfecaaajdajejfcjegeiafbdbffcgid(I):
  h, w = shape(I)
  objs = objects(I, T, F, F)
  shifted_objs = mapply(lambda obj: branch(bordering(obj, I), shift(recolor(2, obj), (crement(centerofmass(obj)[0] - h // 2), crement(centerofmass(obj)[1] - w // 2))), obj), objs)
  O = paint(canvas(0, (h, w)), shifted_objs)
  return O
 
67.5, tensor(1.6586), Description: Copy the input grid. For each colored object, if it touches the border of the grid, move it one space closer to the center of the grid. If it doesn't touch the border, leave it in its original position. Change the color of the moved objects to red. The background color should remain the same. 
:: def babcgbhbaagceeaficbdaacfbjddfcbe(I):
  h, w = shape(I)
  objs = objects(I, T, F, F)
  shifted_objs = set()
  for obj in objs:
    if bordering(obj, I):
      target = (
          uppermost(obj) - sign(uppermost(obj) - h // 2),
          leftmost(obj) - sign(leftmost(obj) - w // 2)
      )
      shifted_objs.add(shift(recolor(2, obj), (target[0] - uppermost(obj), target[1] - leftmost(obj))))
    else:
      shifted_objs.add(obj)
  O = paint(canvas(0, (h, w)), merge(shifted_objs))
  return O
 
18.5, tensor(1.6084), Description: Copy the input grid. For each object with color 1, move the top row of the object one space down and change its color to red. Then, move the rightmost column of the object one space up and two spaces left, and change its color to red. The background color should remain the same. 
:: def ehijcgbdgjfeechjjaeebgiddggafdae(I):
  # 1. Identify objects with color 1
  target_objs = sfilter(objects(I, T, F, T), lambda obj: color(obj) == 1)

  # 2. Modify top row and rightmost column for each object
  modified_objs = frozenset({
      (2, add(cell[1], DOWN)) if cell[1][0] == uppermost(obj) else
      (2, add(cell[1], (-1, -2))) if cell[1][1] == rightmost(obj) else
      cell
      for obj in target_objs for cell in obj
  })

  # 3. Paint modified objects onto a background canvas
  return underpaint(canvas(mostcolor(I), shape(I)), modified_objs)
 
22.5, tensor(1.6031), Description: Copy the input grid. For each colored cell on the border of the grid, move it one space closer to the center of the grid. Change the color of the moved cells to red. The background color should remain the same. 
:: def aeidfifffcjbedehahagggfaabeicada(I):
  h, w = shape(I)
  shifted_objs = set()
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if i == 0 or i == h-1 or j == 0 or j == w-1: # Check if cell is on the border
        if val != mostcolor(I): # Ignore background cells
          direction = (-sign(i - h//2), -sign(j - w//2)) # Calculate inward direction
          shifted_objs.add(shift(frozenset({(2, (i, j))}), direction)) # Shift and recolor
  O = paint(canvas(0, (h, w)), merge(shifted_objs)) # Paint on canvas
  return O
 
32.0, tensor(0.1406), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object. Remove the top-left corner cell from the largest object. Keep the original colors for all other cells. 
:: def bchfebjdedhdegbfaaahfffffecgeejb(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate the new upper-left corner for the second-largest object
  new_ul_corner = (lrcorner(largest)[0] + 1, lrcorner(largest)[1] - width(second_largest) + 1)

  # Shift and recolor the second-largest object
  shifted_obj = shift(recolor(2, second_largest), subtract(new_ul_corner, ulcorner(second_largest)))

  # Remove the top-left corner cell from the largest object
  largest = difference(largest, { (index(I, ulcorner(largest)), ulcorner(largest)) })

  # Generate output by painting both objects on a blank canvas
  O = paint(canvas(0, shape(I)), shifted_obj)
  O = paint(O, largest)
  return O
 
29.0, tensor(0.0390), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its top-left corner is one space below and to the left of the bottom-right corner of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its top-left corner is one space above and to the right of the top-left corner of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its top-left corner is one space above and to the left of the top-left corner of the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def cbcdgheaefdcebjcabfcaafeeccabiif(I):
  # Identify relevant objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Determine relative positioning of objects
  rel_pos = position(second_largest, largest)

  # Calculate offset based on relative position and object sizes
  offset = (height(largest) + (1 if rel_pos[0] >= 0 else 0), 
            width(largest) + (1 if rel_pos[1] > 0 else 0))

  # Shift and recolor the second-largest object
  shifted_obj = shift(recolor(2, second_largest), add(ulcorner(largest), multiply(offset, rel_pos)))

  # Remove a corner cell from the largest object based on relative position
  corner_to_remove = branch(rel_pos == (1,1), ulcorner(largest),
                           branch(rel_pos == (-1, 1), llcorner(largest),
                                  branch(rel_pos == (1, -1), urcorner(largest),
                                         lrcorner(largest))))
  largest = difference(largest, {(index(I, corner_to_remove), corner_to_remove)})

  # Generate the output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
27.0, tensor(0.0390), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its top-left corner is one space below and to the left of the bottom-right corner of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its top-left corner is one space above and to the right of the top-left corner of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its top-left corner is one space above and to the left of the top-left corner of the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def defabigchfdieaciifdjfbicjcacdhfc(I):
  # Identify largest and second-largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Define possible offsets for each relative position
  offsets = {(1,1): (-1, -1), (-1, 1): (1, -1), 
             (1, -1): (-1, 1), (-1, -1): (1, 1)}
  
  # Determine relative position and calculate offset
  rel_pos = position(second_largest, largest)
  offset = offsets.get(rel_pos, (0, 0)) 
  offset = (offset[0] * (height(largest) + 1), offset[1] * (width(largest) + 1))
  
  # Shift and recolor the second-largest object
  shifted_obj = shift(recolor(2, second_largest), add(ulcorner(largest), offset))

  # Remove the corner cell from the largest object based on relative position
  corner_to_remove = branch(any(x == -1 for x in rel_pos), ulcorner(largest), lrcorner(largest))
  largest = difference(largest, { (index(I, corner_to_remove), corner_to_remove) })
  
  # Construct the output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
25.5, tensor(0.0390), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its top-left corner is one space below and to the left of the bottom-right corner of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its top-left corner is one space above and to the right of the top-left corner of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its top-left corner is one space above and to the left of the top-left corner of the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def dbeecffcaeffefjiacfdacefaehaaiac(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate a shift direction vector towards the second-largest object
  direction = gravitate(largest, second_largest)
  
  # Adjust the direction to ensure one empty row/column 
  direction = (direction[0] * (height(largest) + 1), direction[1] * (width(largest) + 1))
  
  # Shift and recolor the second-largest object 
  shifted_obj = shift(recolor(2, second_largest), add(ulcorner(largest), direction))
  
  # Remove a corner cell from the largest object opposite to the shift direction
  corner_to_remove = branch(direction[0] > 0, ulcorner(largest),
                           branch(direction[0] < 0, lrcorner(largest),
                                   branch(direction[1] > 0, ulcorner(largest),
                                           lrcorner(largest))))
  largest = difference(largest, {(index(I, corner_to_remove), corner_to_remove)})

  # Generate the output grid
  O = paint(canvas(0, shape(I)), shifted_obj)
  O = paint(O, largest)
  return O
 
24.5, tensor(0.5211), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. For each cell that was originally part of the largest object, change its color to blue. The background color should remain the same. 
:: def dhaegddafiejebhjbcdaebdifabecfhd(I):
  # Identify objects and background
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  
  # Find the largest object and shift it
  largest = argmax(objs, size)
  shifted_largest = shift(largest, (1,1))
  
  # Construct output grid
  O = canvas(bg, shape(I))
  O = paint(O, recolor(TWO, shifted_largest))
  O = underfill(O, ONE, delta(toindices(largest))) 
  return O
 
16.0, tensor(0.4462), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. Change the color of all other objects to blue. The background color should remain the same. 
:: def ijbadgbfjagcechdbiaggdfebbihebfe(I):
  # Identify objects 
  objs = objects(I, T, F, T)
  main_obj = argmax(objs, size)
  
  # Construct the output grid
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    new_obj = shift(obj, (1, 1)) if obj == main_obj else obj
    new_color = TWO if obj == main_obj else ONE
    O = paint(O, recolor(new_color, new_obj))
  return O
 
28.5, tensor(0.0724), Description: Copy the input grid. For each object, change the color of the middle column of the object to red. Then, move the top row of the input grid down to the row containing the rightmost '1' in the input grid. Change the color of the moved row to red. The background color should remain the same. 
:: def cecaidhabagiefjfjdadfcdecgehjdda(I):
  # 1. Find the row index of the rightmost '1' in the input grid
  target_row = max(i for i, row in enumerate(I) for v in row if v == 1)
  
  # 2. Create a canvas with the same dimensions and background color as the input
  O = canvas(mostcolor(I), shape(I))
  
  # 3. Iterate over objects
  for obj in objects(I, T, F, T):
    # 4. Recolor the middle column of the object to '2'
    for v, (i, j) in obj:
      if j == (leftmost(obj) + rightmost(obj)) // 2:
        O = paint(O, {(2, (i, j))})
      else:
        O = paint(O, {(v, (i, j))})
    
  # 5. Shift the top row down to the target row and paint it onto the canvas
  O = paint(O, recolor(2, shift(toobject(asindices(crop(I, (0, 0), (1, width(I)))), I), (target_row, 0))))
  
  return O
 
28.0, tensor(0.0724), Description: Copy the input grid. For each object, change the color of the middle column of the object to red. Then, move the top row of the input grid down to the row containing the rightmost '1' in the input grid. Change the color of the moved row to red. The background color should remain the same. 
:: def bbjagichbbgdejidajfdfjehfcfjdibf(I):
  # 1. Create a canvas with the same dimensions and background color as the input
  O = canvas(mostcolor(I), shape(I))
  
  # 2. Find the rightmost column containing a '1'
  target_row = max(i for i, row in enumerate(dmirror(I)) for v in row if v == 1)
  
  # 3. Paint all objects from the input onto the canvas, recoloring the middle column to '2'
  for obj in objects(I, T, F, T):
    O = paint(O, recolor(2, intersection(toindices(obj), hfrontier((0, (leftmost(obj) + rightmost(obj)) // 2)))))
    O = paint(O, obj)
    
  # 4. Paint the shifted top row onto the canvas
  O = paint(O, recolor(2, shift(toobject(hfrontier((0, 0)), I), (target_row, 0))))
  
  return O
 
26.0, tensor(0.0724), Description: Copy the input grid. For each object, change the color of the middle column of the object to red. Then, move the top row of the input grid down to the row containing the rightmost '1' in the input grid. Change the color of the moved row to red. The background color should remain the same. 
:: def bijifhjfifeceadiaabdafigeaehicff(I):
  # 1. Find the row index of the rightmost occurrence of '1'
  target_row = max(i for i, j in ofcolor(I, 1))

  # 2. Create a canvas filled with the background color
  O = canvas(mostcolor(I), shape(I))

  # 3. Paint objects onto the canvas, recoloring the middle column to '2'
  for obj in objects(I, T, F, T):
    middle_col = (leftmost(obj) + rightmost(obj)) // 2
    O = paint(O, recolor(2, frozenset((v, (i, j)) for v, (i, j) in obj if j == middle_col)))
    O = paint(O, obj)
  
  # 4. Shift and paint the top row 
  O = paint(O, recolor(2, shift(toobject(asindices(crop(I, (0, 0), (1, width(I)))), I), (target_row, 0))))
  
  return O
 
16.5, tensor(1.7817), Description: Copy the input grid. Find the largest object that is not a single cell.  For each cell in that object, if the Manhattan distance from the cell to the center of the object is less than or equal to one-third of the object's width, change the cell's color to red. Keep the original colors for all other cells. 
:: def hhibfdgdefieeccibcgbahhfccdaeeea(I):
    # Find the primary object
    x1 = objects(I, T, F, T)
    x2 = sizefilter(x1, ONE)
    x3 = difference(x1, x2)
    obj = first(x3)

    # Calculate the center of the object
    center_i, center_j = centerofmass(obj)

    # Create a new object by selecting cells closer to the center
    new_obj = frozenset((2, (i, j)) for v, (i, j) in obj 
                         if abs(i - center_i) + abs(j - center_j) <= width(obj) // 3)
    
    # Paint the new object on the original grid
    O = paint(I, new_obj)
    return O
 
17.0, tensor(0.8289), Description: Copy the input grid. Find the largest object that is not a single cell. For each single cell object, move the largest object one step closer to the single cell object. Change the color of the moved object to red. Keep the original colors for all other cells. 
:: def aedacgagbaejefccaccfgcdbeifcffgg(I):
    # Find the primary and single cell objects
    x1 = objects(I, T, F, T)
    singles = sizefilter(x1, ONE)
    obj = first(difference(x1, singles))

    # Shrink the object towards the single cells
    new_obj = obj
    for single in singles:
        direction = gravitate(first(single), obj)
        new_obj = shift(new_obj, direction)

    # Recolor and paint the modified object
    new_obj = recolor(2, new_obj)
    O = paint(I, new_obj)
    return O
 
16.5, tensor(1.7461), Description: Copy the input grid. Find the largest object that is not a single cell. Create a new object by selecting cells within the bounding box of the original object, where the Manhattan distance from the cell to the center of the object is less than or equal to one-third of the object's height and one-third of the object's width. Change the color of the new object to red. Keep the original colors for all other cells. 
:: def aaiidbeccijaebcjabecbdecjaadifcj(I):
    # Find the primary object
    x1 = objects(I, T, F, T)
    x2 = sizefilter(x1, ONE)
    obj = first(difference(x1, x2))

    # Calculate bounding box and its center
    box_indices = box(obj)
    center_i, center_j = center(box_indices)

    # Create a new object with modified shape within the bounding box
    new_obj = frozenset((2, (i, j)) for i, j in box_indices 
                         if abs(i - center_i) <= height(obj) // 3 
                         and abs(j - center_j) <= width(obj) // 3)

    # Paint the new object on the original grid
    O = paint(I, new_obj)
    return O
 
20.5, tensor(1.7659), Description: Copy the input grid. Find the largest object that is not a single cell. If the object is larger than 2x2, split it vertically and horizontally into four quadrants. Select the top-left quadrant and the left-most quadrant. Combine these two quadrants into a new object. If the object is not larger than 2x2, leave it unchanged. Change the color of the modified object to red. Keep the original colors for all other cells. 
:: def cfiejffdfcgeedaejgdcgdbdeddhdfde(I):
    # Find the primary object
    x1 = objects(I, T, F, T)
    x2 = sizefilter(x1, ONE)
    obj = first(difference(x1, x2))

    # Split the object vertically and horizontally
    v_splits = vsplit(subgrid(obj, I), 2)
    h_splits = hsplit(subgrid(obj, I), 2)

    # Select specific splits based on size and position
    if len(v_splits) > 1 and len(h_splits) > 1:
        new_obj = toobject(asindices(v_splits[0]), I) | toobject(asindices(h_splits[0]), I)
    else:
        new_obj = obj

    # Recolor and paint the modified object
    new_obj = recolor(2, new_obj)
    O = paint(I, new_obj)
    return O
 
17.0, tensor(0.1622), Description: Copy the input grid. Shift the entire grid one space to the right. Find the smallest connected object in the original grid. Change the color of the cells in the smallest object that overlap with the shifted grid to red. Keep the original colors for all other cells. 
:: def bcifcjjfaafbeaihjbgiabgfhcdddcbd(I):
  shifted_grid = shift(asobject(I), (0, 1))  # Shift the entire grid to the right
  target = argmin(objects(I, True, False, False), size) if len(objects(I, True, False, False)) > 0 else initset(((0, (0,0)),))  # Smallest object
  O = paint(I, recolor(2, intersection(toindices(target), toindices(shifted_grid))))  # Recolor the overlapping cells
  return O
 
940.5, tensor(0.0881), Description: Copy the input grid. For each cell that is not the background color and has the background color to its right, check if the cell belongs to the smallest object in the grid. If it does, move the cell one space to the right and change its color to red. If it doesn't belong to the smallest object, leave it unchanged. The background color should remain the same. 
:: def eadbacghbaaeeefdaeehbbabedbedadd(I):
  O = tuple() # Initialize empty output grid
  for i, row in enumerate(I): 
    for j, value in enumerate(row):
      if value != mostcommon(I) and (j + 1 < len(row) and row[j + 1] == mostcommon(I)):  # Check if current cell is not background and right cell is background
        try:
          target = next(obj for obj in objects(I, True, False, False) if (i, j) in toindices(obj) and obj == argmin(objects(I, True, False, False), size))  # Check if cell belongs to smallest object
          O += (tuple(2 if (i, k) == (i, j+1) else v for k, v in enumerate(row)), )  # Recolor if part of smallest object
          break
        except:
          O += (row, ) 
          break
      else:
        O += (row, )
  return O
 
27.5, tensor(1.1005), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object one space closer to the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def ccbbiagagabbeecaidaahdadcdjdjdfh(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  rest = difference(objs, {largest})
  second_largest = argmax(rest, size)

  closest_corner = min(corners(largest), key=lambda corner: sum(abs(a-b) for a, b in zip(corner, centerofmass(second_largest))))
  dx = 1 if centerofmass(second_largest)[0] > closest_corner[0] else -1 if centerofmass(second_largest)[0] < closest_corner[0] else 0
  dy = 1 if centerofmass(second_largest)[1] > closest_corner[1] else -1 if centerofmass(second_largest)[1] < closest_corner[1] else 0

  O = paint(canvas(0, shape(I)), shift(recolor(2, second_largest), (dx, dy)))
  O = paint(O, difference(largest, {(index(I, closest_corner), closest_corner)}))
  return O
 
25.5, tensor(0.3325), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. Create a blue outline around the original position of the largest object. The background color should remain the same. 
:: def djdgjcaebgfdedbebbegifedcahjbceg(I):
  # Identify the largest object
  obj = argmax(objects(I, T, F, T), size)
  
  # Create the shifted object with color '2'
  shifted_obj = recolor(TWO, shift(obj, (1, 1)))
  
  # Create the outline object with color '1'
  outline_obj = recolor(ONE, delta(toindices(obj)))
  
  # Construct the output grid by painting the objects
  O = paint(paint(canvas(mostcolor(I), shape(I)), shifted_obj), outline_obj)
  
  return O
 
29.0, tensor(0.2673), Description: Copy the input grid. For each colored object, move it to the right so that it is adjacent to the previous object, and move it down by one space. If the object is in the top row, change its color to red. The background color should remain the same. 
:: def fedfbeadeijaebihjfcfefifeacddece(I):
  # 1. Create a canvas
  O = canvas(mostcolor(I), shape(I))
  
  # 2. Identify and process objects
  objs = objects(I, T, F, T)
  objs = order(objs, lambda o: (-leftmost(o), uppermost(o)))
  last_rightmost = width(I) 
  for i, obj in enumerate(objs):
    # 3. Determine new position
    new_leftmost = last_rightmost
    if i < len(objs) - 1 and leftmost(objs[i+1]) == leftmost(obj):
      new_topmost = uppermost(objs[i+1]) + height(objs[i+1])
    else:
      new_topmost = uppermost(obj) + 1
    
    # 4. Recolor and paint
    if uppermost(obj) == 0:
      obj = recolor(2, obj)
    O = paint(O, shift(obj, (new_topmost, new_leftmost - leftmost(obj))))
    last_rightmost = new_leftmost - 1

  return O
 
23.0, tensor(0.2673), Description: Copy the input grid. For each colored object, move it to the right so that it is adjacent to the previous object, and move it down by one space. If the object is in the top row, change its color to red. The background color should remain the same. 
:: def bccfijdaibceeecaicijcjbbaabdccfj(I):
  O = canvas(mostcolor(I), shape(I))
  objs = objects(I, T, F, T)
  rightmost_positions = {}
  for i in range(width(I)):
    column_objs = sfilter(objs, lambda obj: leftmost(obj) == i)
    for j, obj in enumerate(order(column_objs, lambda o: uppermost(o))):
      if i not in rightmost_positions:
        rightmost_positions[i] = width(I)
      new_leftmost = rightmost_positions[i]
      new_topmost =  uppermost(obj) + 1 if j == 0 else uppermost(obj)
      if uppermost(obj) == 0:
        obj = recolor(2, obj)
      O = paint(O, shift(obj, (new_topmost, new_leftmost - leftmost(obj))))
      rightmost_positions[i] = new_leftmost - 1
  return O
 
29.0, tensor(0.2673), Description: Copy the input grid. For each colored object, move it to the right so that it is adjacent to the previous object, and move it down by one space. If the object is in the top row, change its color to red. The background color should remain the same. 
:: def ccjjidhcaecdechibfiafcahjgaffdia(I):
  O = canvas(mostcolor(I), shape(I))
  objs = order(objects(I, T, F, T), lambda o: (-leftmost(o), uppermost(o)))
  last_obj_rightmost = width(I)
  for obj in objs:
    new_leftmost = last_obj_rightmost
    if uppermost(obj) == 0:
      obj = recolor(2, obj)
    O = paint(O, shift(obj, (uppermost(obj) + 1, new_leftmost - leftmost(obj))))
    last_obj_rightmost = new_leftmost - 1
  return O
 
30.0, tensor(0.2673), Description: Copy the input grid. For each colored object, move it to the right so that it is adjacent to the previous object, and move it down by one space. If the object is in the top row, change its color to red. The background color should remain the same. 
:: def bdeicbfbfeggegcjbciebhdfdgdcicag(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    new_leftmost = width(I) - len(sfilter(objects(I, T, F, T), lambda o: leftmost(o) > leftmost(obj)))
    new_topmost = uppermost(obj) + sum(height(o) for o in objects(I, T, F, T) if leftmost(o) == leftmost(obj) and uppermost(o) < uppermost(obj))
    if uppermost(obj) == 0:
      obj = recolor(2, obj)
    O = paint(O, shift(obj, (new_topmost, new_leftmost - leftmost(obj))))
  return O
 
26.5, tensor(0.8143), Description: Copy the input grid. Find the largest object and all single-cell objects. For each single-cell object, move it to the closest point on the largest object. Change the color of the moved single-cell objects to red. Keep the original colors for all other cells. 
:: def ddheffdeeggaedfcbfgfigdfibhfgabc(I):
  # Identify small and large objects
  small_objs = sizefilter(objects(I, T, F, T), ONE)
  large_obj = argmax(objects(I, T, F, T), size)
  # Create a canvas filled with the background color
  O = canvas(mostcolor(I), shape(I))
  # Paint the large object onto the canvas
  O = paint(O, large_obj)
  # Define a function to position small objects around the large object
  def position_obj(obj):
    # Calculate the offset for the small object
    offset = gravitate(obj, large_obj)
    # Shift the object by the calculated offset
    return shift(obj, offset)
  # Position the small objects around the large object
  positioned_objs = mapply(position_obj, small_objs)
  # Paint the positioned objects onto the canvas with a different color
  O = paint(O, recolor(TWO, positioned_objs))
  return O
 
17.0, tensor(1.7596), Description: Copy the input grid. Find the smallest connected object. If there is a smallest object, change the color of the cell directly above the uppermost cell of the smallest object to red. If there is no smallest object, leave the grid unchanged. 
:: def adbdfgdddjeiedehjaahbbiicgdchjff(I):
  smallest_obj = argmin(objects(I, True, False, False), size) if len(objects(I, True, False, False)) > 0 else initset(((0, (0, 0)),)) # Find the smallest object (or a dummy if none exist)
  top_row = uppermost(smallest_obj)  # Get the row index of the uppermost cell in the smallest object
  target_column = leftmost(smallest_obj)  # Get the column index of the leftmost cell in the smallest object (and hence the target column)
  O = fill(I, 2, {(top_row - 1, target_column)})  # Fill the cell above the uppermost cell with '2'
  return O
 
20.0, tensor(0.3325), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. Create a blue outline around the original position of the largest object. The background color should remain the same. 
:: def caeedaiagjbcefajaddbgfgdadcegbgc(I):
  # Identify the largest object and background color
  obj = argmax(objects(I, T, F, T), size)
  bg = mostcolor(I)

  # Create shifted object and outline indices
  shifted_obj_indices = toindices(shift(obj, (1, 1)))
  outline_indices = delta(toindices(obj))

  # Construct output grid
  O = tuple(
    tuple(
      branch(
        contained((i, j), shifted_obj_indices), TWO,  # Color shifted object as 2
        branch(
          contained((i, j), outline_indices), ONE,    # Color outline as 1
          I[i][j]                                      # Retain original color otherwise
        )
      )
      for j in range(len(I[0]))                      # Iterate over columns
    )
    for i in range(len(I))                            # Iterate over rows
  )
  return O 
 
30.0, tensor(0.0724), Description: Copy the input grid. For each object, change the color of the middle column of the object to red. Then, move the top row of the input grid down to the row containing the rightmost '1' in the input grid. Change the color of the moved row to red. The background color should remain the same. 
:: def fchidaffaihdeejbbdeidccbbbhjeaie(I):
  target_row = max(i for i, j in ofcolor(I, 1))
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    middle_col = (leftmost(obj) + rightmost(obj)) // 2
    if uppermost(obj) == 0:
      O = paint(O, shift(recolor(2, obj), (target_row, 0)))
    else:
      O = paint(O, shift(recolor(2, frozenset((v, (i, j)) for v, (i, j) in obj if j == middle_col)), (-1, 0)))
  return O
 
33.5, tensor(0.1713), Description: Copy the input grid. For each cell with color 1, if it's in the top row, move it down to the row containing the rightmost '1' in the input grid. If it's in the middle column, change its color to red. The background color should remain the same. 
:: def iiheebaaifceehgabeefjfeedfcgejdc(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        if i == 0:
          O = paint(O, {(2, (max(k for k, r in enumerate(I) for v in r if v == 1), j))})
        else:
          O = paint(O, {(2, (i - 1, j))})
        if j == (len(row) - 1) // 2:
          O = paint(O, {(2, (i, j))})
  return O
 
39.5, tensor(0.1713), Description: Copy the input grid. For each cell with color 1, if it's in the top row, move it down to the row containing the rightmost '1' in the input grid. If it's in the middle column, change its color to red. The background color should remain the same. 
:: def hhbaacaefcchegabbjhcbbheiaihjdbb(I):
  O = paint(canvas(mostcolor(I), shape(I)), recolor(2, shift(toobject(asindices(crop(I, (0, 0), (1, width(I)))), I), (max(i for i, j in ofcolor(I, 1)), 0))))
  for i in range(1, height(I)):
    for j in range(width(I)):
      if I[i][j] == 1:
        O = paint(O, {(2 if j == (width(I) - 1) // 2 else I[i][j], (i - 1, j))})
  return O
 
26.5, tensor(0.0724), Description: Copy the input grid. For each object, change the color of the middle column of the object to red. Then, move the top row of the input grid down to the row containing the rightmost '1' in the input grid. Change the color of the moved row to red. The background color should remain the same. 
:: def agdigcdehdacecdebfbggiebfiffegfe(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, shift(recolor(2, frozenset((v, (i, j)) for v, (i, j) in obj if j == (leftmost(obj) + rightmost(obj)) // 2)), (max(i for i, j in ofcolor(I, 1)) if uppermost(obj) == 0 else -1, 0)))
  return O
 
34.0, tensor(0.1713), Description: Copy the input grid. For each cell with color 1, if it's in the top row, move it down to the row containing the rightmost '1' in the input grid. If it's in the middle column, change its color to red. The background color should remain the same. 
:: def gheeeaigbbcbedjiieabdjfeafgcfejb(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        new_i = max(i for i, j in ofcolor(I, 1)) if i == 0 else i - 1
        new_val = 2 if j == (len(row) - 1) // 2 else val
        O = paint(O, {(new_val, (new_i, j))})
  return O
 
29.0, tensor(0.6129), Description: Copy the input grid. For each cell that is not the background color, move it one space up and one space left, and change its color to red. The background color should remain the same. 
:: def fabaihcabchceghfjcaefbdegfedijjf(I):
    # Find the background color
    bg = mostcolor(I)
    # Create an empty canvas
    O = canvas(bg, shape(I))
    # Iterate through each cell in the input grid
    for i in range(height(I)):
        for j in range(width(I)):
            # If the cell is not background, shift and recolor
            if I[i][j] != bg:
                O = paint(O, {(TWO, (i-1, j-1))}) 
    return O
 
30.5, tensor(0.0214), Description: Copy the input grid. For each cell that is not the background color, move it one space up and one space left. The background color should remain the same. 
:: def jiidfcaiagfbedbfjcfaeijafdccceae(I):
  shifted_grid = canvas(mostcolor(I), shape(I))
  for i in range(1, len(I)):
    for j in range(1, len(I[0])):
      shifted_grid = paint(shifted_grid, {(I[i][j], (i - 1, j - 1))})
  return shifted_grid
 
16.0, tensor(0.5466), Description: Copy the input grid. Find the smallest connected object. If there is a smallest object, move it one space to the right and change its color to red. If there is no smallest object, leave the grid unchanged. 
:: def dcgbchbffbccebihjebfedehhbdafecg(I):
  objs = objects(I, True, False, False)
  min_size = minimum(apply(size, objs)) if objs else 1  # Find the size of the smallest object
  O = I
  for obj in objs:
    if size(obj) == min_size:
      O = paint(O, recolor(2, toindices(shift(obj, (0, 1)))))
  return O
 
18.0, tensor(0.5466), Description: Copy the input grid. Find the smallest connected object. If there is a smallest object, move it one space to the right and change its color to red. If there is no smallest object, leave the grid unchanged. 
:: def dibdaidfhcgbedibbbadeigeiddadcbc(I):
  def right_neighbor_if_smallest(obj):
    smallest_obj = argmin(objects(I, True, False, False), size) if len(objects(I, True, False, False)) > 0 else initset(((0, (0,0)),)) 
    return recolor(2, toindices(shift(obj, (0, 1)))) if obj == smallest_obj else obj
  
  O = paint(I, mfilter(objects(I, True, False, False), right_neighbor_if_smallest)) # Apply right_neighbor_if_smallest function to each object and paint
  return O
 
28.5, tensor(0.5211), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. For each cell that was originally part of the largest object, change its color to blue. The background color should remain the same. 
:: def dbafiddjjhiaejafabeiiegbjcibfjhf(I):
  # Identify the largest object
  obj = argmax(objects(I, T, F, T), size)
  
  # Generate shifted object
  shifted_obj = shift(obj, (1, 1))
  
  # Construct the output grid
  O = paint(
        underfill(canvas(ZERO, shape(I)), ONE, toindices(obj)), 
        recolor(TWO, shifted_obj)
      )
  return O
 
22.5, tensor(0.2891), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to blue. Create a red outline around the original position of the largest object. The background color should remain the same. 
:: def abfdfjgbhceheacgjficdjaebjhjbbce(I):
  # Find the largest object
  obj = argmax(objects(I, T, F, T), size)

  # Create a mask for the shifted object
  shifted_mask = paint(canvas(ZERO, shape(I)), recolor(ONE, shift(obj, (1, 1))))

  # Create a mask for the outline
  outline_mask = paint(canvas(ZERO, shape(I)), recolor(ONE, delta(toindices(obj))))

  # Combine the masks, giving priority to the shifted object
  combined_mask = cellwise(shifted_mask, outline_mask, ONE)

  # Replace the values in the combined mask to get the final output
  O = replace(replace(combined_mask, ONE, ZERO), TWO, ONE)
  return O 
 
32.0, tensor(0.4976), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. For each cell that was originally part of the largest object, if its neighboring cell (up, down, left, or right) is the background color, change the neighboring cell's color to blue. The background color should remain the same. 
:: def beciaidddfhbebjcbehdffbccjjdbjaj(I):
  # Identify the largest object and its shifted version
  obj = argmax(objects(I, T, F, T), size)
  shifted_obj = shift(obj, (1,1))
  
  # Create a grid filled with 2s where the shifted object exists
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, shifted_obj))

  # Iterate over each cell in the original object
  for i, j in toindices(obj):
    # Check if the neighboring cells are within the grid bounds
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
      ni, nj = i + di, j + dj
      if 0 <= ni < len(I) and 0 <= nj < len(I[0]):
        # If a neighboring cell is background, set it to 1
        if index(O, (ni, nj)) == ZERO:
          O = paint(O, {(ONE, (ni, nj))}) 
  return O
 
30.0, tensor(1.6278), Description: Copy the input grid. For each colored object, find the bottom row of the object and the rightmost column of the object. Change the color of the bottom three cells in that column to red. The background color should remain the same. 
:: def fhhjagchbeejeabfjfjhcbbhafjahafb(I):
  O = canvas(mostcolor(I), shape(I))  
  for obj in objects(I, T, F, T):
    rightmost_j = rightmost(obj)
    bottom_i = lowermost(obj)  # Find bottom row of the object
    O = paint(O, recolor(2, shift({(bottom_i, rightmost_j), (bottom_i - 1, rightmost_j), (bottom_i - 2, rightmost_j)}, (0, 0)))) 
  return O
 
35.0, tensor(1.6282), Description: Copy the input grid. For each colored object, find the top row of the object and the rightmost column of the object. Change the color of the top three cells in that column to red. The background color should remain the same. 
:: def gcefebhcfffaeiifbecccfajbfeabhcb(I):
  O = canvas(mostcolor(I), shape(I)) 
  for obj in objects(I, T, F, T):
    height_offset = height(obj) - 1
    rightmost_j = rightmost(obj)
    top_i = uppermost(obj)
    O = paint(O, recolor(2, shift({(top_i + height_offset, rightmost_j), (top_i + height_offset + 1, rightmost_j), (top_i + height_offset + 2, rightmost_j)}, (0, 0)))) 
  return O
 
32.5, tensor(1.6302), Description: Copy the input grid. For each colored object, find the rightmost column of the object. Change the color of the bottom three cells in that column to red. The background color should remain the same. 
:: def aafdgbebeiegedfbijigcegjddaccdcc(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, T):
        rightmost_j = rightmost(obj)
        O = paint(O, recolor(2, {(len(I) - 3, rightmost_j), (len(I) - 2, rightmost_j), (len(I) - 1, rightmost_j)}))
    return O
 
32.0, tensor(1.6299), Description: Copy the input grid. For each colored object, find the rightmost column of the object. Change the color of the middle three cells in that column to red. The background color should remain the same. 
:: def bcdhbgcecidfedahbdeacchiaecabfhc(I):
    O = canvas(mostcolor(I), shape(I))
    center_i = len(I) // 2 - 1
    for obj in objects(I, T, F, T):
        rightmost_j = rightmost(obj)
        O = paint(O, recolor(2, {(center_i, rightmost_j), (center_i + 1, rightmost_j), (center_i + 2, rightmost_j)}))
    return O
 
26.5, tensor(1.6280), Description: Copy the input grid. For each colored object, find the topmost row and rightmost column of the object. Change the color of the cell at that intersection to red. The background color should remain the same. 
:: def dbjeehjafigcedecabbdffcahddcfcde(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, T):
        uppermost_i = uppermost(obj)
        rightmost_j = rightmost(obj)
        O = paint(O, recolor(2, {(uppermost_i, rightmost_j)}))
    return O
 
32.5, tensor(0.6070), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space left, and change its color to red. The background color should remain the same. 
:: def afdcfeaefabeefbhabaigcdccffbdagf(I):
  # Create a blank canvas
  O = canvas(mostcolor(I), shape(I)) 
  # Iterate over all cells in the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If the cell is not background
      if I[i][j] != mostcolor(I):
        # Calculate the diagonally shifted coordinates
        new_i, new_j = i + 1, j - 1 
        # Check if the new coordinates are within the grid bounds
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
          # Paint the shifted cell onto the canvas with color '2'
          O = paint(O, {(TWO, (new_i, new_j))}) 
  return O
 
31.5, tensor(0.6070), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space left, and change its color to red. The background color should remain the same. 
:: def hcadhddcjjfjejebjdcbgdbifchdhbbb(I):
    # Identify the background color
    bg = mostcolor(I)
    # Create a new grid by shifting each cell down-left and recoloring
    O = tuple(
        tuple(
            TWO if 0 <= i + 1 < len(I) and 0 <= j - 1 < len(I[0]) and I[i + 1][j - 1] != bg else bg 
            for j in range(len(I[0]))
        )
        for i in range(len(I))
    )
    return O
 
29.0, tensor(1.1005), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object one space closer to the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def ajdaagagbeefeefbaeeededdedefghah(I):
  # Identify objects and their properties
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Find closest corner using nested loops
  min_dist = float('inf')
  closest_corner = None
  for corner_i, corner_j in corners(toindices(largest)):
    for point_i, point_j in toindices(second_largest):
      dist = abs(corner_i - point_i) + abs(corner_j - point_j)
      if dist < min_dist:
        min_dist = dist
        closest_corner = (corner_i, corner_j)

  # Determine shift based on relative position of centers of mass
  shift_x = 1 if centerofmass(second_largest)[0] > closest_corner[0] else -1
  shift_y = 1 if centerofmass(second_largest)[1] > closest_corner[1] else -1

  # Shift and recolor the second-largest object
  shifted = shift(recolor(2, second_largest), add(closest_corner, (shift_x, shift_y)))

  # Generate output
  O = paint(canvas(0, shape(I)), shifted)
  O = paint(O, difference(largest, {(index(I, closest_corner), closest_corner)}))
  return O
 
20.5, tensor(0.3825), Description: Copy the input grid. Find the largest object. Move the largest object one space to the right and one space down. Change the color of the moved object to red. Create a blue outline around the original position of the largest object. The background color should remain the same. 
:: def fibcdfdjfiehebcaagfdcfgddbhfcgad(I):
  # Identify the largest object and its outline
  largest_obj = argmax(objects(I, T, F, T), size)
  outline_indices = delta(toindices(largest_obj))
  
  # Construct the output grid using a lambda function
  return tuple(
      tuple(
          TWO if (i+1, j+1) in toindices(largest_obj) else (ONE if (i, j) in outline_indices else ZERO) 
          for j in range(len(I[0]))
      ) 
      for i in range(len(I))
  )
 
19.0, tensor(0.6300), Description: Copy the input grid. For each object that touches the top border and has color 1, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def hffffdgddcacefgdjbdbheibaeaafabi(I):
  # Create a copy of the input grid
  O = I
  
  # Iterate through each object
  for obj in objects(I, T, F, T):
    # Check if the object has a '1' in the top row
    if any(I[i][j] == 1 and i == 0 for i, j in toindices(obj)):
      # Recolor the object in the output grid to '2'
      O = fill(O, 2, obj)
      # Shift the object down in the output grid
      O = paint(cover(O, obj), shift(obj, DOWN))
  
  return O
 
16.0, tensor(0.6300), Description: Copy the input grid. For each object that touches the top border and has color 1, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def adicaijffccbeacjjfcceccgaeaafief(I):
  # Define a function to check if an object needs to be shifted
  def should_shift(obj):
    return uppermost(obj) == 0 and color(obj) == 1

  # Create a function to process each object
  def process_obj(obj):
    return shift(recolor(2, obj), DOWN) if should_shift(obj) else obj

  # Apply the processing function to all objects in the input
  processed_objs = apply(process_obj, objects(I, T, F, T))

  # Paint the processed objects onto a blank canvas
  return paint(canvas(mostcolor(I), shape(I)), merge(processed_objs))
 
21.5, tensor(0.6094), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space right, and change its color to red. The background color should remain the same. 
:: def bbfgadaeddcdeceeadfjefiafebhdhef(I):
  # Define a function to process each cell
  def process_cell(i, j):
    # Shift index down-left
    new_i, new_j = i + 1, j + 1
    # If shifted index is within bounds and the cell is not background, return "2"
    if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]) and I[i][j] != mostcolor(I):
      return TWO
    # Otherwise, return the original cell value
    return I[i][j]
  # Apply the function to each cell
  O = tuple(tuple(process_cell(i, j) for j in range(len(I[0]))) for i in range(len(I))) 
  return O
 
27.5, tensor(1.1005), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object one space closer to the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def efebcacehejcehjhbhfejbbdhiacfffj(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate relative position of second largest to largest
  rel_pos = position(second_largest, largest)

  # Define corner selection based on relative position
  corner_selector = {
    (1, 1): ulcorner, 
    (-1, 1): urcorner,
    (1, -1): llcorner,
    (-1, -1): lrcorner,
  }
  
  # Get closest corner function
  get_corner = corner_selector.get(rel_pos, lambda x: x) 

  # Apply function to get the closest corner
  closest_corner = get_corner(toindices(largest))

  # Calculate diagonal direction
  direction = (sign(closest_corner[0] - centerofmass(second_largest)[0]),
              sign(closest_corner[1] - centerofmass(second_largest)[1]))

  # Shift and recolor second largest object
  shifted = shift(recolor(2, second_largest), add(closest_corner, direction))

  # Remove corner from largest object
  largest = difference(largest, {(index(I, closest_corner), closest_corner)})

  # Generate output grid
  O = paint(canvas(0, shape(I)), shifted)
  O = paint(O, largest)
  return O
 
20.0, tensor(0.1027), Description: Copy the input grid. For each object that touches the top border, move it one space to the right and change its color to red. The colors of the objects should remain the same. 
:: def ahbbfabehaadefdcjeaccdcfagbaedif(I):
  shifted_objects = frozenset(shift(recolor(2, obj), (1, 0)) for obj in objects(I, T, F, T) if uppermost(obj) == 0)
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objects | objects(I, T, F, T)))
  return O
 
25.0, tensor(0.3494), Description: Copy the input grid. For each cell with color 1, if it's not in the top row and there is another cell with color 1 above it, move it one space down and change its color to red. The colors of the objects should remain the same. 
:: def baaejfehjfacegcbbecbebdcbcaabacg(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1 and any(I[k][j] == 1 for k in range(i)):
        if i < height(I) - 1:
          O = paint(O, {(2, (i + 1, j))})
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
23.5, tensor(0.0582), Description: Copy the input grid. For each object that has a cell in the top row with color 1, move it one space to the right and change its color to red. The colors of the objects should remain the same. 
:: def ceefcdhcdijjefgbiaeechabdagcefhf(I):
  O = I
  top_row_indices = {j for j in range(width(I)) if I[0][j] == 1}
  for obj in objects(I, T, F, T):
    if any(j in top_row_indices for i, j in toindices(obj)):
      O = paint(cover(O, obj), shift(recolor(2, obj), (1, 0)))
  return O
 
32.0, tensor(0.4732), Description: Copy the input grid. For each colored object, move it one space down and one space left, and change its color to red. The background color should remain the same. 
:: def hahfcccigdbfeaefaaagciggfdbdbfcc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    O = underpaint(O, recolor(TWO, shift(obj, DOWN_LEFT)))
  return O
 
31.5, tensor(0.5516), Description: Copy the input grid. For each colored object, move it one space down and one space left, and change its color to red. The background color should remain the same. Then, paint the original objects onto the grid, keeping their original colors. 
:: def jahfbeddjadbecjabahafbahbhehcgac(I):
  objs = objects(I, T, F, T)
  shifted_objs = {recolor(TWO, shift(obj, DOWN_LEFT)) for obj in objs}
  return paint(paint(canvas(mostcolor(I), shape(I)), merge(objs)), merge(shifted_objs))
 
17.5, tensor(0.0426), Description: Copy the input grid. Find the smallest connected object and move it one space to the right. Change the color of the moved object to red. Keep the original colors for all other cells. 
:: def ddaidcbfaafbedicjjdaacccgeihdfab(I):
  O = canvas(mostcolor(I), shape(I)) # Create a canvas filled with the background color of the input
  for obj in objects(I, True, False, False):
    if obj == argmin(objects(I, True, False, False), size):
      O = paint(O, recolor(2, shift(obj, (0, 1)))) # Paint the shifted and recolored smallest object onto the canvas
    else:
      O = paint(O, obj) # Paint other objects onto the canvas without modification
  return O
 
28.0, tensor(0.0432), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below the bottom-right corner of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its top-left corner is one space below and to the left of the bottom-right corner of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its top-left corner is one space above and to the right of the top-left corner of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its top-left corner is one space above and to the left of the top-left corner of the largest object. Keep the original colors for all other cells. 
:: def fhhhhgagfjffegheagfefjieddcdcdgj(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate the direction to move the second largest object
  direction = (sign(centerofmass(largest)[0] - centerofmass(second_largest)[0]),
              sign(centerofmass(largest)[1] - centerofmass(second_largest)[1]))

  # Calculate the offset for shifting
  offset = (height(largest) + 1 if direction[0] == 1 else 0,
            width(largest) + 1 if direction[1] == 1 else 0)

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), add(ulcorner(largest), multiply(offset, direction)))

  # Generate output by painting both objects on a blank canvas
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
26.5, tensor(0.0418), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its center is one space below and to the right of the center of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its center is one space below and to the left of the center of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its center is one space above and to the right of the center of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its center is one space above and to the left of the center of the largest object. Keep the original colors for all other cells. 
:: def cbfdegbdadaaeiefjaiaeeeehccbcdig(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Determine relative horizontal and vertical positioning of objects
  h_pos = 1 if centerofmass(second_largest)[1] > centerofmass(largest)[1] else -1
  v_pos = 1 if centerofmass(second_largest)[0] > centerofmass(largest)[0] else -1

  # Calculate offset based on relative positioning and object sizes
  offset = ((height(largest) + 1) * v_pos, 
            (width(largest) + 1) * h_pos)

  # Shift and recolor the second-largest object
  shifted_obj = shift(recolor(2, second_largest), add(center(largest), offset))

  # Generate the output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
33.0, tensor(0.0310), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space to the right of the bottom-right corner of the largest object if the second largest object is below the largest object. If the second largest object is above the largest object, move the second largest object so that its top-left corner is one space to the right of the top-left corner of the largest object. Keep the original colors for all other cells. 
:: def fheecceaahceeejcbdjgjccfdhfdieac(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Determine if the second largest object is above or below the largest
  above = uppermost(second_largest) < uppermost(largest)

  # Calculate the new corner position based on the relative position
  new_corner = branch(above, 
                      (uppermost(largest), rightmost(largest) + 1),
                      (lowermost(largest) + 1, leftmost(largest)))

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), subtract(new_corner, ulcorner(second_largest)))

  # Generate output by painting both objects on a blank canvas
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
29.0, tensor(0.0418), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its center is one space below and to the right of the center of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its center is one space below and to the left of the center of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its center is one space above and to the right of the center of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its center is one space above and to the left of the center of the largest object. Keep the original colors for all other cells. 
:: def ieahfeebjffaeffabeahbddabffeabdf(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate the difference in center of mass coordinates
  diff = subtract(centerofmass(largest), centerofmass(second_largest))

  # Determine the shift direction based on the difference
  direction = (1 if diff[0] > 0 else -1, 1 if diff[1] > 0 else -1)

  # Calculate the shift offset based on the direction and object size
  offset = ((height(largest) + 1) * direction[0], (width(largest) + 1) * direction[1])

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), add(center(largest), offset))

  # Generate output by painting both objects on a blank canvas
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
28.0, tensor(0.3325), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. Create a blue outline around the original position of the largest object. The background color should remain the same. 
:: def gdadeicaiafjeaccjgjdfabhgbbgadcf(I):
  # Find the largest object
  obj = argmax(objects(I, T, F, T), size)

  # Create functions to check for shifted object and outline
  is_shifted = lambda cell: contained(cell, toindices(shift(obj, (1, 1))))
  is_outline = lambda cell: any(contained(n, toindices(obj)) for n in dneighbors(cell)) and not contained(cell, toindices(obj))

  # Apply the functions to generate the output grid
  return tuple(
      tuple(
          TWO if is_shifted((i, j)) else (ONE if is_outline((i, j)) else ZERO)
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
28.0, tensor(0.0354), Description: Copy the input grid. For each object that touches the top border, move it one space down and change its color to red. For each object that touches the left border, move it one space to the right and change its color to red. The background color should remain the same. 
:: def adhbbabeeigdebbhidfeccihebajaaac(I):
  O = canvas(mostcolor(I), shape(I))
  top_objects = sfilter(objects(I, T, F, T), lambda obj: uppermost(obj) == 0)
  shifted_top = apply(lambda obj: shift(obj, DOWN), top_objects)
  recolored_top = apply(lambda obj: recolor(2, obj), shifted_top)
  left_objects = sfilter(objects(I, T, F, T), lambda obj: leftmost(obj) == 0)
  shifted_left = apply(lambda obj: shift(obj, RIGHT), left_objects)
  recolored_left = apply(lambda obj: recolor(2, obj), shifted_left)
  O = paint(O, merge(recolored_top | recolored_left))
  return O
 
18.0, tensor(0.1535), Description: Copy the input grid. For each cell that is not the background color and is in the top row or leftmost column, move it one space down or right, respectively, and change its color to red. The background color should remain the same. 
:: def cfeefeajjefaeiiaaahdffcbabicaged(I):
  O = I
  for i, j in product(range(height(I)), range(width(I))):
    if I[i][j] != mostcolor(I) and (i == 0 or j == 0):
      if i < height(I) - 1:
        O = paint(cover(O, {(I[i][j], (i, j))}), {(2, (i + 1, j))})
      if j < width(I) - 1:
        O = paint(cover(O, {(I[i][j], (i, j))}), {(2, (i, j + 1))})
  return O
 
27.0, tensor(0.1962), Description: Copy the input grid. For each colored object, if it touches the top border, move it one space down. If it touches the left border, move it one space to the right. Change the color of the moved objects to red. The background color should remain the same. 
:: def eeafbfggfbebehhfaacdceehffdcjecg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    new_obj = obj
    if uppermost(obj) == 0:
      new_obj = shift(new_obj, DOWN)
    if leftmost(obj) == 0:
      new_obj = shift(new_obj, RIGHT)
    O = paint(O, recolor(2, new_obj))
  return O
 
24.0, tensor(0.1962), Description: Copy the input grid. For each colored object, if it touches the top border, move it one space down. If it touches the left border, move it one space to the right. Change the color of the moved objects to red. The background color should remain the same. 
:: def bfbedddfbbdbeaaaihefbabccjfafedf(I):
  O = paint(canvas(mostcolor(I), shape(I)), asobject(I))
  for obj in objects(I, T, F, T):
    if uppermost(obj) == 0:
      O = underpaint(O, recolor(2, shift(obj, DOWN)))
    if leftmost(obj) == 0:
      O = underpaint(O, recolor(2, shift(obj, RIGHT)))
  return O
 
30.5, tensor(0.6070), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space left, and change its color to red. The background color should remain the same. 
:: def edffaedhajiaebhaibdigghffeecjhce(I):
    # Get background color
    bg = mostcolor(I)
    # Create a new grid by shifting and recoloring only non-background cells
    O = tuple(
        tuple(
            TWO if 0 <= i + 1 < len(I) and 0 <= j - 1 < len(I[0]) and I[i + 1][j - 1] != bg else I[i][j] 
            for j in range(len(I[0]))
        )
        for i in range(len(I))
    )
    return O
 
27.0, tensor(0.1963), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object to the top left corner of the grid. If the second largest object is in the same column as the largest object, remove the bottom-left corner cell from the largest object. Keep the original colors for all other cells. 
:: def eabdfdfgiddbeeffjfefccjebfbdfbdd(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Recolor the second largest object
  second_largest = recolor(2, second_largest)

  # Shift the second largest object to the top left corner
  shifted_obj = shift(second_largest, subtract((0, 0), ulcorner(second_largest)))

  # Remove bottom-left corner of the largest object if it's on the same column
  if leftmost(largest) == leftmost(second_largest):
    largest = difference(largest, {(index(I, (lowermost(largest), leftmost(largest))), (lowermost(largest), leftmost(largest)))})

  # Generate output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
33.0, tensor(0.0256), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def caedahfbbfdbeadcbbecddbgbefdjgae(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate the new position for the second largest object
  new_position = branch(uppermost(largest) < uppermost(second_largest), 
                       (0, width(I) - width(second_largest)),
                       (height(I) - height(second_largest), 0))

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), subtract(new_position, ulcorner(second_largest)))

  # Generate output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
31.0, tensor(0.0390), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space below and to the right of the bottom-right corner of the largest object if the second largest object is below and to the right of the largest object. If the second largest object is below and to the left of the largest object, move the second largest object so that its top-left corner is one space below and to the left of the bottom-right corner of the largest object. If the second largest object is above and to the right of the largest object, move the second largest object so that its top-left corner is one space above and to the right of the top-left corner of the largest object. If the second largest object is above and to the left of the largest object, move the second largest object so that its top-left corner is one space above and to the left of the top-left corner of the largest object. Remove the corner cell of the largest object that is closest to the second largest object. Keep the original colors for all other cells. 
:: def baeejjcdbddhejfebfbehcjfifbfgdce(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate shift direction based on object positions
  direction = position(second_largest, largest)

  # Calculate the shift amount
  shift_amount = (branch(direction[0] == -1, height(largest) + 1, 0), 
                   branch(direction[1] == 1, width(largest) + 1, 0))

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), add(ulcorner(largest), multiply(shift_amount, direction)))

  # Remove a corner cell from the largest object
  corner_to_remove = branch(direction == (1,1), ulcorner(largest),
                           branch(direction == (-1, 1), llcorner(largest),
                                  branch(direction == (1, -1), urcorner(largest),
                                         lrcorner(largest))))
  largest = difference(largest, {(index(I, corner_to_remove), corner_to_remove)})

  # Generate the output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
33.5, tensor(0.1472), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object so that its top-left corner is one space to the right of the bottom-right corner of the largest object. Remove the bottom-left corner cell from the largest object. Keep the original colors for all other cells. 
:: def giaaebddifbgedibicafcccbcdeajghc(I):
  # Identify objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate the new upper-left corner for the second largest object
  new_ul_corner = (uppermost(largest), rightmost(largest) + 1)

  # Shift and recolor the second largest object
  shifted_obj = shift(recolor(2, second_largest), subtract(new_ul_corner, ulcorner(second_largest)))

  # Remove the bottom-left corner cell from the largest object
  largest = difference(largest, {(index(I, (lowermost(largest), leftmost(largest))), (lowermost(largest), leftmost(largest)))})

  # Generate the output grid
  O = paint(canvas(0, shape(I)), largest)
  O = paint(O, shifted_obj)
  return O
 
23.0, tensor(0.1517), Description: Copy the input grid. Find the largest object and shift its bounding box one space to the right and one space down. Change the color of the shifted bounding box to red. Keep the original colors for all other cells. 
:: def ceheadifcheeegjiiffbdaaebdgghiaj(I):
  # Find the largest object and its bounding box
  obj = argmax(objects(I, T, F, T), size)
  bbox = backdrop(toindices(obj))

  # Create a grid with the shifted bounding box filled with the new color
  shifted_grid = fill(canvas(0, shape(I)), 2, shift(bbox, (1, 1)))

  # Combine the shifted grid with the original, prioritizing the original
  O = cellwise(I, shifted_grid, I[0][0])
  return O
 
34.0, tensor(0.3295), Description: Copy the input grid. For each colored object, if it touches the top border, draw a vertical line of red squares extending down from the object's top-left corner. If it touches the left border, draw a horizontal line of red squares extending right from the object's top-left corner. The background color should remain the same. 
:: def cficadcfejaiefgcbbbdibfgcicjbbcc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    if uppermost(obj) == 0:
      O = underfill(O, 2, vfrontier(ulcorner(obj)))
    if leftmost(obj) == 0:
      O = underfill(O, 2, hfrontier(ulcorner(obj)))
  return O
 
19.0, tensor(0.3295), Description: Copy the input grid. For each colored object, if it touches the top border, draw a vertical line of red squares extending down from the object's top-left corner. If it touches the left border, draw a horizontal line of red squares extending right from the object's top-left corner. The background color should remain the same. 
:: def bgdiidafecefecdabbadcfdbgiagiaii(I):
  O = canvas(mostcolor(I), shape(I)) 
  for obj in objects(I, T, F, T):
    start = ulcorner(obj)
    if uppermost(obj) == 0:
       O = fill(O, 2, connect(start, (lowermost(obj), start[1])))
    if leftmost(obj) == 0:
       O = fill(O, 2, connect(start, (start[0], rightmost(obj))))
    O = paint(O, obj) 
  return O
 
20.0, tensor(0.6070), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space left, and change its color to red. The background color should remain the same. 
:: def bbhhcgdiddbaeeijiejcefhabadadjjc(I):
  # Define a lambda function to shift and recolor a cell
  process_cell = lambda i, j: (2, (i + 1, j - 1)) if I[i][j] != mostcolor(I) else (I[i][j], (i, j))
  # Apply the processing function to each cell and filter out out-of-bounds cells
  new_cells = frozenset(process_cell(i, j) for i in range(len(I)) for j in range(len(I[0])))
  new_cells = frozenset((v, (i, j)) for v, (i, j) in new_cells if 0 <= i < len(I) and 0 <= j < len(I[0]))
  # Paint the processed cells onto a blank canvas
  O = paint(canvas(mostcolor(I), shape(I)), new_cells)
  return O
 
26.5, tensor(0.0256), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def abgdafbhfahgejjfbgjgdfgdjcdhfbef(I):
  # Identify the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  rest = difference(objs, {largest})
  second_largest = argmax(rest, size)
  
  # Define target position based on object's initial position
  target_pos = branch(uppermost(second_largest) < uppermost(largest),
                    (uppermost(second_largest), width(I)-width(second_largest)),
                    (height(I)-height(second_largest), leftmost(second_largest)))
  
  # Construct output grid
  O = canvas(ZERO, shape(I))
  O = paint(O, recolor(TWO, largest))  
  O = paint(O, recolor(TWO, shift(second_largest, subtract(target_pos, ulcorner(second_largest))))) 
  return O
 
29.0, tensor(0.0233), Description: Copy the input grid. Find the two largest objects. Change the color of both the largest and second largest objects to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def efcadfebcfadebccieceacfefcidbhab(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, size)
  largest, second_largest = sorted_objs[-1], sorted_objs[-2]

  new_corner = branch(uppermost(largest) > uppermost(second_largest),
                     (0, width(I) - width(second_largest)),
                     (height(I) - height(second_largest), 0)) 

  O = canvas(0, shape(I))
  O = paint(O, recolor(2, largest))
  O = paint(O, recolor(2, shift(second_largest, subtract(new_corner, ulcorner(second_largest)))))
  return O
 
22.5, tensor(0.0233), Description: Copy the input grid. Find the two largest objects. Change the color of both the largest and second largest objects to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def chcbfahhjfbaeaifajhfbafaiheaefcb(I):
  # Find objects
  objs = objects(I, T, F, T)
  
  # Find the two largest objects using a lambda function
  find_largest = lambda objs: argmax(objs, size)
  largest = find_largest(objs)
  second_largest = find_largest(difference(objs, {largest}))
  
  # Calculate the shift based on the position of the second largest object
  shift_amount = branch(any(i == 0 for i in ulcorner(second_largest)),
                       (0, width(I) - width(second_largest)),
                       (height(I) - height(second_largest), 0))
  
  # Create the output grid
  O = paint(canvas(0, shape(I)), recolor(2, largest))
  O = paint(O, recolor(2, shift(second_largest, shift_amount)))
  return O
 
12.0, tensor(0.0646), Description: Copy the input grid. Find the largest object and move it one space to the right and one space down. Change the color of the moved object to red. Keep the original colors for all other cells. 
:: def febjdjibfhheebfbicgcgdbiaifaccca(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)

  # Modify the input grid directly by shifting and recoloring the largest object
  O = paint(canvas(0, shape(I)), recolor(2, shift(largest_obj, (1, 1))))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i, j) not in toindices(largest_obj):
        O = paint(O, {(val, (i, j))})

  return O
 
23.5, tensor(0.2611), Description: Copy the input grid. Find the largest object and shift it one space to the left and one space up. Change the color of the shifted object to red. Keep the original colors for all other cells. The background color should remain the same. 
:: def fgihjhgcdabcedgijbggbeeebgigecgc(I):
  # Find the largest object and its bounding box
  largest_obj = argmax(objects(I, T, F, T), size)
  bbox = backdrop(largest_obj)

  # Create a lambda function to conditionally shift and recolor a cell
  transform_cell = lambda i, j, v: 2 if (i-1, j-1) in toindices(largest_obj) else v

  # Apply the transformation cell-wise and construct the output grid
  O = tuple(
      tuple(
          transform_cell(i, j, I[i][j]) if (i, j) in bbox else 0
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )

  return O
 
33.0, tensor(0.6094), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space right, and change its color to red. The background color should remain the same. 
:: def jcfdadecbfeceddaiadfefeibdabaabi(I):
  # Identify foreground cells 
  fg_indices = difference(asindices(I), ofcolor(I, mostcolor(I)))
  # Shift foreground indices down-right
  shifted_indices = shift(fg_indices, (1, 1))
  # Recolor shifted indices to 2
  recolored_obj = recolor(2, shifted_indices)
  # Underpaint recolored object onto the original grid
  O = underpaint(I, recolored_obj)
  return O
 
90.0, tensor(0.2242), Description: Copy the input grid. For each connected object, if it's in the second-to-last column, move it one space to the right and change its color to red. Keep the original colors for all other cells. 
:: def ccgbgicbjccjeaecjdieiigheejffeae(I):
  def shift_right_if_at_border(obj):
    return toindices(shift(obj, (0, 1))) if rightmost(obj) == len(I[0]) - 2 else initset(0)

  shifted_indices = mfilter(objects(I, True, False, False), shift_right_if_at_border)
  O = fill(I, 2, shifted_indices)
  return O
 
22.5, tensor(0.2242), Description: Copy the input grid. For each connected object, if it's in the second-to-last column, move it one space to the right and change its color to red. Keep the original colors for all other cells. 
:: def eaaeghdcjfccebcajbcagbaiagaadabj(I):
  O = I
  for obj in objects(I, True, False, False):
    if rightmost(obj) == len(I[0]) - 2: 
      O = paint(O, recolor(2, toindices(shift(obj, (0, 1)))))
  return O
 
28.0, tensor(1.7649), Description: Copy the input grid. For each cell that is not the background color and is in the second-to-last column, change its color to red. The background color should remain the same. 
:: def aajfecbeedfdeaadbcfchfiidgdgjcba(I):
  def conditional_shift(j, v):
    return 2 if v != mostcommon(I) and j == len(I[0]) - 2 else v

  O = tuple(tuple(conditional_shift(j, v) for j, v in enumerate(row)) for row in I)
  return O
 
33.5, tensor(0.0256), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def ebabiahiacbceafcijbabdehebihjddb(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)
  top_placement = uppermost(largest) > uppermost(second_largest)
  new_corner = (0, width(I) - width(second_largest)) if top_placement else (height(I) - height(second_largest), 0)
  O = canvas(0, shape(I))
  O = paint(O, largest)
  O = paint(O, recolor(2, shift(second_largest, subtract(new_corner, ulcorner(second_largest)))))
  return O
 
33.0, tensor(0.0256), Description: Copy the input grid. Find the two largest objects. Change the color of the second largest object to red. Move the second largest object to the top right corner of the grid if the second largest object is above the largest object. If the second largest object is below the largest object, move the second largest object to the bottom left corner of the grid. Keep the original colors for all other cells. 
:: def ddciaiechdhfejghbaedbdadaeajiabd(I):
  objs = objects(I, T, F, T)
  s_objs = order(objs, size)
  largest = s_objs[-1]
  second_largest = s_objs[-2]
  new_corner = (0, width(I) - width(second_largest)) if uppermost(largest) > uppermost(second_largest) else (height(I) - height(second_largest), 0)
  return paint(paint(canvas(0, shape(I)), recolor(2, shift(second_largest, subtract(new_corner, ulcorner(second_largest))))), largest)
 
29.0, tensor(0.6080), Description: Copy the input grid. For each cell that is not the background color, move it one space up and one space left, and change its color to red. The background color should remain the same. 
:: def bbcjdccdjcfcehgabjcdfeiaebccjihb(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        O = paint(O, {(2, (i - 1, j - 1))})
  return O
 
34.0, tensor(1.7837), Description: Copy the input grid. For each cell that is not the background color and is in the second row or second column, change its color to red. The background color should remain the same. 
:: def ajgbgfbjfdchecgeidaacdibfddcgfaf(I):
  return tuple(
    tuple(
      branch((i > 0 and j > 0 and I[i - 1][j - 1] != mostcolor(I)), 2, 0) 
      for j in range(len(I[0]))
    ) 
    for i in range(len(I))
  )
 
18.0, tensor(1.6456), Description: Copy the input grid. For each cell that is in the top row or leftmost column, change its color to red. Keep the original colors for all other cells. The background color should remain the same. 
:: def cdehbeddabddejfaibfefcbjacciedfb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    for i, j in toindices(obj):
      if i == 0 or j == 0:
        O = fill(O, 2, {(i, j)})
      else:
        O = fill(O, index(I, (i, j)), {(i, j)})
  return O
 
18.5, tensor(0.6094), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space right, and change its color to red. The background color should remain the same. 
:: def jdfebcjcdiddefjfifbfdcafeffaeiej(I):
  bg = mostcolor(I)
  O = tuple(
    tuple(
        2 if any(0 <= i + 1 < len(I) and 0 <= j + 1 < len(I[0]) and I[i + 1][j + 1] != bg and (v, (i + 1, j + 1)) in obj
                 for obj in objects(I, T, F, T)) else I[i][j]
        for j, v in enumerate(row)
    ) for i, row in enumerate(I)
  )
  return O
 
25.0, tensor(0.2242), Description: Copy the input grid. For each connected object, if it's in the second-to-last column, move it one space to the right and change its color to red. Keep the original colors for all other cells. 
:: def dfbedabajbhbefjaifdjbccfcecdadce(I):
  O = I  # Initialize output as input
  for obj in objects(I, True, False, False):
    if rightmost(obj) == len(I[0]) - 2:
      O = paint(cover(O, obj), recolor(2, shift(obj, (0, 1)))) # Cover, recolor, shift, paint
  return O
 
32.0, tensor(1.7705), Description: Copy the input grid. For each cell that is not the background color, move it to the bottom right corner of the grid, keeping its original color. Then, add a blue cell to the right of the moved cell. The background color should remain the same. 
:: def cbjaejehdhdeeegdjgifhcbheebaedgj(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != mostcolor(I):
        O = paint(O, {(v, (j, len(I) - 1 - i))})
        O = paint(O, {(1, (j + 1, len(I) - i))})
  return O
 
22.5, tensor(1.5704), Description: Rotate the input grid 90 degrees clockwise. Create a new grid with the same dimensions and background color as the input. For each cell in the input grid that is not the background color, move it one space down and one space right in the new grid and change its color to blue. Then, overlay the rotated grid onto the new grid, keeping the original colors of the rotated grid and the blue cells from the new grid. The background color should remain the same. 
:: def bcaigddbcfbaefbcjahbeddefcfbfged(I):
  rotated = rot90(I)
  shifted = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        shifted = fill(shifted, 1, {(i + 1, j + 1)})
  O = cellwise(rotated, shifted, mostcolor(I))
  return O
 
32.5, tensor(1.7027), Description: Copy the input grid. Move the object up by one space and right by one space. Draw a diagonal line from the bottom right corner of the moved object to the right, extending three spaces. Draw a horizontal line from two spaces to the left and one space above the bottom left corner of the moved object, extending five spaces to the right. Change the color of the cell one space above and to the left of the moved object to the original color of the object. The background color should remain the same. 
:: def dceegdajecfbegcaijgcaabfibccedbi(I):
  obj = first(objects(I, T, F, T))  # Extract the object (assuming single object)
  color_obj = color(obj)
  indices = toindices(obj)
  new_obj = shift(obj, (-1, 1))  # Shift object up by one, right by one
  line1 = connect(lrcorner(new_obj), (lrcorner(new_obj)[0] + 3, lrcorner(new_obj)[1]))
  line2 = connect((llcorner(new_obj)[0] + 2, llcorner(new_obj)[1] - 1), (llcorner(new_obj)[0] + 5, llcorner(new_obj)[1] - 1))
  I = fill(I, 0, indices)  # Clear original object
  I = paint(I, new_obj) # Paint shifted object
  I = fill(I, 1, line1)  # Draw diagonal line
  I = fill(I, 1, line2)  # Draw horizontal line
  I = fill(I, color_obj, ((uppermost(new_obj) - 1, leftmost(new_obj)),))
  return I 
 
32.0, tensor(1.7026), Description: Copy the input grid. Move each cell of the object one space down and one space right. Draw a diagonal line from the bottom right corner of the moved object to the right, extending three spaces. Draw a horizontal line from two spaces to the left and one space above the bottom left corner of the moved object, extending five spaces to the right. Change the color of the cell two spaces above and one space to the right of the moved object to the original color of the object. The background color should remain the same. 
:: def edcdbdhefbdbegaebbehjgdifbdfdada(I):
  obj = first(objects(I, T, F, T))  # Extract the object
  color_obj = color(obj)
  new_I = canvas(0, shape(I))  # Create an empty canvas
  for v, (i, j) in obj:
    new_I = fill(new_I, v, {(i - 1, j + 1)})  # Place each cell of the object in a new location
  line1 = connect((lowermost(obj), rightmost(obj) + 1), (lowermost(obj) + 3, rightmost(obj) + 1))
  line2 = connect((lowermost(obj) + 2, leftmost(obj)), (lowermost(obj) + 5, leftmost(obj)))
  new_I = fill(new_I, 1, line1)  # Draw diagonal line
  new_I = fill(new_I, 1, line2)  # Draw horizontal line
  new_I = fill(new_I, color_obj, ((uppermost(obj) - 2, leftmost(obj) + 1),))
  return new_I
 
32.0, tensor(1.7023), Description: Copy the input grid. Move the object up by one space and right by one space. Place a horizontally mirrored copy of the object two spaces down and three spaces to the right of the original object. Draw lines based on the mirrored object's location. The background color should remain the same. 
:: def degagbedfdeiededibgbbfeehhffhaff(I):
  obj = first(objects(I, T, F, T))
  color_obj = color(obj)
  I = paint(cover(I, obj), shift(obj, (-1, 1)))  # Clear & paint shifted object
  sym_obj = hmirror(obj)  # Assume horizontal mirroring is a part of the transformation
  I = paint(I, shift(sym_obj, (2, 3)))  # Place mirrored object at a calculated position
  # ... additional code to draw lines based on the mirrored object's location
  return I
 
30.0, tensor(0.0444), Description: Copy the input grid. Find the smallest and largest objects. Move the smallest object to the bottom right corner of the grid. Change the color of the largest object to red for any cells that are on the same row and column as the cell. Keep the original colors for all other cells. 
:: def bfjbbdciaheeehibjbihebcjicbdabhe(I):
  # Identify objects
  objs = objects(I, T, F, T)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)

  # Move small object to bottom right
  new_corner = (height(I) - height(small_obj), width(I) - width(small_obj))
  small_obj = shift(small_obj, subtract(new_corner, ulcorner(small_obj)))

  # Recolor large object with diagonal pattern
  recolored_large_obj = set()
  for v, (i, j) in large_obj:
    recolored_large_obj.add((2 if i == j else 0, (i, j)))

  # Construct output grid
  O = canvas(0, shape(I))
  O = paint(O, small_obj)
  O = paint(O, frozenset(recolored_large_obj))
  return O
 
23.5, tensor(0.0877), Description: Copy the input grid. For each cell with color 1 (small object), move it to the opposite corner of the grid, keeping its original color. For each cell with color 2 (large object), change its color to red if it's on the same row and column as the cell, otherwise keep it black. 
:: def eibdfcafheebebigieheaceccddfbfif(I):
  # Directly manipulate the grid
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:  # Small object
        O = paint(O, {(1, (height(I) - 1 - i % height(I), width(I) - 1 - j % width(I)))})
      elif val == 2:  # Large object
        O = paint(O, {(2 if i == j else 0, (i, j))})
  return O
 
34.0, tensor(0.0444), Description: Copy the input grid. Find the smallest and largest objects. Move the smallest object to the bottom right corner of the grid. Change the color of the largest object to red for any cells that are on the same row and column as the cell. Keep the original colors for all other cells. 
:: def hddcadgihhfbehjcihdiaadaehddjbid(I):
  # Move the smaller object
  objs = objects(I, T, F, T)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)
  new_corner = (height(I) - height(small_obj), width(I) - width(small_obj))
  O = paint(canvas(0, shape(I)), recolor(1, shift(small_obj, subtract(new_corner, ulcorner(small_obj)))))

  # Recolor the larger object
  for i in range(height(large_obj)):
    for j in range(width(large_obj)):
      if i != j:
        O = replace(O, 2, 0)  
  
  O = paint(O, recolor(2, large_obj))
  return O
 
28.5, tensor(0.0444), Description: Copy the input grid. Find the smallest and largest objects. Move the smallest object to the bottom right corner of the grid. Change the color of the largest object to red for any cells that are on the same row and column as the cell. Keep the original colors for all other cells. 
:: def ececfeeghfcceahcijbecadjbjbgajjf(I):
  # Define functions for object manipulation and recoloring
  move_small = lambda O, small: paint(O, recolor(1, shift(small, subtract((height(I) - height(small), width(I) - width(small)), ulcorner(small)))))
  recolor_large = lambda O, large: paint(O, frozenset({(2 if i == j else 0, (i, j)) for v, (i, j) in large}))
  
  # Identify objects
  objs = objects(I, T, F, T)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)

  # Apply transformations
  return chain(lambda x: move_small(x, small_obj), lambda x: recolor_large(x, large_obj), lambda x: canvas(0, shape(I)))(I) 
 
31.0, tensor(1.7025), Description: Copy the input grid. Move the object up by one space and right by one space. Fill the top left corner with the original color of the object. Draw a diagonal line from the top left corner of the moved object, extending three spaces down and right. Draw a horizontal line from the top left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def bcefdghhdfceefaebhfdfjfbffacdcbc(I):
  obj = first(objects(I, T, F, T))  # Isolate the object
  color_obj = color(obj)  # Get object's color
  ul = ulcorner(obj)  # Get upper left corner of the object
  I = fill(I, 0, toindices(obj))  # Clear original object
  I = paint(I, shift(obj, (-1, 1)))  # Shift object up and right
  I = fill(I, color_obj, ((ul[0], ul[1] + 1),))  # Fill top left corner
  for i in range(3):
    I = fill(I, 1, ((ul[0] + i + 1, ul[1] + i + 2),))  # Draw diagonal line
    I = fill(I, 1, ((ul[0] + i + 2, ul[1]),))  # Draw horizontal line
  return I
 
32.0, tensor(1.7025), Description: Copy the input grid. Move the object up by one space and right by one space. Fill the top left corner with the original color of the object. Draw a diagonal line from the bottom right corner of the moved object, extending two spaces down and right. Draw a horizontal line from one space above the bottom left corner of the moved object, extending two spaces to the right. The background color should remain the same. 
:: def bcfeaeccebedeeadaeehacddgcjbegea(I):
  obj = first(objects(I, T, F, T))
  obj_color = color(obj)
  obj_height, obj_width = shape(obj)
  I = paint(canvas(0, shape(I)), shift(obj, (-1, 1)))  # Clear and shift object
  start_diag = (obj_height, obj_width + 1)
  start_horiz = (1, obj_width + 2)
  diag_line = connect(start_diag, add(start_diag, (2, 2)))  # Calculate diagonal line indices
  horiz_line = connect(start_horiz, add(start_horiz, (2, 0)))  # Calculate horizontal line indices
  I = fill(I, 1, diag_line)  # Draw diagonal line
  I = fill(I, 1, horiz_line)  # Draw horizontal line
  I = fill(I, obj_color, ((0, 1),))  # Fill top left corner
  return I
 
34.0, tensor(1.7025), Description: Copy the input grid. Move the object up by one space and right by one space. Fill the top left corner with the original color of the object. Draw a diagonal line from the bottom right corner of the moved object, extending three spaces down and right. Draw a horizontal line from the top left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def acdhibiafgfbejedidbecbedajcfebij(I):
  obj = first(objects(I, T, F, T))
  c = color(obj)
  ul = ulcorner(obj)
  I = paint(cover(I, obj), shift(obj, (-1, 1)))  # Clear and shift in one step
  I = fill(I, 1, connect((ul[0] + shape(obj)[0] - 1, ul[1] + shape(obj)[1]), (ul[0] + shape(obj)[0] + 2, ul[1] + shape(obj)[1])))  # Diagonal line
  I = fill(I, 1, connect((ul[0] + shape(obj)[0], 0), (ul[0] + shape(obj)[0] + 3, 0)))  # Horizontal line
  return fill(I, c, ((0, 1),))  # Fill top left corner
 
32.0, tensor(1.7025), Description: Copy the input grid. Move the object up by one space and right by one space. Fill the top left corner with the original color of the object. Draw a diagonal line from the bottom right corner of the moved object, extending three spaces down and right. Draw a horizontal line from the top left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def biadbciffdbdefchijfffcecbjbgdefc(I):
  obj = first(objects(I, T, F, T))
  color_obj = color(obj)
  h, w = shape(obj)
  I = paint(canvas(0, shape(I)), shift(obj, (-1, 1)))
  line1 = frozenset({(h + i, w + i + 1) for i in range(3)})  # Set comprehension for diagonal line
  line2 = frozenset({(h + i + 1, 0) for i in range(3)})  # Set comprehension for horizontal line
  I = fill(I, 1, line1)
  I = fill(I, 1, line2)
  I = fill(I, color_obj, ((0, 1),))
  return I
 
33.0, tensor(1.7025), Description: Copy the input grid. Move the object up by one space and right by one space. Fill the top left corner with the original color of the object. Draw a diagonal line from the bottom right corner of the moved object, extending two spaces down and right. Draw a horizontal line from one space above the bottom left corner of the moved object, extending two spaces to the right. The background color should remain the same. 
:: def bfjeeeeheffeeecfbdbedgeehafiacei(I):
  obj = first(objects(I, T, F, T))
  obj_color = color(obj)
  I = paint(canvas(0, shape(I)), shift(obj, (-1, 1)))  # Clear and shift
  ul = (shape(obj)[0], shape(obj)[1] + 1)  # Define starting point for lines
  I = fill(I, 1, connect(ul, add(ul, (2, 2))))  # Diagonal line
  I = fill(I, 1, connect((ul[0] + 1, 0), (ul[0] + 4, 0)))  # Horizontal line
  return fill(I, obj_color, ((0, 1),))  # Fill top left corner
 
27.5, tensor(1.7827), Description: Copy the input grid. Find the smallest and largest objects. Change the color of the smallest object to blue. Change the color of the largest object to red if its top-left corner is on the diagonal (same row and column), otherwise change it to black. Keep the original colors for all other cells. 
:: def jbecehibfgdbedcibbefbdgfjeicbbad(I):
  # Create a function to handle object transformations
  def transform_object(O, obj, color_func):
    return paint(O, recolor(color_func(obj), shift(obj, subtract((height(I) - height(obj), width(I) - width(obj)), ulcorner(obj)))))

  # Define color functions for each object
  small_color = lambda obj: 1
  large_color = lambda obj: 2 if ulcorner(obj)[0] == ulcorner(obj)[1] else 0  # Check diagonal based on corner

  # Apply transformations using the function and a blank canvas
  return chain(
    lambda O: transform_object(O, argmin(objects(I, T, F, T), size), small_color),
    lambda O: transform_object(O, argmax(objects(I, T, F, T), size), large_color),
    lambda x: canvas(0, shape(I)) 
  )(I)
 
29.0, tensor(0.6054), Description: Copy the input grid. For each cell that is not the background color, move it one space down and one space right, and change its color to red. The background color should remain the same. 
:: def cedifbdbcgbbeefcafheiajfieababhg(I):
  return tuple(
      tuple(
          index(I, (j - 1, i + 1)) if 0 <= j - 1 < len(I[0]) and 0 <= i + 1 < len(I) else 0
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
33.0, tensor(1.7026), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from the bottom right corner of the moved object, extending two spaces down and right. Draw a horizontal line from two spaces above the bottom left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def ccjechabcabaefdhjgjeaaafcghcdecf(I):
  obj = first(objects(I, T, F, T))
  I = paint(canvas(0, shape(I)), shift(obj, (1, 1)))
  start_diag = add(lrcorner(obj), (1, 1))
  start_hor = add(llcorner(obj), (2, 0))
  I = fill(I, 1, connect(start_diag, add(start_diag, (2, 2))))
  I = fill(I, 1, connect(start_hor, add(start_hor, (3, 0)))) 
  return I
 
32.0, tensor(1.7025), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from the top right corner of the moved object, extending two spaces down and right. Draw a horizontal line from two spaces above the bottom left corner of the moved object, extending five spaces to the right. The background color should remain the same. 
:: def bbeaabdhjcceefagbhfgbfgbfdhihhaa(I):
  obj = first(objects(I, T, F, T))
  bg = mostcolor(I)
  I = fill(I, bg, asindices(I))
  I = paint(I, shift(obj, (1, 1)))
  ur = urcorner(obj)
  I = fill(I, 1, connect((ur[0] + 1, ur[1] + 1), (ur[0] + 3, ur[1] + 3)))
  I = fill(I, 1, connect((ur[0] + 2, 0), (ur[0] + 5, 0)))
  return I 
 
33.0, tensor(1.7026), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from the top left corner of the moved object, extending two spaces down and right. Draw a horizontal line from one space below the top left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def cabdjeeddedfefhhadacdfgdeccihcca(I):
  obj = first(objects(I, T, F, T))
  I = paint(canvas(0, shape(I)), shift(obj, (1, 1)))
  diag_start = add(ulcorner(obj), (height(obj), width(obj) + 1))
  hor_start = add(ulcorner(obj), (height(obj) + 1, 0)) 
  I = fill(I, 1, connect(diag_start, add(diag_start, (2, 2))))
  I = fill(I, 1, connect(hor_start, add(hor_start, (3, 0))))
  return I
 
23.0, tensor(0.5005), Description: Copy the input grid. Find the object with color '2'. Shift it one space down and one space right. Rotate the shifted object 90 degrees clockwise and change its color to blue. Place the rotated object at the original location of the '2' object. The background color should remain the same. 
:: def ebjdaddcfdfdegccibcedebcefeggjdh(I):
  """
  Finds the '2' object, rotates it 90 degrees clockwise,
  and places it relative to the original object's location.
  """
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))  # Find the '2' object
  shifted_obj = shift(obj, (1, 1))  # Shift down and right
  rotated_obj = frozenset({(1, (j, -i)) for _, (i, j) in normalize(shifted_obj)})  # Rotate and recolor
  return paint(canvas(0, shape(I)), rotated_obj)  # Paint on a blank canvas
 
26.5, tensor(0.4318), Description: Copy the input grid. Find the object with color '2'. Shift it one space down and one space right. Change the color of the shifted object to blue. Place the shifted object at the original location of the '2' object. The background color should remain the same. 
:: def ehdcabcabbabededaajjcddfbeadbcfb(I):
  """
  This version iterates through the '2' object's indices,
  calculating the new position for each '1' cell.
  """
  obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
  h, w = shape(I)
  new_obj = set()
  for i, j in toindices(obj):
    new_obj.add((1, (i + 1, j + 1))) 
  return paint(canvas(0, (h, w)), frozenset(new_obj)) 
 
24.5, tensor(1.7288), Description: Copy the input grid. For each cell with color '2', change its color to black. If the cell to the right and below the current cell is within the grid boundaries, change its color to blue. The background color should remain the same. 
:: def cefgdeaiafifedgciadhaebicgibhahj(I):
  """
  This version directly manipulates the input grid, 
  replacing '2's with '0's and painting '1's in new positions. 
  """
  grid = list(list(row) for row in I)
  for i, row in enumerate(grid):
    for j, v in enumerate(row):
      if v == 2:
        grid[i][j] = 0
        if 0 <= i + 1 < len(grid) and 0 <= j + 1 < len(row):
          grid[i + 1][j + 1] = 1
  return tuple(tuple(row) for row in grid)
 
26.5, tensor(1.6415), Description: Copy the input grid. For each colored object, move it one space down and one space right. Rotate the shifted object 90 degrees clockwise and change its color to blue. Place the rotated object at the original location of the object. The background color should remain the same. 
:: def aicfbheacbeheeecidgibhbdegbfjadi(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, T):
        shifted_obj = shift(toindices(obj), (1, 1))
        transformed_obj = recolor(1, toobject(frozenset((i - 1, j + 1) for i, j in shifted_obj), rot90(I)))
        O = paint(O, transformed_obj)
    return O
 
31.5, tensor(1.6415), Description: Copy the input grid. For each colored object, move it one space down and one space right. Rotate the shifted object 90 degrees clockwise and change its color to blue. Place the rotated object at the original location of the object. The background color should remain the same. 
:: def eaejejacffffeeeejadgibiihgeeebfe(I):
  shifted_objs = mapply(lambda obj: shift(toindices(obj), (1, 1)), objects(I, T, F, T))
  rotated_grid = rot90(I)
  transformed_obj = recolor(1, toobject(shifted_objs, rotated_grid))
  return paint(I, transformed_obj)
 
30.5, tensor(1.7021), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a box around the moved object using blue. Draw a diagonal line from two spaces below and to the right of the top right corner of the moved object, extending two spaces down and right. Draw a horizontal line from two spaces below and to the left of the bottom left corner of the moved object, extending five spaces to the right. The background color should remain the same. 
:: def fdhfdbcfghbcecceajfafgefccgechca(I):
  obj = first(objects(I, T, F, T))
  O = fill(canvas(0, shape(I)), 0, asindices(canvas(0, shape(I)))) # Create an empty canvas
  O = paint(O, shift(obj, (1, 1))) # Move the object
  O = fill(O, 1, box(shift(obj, (1, 1)))) # Draw the box
  O = fill(O, 1, connect(add(urcorner(shift(obj, (1, 1))), (2, 2)), add(urcorner(shift(obj, (1, 1))), (4, 4)))) # Draw the upper-right line
  O = fill(O, 1, connect(add(llcorner(shift(obj, (1, 1))), (2, 0)), add(llcorner(shift(obj, (1, 1))), (5, 0)))) # Draw the lower-left line
  return O
 
31.0, tensor(1.7021), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a box around the moved object using blue. Draw a diagonal line from one space below and to the right of the top right corner of the moved object, extending two spaces down and right. Draw a horizontal line from one space below and to the left of the bottom left corner of the moved object, extending three spaces to the right. The background color should remain the same. 
:: def gbjeaigihjebeadiiadcjbcdfbbcabca(I):
  obj = first(objects(I, T, F, T))
  O = paint(fill(canvas(0, shape(I)), 0, asindices(canvas(0, shape(I)))), shift(obj, (1, 1))) # Create canvas, move and paint the object
  ur = add(urcorner(shift(obj, (1, 1))), (1, 1)) # Calculate corner + offset for lines
  ll = add(llcorner(shift(obj, (1, 1))), (1, 0)) 
  O = fill(O, 1, box(shift(obj, (1, 1)))) # Draw the box
  O = fill(O, 1, connect(ur, add(ur, (2, 2)))) # Draw the upper-right line
  O = fill(O, 1, connect(ll, add(ll, (3, 0)))) # Draw the lower-left line
  return O
 
43.5, tensor(1.7023), Description: Copy the input grid. For each cell in the object, move it one space down and one space right. Draw a vertical line of blue squares extending down from the moved cell, starting two spaces to the right of the cell and extending four spaces down. Draw a vertical line of blue squares extending down from the moved cell, starting two spaces to the left of the cell and extending four spaces down. The background color should remain the same. 
:: def cieeahibadfaefdfbjeebbcabbbfbibb(I):
  obj = first(objects(I, T, F, T))
  O = canvas(0, shape(I))
  for v, (i, j) in obj:
    O = fill(O, v, {(i + 1, j + 1)})
    O = fill(O, 1, {(i, j + 2), (i + 1, j + 2), (i + 2, j + 2), (i + 2, j + 1), (i + 2, j), (i + 3, j), (i + 4, j)})
    O = fill(O, 1, {(i, j - 2), (i + 1, j - 2), (i + 2, j - 2), (i + 2, j - 1), (i + 2, j), (i + 3, j), (i + 4, j)})
  return O
 
32.5, tensor(1.7027), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from two spaces below and to the right of the top right corner of the moved object, extending three spaces down and right. Draw a horizontal line from two spaces below and to the left of the bottom left corner of the moved object, extending five spaces to the right. Draw a vertical line from one space below and to the right of the bottom right corner of the moved object, extending four spaces down. The background color should remain the same. 
:: def bdhhdfffdhccehccbaefeaebbedeaeid(I):
  obj = first(objects(I, T, F, T))  # Isolate the object
  O = paint(canvas(0, shape(I)), shift(obj, (1, 1)))  # Move the object
  O = fill(O, 1, connect(add(urcorner(shift(obj, (1, 1))), (2, 2)), add(urcorner(shift(obj, (1, 1))), (5, 4))))  # Upper-right line
  O = fill(O, 1, connect(add(llcorner(shift(obj, (1, 1))), (2, 0)), add(llcorner(shift(obj, (1, 1))), (5, 0))))  # Lower-left line
  O = fill(O, 1, connect(add(lrcorner(shift(obj, (1, 1))), (1, 1)), add(lrcorner(shift(obj, (1, 1))), (1, 4))))  # Horizontal line
  return O
 
34.5, tensor(1.7027), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from two spaces below and to the right of the top right corner of the moved object, extending one space down and right. Draw a horizontal line from two spaces below and to the left of the bottom left corner of the moved object, extending one space to the right. Draw a vertical line from one space below and to the right of the bottom right corner of the moved object, extending four spaces down. The background color should remain the same. 
:: def bgebeddieddjeifbidehfebafbedahfa(I):
  obj = first(objects(I, T, F, T))
  O = paint(canvas(0, shape(I)), shift(obj, (1, 1)))
  O = fill(O, 1, shoot(add(urcorner(shift(obj, (1, 1))), (2, 2)), (1, 1)))  # Upper-right line
  O = fill(O, 1, shoot(add(llcorner(shift(obj, (1, 1))), (2, 0)), (1, 0)))  # Lower-left line
  O = fill(O, 1, connect(add(lrcorner(shift(obj, (1, 1))), (1, 1)), add(lrcorner(shift(obj, (1, 1))), (1, 4))))  # Horizontal line
  return O
 
32.5, tensor(1.7028), Description: Copy the input grid. Move the object one space to the right and one space down. Draw a diagonal line from two spaces below and to the right of the top right corner of the moved object, extending one space down and right. Draw a diagonal line from two spaces below and to the left of the bottom left corner of the moved object, extending one space down and left. Draw a vertical line from one space below and to the right of the bottom right corner of the moved object, extending four spaces down. The background color should remain the same. 
:: def cfbcjbjhdajeeeigjddjebfheibbiead(I):
  obj = first(objects(I, T, F, T))
  O = paint(canvas(0, shape(I)), shift(obj, (1, 1)))
  O = fill(O, 1, {(i, j) for i in range(urcorner(shift(obj, (1, 1)))[0] + 2, lrcorner(shift(obj, (1, 1)))[0] + 3) for j in range(urcorner(shift(obj, (1, 1)))[1] + 2, lrcorner(shift(obj, (1, 1)))[1] + 3) if i - j == urcorner(shift(obj, (1, 1)))[0] - urcorner(shift(obj, (1, 1)))[1] + 2})  # Upper-right line
  O = fill(O, 1, {(i, j) for i in range(llcorner(shift(obj, (1, 1)))[0] + 2, lrcorner(shift(obj, (1, 1)))[0] + 3) for j in range(llcorner(shift(obj, (1, 1)))[1] - 2, urcorner(shift(obj, (1, 1)))[1] - 1) if i + j == llcorner(shift(obj, (1, 1)))[0] + llcorner(shift(obj, (1, 1)))[1] + 2})  # Lower-left line
  O = fill(O, 1, connect(add(lrcorner(shift(obj, (1, 1))), (1, 1)), add(lrcorner(shift(obj, (1, 1))), (1, 4))))  # Horizontal line
  return O
 
22.5, tensor(0.0664), Description: Copy the input grid. For each object in the grid, if it's the smallest object (size 3), rotate it 180 degrees and place it in the opposite corner of the grid, keeping its original color. If it's the largest object (size 6), change the color of the cells on the top-left diagonal to red and change the color of the cells on the bottom-right diagonal to red, shifting the bottom-right diagonal one space down and one space right. Keep the original colors for all other cells. 
:: def iadbeficeidfeahdjjaijfbjccfbfbeg(I):
  # Directly manipulate the grid using object properties
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) == 3: # Small object
      O = paint(O, recolor(1, shift(rot180(obj), subtract((len(I)-height(obj), len(I[0])-width(obj)), ulcorner(obj)))))
    elif size(obj) == 6: # Large object
      O = paint(O, recolor(2, frozenset((i, j) for i, j in toindices(obj) if i <= j))) # Top-left diagonal
      O = paint(O, recolor(2, shift(frozenset((i, j) for i, j in toindices(obj) if i > j), (1, 1)))) # Bottom-right diagonal shifted
  return O
 
28.5, tensor(1.7699), Description: Copy the input grid. For each cell that is not the background color, move it diagonally to the right and down, keeping its original color. Then, add a blue cell to the right of the moved cell. The background color should remain the same. 
:: def jaddajafibeeebeaabchaahhdidbfjad(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        O = paint(O, {(I[i][j], (i + j, j + i))})
        O = paint(O, recolor(1, {(i + j, j + i + 1)}))
  return O
 
26.5, tensor(1.7701), Description: Copy the input grid. For each cell that is not the background color, move it diagonally to the right and down, keeping its original color. Then, add a blue cell to the right of the moved cell if the move is within the grid boundaries. The background color should remain the same. 
:: def jejdjbcfhbageadfacjbcdbaacecbeah(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        O = paint(O, {(I[i][j], (i + j, j + i))})
        if i + 1 < len(I) and j + i + 1 < len(I[0]): 
          O = paint(O, recolor(1, {(i + j + 1, j + i + 1)}))
  return O
 
30.5, tensor(1.7027), Description: Copy the input grid. Move the object up by one space and right by one space. Draw a vertical line from one space below the top right corner of the moved object, extending two spaces down. Draw a horizontal line from one space to the right of the bottom left corner of the moved object, extending two spaces to the right. Draw a diagonal line from two spaces to the right of the bottom left corner of the moved object, extending two spaces up and left. The background color should remain the same. 
:: def fibhjaffhahfedjebebaedfifabhecfg(I):
  obj = first(objects(I, T, F, T))
  color_obj = color(obj)
  I = paint(cover(I, obj), shift(obj, (-1, 1)))
  
  # Vertical Line
  start_v = add(urcorner(obj), (1, 0))
  v_line = connect(start_v, add(start_v, (2, 0)))
  I = fill(I, ONE, v_line)
  
  # Horizontal Line
  start_h = add(llcorner(obj), (0, 1))
  h_line = connect(start_h, add(start_h, (0, 2)))
  I = fill(I, ONE, h_line)
  
  # Diagonal Line
  start_d = add(llcorner(obj), (0, 2))
  d_line = connect(start_d, add(start_d, (2, -2)))
  I = fill(I, ONE, d_line)
  return I 
 
