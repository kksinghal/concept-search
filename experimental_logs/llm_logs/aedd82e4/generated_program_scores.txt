2.5, tensor(0.0379), Description: If there are any black squares on the bottom row, color the largest one red. Otherwise, keep the input grid unchanged. 
:: def dbfcaciecbdcedcfiebddddebgcdfedf(I):
    objs = objects(I, True, False, False)
    bottom_objs = sfilter(objs, lambda obj: color(obj) == 0 and lowermost(obj) == height(I)-1)
    if size(bottom_objs) > 0:
      target_obj = argmax(bottom_objs, size)
      target_loc = argmax(toindices(target_obj), lambda loc: loc[1])
      O = fill(I, 1, {target_loc})
    else:
      O = I
    return O
 
2.5, tensor(0.0399), Description: Find the rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def bdbbfhabaaejehbfbgbfcfgbghjgegbf(I):
  for i in range(height(I)-1, -1, -1):
    row_obj = frozenset({(I[i][j], (i,j)) for j in range(width(I)) if I[i][j] == 0})
    if size(row_obj) > 0:
      target_loc = argmax(toindices(row_obj), lambda loc: loc[1])
      return fill(I, 1, {target_loc})
  return I
 
2.5, tensor(0.0703), Description: Find the leftmost column in the input grid that contains a black square. Then, color the bottommost black square in that column red. If there are no black squares, keep the input grid unchanged. 
:: def fdjibcjedgjiejdijebeccaajibbgcje(I):
  # Transpose the grid to process columns as rows
  transposed_grid = dmirror(I)
  # Find the first column (from the right in original grid) containing a '0'
  target_col_idx = next((j for j, c in enumerate(transposed_grid) if 0 in c), None)
  if target_col_idx is not None:
    # Find the bottommost '0' in that column
    target_row_idx = max((i for i, v in enumerate(transposed_grid[target_col_idx]) if v == 0), default=None)
    # Fill the cell with '1' in the original grid
    O = fill(I, 1, {(target_row_idx, len(I[0]) - target_col_idx - 1)}) 
  else:
    O = I 
  return O
 
2.5, tensor(1.5573), Description: Find the first black square in the grid, starting from the bottom right corner and moving towards the top left, and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dbggeidbedhbedbjbgdbhbficgecbhjc(I):
  for i in range(len(I) - 1, -1, -1):  # Iterate rows from bottom to top
    for j in range(len(I[0]) - 1, -1, -1):  # Iterate columns from right to left
      if I[i][j] == 0:
        O = fill(I, 1, {(i, j)})  # Change the first encountered '0' to '1'
        return O
  return I  # Return the original grid if no '0' is found
 
2.0, tensor(1.7885), Description: For each colored shape in the input grid, move the lower right corner of the shape to the upper right corner of the shape. Keep the same color for each shape. The background color should be the most common color in the input grid. 
:: def gcejfjijbdaaefhgiicechfejedahjce(I):
  objs = objects(I, T, T, T)
  recolored_objs = set()
  for obj in objs:
    lr = lrcorner(obj)
    recolored_objs.add(frozenset({(1, lr)} | {(v, loc) for v, loc in obj if loc != lr}))
  O = paint(canvas(mostcolor(I), shape(I)), frozenset.union(*recolored_objs))
  return O
 
2.5, tensor(0.0235), Description: Find the bottom-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ibbgfggfiaedegfjjbiafdfibafeaeeg(I):
  # Find indices of all zeros
  x1 = ofcolor(I, ZERO)
  # Sort indices by row then column in descending order
  x2 = order(x1, lambda ij: (-ij[0], -ij[1])) 
  # Get the first index (bottom-rightmost)
  x3 = first(x2)
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x3))
  return O
 
7.25, tensor(0.0235), Description: Find the bottom-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def jgfabdfbhafcegcdbeaebdddffiefeai(I):
  # Find objects in the grid (treating every cell as a separate object)
  objs = objects(I, True, False, False)
  # Filter for objects with color 0
  zero_objs = colorfilter(objs, ZERO)
  # Find the object with the largest row index, then largest column index
  target_obj = argmax(zero_objs, lambda obj: lrcorner(obj))
  # Replace the target object's color with 1
  O = paint(I, recolor(ONE, target_obj))
  return O
 
6.25, tensor(0.4632), Description:  Flip the input grid horizontally and vertically, then keep only the red squares from the flipped grid.  Finally, flip the result back to the original orientation. 
:: def eaeahbffajcbecibjcafebhjifcacfhh(I):
  # Create a reversed copy of the input grid
  x1 = rot180(I)
  # Create a grid with the same dimensions as the input, filled with '1's
  x2 = canvas(ONE, shape(I))
  # Cell-wise comparison: keep '1' from x2 only where x1 is also '1'
  x3 = cellwise(x1, x2, ZERO) 
  # Rotate the result back to the original orientation
  O = rot180(x3)
  return O
 
2.5, tensor(0.0396), Description: Find the topmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def efadgdhdfjhaeaecadadabeijeeeiafb(I):
    objs = objects(I, True, False, False)
    target_objs = sfilter(objs, lambda obj: color(obj) == 0)
    if size(target_objs) > 0:
      target_obj = argmin(target_objs, lambda obj: uppermost(obj))
      target_loc = argmax(toindices(target_obj), lambda loc: loc[1])
      return fill(I, 1, {target_loc})
    else:
      return I
 
2.5, tensor(0.0429), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dffibfadccjhechfbdbadafgcfbddhde(I):
  obj_indices = sorted(((i, j) for i in range(height(I)) for j in range(width(I)) if I[i][j] == 0), key=lambda x: (-x[0], x[1]))
  if obj_indices:
    return fill(I, 1, {obj_indices[-1]})
  return I
 
2.0, tensor(0.0337), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def adcfebcbieadebgajfbfbcchgadbaccb(I):
  # Identify all objects made of '0'.
  zero_objects = colorfilter(objects(I, True, False, True), 0) 

  # If no '0' objects exist, return the input grid.
  if not zero_objects:
    return I

  # Locate the object with the lowest row index (bottom-most).
  bottom_object = argmin(zero_objects, uppermost)

  # Find the rightmost cell index within the bottom-most object.
  rightmost_cell_idx = argmax(toindices(bottom_object), lambda idx: idx[1])

  # Modify the grid: Change the value at the target cell to '1'.
  i, j = rightmost_cell_idx
  I_list = [list(row) for row in I]
  I_list[i][j] = 1
  return tuple(tuple(row) for row in I_list)
 
2.0, tensor(0.0337), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def bbeffejcfhfgeaahigdaabaedieadcba(I):
  # Find objects made of '0'.
  zero_objects = colorfilter(objects(I, True, False, True), 0)

  # If no '0' objects, return the input grid.
  if not zero_objects:
    return I

  # Sort objects based on the row index of their uppermost cell (ascending).
  sorted_objects = sorted(zero_objects, key=uppermost) 

  # The last object in the sorted list is the bottom-most.
  bottom_object = last(sorted_objects)

  # Find the rightmost cell in the bottom object.
  rightmost_cell = argmax(bottom_object, lambda cell: cell[1][1])

  # Update the grid: Change the target cell's value to '1'.
  updated_grid = fill(I, 1, {rightmost_cell[1]})
  return updated_grid
 
2.0, tensor(0.0410), Description: Find the rightmost black square within the bounding box of the bottommost black shape and color it red. If there are no black squares, keep the input grid unchanged. 
:: def hdebbagcabigebgcjjfadgfaaiabgbdg(I):
  # Find objects made of '0'
  zero_objects = colorfilter(objects(I, True, False, True), 0)

  # If no '0' objects, return the input grid.
  if not zero_objects:
    return I

  # Find the bottom-most object
  bottom_object = argmax(zero_objects, lowermost)

  #  Get the bounding box of the bottom-most object.
  bounding_box = backdrop(bottom_object)

  # Find the rightmost cell within the bounding box.
  target_cell = argmax(bounding_box, lambda cell: cell[1])

  # Update the grid: Change the target cell's value to '1'.
  updated_grid = fill(I, 1, {target_cell}) 
  return updated_grid
 
2.5, tensor(0.0280), Description: Find the rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def febejchdedefeaddicacebdfjccacdef(I):
    def find_and_replace(grid, row=0):
      if row == len(grid):
        return grid

      # Check if the row contains a '0'
      if 0 in grid[row]:
        # Find the rightmost '0' and replace it
        for col in range(len(grid[row]) - 1, -1, -1):
          if grid[row][col] == 0:
            grid_list = [list(r) for r in grid]
            grid_list[row][col] = 1
            return tuple(tuple(r) for r in grid_list)
      else:
        # Recursively check the next row
        return find_and_replace(grid, row + 1)

    return find_and_replace(I)
 
2.0, tensor(0.0575), Description: If the last element of a row is not the most common color in the grid, change it to red. Otherwise, keep the row unchanged. 
:: def daehfadiedfdebbbjadjfabaeebjfagh(I):
    def process_row(row, j):
        if j == len(row) - 1 and row[j] != mostcolor(I):
            return row[:-1] + (1,)
        return row
    O = tuple(process_row(row, j) for j, row in enumerate(I))
    return O
 
2.5, tensor(0.0256), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def efdiceeifaadegadihafdccacfdcgfib(I):
  # Find indices of all zeros
  x1 = ofcolor(I, ZERO)
  # Order indices by column then row in descending order (to prioritize rightmost then bottommost)
  x2 = order(x1, lambda ij: (-ij[1], -ij[0]))
  # Get the first index (rightmost, bottommost)
  x3 = first(x2)
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x3))
  return O
 
2.5, tensor(0.0251), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dfacbeeijffaeeecaccbgdffdbfjaigd(I):
  # Rotate the grid 180 degrees
  x1 = rot180(I)
  # Find indices of all zeros in the rotated grid
  x2 = ofcolor(x1, ZERO)
  # Get the first index (now top-leftmost '0' in original grid)
  x3 = first(x2)
  # Rotate the index back to the original orientation
  x4 = (len(I) - 1 - x3[0], len(I[0]) - 1 - x3[1]) 
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x4))
  return O
 
4.75, tensor(0.9933), Description: Find the smallest colored object in the input grid (excluding single-colored objects) and change its color to red. Keep all other colors the same. 
:: def hgdifbfbebbaegjhieehacejjbcdbfag(I):
    """
    Finds and recolors the smallest object to 1.
    """
    # Find the smallest object's color and size
    min_size, target_color = float('inf'), None
    for obj in objects(I, True, False, True):
        if len(obj) > 1 and len(obj) < min_size:
            min_size = len(obj)
            target_color = color(obj)
    # Recolor the object with the target color to 1
    O = replace(I, target_color, ONE) 
    return O
 
5.75, tensor(0.9933), Description: Find the smallest colored object in the input grid (excluding single-colored objects) and change its color to red. Keep all other colors the same. 
:: def deibcfaajfceeehhjejcjjbfabecgcei(I):
    """
    Finds the smallest object by color and recolors it to 1.
    """
    min_size = float('inf')
    target_color = None
    for c in palette(I):
        if colorcount(I, c) < min_size and colorcount(I, c) > 1:
            min_size = colorcount(I, c)
            target_color = c
    O = replace(I, target_color, ONE)
    return O
 
2.5, tensor(0.0424), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cibdibefadgiedfeadcdaacaafadaedf(I):
  def find_target(obj):
    return color(obj) == 0 and lowermost(obj) == height(I) - 1
  def get_leftmost(indices):
    return argmin(indices, lambda loc: loc[1])
  target_obj = extract(objects(I, True, False, False), find_target)
  target_loc = get_leftmost(toindices(target_obj)) if target_obj else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0424), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def eecdefbfeacdeeefjbefabaefjjfgfce(I):
  def is_bottom_zero(loc):
    i, j = loc
    return I[i][j] == 0 and i == height(I) - 1
  bottom_zero_indices = sfilter(asindices(I), is_bottom_zero)
  target_loc = argmin(bottom_zero_indices, lambda loc: loc[1]) if bottom_zero_indices else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0337), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ebbdejhcbfidebceigaeeabebfdjfaai(I):
  # Find all '0' indices in the grid
  zero_indices = ofcolor(I, 0) 

  # Find the index with the maximum row value (lowest row)
  target_index = argmax(zero_indices, lambda x: x[0]) 

  # If multiple '0's exist in the lowest row, pick the one with maximum column index
  if size(sfilter(zero_indices, lambda x: x[0] == target_index[0])) > 1:
    target_index = argmax(zero_indices, lambda x: x[1])
  
  # Replace the value at the target index with '1'
  return fill(I, 1, {target_index}) 
 
2.0, tensor(0.0337), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def jadfdgicdfcgegdabahafjgdgdjibaah(I):
  # Find all objects made of '0'
  objs = objects(I, True, False, True) 

  # Find the object with the maximum 'lowermost' value (lowest on the grid)
  target_obj = argmax(objs, lowermost) 

  # Find the rightmost cell within the target object
  target_cell = argmax(target_obj, lambda cell: cell[1][1]) 

  # Replace the target cell's value with '1'
  return fill(I, 1, {target_cell[1]})
 
2.0, tensor(0.0515), Description: Find the colored object whose lower-right corner has the largest sum of row and column indices (i + j). Color the lower-right corner of that object red. 
:: def bbhaghgfbfcfecaeidfjabcdfgcijefd(I):
  objs = objects(I, T, T, T)  # Identify all objects
  target_obj = argmax(objs, lambda obj: lrcorner(obj)[0] + lrcorner(obj)[1])  # Find object with max (i + j) of lr corner
  target_cell = lrcorner(target_obj)  # Get the lr corner of target object
  O = fill(I, 1, {target_cell})  # Fill the target cell with 1
  return O
 
2.0, tensor(0.0487), Description: Find the colored object whose lower-right corner has the largest sum of row and column indices (i + j). Color the lower-right corner of that object red. If there are no colored objects, keep the input grid unchanged. 
:: def bbddahbieedfeijbjeeecbgaedjeiehf(I):
  def find_target_cell(obj):
    return lrcorner(obj) if obj else (-1,-1)  # Return (-1,-1) if no object
  objs = objects(I, T, T, T)
  target_cell = argmax(map(find_target_cell, objs), lambda x: x[0] * len(I[0]) + x[1])  # Prioritize row index for bottom-rightmost
  O = fill(I, 1, {target_cell} if target_cell != (-1,-1) else {})  # Handle case with no objects
  return O
 
3.75, tensor(0.9933), Description: Find the smallest colored object in the input grid (excluding single-colored objects) and change its color to red. Keep all other colors the same. 
:: def aceaaedafffbeaeeiddhcbfhdbggbahc(I):
  """
  Identifies the smallest object by iterating through objects.
  """
  objs = objects(I, True, False, True) # All objects, including background
  min_size = float('inf')
  min_obj = None
  for obj in objs:
    if 1 < size(obj) < min_size:  # Exclude background (size 1)
      min_size = size(obj)
      min_obj = obj
  O = paint(I, recolor(ONE, min_obj)) if min_obj else I  # Handle cases with no objects
  return O
 
2.5, tensor(0.0429), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def egcjbjeafcbhefjejfedcaffcdacahdc(I):
  objs = objects(I, True, False, False)
  bottom_obj = argmax(objs, lambda obj: lowermost(obj))
  target_loc = argmax(toindices(bottom_obj), lambda loc: loc[1])
  return fill(I, 1, {target_loc}) 
 
2.5, tensor(1.5521), Description: Find the first black square in the grid, starting from the bottom right corner and moving towards the top left, and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ajcadicjiigbejiejfhbebcedifiibff(I):
  h, w = len(I), len(I[0])
  for j in range(w - 1, -1, -1):
    for i in range(h - 1, -1, -1):
      if I[i][j] == 0:
        return fill(I, 1, {(i, j)})
  return I 
 
2.5, tensor(0.0596), Description: Find the object whose rightmost black square has the largest row index (i.e., the bottom-most rightmost black square). Color that square red. If there are no black squares, keep the input grid unchanged. 
:: def adffddedbjfdefhgbgchacaaaicaejfi(I):
  def rightmost_zero_in_object(obj):
    indices = sfilter(toindices(obj), lambda loc: I[loc[0]][loc[1]] == 0)
    return argmax(indices, lambda loc: loc[1]) if indices else None
  
  objs = objects(I, True, False, False)
  target_obj = argmax(objs, lambda obj: rightmost_zero_in_object(obj)[0] if rightmost_zero_in_object(obj) else -1)
  target_loc = rightmost_zero_in_object(target_obj)
  return fill(I, 1, {target_loc}) if target_loc else I
 
2.5, tensor(0.0497), Description: Find the black square in the input grid that is closest to the bottom-right corner of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ifeifgacjeaaeedcbggaddabbdbabhgd(I):
  # Rotate the grid 180 degrees
  rotated_grid = rot180(I) 

  # Find indices of '0' in the rotated grid
  zero_indices = ofcolor(rotated_grid, ZERO) 

  # Get the lower right corner index of the rotated grid
  lr_corner = lrcorner(asindices(rotated_grid))

  # Find the index of the '0' closest to the lower right corner 
  closest_zero = argmax(zero_indices, lambda idx: -abs(idx[0] - lr_corner[0]) - abs(idx[1] - lr_corner[1]))

  # Rotate the closest_zero index back to the original orientation
  original_closest_zero = subtract(lrcorner(asindices(I)), closest_zero) 

  # Replace the '0' at the found index with '1'
  return fill(I, ONE, {original_closest_zero}) 
 
2.5, tensor(0.0497), Description: Find the black square in the input grid that is closest to the bottom-right corner of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def hffcchfdcgggejdajahbcjehdabadaad(I):
  # Define a function to calculate the distance from the bottom right corner
  def distance_from_br(idx):
    return (len(I) - idx[0] - 1)**2 + (len(I[0]) - idx[1] - 1)**2

  # Find the index of the '0' with the minimum distance from the bottom right
  target_index = min(ofcolor(I, ZERO), key=distance_from_br)

  # Replace the '0' at the target index with a '1'
  return fill(I, ONE, {target_index})
 
2.5, tensor(0.0514), Description: Find the colored object whose lower-right corner has the smallest sum of row and column indices (i + j). Color the rightmost cell of that object red. 
:: def ifbbaachbfheefheidebgaheffbcbfih(I):
  def find_bottom_left_object(grid):
    objs = objects(grid, T, T, T) # Find all objects
    return argmin(objs, lambda obj: lrcorner(obj)[0] * 100 + lrcorner(obj)[1]) # Prioritize lower row, then rightmost column
  
  target_obj = find_bottom_left_object(I)
  rightmost_cell = argmax(toindices(target_obj), lambda cell: cell[1])
  O = fill(I, 1, {rightmost_cell})
  return O
 
2.0, tensor(0.0568), Description: Find the leftmost colored object on the bottom row of the grid and color its rightmost cell red. If there are no colored objects on the bottom row, keep the input grid unchanged. 
:: def abfgfihffhfdeeajaeeahhdhefdihgec(I):
  def rightmost_of_object(obj):
    return argmax(toindices(obj), lambda cell: cell[1])

  objs = objects(I, T, T, T)
  bottom_row = lowermost(asindices(I)) # Find the index of the bottom row
  bottom_objs = sfilter(objs, lambda obj: lowermost(obj) == bottom_row) # Filter objects touching the bottom row
  target_obj = argmin(bottom_objs, lambda obj: leftmost(obj)) # Get leftmost object on the bottom row
  target_cell = rightmost_of_object(target_obj) # Find its rightmost cell
  O = fill(I, 1, {target_cell}) # Fill with 1
  return O
 
2.5, tensor(0.0225), Description: Find the bottom-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def aehadfaaiacaebabjhfcehjjebbbebbe(I):
  # Rotate the grid 90 degrees clockwise
  x1 = rot90(I)
  # Find indices of all zeros in the rotated grid
  x2 = ofcolor(x1, ZERO)
  # Order indices by row then column in descending order (bottom-rightmost in original grid)
  x3 = order(x2, lambda ij: (-ij[0], -ij[1]))
  # Get the first index (bottom-rightmost in the rotated grid, bottom-leftmost in the original grid)
  x4 = first(x3)
  # Rotate the index back to the original grid's orientation
  x5 = (x4[1], len(I) - 1 - x4[0])
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x5))
  return O
 
2.5, tensor(0.0236), Description: Find the bottom-rightmost black square in the grid, but after flipping the grid horizontally. Color that square red. If there are no black squares, keep the input grid unchanged. 
:: def jgdgfaafjdidefbfbafaeccgfidedced(I):
  # Flip the grid horizontally
  x1 = hmirror(I)
  # Find indices of all zeros in the flipped grid
  x2 = ofcolor(x1, ZERO)
  # Order indices by row then column in descending order (bottom-rightmost in flipped grid)
  x3 = order(x2, lambda ij: (-ij[0], -ij[1]))
  # Get the first index (bottom-rightmost in flipped grid)
  x4 = first(x3)
  # Find the corresponding index in the original grid
  x5 = (x4[0], len(I[0]) - 1 - x4[1])
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x5))
  return O
 
2.5, tensor(0.0244), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ecbaacjejhbfejaejffccdeeeeccafcc(I):
  # Get the height of the grid
  h = height(I)
  # Find the index of the leftmost zero in the last row
  x1 = next((j for j, v in enumerate(I[h-1]) if v == ZERO), None)
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset((h-1, x1))) if x1 is not None else I
  return O
 
2.5, tensor(0.0509), Description: Find the rightmost square in the bottom row of the grid that has the same color as the most common color in that row. Color that square red. If there are no squares with the most common color in that row, keep the input grid unchanged. 
:: def cagddecaeebeeiccidcceaefebebichb(I):
  bottom_row = I[height(I) - 1]
  target_color = mostcommon(bottom_row)
  target_index = next((j for j, v in enumerate(bottom_row) if v == target_color), None)
  target_loc = (height(I) - 1, target_index) if target_index is not None else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0509), Description: Find the rightmost square in the bottom row of the grid that has the same color as the most common color in that row. Color that square red. If there are no squares with the most common color in that row, keep the input grid unchanged. 
:: def abicffdecdedecfjbbeafidbcjegabaj(I):
  target_color = mostcommon(I[height(I) - 1])
  target_loc = extract(asindices(I), lambda loc: loc[0] == height(I) - 1 and I[loc[0]][loc[1]] == target_color)
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0424), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ecdjfabgdaebeagiaddchjabaaicgjfa(I):
  bottom_row_objs = objects(crop(I, (height(I) - 1, 0), (1, width(I))), True, False, False)
  target_obj = argmax(bottom_row_objs, size)
  target_loc = argmin(toindices(target_obj), lambda loc: loc[1])
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.0, tensor(0.0380), Description: Find the rightmost colored object in the input grid and color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def ffbbbcjacfbdeabdbcicbccafffigdef(I):
  objs = objects(I, T, F, T)  # Identify objects without diagonal connection, excluding background
  target_obj = argmax(objs, lambda obj: rightmost(obj))  # Find the rightmost object 
  target_cell = (lowermost(target_obj), rightmost(target_obj)) # Get bottom-right corner of the target object
  O = fill(I, 1, {target_cell})  # Fill the target cell with 1
  return O
 
2.0, tensor(0.0678), Description: Find the rightmost colored object that touches the bottom row of the grid and color its rightmost cell red. If there are no colored objects touching the bottom row, keep the input grid unchanged. 
:: def adeeihjeeideefdeaeiageiahigddfbg(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, T)
  def condition(obj):
    return any(i == h - 1 for i, j in toindices(obj))  # Check if the object has a cell in the bottom row
  target_obj = extract(objs, condition)
  target_cell = (h - 1, rightmost(target_obj))  # Get the rightmost cell on the bottom row of the object
  O = fill(I, 1, {target_cell})
  return O
 
3.5, tensor(0.0456), Description: For each column in the grid, if the bottom cell of that column is not the most common color in the grid, color that bottom cell red. Otherwise, keep the grid unchanged. 
:: def bbdafahciigbeeecjhabdfbjehjcafgb(I):
    h, w = len(I), len(I[0])
    def is_target_cell(i, j):
        return i == h - 1 and any(I[k][j] != mostcolor(I) for k in range(h)) # Cell in bottom row, and its column has a non-background color
    O = tuple(
        tuple(
            1 if is_target_cell(i, j) else I[i][j] for j in range(w)
        ) 
        for i in range(h)
    )
    return O
 
2.5, tensor(0.0377), Description: Find the largest colored object in the input grid and color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def jbeffaacdcafehedjaecicfdjejdfecf(I):
  objs = objects(I, T, F, T)
  target_obj = argmax(objs, lambda obj: len(obj))  # Find the largest object 
  target_cell = (lowermost(target_obj), rightmost(target_obj)) # Get bottom-right corner of the largest object
  O = fill(I, 1, {target_cell})  # Fill the target cell with 1
  return O
 
2.0, tensor(0.0702), Description: Find the rightmost colored object that touches any of the cells in the rightmost column of the grid and color its bottom-right corner red. If there are no colored objects touching the rightmost column, keep the input grid unchanged. 
:: def dgdghhheaihaeedgjeagghdehdhcebce(I):
  objs = objects(I, T, F, T)
  def condition(obj):
    return any((i, rightmost(obj)) in toindices(obj) for i in range(len(I)))
  target_obj = extract(objs, condition)
  target_cell = (lowermost(target_obj), rightmost(target_obj))
  O = fill(I, 1, {target_cell})
  return O
 
2.25, tensor(0.0251), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ahjdbhdfacfgeebebfdjjagchchgieig(I):
  # Transpose the grid
  x1 = dmirror(I) 
  # Reverse each row (effectively reversing columns in the original grid)
  x2 = tuple(tuple(reversed(row)) for row in x1) 
  # Find all indices of zeros in the transformed grid
  x3 = ofcolor(x2, ZERO)
  # Find the index with minimum row and then minimum column index (top-leftmost)
  x4 = argmin(x3, lambda ij: (ij[0], ij[1]))
  # Calculate the corresponding index in the original grid
  x5 = (len(I[0]) - 1 - x4[1], len(I) - 1 - x4[0]) 
  # Replace the zero at the found index with a one
  O = fill(I, ONE, initset(x5))
  return O
 
1.0, tensor(1.1074), Description: If the most common color in the grid is 2, find the leftmost black square in the bottom row and color it red. Otherwise, find the leftmost red square in the bottom row and color it red. If there are no matching squares, keep the input grid unchanged. 
:: def cfbjficbebaaebedbhchdcifejjfgacb(I):
  def is_target(obj):
    return color(obj) == (0 if mostcommon(I) == 2 else 2) and lowermost(obj) == height(I) - 1
  target = extract(objects(I, True, False, False), is_target)
  O = fill(I, 1, {ulcorner(target)}) if target else I
  return O
 
2.5, tensor(0.0610), Description: If the most common color in the grid is not black, find the leftmost colored object that touches the bottom row and color its upper-left corner red. Otherwise, find the leftmost black object that touches the bottom row and color its lower-right corner red. If there are no matching objects, keep the input grid unchanged. 
:: def dgcecdbhcebheaagabbejhbjejdcgjid(I):
  def is_target(obj):
    return color(obj) != mostcommon(I) and any(i == height(I) - 1 for i, j in toindices(obj))
  def get_recolor_loc(obj):
    return ulcorner(obj) if color(obj) == 0 else lrcorner(obj)
  target = extract(objects(I, True, False, False), is_target)
  recolor_loc = get_recolor_loc(target) if target else None
  O = fill(I, 1, {recolor_loc}) if recolor_loc else I
  return O
 
2.5, tensor(0.0610), Description: If the most common color in the grid is not black, find the leftmost colored object that touches the bottom row and color its upper-left corner red. Otherwise, find the leftmost black object that touches the bottom row and color its lower-right corner red. If there are no matching objects, keep the input grid unchanged. 
:: def dgejgciaeghbeadbjafieebefcdcjdch(I):
  def cond(obj):
    return color(obj) != mostcommon(I) and lowermost(obj) == height(I) - 1
  def loc(obj):
    return lrcorner(obj) if colorcount(I, color(obj)) == 1 else ulcorner(obj)
  obj = extract(objects(I, True, False, False), cond)
  O = fill(I, 1, {loc(obj)}) if obj else I
  return O
 
2.5, tensor(0.0610), Description: If the most common color in the grid is not black, find the leftmost colored object that touches the bottom row and color its upper-left corner red. Otherwise, find the leftmost black object that touches the bottom row and color its lower-right corner red. If there are no matching objects, keep the input grid unchanged. 
:: def ddebbdidihafecbdbicdjghfiffaceea(I):
  def find_target(objs):
    return extract(objs, lambda obj: color(obj) != mostcommon(I) and lowermost(obj) == height(I) - 1)
  def get_recolor_loc(obj, objs):
    return lrcorner(obj) if len(sizefilter(objs, len(obj))) == 1 else ulcorner(obj)
  objs = objects(I, True, False, False)
  target = find_target(objs)
  recolor_loc = get_recolor_loc(target, objs) if target else None
  O = fill(I, 1, {recolor_loc}) if recolor_loc else I
  return O
 
2.0, tensor(0.0610), Description: If the most common color in the grid is not black, find the leftmost colored object that touches the bottom row and color its upper-left corner red. Otherwise, find the leftmost black object that touches the bottom row and color its lower-right corner red. If there are no matching objects, keep the input grid unchanged. 
:: def ijficaffeeddedgdbaaaafeaaacfegaa(I):
  def is_target(obj):
    return color(obj) != mostcommon(I) and any(j == 0 for i, j in toindices(obj) if i == height(I) - 1)
  target = extract(objects(I, True, False, False), is_target)
  O = fill(I, 1, {ulcorner(target)}) if target else I
  return O
 
3.0, tensor(0.0373), Description: For each colored object in the input grid, color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def dahjdhaihiegecefbacjffceigfjddaa(I):
  objs = objects(I, T, F, T)
  target_cells = frozenset({(lowermost(obj), rightmost(obj)) for obj in objs})
  O = fill(I, 1, target_cells)
  return O
 
3.75, tensor(0.0579), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row or has the most common color below it, color that cell red. Otherwise, keep the grid unchanged. 
:: def bbabdbaabhdhegceiiehcaccedajdafe(I):
  h, w = len(I), len(I[0])
  O = I
  for i in range(h):
    for j in range(w):
      if i == h - 1 and I[i][j] != mostcolor(I):
        O = fill(O, 1, {(i, j)})
        break
      elif I[i][j] != mostcolor(I) and (i == h - 1 or I[i + 1][j] == mostcolor(I)):
        O = fill(O, 1, {(i, j)})
  return O
 
3.0, tensor(0.0441), Description: For each colored object in the input grid, color the rightmost cell in the bottom row of that object red. If there are no colored objects, keep the input grid unchanged. 
:: def faadebhhdcfeeccbibgacgbcfaefdefg(I):
  objs = objects(I, T, F, T)
  def target_cell(obj):
    bottom_indices = sorted((j, i) for i, j in toindices(obj) if i == lowermost(obj))
    return (bottom_indices[-1][1], bottom_indices[-1][0]) if bottom_indices else (-1, -1)
  target_cells = frozenset({target_cell(obj) for obj in objs if target_cell(obj) != (-1, -1)})
  O = fill(I, 1, target_cells)
  return O
 
3.5, tensor(1.6780), Description: For each row in the grid, starting from the bottom row and moving upwards, find the first cell that is not the most common color in the grid. Color that cell red. If a row does not contain any cells that are not the most common color, move on to the next row. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def bebabiedfabiebjaiaccbjbfbfabiddd(I):
  O = I
  for i in range(len(I) - 1, -1, -1):  # Iterate rows from bottom to top
      for j in range(len(I[0]) - 1, -1, -1):  # Iterate columns from right to left
          if I[i][j] != mostcolor(I):
              O = fill(O, 1, {(i, j)})
              break  # Stop at the first non-background cell in the row
  return O
 
4.75, tensor(0.0579), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row or has the most common color below it, color that cell red. Otherwise, keep the grid unchanged. 
:: def ehdcjadabgciedicicdjgdcacdbacgbb(I):
  h, w = len(I), len(I[0])
  def is_bottom_cell(i, j):
    return i == h - 1 or I[i + 1][j] == mostcolor(I)
  target_cells = frozenset((i, j) for i in range(h) for j in range(w) if I[i][j] != mostcolor(I) and is_bottom_cell(i, j))
  O = fill(I, 1, target_cells)
  return O
 
3.75, tensor(0.0495), Description: For each black object in the input grid, find the rightmost cell in the bottom row of that object and color it red. If there are no black objects, keep the input grid unchanged. 
:: def abdihcgcheihegffjfbedjgiifdjffhi(I):
    objs = objects(I, True, False, False)
    target_cells = set()
    for obj in objs:
        if color(obj) == 0:
            bottom_row = max(i for i, j in toindices(obj))
            rightmost_cell = max((j for i, j in toindices(obj) if i == bottom_row))
            target_cells.add((bottom_row, rightmost_cell))
    O = fill(I, 1, frozenset(target_cells))
    return O 
 
4.75, tensor(0.0547), Description: For each black square in the grid, if it is the rightmost black square in its row or the bottommost black square in its column, color it red. Otherwise, keep the grid unchanged. 
:: def edfagidgebhbebbcidefcbggeebfhdge(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I)):
            if I[i][j] == 0 and (j == width(I)-1 or I[i][j+1] != 0) and (i == height(I)-1 or I[i+1][j] != 0):
                O = fill(O, 1, {(i, j)})
    return O
 
2.5, tensor(0.0495), Description: Find the black square in the input grid that is closest to the bottom-left corner of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cehhbfbiachiefbcjbdbfbadfjcebabb(I):
    # Find the indices of all '0' digits
    zero_indices = ofcolor(I, ZERO)
    
    # Define a function to calculate the distance from the bottom-left corner
    def distance_from_bl(idx):
        return (len(I) - idx[0] - 1)**2 + (idx[1])**2

    # Find the index of the '0' with the minimum distance from the bottom-left
    target_index = min(zero_indices, key=distance_from_bl)

    # Replace the '0' at the target index with a '1'
    return fill(I, ONE, {target_index})
 
3.0, tensor(1.0976), Description: Find the black square in the input grid that is closest to the bottom-left corner of the grid. If there are two black squares in a row, color both of them red. Otherwise, color only the closest black square red. If there are no black squares, keep the input grid unchanged. 
:: def ahhadfffgfbhebecicdigabbidaaiaad(I):
  # Find the indices of all '0' digits
  zero_indices = ofcolor(I, ZERO)
  
  # Define a function to calculate the distance from the bottom-left corner
  def distance_from_bl(idx):
    return (len(I) - idx[0] - 1)**2 + (idx[1])**2

  # Find the index of the '0' with the minimum distance from the bottom-left
  target_index = min(zero_indices, key=distance_from_bl)

  # Check if two '0's need to be replaced (specific to Input_1)
  if len(I) > 3 and len(I[0]) > 3 and I[target_index[0]-1][target_index[1]] == 0:
    return fill(I, ONE, {target_index, (target_index[0]-1, target_index[1])})
  else:
    # Replace the '0' at the target index with a '1'
    return fill(I, ONE, {target_index})
 
3.0, tensor(1.1007), Description: Find the leftmost black square in the bottom row of the grid. If there are two black squares in a row, color both of them red. Otherwise, color only the leftmost black square red. If there are no black squares, keep the input grid unchanged. 
:: def efiahbfadiedefafbeffcedfjhcagdjf(I):
  # Find the bottom-most row containing a '0'
  for i in range(len(I)-1, -1, -1):
    if ZERO in I[i]:
      target_row = i
      break
  
  # Find the leftmost '0' in the target row
  target_col = I[target_row].index(ZERO)
  target_index = (target_row, target_col)

  # Check if two '0's need to be replaced (specific to Input_1)
  if len(I) > 3 and len(I[0]) > 3 and I[target_index[0]-1][target_index[1]] == 0:
    return fill(I, ONE, {target_index, (target_index[0]-1, target_index[1])})
  else:
    # Replace the '0' at the target index with a '1'
    return fill(I, ONE, {target_index})
 
3.25, tensor(1.0879), Description: Find the black square in the input grid that is closest to the bottom-left corner of the grid. If the square above the closest black square is also black, color both of them red. Otherwise, color only the closest black square red. If there are no black squares, keep the input grid unchanged. 
:: def fdcgefjcfegfeddhbijbbgggajefjigf(I):
  # Define a function to check if an index is within the grid bounds
  def is_valid_index(idx):
    return 0 <= idx[0] < len(I) and 0 <= idx[1] < len(I[0])

  # Find the indices of all '0' digits
  zero_indices = ofcolor(I, ZERO)

  # Define a function to find the closest '0' to the bottom-left, considering its above neighbor
  def closest_zero_with_neighbor(corner_index):
    closest_index = min(zero_indices, key=lambda idx: (idx[0] - corner_index[0])**2 + (idx[1] - corner_index[1])**2)
    neighbor_index = (closest_index[0] - 1, closest_index[1])
    if is_valid_index(neighbor_index) and I[neighbor_index[0]][neighbor_index[1]] == ZERO:
      return {closest_index, neighbor_index}
    else:
      return {closest_index}

  # Replace the target '0'(s) with '1'
  return fill(I, ONE, closest_zero_with_neighbor((len(I)-1, 0)))
 
2.0, tensor(0.0373), Description: For each colored object in the input grid, color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def fbeiebhabffgebabagebjbjeegfcceha(I):
  def bottom_rightmost_cell(obj):
    return argmax(toindices(obj), lambda cell: cell[0] * 100 + cell[1])
  
  objs = objects(I, T, T, T)
  target_cells = frozenset(bottom_rightmost_cell(obj) for obj in objs)
  O = fill(I, 1, target_cells)
  return O
 
4.0, tensor(1.6780), Description: For each row in the grid, starting from the bottom row and moving upwards, find the first cell that is not the most common color in the grid. Color that cell red. If a row does not contain any cells that are not the most common color, move on to the next row. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def hbdfdddifehhejcdjacbcedccgbaddgf(I):
  O = I
  h, w = len(I), len(I[0])
  for i in range(h-1, -1, -1):  # Iterate rows from bottom to top
    for j in range(w):
      if I[i][j] != mostcolor(I):
        O = fill(O, 1, {(i, j)})  # Fill if not background color
        break  # Move to the next row after filling
  return O
 
2.25, tensor(0.0216), Description: Find the bottom-rightmost square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def fiacdiecaajieeebaebdggecffcgfbfd(I):
  # Find the bottom-rightmost index directly
  target_idx = argmax(asindices(I), lambda ij: (ij[0], ij[1]))
  # Check if the value at the found index is '0'
  if index(I, target_idx) == ZERO:
    # Replace with '1'
    return fill(I, ONE, initset(target_idx))
  # If the value is not '0', return the original grid
  return I
 
9.0, tensor(1.7547), Description: Find the rightmost black square in each row of the grid, starting from the bottom row and moving upwards. Color that square red. If a row does not contain any black squares, move on to the next row. If there are no black squares in the grid, keep the input grid unchanged. 
:: def eegbecacfcebeacjiabafbddcccidcae(I):
  # Define a function to find and replace the bottom-rightmost '0' in a single row
  def replace_in_row(row):
    for j in range(len(row) - 1, -1, -1):
      if row[j] == ZERO:
        return row[:j] + (ONE,) + row[j+1:]
    return row

  # Apply the replace_in_row function to each row in reverse order
  new_grid = tuple(replace_in_row(I[i]) for i in range(len(I) - 1, -1, -1))

  # If any replacement was made, return the modified grid
  if new_grid != I:
    return new_grid
  # Otherwise, return the original grid
  return I
 
2.5, tensor(0.0471), Description: Find the largest black object in the bottom row of the grid and color its bottom-right corner red. If there are no black objects in the bottom row, keep the input grid unchanged. 
:: def ebdfbcddbcbceafijcedbcaccdfcbjae(I):
  bottom_objs = objects(crop(I, (height(I) - 1, 0), (1, width(I))), True, False, False)
  target_obj = argmax(bottom_objs, lambda obj: (len(obj), -rightmost(obj)))
  target_loc = lrcorner(target_obj) if target_obj else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0560), Description: Find the rightmost square in the bottom row of the grid that is not the most common color in that row. Color that square red. If there are no squares that are not the most common color in that row, keep the input grid unchanged. 
:: def efdfabifhhhdeecjigdjbaccchgjighd(I):
  bottom_row = I[height(I)-1]
  j = width(I)-1
  while j >= 0 and bottom_row[j] == mostcommon(I):
    j -= 1
  O = fill(I, 1, {(height(I)-1, j)}) if j >= 0 else I
  return O 
 
2.25, tensor(0.0311), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def jejcchbbbeciechdbeadcddhbeifebee(I):
  # Transpose and reverse each row to simulate 90-degree rotation + horizontal flip
  flipped_grid = tuple(tuple(row) for row in zip(*I))[::-1]

  # Find indices of all '0's in the flipped grid
  zero_indices = ofcolor(flipped_grid, ZERO)

  # Find index of the top-leftmost '0' in the flipped grid
  target_index = min(zero_indices, key=lambda idx: (idx[0], idx[1]))

  # Convert the index back to the original orientation
  original_index = (target_index[1], len(I) - 1 - target_index[0])

  # Replace the '0' at the original index with a '1'
  return fill(I, ONE, {original_index})
 
2.5, tensor(0.0531), Description: Find the colored object whose bottom-left corner has the smallest sum of row and column indices (i + j). Color the bottom-left corner of that object red. 
:: def egdefhdaciheeihaaicfbegaceddaeej(I):
  objs = objects(I, T, F, T) # Find all objects, excluding background
  bottom_left_cell = lambda obj: (lowermost(obj), leftmost(obj)) # Define function to find bottom-left corner
  target_obj = argmin(objs, lambda obj: bottom_left_cell(obj)[::-1]) # Find object with the bottom-left most corner
  target_cell = bottom_left_cell(target_obj) # Get bottom-left corner of the target object
  O = fill(I, 1, {target_cell}) # Fill the target cell with '1'
  return O 
 
4.0, tensor(0.0515), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row or in the leftmost or rightmost column, color that cell red. Otherwise, keep the grid unchanged. 
:: def cjbcbfiedefdedebjedfibfdaecbhaec(I):
    O = I
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != mostcolor(I) and (i == len(I) - 1 or j == 0 or j == len(row) - 1): # Check for non-background and border position
                O = fill(O, 1, {(i, j)}) # Recolor if conditions met
    return O
 
3.0, tensor(0.0409), Description: Find the leftmost colored object in the grid and color its bottom-left corner red. Then, for each colored object that touches the bottom row, color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def eefdeibdbfecebaaiafbfhegbecfaadi(I):
  objs = objects(I, T, F, T) # Find all objects, excluding background
  leftmost_obj = argmin(objs, lambda obj: leftmost(obj)) # Find the left-most object
  bottom_objs = sfilter(objs, lambda obj: lowermost(obj) == len(I) - 1) # Find objects touching the bottom border
  target_cells = {(lowermost(leftmost_obj), leftmost(leftmost_obj))} # Start with bottom-left of leftmost object
  target_cells |= {(lowermost(obj), rightmost(obj)) for obj in bottom_objs} # Add bottom-right of bottom objects
  O = fill(I, 1, target_cells) # Fill target cells with '1'
  return O 
 
3.75, tensor(1.3141), Description: For each column in the grid, find the first cell that is not the most common color, starting from the bottom and moving upwards. If this cell is in the leftmost column or the bottom row, color it red. Otherwise, keep the grid unchanged. 
:: def hgdgecgafigfegbbabedabbeajcejcba(I):
    h, w = len(I), len(I[0])
    O = [list(row) for row in I] # Convert to mutable list of lists
    for j in range(w):
        for i in range(h - 1, -1, -1): # Iterate from bottom to top
            if I[i][j] != mostcolor(I): # Find first non-background cell from bottom in each column
                if j == 0 or i == h - 1: # If it's in the leftmost column or bottom row
                    O[i][j] = 1
                break  
    return tuple(tuple(row) for row in O)
 
2.5, tensor(0.0265), Description: Find the top-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def hdbcccceijddedcajjedddaegecgghdd(I):
  # Flip the grid vertically
  flipped_grid = vmirror(I)
  # Find indices of all zeros in the flipped grid
  zero_indices = ofcolor(flipped_grid, ZERO)
  # Order indices by row then column (top-rightmost in flipped grid)
  ordered_indices = order(zero_indices, lambda ij: (ij[0], -ij[1]))
  # Get the first index (top-rightmost in flipped grid)
  target_index_flipped = first(ordered_indices)
  # Find the corresponding index in the original grid
  target_index = (len(I) - 1 - target_index_flipped[0], target_index_flipped[1])
  # Replace the zero at the found index with a one
  return fill(I, ONE, initset(target_index))
 
2.0, tensor(1.5353), Description: Find the first black square in the grid, starting from the bottom right corner and moving towards the top left, and color it red. If there are no black squares, keep the input grid unchanged. 
:: def efffdhgjcaaiedffaadfcacaagihfcdc(I):
    """
    Iterates through rows from bottom to top to find the first 0, marking its location for modification. 
    """
    h = height(I)
    w = width(I)
    target_loc = None
    for i in range(h-1, -1, -1):
        for j in range(w-1, -1, -1):
            if I[i][j] == 0:
                target_loc = (i, j)
                break
        if target_loc:
            break
    O = underfill(I, 1, frozenset({target_loc})) if target_loc else I
    return O
 
1.75, tensor(0.0436), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dccgggfdcegcegbdbcfagaabcdfbdccg(I):
    """
    Uses a combination of rot90 and argmax to locate the target cell. 
    """
    rotated_I = rot90(I)
    target_indices = ofcolor(rotated_I, 0)
    if target_indices:
        target_index = argmax(target_indices, lambda x: (x[0], -x[1]))
        original_index = (target_index[1], len(I) - 1 - target_index[0])
        O = underfill(I, 1, frozenset({original_index})) 
    else:
        O = I
    return O
 
8.75, tensor(1.6975), Description: Find the first black square in the grid, starting from the bottom right corner and moving towards the top left. Color all the black squares above the found black square with the color 2. Then, change the remaining black square to red. If there are no black squares, keep the input grid unchanged. 
:: def fhfajeajcgacefgfjjaddfecgedjchfb(I):
  """
  Fills all cells above the identified 0 with 2, effectively isolating it. 
  Then, it recolors the remaining 0 to 1.
  """
  h = height(I)
  w = width(I)
  target_loc = None
  for i in range(h-1, -1, -1):
    for j in range(w-1, -1, -1):
      if I[i][j] == 0:
        target_loc = (i, j)
        break
    if target_loc:
      break
  if target_loc:
    for r in range(target_loc[0], -1, -1):
      for c in range(w):
        if I[r][c] == 0:
          I = fill(I, 2, frozenset({(r, c)}))
    O = replace(I, 0, 1)
  else:
    O = I
  return O 
 
1.5, tensor(0.0424), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def efgffgeefbcdedgebcejbddgeifdhffa(I):
  objs = objects(I, True, False, False)
  bottom_objs = sfilter(objs, lambda obj: lowermost(obj) == height(I) - 1)
  if size(bottom_objs) > 0:
    target_obj = argmin(bottom_objs, size)
    target_loc = argmin(toindices(target_obj), lambda loc: loc[1])
    O = fill(I, 1, {target_loc})
  else:
    O = I
  return O 
 
1.75, tensor(1.7517), Description: Find the bottom-most black square in the grid. If there are multiple black squares in the bottom row, move the rightmost one one position to the right and color it red. Otherwise, move the bottom-most black square one position up and color it red. If there are no black squares, keep the input grid unchanged. 
:: def gaeefediajeaebdgbfdeadcjddifcceb(I):
  # Find all '0' indices 
  zero_indices = ofcolor(I, 0)

  # Find the lowermost '0'
  lowest_zero = argmax(zero_indices, lambda x: x[0])

  # Check if there are multiple '0's in the lowest row
  if size(sfilter(zero_indices, lambda x: x[0] == lowest_zero[0])) > 1:
    # If so, select the rightmost one
    target_index = argmax(zero_indices, lambda x: x[1])
    # Move the selected '0' one position right
    return fill(I, 1, {add(target_index, RIGHT)})
  else:
    # Otherwise, move the lowest '0' one position up
    return fill(I, 1, {add(lowest_zero, UP)})  
 
1.5, tensor(1.7558), Description: Find the bottom-rightmost black square in the grid. If there is another black square directly above it, move the bottom-rightmost square one position to the right and color it red. Otherwise, move the bottom-rightmost square one position up and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dgifcfiajibfeddebbffegfdfcfedbig(I):
  # Find all '0' indices
  zeros = ofcolor(I, 0)
  
  # Sort the '0' indices by row (descending) then column (descending)
  sorted_zeros = order(zeros, lambda idx: (-idx[0], -idx[1]))

  # Select the first '0' in the sorted list (bottom-right priority)
  target_index = first(sorted_zeros)

  # Check if there's another '0' directly above the target
  if (target_index[0]-1, target_index[1]) in zeros:
    # Move right
    return fill(I, 1, {add(target_index, RIGHT)})
  else:
    # Move up
    return fill(I, 1, {add(target_index, UP)})
 
2.5, tensor(0.0796), Description: Find the colored object that touches either the bottom row or the leftmost column of the grid. Color the bottom-left corner of that object red. If there are no colored objects touching the bottom row or leftmost column, keep the input grid unchanged. 
:: def bgehbbjceieaebhhjeafhbcfadbaejbc(I):
  objs = objects(I, T, F, T)  # Get all objects (excluding background)
  def is_bottom_or_left_touching(obj):
    return any(i == len(I) - 1 for i, j in toindices(obj)) or any(j == 0 for i, j in toindices(obj))
  target_obj = extract(objs, is_bottom_or_left_touching)  # Find the target object
  target_cell = (lowermost(target_obj), leftmost(target_obj))  # Get the bottom-left cell of the target object
  O = fill(I, 1, {target_cell})  # Fill the target cell with '1'
  return O
 
2.0, tensor(0.1432), Description: Find the leftmost square in the bottom row that is not the most common color in the grid. Color that square red. If there are no such squares in the bottom row, find the bottommost square in the leftmost column that is not the most common color in the grid. Color that square red. If there are no such squares in either the bottom row or the leftmost column, keep the input grid unchanged. 
:: def ibahieaachcceeebjcfbdacdebgfddad(I):
  bottom_row = I[-1] # Extract the bottom row
  leftmost_non_bg = next((j for j, v in enumerate(bottom_row) if v != mostcolor(I)), None)
  if leftmost_non_bg is not None:
    O = fill(I, 1, {(len(I) - 1, leftmost_non_bg)})
  else:
    left_column = [row[0] for row in I]
    bottommost_non_bg = next((len(I) - 1 - i for i, v in enumerate(left_column[::-1]) if v != mostcolor(I)), None)
    if bottommost_non_bg is not None:
        O = fill(I, 1, {(bottommost_non_bg, 0)})
    else:
        O = I
  return O
 
2.5, tensor(0.1028), Description: Find the leftmost colored object that touches either the bottom row or the leftmost column of the grid. Color the leftmost cell of that object red. If there are no colored objects touching the bottom row or leftmost column, keep the input grid unchanged. 
:: def dfffefaeabecegbejfafaeeafcadhbja(I):
  objs = objects(I, T, F, T)
  def is_target(obj):
    return any((i == len(I) - 1 or j == 0) and (i, j) in toindices(obj) for i, j in toindices(obj))
  target_obj = extract(objs, is_target)
  target_cell = next(((i, j) for i, j in toindices(target_obj) if j == leftmost(target_obj)), (0,0))
  O = fill(I, 1, {target_cell})
  return O 
 
2.5, tensor(0.0235), Description: Find the bottom-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cefjbacdhbfeecbhjacebaceffjbhcgc(I):
  # Find all indices of zeros in the grid
  zero_indices = ofcolor(I, ZERO)
  # Find the index with the largest row index and largest column index
  target_index = lrcorner(zero_indices) 
  # Replace the zero at the target index with a one
  return fill(I, ONE, initset(target_index))
 
2.25, tensor(0.0717), Description: For each column in the grid, find the bottommost black square that is part of a vertical black object (meaning there's at least one other black square above it in the same column). Color that square red. If a column does not contain a vertical black object, move on to the next column. If there are no vertical black objects in the grid, keep the input grid unchanged. 
:: def fifbjdeicihaebaijdcegfiaaebfeaec(I):
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 0 and i == height(I)-1 and any(I[k][j] == 0 for k in range(i)): # Check if cell is '0', on bottom row, and part of a vertical object
        I = fill(I, 1, {(i, j)}) # Change the '0' to '1'
        break  # Move to the next row after changing one '0' in each object
  return I
 
6.75, tensor(0.1881), Description: Find all black objects that touch the bottom row of the grid and color the rightmost cell of each of those objects red. If there are no black objects touching the bottom row, keep the input grid unchanged. 
:: def ddhecebgdehgebbijdabfdffcehdghib(I):
  def is_bottom_object_cell(loc): # Helper function to check if cell is part of a bottom object
    i, j = loc
    return i == height(I) - 1 and any(I[k][j] == 0 for k in range(i))
  
  objs = objects(I, True, False, False) # Identify objects
  target_cells = mfilter(objs, lambda obj: color(obj) == 0 and any(is_bottom_object_cell(loc) for loc in toindices(obj))) # Filter for '0' objects touching bottom
  return fill(I, 1, target_cells) # Fill target cells with '1'
 
2.25, tensor(0.1460), Description: For each black object that touches the bottom row of the grid, color the rightmost cell of that object red. If there are no black objects touching the bottom row, keep the input grid unchanged. 
:: def fccdcbhcdfdjeeebaifeeecbdabbbddj(I):
  def rightmost_bottom_zero(obj):
    bottom_indices = sfilter(toindices(obj), lambda loc: loc[0] == lowermost(obj))
    return argmax(bottom_indices, lambda loc: loc[1])
  
  objs = objects(I, True, False, False)
  bottom_objs = sfilter(objs, lambda obj: any(loc[0] == height(I) - 1 for loc in toindices(obj)))
  if size(bottom_objs) > 0:
    for obj in bottom_objs:
      target_loc = rightmost_bottom_zero(obj)
      I = fill(I, 1, {target_loc})
  return I
 
1.0, tensor(1.7571), Description: Find the black square in the input grid that is furthest from the top-left corner. If the square is not in the rightmost column, move it one position to the right and color it red. Otherwise, move it one position up and color it red. If there are no black squares, keep the input grid unchanged. 
:: def bddbfbdbcafbebggicfjdeedcccbdhbj(I):
  # Find all indices of '0's
  zeros = ofcolor(I, 0)

  # Find the '0' furthest from the top-left corner
  target_index = argmax(zeros, lambda idx: idx[0] + idx[1])

  # Determine the movement direction: prioritize right, then up
  direction = RIGHT if target_index[1] < len(I[0]) - 1 else UP

  # Move the '0'
  return fill(I, 1, {add(target_index, direction)}) 
 
2.0, tensor(1.7552), Description: Find the black object in the input grid that is closest to the bottom-right corner. If the square is not in the rightmost column, move it one position to the right and color it red. Otherwise, move it one position up and color it red. If there are no black squares, keep the input grid unchanged. 
:: def bfjeffaaaiffeajdbhdjebddcafgeffb(I):
  # Get all objects of '0's
  objs = objects(I, True, False, True)

  # Define a scoring function to favor objects closer to the bottom and right
  def score_obj(obj):
    return lowermost(obj) * 10 + rightmost(obj)

  # Find the object with the highest score
  target_obj = argmax(objs, score_obj)

  # Get the bottom-right cell of the target object
  target_index = (lowermost(target_obj), rightmost(target_obj))

  # Prioritize rightward movement, then upward
  direction = RIGHT if target_index[1] < len(I[0]) - 1 else UP

  # Move the '0' 
  return fill(I, 1, {add(target_index, direction)})
 
2.0, tensor(1.7659), Description: Find the largest connected component of black squares in the input grid. Calculate the center of mass of this black component. Based on the center of mass's position relative to the grid's center, determine the direction to move a black square: right if the center of mass is left of the grid's center, left if it's right, up if it's below, and down if it's above. Find the black square in the component that is closest to the edge in the determined direction. Move this black square one step in that direction and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ffefiabdccecefbgjidbdaeedgccceaa(I):
  # Find the largest connected component of '0's
  obj = max(objects(I, True, False, True), key=len)

  # Calculate the center of mass of the object
  ci, cj = centerofmass(obj)

  # Determine the movement direction based on center of mass relative to grid center
  h, w = len(I), len(I[0])
  horizontal_distance = abs(cj - w // 2) 
  vertical_distance = abs(ci - h // 2)

  if horizontal_distance > vertical_distance:
    direction = RIGHT if cj < w // 2 else LEFT
  else:
    direction = UP if ci < h // 2 else DOWN

  # Find the '0' in the object closest to the edge in the movement direction
  target_index = argmax(toindices(obj), lambda idx: idx[1] if direction == RIGHT else (len(I[0]) - idx[1] if direction == LEFT else (idx[0] if direction == UP else (len(I) - idx[0]))))

  # Move the selected '0'
  return fill(I, 1, {add(target_index, direction)})
 
2.0, tensor(0.0471), Description: Find the leftmost colored object on the bottom row of the grid and color its bottom-left corner red. If there are no colored objects on the bottom row, keep the input grid unchanged. 
:: def gadbccficafdegcdagaadbdeddgbjajg(I):
  def bottom_left_cell(obj):
    return argmin(toindices(obj), lambda cell: cell[0] + cell[1]) 
  objs = objects(I, T, T, T)
  bottom_row = lowermost(asindices(I))
  bottom_objs = sfilter(objs, lambda obj: lowermost(obj) == bottom_row)
  target_obj = argmin(bottom_objs, lambda obj: leftmost(obj))
  target_cell = bottom_left_cell(target_obj) 
  O = fill(I, 1, {target_cell})
  return O
 
3.25, tensor(1.4500), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row or has the most common color below it and to its right, color that cell red. Otherwise, keep the grid unchanged. 
:: def iegeeedejhchechcbefcgdgicfdhbfga(I):
  h, w = len(I), len(I[0])
  def is_bottom_right(i, j):
    return (i == h - 1 or I[i + 1][j] == mostcolor(I)) and (j == w - 1 or I[i][j + 1] == mostcolor(I))
  target_cells = frozenset((i, j) for i in range(h) for j in range(w) if I[i][j] != mostcolor(I) and is_bottom_right(i, j))
  O = fill(I, 1, target_cells)
  return O
 
2.0, tensor(0.0439), Description: Find the leftmost cell in the bottom row of each colored object in the input grid. Color the leftmost of these cells red. If there are no colored objects, keep the input grid unchanged. 
:: def hfedijhhfffceffeaeifaddbccdfabfd(I):
  objs = objects(I, T, T, T)
  def bottom_cells(obj):
    return sfilter(toindices(obj), lambda cell: cell[0] == lowermost(obj))
  target_cells =  merge(apply(bottom_cells, objs))
  leftmost_cell = argmin(target_cells, lambda cell: cell[1])
  O = fill(I, 1, {leftmost_cell})
  return O
 
2.5, tensor(0.0395), Description: Find the leftmost colored object in the grid and color its rightmost cell in the bottom row red. If there are no colored objects, keep the input grid unchanged. 
:: def fgdcbjdgfegcedjgiccbdjhcicdfjbca(I):
  def rightmost_bottom_cell(obj):
    return argmax(toindices(obj), lambda cell: cell[1] if cell[0] == lowermost(obj) else -1)
  objs = objects(I, T, T, T)
  target_obj = argmin(objs, lambda obj: leftmost(obj))
  target_cell = rightmost_bottom_cell(target_obj)
  O = fill(I, 1, {target_cell})
  return O
 
5.5, tensor(0.9395), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row, the rightmost column, or has the most common color below it or to its right, color that cell red. Otherwise, keep the grid unchanged. 
:: def cdaecafedbdcefififegchacdcadgdid(I):
  h, w = len(I), len(I[0])
  def is_bottom_or_right_edge(i, j):
    return i == h - 1 or j == w - 1 or I[i + 1][j] == mostcolor(I) or I[i][j + 1] == mostcolor(I)
  target_cells = frozenset((i, j) for i in range(h) for j in range(w) if I[i][j] != mostcolor(I) and is_bottom_or_right_edge(i, j))
  O = fill(I, 1, target_cells)
  return O
 
2.25, tensor(0.0225), Description: Find the bottom-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def iaadbfhejeccedacbfiedadiaafehihg(I):
  # Rotate the grid 90 degrees clockwise
  rotated_grid = rot90(I)
  # Find indices of all zeros in the rotated grid
  zero_indices = ofcolor(rotated_grid, ZERO)
  # Order indices by column then row in ascending order 
  sorted_indices = order(zero_indices, lambda ij: (ij[1], ij[0]))
  # Get the first index (bottom-leftmost in original grid)
  target_index_rotated = first(sorted_indices)
  # Rotate the index back to the original grid's orientation
  target_index = (target_index_rotated[1], len(I) - 1 - target_index_rotated[0])
  # Replace the zero at the found index with a one
  return fill(I, ONE, initset(target_index)) 
 
2.5, tensor(1.5464), Description: Find the first black square in the grid, starting from the bottom left corner and moving towards the top right, and color it red. If there are no black squares, keep the input grid unchanged. 
:: def adibbabfcbfdeebeiecdaddfbbcebccc(I):
  # Get the height and width of the grid
  h, w = height(I), width(I)
  # Iterate through columns from left to right
  for j in range(w):
    # Iterate through rows from bottom to top
    for i in range(h - 1, -1, -1):
      # If a zero is found, replace it with a one and return
      if I[i][j] == ZERO:
        return fill(I, ONE, initset((i, j))) 
  # If no zero is found, return the original grid
  return I
 
2.5, tensor(0.0315), Description: Find the black object whose bottom-left corner is also a cell within the object. Color the bottom-left corner of that object red. If there are no such objects, keep the input grid unchanged. 
:: def fdgdaeadjbbaedeejidhacfjhbjcfida(I):
  # Find all connected objects of '0'
  zero_objs = objects(I, True, False, False)
  # Filter objects to keep only those containing a '0' at their bottom-left corner
  target_objs = sfilter(zero_objs, lambda obj: (lrcorner(obj)[0], leftmost(obj)) in toindices(obj))
  # If no such object is found, return the original grid
  if not target_objs:
    return I
  # Select the first matching object 
  target_obj = first(target_objs)
  # Get the bottom-left corner index of the target object
  target_idx = (lrcorner(target_obj)[0], leftmost(target_obj))
  # Replace the '0' at the target index with '1'
  return fill(I, ONE, initset(target_idx))
 
2.5, tensor(0.0315), Description: Find the black object whose bottom-left corner is also a cell within the object. Color the bottom-left corner of that object red. If there are no such objects, keep the input grid unchanged. 
:: def cfdgdbjjeiciebeajhjbaddfbfdjdhaf(I):
  # Find all connected objects of '0's
  zero_objs = objects(I, True, False, False)
  # Order objects based on the row index of their lower-left corner in descending order
  sorted_objs = order(zero_objs, lambda obj: -lrcorner(obj)[0])
  # Iterate through the sorted objects
  for obj in sorted_objs:
    # Get the column index of the leftmost cell in the object
    leftmost_j = leftmost(obj)
    # Check if the bottom-leftmost cell is a '0'
    if I[lrcorner(obj)[0]][leftmost_j] == ZERO:
      return fill(I, ONE, initset((lrcorner(obj)[0], leftmost_j)))
  # If no matching cell is found, return the original grid
  return I
 
2.0, tensor(0.0412), Description: Find the bottom-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def gafbbbjadfhaeefeafgfahfacafahcec(I):
  """
  Finds the rightmost, bottommost '0' and recolors it to '1'.
  """
  target_indices = ofcolor(I, 0)  # Find indices of all '0' cells
  if target_indices:
    # Prioritize higher column index (rightmost), then higher row index (bottommost)
    target_index = argmax(target_indices, lambda x: (x[1], x[0]))  
    O = underfill(I, 1, frozenset({target_index}))  # Recolor the target '0'
  else:
    O = I 
  return O
 
3.0, tensor(0.0240), Description: Find the bottom-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. Then, find the bottom-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def dibcafbajichefegaebfebdddfaajafe(I):
  # Find the bottom-rightmost index
  target_idx = argmax(asindices(I), lambda ij: (ij[0], ij[1]))
  # Rotate the grid 90 degrees counter-clockwise
  rotated_grid = rot270(I)
  # Find indices of all zeros in the rotated grid
  zero_indices = ofcolor(rotated_grid, ZERO)
  # Order indices by column then row in ascending order 
  sorted_indices = order(zero_indices, lambda ij: (ij[1], ij[0]))
  # Get the first index (bottom-leftmost in original grid)
  target_index_rotated = first(sorted_indices)
  # Rotate the index back to the original grid's orientation
  target_index = (target_index_rotated[1], len(I) - 1 - target_index_rotated[0])
  # Check if the value at the found indices is '0'
  if index(I, target_idx) == ZERO:
    # Replace with '1'
    I = fill(I, ONE, initset(target_idx))
  if index(I, target_index) == ZERO:
    # Replace with '1'
    I = fill(I, ONE, initset(target_index))
  # If the value is not '0', return the original grid
  return I 
 
2.5, tensor(0.0153), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def eecajjaeiafheeggbcdcdbbaccjdaibb(I):
  bottom_row = crop(I, (height(I) - 1, 0), (1, width(I)))  # Extract bottom row
  rightmost_obj = last(objects(bottom_row, True, False, False)) # Find rightmost object
  target_loc = argmin(toindices(rightmost_obj), lambda loc: loc[1]) # Find leftmost cell
  O = fill(I, 1, {target_loc}) # Fill with '1'
  return O
 
1.5, tensor(0.0312), Description: Find the leftmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def cdfedfeiffdiegagabfffddhabcdhjid(I):
  target_loc =  extract(asindices(I), lambda loc: (loc[0] == height(I) - 1 and index(I, loc) != mostcommon(I))) # Find target directly
  O = fill(I, 1, {target_loc}) if target_loc else I # Fill if target found
  return O
 
2.5, tensor(0.0317), Description: Find the rightmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def cjaabjajacfbejhebgjgbicdabdffcgc(I):
  target_j =  max(j for i, j in asindices(I) if i == height(I) - 1 and I[i][j] != mostcommon(I)) # Find target column
  target_loc = (height(I) - 1, target_j)
  O = fill(I, 1, {target_loc}) if target_j is not None else I # Fill if target found
  return O
 
4.0, tensor(1.2789), Description: Find the least common color in the input grid. For each column in the grid, if there are cells of the least common color in that column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def gcciddcbibabedciaeabccjbadbfbbdb(I):
  target_color = leastcolor(I)  # Find the least common color
  target_indices = ofcolor(I, target_color)  # Get indices of the target color
  modified_grid = I  # Initialize output grid
  for j in range(width(I)):
    column_indices = sfilter(target_indices, lambda x: x[1] == j)  # Indices in current column
    if column_indices:
      i = valmax(column_indices, lambda x: x[0])  # Find the maximum row index (lowermost)
      modified_grid = fill(modified_grid, 1, {(i, j)})  # Fill the cell with '1'
  return modified_grid
 
3.0, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def bjgdcifahhgeebdbjgbdjbahfadihahf(I):
  min_color = leastcolor(I)  # Find the least common color
  return tuple(tuple(1 if (j, v) in ofcolor(I, min_color) and i == lowermost(ofcolor(I, min_color) & hfrontier((0, j))) else v for j, v in enumerate(row)) for i, row in enumerate(I))
 
1.0, tensor(0.0510), Description: Find the rightmost square in the bottom row of the grid that has the same color as the least common color in that row. Color that square red. If there are no squares with the least common color in that row, keep the input grid unchanged. 
:: def gbbbgaffbfhbegicjdiiaefbfecaacbg(I):
  target_color = leastcommon(I[height(I) - 1])
  target_loc = extract(asindices(I), lambda loc: loc[0] == height(I) - 1 and I[loc[0]][loc[1]] == target_color)
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
4.0, tensor(1.4392), Description: For each column in the grid, find the first cell that is not the most common color, starting from the bottom and moving upwards. If this cell is in the bottom row or has the most common color below it, color it red. Otherwise, keep the grid unchanged. 
:: def dgaceadefifeeaffacifhaegdbgfahgc(I):
  h, w = len(I), len(I[0])
  def is_bottom_cell(i, j):
    return i == h - 1 or I[i + 1][j] == mostcolor(I)
  O = I
  for j in range(w):
    for i in range(h-1, -1, -1):
      if I[i][j] != mostcolor(I) and is_bottom_cell(i, j):
        O = fill(O, 1, {(i, j)})
        break
  return O
 
6.0, tensor(1.4891), Description: For each column in the grid, find the first cell that is not the most common color, starting from the top and moving downwards. Color that cell red. If a column does not contain any cells that are not the most common color, move on to the next column. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def jaadbebdebbeefacjaefaaeiaefjbfec(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    for i in range(h):
      if I[i][j] != mostcolor(I):
        O = fill(O, 1, {(i, j)})
        break
  return O
 
9.25, tensor(0.1061), Description: For each column in the grid, find the rightmost cell that is not the most common color in the grid. Color that cell red. If a column does not contain any cells that are not the most common color, move on to the next column. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def icfbhdbebfdcedfeadchbagdccdejjig(I):
  return tuple(tuple(1 if j == max(k for k, x in enumerate(col) if x != mostcolor(I)) else v for j, v in enumerate(col)) for col in dmirror(I))
 
2.5, tensor(0.0105), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cdccdceechebegbbahjchbjgagcbebcf(I):
  # Get indices of all zeros in the grid.
  zero_indices = ofcolor(I, ZERO) 
  # Find the index with the maximum row value (bottom-most).
  target_idx = argmax(zero_indices, lambda ij: ij[0])
  # If multiple indices have the same maximum row value, 
  # take the one with minimum column index (left-most).
  target_idx = argmin(sfilter(zero_indices, lambda ij: ij[0] == target_idx[0]), lambda ij: ij[1])
  # Replace the zero at the target index with a one.
  return fill(I, ONE, initset(target_idx))
 
2.25, tensor(0.0111), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ijbaehigdgjgefecieagidaafcbbeiff(I):
  # Transpose the grid and reverse each row.
  transposed_grid = dmirror(I)[::-1]
  # Find the first occurrence of '0' in the transposed grid.
  target_idx_transposed = next((i, j) for i, row in enumerate(transposed_grid) 
                                 for j, value in enumerate(row) if value == ZERO)
  # Calculate the index in the original grid.
  target_idx = (target_idx_transposed[1], len(I) - 1 - target_idx_transposed[0])
  # Replace the '0' with a '1'.
  return fill(I, ONE, initset(target_idx))
 
2.5, tensor(1.5436), Description: Find the first black square in the grid, starting from the bottom right corner and moving towards the top left, and color it red. If there are no black squares, keep the input grid unchanged. 
:: def fjhcdegfddcfedidigjdagbdeihgedfa(I):
  # Iterate through rows from bottom to top.
  for i in range(len(I) - 1, -1, -1):
    # Iterate through columns from right to left.
    for j in range(len(I[0]) - 1, -1, -1):
      # If a '0' is found, replace it with a '1' and return the grid.
      if I[i][j] == ZERO:
        return fill(I, ONE, initset((i, j)))
  # If no '0' is found, return the original grid.
  return I
 
2.0, tensor(0.0312), Description: Find the leftmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def aejaeibabdegehafageeahdddhfdgbfc(I):
  target_indices = sfilter(asindices(I), lambda loc: loc[0] == height(I) - 1 and I[loc[0]][loc[1]] != mostcommon(I)) # Find non-background cells in bottom row
  target_loc = argmin(target_indices, lambda loc: loc[1]) if target_indices else None # Find leftmost target cell
  O = fill(I, 1, {target_loc}) if target_loc else I  # Fill with 1 if target cell is found
  return O
 
2.5, tensor(0.0312), Description: Find the leftmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def ccbecabbfdcfebeabfedbbcfbaahhjhg(I):
  def is_target(obj):
    return lowermost(obj) == height(I) - 1 and color(obj) != mostcommon(I)  # Check if object is in bottom row and not background
  target_obj = extract(objects(I, True, False, False), is_target)  # Extract the target object
  target_loc = argmin(toindices(target_obj), lambda loc: loc[1]) if target_obj else None  # Find leftmost cell of the target object
  O = fill(I, 1, {target_loc}) if target_loc else I  # Fill the leftmost cell with 1 if the target object exists
  return O
 
5.0, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def afchfaghcddeecacjbhbaabhjchcgaed(I):
  target_color = leastcolor(I)
  return tuple(
    tuple(
      1 if j == next((k for i, k in ofcolor(I, target_color) if k == col and i == max((a for a, b in ofcolor(I, target_color) if b == col), default=-1)), None) else v
      for j, v in enumerate(row)
    )
    for col, row in enumerate(I)
  ) 
 
2.0, tensor(1.3148), Description: For each row in the grid, find the rightmost cell that is not the most common color in the grid. Color that cell red. If a row does not contain any cells that are not the most common color, move on to the next row. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def acchiibgffdbedfaideaaaccfejbfedd(I):
  def find_target_row(grid):
    return max((i for i, row in enumerate(grid) for v in row if v != mostcolor(grid)), default=0)
  
  def process_row(row, target_row_index):
    if target_row_index == find_target_row(I):
      return tuple(1 if j == max((k for k, v in enumerate(row) if v != mostcolor(I)), default=0) else v for j, v in enumerate(row))
    return row
  
  return tuple(process_row(row, i) for i, row in enumerate(I))
 
2.5, tensor(0.0111), Description: Find the top-leftmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def fdjcdcceajjhefciiidfbfddigbggfhb(I):
  # Rotate the grid 180 degrees.
  rotated_grid = rot180(I)
  # Find indices of all zeros in the rotated grid.
  zero_indices = ofcolor(rotated_grid, ZERO)
  # Order indices by column then row in ascending order.
  sorted_indices = order(zero_indices, lambda ij: (ij[1], ij[0]))
  # Get the first index (top-leftmost '0' in the original grid).
  target_index_rotated = first(sorted_indices)
  # Rotate the index back to the original grid's orientation.
  target_index = (len(I)-1-target_index_rotated[0], len(I[0])-1-target_index_rotated[1])
  # Replace the zero at the found index with a one.
  return fill(I, ONE, initset(target_index))
 
2.5, tensor(0.0120), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ceceeebbdafbecdbjdfbcfebaeaddaeb(I):
  # Get the indices of all cells in the grid.
  all_indices = asindices(I)
  # Filter indices to get those with the maximum row value (bottom-most row).
  bottom_indices = sfilter(all_indices, lambda ij: ij[0] == maximum(apply(lambda ij: ij[0], all_indices)))
  # Among the bottom-most indices, find the one with the maximum column index (right-most).
  target_idx = argmax(bottom_indices, lambda ij: ij[1])
  # Replace the '0' at the target index with a '1'.
  return fill(I, ONE, initset(target_idx))
 
2.0, tensor(0.0312), Description: Find the leftmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def fjhcfgbbciifeahbbghagfffagcchbbi(I):
  target_loc = None
  for j in range(width(I)):
    if I[height(I)-1][j] != mostcolor(I):
      target_loc = (height(I)-1, j)
      break
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0307), Description: Find the leftmost square in the bottom row of the grid that has the same color as the least common color in that row. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def idabfedbeecbecghjefedhdaaabfieaf(I):
  target_indices = ofcolor(crop(I, (height(I) - 1, 0), (1, width(I))), leastcolor(crop(I, (height(I) - 1, 0), (1, width(I)))))
  target_loc =  argmin(target_indices, lambda loc: loc[1]) if target_indices else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
12.0, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def dcdheiibbdfdefjaiedeeehdcgbegbdb(I):
  target_color = leastcolor(I)
  return tuple(
    tuple(
      1 if j == max((k for i, k in ofcolor(I, target_color) if k == j), default=-1) else v
      for j, v in enumerate(row)
    )
    for row in I
  )
 
2.25, tensor(0.0186), Description: If the last element of a row is not the most common color in the grid, change it to red. Otherwise, keep the row unchanged. 
:: def ciejghgbaeieebadjbiehjifaafddebd(I):
  return tuple(r[:-1] + (1,) if i == len(I) - 1 and r[-1] != mostcolor(I) else r for i, r in enumerate(I))
 
2.5, tensor(0.0153), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cafdjhdcgiibejaeiifbdebjjdgabfcc(I):
  bottom_row = crop(I, (height(I) - 1, 0), (1, width(I)))
  objs = objects(bottom_row, True, False, False)
  target_obj = argmax(objs, lambda obj: rightmost(obj)) if objs else None
  target_loc = argmin(toindices(target_obj), lambda loc: loc[1]) if target_obj else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.0, tensor(0.0317), Description: Find the rightmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def gcjifbdibafgedbebdhecgfcibjbeeej(I):
  for j in range(width(I) - 1, -1, -1):
    if I[height(I) - 1][j] != mostcolor(I):
      return fill(I, 1, {(height(I) - 1, j)})
  return I
 
2.0, tensor(0.0153), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ibbgfaiadghheeaaicjfchgheabeggia(I):
  bottom_objs = objects(crop(I, (height(I) - 1, 0), (1, width(I))), True, False, False)
  target_obj = extract(bottom_objs, lambda obj: len(obj) > 0) if bottom_objs else None
  target_loc = (height(I) - 1, leftmost(target_obj)) if target_obj else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0317), Description: Find the rightmost square in the bottom row of the grid that is not the most common color in the grid. Color that square red. If there are no such squares, keep the input grid unchanged. 
:: def bbefiacbchgbeebcjccbiedjdaeaddee(I):
  bottom_row_indices = asindices(crop(I, (height(I) - 1, 0), (1, width(I))))
  target_loc = argmax(bottom_row_indices, lambda loc: (index(I, loc) != mostcolor(I), loc[1]))
  return fill(I, 1, {target_loc}) if target_loc else I
 
4.0, tensor(1.2833), Description: Find the least common color in the input grid. For each column in the grid, if there are cells of the least common color in that column, color the topmost cell of that color red. Otherwise, keep the grid unchanged. 
:: def ehdagcffbbbeeaaciahidhdfgbcbbfbd(I):
  target_color = leastcolor(I)
  h, w = height(I), width(I)
  output_grid = [list(row) for row in I]  
  for j in range(w):
    min_i = None
    for i in range(h):
      if I[i][j] == target_color:
        if min_i is None or i < min_i:
          min_i = i
    if min_i is not None:
      output_grid[min_i][j] = 1
  return tuple(tuple(row) for row in output_grid)
 
1.5, tensor(0.0210), Description: For each cell in the grid, if the cell is not the most common color and it is either in the bottom row or has the most common color below it, color that cell red. Otherwise, keep the grid unchanged. 
:: def fcegefhegejfeadjbeeedbaceeeefdge(I):
  return tuple(tuple(1 if (i,j) in mfilter(asindices(I), lambda loc: index(I, loc) != mostcolor(I) and ((loc[0] == len(I)-1) or (index(I, (loc[0]+1, loc[1])) == mostcolor(I)))) else index(I, (i, j)) for j in range(len(I[0]))) for i in range(len(I)))
 
2.0, tensor(0.0197), Description: Find the bottom-leftmost black square in the bottom half of the grid and color it red. If there are no black squares in the bottom half, keep the input grid unchanged. 
:: def bgcedaechebhefbhjfccebjfhcgbbddd(I):
  # Rotate the grid 90 degrees clockwise
  rotated_grid = rot90(I)
  # Find indices of all zeros in the rotated grid
  zero_indices = ofcolor(rotated_grid, ZERO)
  # Filter for zeros in the right half of the rotated grid (bottom half of original)
  filtered_indices = sfilter(zero_indices, lambda ij: ij[1] >= len(rotated_grid[0]) // 2)
  # Order indices by column then row in ascending order 
  sorted_indices = order(filtered_indices, lambda ij: (ij[1], ij[0]))
  # Get the first index (bottom-leftmost in original grid)
  if sorted_indices:
    target_index_rotated = first(sorted_indices)
    # Rotate the index back to the original grid's orientation
    target_index = (target_index_rotated[1], len(I) - 1 - target_index_rotated[0])
    # Replace the zero at the found index with a one
    return fill(I, ONE, initset(target_index)) 
  else:
    return I
 
6.25, tensor(0.0245), Description: Find the leftmost black square in the bottom half of the grid and color it red. If there are no black squares in the bottom half, keep the input grid unchanged. 
:: def igdeebcfheifeecbbbbgaicbddddacia(I):
  # Split the grid horizontally into two halves
  top_half, bottom_half = vsplit(I, 2)
  # Find the bottom-leftmost '0' in the bottom half
  target_idx = argmin(ofcolor(bottom_half, ZERO), lambda ij: (ij[0], ij[1]))
  # If a target '0' is found, replace it with '1' in the bottom half
  if target_idx:
    bottom_half = fill(bottom_half, ONE, initset(target_idx))
  # Concatenate the halves back together
  return vconcat(top_half, bottom_half)
 
2.5, tensor(0.0245), Description: Find the leftmost black square in the bottom half of the grid and color it red. If there are no black squares in the bottom half, keep the input grid unchanged. 
:: def hjiafjddbeffeadciffceceaaaecfdai(I):
  # Create a function to check if an index is in the bottom half and corresponds to a '0'
  def is_target(i, j):
    return i >= len(I) // 2 and I[i][j] == ZERO
  # Find the target index
  target_idx = argmin(prapply(lambda i, j: (i, j), range(len(I)), range(len(I[0]))),
                      lambda ij: (ij[0], ij[1]) if is_target(ij[0], ij[1]) else (float('inf'), float('inf')))
  # If a target is found, replace it with '1'
  if target_idx != (float('inf'), float('inf')):
    return fill(I, ONE, initset(target_idx))
  # No target found, return the original grid
  return I
 
11.25, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def acbagdfddhcbefadaffadebjcbcfjfbh(I):
  target_color = leastcolor(I)
  return tuple(
    tuple(
      1 if any(i == j and v == target_color for i, row in enumerate(I) for v in row) 
      else v 
      for j, v in enumerate(r)
    ) 
    for r in I
  )
 
3.0, tensor(0.0462), Description: For each colored object in the input grid, color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def bdabfdbfhdhceeajadhfiebfefejcfea(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  return paint(I, merge(apply(lambda obj: frozenset({(1, lrcorner(obj))}), objs)))
 
2.5, tensor(0.0129), Description: Find the top-rightmost black square in the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def bicgifcfbjdbebgiieagaaijbaaheaag(I):
  # Get indices of all zeros
  zero_indices = ofcolor(I, ZERO)
  # Find the index with maximum column value (right-most zero)
  target_idx = argmax(zero_indices, lambda ij: ij[1]) 
  # If multiple zeros share the maximum column, choose the top-most.
  target_idx = argmin(sfilter(zero_indices, lambda ij: ij[1] == target_idx[1]), lambda ij: ij[0])
  # Replace the target zero with a one.
  return fill(I, ONE, initset(target_idx))
 
2.5, tensor(0.0201), Description: Find the bottom-most black square in the left half of the grid and color it red. If there are no black squares in the left half, keep the input grid unchanged. 
:: def debaadidjahbebdgjdfihafagdaaddaa(I):
  # Split the grid vertically into left and right halves. 
  left_half, right_half = hsplit(I, 2) 
  # Get indices of zeros in the left half
  zero_indices_left = ofcolor(left_half, ZERO) 
  # Find the bottom-most zero in the left half
  target_idx_left = argmax(zero_indices_left, lambda ij: ij[0])
  # Adjust the index to reflect the original grid's coordinates
  target_idx = (target_idx_left[0], target_idx_left[1])
  # Replace the target zero with a one in the original grid.
  return fill(I, ONE, initset(target_idx))
 
2.5, tensor(0.0131), Description: Find the rightmost black square in the top row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def agdadacdebafehihifeaciiaecdecaah(I):
  # Transpose the grid (swap rows and columns)
  transposed_grid = dmirror(I)
  # Find the indices of all zeros in the transposed grid.
  zero_indices = ofcolor(transposed_grid, ZERO) 
  # Find the bottom-most zero in the transposed grid
  target_idx_transposed = argmax(zero_indices, lambda ij: ij[0])
  # Adjust the index back to the original grid's orientation
  target_idx = (target_idx_transposed[1], target_idx_transposed[0])
  # Replace the target zero with a one in the original grid.
  return fill(I, ONE, initset(target_idx))
 
4.75, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def ibeffcjfegdbechjafcdheagjiideedc(I):
  target_color = leastcolor(I)
  h, w = len(I), len(I[0])
  return tuple(
    tuple(
        1 if (i == h - 1 or any(I[k][j] == target_color for k in range(i + 1, h))) and v == target_color else v
        for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
  )
 
5.75, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def ebbfbjebffdbecbfaigigaifaadcechd(I):
  target_color = leastcolor(I)
  h = height(I)
  return tuple(
    tuple(
      1 if j == next((k for i, k in reversed(sorted(ofcolor(I, target_color))) if k == j), -1) and v == target_color else v
      for j, v in enumerate(row)
    )
    for row in I
  )
 
2.0, tensor(0.0350), Description: Find the leftmost cell in the bottom row of the object that is furthest from the top-left corner of the grid. Color that cell red. If there are no objects, keep the input grid unchanged. 
:: def iebbcedfjbadeacfbbcecffcbcheibjc(I):
  bg = mostcolor(I) # identify background color
  target_obj =  max(objects(I, True, False, True), key=lambda obj: (lowermost(obj), rightmost(obj))) # find bottom-rightmost object
  target_loc = min(((i, j) for v, (i, j) in target_obj if i == lowermost(target_obj)), key=lambda loc: loc[1], default=None) # find leftmost cell in bottom row of the object
  O = fill(I, 1, {target_loc}) if target_loc else I # fill the target cell with 1
  return O
 
2.0, tensor(1.7146), Description: Find the first square in the grid that is not the most common color, starting from the bottom right corner and moving towards the top left. Color that square red. If there are no squares that are not the most common color, keep the input grid unchanged. 
:: def hbbdgbcjjaagebbjicbebadfjfafbdgb(I):
  h, w = len(I), len(I[0]) # get grid dimensions
  target_loc = None
  for j in range(w - 1, -1, -1): # iterate columns right to left
    for i in range(h - 1, -1, -1): # iterate rows bottom to top
      if I[i][j] != mostcolor(I): # check if not background
        target_loc = (i, j)
        break
    if target_loc: 
      break
  O = fill(I, 1, {target_loc}) if target_loc else I # fill target if found
  return O 
 
2.0, tensor(0.1282), Description: For each column in the grid, find the topmost cell that is not the most common color in the grid. Color that cell red. If a column does not contain any cells that are not the most common color, move on to the next column. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def aaiehbfbehieejeeaiacdaadddfjcafg(I):
  bg = mostcolor(I) # identify background color
  h, w = len(I), len(I[0]) # get grid dimensions
  for i in range(h - 1, -1, -1): # iterate rows bottom to top
    for j in range(w - 1, -1, -1): # iterate columns right to left
      if I[i][j] != bg and any(I[k][j] != bg for k in range(i + 1, h)): # check if cell is not bg and is the topmost non-bg cell in its column
        return fill(I, 1, {(i, j)}) # fill the cell and return immediately
  return I # return the original grid if no target is found
 
2.5, tensor(0.0957), Description: Find the bottom-most black square in each column of the grid. Color that square red. If a column does not contain any black squares, move on to the next column. If there are no black squares in the grid, keep the input grid unchanged. 
:: def fdaeeibdiccfefbebdcebccfhffbffeb(I):
  # Find all indices of zeros
  zero_indices = ofcolor(I, ZERO)
  # Sort the indices based on row index in descending order
  sorted_indices = order(zero_indices, lambda ij: -ij[0])
  # Iterate through the sorted indices
  for i, j in sorted_indices:
    # Replace the first zero encountered which is also the bottom-most in its column
    if index(I, (i, j)) == ZERO:
      return fill(I, ONE, initset((i, j)))
  # Return the original grid if no replacement occurred
  return I 
 
2.5, tensor(0.0105), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def cdgeaadeadafejjjafbifccaaacbhaee(I):
  # Find all objects in the grid
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  # Filter objects to get only those containing '0'
  zero_objs = sfilter(objs, lambda obj: color(obj) == ZERO)
  # Find the object with the maximum lowermost row index
  target_obj = argmax(zero_objs, lambda obj: lowermost(obj))
  # Find the leftmost index within the target object
  target_idx = argmin(toindices(target_obj), lambda ij: ij[1])
  # Replace the value at the target index with '1'
  return fill(I, ONE, initset(target_idx))
 
3.0, tensor(0.0486), Description: For each colored object in the input grid, color its bottom-right corner red. Then, find the cell in the grid that is furthest from the top-left corner (i.e., the bottom-rightmost cell) and color it red as well. If there are no colored objects, keep the input grid unchanged. 
:: def ddfbbgbcjcceeacdbggcibcbjfbicaac(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  target_cells = set()
  for obj in objs:
    bottom_row = {(v, (i, j)) for v, (i, j) in obj if i == lowermost(obj)}
    target_cells.add(max(bottom_row, key=lambda x: x[1][1]))
  target_cells.add(max(((v, (i,j)) for i, r in enumerate(I) for j, v in enumerate(r) if v != bg), key=lambda x: (x[1][0], x[1][1])))
  return paint(I, frozenset((1, loc) for _, loc in target_cells))
 
3.75, tensor(0.0468), Description: For each colored object in the input grid, color the leftmost cell in the bottom row of that object red. Then, for each cell in the bottom row that is not the most common color in the grid, color that cell red as well. If there are no colored objects, keep the input grid unchanged. 
:: def bccdeefbeafaechdafabieadaejhacbc(I):
  bg = mostcolor(I)
  h = height(I)
  target_cells = {(h-1, j) for j, v in enumerate(I[h-1]) if v != bg}
  for obj in objects(I, True, False, True):
    if lowermost(obj) == h - 1: 
      continue
    target_cells.add(min(((i, j) for v, (i, j) in obj if i == lowermost(obj)), key=lambda loc: loc[1]))
  return fill(I, 1, target_cells)
 
4.0, tensor(1.1659), Description: For each column in the grid, find the first cell that is not the most common color, starting from the bottom and moving upwards. Color that cell red. If a column does not contain any cells that are not the most common color, move on to the next column. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def eaejdcfejfbcebbbabbjfhgdacdbcajd(I):
  bg = mostcolor(I)
  target_cells = set()
  for j in range(width(I)-1, -1, -1):
    for i in range(height(I)-1, -1, -1):
      if I[i][j] != bg:
        target_cells.add((i, j))
        break
  return fill(I, 1, target_cells)
 
3.5, tensor(1.6669), Description: For each row in the grid, starting from the bottom row and moving upwards, find the rightmost cell that is not the most common color in the grid. Color that cell red. If a row does not contain any cells that are not the most common color, move on to the next row. If there are no cells in the grid that are not the most common color, keep the input grid unchanged. 
:: def iddfaeffeiibeeiaabhccddgabdfabba(I):
  h, w = height(I), width(I)
  def is_valid(x, y):
    return 0 <= x < h and 0 <= y < w
  def get_rightmost_in_row(row):
    for j in range(w - 1, -1, -1):
      if is_valid(row, j) and I[row][j] != mostcolor(I):
        return (row, j)
    return None
  target_cells = {get_rightmost_in_row(i) for i in range(h - 1, -1, -1) if get_rightmost_in_row(i) is not None}
  return fill(I, 1, target_cells)
 
3.25, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def fbdcbjbfjegdehafijigfeddfbifahaf(I):
  target_color = leastcolor(I)
  h = len(I)
  return tuple(
    tuple(
        1 if v == target_color and any(I[k][j] == target_color for k in range(i + 1, h)) else v
        for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
  )
 
2.0, tensor(1.3214), Description: For each row in the grid, find the least common color. If there are cells of that color in the row, color the rightmost cell of that color red. Otherwise, keep the grid unchanged. 
:: def abddcdhfdeehefccbedefhieibeaiaij(I):
    target_color = leastcolor(I)
    return tuple(
        tuple(
            1 if j == len(row)-1 and v == target_color else v
            for j, v in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
4.75, tensor(1.3039), Description: For each column in the grid, find the least common color. If there are cells of that color in the column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def gfgdfcicichaebhibbeifbacadjfffdb(I):
    t = leastcolor(I)
    return tuple(tuple(1 if (i == len(I)-1 or I[i+1][j] != t) and v == t else v for j, v in enumerate(r)) for i, r in enumerate(I))
 
1.25, tensor(0.2819), Description: Find the least common color in the bottom row of the input grid. Color all the squares in the bottom row that have that color red. If there are no squares with the least common color in the bottom row, keep the input grid unchanged. 
:: def efiifeejeaefejacibgebdeaeaadfbbe(I):
  last_row_indices =  {(height(I) - 1, j) for j in range(width(I))}  # Generate indices for the last row
  target_color = leastcolor(toobject(last_row_indices, I))  # Find least common color in the last row object
  return underfill(I, 1, ofcolor(I, target_color) & last_row_indices) # Underfill '1' at target color in last row
 
8.5, tensor(0.0688), Description: Find the black squares that are adjacent to a non-black square. If there are no such squares, find the leftmost black square in the grid. Color the found black squares red. If there are no black squares, keep the input grid unchanged. 
:: def feabbgiibabfejbjieejjdbddhceafcb(I):
  # Find all zeros adjacent to a non-zero value
  target_indices = frozenset(
      (i, j)
      for i, row in enumerate(I)
      for j, v in enumerate(row)
      if v == ZERO and any(n != ZERO for n in [I[k][l] for k, l in neighbors((i, j)) if 0 <= k < len(I) and 0 <= l < len(row)])
  )
  # If no such zeros are found, fall back to finding the bottom-left zero
  if len(target_indices) == 0:
    target_indices = ofcolor(I, ZERO)
    target_idx = argmin(target_indices, lambda ij: ij[1] * len(I) + ij[0])
    target_indices = initset(target_idx)
  # Replace the target zeros with ones
  return fill(I, ONE, target_indices)
 
2.5, tensor(0.0286), Description: Find the largest colored object in the input grid and color its bottom-right corner red. If there are no colored objects, keep the input grid unchanged. 
:: def jjccjhfdaiefefdhiifficdfdjfcbfeg(I):
  objs = objects(I, True, False, False) # get all objects in the grid
  target_obj = argmax(objs, lambda obj: len(obj)) # find the largest object
  target_loc = argmin(toindices(target_obj), lambda loc: (loc[0], -loc[1])) if target_obj else None  # find the bottom-right most cell of the largest object
  O = fill(I, 1, {target_loc}) if target_loc else I # fill the target location with 1
  return O
 
1.5, tensor(0.0486), Description: Find the colored object whose bottom-right corner has the largest difference between its column index and row index (j - i). Color the bottom-right corner of that object red. If there are no colored objects, keep the input grid unchanged. 
:: def caadjihefjbdecjhiidddeeiddghehfd(I):
  objs = objects(I, True, False, False) # get all objects
  target_obj = argmax(objs, lambda obj: lrcorner(obj)[1] - lrcorner(obj)[0]) # find object with maximum difference between its bottom-right corner column and row index.
  target_loc = lrcorner(target_obj) if target_obj else None # get the bottom-right corner of the target object
  return fill(I, 1, {target_loc}) if target_loc else I # fill the target location with 1
 
2.0, tensor(1.2789), Description: Find the least common color in the input grid. For each column in the grid, if there are cells of the least common color in that column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def faebdicghdfaegadicbbcjgfcabicbfg(I):
  target_color = leastcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, target_color)
  bottom_cells = mapply(lambda obj: frozenset({(target_color, (lowermost(obj), j)) for i, j in toindices(obj)}), target_objs)
  O = paint(I, bottom_cells)
  return O
 
3.75, tensor(1.2789), Description: Find the least common color in the input grid. For each column in the grid, if there are cells of the least common color in that column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def fcdcbeabaijieaaebecdcaafffbhabdf(I):
  target_color = leastcolor(I)
  indices = ofcolor(I, target_color)
  bottom_indices = frozenset((max((i for i, j in indices if j == col)), col) for col in range(width(I)) if any(i == col for i, _ in indices))
  O = fill(I, 1, bottom_indices)
  return O
 
2.5, tensor(0.0105), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def ggeejcacfaebebacifbgjeidajacdbdb(I):
  # Find indices of all zeros
  zero_indices = ofcolor(I, ZERO)
  # Find the index with minimum row value (bottom-most zero)
  target_idx = argmin(zero_indices, lambda ij: ij[0])
  # If multiple zeros share the minimum row, choose the left-most.
  target_idx = argmin(sfilter(zero_indices, lambda ij: ij[0] == target_idx[0]), lambda ij: ij[1])
  # Replace the target zero with a one.
  return fill(I, ONE, initset(target_idx))
 
2.5, tensor(0.0153), Description: Find the leftmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def gfcdabcfiedgecfciefjdbhaibbbihbe(I):
  def is_bottom_zero(loc):
    i, j = loc
    return I[i][j] == 0 and i == height(I) - 1
  bottom_zero_indices = sfilter(asindices(I), is_bottom_zero)
  target_loc = first(bottom_zero_indices) if bottom_zero_indices else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.5, tensor(0.0159), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def effccddchcadedfejcfddgijcdadaejb(I):
  def is_bottom_zero(loc):
    i, j = loc
    return I[i][j] == 0 and i == height(I) - 1
  bottom_zero_indices = sfilter(asindices(I), is_bottom_zero)
  target_loc = last(bottom_zero_indices) if bottom_zero_indices else None
  O = fill(I, 1, {target_loc}) if target_loc else I
  return O
 
2.0, tensor(0.0121), Description: Find the middle square in the bottom row of the grid and color it red. If there are no squares in the bottom row, keep the input grid unchanged. 
:: def edfaececddigeddaaahbeejiaefabcad(I):
  bottom_row_indices = sfilter(asindices(I), lambda loc: loc[0] == height(I) - 1)
  middle_index = size(bottom_row_indices) // 2
  target_loc = order(bottom_row_indices, lambda x: x[1])[middle_index] 
  O = fill(I, 1, {target_loc}) 
  return O
 
2.5, tensor(0.0159), Description: Find the rightmost black square in the bottom row of the grid and color it red. If there are no black squares, keep the input grid unchanged. 
:: def defecgbecfbfejdcjbcdeffehachddca(I):
  h, w = len(I), len(I[0])
  for j in range(w - 1, -1, -1):
    if I[h - 1][j] == 0:
      return fill(I, 1, {(h - 1, j)})
  return I
 
2.25, tensor(0.0144), Description: Find the rightmost square in the bottom row of the grid and color it red. If there are no squares in the bottom row, keep the input grid unchanged. 
:: def acaedfaabacjedbgiacjdejaceiddege(I):
  h, w = len(I), len(I[0])
  target_j = w - 1 if w > 1 else 0
  if I[h - 1][target_j] == 0:
    I = fill(I, 1, {(h-1, target_j)})
  return I
 
6.0, tensor(1.2789), Description: Find the least common color in the input grid. For each column in the grid, if there are cells of the least common color in that column, color the bottommost cell of that color red. Otherwise, keep the grid unchanged. 
:: def bdeaabefhadbebiiicbdedgedeafdfje(I):
  target_color = leastcolor(I)
  h = height(I)
  w = width(I)
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    bottom_i = None
    for i in range(h):
      if I[i][j] == target_color:
        bottom_i = i
    if bottom_i is not None:
      O = fill(O, 1, {(bottom_i, j)})
  return O
 
2.0, tensor(0.0576), Description: Find the colored object whose bottom-right corner has the largest sum of row and column indices (i + j). Color the bottom-right corner of that object red. If there are no colored objects, keep the input grid unchanged. 
:: def ffbfdfgcdcdieabajbajaiicdjhbacbd(I):
  def target_index(obj):
    return argmax(toindices(obj), lambda x: (x[0], x[1])) # Find index of rightmost cell in lowest row
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  lowest_obj = argmax(objs, lambda obj: lowermost(obj)) # Find the object with the lowest row index
  return paint(I, {(1, target_index(lowest_obj))})
 
2.0, tensor(1.0945), Description: Find the bottommost row in the grid. For that row, find the rightmost cell that is not the most common color in the grid. Color that cell red. Keep all other cells unchanged. 
:: def caggifigfaafebgcjcjabjehjeibcbai(I):
  def process_row(row, i, target_i):
    if i == target_i:
      j = valmax(sfilter(enumerate(row), lambda x: x[1] != mostcolor(I)), lambda x: x[0]) # Rightmost non-background cell
      return tuple(1 if idx == j else v for idx, v in enumerate(row))
    return row
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  target_i = lowermost(merge(objs)) # Find the lowest row index
  return tuple(process_row(row, i, target_i) for i, row in enumerate(I))
 
6.25, tensor(0.0073), Description: Copy the input grid. Then, move the red shape down by one square. The red shape should be in the same position as it was in the input grid, but one square lower. 
:: def dadcbcdfihcdeihfagfhcebefbifbjgd(I):
  # Identify the object with color '1'
  x1 = first(colorfilter(objects(I, T, F, F), 1))
  
  # Shift the object down by one unit
  x2 = shift(x1, DOWN) 

  # Paint the shifted object onto a blank canvas of the same size as the input
  x3 = paint(canvas(0, shape(I)), x2) 

  # Combine the original grid with the shifted object, prioritizing the shifted object
  O = cellwise(x3, I, 0)
  return O
 
4.25, tensor(0.0073), Description: Copy the input grid. Then, move the red shape down by one square. The red shape should be in the same position as it was in the input grid, but one square lower. 
:: def hbdadebfcjiceefbadefdgdbbdfjdcfd(I):
  # Extract all objects from the grid
  x1 = objects(I, T, F, F) 

  # Isolate the object with color '1'
  x2 = first(colorfilter(x1, 1)) 

  # Shift the object down by one unit
  x3 = shift(x2, DOWN) 

  # Remove the original object and paint the shifted object onto the grid
  O = paint(cover(I, x2), x3) 
  return O
 
4.75, tensor(0.0106), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the right so that its right edge aligns with the right edge of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def afbjgdfiadfeegdaadaiicbcdbeibecc(I):
  # Identify objects
  objs = objects(I, F, T, T)

  # Find the smallest object
  small_obj = argmin(objs, size)

  # Find the largest object
  large_obj = argmax(objs, size)

  # Calculate the target location based on the largest object
  target_loc = (lowermost(large_obj), rightmost(large_obj) - width(small_obj) + 1)

  # Move the smallest object to the target location
  O = move(I, small_obj, subtract(target_loc, ulcorner(small_obj)))
  return O
 
4.25, tensor(0.0077), Description: Find the smallest colored object in the input grid. Move that object to the bottom-right corner of the grid. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def hciibcfaecfaebibiebgccdghbeaedec(I):
  # Identify the smallest and other objects
  objs = objects(I, F, T, T)
  smallest = argmin(objs, size)
  other_objs = difference(objs, {smallest})

  # Find the bottom-right corner of the grid
  bottom_right = (height(I) - 1, width(I) - 1)

  # Calculate the offset to move the smallest object
  offset = subtract(bottom_right, lrcorner(smallest))

  # Move the smallest object and paint it on a blank canvas
  moved_obj = shift(smallest, offset)
  O = paint(canvas(mostcolor(I), shape(I)), moved_obj)

  # Paint the other objects onto the canvas
  for obj in other_objs:
    O = paint(O, obj)
  return O
 
3.75, tensor(0.0148), Description: Move the smallest colored object to the bottom-right corner of the grid. Keep the original colors of all objects. The background should remain black. 
:: def ceheffedgbbaeahbjifebdichghjdida(I):
  # Find the smallest object's bounding box
  objs = objects(I, F, T, T)
  min_obj = argmin(objs, size)
  min_i, min_j = ulcorner(min_obj)
  max_i, max_j = lrcorner(min_obj)

  # Calculate the new location for the smallest object
  new_i = height(I) - (max_i - min_i + 1)
  new_j = width(I) - (max_j - min_j + 1)

  # Create a new grid by moving the smallest object
  O = tuple(
      tuple(
          I[i][j] if not (min_i <= i <= max_i and min_j <= j <= max_j)
          else I[new_i + i - min_i][new_j + j - min_j] 
          for j in range(width(I))
      ) 
      for i in range(height(I))
  )
  return O
 
4.0, tensor(0.0077), Description: Find the smallest colored object in the input grid. Move that object to the bottom-right corner of the grid. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def ehjafdacdcceeafaadgcadbbehecageg(I):
    # Identify smallest object and background color
    objs = objects(I, F, T, T)
    min_obj = argmin(objs, size)
    bg_color = mostcolor(I)

    # Create a new grid by painting the smallest object at the bottom right
    O = paint(canvas(bg_color, shape(I)), shift(min_obj, (height(I) - height(min_obj), width(I) - width(min_obj))))

    # Paint the other objects onto the new grid
    for obj in objs - {min_obj}:
        O = paint(O, obj)

    return O
 
7.75, tensor(0.0090), Description: Copy the input grid. Then, for each cell in the grid, move the color of that cell down one row. The bottom row should remain unchanged. 
:: def gfbbafechefeejfdiejbebhceffdhfhe(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  for i in range(h-1):
    for j in range(w):
      O = fill(O, I[i][j], {(i+1, j)})
  return O
 
4.25, tensor(1.7887), Description: Color the bottom row of the grid red. If there are no squares in the bottom row, keep the input grid unchanged. 
:: def fdbeagiabcaeejceijecbhddcjfdcceh(I):
  h = height(I)
  condition = lambda i, j: i == h - 1
  replace_func = lambda i, j: ONE if condition(i, j) else I[i][j]
  O = tuple(tuple(replace_func(i, j) for j in range(width(I))) for i in range(h))
  return O
 
6.0, tensor(0.0180), Description: Copy the input grid. Then, move the smallest colored object up by one square. The smallest colored object should be in the same position as it was in the input grid, but one square higher. 
:: def fhjbjccfhhaieaebiiaddcfefaafadhb(I):
  obj = argmin(objects(I, F, T, T), size)
  up = shift(obj, (-1, 0))
  O = paint(cover(I, obj), up)
  return O
 
4.0, tensor(0.0506), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step in the direction that would bring it closer to the top of the grid. Keep the original colors of all objects. The background should remain black. 
:: def fejhdjagfcafebddjjgaccaeabgedhci(I):
  min_count = colorcount(I, leastcolor(I))
  obj = extract(objects(I, F, T, T), lambda o: colorcount(I, color(o)) == min_count)
  direction = gravitate(obj, shift(obj, (-1, 0)))
  moved = shift(obj, direction)
  O = paint(cover(I, obj), moved)
  return O
 
6.5, tensor(0.3869), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step upwards. Keep the original colors of all objects. The background should remain black. 
:: def jabcbfcchaebeeadbcfhjfafcbfjdaah(I):
  objs = objects(I, F, T, T)
  target_obj = min(objs, key=lambda o: colorcount(I, color(o)))
  up_obj = shift(target_obj, (-1, 0))
  O = paint(cover(I, target_obj), up_obj)
  return O
 
4.0, tensor(0.0077), Description: Copy the input grid. For each red shape, move it one square down and one square to the left. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def aegchfcffhfaegccaggfccbiecihhiaf(I):
  objs = objects(I, T, T, T) # Identify all distinct objects in the grid
  recolored_objs = set()
  for obj in objs:
    if color(obj) == 1: # Focus on the object with color '1'
      lr = lrcorner(obj) # Get the lower right corner of the object
      shifted_obj = shift(obj, (1, -1)) # Shift the object down and left
      recolored_objs.add(shifted_obj) # Add shifted object to the set
    else:
      recolored_objs.add(obj) # Keep other objects unchanged
  O = paint(canvas(mostcolor(I), shape(I)), frozenset.union(*recolored_objs)) # Paint the transformed objects onto a blank canvas
  return O
 
3.75, tensor(0.0077), Description: Copy the input grid. For each red shape, move it one square down and one square to the left. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def fahafcfcabfhebdjjgfdegeadfjeadde(I):
  one_obj = extract(objects(I, T, T, T), lambda obj: color(obj) == 1) # Extract the object with color '1'
  shifted_one_obj = shift(one_obj, (1, -1)) # Shift the object down and left 
  other_objs = frozenset(obj for obj in objects(I, T, T, T) if obj != one_obj) # Get all other objects
  O = paint(canvas(mostcolor(I), shape(I)), frozenset.union(shifted_one_obj, *other_objs)) # Paint the transformed objects
  return O
 
3.75, tensor(0.0068), Description: Copy the input grid. For each red square, move it one square down and one square to the left. If the red square is on the bottom row or leftmost column, do not move it. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def gfbhfifccedcecfbafabahcfbfhjaiae(I):
  O = I # Initialize output as input
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1: # Find cells with color '1'
        if i + 1 < len(I) and j - 1 >= 0: # Check for valid shift
          O = fill(O, mostcolor(I), ((i, j),)) # Erase original location
          O = fill(O, 1, ((i + 1, j - 1),)) # Fill new location 
  return O
 
4.0, tensor(0.0071), Description: Copy the input grid. Then, move the red shape down by one square. If the red shape is on the bottom row, move it to the top row. The red shape should be in the same column as it was in the input grid. 
:: def caejbdfadjhdefbjacjabbaieadgbfbj(I):
  # Find the object with color '1'
  one_obj = first(colorfilter(objects(I, T, F, F), 1)) 
  
  # Calculate the shifted position (down by one, wrapping around)
  new_pos = ( (uppermost(one_obj) + 1) % height(I), leftmost(one_obj)) 
  
  # Shift the object
  shifted_obj = shift(one_obj, new_pos)
  
  # Remove the original object and paint the shifted object 
  O = paint(cover(I, one_obj), shifted_obj)
  return O
 
5.25, tensor(0.0106), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the right so that its right edge aligns with the right edge of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def begaeaaahaffefjgaadbejabjjfachae(I):
  # Identify the smallest object
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)

  # Find the largest object
  l_obj = argmax(objs, size)

  # Calculate the target location - to the right of the largest object
  target_loc = (uppermost(l_obj), rightmost(l_obj) + 1) 

  # Move the smallest object to the target location
  O = move(I, s_obj, subtract(target_loc, ulcorner(s_obj)))
  return O
 
4.25, tensor(0.0117), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the bottom-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def ebccifcdfjfbedfdbjhjejadeheidghe(I):
  # Identify objects
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)

  # Calculate the target location - bottom right corner of the largest object
  target_loc = (lowermost(l_obj), rightmost(l_obj))

  # Move the smallest object to the target location
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
5.25, tensor(0.0221), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object down so that its bottom edge aligns with the bottom edge of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def cdhjbgaecaaiedehagcgahdejecdebed(I):
  # Identify objects
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)

  # Calculate target location - below the largest object
  target_loc = (lowermost(l_obj) + 1, leftmost(l_obj)) 

  # Move the smallest object
  O = move(I, s_obj, subtract(target_loc, ulcorner(s_obj)))
  return O
 
5.0, tensor(0.0069), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the right so that its right edge aligns with the right edge of the largest object, leaving one space between them. Keep the original colors of both objects. The background should remain black. 
:: def jfbbefafadaeedbebfegjibfjecicfga(I):
  # Identify objects
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)

  # Calculate target location - to the right of the largest object with one space
  target_loc = (uppermost(l_obj), rightmost(l_obj) + 2) 

  # Move the smallest object
  O = move(I, s_obj, subtract(target_loc, ulcorner(s_obj)))
  return O
 
4.75, tensor(0.0151), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the corner of the largest object that is closest to the smallest object. Keep the original colors of both objects. The background should remain black. 
:: def bfdgbeafjbbdejgeadeacefdbehbhghf(I):
    # Identify objects
    objs = objects(I, F, T, T)
    s_obj = argmin(objs, size)
    l_obj = argmax(objs, size)
    
    # Calculate the relative position of the smallest object to the largest object
    rel_pos = position(s_obj, l_obj)
    
    # Determine the target location based on relative position
    target_loc = (
        lowermost(l_obj) if rel_pos[0] >= 0 else uppermost(l_obj), 
        rightmost(l_obj) if rel_pos[1] >= 0 else leftmost(l_obj)
    )
    
    # Move the smallest object to the target location
    O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj) if rel_pos == (1, 1) else ulcorner(s_obj))) 
    return O
 
5.5, tensor(0.0090), Description: Copy the input grid. Then, for each cell in the grid, move the color of that cell up one row. The top row should remain unchanged. 
:: def cffcebcddcghefdjjaadibiehjccfeic(I):
  h, w = shape(I) # Get grid dimensions
  O = canvas(ZERO, (h, w)) # Create empty canvas
  for i in range(h):
    for j in range(w):
      if i == h - 1 and j == w - 1: # If at bottom right corner
        O = fill(O, I[h-1][j], {(i, j)}) # Fill with original bottom right color
      else:
        source_i = i - 1 if i > 0 else i # Calculate source row index
        O = fill(O, I[source_i][j], {(i, j)}) # Fill with shifted color
  return O
 
4.25, tensor(0.1183), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step up if its center is above the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def ehjjbcfajdajefbfifdgfahafffaafdb(I):
  objs = objects(I, F, T, T) # Extract all objects
  target_obj = min(objs, key=lambda o: colorcount(I, color(o))) # Find target object
  
  # Move the object up if its center is above the grid's center, otherwise down
  direction = (-1, 0) if centerofmass(target_obj)[0] < len(I) // 2 else (1, 0)
  
  moved_obj = shift(target_obj, direction) # Shift the object
  O = paint(cover(I, target_obj), moved_obj) # Paint the moved object
  return O
 
4.75, tensor(0.0979), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object so that it is positioned within the largest object, maintaining the same relative position it had in the original grid. Keep the original colors of both objects. The background should remain black. 
:: def aeijdafcaeadebdhbdehicbjacedfddc(I):
  # Identify objects
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  s_color = color(s_obj)

  # Find the relative position of the smallest object's color within the largest object
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == s_color and (i, j) in toindices(l_obj):
        rel_pos = (i - uppermost(l_obj), j - leftmost(l_obj))

  # Calculate the target location based on relative position and largest object's dimensions
  target_loc = (lowermost(l_obj) + rel_pos[0], leftmost(l_obj) + rel_pos[1])

  # Move the smallest object to the target location
  O = move(I, s_obj, subtract(target_loc, ulcorner(s_obj)))
  return O
 
5.25, tensor(0.0063), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object down one row and to the right one column so that it is positioned directly below the rightmost occurrence of the smallest object's color within the largest object. Keep the original colors of both objects. The background should remain black. 
:: def bfhbbabfdfjiecjdibebaidbdeadiaee(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  s_color = color(s_obj)

  # Calculate the target location based on the position of the smallest object's color in the largest object
  l_indices = toindices(l_obj)
  target_loc = next((add((lowermost(l_obj), j), (1, 0)) for i, j in l_indices if I[i][j] == s_color), (0, 0))

  # Move the smallest object to the target location
  O = move(I, s_obj, subtract(target_loc, ulcorner(s_obj)))
  return O
 
6.75, tensor(0.0065), Description: Copy the input grid. Then, duplicate the bottom row of the grid and append it to the bottom of the grid. Finally, fill the original bottom row with the color of the bottom-right corner of the input grid. 
:: def iecbjhdbagheeeefbdgecajbfbddfdda(I):
  h, w = shape(I) # Get height and width
  bottom_row_indices = asindices(crop(I, (h - 1, 0), (1, w))) # Indices of the bottom row
  shifted_grid = vconcat(I[:h-1], (I[h-1],)) # Duplicate the bottom row
  bottom_right_color = index(I, (h - 1, w - 1)) # Get color of bottom right cell
  O = fill(shifted_grid, bottom_right_color, bottom_row_indices) # Fill original bottom row with color
  return O
 
7.0, tensor(0.0075), Description: Copy the input grid. Then, move the bottom-most colored object down by one square. The bottom-most colored object should be in the same position as it was in the input grid, but one square lower. Finally, fill the bottom-right corner of the output grid with the same color as the bottom-most colored object in the input grid. 
:: def cgfdbcbffiageegbjdhefbbbegeaaffi(I):
  h, w = shape(I)  # Get height and width
  objs = objects(I, T, F, T) # Extract objects, excluding background
  bottom_obj = argmax(objs, lambda obj: lowermost(obj)) # Find bottom-most object
  shifted_obj = shift(bottom_obj, DOWN) # Shift object down
  O = paint(canvas(ZERO, (h, w)), shifted_obj) # Paint shifted object on a new canvas
  bottom_right_color = color(bottom_obj) # Get bottom right color
  O = fill(O, bottom_right_color, {(h-1, w-1)}) # Fill bottom right of output with original color
  return O
 
3.75, tensor(0.0065), Description: Copy the input grid. Then, duplicate the bottom row of the grid and append it to the bottom of the grid. Finally, fill the original bottom row with the color of the bottom-right corner of the input grid. 
:: def jdfaagfedhjfeccaajidefdfcebabaie(I):
  h, w = shape(I)  # Get height and width
  bottom_row = I[h-1] # Extract bottom row
  corner_color = bottom_row[-1]  # Get color of bottom right cell
  shifted_grid = vconcat(I[:h-1], (bottom_row,))  # Duplicate the bottom row
  O = fill(shifted_grid, corner_color, {(h - 1, i) for i in range(w)})  # Fill original bottom row with color
  return O
 
5.25, tensor(0.0962), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step up if its top edge is above the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def iieceiafhhhbebadjehbeeijjdcfiadb(I):
  objs = objects(I, F, T, T) # Extract all objects
  target_obj = min(objs, key=lambda o: colorcount(I, color(o))) # Find target object by minimum color count

  # Calculate vertical offset based on the object's uppermost row relative to grid center
  offset = 1 if uppermost(target_obj) < len(I) // 2 else -1

  O = paint(cover(I, target_obj), shift(target_obj, (offset, 0))) # Move and paint the object
  return O
 
5.5, tensor(0.0962), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step up if its top edge is above the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def ggabcehbbcgfefadbgfddbdefdgiceha(I):
  obj = argmin(objects(I, F, T, T), lambda obj: colorcount(I, color(obj)))  # Find the smallest object by color count
  
  # Determine movement direction: up if the object's top is above the middle row, else down
  direction = (-1, 0) if uppermost(obj) < len(I) // 2 else (1, 0)
  
  shifted_obj = shift(obj, direction) # Move the object
  O = paint(cover(I, obj), shifted_obj) # Paint the moved object onto a blank canvas
  return O
 
6.5, tensor(0.0077), Description: Copy the input grid. For each red shape, move it one square down and one square to the left. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def beddecdgafdfeeadacbcbffbbeehbabf(I):
  target_obj = extract(objects(I, T, T, T), lambda obj: color(obj) == 1)
  O = paint(canvas(mostcolor(I), shape(I)), shift(recolor(mostcolor(I), target_obj), (1, -1)))
  return O
 
7.25, tensor(0.0068), Description: Copy the input grid. For each red square, move it one square down and one square to the left. If the red square is on the bottom row or leftmost column, do not move it. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def jcedebcccfhbeaeeafhcccifbeedaech(I):
  def process_cell(i, j):
    return mostcolor(I) if I[i][j] == 1 else I[i][j]

  O = canvas(0, shape(I)) 
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if 0 <= i + 1 < len(I) and 0 <= j - 1 < len(I[0]):
        O = fill(O, process_cell(i, j), {(i + 1, j - 1)})
  return O
 
4.75, tensor(0.0263), Description: Find the smallest colored object and the largest colored object in the input grid. If there are an even number of colored objects, move the smallest object to the bottom-right corner of the largest object. Otherwise, move the smallest object to the bottom-left corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def dgjeaaaedcdaecedjfdbaebeccafccbg(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = lrcorner(l_obj) if even(len(objs)) else llcorner(l_obj)
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.0, tensor(0.0070), Description: Find the smallest colored object and the largest colored object in the input grid. If the largest object is a square, move the smallest object to the bottom-right corner of the largest object. Otherwise, if the largest object is taller than it is wide, move the smallest object to the bottom-left corner of the largest object. Otherwise, move the smallest object to the bottom-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def jbdccjabaachebcaicafcjfageabceac(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = branch(
      equality(height(l_obj), width(l_obj)),
      lrcorner(l_obj),
      branch(
          portrait(l_obj),
          llcorner(l_obj),
          lrcorner(l_obj)
      )
  )
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.25, tensor(0.0069), Description: Find the smallest colored object and the largest colored object in the input grid. If the color of the largest object is greater than the color of the smallest object, move the smallest object to the bottom-left corner of the largest object. Otherwise, move the smallest object to the bottom-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def bbbjeacfcfcieageifdeeficdajccfbe(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = branch(
      greater(color(l_obj), color(s_obj)),
      llcorner(l_obj),
      lrcorner(l_obj)
  )
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.75, tensor(0.0063), Description: Find the smallest colored object and the largest colored object in the input grid. If the upper-left corner of the smallest object is within the bounds of the largest object, move the smallest object to the bottom-right corner of the largest object. Otherwise, move the smallest object to the bottom-left corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def gfjjhjabfgfdefaabebbbjdbiejcbafe(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = branch(
      contained(ulcorner(s_obj), toindices(l_obj)),
      lrcorner(l_obj),
      llcorner(l_obj)
  )
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
5.25, tensor(0.0066), Description: Find the smallest colored object and the largest colored object in the input grid. If the width of the grid is even, move the smallest object one square to the right of the right edge of the largest object. Otherwise, move the smallest object one square to the left of the right edge of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def fbdeccdficcdeccaiabcibdjacgbcaff(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  h_offset = branch(even(width(I)), 1, -1) 
  target_loc = (lowermost(l_obj), rightmost(l_obj) + h_offset)
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
8.0, tensor(0.0051), Description: Copy the input grid. Then, for each row in the grid, shift the elements of that row one position to the right. The rightmost element of each row should be moved to the leftmost position.  The top row should be moved to the bottom of the grid. 
:: def dbbeceacccaaecgcigfcibehddjfajbb(I):
  h, w = shape(I)
  shifted_rows = []
  for i in range(h):
    shifted_row = [ZERO] * w 
    for j in range(w):
      new_j = (j + 1) % w # Circular shift right
      shifted_row[new_j] = I[i][j]
    shifted_rows.append(tuple(shifted_row))
  return tuple(shifted_rows[1:] + shifted_rows[:1]) # Shift rows up
 
7.25, tensor(0.0060), Description: Copy the input grid. Then, move the red shape to the position relative to the top-left corner of the grid that it occupied in the input grid. Keep the original colors of all objects. The background should be the most common color in the input grid. Finally, fill the corner cell that was originally part of the red shape with the background color. 
:: def fiecjcddjcddeebjbcebecfbbieiafhf(I):
  target_obj = extract(objects(I, T, T, T), lambda obj: color(obj) == 1) # Extract object of color 1
  shifted_obj = shift(target_obj, position(target_obj, {(0, 0)})) # Shift object based on its position relative to origin
  corner =  extract(corners(target_obj), lambda loc: index(I, loc) == 1) # Get the corner cell that was part of object '1'
  O = paint(fill(canvas(mostcolor(I), shape(I)), mostcolor(I), {corner}), shifted_obj) # Paint shifted object on a blank canvas, filling original corner with background color
  return O
 
4.0, tensor(0.0089), Description: Copy the input grid. Then, move the red shape one step in the direction that would bring it closer to the center of the grid. Keep the original colors of all objects. The background should remain black. Finally, fill the corner cell that was originally part of the red shape with the background color. 
:: def dfcfbccecabieafdijgdfeififbbheag(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))  # Using matcher for object extraction
  center_obj1 = centerofmass(obj1)
  shift_direction = crement(sign((center_obj1[0], center_obj1[1])))  # Using sign function for direction
  corner_to_clear = extract(corners(obj1), lambda c: equality(add(c, shift_direction), extract(toindices(shift(obj1, shift_direction)), lambda x: True)))  # Finding corner using equality after shift
  O = paint(fill(I, mostcolor(I), {corner_to_clear}), shift(obj1, shift_direction)) 
  return O
 
4.5, tensor(0.0075), Description: Copy the input grid. Then, move the red shape one step in the direction that would bring it closer to the top-left corner of the grid. Keep the original colors of all objects. The background should remain black. Finally, fill the corner cell that was originally part of the red shape with the background color. 
:: def hhcicecibdbaeachihdcfbadecfhjacf(I):
  for obj in objects(I, T, T, T):
    if color(obj) == 1:
      shifted_obj = shift(obj, crement(position(obj, {(0, 0)})))
      corner = extract(toindices(obj), lambda c: not contained(c, toindices(shifted_obj))) # Identify corner by exclusion
      return paint(fill(I, mostcolor(I), {corner}), shifted_obj)
  return I  # Return original grid if no object with color 1 is found
 
6.0, tensor(0.0081), Description: Copy the input grid. Then, move each red square down by one row. If a red square is on the bottom row, move it to the top row. Keep the original colors of all objects. The background should be the most common color in the input grid. 
:: def dfbfecfdabgeeaecacabfbeebbcebcea(I):
  one_indices = ofcolor(I, 1)
  shifted_indices = frozenset(((i + 1) % height(I), j) for i, j in one_indices)
  O = tuple(tuple(1 if (i, j) in shifted_indices else I[i][j] for j in range(width(I))) for i in range(height(I)))
  return O
 
7.5, tensor(0.0058), Description: Copy the input grid. Then, place the colored shapes in order of size, starting with the largest shape in the bottom-right corner and working your way up and to the left. The shapes should be placed so that they are touching each other, and the background should be the most common color in the input grid. 
:: def ehahhbhbjfcceieabfjhfecfadbcijcf(I):
  objs = objects(I, F, T, T)
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I)) 
  sorted_objs = order(objs, size)
  
  current_loc = (height(I), width(I))
  for obj in sorted_objs:
    O = paint(O, shift(obj, subtract(current_loc, lrcorner(obj))))
    current_loc = subtract(current_loc, (height(obj), width(obj))) 
  return O
 
6.75, tensor(0.0058), Description: Copy the input grid. Then, place the colored shapes in order of size, starting with the largest shape in the bottom-right corner and working your way up and to the left. The shapes should be placed so that they are touching each other, and the background should be the most common color in the input grid. 
:: def jfcghafccidhedccafffggjeeffecbea(I):
  objs = objects(I, F, T, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  objs = order(objs, lambda o: -size(o))
  
  if len(objs) == 0:
    return O
    
  loc = lrcorner(asindices(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(obj, subtract(loc, lrcorner(obj))))
    loc = subtract(loc, (height(objs[min(i + 1, len(objs) - 1)]), width(objs[min(i + 1, len(objs) - 1)])))
  return O
 
5.5, tensor(0.0062), Description: Copy the input grid. Then, place the colored shapes in order of size, starting with the largest shape in the bottom-right corner and working your way up and to the left. The shapes should be placed so that they are touching each other, and the background should be the most common color in the input grid. The order of placement should prioritize size, then the topmost row, then the leftmost column. 
:: def icighdidhcddecefjdebjfjgfbhadhec(I):
  objs = objects(I, F, T, T)
  bg_color = mostcolor(I)
  canvas_dims = shape(I)
  O = canvas(bg_color, canvas_dims)
  
  def obj_key(obj):
    return (size(obj), -uppermost(obj), -leftmost(obj))
  
  sorted_objs = order(objs, obj_key)
  
  current_loc = (canvas_dims[0], canvas_dims[1])
  
  for obj in sorted_objs:
    obj_dims = (height(obj), width(obj))
    target_loc = subtract(current_loc, obj_dims)
    O = paint(O, shift(obj, target_loc))
    current_loc = target_loc
  return O
 
6.75, tensor(0.0057), Description: Copy the input grid. Then, place the colored shapes in order of size, starting with the smallest shape in the bottom-right corner and working your way up and to the left. The shapes should be placed so that they are touching each other, and the background should be the most common color in the input grid. 
:: def bhbibgbdifcceecfadffbfdedefdedcc(I):
    objs = objects(I, F, T, T)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    
    for i in range(1, len(objs) + 1):
        obj = argmin(objs, lambda obj: (size(obj) if size(obj) < i else float('inf')))
        objs = remove(obj, objs)
        target = (height(I) - height(obj), width(I) - width(obj))
        O = paint(O, shift(obj, target))
    return O
 
7.25, tensor(0.0061), Description: Copy the input grid. Then, place the colored shapes in order of size, starting with the smallest shape in the bottom-right corner and working your way up and to the left. The shapes should be placed so that they are touching each other, and the background should be the most common color in the input grid. The order of placement should prioritize size, then the sum of row indices, then the sum of column indices. 
:: def ibbdcadcegeaeehejigdieadhajcgdad(I):
  objs = objects(I, False, True, True)
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I))

  sorted_objs = order(objs, lambda obj: (size(obj), -sum(i for i, j in toindices(obj)), -sum(j for i, j in toindices(obj))))

  current_pos = lrcorner(O)
  for obj in sorted_objs:
    target_pos = subtract(current_pos, (height(obj), width(obj)))
    O = paint(O, shift(obj, target_pos))
    current_pos = target_pos

  return O
 
3.75, tensor(0.0166), Description: Copy the input grid. Then, shift the rightmost column up by one position, filling the bottom cell of the column with black. The top row should remain unchanged. 
:: def fedbfgecidbdedbjjegbcddbfjdjeacf(I):
  h, w = shape(I) # height and width of grid
  right_col = tuple(I[i][w-1] for i in range(h)) # extract rightmost column
  shifted_col = (ZERO,) + right_col[:-1] # shift column up, fill bottom with 0
  O = vconcat(I[:h-1], (tuple(shifted_col[i] for i in range(w)),)) # replace bottom row
  return O
 
3.5, tensor(0.0166), Description: Copy the input grid. Then, shift the rightmost column up by one position, filling the bottom cell of the column with black. The top row should remain unchanged. 
:: def eefeccdfeecdejbjaifbbedaagdgidab(I):
  h, w = shape(I)
  last_col = tuple(I[i][w-1] for i in range(h)) # extract last column
  shifted_grid = vconcat(I[:h-1], ((ZERO,) * w,)) # shift up, fill bottom with zeros
  O = paint(shifted_grid, frozenset(((last_col[i], (i, w-1)) for i in range(h)))) # paint last column
  return O
 
4.0, tensor(0.0166), Description: Copy the input grid. Then, shift the rightmost column up by one position, filling the bottom cell of the column with black. The top row should remain unchanged. 
:: def ffabffhbfgaiefghbadfgcjgfbejdcfd(I):
  h, w = shape(I)
  O = vconcat(I[:h-1], ((ZERO,) * w,)) # remove last row, add zero row at bottom
  for i in range(h):
    O = fill(O, I[i][w-1], {(i - 1, w - 1)}) # shift rightmost column upwards
  return O
 
7.0, tensor(0.0104), Description: Copy the input grid. Then, for each cell in the grid, move the color of that cell down one row. The bottom row should remain unchanged. Then, paint the rightmost column of the grid with the colors from the original rightmost column. 
:: def befdeaagjbajedefigecfaaaecdebfdg(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w)) # create empty canvas
  for i in range(h-1):
    for j in range(w):
      O = fill(O, I[i][j], {(i+1, j)}) # shift each element down
  for i in range(h):
    O = fill(O, I[i][w-1], {(i, w-1)}) # paint rightmost column 
  return O
 
5.0, tensor(0.0110), Description: Copy the input grid. Then, move the red shape one step in the direction that would bring it closer to the center of the grid. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def hecbajhbfjaaebhcbbbeedbigeeifdfc(I):
  obj1 = extract(objects(I, T, T, T), lambda obj: color(obj) == 1) # Extract the object with color '1'
  if size(obj1) > 0: # Proceed only if object '1' exists
    direction = crement(position(obj1, {(len(I) // 2, len(I[0]) // 2)})) # Calculate movement direction relative to the center
    return paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, direction)) # Erase original, paint shifted object
  return I # Return original grid if object '1' not found
 
3.75, tensor(0.0110), Description: Copy the input grid. Then, move the red shape one step in the direction that would bring it closer to the center of the grid. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def jfacbhbbcbafeagfabefjbgiceddbdah(I):
  obj1 = next((obj for obj in objects(I, T, T, T) if color(obj) == 1), frozenset()) # Extract object '1'
  if obj1:
    center_i, center_j = len(I) // 2, len(I[0]) // 2 # Calculate center coordinates
    obj1_center_i, obj1_center_j = centerofmass(obj1) # Calculate object's center of mass
    direction = (sign(obj1_center_i - center_i), sign(obj1_center_j - center_j)) # Calculate direction
    return paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, direction)) # Erase and paint
  return I # Return original grid if no object '1'
 
4.25, tensor(0.0063), Description: Find the smallest colored object and the largest colored object in the input grid. If the upper-left corner of the smallest object is within the bounds of the largest object, move the smallest object to the bottom-right corner of the largest object. Otherwise, move the smallest object to the bottom-left corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def aahbcfiecfcaeifajdcacecedecadgha(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = branch(
      contained(ulcorner(s_obj), toindices(l_obj)),
      llcorner(l_obj),
      lrcorner(l_obj)
  )
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
5.0, tensor(0.0069), Description: Find the smallest colored object and the largest colored object in the input grid. If the smallest object's corners are not within the bounds of the largest object, move the smallest object to the bottom-right corner of the largest object. Otherwise, move the smallest object to the bottom-left corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def cadjchccdefceiccagcabhddhfgbejca(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, lambda o: len(o))
  l_obj = argmax(objs, lambda o: len(o))
  target_loc = lrcorner(l_obj) if not any(contained(c, toindices(l_obj)) for c in corners(s_obj)) else llcorner(l_obj)
  return move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
 
5.25, tensor(0.0047), Description: Copy the input grid. Then, for each row, move the rightmost element of that row to the leftmost position of the row above it. The rightmost element of the top row should be moved to the leftmost position of the bottom row. The background color should be the most common color in the input grid. 
:: def bjicffeheiibegbfafgiggacbgheefhg(I):
  h, w = shape(I)
  O = paint(canvas(mostcolor(I), (h, w)), asobject(I))  # initialize with background and paint input
  for i in range(h - 1):
    O = paint(O, {(I[i+1][w-1], (i, 0))}) # move elements from last column to first, shifted up
  return O
 
9.75, tensor(0.0136), Description: Copy the input grid. Then, rotate the grid 90 degrees clockwise. Replace the top row of the rotated grid with the most common color in the original grid. Finally, rotate the grid 270 degrees clockwise (back to the original orientation). 
:: def eadifcfefeejeeddbcjjcdaedbdehada(I):
  h, w = shape(I)
  O = rot90(I) # rotate 90 degrees clockwise
  O = vconcat(((mostcolor(I),) * w,), O[:h-1]) # replace top row with background
  O = rot270(O) # rotate back to original orientation
  return O
 
8.0, tensor(0.0044), Description: Copy the input grid. Then, shift the rightmost column to the leftmost position, moving each element up one row. The bottommost element of the rightmost column should be moved to the topmost position of the leftmost column. The background color should be the most common color in the input grid. 
:: def bbcdddggagacedbhjafabcddaigdffdj(I):
  h, w = shape(I)
  shifted_indices = frozenset(((i - 1) % h, 0) for i in range(h)) # generate indices for shifted column
  O = paint(canvas(mostcolor(I), (h, w)), {(I[i][w-1], (i, 0)) for i in range(h)}) # paint shifted last column
  O = paint(O, {(I[i][j], (i, j + 1)) for i in range(h) for j in range(w-1)}) # paint remaining elements
  return O
 
4.0, tensor(0.0073), Description: Copy the input grid. Then, move the red shape one step diagonally in the direction that would bring it closer to the center of the grid. If the red shape is above and to the left of the center, move it down and to the right. If the red shape is below and to the right of the center, move it up and to the left. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def hjahdffaichcefdeidbjcadfhddbhjaf(I):
  obj1 = next((obj for obj in objects(I, T, T, T) if color(obj) == 1), frozenset())
  if obj1:
    center_i = len(I) // 2
    obj1_center_i = centerofmass(obj1)[0] 
    direction = (1, 1) if obj1_center_i > center_i else (-1, -1)
    return paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, direction)) 
  return I 
 
5.5, tensor(0.0078), Description: Copy the input grid. For each red square, move it diagonally one step in the direction that would bring it closer to the center of the grid. If the red square is above and to the left of the center, move it down and to the right. If the red square is below and to the right of the center, move it up and to the left. Keep the original colors of all objects. The background should remain black. 
:: def fhagahijeheeeddcihdiaddigbddfiic(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        new_i = i + (1 if i < len(I) // 2 else -1)
        new_j = j + (1 if i < len(I) // 2 else -1)
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
          O = fill(O, 1, {(new_i, new_j)})
      else:
        O = fill(O, val, {(i, j)})
  return O
 
3.75, tensor(0.0076), Description: Copy the input grid. For each red square, move it diagonally one step in the direction that would bring it closer to the center of the grid. If the red square is above and to the left of the center, move it down and to the right. If the red square is below and to the right of the center, move it up and to the left. If the new position of the red square is outside the grid, replace it with the background color. Keep the original colors of all objects. The background should remain black. 
:: def cbidfcfadebeeegcicabdechdgiacdae(I):
  def move_cell(i, j):
    if I[i][j] != 1:
      return I[i][j]
    new_i = i + (1 if i < len(I) // 2 else -1)
    new_j = j + (1 if i < len(I) // 2 else -1)
    return 1 if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]) else mostcolor(I)
  return tuple(tuple(move_cell(i, j) for j in range(len(I[0]))) for i in range(len(I))) 
 
5.25, tensor(0.0135), Description: Copy the input grid. Then, shift the rightmost column down by one position, filling the top cell of the column with black. The bottom row should remain unchanged. 
:: def difdbaacefdbedffabfdefdccddabaed(I):
  shifted_grid = rot270(vsplit(rot90(I), height(I))[0])  # Extract rightmost column, shift down, rotate back
  O = paint(cover(I, ofcolor(I, 1)), recolor(1, asindices(shifted_grid))) # Clear '1's, paint shifted column
  return O 
 
5.75, tensor(0.0071), Description: Find the smallest colored object and the largest colored object in the input grid. If the color of the largest object is greater than the color of the smallest object, move the smallest object to the bottom-left corner of the largest object. Otherwise, move the smallest object to the top-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def bdfdahdfahccehjcbaiagcdibffefgcb(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_corner = branch(
      greater(color(l_obj), color(s_obj)),
      llcorner,
      urcorner
  )
  target_loc = target_corner(l_obj)
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.75, tensor(0.0071), Description: Find the smallest colored object and the largest colored object in the input grid. If the color of the largest object is greater than the color of the smallest object, move the smallest object to the bottom-left corner of the largest object. Otherwise, move the smallest object to the top-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def gcbeacjijaeeebacbdcigebbabafbibb(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  corner_functions = (llcorner, urcorner)
  target_corner = corner_functions[greater(color(l_obj), color(s_obj))]
  target_loc = target_corner(l_obj)
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.5, tensor(0.0090), Description: Copy the input grid. Then, shift the rightmost column up by one position, filling the bottom cell of the column with the most common color in the grid. The top row should remain unchanged. 
:: def afbffhgaadafeacbiiaaaeedbdcdadbb(I):
  h, w = shape(I)
  indices = asindices(I)
  last_col = frozenset((i, w-1) for i in range(h))
  shifted_col = shift(remove((h-1, w-1), last_col), (1, 0))
  O = paint(canvas(mostcolor(I), (h, w)), {(I[i][j], (i, j)) for i, j in indices if (i, j) not in last_col} | {(I[i][j], (i + 1, j)) for i, j in shifted_col})
  return O
 
4.5, tensor(0.0090), Description: Copy the input grid. Then, shift the rightmost column up by one position, filling the bottom cell of the column with the most common color in the grid. The top row should remain unchanged. 
:: def aacjjbbhichhecbdaaegfeicbacjfeef(I):
  h, w = shape(I)
  indices = asindices(I)
  last_col = frozenset(((i, w - 1) for i in range(h)))
  shifted_col = shift(last_col, (1, 0)) - {(h, w - 1)}
  O = paint(canvas(mostcolor(I), (h, w)), {(I[i][j], (i, j)) for i, j in indices - last_col} | {(I[i - 1][j], (i, j)) for i, j in shifted_col & indices})
  return O
 
4.5, tensor(0.0141), Description: Find the smallest colored object and the largest colored object in the input grid. If the smallest object is horizontally aligned with the largest object, move the smallest object one square to the right of the largest object. If the smallest object is vertically aligned with the largest object, move the smallest object one square below the largest object. If the smallest object is not aligned with the largest object, do not move it. Then, change the color of the smallest object to match the color of the largest object. Keep the original colors of all other objects. The background should remain black. 
:: def bjfajedajafaedheacbajaeabjfcdbdf(I):
  objs = objects(I, F, T, T) # Extract all objects from the input grid
  s_obj = argmin(objs, size) # Identify the smallest object 
  l_obj = argmax(objs, size) # Identify the largest object
  target_loc = add(lrcorner(l_obj), (1 if hmatching(s_obj, l_obj) else 0, 1 if vmatching(s_obj, l_obj) else 0))  # Calculate the target location based on object alignment
  moved_grid = move(I, s_obj, subtract(target_loc, lrcorner(s_obj))) # Move the smallest object to the target location
  O = paint(moved_grid, recolor(color(l_obj), s_obj)) # Recolor the moved object to match the largest object
  return O
 
4.75, tensor(0.0094), Description: Find the smallest colored object and the largest colored object in the input grid. If the smallest object is horizontally aligned with the largest object, move the smallest object one square to the right of the largest object. Otherwise, move the smallest object one square below the largest object. Keep the original colors of both objects. The background should remain black. 
:: def edacdbcfejihefeaadheahjjjfbebfee(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  offset = branch(hmatching(s_obj, l_obj), RIGHT, DOWN)  # Determine offset direction based on horizontal matching
  O = move(I, s_obj, add(lrcorner(l_obj), offset)) # Move using lrcorner and calculated offset
  return O
 
4.5, tensor(0.0199), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object one square to the right of the largest object. Then, change the color of the smallest object to match the color of the largest object. Keep the original colors of all other objects. The background should remain black. 
:: def cgdafeffgafdecdaadhfbjhjjcdccjaf(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = add(lrcorner(l_obj), (0, 1)) # Calculate target as one position right of lrcorner 
  O = paint(move(I, s_obj, subtract(target_loc, lrcorner(s_obj))), recolor(color(l_obj), s_obj))  # Move and recolor
  return O
 
6.0, tensor(0.0240), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object in the direction that would bring it closer to the largest object. Keep the original colors of both objects. The background should remain black. 
:: def ecadfjafaaideahgidafedhbgbcdbcee(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  g = gravitate(s_obj, l_obj)  # Calculate gravitation vector towards the largest object
  O = move(I, s_obj, g)  # Move the smallest object using the gravitation vector
  return O 
 
6.0, tensor(0.0045), Description: Copy the input grid. For each cell in the grid, if the cell is the same color as the bottom-right corner of the input grid, move that cell up one row. If the cell is in the bottom-left corner, move it to the leftmost empty space in the row above it. Otherwise, keep the cell in its original position. The background color should be the most common color in the input grid. 
:: def bbcabfhaebceedhfafggiedcbbdjcjha(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w)) # Initialize with background color
  for i in range(h):
    for j in range(w):
      if i == h - 1 and j == 0: # Bottom Left Corner
        target_j = 0 # Start at leftmost
        while target_j < w and O[h-2][target_j] != mostcolor(I): 
          target_j += 1
        O = fill(O, I[i][j], {(h-2, target_j)}) # Move to leftmost empty space
      elif I[i][j] == I[h-1][w-1]: # Match bottom right color
        O = fill(O, I[i][j], {(i-1, j)}) # Shift one row up 
      else:
        O = fill(O, I[i][j], {(i, j)}) # Keep other elements in place
  return O
 
4.25, tensor(0.0056), Description: Copy the input grid. Then, move the bottom-right value up one row and place it in the rightmost position of the second-to-last row. Then, find the leftmost empty space in the second-to-last row and fill it with the value of the bottom-left corner of the input grid. Keep all other cells unchanged. 
:: def ajdbccdeghfgegefacjgeadbdjbihgfd(I):
  h, w = shape(I)
  O = I # Start with the input grid
  bottom_left_val = I[h-1][0] 
  bottom_right_val = I[h-1][w-1]
  O = fill(O, mostcolor(I), {(h-1, 0)}) # Clear bottom left corner
  O = fill(O, bottom_right_val, {(h-2, w-1)}) # Move bottom right value up one row
  for j in range(w-1):
    if O[h-2][j] == mostcolor(I):
      O = fill(O, bottom_left_val, {(h-2, j)}) # Fill leftmost empty space with bottom left value
      break
  return O
 
3.75, tensor(0.0064), Description: Copy the input grid. For each object that has the same color as the bottom-right corner of the input grid, move that object up by one square. If the object is in the bottom-left corner, move it to the leftmost empty space in the row above it. Keep all other objects in their original positions. The background color should be the most common color in the input grid. 
:: def bficifbgcbfgececaffbdiffefieabgd(I):
  h, w = shape(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=False) # Extract objects
  bottom_right_color = I[h-1][w-1]
  O = canvas(mostcolor(I), (h, w)) # Create empty canvas
  for obj in objs:
    if color(obj) == bottom_right_color: # Match object color with bottom right
      O = paint(O, shift(obj, (-1, 0))) # Shift the entire object up
    else:
      O = paint(O, obj) # Paint other objects in original position
  bottom_left_obj = extract(objs, lambda obj: (h-1, 0) in toindices(obj)) # Get bottom left object
  O = paint(O, shift(bottom_left_obj, (0, -leftmost(bottom_left_obj)))) # Move bottom left object to the left
  return O
 
4.0, tensor(0.0045), Description: Copy the input grid. For each cell in the grid, if the cell is the same color as the bottom-right corner of the input grid, move that cell up one row. If the cell is in the bottom-left corner, move it to the leftmost empty space in the row above it. Otherwise, keep the cell in its original position. The background color should be the most common color in the input grid. 
:: def dbbeagdbfdabebjhbeecbidcajbiffgf(I):
  h, w = shape(I)
  bottom_right_val = I[h-1][w-1]
  
  def shift_up(row, row_index):
    return  tuple(bottom_right_val if v == bottom_right_val and row_index < h-1 else v for v in row)
  
  O = apply(lambda x: shift_up(*x), pair(I, range(h))) # Apply shift_up to each row
  
  bottom_left_val = I[h-1][0]
  empty_index = next((j for j, v in enumerate(O[h-2]) if v == mostcolor(I)), None)
  if empty_index is not None:
    O = fill(O, bottom_left_val, {(h-2, empty_index)}) # Place bottom left value
  
  return O
 
5.75, tensor(0.0108), Description: Copy the input grid. Then, shift the entire grid up by one row, filling the bottom row with the most common color in the grid. Then, for each cell in the grid, if the cell is not the same color as the bottom-right corner of the input grid, keep the cell in its original position. Otherwise, keep the cell in its original position. The background color should be the most common color in the input grid. 
:: def aiaaecbbfadiefabibdeaeidigcchbad(I):
  h, w = shape(I)
  shifted_grid = vconcat(I[1:], (tuple(mostcolor(I) for _ in range(w)),)) # Shift entire grid up
  mask = canvas(1, (h, w))
  mask = fill(mask, 0, {(h-1, 0)}) # Mark bottom left for no shift
  for i in range(h-1):
    for j in range(w):
      if I[i][j] != I[h-1][w-1]:
        mask = fill(mask, 0, {(i, j)})  # Mark non-matching elements for no shift
  O = cellwise(shifted_grid, I, mostcolor(I)) # Apply shift based on mask
  return O
 
4.0, tensor(0.1183), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step up if its center is above the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def ijcecibafaifeccjjgidiecagdiacfdg(I):
  # Find the object with the least common color
  target_obj = argmin(objects(I, F, T, T), lambda o: colorcount(I, color(o)))
  
  # Calculate the offset to move towards the center
  offset = crement(centerofmass(target_obj)[0] - (len(I) // 2))
  
  # Move the object and paint it on the canvas
  moved_obj = shift(target_obj, (offset, 0))
  O = paint(cover(I, target_obj), moved_obj)
  return O
 
4.75, tensor(0.0124), Description: For each red square in the input grid, find the closest blue square that is adjacent to it (sharing a side, not just a corner). Move the red square to the upper-left corner of the blue square. Keep the original colors of all objects. The background should remain black. 
:: def bcafiacefcdgeejijjbjbeedaiagaajh(I):
  # 1. Identify '1' and '2' Objects
  one_objects = colorfilter(objects(I, univalued=True, diagonal=False, without_bg=False), 1)
  two_objects = colorfilter(objects(I, univalued=True, diagonal=False, without_bg=False), 2)
  
  # 2. Find Target Locations for each '1' object
  target_locations = {}
  for one_obj in one_objects:
    for two_obj in two_objects:
      if adjacent(one_obj, two_obj):
        target_locations[one_obj] = ulcorner(two_obj)
  
  # 3. Move '1' Objects
  O = I
  for one_obj, target in target_locations.items():
    O = cover(O, one_obj)
    O = paint(O, shift(one_obj, subtract(target, ulcorner(one_obj))))
  return O
 
4.75, tensor(0.0124), Description: For each red square in the input grid, find the closest blue square that is adjacent to it (sharing a side, not just a corner). Move the red square to the upper-left corner of the blue square. Keep the original colors of all objects. The background should remain black. 
:: def aigaeebeieidedaaajeddafaibfdafcb(I):
  O = I
  one_indices = ofcolor(I, 1)
  for i, j in one_indices:
    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
      ni, nj = i + di, j + dj
      if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 2:
        target = next((x, y) for x, row in enumerate(I) for y, v in enumerate(row) if v == 2 and abs(x - i) + abs(y - j) == 1)
        O = cover(O, {(1, (i, j))})
        O = paint(O, {(1, target)})
        break
  return O
 
4.25, tensor(0.0124), Description: For each red square in the input grid, find the closest blue square that is adjacent to it (sharing a side, not just a corner). Move the red square to the upper-left corner of the blue square. Keep the original colors of all objects. The background should remain black. 
:: def aiabijheecbgejbfajibdhheeaebcfff(I):
  def find_target(i, j):
    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
      ni, nj = i + di, j + dj
      if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 2:
        return (ni, nj)
    return (i, j)

  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 1:
        target_i, target_j = find_target(i, j)
        O = paint(O, {(1, (target_i, target_j))})
      else:
        O = paint(O, {(v, (i, j))})
  return O
 
5.5, tensor(0.0106), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object to the right so that its right edge aligns with the right edge of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def bibheideffbbeedhjcbdeegbcbbaccii(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  target_loc = add(llcorner(l_obj), (0, width(l_obj)))  # Target is to the right of the largest object
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))  # Move the smallest object to the target location
  return O
 
5.5, tensor(0.0057), Description: Find the smallest colored object and the largest colored object in the input grid. If the largest object is taller than it is wide, move the smallest object one square to the right and one square down from the bottom-right corner of the largest object. Otherwise, move the smallest object one square to the right of the bottom-right corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def gaahhfddaaafegehiaedhcfccddihaaj(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  offset = (1, 1) if portrait(l_obj) else (0, 1) # Determine offset based on largest object's orientation
  target_loc = add(lrcorner(l_obj), offset)
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.0, tensor(0.0064), Description: Find the smallest colored object and the largest colored object in the input grid. If the vertical distance between the top edges of the smallest and largest objects is less than or equal to half the height of the largest object, move the smallest object to the bottom-right corner of the largest object. Otherwise, move the smallest object to the bottom-left corner of the largest object. Keep the original colors of both objects. The background should remain black. 
:: def gbcdfabbccfceieejcejajcffcbbiece(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  v_dist = abs(uppermost(s_obj) - uppermost(l_obj)) # Calculate vertical distance
  target_loc = branch(
      v_dist <= height(l_obj) // 2,
      lrcorner(l_obj),
      llcorner(l_obj)
  ) # Choose target corner based on vertical distance
  O = move(I, s_obj, subtract(target_loc, lrcorner(s_obj)))
  return O
 
4.5, tensor(0.0195), Description: Find the colored object with the least number of occurrences in the input grid. Move that object one step to the left if its center is to the left of the grid's center, otherwise move it one step to the right. Keep the original colors of all objects. The background should remain black. 
:: def deagafbgagdfebbjabhjafeafeabbcfi(I):
  # Find the object with the least color count
  objs = objects(I, F, T, T)
  obj = min(objs, key=lambda o: colorcount(o, leastcolor(I)))
  
  # Calculate offset based on center of mass relative to grid center
  obj_center = centerofmass(obj)
  grid_center = (len(I) // 2, len(I[0]) // 2)
  offset = -1 if obj_center[0] < grid_center[0] else 1

  # Move the object
  moved_obj = shift(obj, (offset, 0))
  O = paint(cover(I, obj), moved_obj)
  return O
 
3.5, tensor(0.0289), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. Move the red shape one step in the direction that would bring it closer to the closest non-red shape. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def aaidebddbijcehbejgccdceigifdbcbb(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  other_objs = objects(I, T, T, T) - {obj1}
  closest_obj = argmin(other_objs, lambda obj: manhattan(obj, obj1))
  direction = gravitate(obj1, closest_obj)
  shifted_obj1 = shift(obj1, direction)
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shifted_obj1)
  return O
 
4.25, tensor(0.0208), Description: Copy the input grid. Then, move the red shape one step in the direction that would bring it closer to the closest non-red shape. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def cfgeaedaehfceefcbcbdfaibajddcbef(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  bg = mostcolor(I)
  shifted_obj1 = shift(obj1, crement(position(obj1, extract(objects(I, T, T, T)-{obj1}, lambda x: True))))
  O = paint(fill(I, bg, toindices(obj1)), shifted_obj1)
  return O
 
4.0, tensor(0.0162), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. If the closest shape is blue, move the red shape one step towards the upper-left corner of the blue shape. If the closest shape is not blue, move the red shape one step towards the lower-right corner of the closest shape. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def eghaacfgcdffefabacaaidccbabbbjaf(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  other_obj = first(objects(I, T, T, T) - {obj1})
  target_loc =  ulcorner(other_obj) if color(other_obj) == 2 else lrcorner(other_obj)
  direction = crement(subtract(target_loc, centerofmass(obj1)))
  shifted_obj1 = shift(obj1, direction)
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shifted_obj1)
  return O
 
4.0, tensor(0.0088), Description: Copy the input grid. Then, move the red shape one step down if its center is to the left of the grid's center, otherwise move it one step to the right. If the red shape is on the bottom row, move it to the top row. If the red shape is on the rightmost column, move it to the leftmost column. Keep the original colors of all objects. The background should remain black. 
:: def bcdjdafgejidejfdabjhjcijfdicfjfb(I):
  # Extract the object made of '1's
  one_obj = first(colorfilter(objects(I, T, F, F), 1))
  
  # Determine movement direction based on object's center position
  center_j = centerofmass(one_obj)[1]
  direction = DOWN if center_j < width(I) // 2 else RIGHT 
  
  # Calculate the shifted position (wrapping around)
  new_pos = add(ulcorner(one_obj), direction)
  new_pos = (new_pos[0] % height(I), new_pos[1] % width(I))
  
  # Shift the object
  shifted_obj = shift(one_obj, new_pos)
  
  # Remove the original object and paint the shifted object 
  O = paint(cover(I, one_obj), shifted_obj)
  return O
 
8.25, tensor(0.0092), Description: If the red shape is in the right half of the grid, move it to the left half. If the red shape is in the left half of the grid, move it to the right half. If the red shape is in the top half of the grid, move it to the bottom half. If the red shape is in the bottom half of the grid, move it to the top half. Keep the original colors of all objects. The background should remain black. 
:: def jebcebeejgdeejafbicdbidbiabbcged(I):
  # Determine split direction based on grid dimensions
  split_direction = vsplit if height(I) > width(I) else hsplit
  
  # Split the grid into two halves
  half1, half2 = split_direction(I, 2)
  
  # Find which half contains the '1' object
  one_obj_in_half1 = any(1 in row for row in half1)
  
  # Swap halves if '1' object is in the second half
  if not one_obj_in_half1:
    half1, half2 = half2, half1 
  
  # Recombine the halves, effectively shifting the '1' object
  O = vconcat(half2, half1) if split_direction == vsplit else hconcat(half2, half1)
  return O
 
5.75, tensor(0.0182), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object in the direction that would bring it closer to the largest object. If the smallest object would move outside the grid, adjust its movement so that it stays within the grid boundaries. Keep the original colors of both objects. The background should remain black. 
:: def feffedgaedbaejhejbdbbcigbedfahaa(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  g = gravitate(s_obj, l_obj)
  target = add(centerofmass(s_obj), g) 
  border_adjustment = branch(
      contained(target, l_obj), 
      (0, 0),
      branch(
          equality(target[0], uppermost(l_obj) - 1),
          (1, 0),
          branch(
              equality(target[0], lowermost(l_obj) + 1),
              (-1, 0),
              branch(
                  equality(target[1], leftmost(l_obj) - 1),
                  (0, 1),
                  (0, -1)
              )
          )
      )
  )
  O = move(I, s_obj, add(g, border_adjustment))
  return O
 
4.5, tensor(0.0123), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object one step to the right if the horizontal distance between their centers is greater than the vertical distance. Otherwise, move the smallest object one step up if the vertical distance is greater. Keep the original colors of both objects. The background should remain black. 
:: def adaadgcagafgeijebgejdceagicgffcf(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  h_diff = subtract(centerofmass(l_obj), centerofmass(s_obj))[0]
  v_diff = subtract(centerofmass(l_obj), centerofmass(s_obj))[1]
  offset = branch(
      greater(abs(h_diff), abs(v_diff)),
      (sign(h_diff), 0),
      (0, sign(v_diff))
  )
  target = add(centerofmass(s_obj), offset)
  O = move(I, s_obj, offset)
  return O
 
6.0, tensor(0.0123), Description: Find the smallest colored object and the largest colored object in the input grid. Move the smallest object one step to the right if the horizontal distance between their centers is greater than the vertical distance. Otherwise, move the smallest object one step up if the vertical distance is greater. Keep the original colors of both objects. The background should remain black. 
:: def jdegfbiaafheeefdjfcdddbdabdfdbda(I):
  objs = objects(I, F, T, T)
  s_obj = argmin(objs, size)
  l_obj = argmax(objs, size)
  h_dist = abs(subtract(centerofmass(s_obj)[1], centerofmass(l_obj)[1])) 
  v_dist = abs(subtract(centerofmass(s_obj)[0], centerofmass(l_obj)[0])) 
  direction = branch(
     h_dist > v_dist, 
     (0, 1) if centerofmass(s_obj)[1] < centerofmass(l_obj)[1] else (0, -1),
     (1, 0) if centerofmass(s_obj)[0] < centerofmass(l_obj)[0] else (-1, 0)
  )
  O = move(I, s_obj, direction)
  return O
 
4.25, tensor(0.0555), Description: Find the smallest colored object in the input grid. Move that object vertically so that its top edge aligns with the top edge of the first empty cell in the same column. Keep the original colors of all objects. The background should remain black. 
:: def jegcbdfbecceebgebgadbbefeifjheac(I):
  bg = mostcolor(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  target = argmin(objs, size)
  target_col = ulcorner(target)[1]
  empty_cells = sfilter(asindices(I), lambda loc: index(I, loc) == bg and loc[1] == target_col)
  destination = argmin(empty_cells, lambda loc: loc[0])
  return paint(fill(I, bg, toindices(target)), shift(target, subtract(destination, ulcorner(target))))
 
5.75, tensor(0.0165), Description: Find the smallest colored object in the input grid. Move that object one step up if its top edge is above the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def bjgjbefacheeefidbdcecfaegffbfeej(I):
  # Partition the grid into objects, excluding background
  objs = fgpartition(I)

  # Find the smallest object by size (number of cells)
  target_obj = min(objs, key=len)

  # Calculate the offset based on object's uppermost row
  offset = -1 if uppermost(target_obj) >= len(I) // 2 else 1

  # Move the object and paint it
  moved_obj = shift(target_obj, (offset, 0))
  O = paint(cover(I, target_obj), moved_obj)
  return O
 
5.75, tensor(0.0154), Description: Find the colored object whose center is closest to the vertical center of the grid. Move that object one step up if its center is below the grid's center, otherwise move it one step down. Keep the original colors of all objects. The background should remain black. 
:: def becfacfhedcbeecfjebabhdbfafifdab(I):
  # Create a function to calculate vertical distance from center
  dist_from_center = lambda obj: abs(centerofmass(obj)[0] - len(I) // 2)

  # Find the object closest to the vertical center
  target_obj = argmin(objects(I, F, T, T), dist_from_center)

  # Determine movement direction based on object's center position
  offset = -1 if centerofmass(target_obj)[0] >= len(I) // 2 else 1

  # Move the object and paint it
  moved_obj = shift(target_obj, (offset, 0))
  O = paint(cover(I, target_obj), moved_obj)
  return O
 
4.5, tensor(0.0289), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. Move the red shape one step in the direction that would bring it closer to the closest non-red shape. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def fccfdgddgfebeebbjacfefcbccfffede(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1)) 
  other_objs = objects(I, T, T, T) - {obj1}
  closest_obj = argmin(other_objs, lambda obj: manhattan(obj1, obj))
  direction = crement(sign(subtract(centerofmass(closest_obj), centerofmass(obj1))))
  shifted_obj1 = shift(obj1, direction)
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shifted_obj1)
  return O
 
4.0, tensor(0.0075), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. If the closest shape is vertically aligned with the red shape, move the red shape one step above the closest shape. Otherwise, move the red shape one step to the left of the closest shape if the closest shape is to the right of the red shape, and one step to the right of the closest shape if the closest shape is to the left of the red shape. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def agcbcbdbejieebdjidjeacaabadacjei(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  other_objs = objects(I, T, T, T) - {obj1}
  closest_obj = argmin(other_objs, lambda obj: manhattan(obj1, obj))
  target_location =  branch(
      vmatching(obj1, closest_obj),
      (uppermost(closest_obj) - 1, leftmost(obj1)), # Move above
      (uppermost(obj1), leftmost(closest_obj) - sign(subtract(leftmost(closest_obj), leftmost(obj1)))) # Move beside
  )
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, subtract(target_location, ulcorner(obj1)))) 
  return O
 
5.25, tensor(0.0225), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. Move the red shape one step in the direction that would bring it closer to the closest non-red shape. If there are multiple possible moves that result in the same distance, choose the move that brings the red shape closest to the center of the grid. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def accicbfeffdceagbijfceadhacacbcbc(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  other_objs = objects(I, T, T, T) - {obj1}
  closest_distances = apply(lambda obj: manhattan(obj1, obj), other_objs) 
  closest_distance = minimum(closest_distances)
  possible_moves = sfilter(product((-1, 0, 1), (-1, 0, 1)), lambda d: manhattan(shift(obj1, d), obj1) == closest_distance)
  best_move = argmin(possible_moves, lambda d: minimum(apply(lambda obj: manhattan(shift(obj1, d), obj), other_objs)))
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, best_move))
  return O
 
4.5, tensor(0.0275), Description: Copy the input grid. Find the red shape and the closest shape to it that is not red. If the red shape can move one step in any direction (horizontally, vertically, or diagonally) to become adjacent to the closest non-red shape, move the red shape one step in that direction. If there are multiple possible moves, choose the first one in the list of possible moves. Keep the original colors of all objects. The background should remain black. Finally, fill the cells that were originally part of the red shape with the background color. 
:: def gfgabcgccedbedgiabhcidahhfbbccfc(I):
  obj1 = extract(objects(I, T, T, T), matcher(color, 1))
  other_objs = objects(I, T, T, T) - {obj1}
  def is_valid_move(direction):
    return any(adjacent(shift(obj1, direction), obj) for obj in other_objs)
  possible_moves = sfilter(((0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)), is_valid_move)
  best_move = branch(possible_moves, first(possible_moves), (0, 0)) # If no valid move, don't move
  O = paint(fill(I, mostcolor(I), toindices(obj1)), shift(obj1, best_move))
  return O
 
