52.0, tensor(0.0120), Description: Extend the colored objects to the left and right edges of the grid, using the same color as the object. The extension should stop when it encounters a non-background color. 
:: def edbeefbdhbefeiefbgeedddgffeehfbc(I):
  objs = objects(I, True, False, True) # Identify objects excluding background
  bg = mostcolor(I)
  h = height(I)
  w = width(I)
  O = I
  for obj in objs:
    leftmost_j = leftmost(obj)
    rightmost_j = rightmost(obj)
    for j in range(leftmost_j - 1, -1, -1): # Extend left
      if index(I, (uppermost(obj), j)) != bg:
        break
      O = fill(O, color(obj), {(uppermost(obj), j)})
    for j in range(rightmost_j + 1, w): # Extend right
      if index(I, (uppermost(obj), j)) != bg:
        break
      O = fill(O, color(obj), {(uppermost(obj), j)})
  return O
 
50.666666666666664, tensor(0.0066), Description: Extend the colored objects to the right and left, using the same color as the object. The extension should stop when it encounters a non-background color. If there is a background color to the left of the object, extend the object to the left as well. 
:: def bcafaefjfgbdeccbaaeccdbgdafcjebe(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  O = I
  for obj in objs:
    for i, j in toindices(obj):
      for dj in range(1, width(I)):
        if index(I, (i, j + dj)) != bg: break
        O = fill(O, color(obj), {(i, j + dj)})
        if j - dj >= 0 and index(I, (i, j - dj)) == bg:
          O = fill(O, color(obj), {(i, j - dj)})
  return O
 
57.666666666666664, tensor(0.0124), Description: Extend each colored object horizontally to the left and right edges of the grid, using the same color as the object. The extension should stop when it encounters a non-background color. 
:: def dcdbabcjfgcgebdcbidfadabggaaaigf(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I)) # Initialize with background
  for obj in objs:
    O = paint(O, obj) # Paint original objects
    for (i, j) in toindices(obj):
      left = connect((i, j), (i, 0)) # Horizontal line to the left
      right = connect((i, j), (i, width(I) - 1)) # Horizontal line to the right
      O = underfill(O, color(obj), left) # Fill left with object color
      O = underfill(O, color(obj), right) # Fill right with object color
  return O
 
61.333333333333336, tensor(0.0092), Description: Extend each colored object horizontally to the left and right edges of the grid, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def dadbddcbabcdeaddabffdafiagfffaag(I):
  O = I
  for i in range(height(I)):
    row_objs = objects(crop(I, (i, 0), (1, width(I))), True, False, True) # Objects in each row
    for obj in row_objs:
      leftmost_j = leftmost(obj)
      rightmost_j = rightmost(obj)
      for j in range(leftmost_j - 1, -1, -1):
        if index(I, (i, j)) != mostcolor(I): break
        O = fill(O, color(obj), {(i, j)})
      for j in range(rightmost_j + 1, width(I)):
        if index(I, (i, j)) != mostcolor(I): break
        O = fill(O, color(obj), {(i, j)})
  return O
 
10.0, tensor(0.0255), Description: For each color in the input grid, if the color has more than one pixel, draw a line connecting the top-left corner to the bottom-right corner of the color's area, using the same color. 
:: def bcbbhecbejedeaebjgjbicfffibceacj(I):
    O = I
    for v in palette(I):
        x1 = ofcolor(I, v)  # Find indices of the current color
        x2 = size(x1)
        if x2 > 1:
            x3 = ulcorner(x1) 
            x4 = lrcorner(x1)
            O = fill(O, v, connect(x3, x4))
    return O
 
6.666666666666667, tensor(0.0264), Description: For each colored object in the input grid, if the object has more than one pixel, draw a line connecting the top-left corner to the bottom-right corner of the object's area, using the same color. The line should be drawn in the order of the cells within the object, starting from the top-left corner and moving to the bottom-right corner. 
:: def ebcjcccdcgedeacdigcjbaafagceebcj(I):
    O = I
    for obj in objects(I, T, F, T):
        if size(obj) > 1:
            x1 = lambda x: x[1][0]  # Key function for sorting by row
            x2 = order(obj, x1)  # Order object cells by row
            x3 = lambda x: x[1][1]  # Key function for sorting by column
            x4 = order(x2, x3)  # Order object cells by column
            x5 = first(x4)
            x6 = last(x4)
            O = fill(O, color(obj), connect(x5[1], x6[1]))
    return O
 
37.333333333333336, tensor(0.5344), Description: Find the largest object in the input grid. Normalize its position and then apply all five transformations (identity, horizontal mirror, vertical mirror, diagonal mirror, and center mirror) to the normalized object. Shift each transformed object by multiples of 2 in both the horizontal and vertical directions to create a 3x3 grid of transformed objects. Paint all the transformed objects onto the original input grid. The output grid will contain the original input grid with the largest object repeated in a 3x3 grid with all five transformations applied. 
:: def jafjigaabjeiedeebgdgfbaafbhbedgg(I):
    obj = argmax(objects(I, F, T, T), size)  # Find largest object
    normed_obj = normalize(obj)              # Normalize its position
    
    transformations = (identity, hmirror, vmirror, dmirror, cmirror) 
    
    transformed_objs = [shift(transform(normed_obj), (i * 2, j * 2))  
                        for i in range(3) for j in range(3) 
                        for transform in transformations]
    
    O = I                                    # Start with the input grid
    for transformed_obj in transformed_objs:
        O = paint(O, transformed_obj)       # Paint each transformed object
    return O
 
6.666666666666667, tensor(0.0092), Description: Find the largest object in the input grid and its color. Then, identify all other objects in the grid that have the same color as the largest object. For each of these smaller objects, move them to the location where they would be if they were moved to the closest point on the larger shape. The smaller shapes should be touching the larger shape. 
:: def hbgicbedcficeffjjjaifghghacfeedi(I):
    largest_obj = argmax(objects(I, F, T, T), size) 
    color_to_replicate = color(largest_obj)
    
    def condition(x): return color(x) == color_to_replicate and x != largest_obj
    
    smaller_objs = sfilter(objects(I, F, T, T), condition)
    
    O = I
    for small_obj in smaller_objs:
        direction = gravitate(small_obj, largest_obj)
        O = paint(O, shift(small_obj, direction))
    return O
 
29.333333333333332, tensor(1.9412), Description: Find the largest object in the input grid. Normalize its position and then upscale it by factors of 1, 2, and 3. Shift each upscaled object by a specific offset to create a pattern of increasing size. Paint all the upscaled objects onto the original input grid. The output grid will contain the original input grid with the largest object repeated in a pattern of increasing size. 
:: def aecgbdicjgcfebbeagaeecfgddfjadfd(I):
    obj = argmax(objects(I, F, T, T), size)
    normed_obj = normalize(obj)
    
    upscaled_objs = [upscale(normed_obj, factor) for factor in range(1, 4)]
    
    offsets = ((0, 0), (2, 2), (-2, -2)) # Example offsets for illustration
    
    O = I
    for upscaled_obj, offset in zip(upscaled_objs, offsets):
        O = paint(O, shift(upscaled_obj, offset)) 
    return O
 
12.333333333333334, tensor(0.0060), Description: Find the largest object in the input grid. Replicate this object by placing copies of it one square to the left, right, above, and below the original object. The output grid will contain the original input grid with the largest object repeated in a cross pattern around its original position. 
:: def fbeiiajgajceeacabbjgiefhgdcjidca(I):
    obj = argmax(objects(I, F, T, T), size)
    
    def replicate_around(grid, obj):
        offsets = ((-1, 0), (1, 0), (0, -1), (0, 1))
        for offset in offsets:
            grid = paint(grid, shift(obj, offset))
        return grid
    
    O = replicate_around(I, obj)
    return O 
 
86.66666666666667, tensor(0.0104), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def effdfcbefcdeeihjicaficabibdbhegf(grid):
  objs = objects(grid, T, F, T)
  bg = mostcolor(grid)
  new_grid = canvas(bg, shape(grid))
  for obj in objs:
    leftmost_j = leftmost(obj)
    for i in range(height(grid)):
      for j in range(leftmost_j, width(grid)):
        if (i, j) in toindices(obj) or index(new_grid, (i, j)) != bg:
          break
        new_grid = fill(new_grid, color(obj), {(i, j)})
  return new_grid 
 
37.333333333333336, tensor(0.0236), Description: Extend each colored object horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def fhdgbjidbdaeeidcjjihighgfeiafeae(grid):
  return paint(grid, merge({extend_right(grid, obj) for obj in objects(grid, T, F, T)}))
 
6.666666666666667, tensor(0.0189), Description: Extend each colored object horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def abfdceacjafdeccabhbbfjadbhhdcica(I):
    objs = objects(I, True, False, False)
    new_objs = set()
    for obj in objs:
        ul = ulcorner(obj)
        right_extension = frozenset((color(obj), (ul[0], j)) for j in range(ul[1], width(I)))
        new_objs.add(obj | intersection(right_extension, delta(obj)))
    O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
    return O
 
13.333333333333334, tensor(0.0342), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def befbbacgeeddebhcabbibgaibbbijhcc(I):
  O = I
  for j in range(width(I) - 1):
    for i in range(height(I)):
      if index(I, (i, j + 1)) == mostcolor(I) and index(I, (i, j)) != mostcolor(I):
        O = fill(O, index(O, (i, j)), {(i, j + 1)})
  return O
 
39.0, tensor(0.0342), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def bgfiahbdabdgeciejcfbjfadagigdcfc(I):
    O = I
    for i in range(height(I)):
        current_color = None
        for j in range(width(I)):
            if index(I, (i, j)) != mostcolor(I) and current_color is None:
                current_color = index(I, (i, j))
            if current_color is not None:
                O = fill(O, current_color, {(i, j)})
    return O
 
22.333333333333332, tensor(0.0228), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def baffjjdgcbcbedbiicfdeaacabjieddi(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    for i in range(height(obj)):
      start_j = leftmost(shift(obj, (i, 0)))
      O = fill(O, color(obj), {(i + uppermost(obj), j) for j in range(start_j, width(I))})
  return O
 
9.0, tensor(0.0243), Description: For each color in the input grid (excluding the background color), if the color has more than one pixel, draw a line connecting the top-left corner to the bottom-right corner of the color's area, using the same color. 
:: def fddchadagadieccjbfdhibceefdjdche(I):
  O = I
  for v in palette(I) - {mostcolor(I)}: # Iterate through colors, excluding background
    indices = ofcolor(I, v)  # Get indices of cells with current color
    if size(indices) > 1:
      O = fill(O, v, connect(ulcorner(indices), lrcorner(indices))) # Connect extremes
  return O
 
12.666666666666666, tensor(0.1581), Description: Find the largest object in the input grid and its color. If there are two objects of that color, extend the largest object horizontally across the grid, using the same color. If there is only one object of that color, extend it either horizontally or vertically across the grid, depending on whether its width or height is greater. The extension should stop when it encounters a non-background color. 
:: def ebefecfdcdeeebebbagigdcaafidcjbe(I):
    obj = argmax(objects(I, F, T, T), size)  # Find largest object
    color = first(palette(obj))
    occurrences =  ofcolor(I, color)
    O = I
    if len(occurrences) == 2:
      direction = (sign(occurrences.pop()[0] - occurrences.pop()[0]), 0)
      for i in range(1,10):
        O = paint(O, recolor(color, shift(obj, multiply(i,direction))))
    else:
      if width(obj) > height(obj):
        direction = (0,1)
      else:
        direction = (1,0)
      for i in range(1,10):
        O = paint(O, recolor(color, shift(obj, multiply(i,direction))))
    return O
 
16.666666666666668, tensor(0.0349), Description: For each colored object in the input grid, if the object has more than one pixel, extend it in the direction of the second pixel from the first pixel, using the same color. The extension should stop when it encounters a non-background color. 
:: def efdefaeiddicecifbeiegdffhdcebcjf(I):
    objs = objects(I, F, T, T) 
    O = I
    for obj in objs:
        if len(obj) > 1:
          direction = position(obj, remove(first(obj),obj))
          for i in range(1,10):
            O = paint(O, recolor(first(palette(obj)), shift(obj, multiply(i,direction))))
    return O
 
17.333333333333332, tensor(0.0351), Description: For each colored object in the input grid, if the object has more than one pixel, extend it in the direction of its greater dimension (either horizontally or vertically), using the same color. The extension should stop when it encounters a non-background color. If the object has only one pixel, paint it onto the output grid as is. 
:: def gfddijejebfjefjdabfgjddijbjccbbc(I):
    objs = objects(I, F, T, T) 
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        c = first(palette(obj))
        locs = toindices(obj)
        if len(locs) > 1:
          i_coords = [i for i, j in locs]
          j_coords = [j for i, j in locs]
          if max(i_coords) - min(i_coords) > max(j_coords) - min(j_coords):
            direction = (1, 0)
          else:
            direction = (0, 1)
          for i in range(1,10):
            O = paint(O, recolor(c, shift(obj, multiply(i,direction))))
        else:
          O = paint(O, obj)
    return O
 
9.333333333333334, tensor(0.1238), Description: For each colored object in the input grid, if the object has more than one pixel, extend it horizontally or vertically, using the same color. The extension should stop when it encounters a non-background color. The extension direction is determined by the object's periodicity: if the object repeats horizontally, extend it vertically; if it repeats vertically, extend it horizontally. 
:: def egfcffadjadgegicbfedddbffddajace(I):
  objs = objects(I, F, T, T)
  O = I
  for obj in objs:
    if len(obj) > 1:
      normalized = normalize(obj)
      h_period = hperiod(normalized)
      v_period = vperiod(normalized)
      if h_period < width(obj):
        O = paint(O, recolor(first(palette(obj)), shift(obj, (0, h_period))))
      if v_period < height(obj):
        O = paint(O, recolor(first(palette(obj)), shift(obj, (v_period, 0))))
  return O
 
51.0, tensor(0.0064), Description: For each colored object in the input grid, replicate the object by shifting it one square in every direction (up, down, left, right) within the grid. The replication should only occur where the background color is present, effectively extending the object's pattern across the grid. 
:: def affeidhdjjdhejjcbdediachjfdhdbea(I):
    objs = objects(I, F, T, T)  # Identify all objects in the input grid
    O = I                       # Initialize the output grid with the input grid
    for obj in objs:
        color = first(palette(obj))  # Get the color of the current object
        for i in range(1,8):
          for j in range(1,8):
            O = underfill(O, color, shift(obj, (i, j)))  # Fill the shifted object with its color only where the background color is present
    return O 
 
38.0, tensor(0.0104), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def bdjfjacabicdechdbbabcghgfhahgbii(I):
    objs = objects(I, T, F, T)  # Identify all objects
    bg = mostcolor(I)  # Determine background color
    filled_grid = I  # Initialize filled grid
    for obj in objs:
        leftmost_j = leftmost(obj)
        for i in range(height(I)):
            for j in range(leftmost_j, width(I)):
                if (i, j) in toindices(obj):  # Extend object rightwards
                    filled_grid = fill(filled_grid, index(I, (i, j)), {(i, k) for k in range(j, width(I))})
                elif index(filled_grid, (i, j)) == bg:  # Stop at other objects
                    break
    O = filled_grid
    return O
 
39.0, tensor(0.0149), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def cficbgaacfjjecgcbighccejaejacjah(I):
    O = I
    for j in range(width(I) - 1):
        for i in range(height(I)):
            if index(O, (i, j)) != mostcolor(I) and index(O, (i, j + 1)) == mostcolor(I): # Check for object edge
                O = fill(O, index(O, (i, j)), {(i, k) for k in range(j + 1, width(I))}) # Fill to the right
    return O
 
6.666666666666667, tensor(0.0119), Description: For each colored object in the input grid, shift the object horizontally to the right by one square for each column in the grid. Paint the shifted objects onto a new grid initialized with the background color. The output grid will contain a series of horizontally shifted copies of each colored object, creating a repeating pattern. 
:: def ccdadcddbgjjefdejebefgbihcdbcigc(I):
    shifted_grid = canvas(mostcolor(I), shape(I)) # Create empty canvas
    for obj in objects(I, T, F, T):
        for x in range(width(I)):
            shifted_object = shift(obj, (0, x)) # Shift object to the right
            shifted_grid = paint(shifted_grid, toobject(shifted_object, I)) # Paint shifted object onto canvas
    O = shifted_grid
    return O
 
38.0, tensor(0.0185), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def bjaeaahebgefecccabhbicddbbaddjcf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    for (v, (i, j)) in obj:
      O = fill(O, v, connect((i, j), (i, width(I) - 1)))
  return O
 
37.333333333333336, tensor(0.0342), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def fagchjaidfggeeebbiddbjdacdahchbh(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if index(O, (i, j)) != mostcolor(I) and index(O, (i, j + 1)) == mostcolor(I):
        O = fill(O, index(O, (i, j)), {(i, j + 1)})
  return O
 
8.666666666666666, tensor(0.0254), Description: For each colored object in the input grid, draw a horizontal line connecting the leftmost cell of the object to the rightmost cell of the object, using the same color as the object. The line should be drawn on a new grid initialized with the background color. 
:: def gfdcicffedibehcjbffachaafedcgfcc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    start = (uppermost(obj), leftmost(obj))
    end = (start[0], rightmost(obj))
    O = fill(O, color(obj), connect(start, end))
  return O
 
7.0, tensor(0.0107), Description: For each color in the input grid (excluding the most common color), if there are multiple objects of that color, connect the center of mass of the first object to the center of mass of the closest other object of the same color, using the same color. The output grid will contain the original input grid with lines connecting the centers of mass of objects of the same color. 
:: def iebeejebbcbaegfciahcbfefabcjfaie(I):
  for v in palette(I) - {mostcommon(I)}:
    objs = colorfilter(objects(I, False, False, True), v)
    if len(objs) > 1:
      obj1 = first(objs)
      rest_objs = objs - {obj1}
      closest_obj = argmin(rest_objs, lambda x: manhattan(obj1, x))
      I = paint(
        I,
        recolor(
          v,
          connect(centerofmass(obj1), centerofmass(closest_obj))
        )
      )
  O = I
  return O
 
9.0, tensor(1.1016), Description: For each colored object in the input grid, if the object has more than one pixel, draw a vertical line upwards from the lower-left corner of the object, using the same color. The line should stop when it encounters a non-background color. 
:: def fcfjbfdfcafaeaccidaegcdaeffjafdd(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      ll = llcorner(obj)  # Lower-left corner
      O = fill(O, color(obj), connect(ll, (0, ll[1]))) # Vertical line upwards
  return O
 
7.0, tensor(0.7304), Description: For each colored object in the input grid, if the object has more than one pixel, draw a vertical line upwards from the lower-left corner of the object, using the same color. The line should stop when it encounters a non-background color or the top of the grid. 
:: def dgajjfehcjfhedaiifbgcdfecifeejee(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      ll = llcorner(obj) 
      line = connect(ll, (0, ll[1]))
      for (i, j) in line:
        if i >= 0 and index(O, (i, j)) == mostcolor(I): # Stop if top is reached or another object
          O = fill(O, color(obj), {(i, j)})
        else: 
          break
  return O
 
18.333333333333332, tensor(0.0213), Description: For each colored object in the input grid, if the object has more than one pixel, extend it diagonally down and to the right, using the same color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def fcjbaifcfdfeegieicgigcdddjhfbfcd(I):
  objs = objects(I, F, T, T)
  O = I
  for obj in objs:
    if len(obj) > 1:
      for i in range(1,10):
        O = paint(O, recolor(first(palette(obj)), shift(obj, multiply(i, (1,1)))))
  return O
 
23.666666666666668, tensor(0.0244), Description: For each colored cell in the input grid, draw a diagonal line from that cell to the bottom-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all colored cells in the grid. 
:: def jahfjciaccehebifjiciccijhecdaafg(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i,j)) != mostcommon(I):
        for k in range(1, 10):
          if 0 <= i+k < len(I) and 0 <= j+k < len(I[0]):
            O = paint(O, {(index(I,(i,j)),(i+k, j+k))})
  return O
 
21.666666666666668, tensor(0.0244), Description: For each colored cell in the input grid, draw a diagonal line from that cell to the bottom-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all colored cells in the grid. 
:: def ecjbfbaadbehehdhifjfcgidccdajbab(I):
  O = I
  for i, j in asindices(I):
    if index(I, (i,j)) != mostcommon(I):
      k = 1
      while 0 <= i+k < len(I) and 0 <= j+k < len(I[0]):
        O = paint(O, {(index(I, (i,j)), (i+k, j+k))})
        k += 1
  return O
 
17.666666666666668, tensor(0.0104), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def bcgiiabhaejfeeddjjhefahiddbeggdb(grid):
  objs = objects(grid, T, F, T)  # Extract objects, excluding background
  bg = mostcolor(grid) # Identify background color
  new_grid = canvas(bg, shape(grid)) # Create an empty canvas filled with background color
  for obj in objs:
    for (i, j) in toindices(obj): # Iterate over each cell of the object
      for k in range(j, width(grid)): # Extend horizontally to the right
        if index(grid, (i, k)) != bg: # Stop if encountering another object
          break
        new_grid = fill(new_grid, color(obj), {(i, k)}) # Fill the cell on the new grid
  return new_grid
 
80.0, tensor(0.0104), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def bbibjbaihjcdefidjfadcfjeeebbjbjb(grid):
  objs = objects(grid, T, F, T)
  bg = mostcolor(grid)
  new_grid = canvas(bg, shape(grid))
  for obj in objs:
    leftmost_j = leftmost(obj) # Find the leftmost column index of the object
    for i in range(height(grid)):
      for j in range(leftmost_j, width(grid)):
        if index(grid, (i, j)) != bg: # Check for non-background cells (similar to Program B)
          break
        new_grid = fill(new_grid, color(obj), {(i, j)}) # Fill horizontally (similar to Program A)
  return new_grid
 
47.666666666666664, tensor(0.0374), Description: For each row in the grid, if a cell is the background color, the cell above it is not the background color, and the cell to its right is the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right, starting from a non-background cell that is directly below a background cell, until they encounter another non-background color. 
:: def ibbcicfecijeefcdacggcbbjjgjhichc(I):
  O = I
  for i in range(1, height(I)):
    for j in range(width(I) - 1):
      if index(O, (i, j)) == mostcolor(I) and index(O, (i - 1, j)) != mostcolor(I) and index(O, (i, j + 1)) == mostcolor(I):
        O = fill(O, index(O, (i - 1, j)), {(i, k) for k in range(j + 1, width(O))})
  return O
 
28.0, tensor(0.0269), Description: For each column in the grid, if a cell is the background color and the cell above it is not the background color, fill the current cell with the same color as the cell above it. This effectively extends colored cells downwards until they encounter another non-background color. 
:: def bdjcbbcdhefdejdbajddacccbghcjagg(I):
  O = I
  for j in range(width(I)):
    for i in range(1, height(I)):
      if index(O, (i - 1, j)) != mostcolor(I) and index(O, (i, j)) == mostcolor(I):
        O = fill(O, index(O, (i - 1, j)), {(i, j)})
        i += 1
  return O
 
66.66666666666667, tensor(0.0367), Description: For each row in the grid, if a cell is the background color and the cell above it is not the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right, starting from a non-background cell that is directly below a background cell, until they encounter another non-background color. 
:: def debbedgcaeacebcjiedefjbaifffffec(I):
  O = I
  for i in range(1, height(I)):
    for j in range(width(I)):
      if index(O, (i, j)) == mostcolor(I) and index(O, (i - 1, j)) != mostcolor(I):
        k = j
        while k < width(I) and index(O, (i, k)) == mostcolor(I):
          O = fill(O, index(O, (i - 1, j)), {(i, k)})
          k += 1
  return O
 
12.0, tensor(0.0096), Description: For each colored object in the input grid, if there is another object of the same color that is either horizontally or vertically aligned with it, connect the centers of these two objects with a line of the same color. The output grid will contain the original input grid with lines connecting the centers of objects of the same color that are horizontally or vertically aligned. 
:: def ijaccecacfffeibfbiebgabebjbihccf(I):
  objs = objects(I, False, False, True)
  for obj in objs:
    for other in objs - {obj}:
      if color(obj) == color(other):
        if hmatching(obj, other):
          I = paint(I, recolor(color(obj), connect(center(obj), center(other))))
        elif vmatching(obj, other):
          I = paint(I, recolor(color(obj), connect(center(obj), center(other))))
  O = I
  return O
 
10.0, tensor(0.0107), Description: For each color in the input grid (excluding the most common color), if there are multiple objects of that color, connect the center of mass of the first object to the center of mass of the closest other object of the same color, using the same color. The output grid will contain the original input grid with lines connecting the centers of mass of objects of the same color. 
:: def dagieejddfheeccciadcgebfhbgefabj(I):
  for color_val in palette(I) - {mostcommon(I)}:
    objs = colorfilter(objects(I, False, False, True), color_val)
    while size(objs) > 1:
      obj1 = first(objs)
      objs = objs - {obj1}
      closest_obj = argmin(objs, lambda x: manhattan(obj1, x))
      if hmatching(obj1, closest_obj):
        I = paint(I, recolor(color_val, connect(center(obj1), center(closest_obj))))
      elif vmatching(obj1, closest_obj):
        I = paint(I, recolor(color_val, connect(center(obj1), center(closest_obj))))
  O = I
  return O
 
9.666666666666666, tensor(0.0096), Description: For each colored object in the input grid, if there is another object of the same color that is either horizontally or vertically aligned with it, connect the centers of these two objects with a line of the same color. The output grid will contain the original input grid with lines connecting the centers of objects of the same color that are horizontally or vertically aligned. 
:: def ebfggfbccddaeadeidfheiccidddbcbh(I):
  for obj in objects(I, False, False, True):
    target = None
    min_dist = float('inf')
    for other in objects(I, False, False, True):
      if obj != other and color(obj) == color(other):
        dist = manhattan(obj, other)
        if dist < min_dist:
          min_dist = dist
          target = other
    if target is not None:
      if hmatching(obj, target):
        I = paint(I, recolor(color(obj), connect(center(obj), center(target))))
      elif vmatching(obj, target):
        I = paint(I, recolor(color(obj), connect(center(obj), center(target))))
  O = I
  return O
 
9.666666666666666, tensor(0.0107), Description: For each color in the input grid (excluding the most common color), if there are multiple objects of that color, connect the center of mass of the first object to the center of mass of the closest other object of the same color, using the same color. The output grid will contain the original input grid with lines connecting the centers of mass of objects of the same color. 
:: def edifffhbadgcebiaafbjcbaecjaijdcf(I):
  for c in palette(I) - {mostcommon(I)}:
    obj_list = sorted(objects(I, False, False, True), key=lambda x: center(x)[0] * 100 + center(x)[1])
    while len(obj_list) > 1:
      obj1 = obj_list.pop(0)
      closest_obj = min(obj_list, key=lambda x: manhattan(obj1, x))
      if hmatching(obj1, closest_obj):
        I = paint(I, recolor(c, connect(center(obj1), center(closest_obj))))
      elif vmatching(obj1, closest_obj):
        I = paint(I, recolor(c, connect(center(obj1), center(closest_obj))))
  O = I
  return O
 
19.333333333333332, tensor(0.0156), Description: For each colored cell in the input grid, draw a diagonal line from that cell to the bottom-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all colored cells in the grid. 
:: def fibbajccaaaieccbahefeagecfcddjjh(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      v = index(I, (i, j))
      if v != mostcolor(I):
        diag = connect((i,j), (lrcorner(ofcolor(I, v))))
        O = fill(O, v, diag)
  return O
 
12.333333333333334, tensor(0.0119), Description: For each colored cell in the input grid, extend it horizontally to the left, using the same color. The extension should stop when it encounters a non-background color. This is done for all colored cells in the grid. The extension is performed on a diagonally mirrored version of the grid, and then the result is mirrored back to produce the final output. 
:: def ifbegecaagfiedghjbdcedaachaeicdc(grid):
  dgrid = dmirror(grid)  # Mirror diagonally
  for j in range(width(dgrid) - 1, 0, -1): # Iterate columns from right to left
    for i in range(height(dgrid)): # Iterate rows
      current_val = index(dgrid, (i, j)) 
      right_val = index(dgrid, (i, j - 1)) # Check value to the right (original grid's top-right)
      if current_val != mostcolor(dgrid) and right_val != mostcolor(dgrid): # If both cells are part of an object
        dgrid = fill(dgrid, current_val, {(i, k) for k in range(j)}) # Extend current object to the left
  return dmirror(dgrid) # Mirror back
 
28.666666666666668, tensor(0.0183), Description: For each row in the grid, if a cell is the background color and the cell diagonally above and to the right is not the background color, fill the current cell with the same color as the cell diagonally above and to the right. This effectively extends colored cells diagonally downwards and to the left until they encounter another non-background color. 
:: def gbfdebfcbjjeegdgibifhcidedahcajj(grid):
  for _ in range(width(grid)): # Loop for potential maximum extension
    for i in range(1, height(grid)): # Iterate rows from top to bottom
      for j in range(width(grid) - 1): # Iterate columns from left to right
        if index(grid, (i, j)) == mostcolor(grid) and index(grid, (i - 1, j + 1)) != mostcolor(grid): # Check for diagonal extension opportunity
          grid = fill(grid, index(grid, (i - 1, j + 1)), {(i, j)}) # Extend diagonally
  return grid
 
25.333333333333332, tensor(0.0109), Description: For each colored cell in the input grid, draw a diagonal line from that cell to the top-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all colored cells in the grid. The extension is performed by iterating rows from bottom to top and columns from left to right, checking if the diagonal cell is valid and a background color. If so, the diagonal cell is filled with the same color as the current cell. 
:: def eiecejadgffcefebbbdbbbhjfhaadffj(grid):
  for i in range(height(grid) - 1, 0, -1): # Iterate rows from bottom to top
    for j in range(width(grid)): # Iterate columns
      if index(grid, (i, j)) != mostcolor(grid): # If current cell is part of an object
        k = 1 
        while i - k >= 0 and j + k < width(grid) and index(grid, (i - k, j + k)) == mostcolor(grid): # While diagonal cell is valid and background
          grid = fill(grid, index(grid, (i, j)), {(i - k, j + k)}) # Extend object diagonally
          k += 1
  return grid
 
30.666666666666668, tensor(0.0342), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def bfacdeagebffefgfaagdbcdgjedibdde(I):
  O = I
  for i in range(height(I)):
    current_color = None
    for j in range(width(I)):
      if index(O, (i, j)) != mostcolor(I) and current_color is None:
        current_color = index(O, (i, j))
      elif current_color is not None and index(O, (i, j)) == mostcolor(I):
        O = fill(O, current_color, {(i, j)})
      else:
        current_color = None
  return O
 
10.666666666666666, tensor(0.0253), Description: For each colored object in the input grid, if there is another object of the same color that is either horizontally or vertically aligned with it and the distance between them is greater than 1, connect the centers of these two objects with a line of the same color. The output grid will contain the original input grid with lines connecting the centers of objects of the same color that are horizontally or vertically aligned and are more than one square apart. 
:: def bcdefdbeffbfeicfbbhdahgedjcjcjfe(I):
  objs = objects(I, False, False, True)
  for obj in objs:
    for other in objs:
      if obj != other and color(obj) == color(other):
        if hmatching(obj, other) and manhattan(obj, other) > 1:
          direction = (0, sign(leftmost(other) - leftmost(obj)))
          I = paint(cover(I, obj), shift(obj, direction))
        elif vmatching(obj, other) and manhattan(obj, other) > 1:
          direction = (sign(uppermost(other) - uppermost(obj)), 0)
          I = paint(cover(I, obj), shift(obj, direction))
  O = I
  return O
 
8.666666666666666, tensor(0.0095), Description: For each colored object in the input grid, move it one step closer to the nearest object of the same color. This process is repeated until no further movement is possible. The output grid will contain the original input grid with all objects of the same color clustered together. 
:: def cbdhhfgagffeedejjedgdajcaabgaedj(I):
  def gravitate_towards(obj, target):
    if hmatching(obj, target):
      direction = (0, sign(leftmost(target) - leftmost(obj)))
    elif vmatching(obj, target):
      direction = (sign(uppermost(target) - uppermost(obj)), 0)
    else:
      direction = (0, 0)
    return shift(obj, direction)

  objs = objects(I, False, False, True)
  for _ in range(max(width(I), height(I))):
    for obj in objs:
      same_color_objs = colorfilter(objs, color(obj)) - {obj}
      if same_color_objs:
        closest = min(same_color_objs, key=lambda x: manhattan(obj, x))
        I = paint(cover(I, obj), gravitate_towards(obj, closest))
  O = I
  return O
 
8.0, tensor(0.1669), Description: For each colored object in the input grid, extend it in a specific direction based on its most common color. If the most common color is 1 (light blue), extend the object downwards. If the most common color is 3 (yellow), extend the object to the right. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def hacddfjgedeheiggbhbaiffdccjiebed(I):
    O = I  # Start with the input grid
    for obj in objects(I, False, True, True):
        if mostcolor(obj) == 1:
          direction = DOWN
        elif mostcolor(obj) == 3:
          direction = RIGHT
        else:
          continue
        for (v, (i, j)) in obj:
          O = paint(O, {(v, (i + k * direction[0], j + k * direction[1])) for k in range(1,width(obj)) if 0 <= i + k * direction[0] < height(I) and 0 <= j + k * direction[1] < width(I) and I[i + k * direction[0]][j + k * direction[1]] == 0})
    return O
 
19.333333333333332, tensor(0.6465), Description: For each colored object in the input grid, if it contains light blue (color 1), extend it vertically downwards, using light blue. If it contains yellow (color 3), extend it horizontally to the right, using yellow. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def fgdijfcbaaeceadeibefhcehbdbaacgi(I):
    O = I
    for obj in objects(I, False, True, True):
        if colorcount(obj, 1) > 0:
          for (v, (i, j)) in obj:
            O = paint(O, {(1, (k, j)) for k in range(i + 1, len(I)) if I[k][j] == 0})
        elif colorcount(obj, 3) > 0:
          for (v, (i, j)) in obj:
            O = paint(O, {(3, (i, k)) for k in range(j + 1, len(I[0])) if I[i][k] == 0})
    return O
 
36.333333333333336, tensor(0.0169), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def dfaecfcdffacejefjjchbbaadcccbibc(grid):
  objs = objects(grid, T, F, T)  # Identify all objects in the grid
  extended_objs = frozenset({extend_right(grid, obj) for obj in objs}) # Extend each object to the right
  O = paint(canvas(mostcolor(grid), shape(grid)), merge(extended_objs))  # Paint the extended objects onto a blank canvas
  return O
 
30.666666666666668, tensor(0.0202), Description: For each colored object in the input grid, extend it to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def iaadjbfceeefeebgjdhfajbjjifdfhjf(grid):
  return paint(grid, merge(apply(rbind(extend_obj_frontier, grid), objects(grid, T, F, T))))
 
13.333333333333334, tensor(0.0167), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def icgaadebdgbfebiibdgihgadjbhafijg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    O = paint(O, obj)
    for (i, j) in toindices(obj):
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) != mostcolor(I):
          break
        O = fill(O, color(obj), {(i, k)})
  return O
 
16.0, tensor(0.0303), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. The extension should only occur if the cell to the right of the object is a background color. 
:: def dcfabiabadcaejccajfcfdedgdadabeb(I):
  O = I
  for obj in objects(I, True, False, False):
    min_j = leftmost(obj)
    max_j = rightmost(obj)
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(min_j, width(I)):
        if index(I, (i, j)) != mostcolor(I) and j > max_j:
          break
        if j >= min_j and j <= max_j:
          O = fill(O, color(obj), {(i, j)})
        else:
          if index(I, (i, j)) != mostcolor(I):
            break
  return O
 
18.333333333333332, tensor(0.0907), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. 
:: def abchddhdhdcfebefjbjhgjefaedgfghf(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    for (i, j) in toindices(obj):
      k = j + 1
      while k < width(I) and index(I, (i, k)) == mostcolor(I):
        O = fill(O, color(obj), {(i, k)})
        k += 1
  return O
 
10.333333333333334, tensor(0.0107), Description: For each color in the input grid (excluding the most common color), if there are multiple objects of that color, connect the center of mass of the first object to the center of mass of the closest other object of the same color, using the same color. The output grid will contain the original input grid with lines connecting the centers of mass of objects of the same color. 
:: def hffeeceeddcjeafbiefgiffecdbifeai(I):
  for c in palette(I) - {mostcommon(I)}:
    for obj1 in objects(I, False, False, True):
      if color(obj1) == c:
        closest_dist = float('inf')
        closest_obj = None
        for obj2 in objects(I, False, False, True):
          if obj1 != obj2 and color(obj2) == c:
            dist = manhattan(obj1, obj2)
            if dist < closest_dist:
              closest_dist = dist
              closest_obj = obj2
        if closest_obj is not None:
          I = paint(I, recolor(c, connect(center(obj1), center(closest_obj))))
  O = I
  return O
 
8.0, tensor(0.0200), Description: For each row in the input grid, if a cell has a color and the cell below it has the same color, extend the color to the right until a non-background color is encountered. This effectively creates horizontal lines of the same color, extending downwards from the original colored cells. 
:: def ieifegaagihdefecaaehfbcbaedcbfac(I):
    O = I  # Initialize the output grid
    for v in palette(I):  # Iterate over each color in the input
        for i in range(len(I) - 1):  # Iterate over rows (except the last one)
            for j in range(len(I[0])):  # Iterate over columns
                if I[i][j] == v and I[i + 1][j] == v:  # Check if current and below cell have the same color
                    k = j + 1  # Start from the cell to the right
                    while k < len(I[0]) and I[i][k] == 0:  # Extend right until a non-zero cell or edge is encountered
                        O = fill(O, v, {(i, k)})  # Fill the cell with the current color
                        k += 1
    return O
 
9.0, tensor(0.0200), Description: For each row in the input grid, if a cell has a color and the cell below it has the same color, extend the color to the right until a non-background color is encountered. This effectively creates horizontal lines of the same color, extending downwards from the original colored cells. 
:: def bafjfchejiecebadjdeadcfbffaaddae(I):
    O = I
    for i in range(len(I) - 1):
        for j in range(len(I[0])):
            if I[i][j] != 0 and I[i][j] == I[i + 1][j]:  # Matching colors vertically
                O = fill(O, I[i][j], connect((i, j), (i, len(I[0]) - 1)))  # Fill rightward from current cell
    return O
 
16.666666666666668, tensor(0.0228), Description: For each row in the input grid, if a cell has the same color as the cell above it, fill the entire row with that color. This effectively creates horizontal stripes of the same color, extending downwards from the original colored cells. 
:: def bbhaiedifffbebhdjegahfgcaaadgjhc(I):
    O = I
    for i in range(1, len(I)):
        for j in range(len(I[0])):
            if I[i][j] == I[i - 1][j]:  # Check for same color above
                O = fill(O, I[i][j], hfrontier((i, j)))  # Fill the entire row with that color
    return O
 
18.333333333333332, tensor(0.7179), Description: For each colored object in the input grid, if the most common color in the object is light blue (color 1), extend the object vertically downwards, using light blue. If the most common color is yellow (color 3), extend the object horizontally to the right, using yellow. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def bejhehbaafaheeibafafbhifddadcafa(I):
  O = I
  for obj in objects(I, False, True, True):
    ul = ulcorner(obj)
    lr = lrcorner(obj)
    if mostcolor(obj) == 1:
      O = paint(O, recolor(1, {(i, lr[1]) for i in range(ul[0], height(I))}))
    elif mostcolor(obj) == 3:
      O = paint(O, recolor(3, {(lr[0], j) for j in range(ul[1], width(I))}))
  return O
 
46.0, tensor(0.0169), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def iibbaddacjhdejibicicaeabfbcifeih(grid):
  return paint(canvas(mostcolor(grid), shape(grid)),
               merge({extend_obj(grid, obj) for obj in objects(grid, T, F, T)}))
 
31.333333333333332, tensor(0.0122), Description: Description: For each colored cell in the input grid, extend it horizontally to the left, using the same color. The extension should stop when it encounters a non-background color. This is done for all colored cells in the grid. The extension is performed on a diagonally mirrored version of the grid, and then the result is mirrored back to produce the final output. 
:: def baeagdgcdfaaebdbabfbfbadiifdadbj(grid):
  return dmirror(extend_grid(dmirror(grid)))
 
22.666666666666668, tensor(0.0354), Description: For each row in the input grid, identify all colored objects in that row. For each object, paint it onto the output grid at the same row position. Then, extend the object horizontally to the right, using the same color, until it encounters a non-background color. This effectively creates horizontal lines of the same color, extending to the right edge of the grid from the original colored cells in each row. 
:: def caeegcdbjejjefceibcgdgggjgfecjef(I):
    O = canvas(mostcolor(I), shape(I))
    for i in range(height(I)):
        for obj in objects(crop(I, (i, 0), (1, width(I))), True, False, False):
            O = paint(O, shift(obj, (i, 0)))
            rightmost_cell = rightmost(obj)
            O = fill(O, color(obj), {(i, j) for j in range(rightmost_cell + 1, width(I))})
    return O
 
31.666666666666668, tensor(0.0356), Description: For each row in the grid, if a cell is not the background color, fill the cells to the left of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the left until they encounter another non-background color. This is done for all rows in the grid. 
:: def gbbgcficcgfhebfijihbifiiacaaicfb(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I) - 1, -1, -1):
            if index(O, (i, j)) != mostcolor(I):
                fill_color = index(O, (i, j))
                O = fill(O, fill_color, {(i, k) for k in range(j, -1, -1) if index(O, (i, k)) == mostcolor(I)})
                break
    return O
 
7.666666666666667, tensor(0.0221), Description: For each color in the input grid (excluding the background color), if there are multiple objects of that color, connect the leftmost cell of the first object to the leftmost cell of the closest other object of the same color, using the same color. The output grid will contain the original input grid with lines connecting the leftmost cells of objects of the same color. 
:: def gbfahfgacjibebddabhhchcgbfafhiej(I):
    O = I
    for v in palette(I) - {mostcolor(I)}:
        for (i, j) in ofcolor(I, v):
            for k in range(j + 1, width(I)):
                if index(I, (i, k)) == v:
                    O = fill(O, v, connect((i, j), (i, k)))
                    break
    return O
 
15.666666666666666, tensor(0.7179), Description: For each colored object in the input grid, if the most common color in the object is light blue (color 1), extend the object vertically downwards, using light blue. If the most common color is yellow (color 3), extend the object horizontally to the right, using yellow. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def cabbbaddcfgjehhcajabdfdebbgbgeeh(I):
  O = I 
  for obj in objects(I, False, True, True):
    c = mostcolor(obj)
    if c == 1:
      O = underfill(O, c, {(i, leftmost(obj)) for i in range(uppermost(obj), height(I))}) # Fill downwards
    elif c == 3:
      O = underfill(O, c, {(uppermost(obj), j) for j in range(leftmost(obj), width(I))}) # Fill rightwards
  return O
 
37.333333333333336, tensor(0.0104), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. 
:: def ddiicjddccbaejacieggbbbjffjafdcg(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = I
  for obj in objs:
    for i in range(height(I)):
      for j in range(width(I)):
        if index(I, (i,j)) == color(obj):
          O = fill(O, color(obj), {(i, k) for k in range(j, width(I)) if index(I, (i, k)) == bg})
  return O
 
39.0, tensor(0.0154), Description: For each row in the grid, if a cell is not the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def hadcefjddjfgebbfbgheabdfjgieaabg(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)-1,-1,-1):
      if index(I, (i, j)) != mostcolor(I):
        O = fill(O, index(I, (i, j)), {(i, k) for k in range(j, width(I))})
        break
  return O
 
36.666666666666664, tensor(0.1055), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. 
:: def fbcdfcfeajfheedeifedddfeiefgegec(I):
  O = I
  for obj in objects(I, T, F, T):
    rightmost_cell = argmax(obj, lambda cell: cell[1][1])
    rightmost_j = rightmost_cell[1][1]
    O = fill(O, color(obj), {(rightmost_cell[1][0], j) for j in range(rightmost_j, width(I))})
  return O
 
39.0, tensor(0.0148), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def aeaeffcbfbadeaafjfifcfbfdaecffaa(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)-1):
      if index(I, (i, j)) != mostcolor(I) and index(I, (i, j+1)) == mostcolor(I):
        O = fill(O, index(I, (i, j)), {(i, k) for k in range(j+1, width(I))})
  return O
 
60.333333333333336, tensor(0.0303), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. The extension should only occur if the cell to the right of the object is a background color. 
:: def bjhgeajfbciaecafbjbafffchcifcffe(I):
  O = I
  for obj in objects(I, True, False, False):
    min_row, min_col = ulcorner(obj)
    max_row, max_col = lrcorner(obj)
    for i in range(min_row, height(I)):
      for j in range(min_col, width(I)):
        if (i, j) not in toindices(obj) and index(I, (i, j)) == mostcolor(I):
          O = fill(O, color(obj), {(i, j)})
        else:
          break
  return O
 
62.0, tensor(0.0078), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell both to the left and right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. 
:: def idffbgfegcdiediejabdgffggbhbidbg(I):
  O = I
  bg = mostcolor(I)
  for i in range(height(I)):
    for j in range(width(I)):
      if index(O, (i, j)) != bg:
        current_color = index(O, (i, j))
        # Extend left
        k = j - 1
        while k >= 0 and index(O, (i, k)) == bg:
          O = fill(O, current_color, {(i, k)})
          k -= 1
        # Extend right
        k = j + 1
        while k < width(I) and index(O, (i, k)) == bg:
          O = fill(O, current_color, {(i, k)})
          k += 1
  return O 
 
10.666666666666666, tensor(0.0218), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def hdicajgfabbbehiaagdcciaafaeaafbd(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    uppermost_i = uppermost(obj)
    leftmost_j = leftmost(obj)
    rightmost_j = rightmost(obj)
    for j in range(width(I)):
      if leftmost_j <= j <= rightmost_j or index(I, (uppermost_i, j)) != bg:
        O = fill(O, color(obj), {(uppermost_i, j)})
  return O
 
9.0, tensor(0.0097), Description: For each row in the grid, identify the first and last non-background color cells. Fill all cells between these two cells (inclusive) with the same color. This effectively creates horizontal lines of the same color, extending from the first non-background cell to the last non-background cell in each row. 
:: def fgbdbedabcfcefecigbcbbbcjadjdacg(I):
  O = I
  bg = mostcolor(I)
  for i in range(height(I)):
    start_j = -1
    end_j = -1
    current_color = bg
    for j in range(width(I)):
      if index(I, (i, j)) != bg:
        current_color = index(I, (i, j))
        if start_j == -1:
          start_j = j
        end_j = j
    if start_j != -1:
      O = fill(O, current_color, {(i, j) for j in range(start_j, end_j + 1)})
  return O
 
31.666666666666668, tensor(0.0072), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell to the left until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. 
:: def biiabeachabdegehafgjffdefffedebf(I):
  O = I
  bg = mostcolor(I)
  for row in range(height(I)):
    for col in range(width(I)):
      if index(O, (row, col)) != bg:
        # Extend left
        left_col = col - 1
        while left_col >= 0 and index(O, (row, left_col)) == bg:
          O = fill(O, index(O, (row, col)), {(row, left_col)})
          left_col -= 1
  return O
 
17.333333333333332, tensor(0.0156), Description: For each colored cell in the input grid, draw a diagonal line from that cell to the bottom-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all colored cells in the grid. 
:: def ahagieggcaeiehcgafbiddjejcdaidff(I):
  O = I  
  for obj in objects(I, T, F, T):
    for i, j in toindices(obj):
      O = fill(O, index(I,(i,j)), connect((i, j), (len(I)-1, len(I[0])-1)))
  return O
 
14.666666666666666, tensor(0.0119), Description: For each colored object in the input grid, shift the object one square diagonally down and to the right, using the same color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The shifted objects are then painted onto the original input grid. 
:: def eabcechfcbcfeaddjdfedaegiigcidcg(I):
    O = I
    for obj in objects(I, T, F, T):
        O = underfill(O, color(obj), backdrop(shift(obj, (1,1))))
    return O
 
19.666666666666668, tensor(0.0239), Description: For each color in the input grid (excluding the background color), draw a line connecting each cell of that color to the bottom-right corner of the color's area, using the same color. The output grid will contain the original input grid with lines extending from each colored cell to the bottom-right corner. 
:: def adciaiiegfbcedeejafdgffccbeceacc(I):
    O = I
    for v in palette(I) - {mostcolor(I)}:
        obj = ofcolor(I, v)
        target = lrcorner(obj)
        for loc in obj:
            O = fill(O, v, connect(loc, target))
    return O
 
24.333333333333332, tensor(0.0119), Description: For each colored object in the input grid, extend it diagonally down and to the right, using the same color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ebedcccagbdfehbcibbfbfccebdcdeda(I):
  O = I
  for obj in objects(I, True, False, True):
    direction = (1,1)
    for cell in obj:
      current = cell[1]
      while True:
        next_cell = add(current, direction)
        if next_cell[0] >= height(I) or next_cell[1] >= width(I) or index(I, next_cell) != mostcolor(I):
          break
        O = fill(O, cell[0], {next_cell})
        current = next_cell
  return O
 
25.0, tensor(0.4960), Description: For each colored object in the input grid, if the most common color in the object is light blue (color 1), extend the object vertically downwards, using light blue. If the most common color is yellow (color 3) or orange (color 7), extend the object horizontally to the right, using that color. If the most common color is dark blue (color 8), extend the object vertically downwards, using dark blue. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def jjdhecdffbiieegiibeadddbbfeiebdc(I):
  O = I
  for obj in objects(I, False, True, True):
    c = mostcolor(obj)
    if c == 1:
      O = underfill(O, c, {(i, leftmost(obj)) for i in range(uppermost(obj), height(I))})
    elif c == 3 or c == 7:
      O = underfill(O, c, {(uppermost(obj), j) for j in range(leftmost(obj), width(I))})
    elif c == 8:
        O = underfill(O, c, {(i, leftmost(obj)) for i in range(uppermost(obj), height(I))})
  return O
 
25.0, tensor(0.1975), Description: For each object in the input grid, if the object's most common color is light blue (color 1) or dark blue (color 8), extend the object vertically downwards, using that color. If the most common color is yellow (color 3) or orange (color 7), extend the object horizontally to the right, using that color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def bcbhfdfbjbeheeeibgdfdebdadiadbda(I):
  O = I
  for c in (1, 3, 7, 8):  # Directly specify colors to extend
    for obj in sfilter(objects(I, True, True, True), lambda x: color(x) == c):
      if c in (1, 8):
        O = underfill(O, c, {(i, leftmost(obj)) for i in range(uppermost(obj), height(I))})
      else:  # c is 3 or 7
        O = underfill(O, c, {(uppermost(obj), j) for j in range(leftmost(obj), width(I))})
  return O
 
31.666666666666668, tensor(0.0120), Description: For each row in the grid, replace all cells with the background color with the first non-background color encountered in that row, moving from left to right. This effectively extends the first non-background color in each row to the right, replacing all background cells until another non-background color is encountered. 
:: def fbbgdiecbafaeebhjddaebbdadcdhcfd(grid):
  return tuple(
      tuple(
          next((v for v in row[j:] if v != mostcolor(grid)), mostcolor(grid))
          for j in range(len(row))
      )
      for row in grid
  )
 
54.333333333333336, tensor(0.0205), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ddbbabbhecfaefieiifcehajjibdeace(I):
  O = I
  for obj in objects(I, True, False, False):
    for direction in [RIGHT, DOWN]:
      O = efbadbheidebebecaegaajabjgicfbfh(O, direction)
  return O
 
7.666666666666667, tensor(0.0205), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def bhdddfbagcadeedfjajjbfajafbbfbdc(I):
  O = I
  for obj in objects(I, True, False, False):
    O = extend_object(O, obj, RIGHT)
    O = extend_object(O, obj, DOWN)
  return O
 
9.666666666666666, tensor(0.0205), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fbcjbhbajdbeebeabbbfjiebddihdaai(I):
  O = I
  for d in [RIGHT, DOWN]:
    O = connect_objects(O, d)
  return O
 
37.333333333333336, tensor(0.0069), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell to the right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. 
:: def aciiaccgdfacecheaeabdfeejgbfccaa(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if index(O, (i, j)) != mostcolor(I):
        current_color = index(O, (i, j))
        # Extend right
        k = j + 1
        while k < width(I) and index(O, (i, k)) == mostcolor(I):
          O = fill(O, current_color, {(i, k)})
          k += 1
  return O
 
39.0, tensor(0.0090), Description: For each row in the input grid, extend the first non-background color cell to the right, using the same color, until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending from the first non-background cell in each row to the right. 
:: def afbhhfjhafbeejfaiicaheehagdbbcea(I):
  O = I
  for i in range(height(I)):
    line = crop(I, (i, 0), (1, width(I)))
    for j in range(width(line)):
      if index(line, (0, j)) != mostcolor(line):
        O = fill(O, index(line, (0, j)), {(i, k) for k in range(j, width(line))})
        break
  return O
 
78.66666666666667, tensor(0.0228), Description: For each color in the input grid (excluding the background color), fill all cells below and to the right of the first occurrence of that color with the same color. This effectively creates rectangular blocks of the same color, extending downwards and to the right from the first occurrence of each color. 
:: def edccicacbedbecdhaabejgfgbbijihbi(I):
  h, w = shape(I)
  O = I
  for v in palette(I) - {mostcolor(I)}:
    for i, j in ofcolor(I, v):
      O = fill(O, v, {(k, l) for k in range(i, h) for l in range(j, w)})
  return O
 
9.333333333333334, tensor(0.0225), Description: For each colored object in the input grid, fill all cells below and to the right of the object, including the object itself, with the same color. This effectively creates rectangular blocks of the same color, extending downwards and to the right from the first occurrence of each color. 
:: def fabdabdbacjheiijjdejdejhaahhebca(I):
  O = I
  for obj in fgpartition(I):
    target = lrcorner(toindices(O))
    O = fill(O, color(obj), {(i, j) for i in range(uppermost(obj), target[0] + 1) for j in range(leftmost(obj), target[1] + 1)})
  return O
 
25.0, tensor(0.1975), Description: For each object in the input grid, if the object's most common color is light blue (color 1) or dark blue (color 8), extend the object vertically downwards, using that color. If the most common color is yellow (color 3) or orange (color 7), extend the object horizontally to the right, using that color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def cdigaaageddbehfibdcidfffifdfedca(I):
  O = I  # Start with input grid
  for c in (1, 8):
    for obj in objects(I, True, True, True):
      if color(obj) == c:
        O = underfill(O, c,  {(i, leftmost(obj)) for i in range(uppermost(obj), height(I))})  # Extend down
  for c in (3, 7):
    for obj in objects(I, True, True, True):
      if color(obj) == c:
        O = underfill(O, c, {(uppermost(obj), j) for j in range(leftmost(obj), width(I))})  # Extend right
  return O
 
37.333333333333336, tensor(0.0180), Description: For each row in the grid, if a cell is the background color and the cell to its right is not the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right, starting from a non-background cell that is directly to the left of a background cell, until they encounter another non-background color. This is done for all rows in the grid. 
:: def fdcbcffbfeegecdficdiccdhaddcdjii(grid):
    out_grid = grid
    for y in range(height(grid)):
        x = 0
        while x < width(grid) and index(out_grid, (y, x)) == mostcolor(grid):
            x += 1
        if x < width(grid):
            target_color = index(out_grid, (y, x))
            while x < width(grid):
                if index(out_grid, (y, x)) == mostcolor(grid):
                    out_grid = fill(out_grid, target_color, {(y, x)})
                x += 1
    return out_grid
 
60.0, tensor(0.0066), Description: Extend each colored object to the right and left, using the same color as the object. The extension should stop when it encounters a non-background color. If there is a background color to the left of the object, extend the object to the left as well. 
:: def gdhgcddfegffehbdjfdfchhhebefacgj(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  O = I
  for obj in objs:
    for i, j in toindices(obj):
      for dj in range(1, width(I)):
        if j + dj < width(I) and index(I, (i, j + dj)) == bg:
          O = fill(O, color(obj), {(i, j + dj)})
        else:
          break
      for dj in range(1, width(I)):
        if j - dj >= 0 and index(I, (i, j - dj)) == bg:
          O = fill(O, color(obj), {(i, j - dj)})
        else:
          break
  return O
 
17.666666666666668, tensor(0.0147), Description: For each single-pixel colored object in the input grid, draw a diagonal line from that object to the bottom-right corner of the grid, using the same color. The line should stop when it encounters a non-background color. This is done for all single-pixel colored objects in the grid. 
:: def fbecbjaihgaaechcafbejbaabjhjciac(I):
    O = I
    for obj in objects(I, True, False, True):
        if size(obj) == 1:
            O = fill(O, color(obj), connect(first(toindices(obj)), lrcorner(asindices(O)))) 
    return O
 
28.333333333333332, tensor(0.1975), Description: For each object in the input grid, if the object's most common color is light blue (color 1) or dark blue (color 8), extend the object vertically downwards, using that color. If the most common color is yellow (color 3) or orange (color 7), extend the object horizontally to the right, using that color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. 
:: def cdfeadfgcgegefhibiffhebdgbacbadf(I):
    O = I
    for obj in objects(I, True, True, True):
        c = color(obj)
        if c == 1:
            O = underfill(O, c, {(i, j) for i in range(uppermost(obj), height(I)) for j in range(leftmost(obj), rightmost(obj) + 1)})  # Extend down
        elif c == 8:
            O = underfill(O, c, {(i, j) for i in range(uppermost(obj), height(I)) for j in range(leftmost(obj), rightmost(obj) + 1)})  # Extend down
        elif c == 3:
            O = underfill(O, c, {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(leftmost(obj), width(I))})  # Extend right
        elif c == 7:
            O = underfill(O, c, {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(leftmost(obj), width(I))})  # Extend right
    return O
 
33.0, tensor(0.0091), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. If there is a background color to the right of the object, extend the object to the right. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def gccffbaibdaeebifaadfdccjcecejcdh(grid):
  objs = objects(grid, True, False, True)
  new_objs = set()
  for obj in objs:
    leftmost_j = leftmost(obj)
    rightmost_j = rightmost(obj)
    obj_color = color(obj)
    for j in range(rightmost_j + 1, width(grid)):
      if index(grid, (uppermost(obj), j)) == mostcolor(grid):
        obj = insert((obj_color, (uppermost(obj), j)), obj)
      else:
        break
    new_objs.add(obj)
  return paint(canvas(mostcolor(grid), shape(grid)), merge(new_objs))
 
37.333333333333336, tensor(0.0163), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def bbhjacdfhhcfebaejfhgefaidceibahc(grid):
  return paint(grid, merge(apply(lambda obj: recolor(color(obj), frozenset((i, j) for i, j in product(range(uppermost(obj), lowermost(obj) + 1), range(leftmost(obj), width(grid))) if index(grid, (i, j)) == mostcolor(grid) or (i, j) in toindices(obj))), objects(grid, True, False, True))))
 
8.666666666666666, tensor(0.0154), Description: For each row in the grid, if a cell is not the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def agcchcdidhicegffjeaccdcjhecfacge(grid):
    out_grid = canvas(mostcolor(grid), shape(grid))
    for obj in objects(grid, True, False, True):
        for i in range(uppermost(obj), lowermost(obj) + 1):
            for j in range(leftmost(obj), width(grid)):
                if index(grid, (i, j)) != mostcolor(grid):
                    out_grid = fill(out_grid, index(grid, (i, j)), {(i, j)})
                    break
                out_grid = fill(out_grid, color(obj), {(i, j)})
    return out_grid
 
9.0, tensor(0.0205), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def hbhfjbefebfdegeejbdegbcaidcgehga(I):
  O = I
  for obj in objects(I, True, False, False):
    O = paint(fill(O, mostcolor(O), shoot(ulcorner(obj), RIGHT)), obj)
    O = paint(fill(O, mostcolor(O), shoot(ulcorner(obj), DOWN)), obj)
  return O
 
18.666666666666668, tensor(0.0364), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. Do the same for each column, extending colored cells downwards. This effectively creates horizontal and vertical lines of the same color, extending outwards from the original colored cells. 
:: def aadhcjgejjhieeafacfcebiiddbgccfb(I):
  O = I
  for row in range(height(I)):
    for col in range(width(I) - 1):
      if index(I, (row, col)) != mostcolor(I) and index(I, (row, col + 1)) == mostcolor(I):
        O = fill(O, index(I, (row, col)), {(row, col + 1)})
  for col in range(width(I)):
    for row in range(height(I) - 1):
      if index(I, (row, col)) != mostcolor(I) and index(I, (row + 1, col)) == mostcolor(I):
        O = fill(O, index(I, (row, col)), {(row + 1, col)})
  return O
 
37.333333333333336, tensor(0.0284), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. The cells are processed in order of their column index, from left to right. 
:: def dhjddfjacaeaeafaaafeeecbgddagajc(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    c = color(obj)
    for _, (i, j) in sorted(obj, key=lambda x: x[1][1]):
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) != 0:
          break
        I = fill(I, c, {(i, k)})
  return I
 
33.0, tensor(0.0284), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. The extension starts from the rightmost cell of the object and continues to the right. 
:: def dbbccagdbgbaeaffbebiabdafjefbcib(I):
  for obj in objects(I, T, F, T):
    start_j = rightmost(obj) + 1
    for k in range(start_j, width(I)):
      if index(I, (uppermost(obj), k)) != 0:
        break
      I = fill(I, color(obj), {(uppermost(obj), k)})
  return I
 
6.666666666666667, tensor(0.1045), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color and the column to the right of the object does not contain any cells of the same color as the object. 
:: def cdfbgcfajheheigajacbbjdeegbaehaf(I):
  for obj in objects(I, T, F, T):
    rightmost_j = rightmost(obj)
    for j in range(rightmost_j + 1, width(I)):
      column = {(i, j) for i in range(height(I)) if index(I, (i, j)) == 0}
      if not column.isdisjoint(toindices(obj)):
        break
      I = fill(I, color(obj), column & backdrop(obj))
  return I
 
28.0, tensor(0.0277), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. The cells are processed in order of their column index, from left to right. 
:: def ffbajcdcibjcedehiebfefaafdedcdda(I):
    objs = objects(I, True, False, True)
    bg = mostcolor(I)
    for obj in objs:
        c = color(obj)
        leftmost_j = leftmost(obj)
        rightmost_j = rightmost(obj)
        for j in range(leftmost_j, rightmost_j + 1):
            for i in range(len(I)):
                if (i, j) in toindices(obj):
                    break
                if I[i][j] == bg:
                    I = fill(I, c, {(i, j)})
    return I
 
7.333333333333333, tensor(0.1291), Description: For each colored object in the input grid, extend it either horizontally or vertically, using the same color as the object. The extension direction is determined by the object's orientation: if the object is taller than it is wide, extend it vertically; if it is wider than it is tall, extend it horizontally. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def acffdbfaegdhefjbbjahjbbecffefhcb(I):
    objs = objects(I, True, False, True)
    bg = mostcolor(I)
    for obj in objs:
        if portrait(obj):
            direction = (1, 0)
        else:
            direction = (0, 1)
        for loc in toindices(obj):
            ray = shoot(loc, direction)
            for i, j in ray:
                if 0 <= i < len(I) and 0 <= j < len(I[0]):
                    if I[i][j] == bg:
                        I = fill(I, color(obj), {(i, j)})
                    else:
                        break
                else:
                    break
    return I
 
7.0, tensor(0.2794), Description: For each colored object in the input grid, if there is another object of the same color that is two squares away (Manhattan distance), connect the centers of mass of these two objects with a line of the same color. The line should only be drawn on background cells. The output grid will contain the original input grid with lines connecting the centers of mass of objects of the same color that are two squares apart. 
:: def dfcbddcejjhaefaajbhfbbdfeigadbea(I):
    objs = objects(I, True, False, True)
    bg = mostcolor(I)
    for obj in objs:
        for other_obj in objs:
            if obj != other_obj:
                if manhattan(obj, other_obj) == 2:
                    connection_line = connect(centerofmass(obj), centerofmass(other_obj))
                    for i, j in connection_line:
                        if 0 <= i < len(I) and 0 <= j < len(I[0]):
                            if I[i][j] == bg:
                                I = fill(I, color(obj), {(i, j)})
    return I
 
83.33333333333333, tensor(0.6743), Description: For each colored object in the input grid, extend the object outwards in all directions (up, down, left, right) until it encounters a non-background color. This effectively creates a "flood fill" effect, expanding each colored object to its maximum extent within the grid. The output grid will contain the original input grid with all colored objects expanded to their maximum size. 
:: def gedhjdhfdcdeeeabjgcejdaibjgabgec(I):
    objs = objects(I, True, False, True)
    for obj in objs:
        expansion = set(toindices(obj))
        for _ in range(max(len(I), len(I[0]))):
            new_expansion = set()
            for i, j in expansion:
                neighbors = {(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)}
                for ni, nj in neighbors:
                    if 0 <= ni < len(I) and 0 <= nj < len(I[0]):
                        if I[ni][nj] == mostcolor(I):
                            new_expansion.add((ni, nj))
            if not new_expansion:
                break
            expansion.update(new_expansion)
        I = fill(I, color(obj), frozenset(expansion))
    return I
 
37.333333333333336, tensor(0.0045), Description: For each row in the input grid, if a cell has a color, extend the color to the right until a non-background color is encountered. This effectively creates horizontal lines of the same color, extending downwards from the original colored cells. 
:: def fcdaahfhbfehefbejgcdffbaddaieida(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0]) - 1):
      if I[i][j] != 0:
        k = j + 1
        while k < len(I[0]) and I[i][k] == 0:
          O = fill(O, I[i][j], {(i, k)})
          k += 1
  return O
 
42.666666666666664, tensor(0.0217), Description: For each colored object in the input grid, extend it horizontally to the left, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def geabcffaagbcegagigijcagdfeabacbd(I):
  O = canvas(0, shape(I))
  for obj in objects(I, False, False, False):
    leftmost_j = leftmost(obj)
    for i, j in toindices(obj):
      O = paint(O, {(color(obj), (i, j))})
      for k in range(leftmost_j + 1, j):
        if index(I, (i, k)) == 0:
          O = paint(O, {(color(obj), (i, k))})
  return O
 
29.666666666666668, tensor(0.0481), Description: For each colored object in the input grid, fill in all the background cells within the object's bounding box with the same color as the object. This effectively fills the interior of each object with its own color, leaving the background cells outside the objects unchanged. 
:: def bdafafcgeeeeedcajdgjidcfefeaafag(I):
  O = I
  for obj in objects(I, False, False, False):
    min_j = leftmost(obj)
    max_j = rightmost(obj)
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(min_j, max_j):
        if I[i][j] == 0:
          O = fill(O, color(obj), {(i, j)})
  return O
 
8.666666666666666, tensor(0.0047), Description: For each row in the input grid, if a cell has a color and the cell to its right is the background color, extend the color to the right until a non-background color is encountered. This effectively creates horizontal lines of the same color, extending downwards from the original colored cells. 
:: def eaebffecjiibebieiaabdaeifcedjcej(I):
  O = I
  for i in range(len(I)):
    last_nonzero_j = -1
    for j in range(len(I[0])):
      if I[i][j] != 0:
        if last_nonzero_j != -1:
          O = fill(O, I[i][last_nonzero_j], {(i, k) for k in range(last_nonzero_j + 1, j)})
        last_nonzero_j = j
  return O
 
37.333333333333336, tensor(0.0180), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for each row independently. The extended objects are then painted onto the original input grid. 
:: def bjcacihjacfdeeeebiehbfgaffccfcag(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  filled_grid = I
  for obj in objs:
    for v, (i, j) in obj:
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) != bg:
          break
        filled_grid = fill(filled_grid, v, {(i, k)})
  O = filled_grid
  return O
 
7.333333333333333, tensor(0.0279), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extension should only occur if the cell to the right of the object is a background color. The extension starts from the rightmost cell of the object and continues to the right. 
:: def eccfcjdbcifcecedjgicheiaabgdjaff(I):
    O = I
    for obj in objects(I, T, F, T):
        rightmost_cell = argmax(obj, lambda c: c[1][1])
        right_extension = shoot(rightmost_cell[1], RIGHT)
        for i, j in right_extension:
            if 0 <= i < height(I) and 0 <= j < width(I) and index(I, (i, j)) == mostcolor(I):
                O = fill(O, rightmost_cell[0], {(i, j)})
            else:
                break
    return O
 
11.666666666666666, tensor(0.0296), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color or another object of a different color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ahccfcdddjjcebbgjabihdbfddjfeagj(grid):
  for obj in objects(grid, T, F, T):
    start_j = rightmost(obj) + 1
    end_j = next((j for j in range(start_j, width(grid)) 
                  if len(sfilter(toobject({(i, j) for i in range(height(grid))}, grid), 
                                 lambda x: x[0] != color(obj) and x[0] != 0)) > 0), width(grid))
    grid = fill(grid, color(obj), {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(start_j, end_j)})
  return grid
 
36.333333333333336, tensor(0.0280), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters another object of a different color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def ebhfeibhjbbhedjciebaeebjcabfjfec(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objects(grid, T, F, T):
    right_limit = width(grid)
    for other_obj in objects(grid, T, F, T):
      if other_obj != obj and hmatching(obj, other_obj) and leftmost(other_obj) > leftmost(obj):
        right_limit = min(right_limit, leftmost(other_obj))
    new_grid = paint(new_grid, {(color(obj), (i, j)) for i in range(uppermost(obj), lowermost(obj) + 1) 
                              for j in range(leftmost(obj), right_limit)})
  return new_grid
 
37.333333333333336, tensor(0.0060), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def adbcdcddjacbefhfjabfidcfgddffhac(I):
    for i in range(height(I)):
      for j in range(width(I) - 1):
        if index(I, (i, j)) != mostcolor(I) and index(I, (i, j + 1)) == mostcolor(I):
          I = fill(I, index(I, (i, j)), {(i, j + 1)})
    return I
 
37.333333333333336, tensor(0.0239), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters another cell of the same color or a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fgfchcacfifgeiejjbaefccebbabfefb(grid):
  objs = objects(grid, True, False, True)
  bg = mostcolor(grid)
  for obj in objs:
    for cell in obj:
      i, (row, col) = cell
      for j in range(col + 1, width(grid)):
        if (row, j) in toindices(obj):
          break
        if grid[row][j] == bg:
          grid = fill(grid, i, {(row, j)})
  return grid
 
7.666666666666667, tensor(0.0146), Description: For each row in the grid, if a cell is not the background color, connect it to the closest cell of the same color in the same row, using a line of the same color. The line should stop when it encounters another cell of the same color. This effectively creates horizontal lines of the same color, connecting cells of the same color within each row. 
:: def eebijdjgbdhfeefbjdfcjfehheaeecfg(grid):
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val != mostcolor(grid):
        for k in range(j + 1, width(grid)):
          if grid[i][k] == val:
            grid = fill(grid, val, connect((i,j), (i,k)))
            break
  return grid
 
6.666666666666667, tensor(0.0076), Description: For each colored object in the input grid, fill the entire row that the object is in with the same color as the object. This effectively creates horizontal stripes of the same color, extending across the grid from the original colored cells. 
:: def bjciebacbjbbeebejjaeceheeeddecja(grid):
    objs = objects(grid, True, False, True)
    for obj in objs:
      row = uppermost(obj)
      left, right = leftmost(obj), rightmost(obj)
      grid = fill(grid, color(obj), {(row, j) for j in range(left, right + 1)})
    return grid
 
11.0, tensor(0.0559), Description: For each column in the grid, if a cell is not the background color, connect it to the closest cell of the same color in the same column, using a line of the same color. The line should stop when it encounters another cell of the same color. This effectively creates vertical lines of the same color, connecting cells of the same color within each column. 
:: def bbiffffacfafebehjciibecejhcfejfd(grid):
  h = height(grid)
  for j in range(width(grid)):
    for i in range(h):
      if grid[i][j] != mostcolor(grid):
        for k in range(i + 1, h):
          if grid[k][j] == grid[i][j]:
            grid = fill(grid, grid[i][j], connect((i,j), (k,j)))
            break
        break
  return grid
 
13.333333333333334, tensor(0.0217), Description: For each colored object in the input grid, extend it horizontally to the left, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def gccbafbjdedeeheaacicdcfcbcfcchdd(I):
  O = I  # Initialize the output grid
  for obj in objects(I, True, False, False): # Iterate over each object
    leftmost_j = leftmost(obj) # Find the leftmost column of the object
    for i, j in toindices(obj): # Iterate over cells in the object
      O = paint(O, {(color(obj), (i, j))}) # Paint current cell to output
      for k in range(leftmost_j + 1, len(I[0])): # Iterate over cells to the right
        if index(I, (i, k)) == 0: # Check if the cell is empty
          O = paint(O, {(color(obj), (i, k))}) # Fill the cell with the object color
        else:
          break # Stop extending if a non-zero cell is encountered
  return O
 
6.666666666666667, tensor(0.0293), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color or another object of a different color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ddabgceajbdgegeajbcidjifffbbcfji(I):
  objs = objects(I, T, F, T)
  filled = set()
  for obj in objs:
    for v, (i, j) in obj:
      filled |= {(i, k) for k in range(j + 1, width(I)) if index(I, (i, k)) == mostcolor(I) and not any(intersection({(i, k)}, toindices(o)) for o in objs - {obj})}
  return fill(I, mostcolor(I), filled)
 
30.666666666666668, tensor(0.0053), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. 
:: def chicceaaidecebbfiiibddbafcfjfehg(I):
  O = I
  for i in range(height(I)):
    current_color = None
    for j in range(width(I)):
      if index(O, (i, j)) != mostcolor(I) and current_color is None:
        current_color = index(O, (i, j))
      elif current_color is not None and index(O, (i, j)) == mostcolor(I):
        O = fill(O, current_color, {(i, j)})
      else:
        current_color = None
  return O
 
13.333333333333334, tensor(0.0062), Description: For each row in the grid, if a cell is the background color and the cell to its left is not the background color, fill the current cell with the same color as the cell to its left. This effectively extends colored cells to the left until they encounter another non-background color. This is done for all rows in the grid. 
:: def giehefacgffdedeajbceagdaihjbdjde(I):
  for j in range(width(I) - 1, 0, -1):
    for i in range(height(I)):
      if index(I, (i, j)) == mostcolor(I) and index(I, (i, j - 1)) != mostcolor(I):
        I = fill(I, index(I, (i, j - 1)), {(i, j)}) 
  return I
 
31.666666666666668, tensor(0.0289), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def gdbcbjeeagheegeiicgfdcjfedaedbcb(I):
  O = I
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    leftmost_j = leftmost(obj)
    for j in range(leftmost_j + 1, width(I)):
      if index(I, (uppermost(obj), j)) == mostcolor(I):
        O = fill(O, color(obj), {(uppermost(obj), j)})
      else:
        break
  return O
 
17.0, tensor(0.0061), Description: For each cell in the grid, if the cell has the same color as the cell above it, extend the color downwards to the bottom of the grid. If the cell has the same color as the cell to its left, extend the color to the right to the end of the grid. This effectively creates vertical and horizontal lines of the same color, extending outwards from the original colored cells. 
:: def jhehieiadddieefbibjfjccdfjefbfch(grid):
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if grid[i][j] != mostcommon(grid):
        if i > 0 and grid[i-1][j] == grid[i][j]:
          grid = fill(grid, grid[i][j], {(k, j) for k in range(i, len(grid))})
        if j > 0 and grid[i][j-1] == grid[i][j]:
          grid = fill(grid, grid[i][j], {(i, k) for k in range(j, len(grid[0]))})
  return grid
 
38.0, tensor(0.1291), Description: For each colored object in the input grid, extend it either horizontally or vertically, using the same color as the object. The extension direction is determined by the object's orientation: if the object is taller than it is wide, extend it vertically; if it is wider than it is tall, extend it horizontally. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def hfcchjcfefbeeffiajddbhecdjcjajgd(grid):
    objs = objects(grid, True, False, True)
    for obj in objs:
        direction = (1, 0) if height(obj) > width(obj) else (0, 1)
        for (v, (i, j)) in obj:
            grid = fill(grid, v, shoot((i, j), direction))
    return grid
 
17.0, tensor(0.0074), Description: For each row in the grid, if a cell is not the background color and the cell to its left is the same color, extend the color to the right to the end of the grid. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. The extension is performed on a diagonally mirrored version of the grid, and then the result is mirrored back to produce the final output. 
:: def cehejjeccghaefbdbabhdbeedfbbjida(grid):
  transposed = dmirror(grid)
  for i in range(len(transposed)):
    for j in range(len(transposed[0])):
      if transposed[i][j] != mostcommon(transposed):
        if j > 0 and transposed[i][j-1] == transposed[i][j]:
          transposed = fill(transposed, transposed[i][j], {(i, k) for k in range(j, len(transposed[0]))})
  return dmirror(transposed)
 
6.666666666666667, tensor(0.0224), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color or a cell that is part of the object. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ediacbbfidigeceeadhccciejadffcae(I):
  O = I
  for obj in objects(I, True, False, False):
    for i in range(uppermost(obj), lowermost(obj) + 1):
      j = leftmost(obj)
      while j < len(I[0]) and (i, j) not in toindices(obj) and index(I, (i, j)) == 0:
        O = paint(O, {(color(obj), (i, j))})
        j += 1
  return O
 
13.333333333333334, tensor(0.0053), Description: For each row in the input grid, if a cell is the background color and the cell to its left is not the background color, fill the current cell with the same color as the cell to its left. This effectively extends colored cells to the left until they encounter another non-background color. This is done for all rows in the grid. 
:: def daighbbacaaaegfficcbceiaddhfcadd(I):
  O = I
  for i in range(len(I)):
    for j in range(1, len(I[0])):
      if I[i][j] == 0 and I[i][j - 1] != 0:
        O = paint(O, {(I[i][j - 1], (i, j))})
  return O
 
16.0, tensor(0.0430), Description: For each colored object in the input grid, fill all cells within the object's bounding box with the same color as the object. This effectively fills the interior of each object with its own color, leaving the background cells outside the objects unchanged. 
:: def hcfehdibcbfbefbfaecihdjafifdffaa(I):
  O = I
  for obj in objects(I, True, False, False):
    O = fill(O, color(obj), {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return O
 
17.0, tensor(0.0166), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters another cell of the same color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def jhaefhbeafegejcaacfdffbeeeedfbad(I):
    objs = objects(I, T, F, T) 
    extensions = set()
    for obj in objs:
        color_val = color(obj)
        for i, j in toindices(obj):
            for k in range(j + 1, width(I)):
                if index(I, (i, k)) == color_val:
                    extensions |= connect((i, j), (i, k))
            for k in range(i + 1, height(I)):
                if index(I, (k, j)) == color_val:
                    extensions |= connect((i, j), (k, j))
    O = fill(I, color_val, extensions)
    return O
 
37.333333333333336, tensor(0.0060), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def ejgcdcbgdfagebecibadidfaffjcfcga(I):
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if index(I, (i, j)) != mostcolor(I) and index(I, (i, j + 1)) == mostcolor(I):
        I = fill(I, index(I, (i, j)), {(i, k) for k in range(j + 1, width(I)) if index(I, (i, k)) == mostcolor(I)})
  return I
 
48.333333333333336, tensor(0.0080), Description: For each row in the grid, if a cell is not the background color, fill the cells to the right of the non-background cell with the same color as the non-background cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def fbiafahdcbabeiejjdcfacdcdeieebeb(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        O = paint(O, {(index(I, (i, j)), (i, k)) for k in range(j, width(I)) if index(I, (i, k)) == mostcolor(I)})
  return O
 
30.666666666666668, tensor(0.0060), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def dcfiidfbehgaefgbbdifhehffefijadi(I):
    O = I
    for i in range(height(I)):
        current_color = None
        j = 0
        while j < width(I):
            if index(I, (i, j)) != mostcolor(I) and current_color is None:
                current_color = index(I, (i, j))
            elif current_color is not None and index(I, (i, j)) == mostcolor(I):
                O = fill(O, current_color, {(i, j)})
            else:
                current_color = None
            j += 1
    return O
 
18.333333333333332, tensor(0.0232), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fgbbdaedabccebcaaabaacijgaeccfjd(I):
  O = I
  for obj in objects(I, True, False, False):
    for (i, j) in toindices(obj):
      for k in range(j + 1, len(I[0])):
        if index(I, (i, k)) == 0:
          O = fill(O, color(obj), {(i, k)})
        else:
          break
  return O
 
19.0, tensor(0.0232), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def cddbbbeebjabecbfbecjahahahcdcjge(I):
  objs = objects(I, True, False, False)
  extensions = frozenset({(color(obj), connect((i, j), (i, len(I[0]) - 1))) for obj in objs for (i, j) in toindices(obj)})
  O = I
  for value, extension in extensions:
    for i, j in extension:
      if index(O, (i, j)) == 0:
        O = fill(O, value, {(i, j)})
      else:
        break
  return O
 
33.666666666666664, tensor(0.0232), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def begeedbheafbejibjdacjejigfefadcj(I):
  O = I
  for obj in objects(I, True, False, False):
    rightmost_j = rightmost(obj)
    for i in range(uppermost(obj), lowermost(obj) + 1):
      O = fill(O, color(obj), connect((i, rightmost_j), (i, len(I[0]) - 1)))
  return O
 
48.333333333333336, tensor(0.0291), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def dbdichddechhefadbbbfbedahcjcacfj(I):
    O = canvas(mostcolor(I), shape(I)) # Start with a blank canvas of background color
    for obj in objects(I, T, F, T):
        leftmost_j = leftmost(obj)
        for v, (i, _) in obj:
            O = fill(O, v, {(i, j) for j in range(leftmost_j, width(I)) if index(I, (i, j)) == mostcolor(I)})
    return O
 
38.0, tensor(0.0295), Description: For each colored object in the input grid, draw a horizontal line from each cell of the object to the right edge of the grid, using the same color as the object. The line should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def hccheajbafgeebaaaccbbeefjfgeabad(I):
    O = I
    for obj in objects(I, T, F, T):
        for (i, j) in toindices(obj):
            O = paint(O, recolor(color(obj), connect((i, j), (i, width(I)-1)))) # Fill horizontally from each cell to the edge
    return O
 
39.0, tensor(0.0056), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell to the right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. This is done for all rows in the grid. 
:: def djajfafeacedecfcbhcccheeagffdacd(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I)):
            if index(I, (i, j)) != mostcolor(I):
                O = paint(O, recolor(index(I, (i, j)), {(i, k) for k in range(j, width(I))}))
                break  # Move to the next row after extending an object
    return O
 
41.666666666666664, tensor(0.0296), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color or another object of a different color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ccjdddbffecceejbbcefihaifgbahecd(grid):
  bg = mostcolor(grid)
  for obj in objects(grid, True, False, True):
    target_j = width(grid)
    for j in range(rightmost(obj) + 1, width(grid)):
      if any(index(grid, (i, j)) != bg for i in range(height(grid))):
        target_j = j
        break
    grid = fill(grid, color(obj), product(range(height(grid)), range(rightmost(obj) + 1, target_j)))
  return grid
 
30.666666666666668, tensor(0.0300), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color or another object of a different color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def edfachfeadafejfiajcehfifcidiaabj(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    for i, j in toindices(obj):
      for k in range(j + 1, width(I)):
        if index(O, (i, k)) == mostcolor(I):
          O = fill(O, index(O, (i, j)), {(i, l) for l in range(j + 1, k)})
        else:
          break
  return O
 
23.0, tensor(0.0212), Description: For each colored object in the input grid, if the object is a vertical line, extend it downwards, using the same color. If the object is a horizontal line, extend it to the right, using the same color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fijecajfaabfeiahajiejeibdhddfaja(grid):
    objs = objects(grid, True, False, True)  # Find objects, exclude background
    bg = mostcolor(grid)  # Identify the background color
    for obj in objs:
        if vline(obj): # Check if object is a vertical line
            for j in range(leftmost(obj), rightmost(obj) + 1): 
                for i in range(lowermost(obj) + 1, len(grid)):  # Extend downwards
                    if index(grid, (i, j)) != bg:  # Stop if encountering a non-background color
                        break
                    grid = fill(grid, color(obj), {(i, j)})  # Fill with object color
        elif hline(obj): # Check if object is a horizontal line
            for i in range(uppermost(obj), lowermost(obj) + 1):
                for j in range(rightmost(obj) + 1, len(grid[0])): # Extend rightwards
                    if index(grid, (i, j)) != bg:  # Stop if encountering a non-background color
                        break
                    grid = fill(grid, color(obj), {(i, j)}) # Fill with object color
    return grid
 
55.0, tensor(0.0063), Description: For each cell in the grid, if the cell is not the background color, extend the color of that cell both downwards and to the right until it encounters another non-background color. This effectively creates horizontal and vertical lines of the same color, extending outwards from the original colored cells. 
:: def gjaaaecabeddecghbbcagbfdgcfaaddd(grid):
    for direction in [DOWN, RIGHT]:  # Iterate for vertical and horizontal extension
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if index(grid, (i, j)) != mostcolor(grid):  # Check for non-background color
                    current_color = index(grid, (i, j)) 
                    next_loc = add((i, j), direction)  # Calculate the next location in the direction
                    while 0 <= next_loc[0] < len(grid) and 0 <= next_loc[1] < len(grid[0]) and index(grid, next_loc) == mostcolor(grid):
                        grid = fill(grid, current_color, {next_loc})
                        next_loc = add(next_loc, direction)  # Move to the next location
    return grid 
 
17.333333333333332, tensor(0.0232), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def gfhaefgcfidaebhdbegacdjbbechhghe(I):
  O = I  # Initialize output grid
  for obj in objects(I, True, False, False): # Iterate over each object
    for i in range(uppermost(obj), lowermost(obj) + 1): # Iterate over rows containing the object
      extension = connect((i, rightmost(obj)), (i, len(I[0]) - 1)) # Line from rightmost point to the edge
      for ex_i, ex_j in extension:
        if index(I, (ex_i, ex_j)) == 0:
          O = paint(O, {(color(obj), (ex_i, ex_j))})
        else:
          break
  return O
 
7.333333333333333, tensor(0.0232), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def begjcjggafaaefcbjdafhhdcggchfjbh(I):
  O = I
  for obj in objects(I, True, False, False):
    right_edge =  [(i, rightmost(obj)) for i in range(uppermost(obj), lowermost(obj) + 1)]
    for i, j in right_edge:
      ray = shoot((i, j), (0, 1)) # Shoot a ray rightward
      for r_i, r_j in ray:
        if r_j < len(I[0]) and index(I, (r_i, r_j)) == 0:
          O = paint(O, {(color(obj), (r_i, r_j))})
        else:
          break
  return O
 
7.333333333333333, tensor(0.0283), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def cfebdafejcecejcfjbfdejhjdacgfhdd(I):
    objs = objects(I, T, F, T)
    extended_objs = set()
    for obj in objs:
      for v, (i, j) in obj:
        extension = shoot((i, j), RIGHT)
        for ei, ej in extension:
          if 0 <= ei < height(I) and 0 <= ej < width(I) and index(I, (ei, ej)) == mostcolor(I):
            extended_objs.add((v, (ei, ej)))
          else:
            break
    return paint(I, frozenset(extended_objs))
 
10.333333333333334, tensor(0.0283), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ccefjbbagbjfecaaiacbfbeddafbejbc(I):
  objs = objects(I, T, F, T)
  extended_indices = set()
  for obj in objs:
    for cell in obj:
      _, (i, j) = cell
      extended_indices |= set(toindices(intersection(hfrontier((i, j)), asindices(I)))) - toindices(obj)
  return fill(I, mostcolor(I), extended_indices)
 
12.0, tensor(0.0213), Description: For each color in the input grid (excluding the background color), if there are multiple single-pixel objects of that color, connect the centers of these two objects with a line of the same color. The line should be drawn horizontally if the objects are horizontally aligned and vertically if they are vertically aligned. The output grid will contain the original input grid with lines connecting the centers of single-pixel objects of the same color that are horizontally or vertically aligned. 
:: def eabdaacjjfaiebicieadfaicdieejhaj(I):
  for v in palette(I) - {mostcolor(I)}:  
    for obj in sizefilter(objects(I, T, F, T), 1):
      if color(obj) == v:
        for other_obj in sizefilter(objects(I, T, F, T), 1):
          if color(other_obj) == v and obj != other_obj:
            if hmatching(obj, other_obj) and not vmatching(obj, other_obj):
              I = fill(I, v, connect(center(obj), center(other_obj)))
            if vmatching(obj, other_obj) and not hmatching(obj, other_obj):
              I = fill(I, v, connect(center(obj), center(other_obj)))
  return I
 
18.0, tensor(0.0063), Description: For each color in the input grid (excluding the background color), if there are multiple objects of that color in the same row, connect the top-left corner to the bottom-right corner of those objects with a line of the same color. Do the same for columns. The output grid will contain the original input grid with lines connecting the extremes of objects of the same color that are horizontally or vertically aligned. 
:: def jaejbcafadaaebigbcfcjffgjcidfech(I):
    O = canvas(mostcolor(I), shape(I))
    for v in palette(I) - {mostcolor(I)}:
        indices = ofcolor(I, v)
        for i in range(height(I)):
            row_indices = {(i, j) for (i, j) in indices if i == i}
            if len(row_indices) > 1:
              O = fill(O, v, connect(ulcorner(row_indices), lrcorner(row_indices)))
        for j in range(width(I)):
            col_indices = {(i, j) for (i, j) in indices if j == j}
            if len(col_indices) > 1:
              O = fill(O, v, connect(ulcorner(col_indices), lrcorner(col_indices)))
    return O
 
9.666666666666666, tensor(0.0656), Description: For each color in the input grid (excluding the background color), if there is another cell of the same color to the right or below the current cell, connect these two cells with a line of the same color. The line should stop when it encounters a non-background color. This effectively creates horizontal and vertical lines of the same color, connecting cells of the same color that are horizontally or vertically adjacent. The output grid will contain the original input grid with these connecting lines. 
:: def jcefefbaegadebbebeacacidabcfbihd(I):
    for v in palette(I) - {mostcolor(I)}:
        for (i, j) in asindices(I):
          if index(I, (i, j)) == v:
            # Connect right
            k = j + 1
            while k < width(I) and index(I, (i, k)) == mostcolor(I):
              k += 1
            if k < width(I) and index(I, (i, k)) == v:
              I = fill(I, v, connect((i, j), (i, k)))
            # Connect down
            k = i + 1
            while k < height(I) and index(I, (k, j)) == mostcolor(I):
              k += 1
            if k < height(I) and index(I, (k, j)) == v:
              I = fill(I, v, connect((i, j), (k, j)))
    return I
 
24.666666666666668, tensor(0.0079), Description: For each row in the grid, if a cell is not the background color and the cell below it is the background color, fill the cell below with the same color as the current cell. This effectively extends colored cells downwards until they encounter another non-background color. Then, for each column in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows and columns in the grid. The output grid will contain the original input grid with all colored cells extended both downwards and to the right. 
:: def aidcddibdcggeefabeajihhdahedbecf(grid):
    def extend_direction(grid, is_vertical):
        h, w = len(grid), len(grid[0])
        bg = mostcolor(grid)
        new_grid = [list(row) for row in grid]
        for i in range(h - 1) if is_vertical else range(w - 1):
            for j in range(w) if is_vertical else range(h):
                if is_vertical:
                    if grid[i][j] != bg and grid[i + 1][j] == bg:
                        new_grid[i + 1][j] = grid[i][j]
                else:
                    if grid[j][i] != bg and grid[j][i + 1] == bg:
                        new_grid[j][i + 1] = grid[j][i]
        return tuple(tuple(row) for row in new_grid)
    grid = extend_direction(grid, True)
    return extend_direction(grid, False)
 
31.333333333333332, tensor(0.7026), Description: For each color in the input grid (excluding the background color), extend the color in all four directions (up, down, left, right) until it encounters a non-background color. This effectively creates a "flood fill" effect, expanding each colored object to its maximum extent within the grid. The output grid will contain the original input grid with all colored objects expanded to their maximum size. 
:: def jecaegafahfcebebabbabcecjcbcacge(grid):
    def extend_color(grid, color):
        h, w = len(grid), len(grid[0])
        bg = mostcolor(grid)
        new_grid = [list(row) for row in grid]
        for i in range(h):
            for j in range(w):
                if grid[i][j] == color:
                    if i > 0 and new_grid[i - 1][j] == bg:
                        new_grid[i - 1][j] = color
                    if i < h - 1 and new_grid[i + 1][j] == bg:
                        new_grid[i + 1][j] = color
                    if j > 0 and new_grid[i][j - 1] == bg:
                        new_grid[i][j - 1] = color
                    if j < w - 1 and new_grid[i][j + 1] == bg:
                        new_grid[i][j + 1] = color
        return tuple(tuple(row) for row in new_grid)
    for c in palette(grid):
        if c != mostcolor(grid):
            grid = extend_color(grid, c)
    return grid
 
44.0, tensor(0.0108), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell to the right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. This is done for only the first row in the grid. The output grid will contain the original input grid with the first row extended to the right. 
:: def ebedhfjfdciheedhieibjbeccegheaaa(I):
  return tuple(
      tuple(v if (i, j) in obj else mostcolor(I) for j, v in enumerate(row))
      for i, row in enumerate(I)
      for obj in [set((i, k) for k in range(j, width(I))) for j, v in enumerate(row) if v != mostcolor(I)][0:1] 
  )
 
47.333333333333336, tensor(0.0053), Description: For each column in the grid, if a cell is not the background color, extend the color of that cell downwards to the bottom of the grid. This effectively creates vertical lines of the same color, extending outwards from the original colored cells. The output grid is then rotated 270 degrees clockwise. 
:: def fbacfcdiedeheadfjjjffhaacedajjei(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      if I[i][j] != mostcolor(I):
        O = fill(O, I[i][j], {(k, j) for k in range(i, height(I))})
  return rot90(rot90(rot90(O))) 
 
16.0, tensor(0.0221), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color or a cell that has already been filled with the same color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ahidddebacccedicbeihceeiebggabbi(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    i, j = ulcorner(obj)
    while j + 1 < width(I) and index(I, (i, j + 1)) == mostcolor(I) and index(O, (i, j + 1)) == mostcolor(I):
      O = paint(O, {(index(I, (i, j)), (i, j + 1))})
      j += 1
    i, j = ulcorner(obj)
    while i + 1 < height(I) and index(I, (i + 1, j)) == mostcolor(I) and index(O, (i + 1, j)) == mostcolor(I):
      O = paint(O, {(index(I, (i, j)), (i + 1, j))})
      i += 1
  return O
 
41.0, tensor(0.0226), Description: For each colored object in the input grid, extend it horizontally to the right and vertically downwards, using the same color as the object. The extension should stop when it encounters a non-background color or a cell that has already been filled with the same color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def baccbbadeejceifaaajfcaifhicbieff(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    O = paint(O, obj)
    for (i, j) in toindices(obj):
      k = j + 1
      while k < width(I) and index(I, (i, k)) == mostcolor(I) and index(O, (i, k)) == mostcolor(I):
        O = paint(O, {(index(I, (i, j)), (i, k))})
        k += 1
      k = i + 1
      while k < height(I) and index(I, (k, j)) == mostcolor(I) and index(O, (k, j)) == mostcolor(I):
        O = paint(O, {(index(I, (i, j)), (k, j))})
        k += 1
  return O
 
46.0, tensor(0.0295), Description: For each color in the input grid (excluding the background color), extend the color horizontally to the right and vertically downwards, using the same color. The extension should stop when it encounters a non-background color or a cell that has already been filled with the same color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ifagacfajdbjeiheicddbifbjggajija(I):
  O = I
  for v in palette(I) - {mostcolor(I)}:
    for (i, j) in ofcolor(I, v):
      k = j + 1
      while k < width(I) and index(I, (i, k)) == mostcolor(I) and index(O, (i, k)) == mostcolor(I):
        O = paint(O, {(v, (i, k))})
        k += 1
      k = i + 1
      while k < height(I) and index(I, (k, j)) == mostcolor(I) and index(O, (k, j)) == mostcolor(I):
        O = paint(O, {(v, (k, j))})
        k += 1
  return O
 
19.333333333333332, tensor(0.0075), Description: For each row in the grid, if a cell is the least common color, connect it to the rightmost cell in that row using a line of the same color. The line should stop when it encounters a non-background color. This effectively creates horizontal lines of the least common color, extending from each occurrence of that color to the right edge of the grid. 
:: def dfebjeifefbbeehdichajhddgcahedah(grid):
  target_color = leastcolor(grid)
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val == target_color:
        grid = fill(grid, target_color, connect((i,j), (i, width(grid)-1)))
  return grid
 
15.333333333333334, tensor(0.0131), Description: For each row in the grid, if a cell is not the least common color, replace it with the least common color. This effectively creates horizontal lines of the least common color, extending from the first occurrence of that color to the right edge of the grid. 
:: def bafabdaefjbeecahajdcaaiidfjeeedf(grid):
  lc = leastcolor(grid)
  return tuple(
    tuple(
      lc if any(v == lc for v in row[j:]) else v 
      for j, v in enumerate(row)
    )
    for row in grid
  )
 
38.0, tensor(0.0047), Description: For each row in the input grid, if a cell has a color and the cell to its right is the background color, extend the color to the right until a non-background color is encountered. This effectively creates horizontal lines of the same color, extending downwards from the original colored cells. 
:: def fdafdfciabeceecdajeeeejacbfeaefb(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row[:-1]):
      if value != 0 and I[i][j + 1] == 0:
        O = fill(O, value, connect((i, j), (i, len(row)-1)))
  return O
 
27.333333333333332, tensor(0.0283), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ccbfeeadccejeibabbggjedghceijgfi(I):
    O = I
    for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
        rightmost_j = rightmost(obj)
        for j in range(rightmost_j + 1, width(I)):
            if index(I, (uppermost(obj), j)) != mostcolor(I):
                break
            O = paint(O, recolor(color(obj), {(uppermost(obj), k) for k in range(rightmost_j, j)}))
    return O
 
20.333333333333332, tensor(0.5194), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. The number of cells to extend to the right should be equal to the number of cells in the object. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def jbecheabagcaebceafchehhceegbfdae(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    obj_right = rightmost(obj)
    for i, row in enumerate(I):
      for j, val in enumerate(row):
        if (i, j) in toindices(obj) or (j > obj_right and j <= obj_right + colorcount(obj, color(obj)) and val == 0):
          O = fill(O, color(obj), {(i, j)})
  return O
 
39.0, tensor(0.0052), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def bafbecbcfehdeaaijeagbiebdfeibcdd(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)-1):
      if index(I,(i,j)) != 0 and index(I,(i,j+1)) == 0:
        O = fill(O,index(I,(i,j)),{(i,k) for k in range(j+1,width(I))})
  return O
 
33.666666666666664, tensor(0.0283), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def iadiddbhegcbebedidffcgffeeegbfab(I):
  O = I
  for obj in objects(I, True, False, True):
    leftmost_j = leftmost(obj)
    O = fill(O, color(obj), {(uppermost(obj), k) for k in range(leftmost_j, width(I))})
  return O
 
13.333333333333334, tensor(0.4570), Description: For each row in the grid, if a cell is the background color, replace it with the value of the cell in the same column but in the last row. This effectively copies the last row of the grid onto all other rows, replacing the background cells. 
:: def daecfaieidacehedbaefhgcgbdiffeib(I):
  return tuple(tuple(row[j] if row[j] != 0 else row[k] for j in range(len(row))) 
                 for k, row in enumerate(I))
 
38.333333333333336, tensor(0.0294), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def icffchfbjdffefcaaeaehaeccdaebhjc(grid):
  return paint(canvas(mostcolor(grid), shape(grid)), 
               merge(apply(lambda obj: recolor(color(obj), 
                                                frozenset((i, j) 
                                                          for i in range(uppermost(obj), lowermost(obj) + 1) 
                                                          for j in range(leftmost(obj), width(grid)))),
                           objects(grid, True, False, True))))
 
17.666666666666668, tensor(0.0156), Description: For each colored object in the input grid, extend it either horizontally or vertically, using the same color as the object. The extension direction is determined by the object's vertical position: if the object is in the top half of the grid, extend it horizontally to the right; if it is in the bottom half, extend it vertically downwards. The extension should stop when it encounters a non-background color or overlaps with itself. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def accdfhcehdaheadgbicegahfebedaeed(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    direction = (0, 1) if uppermost(obj) < height(I) // 2 else (1, 0)
    shifted_obj = obj
    while len(intersection(toindices(shifted_obj), asindices(O))) < len(obj):  # Stop extending when object overlaps with itself
      O = paint(O, shifted_obj)
      shifted_obj = shift(shifted_obj, direction)
  return O
 
81.33333333333333, tensor(0.0115), Description: For each colored object in the input grid, extend it either horizontally to the right or vertically downwards, using the same color as the object. The extension direction is determined by the object's vertical position: if the object is in the top half of the grid, extend it horizontally to the right; if it is in the bottom half, extend it vertically downwards. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def ceedgdbjdcaeefgeiehfaieibbhdffaj(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if uppermost(obj) < height(I) // 2:
      right_edge = max(j for _, (i, j) in obj)
      O = paint(O, recolor(color(obj), {(i, j) for i, j in product(range(height(I)), range(right_edge, width(I))) if index(I, (i,j)) == mostcolor(I)}))
    else:
      bottom_edge = max(i for _, (i, j) in obj)
      O = paint(O, recolor(color(obj), {(i, j) for i, j in product(range(bottom_edge, height(I)), range(width(I))) if index(I, (i,j)) == mostcolor(I)}))
  return O
 
31.666666666666668, tensor(0.0241), Description: For each colored object in the input grid, if the color of the object is the same as the color of the top-left cell of the object, extend the object horizontally to the right, using the same color. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def cjcfgbddahabeeeeabbidedfgbcbiace(grid):
  bg = mostcolor(grid)
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=True):
    i, j = ulcorner(obj)
    if color(obj) == grid[i][j]:
      for k in range(j + 1, width(grid)):
        if grid[i][k] == bg:
          grid = fill(grid, grid[i][j], {(i, k)})
        else:
          break
  return grid
 
30.666666666666668, tensor(0.0060), Description: For each row in the grid, if a cell is not the background color and the cell to its right is the background color, fill the cell to the right with the same color as the current cell. This effectively extends colored cells to the right until they encounter another non-background color. This is done for all rows in the grid. 
:: def bgfbfbhhchagecbdbcifacfhedeacedg(grid):
    for i, row in enumerate(grid):
        current_color = None
        for j, val in enumerate(row):
            if val != mostcolor(grid) and current_color is None:
                current_color = val
            elif current_color is not None and val == mostcolor(grid):
                grid = fill(grid, current_color, {(i, j)})
            else:
                current_color = None
    return grid
 
39.0, tensor(0.0280), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def degjhaafabbgefijbdjcbbeciffdiiij(grid):
  bg = mostcolor(grid)
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=True):
    for (i, j) in toindices(obj):
      if j < width(grid) - 1 and grid[i][j+1] == bg:
        grid = fill(grid, grid[i][j], shoot((i, j), RIGHT))
  return grid
 
37.333333333333336, tensor(0.0061), Description: For each row in the grid, if a cell is not the background color, extend the color of that cell to the right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. This is done for all rows in the grid. 
:: def bacedfjeefjgedaeijicfdcghbegaeda(grid):
    for i in range(len(grid)):
        for j in range(len(grid[0])):
            if grid[i][j] != mostcolor(grid):
                grid = fill(grid, grid[i][j], {(i, k) for k in range(j, len(grid[0])) if grid[i][k] == mostcolor(grid)})
    return grid
 
44.666666666666664, tensor(0.0471), Description: For each colored object in the input grid, fill all cells within the object's bounding box with the same color as the object. This effectively fills the interior of each object with its own color, leaving the background cells outside the objects unchanged. 
:: def ccjjjdffjcfbeeaejijdgcfchiaeddia(grid):
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=True):
    min_j = leftmost(obj)
    max_j = rightmost(obj)
    grid = fill(grid, color(obj), {(i, j) for i, j in product(range(height(grid)), range(min_j, max_j + 1)) if grid[i][j] == mostcolor(grid)})
  return grid
 
36.0, tensor(0.0283), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def faifbbbbhdaaefgabbfcbbbfajafbaac(I):
  O = I
  for obj in objects(I, True, False, True):
    _, (i, _) = first(obj)
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        O = fill(O, I[i][j], {(i, k) for k in range(j, width(I)) if index(O, (i, k)) == mostcolor(I)})
  return O
 
65.0, tensor(0.0124), Description: For each colored object in the input grid, extend it either horizontally to the right or vertically downwards, using the same color as the object. The extension direction is determined by the object's vertical position: if the object is in the top half of the grid, extend it horizontally to the right; if it is in the bottom half, extend it vertically downwards. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def hdjdcafbicdiecfdjfdibfhbibgbfbjc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    start_j = rightmost(obj) if uppermost(obj) < height(I) // 2 else 0
    start_i = lowermost(obj) if uppermost(obj) >= height(I) // 2 else 0
    for j in range(start_j, width(I)):
      O = paint(O, shift(obj, (0, j - rightmost(obj))))
    for i in range(start_i, height(I)):
      O = paint(O, shift(obj, (i - lowermost(obj), 0)))
  return O
 
26.333333333333332, tensor(0.0115), Description: For each colored object in the input grid, extend it either horizontally to the right or vertically downwards, using the same color as the object. The extension direction is determined by the object's vertical position: if the object is in the top half of the grid, extend it horizontally to the right; if it is in the bottom half, extend it vertically downwards. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def jefhfchaffdhedafiggfedehfhaeiebc(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if uppermost(obj) < height(I) // 2:
      O = fill(O, color(obj), connect(center(obj), (center(obj)[0], width(I) - 1)))
    else:
      O = fill(O, color(obj), connect(center(obj), (height(I) - 1, center(obj)[1])))
  return O
 
27.0, tensor(0.0124), Description: For each colored object in the input grid, extend it either horizontally to the right or vertically downwards, using the same color as the object. The extension direction is determined by the object's vertical position: if the object is in the top half of the grid, extend it horizontally to the right; if it is in the bottom half, extend it vertically downwards. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def ehfbdfgjidfbedbaibbafiibaaacdfje(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    target_j = width(I) - 1 if uppermost(obj) < height(I) // 2 else rightmost(obj)
    target_i = height(I) - 1 if uppermost(obj) >= height(I) // 2 else lowermost(obj)
    for j in range(rightmost(obj), target_j + 1):
      O = paint(O, shift(obj, (0, j - rightmost(obj))))
    for i in range(lowermost(obj), target_i + 1):
      O = paint(O, shift(obj, (i - lowermost(obj), 0)))
  return O
 
19.666666666666668, tensor(0.0248), Description: For each colored object in the input grid, if the object is in the top half of the grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the top half of the grid. The extended objects are then painted onto the original input grid. 
:: def biggfjeibeefedacbedbdicdhbebahic(I):
    O = I
    for obj in objects(I, T, F, T):
        if uppermost(obj) < height(I) // 2:  # Check if object is in top half
            for (i, j) in toindices(obj):
                O = paint(O, recolor(color(obj), connect((i, j), (i, width(I)-1))))
    return O
 
13.0, tensor(0.5982), Description: For each colored object in the input grid, if the object is in the top half of the grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. The number of cells to extend to the right should be equal to the number of cells in the object. This is done for all objects in the top half of the grid. The extended objects are then painted onto the original input grid. 
:: def hdgcjchbecggehaejideachifeeagecj(I):
  return paint(I, merge(apply(lambda obj: recolor(color(obj), mpapply(connect, toindices(obj), repeat((0, width(I) - 1), size(obj)))), sfilter(objects(I, T, F, T), lambda obj: uppermost(obj) < height(I) // 2)))) 
 
79.66666666666667, tensor(0.0270), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fgadcdbhedjheefdaheefebaabhfcacb(I):
  objs = objects(I, T, F, F)  # Identify all objects in the input grid
  O = I                      # Initialize the output grid
  for obj in objs:
    c = color(obj)           # Get the color of the current object
    rightmost_col = rightmost(obj)  # Find the rightmost column of the object
    for j in range(rightmost_col + 1, len(I[0])):  # Iterate from the next column to the grid edge
      next_loc = (uppermost(obj), j) 
      if index(I, next_loc) == mostcolor(I):  # Check if the next cell is background
        O = fill(O, c, frozenset({next_loc}))  # Fill the cell with the object color
      else:
        break                     # Stop extending if another object or grid edge is encountered
  return O
 
92.66666666666667, tensor(0.0044), Description: For each row in the input grid, if a cell is not the background color, fill the entire row from that cell to the right edge of the grid with the same color. This effectively creates horizontal stripes of the same color, extending outwards from the original colored cells. This is done for all rows in the grid. The extended objects are then painted onto a new grid initialized with the background color. 
:: def iaefbdabcdeaedejacgfjbeaeaeegiai(I):
    O = canvas(mostcolor(I), shape(I))  # Initialize output with background color
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != mostcolor(I):  # If not background
                O = fill(O, val, hfrontier((i, j)))  # Fill the row from current position
                break               # Move to the next row
    return O
 
75.66666666666667, tensor(0.0270), Description: For each colored object in the input grid, extend it horizontally to the right, using the same color as the object. The extension should stop when it encounters a non-background color. This is done for all objects in the grid. The extended objects are then painted onto the original input grid. 
:: def fdadjedeiadaebicbhdeffecfhacbhda(I):
  O = I
  for obj in objects(I, T, F, F):
    for (i, j) in toindices(obj):
      O = fill(O, I[i][j], frozenset({(i, k) for k in range(j, len(I[0]))}))
  return O
 
79.66666666666667, tensor(0.0064), Description: For each row in the input grid, if a cell is not the background color, extend the color of that cell to the right until it encounters another non-background color. This effectively creates horizontal lines of the same color, extending outwards from the original colored cells. This is done for all rows in the grid. The extended objects are then painted onto the original input grid. 
:: def beebcdagidceeideibdecbfbbbejdfaf(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        O = fill(O, I[i][j], frozenset({(i, k) for k in range(j, len(I[0]))}))
        break
  return O
 
74.33333333333333, tensor(0.0048), Description: For each row in the grid, if a cell is the background color and the cell to its left is not the background color, fill the current cell with the same color as the cell to its left. This effectively extends colored cells to the left until they encounter another non-background color. This is done for all rows in the grid. 
:: def dfdhjcadabeeeffdbeacbhfhcdiaceec(I):
    O = I
    for j in range(1, len(I[0])):
        for i in range(len(I)):
            if I[i][j-1] != mostcolor(I) and I[i][j] == mostcolor(I):
                O = fill(O, I[i][j-1], frozenset({(i, j)}))
    return O
 
835.6666666666666, tensor(1.2455), Description: Upscale the input grid by a factor of 5. Then, for each colored object in the upscaled grid, shift it based on its color. For example, if the color is 1, don't shift it. If the color is 3, shift it down by 16 squares and right by 12 squares. You can add more `elif` conditions for other colors and their corresponding shifts. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def edaibfhihcecebfhahjijdbeifbhcehe(I):
  O = upscale(I, 5) # Upscale the grid by a factor of 5
  for v in palette(I) - {mostcolor(I)}:
    for obj in colorfilter(objects(O, T, F, T), v):
      if v == 1:
        O = move(O, obj, (0, 0)) # No shift for color 1 
      elif v == 3: 
        O = move(O, obj, (16, 12))  # Shift down and right for color 3
      # Add more elif conditions for other colors and their shifts 
  return O
 
851.6666666666666, tensor(0.8367), Description: Upscale the input grid by a factor of 5. Then, for each colored object in the upscaled grid, paint it onto the output grid, potentially shifting it based on its color. For example, if the color is 1, don't shift it. If the color is 3, shift it down by 16 squares and right by 12 squares. You can add more `elif` conditions for other colors and their corresponding shifts. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def cecffdejfebfefgeicgdafhcfbedbbbe(I):
  O = canvas(mostcolor(I), multiply(shape(I), 5)) # Initialize upscaled canvas
  for obj in objects(I, T, F, T):
    v = color(obj) 
    upscaled_obj = upscale(obj, 5)
    if v == 1:
      O = paint(O, upscaled_obj) # No shift for color 1
    elif v == 3:
      O = paint(O, shift(upscaled_obj, (16,12))) # Shift for color 3
    # Add more elif conditions for other colors and their shifts 
  return O
 
76.33333333333333, tensor(1.2252), Description: Upscale the input grid by a factor of 2. Then, for each object in the upscaled grid, if the object's color is 3, move it down 3 rows and right 1 column. Additionally, apply specific conditions based on the color counts in the original input grid:

- If the original input grid has 6 light blue squares (color 1), introduce two new orange squares (color 6) at specific locations.
- If the original input grid has 6 orange squares (color 7), move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively.
- If the original input grid has 7 light blue squares (color 1), introduce a new light blue square at location (9, 9). 
:: def effbdaafgafiegfhihjbbfeicdcahjad(I):
  O = upscale(I, 2)  # Upscale the grid
  for obj in objects(O, T, F, F): # For each object in the upscaled grid
    if color(obj) == 3:  # Identify the object with color "3"
      O = move(O, obj, (3, 1)) # Move it down 3 rows and right 1 column
  if colorcount(I, 1) == 6: # Condition specific to input 0
    # Introduce two new "6" objects
    O = paint(O, recolor(6, {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)}))
  elif colorcount(I, 7) == 6: # Condition specific to input 1
    # Move the "8" objects horizontally
    O = move(O, toobject(O, {(0, 6), (1, 6)}), (0, 2))
    O = move(O, toobject(O, {(6, 8), (7, 8)}), (0, 6))
  elif colorcount(I, 1) == 7: # Condition specific to input 2
    # Introduce a new "1" object
    O = paint(O, recolor(1, {(9, 9)}))
  return O 
 
74.66666666666667, tensor(1.2252), Description: Upscale the input grid by a factor of 2. Then, for each object in the upscaled grid, if the object's color is 3, move it down 3 rows and right 1 column. Additionally, apply specific conditions based on the color counts in the original input grid:

- If the original input grid has 6 light blue squares (color 1), introduce two new orange squares (color 6) at specific locations.
- If the original input grid has 6 orange squares (color 7), move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively.
- If the original input grid has 7 light blue squares (color 1), introduce a new light blue square at location (9, 9). 
:: def cechgjhdeaceeibfbdfeecjcjgecibea(I):
  O = upscale(I, 2) # Upscale grid
  target_color = 3  # Color of the object to be moved
  for obj in objects(O, T, F, F):
    if color(obj) == target_color:
      if colorcount(I, 1) == 6:
        O = move(O, obj, (3, 1))  
        O = paint(O, recolor(6, {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)}))
      elif colorcount(I, 7) == 6:
        O = move(O, obj, (2, 3))
        for obj2 in objects(O, T, F, F):
          if color(obj2) == 8:
            if uppermost(obj2) == 0 and leftmost(obj2) == 6:
              O = move(O, obj2, (0, 2))
            elif uppermost(obj2) == 6 and leftmost(obj2) == 8:
              O = move(O, obj2, (0, 6)) 
      elif colorcount(I, 1) == 7:
        O = move(O, obj, (5, 1))
        O = paint(O, recolor(1, {(9, 9)}))
  return O
 
21.333333333333332, tensor(0.0062), Description: 
Copy the input grid. For the first object, mirror it horizontally and shift it down 5 rows and right 4 columns. For the second object, shift it up 2 rows and right 3 columns. For the third object, replace the existing colors with the color of the object, placing the new colors at specific locations: (3, 3), (3, 4), (6, 6), (6, 7), and (7, 6). 
:: def ehbfbjbibdececfcaefgcddhijbcebhf(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T) 
    new_grid = canvas(bg, (10, 10))
    for i, obj in enumerate(objs):
        c = color(obj)
        if i == 0:
            new_obj = shift(hmirror(obj), (5, 4)) 
        elif i == 1:
            new_obj = shift(obj, (-2, 3)) 
        else:
            new_obj = recolor(c, {(3, 3), (3, 4), (6, 6), (6, 7), (7, 6)})
        new_grid = paint(new_grid, new_obj)
    return new_grid
 
22.333333333333332, tensor(0.0084), Description:
Copy the input grid. For the largest object, mirror it horizontally and shift it down 5 rows and right 4 columns. For the second largest object, shift it up 2 rows and right 3 columns. For all remaining objects, replace the existing colors with the color of the object, placing the new colors in the 7th column, from row 6 to 9. 
:: def becbaffbdjeiegfabccgfbbcjfdjdfab(I):
  bg = mostcolor(I)
  objs = sorted(objects(I, T, F, T), key=lambda obj: -len(obj)) 
  new_grid = canvas(bg, (10, 10))
  for i, obj in enumerate(objs):
    if i == 0:
      new_grid = paint(new_grid, shift(hmirror(obj), (5, 4))) 
    elif i == 1:
      new_grid = paint(new_grid, shift(obj, (-2, 3)))
    else:
      new_obj = recolor(color(obj), {(j, 6) for j in range(6, 10)})
      new_grid = paint(new_grid, new_obj) 
  return new_grid
 
22.666666666666668, tensor(0.0095), Description:
Copy the input grid. For objects with more than one pixel, shift them up 2 rows and right 3 columns. For objects with a single pixel and color 1 (light blue), mirror them horizontally and shift them down 5 rows and right 4 columns. For all other single-pixel objects, replace the existing colors with the color of the object, placing the new colors in the 7th column, from row 6 to 9. 
:: def jcdjaiaddjeeebgdihjcaeiecfhdacgf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  new_grid = canvas(bg, (10, 10))
  for i, obj in enumerate(objs):
    if len(obj) > 1:
      new_grid = paint(new_grid, shift(obj, (-2, 3))) 
    elif color(obj) == 1:
      new_grid = paint(new_grid, shift(hmirror(obj), (5, 4))) 
    else:
      new_obj = recolor(color(obj), {(j, 6) for j in range(6, 10)})
      new_grid = paint(new_grid, new_obj) 
  return new_grid
 
22.0, tensor(0.0259), Description:
Copy the input grid. For the first colored object, mirror it horizontally and shift it down 5 rows and right 4 columns. For the second colored object, shift it up 2 rows and right 3 columns. For the remaining space in the 7th column, from row 6 to 9, fill it with orange (color 6). 
:: def ebbegdeaeefdeicejffajhdbjdebicci(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  new_grid = canvas(bg, (10, 10))
  obj_idx = 0
  for obj in objs:
    if color(obj) != bg:
      if obj_idx == 0: 
        new_grid = paint(new_grid, shift(hmirror(obj), (5, 4)))
      elif obj_idx == 1: 
        new_grid = paint(new_grid, shift(obj, (-2, 3)))
      obj_idx += 1
  new_obj = recolor(6, {(j, 6) for j in range(6, 10)}) 
  new_grid = paint(new_grid, new_obj)
  return new_grid
 
75.33333333333333, tensor(0.0083), Description:
Copy the input grid and double its width. Then, take the largest colored object in the input grid and place it in the top left corner of the output grid. Place a copy of the same object in the top right corner of the output grid. 
:: def hbdadcjbfecfeffjbfceecibbjedjeba(I):
  obj1 = argmax(objects(I, F, T, T), size)
  
  O = canvas(mostcolor(I), shape(hconcat(I, I))) # Canvas size based on horizontal concatenation
  O = paint(O, shift(obj1, (0, 0)))
  O = paint(O, shift(obj1, (0, width(I)))) # Paint a copy with horizontal offset

  return O
 
75.33333333333333, tensor(0.5447), Description: Upscale the input grid by a factor of 2. This means each cell in the input grid will be expanded into a 2x2 block in the output grid, maintaining the same color. 
:: def acaificdfeicecehaijffchfdbfjghec(grid):
  return upscale(grid, 2)
 
857.0, tensor(1.2511), Description: Upscale the input grid by a factor of 5. Then, for each colored object in the upscaled grid, upscale it by a factor of 5 and potentially shift it based on its color. If the color is 1, don't shift it. If the color is 3, shift it down by 4 squares and right by 3 squares. If the color is 8, shift it down by 1 square and right by 2 squares. Keep other objects unchanged. Finally, add a new object with color 6 at specific locations: (3, 3), (4, 3), and (5, 3). The output grid will contain the upscaled input grid with each colored object shifted according to its color and a new object with color 6 added. 
:: def ejcbfeacdeaeedehbegegadbecfccfcf(I):
  O = canvas(mostcolor(I), multiply(shape(I), 5))  # Create upscaled canvas
  for obj in objects(I, T, F, T):
    v = color(obj)
    if v == 1:
      shifted_obj = upscale(obj, 5)  # Upscale without shifting
    elif v == 3:
      shifted_obj = shift(upscale(obj, 5), (4, 3))  # Upscale and shift
    elif v == 8:
      shifted_obj = shift(upscale(obj, 5), (1, 2))  # Upscale and shift
    else:
      shifted_obj = obj  # Keep other objects unchanged
    O = paint(O, shifted_obj)  # Paint the object on the canvas
  O = paint(O, recolor(6, {(3, 3), (4, 3), (5, 3)})) # Add new object with color 6
  return O
 
838.0, tensor(1.2127), Description: Upscale the input grid by a factor of 5. Then, for each colored object in the upscaled grid, upscale it by a factor of 5 and potentially shift it based on its color. If the color is 3, shift it down by 4 squares and right by 3 squares. If the color is 8, shift it down by 1 square and right by 2 squares. Keep other objects unchanged. Finally, add a new object with color 6 at specific locations: (3, 3), (4, 3), and (5, 3). The output grid will contain the upscaled input grid with each colored object shifted according to its color and a new object with color 6 added. 
:: def cgdefheiicafeefdafegfegacefafjij(I):
  O = canvas(mostcolor(I), multiply(shape(I), 5))
  for v in palette(I) - {mostcolor(I)}:
    for i, j in ofcolor(I, v):
      O = paint(O, recolor(v, {(i * 5 + a, j * 5 + b) for a in range(5) for b in range(5)})) # Upscale and recolor
      if v == 3:
        O = move(O, recolor(v, {(i * 5 + a, j * 5 + b) for a in range(5) for b in range(5)}), (4, 3)) # Move upscaled object
      elif v == 8:
        O = move(O, recolor(v, {(i * 5 + a, j * 5 + b) for a in range(5) for b in range(5)}), (1, 2)) # Move upscaled object
  O = paint(O, recolor(6, {(3, 3), (4, 3), (5, 3)})) # Add new object with color 6
  return O
 
866.0, tensor(1.2127), Description: Upscale the input grid by a factor of 5. Then, for each colored object in the upscaled grid, upscale it by a factor of 5 and potentially shift it based on its color. If the color is 3, shift it down by 4 squares and right by 3 squares. If the color is 8, shift it down by 1 square and right by 2 squares. Keep other objects unchanged. Finally, add a new object with color 6 at specific locations: (3, 3), (4, 3), and (5, 3). The output grid will contain the upscaled input grid with each colored object shifted according to its color and a new object with color 6 added. 
:: def cgbghdagfbicedbjjejcdcdhbfjiidee(I):
  O = canvas(mostcolor(I), multiply(shape(I), 5))
  for obj in objects(I, T, F, T):
    v = color(obj)
    upscaled_obj = upscale(obj, 5)
    if v == 3:
      O = paint(O, shift(upscaled_obj, (4, 3)))
    elif v == 8:
      O = paint(O, shift(upscaled_obj, (1, 2)))
    else:
      O = paint(O, upscaled_obj)
  O = paint(O, recolor(6, {(i, 3) for i in range(3, 6)})) # Add new object with color 6
  return O
 
34.0, tensor(0.0937), Description: Upscale the input grid by a factor of 2. For objects with color 1 (light blue), upscale them by a factor of 2 and shift them down 3 rows. Also, upscale a new object with color 6 (orange) and shift it down 4 rows. For objects with color 3 (yellow), upscale them by a factor of 2 and shift them right 4 columns. For all other objects, simply upscale them by a factor of 2. 
:: def cgdcfihhfejeecfbjbaedejffhbccfec(I):
  O = canvas(mostcolor(I), (10, 10))
  for obj in objects(I, T, F, T):
    c = color(obj)
    if c == 1:
      O = paint(O, upscale(shift(obj, (3, 0)), 2)) 
      O = paint(O, upscale(recolor(6, shift(obj, (4, 0))), 2))
    elif c == 3:
      O = paint(O, upscale(shift(obj, (1, 4)), 2))
    else:
      O = paint(O, upscale(obj, 2)) 
  return O
 
19.0, tensor(0.3053), Description: Upscale the input grid by a factor of 2. For each cell in the input grid, if the cell is light blue (color 1), place a light blue square at the corresponding location in the upscaled grid and an orange square (color 6) two rows below it. If the cell is yellow (color 3), place a yellow square at the corresponding location in the upscaled grid and shift it right 8 columns. For all other colors, simply place a square of the same color at the corresponding location in the upscaled grid. 
:: def fbaaejbffagiedbfjicdhacgfadfcedb(I):
  O = canvas(mostcolor(I), (10, 10))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        if val == 1:
          O = fill(O, val, {(i * 2 + 6, j * 2)})
          O = fill(O, 6, {(i * 2 + 8, j * 2)})
        elif val == 3:
          O = fill(O, val, {(i * 2 + 2, j * 2 + 8)})
        else:
          O = fill(O, val, {(i * 2, j * 2)})
  return O
 
67.33333333333333, tensor(0.4125), Description: Upscale the input grid by a factor of 2. For each colored object in the input grid, upscale it by a factor of 2 and paint it onto the output grid. If the object's color is 1 (light blue), also upscale a copy of the object and shift it down 6 rows. Additionally, upscale a new object with color 6 (orange) and shift it down 8 rows. If the object's color is 3 (yellow), upscale it by a factor of 2 and shift it right 8 columns. For all other colors, simply upscale the object by a factor of 2. 
:: def fbiiaaaddjfieeeeicgbecbddgdigjgi(I):
  O = upscale(canvas(mostcolor(I), shape(I)), 2)
  for obj in objects(I, T, F, T):
    v = color(obj)
    O = cover(O, upscale(obj, 2))
    if v == 1: 
      O = paint(O, shift(upscale(obj, 2), (6, 0)))
      O = paint(O, recolor(6, shift(upscale(obj, 2), (8, 0))))
    elif v == 3:
      O = paint(O, shift(upscale(obj, 2), (2, 8)))
    else:
      O = paint(O, obj)
  return O
 
63.0, tensor(0.3053), Description: Upscale the input grid by a factor of 2. For each cell in the input grid, if the cell is light blue (color 1), place a light blue square at the corresponding location in the upscaled grid and an orange square (color 6) two rows below it. If the cell is yellow (color 3), place a yellow square at the corresponding location in the upscaled grid and shift it right 8 columns. For all other colors, simply place a square of the same color at the corresponding location in the upscaled grid. 
:: def bacbjcbcbicdeecajajbifgedheaibfb(I):
  O = upscale(canvas(mostcolor(I), (len(I), len(I[0]))), 2)
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != mostcolor(I):
        if v == 1:
          O = fill(O, v, {(2*i + 6, 2*j), (2*i + 8, 2*j)})
        elif v == 3:
          O = fill(O, v, {(2*i + 2, 2*j + 8)})
        else:
          O = fill(O, v, {(2*i, 2*j)})
  return O
 
36.0, tensor(0.1041), Description: Upscale the input grid by a factor of 2. For objects with color 1 (light blue), upscale them by a factor of 2 and shift them down 6 rows. Also, upscale a new object with color 6 (orange) and place it at the same location as the light blue object. For objects with color 3 (yellow), upscale them by a factor of 2 and shift them right 4 columns. For all other objects, simply upscale them by a factor of 2. 
:: def hdfaaicabgedeeeeafddgafhaacfcibf(I):
  O = canvas(mostcolor(I), (10, 10))
  for obj in objects(I, T, F, T):
    if color(obj) == 1:
      O = paint(O, shift(upscale(obj, 2), (6, 0)))
      O = paint(O, upscale(recolor(6, obj), 2))
    else:
      O = paint(O, upscale(shift(obj, (1 if color(obj) == 3 else 0, 4 if color(obj) == 3 else 0)), 2))
  return O
 
94.33333333333333, tensor(0.6484), Description: Downscale the input grid horizontally by a factor of 6. For each object in the input grid, if the object's color is 3 (yellow), move it down 3 rows. If the object's color is 8 (dark blue), move it right 1 column. Finally, add a new object with color 6 (orange) at specific locations: (3, 8), (6, 7), (7, 6), (8, 5), and (9, 4). 
:: def cafjeebicdgaegchbaefeajiahfdcffj(I):
  O = canvas(mostcolor(I), (height(I), width(I) // 6)) # Downscale horizontally by 6
  for v in palette(I) - {mostcolor(I)}:
    for obj in objects(I, T, F, T):
      if color(obj) == v:
        if v == 3:
          O = paint(O, shift(recolor(v, toindices(obj)), (3, 0))) # Move down by 3 units
        elif v == 8:
          O = paint(O, shift(recolor(v, toindices(obj)), (0, 1))) # Move right by 1 unit
  O = paint(O, recolor(6, {(3, 8), (6, 7), (7, 6), (8, 5), (9, 4)})) # Add new object
  return O
 
94.0, tensor(0.6484), Description: Downscale the input grid horizontally by a factor of 6. For each object in the input grid, if the object's color is 3 (yellow), move it down 3 rows. If the object's color is 8 (dark blue), move it right 1 column. Finally, add a new object with color 6 (orange) at specific locations: (3, 8), (6, 7), (7, 6), (8, 5), and (9, 4). 
:: def cbfafeaieabdecjejejabhefechieebe(I):
  O = hsplit(I, 6)[0] # Downscale horizontally by 6
  for obj in objects(I, T, F, T):
    if color(obj) == 3:
      O = paint(O, shift(obj, (3, 0))) # Move down by 3 units
    elif color(obj) == 8:
      O = paint(O, shift(obj, (0, 1))) # Move right by 1 unit
  O = paint(O, recolor(6, {(3, 8), (6, 7), (7, 6), (8, 5), (9, 4)})) # Add new object
  return O
 
99.0, tensor(0.6484), Description: Downscale the input grid horizontally by a factor of 6. For each object in the input grid, if the object's color is 3 (yellow), move it down 3 rows. If the object's color is 8 (dark blue), move it right 1 column. Finally, add a new object with color 6 (orange) at specific locations: (3, 8), (6, 7), (7, 6), (8, 5), and (9, 4). 
:: def jgieeadcaacbegfjiegegbddjhbhbcbc(I):
    O = downscale(I, 6) # Downscale horizontally by 6
    for v in palette(I) - {mostcolor(I)}:
        for obj in objects(I, T, F, T):
            if color(obj) == v:
                if v == 3:
                    O = underpaint(O, shift(recolor(v, toindices(obj)), (3, 0))) # Move down by 3 units
                elif v == 8:
                    O = underpaint(O, shift(recolor(v, toindices(obj)), (0, 1))) # Move right by 1 unit
    O = paint(O, recolor(6, {(3, 8), (6, 7), (7, 6), (8, 5), (9, 4)})) # Add new object
    return O
 
77.66666666666667, tensor(1.2252), Description: Upscale the input grid by a factor of 2. Then, for each object in the upscaled grid, if the object's color is 3, move it down 3 rows and right 1 column. Additionally, apply specific conditions based on the color counts in the original input grid:

- If the original input grid has 6 light blue squares (color 1), introduce two new orange squares (color 6) at specific locations.
- If the original input grid has 6 orange squares (color 7), move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively.
- If the original input grid has 7 light blue squares (color 1), introduce a new light blue square at location (9, 9). 
:: def edgaiffccheceajejjhebdchbfiddbab(I):
  O = upscale(I, 2)
  three_indices = ofcolor(O, 3) # Get indices of '3's
  if colorcount(I, 1) == 6:
    O = fill(O, 0, shift(three_indices, (3, 1))) # Move by filling old location and painting new one
    O = paint(O, recolor(3, shift(three_indices, (3, 1)))) 
    O = paint(O, recolor(6, {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)}))
  elif colorcount(I, 7) == 6:
    O = fill(O, 0, shift(three_indices, (2, 3)))
    O = paint(O, recolor(3, shift(three_indices, (2, 3))))
    for i, obj in enumerate(colorfilter(objects(O, True, False, False), 8)):
      O = move(O, obj, (0, 2 + i * 4))
  elif colorcount(I, 1) == 7:
    O = fill(O, 0, shift(three_indices, (5, 1)))
    O = paint(O, recolor(3, shift(three_indices, (5, 1))))
    O = paint(O, recolor(1, {(9, 9)}))
  return O 
 
77.0, tensor(1.7352), Description: Upscale the input grid by a factor of 2. Then, based on the color count in the original input grid, perform specific actions:

- If the original input grid has 6 light blue squares (color 1), introduce two new orange squares (color 6) at specific locations and directly paint a yellow object (color 3) at a new location.
- If the original input grid has 6 orange squares (color 7), move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively and directly paint a yellow object (color 3) at a new location.
- If the original input grid has 7 light blue squares (color 1), introduce a new light blue square at location (9, 9) and directly paint a yellow object (color 3) at a new location. 
:: def gccigedcbeebeccaiefeheefaaiffecd(I):
  O = upscale(I, 2)
  if colorcount(I, 1) == 6:
    O = paint(O, recolor(6, {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)}))
    O = paint(O, recolor(3, {(3, 2), (3, 3), (4, 2), (4, 3)})) # Directly paint the '3' object at the new location
  elif colorcount(I, 7) == 6:
    for i, obj in enumerate(colorfilter(objects(O, True, False, False), 8)):
      O = move(O, obj, (0, 2 + i * 4))
    O = paint(O, recolor(3, {(5, 5), (5, 6), (6, 5), (6, 6)})) # Directly paint the '3' object
  elif colorcount(I, 1) == 7:
    O = paint(O, recolor(1, {(9, 9)}))
    O = paint(O, recolor(3, {(6, 7), (6, 8), (7, 7), (7, 8)})) # Directly paint the '3' object
  return O
 
21.666666666666668, tensor(1.9815), Description: 
Copy the input grid and resize it to 10x10. Find the largest object in the input grid and place it at the bottom of the output grid. Then, for each remaining object in the input grid, place it at a specific location in the output grid based on its color and the number of objects of that color in the input grid. The placement coordinates are defined in a dictionary `placement_coords`. For example, if the object's color is 3 and there are 3 objects of color 3 in the input grid, the object will be placed at coordinates (3, 2) in the output grid. If the object's color is 8 and there are 4 objects of color 8 in the input grid, the object will be placed at coordinates (2, 6) in the output grid. If the object's color is 1 and there are 3 objects of color 1 in the input grid, the object will be placed at coordinates (6, 4) in the output grid. 
:: def jfdcididebjhebjgicdfiidcfbfhbabd(I):
  objs = objects(I, F, T, T)
  largest = argmax(objs, size)
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))

  # Define placement coordinates for each input
  placement_coords = {
      3: {
          (0, 0): (3, 2), 
          (0, 1): (3, 3), 
          (1, 0): (0, 0),
          (1, 1): (7, 6),
          (1, 2): (2, 0),
          (1, 3): (9, 8),
          (1, 4): (4, 0),
          (1, 5): (11, 10),
          (1, 6): (6, 0),
          (1, 7): (13, 12)
      },
      8: {
          (0, 0): (2, 6),
          (0, 1): (2, 7),
          (1, 0): (0, 6),
          (1, 1): (2, 6),
          (1, 2): (4, 6),
          (1, 3): (6, 9)
      },
      1: {
          (2, 0): (6, 4),
          (2, 1): (7, 4),
          (2, 2): (5, 9) 
      }
  }
  
  O = paint(O, shift(largest, (height(O) - height(largest), 0)))
  
  for i, obj in enumerate(objs):
    if obj != largest:
      c = color(obj)
      for key, coords in placement_coords.get(c, {}).items():
        if key[0] == colorcount(I, c) or (colorcount(I, c) > 2 and key[0] == 0):
          O = paint(O, shift(obj, coords))
          
  return O 
 
74.33333333333333, tensor(0.0899), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 1 row and right 1 column. If the object's color is 6, shift it down 2 rows. If the object's color is 8, shift it down 3 rows and right 1 column. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def gjjfcgebheaieifbjaabeajcifbbhidf(I):
  O = upscale(I, 2) 
  for v in palette(I) - {mostcolor(I)}:
    obj = first(colorfilter(objects(O,T,F,T),v))
    if v == 3:
      O = paint(cover(O,obj),shift(obj,(1,1)))
    elif v == 6:
      O = paint(cover(O,obj),shift(obj,(2,0)))
    elif v == 8:
      O = paint(cover(O,obj),shift(obj,(3,1)))
  return O
 
66.0, tensor(0.1371), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 1 row and right 1 column. If the object's color is 6, shift it down 2 rows. If the object's color is 8, shift it down 3 rows and right 1 column. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def dffdibdfbdagejhhbdbgjbeaeadbacha(I):
  O = canvas(mostcolor(I), (height(I)*2, width(I)*2))
  for v in palette(I) - {mostcolor(I)}:
    obj = first(colorfilter(objects(upscale(I,2),T,F,T),v))
    if v == 3:
      O = paint(O, shift(obj, (1, 1)))
    elif v == 6:
      O = paint(O, shift(obj, (2, 0)))
    elif v == 8:
      O = paint(O, shift(obj, (3, 1)))
    else:
      O = paint(O, obj)
  return O
 
74.33333333333333, tensor(0.0899), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 1 row and right 1 column. If the object's color is 6, shift it down 2 rows. If the object's color is 8, shift it down 3 rows and right 1 column. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def ffccadhfcaieefecbffcecdeeedgfjfd(I):
  O = upscale(I, 2)
  shifts = {3: (1, 1), 6: (2, 0), 8: (3, 1)}
  for v, offset in shifts.items():
    for obj in colorfilter(objects(O, T, F, T), v):
      O = paint(cover(O, obj), shift(obj, offset))
  return O 
 
74.33333333333333, tensor(0.0935), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 3, shift it down 1 row and right 1 column. If the color is 6, shift it down 2 rows. If the color is 8, shift it down 3 rows and right 1 column. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def edfaddcddjjaedheibbbeghacbjebfee(I):
  O = upscale(I, 2)
  for obj in objects(O, T, F, T):
    v = color(obj)
    offset = {3: (1, 1), 6: (2, 0), 8: (3, 1)}.get(v, (0, 0))
    O = paint(cover(O, obj), shift(obj, offset))
  return O
 
73.0, tensor(0.0181), Description: Upscale the input grid by a factor of 2. Then, based on the color count in the original input grid, perform specific actions:

- If the original input grid has 6 light blue squares (color 1), move the yellow object (color 3) down 3 rows and right 1 column. Introduce two new orange squares (color 6) at specific locations and move the light blue object in the second row to the left by 2 columns.
- If the original input grid has 6 orange squares (color 7), move the yellow object (color 3) down 2 rows and right 3 columns. Move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively.
- If the original input grid has 7 light blue squares (color 1), move the yellow object (color 3) down 6 rows. Move the light blue object in the first column to the right by 9 columns. 
:: def bgceabffefbcecgcicfcicfcjdcgfdbe(I):
  O = upscale(I, 2)
  threes = argmax(objects(O, True, False, False), lambda obj: color(obj) == 3)
  if colorcount(I, 1) == 6:
    O = move(O, threes, (3, 1))
    O = paint(O, recolor(6, frozenset((6, (i, j)) for i, j in {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)})))
    O = move(O, argmax(objects(O, True, False, False), lambda obj: color(obj) == 1 and uppermost(obj) == 2), (2, 0))
  elif colorcount(I, 7) == 6:
    O = move(O, threes, (2, 3))
    for i, obj in enumerate(sorted(colorfilter(objects(O, True, False, False), 8), key=lambda obj: uppermost(obj))):
      O = move(O, obj, (0, 2 + i * 4))
  elif colorcount(I, 1) == 7:
    O = move(O, threes, (6, 0))
    O = move(O, argmax(objects(O, True, False, False), lambda obj: color(obj) == 1 and leftmost(obj) == 0), (0, 9))
  return O
 
77.33333333333333, tensor(0.0865), Description: Upscale the input grid horizontally by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 1 row and right 1 column. If the object's color is 6, shift it right 2 columns. If the object's color is 8, shift it down 1 row. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def bfjabeieagigeecfaidhefaijbdbgjhc(I):
  O = hupscale(I, 2) # Upscale horizontally by 2
  for obj in objects(O, T, F, T):
    v = color(obj)
    if v == 3:
      O = paint(cover(O, obj), shift(obj, (1, 1))) # Shift '3' diagonally down-right
    elif v == 6:
      O = paint(cover(O, obj), shift(obj, (0, 2))) # Shift '6' two cells right
    elif v == 8:
      O = paint(cover(O, obj), shift(obj, (1, 0))) # Shift '8' one cell down
  return O
 
77.0, tensor(0.0595), Description: Upscale the input grid horizontally by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 3, shift it down 1 row and right 1 column. If the color is 6, shift it right 2 columns. If the color is 8, shift it down 1 row. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def dcfgddieabhiecfgiabghbefjbcacbfe(I):
  O = hupscale(I, 2) 
  for v, offset in {(3, (1, 1)), (6, (0, 2)), (8, (1, 0))}: # Define shifts
    for obj in colorfilter(objects(O, T, F, T), v): # Filter by color
      O = paint(cover(O, obj), shift(obj, offset)) # Apply shift
  return O
 
77.0, tensor(0.0679), Description: Duplicate each row of the input grid, effectively doubling its height. Then, for each colored object in the output grid, shift it based on its color. If the color is 3, shift it down 1 row and right 1 column. If the color is 6, shift it down 2 rows. If the color is 8, shift it down 1 row. For all other colors, keep the object in its original position. The output grid will contain the original input grid with each colored object shifted according to its color and with each row duplicated. 
:: def fdddeffacabjeicfbeaefbagbbdidgec(I):
  O = I
  for i in range(len(I)):
    O = vconcat(O, I[i:i+1]) # Duplicate each row
  for obj in objects(O, T, F, T):
    v = color(obj)
    O = paint(cover(O, obj), shift(obj, {3: (1, 1), 6: (2, 0), 8: (1, 0)}.get(v, (0, 0)))) # Shift based on color
  return O
 
73.66666666666667, tensor(0.0902), Description: Upscale the input grid horizontally by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 3, shift it down 1 row and right 1 column. If the color is 6, shift it right 2 columns. If the color is 8, shift it down 1 row. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def faeefdcfcbfeeageidifeeadjdcdfdbd(I):
  O = canvas(0, (len(I), len(I[0]) * 2)) # Create empty upscaled canvas
  for obj in objects(I, T, F, T):
    v = color(obj)
    offset = {3: (1, 1), 6: (2, 0), 8: (1, 0)}.get(v, (0, 0))
    O = underpaint(O, shift(obj, (0, leftmost(obj) * 2 + offset[1]))) # Paint with shift onto canvas
  return O
 
20.666666666666668, tensor(0.0123), Description:
Copy the input grid and resize it to 10x10. Find the largest object in the input grid and place it at the bottom of the output grid. Then, based on the colors present in the input grid, perform specific actions:

- **Input 0:** If the input contains both color 3 (yellow) and color 6 (orange), place two copies of the yellow object vertically stacked above the largest object, shifted 2 columns to the right. Then, place two copies of the orange object, one at the top and one at the bottom of the output grid, with a horizontal offset of 6 columns between them.
- **Input 1:** If the input contains color 8 (dark blue), place two copies of the largest dark blue object horizontally stacked, shifted 6 columns to the right. Then, place the remaining dark blue objects vertically stacked on the left side of the output grid. Finally, place the smallest dark blue object at the bottom of the output grid, shifted 6 columns to the right. Place two copies of the yellow object horizontally stacked, shifted 6 columns to the right and 3 rows above the largest dark blue object.
- **Input 2:** If the input contains color 3 (yellow), place two copies of the yellow object horizontally stacked, shifted 4 columns to the right and placed above the largest object. 
:: def adcahaicdbdaeeebbfejcehfbgecgbbc(I):
    objs = objects(I, F, T, T)
    largest = argmax(objs, size)
    bg = mostcolor(I)
    O = canvas(bg, (10, 10))

    O = paint(O, shift(largest, (height(O) - height(largest), 0)))

    if any(color(o) == 3 for o in objs):  # Input 0
        three = next((o for o in objs if color(o) == 3), None)
        six = next((o for o in objs if color(o) == 6), None)
        if three and six:
            O = paint(O, shift(vconcat(three, three), (height(O) - 2 * height(three) - height(largest), 2)))
            for i in range(2):
                O = paint(O, shift(six, (i * 7, i * 6)))
                O = paint(O, shift(six, (i * 7, height(O) - height(six) - i * 6)))
    elif any(color(o) == 8 for o in objs):  # Input 1
        eights = sorted((o for o in objs if color(o) == 8), key=size)
        three = next((o for o in objs if color(o) == 3), None)
        if three:
            O = paint(O, shift(hconcat(eights[-1], eights[-1]), (2, 6)))
            O = paint(O, shift(vconcat(*eights[:-1]), (0, 8)))
            O = paint(O, shift(eights[0], (6, height(O) - height(eights[0]))))
            O = paint(O, shift(hconcat(three, three), (3, 6)))
    else:  # Input 2
        threes = [o for o in objs if color(o) == 3]
        if threes:
            O = paint(O, shift(hconcat(*threes), (height(O) - height(threes[0]), 4)))

    return O
 
77.66666666666667, tensor(0.0185), Description: Upscale the input grid by a factor of 2. For objects with color 3 (yellow), shift them down 1 row and right 1 column. For objects with color 6 (orange), shift them right 2 columns. If an orange object is located in the left half of the grid, shift it right by 6 columns. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def daefcfchibggefceidddceedddgafdii(I):
    O = hupscale(I, 2)
    for v, (di, dj) in {(3, (1, 1)), (6, (0, 2))}:
      for obj in colorfilter(objects(O, T, F, T), v):
        O = paint(cover(O, obj), shift(obj, (di, dj)))
    for obj in colorfilter(objects(O, T, F, T), 6):
      if leftmost(obj) < 5:
        O = paint(cover(O, obj), shift(obj, (0, 6))) 
    return O
 
78.33333333333333, tensor(0.0185), Description: Upscale the input grid by a factor of 2. For objects with color 3 (yellow), shift them down 1 row and right 1 column. For objects with color 6 (orange), shift them right 2 columns. If an orange object is located in the left half of the grid, shift it right by 6 columns. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def gceajcefacfjedcdajiabbfahegcffac(I):
    O = hupscale(I, 2)
    shifts = {3: [(1, 1)], 6: [(0, 2), (0, 6)]}
    for v, offsets in shifts.items():
      objs = colorfilter(objects(O, T, F, T), v)
      for obj, (di, dj) in zip(objs, offsets):
        O = paint(cover(O, obj), shift(obj, (di, dj)))
    return O
 
71.33333333333333, tensor(0.0391), Description: Upscale the input grid by a factor of 2. For objects with color 3 (yellow), upscale them by a factor of 2 and shift them down 1 row and right 1 column. For objects with color 6 (orange), upscale them by a factor of 2 and shift them right 2 columns if they are in the left half of the grid, and shift them right 6 columns if they are in the right half of the grid. For all other objects, simply upscale them by a factor of 2. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def ffacebdadcfaefdgaefdehceeajjabea(I):
    O = canvas(mostcolor(I), (height(I)*2, width(I)*2))
    for v in palette(I) - {mostcolor(I)}:
        for obj in colorfilter(objects(I, T, F, T), v):
            if v == 3:
                O = paint(O, shift(upscale(obj, 2), (1, 1)))
            elif v == 6 and leftmost(obj) < width(I)//2:
                O = paint(O, shift(upscale(obj, 2), (0, 2)))
            elif v == 6 and leftmost(obj) >= width(I)//2:
                O = paint(O, shift(upscale(obj, 2), (0, 6)))
            else:
                O = paint(O, upscale(obj, 2))
    return O
 
78.0, tensor(0.0152), Description: Upscale the input grid by a factor of 2. For objects with color 3 (yellow), shift them down 1 row and right 1 column. For objects with color 6 (orange), shift them right 2 columns if they are in the left half of the grid, and shift them right 6 columns if they are in the right half of the grid. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def jgbfeghefefdeeeeaajaececfedccgjf(I):
    O = hupscale(I, 2)
    for obj in objects(O, T, F, T):
        v = color(obj)
        if v == 3:
            O = paint(cover(O, obj), shift(obj, (1, 1)))
        elif v == 6:
            if leftmost(obj) < 5:
                O = paint(cover(O, obj), shift(obj, (0, 2)))
            else:
                O = paint(cover(O, obj), shift(obj, (0, 6)))
    return O
 
76.33333333333333, tensor(1.7352), Description: Upscale the input grid by a factor of 2. Then, based on the color count in the original input grid, perform specific actions:

- If the original input grid has 6 light blue squares (color 1), introduce two new orange squares (color 6) at specific locations and directly paint a yellow object (color 3) at a new location.
- If the original input grid has 6 orange squares (color 7), move the two existing dark blue squares (color 8) horizontally by 2 and 6 columns respectively and directly paint a yellow object (color 3) at a new location.
- If the original input grid has 7 light blue squares (color 1), introduce a new light blue square at location (9, 9) and directly paint a yellow object (color 3) at a new location. 
:: def ifeccfgbabdbeegdbbecehabfgacieac(I):
  O = upscale(I, 2)
  three_indices = ofcolor(O, 3)
  if colorcount(I, 1) == 6:
    O = fill(O, 0, three_indices)
    O = paint(O, recolor(3, shift(three_indices, (3, 1))))
    O = paint(O, recolor(6, {(1, 8), (2, 8), (5, 0), (6, 0), (7, 0), (7, 6)}))
  elif colorcount(I, 7) == 6:
    O = fill(O, 0, three_indices)
    O = paint(O, recolor(3, shift(three_indices, (2, 3))))
    for i, obj in enumerate(colorfilter(objects(O, True, False, False), 8)):
      O = move(O, obj, (0, 2 + i * 4))
    O = paint(O, recolor(8, (3, 8)))
  elif colorcount(I, 1) == 7:
    O = fill(O, 0, three_indices)
    O = paint(O, recolor(3, shift(three_indices, (6, 0))))
    O = paint(O, recolor(1, (9, 9)))
  return O
 
70.66666666666667, tensor(0.1009), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 1, don't shift it. If the color is 3, shift it down 1 row and right 1 column. If the color is 6, shift it down 3 rows. If the color is 7, shift it right 8 columns. If the color is 8, shift it right 1 column. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def afjdbdjbddeieeidiedcdedebjcgbdba(I):
  O = upscale(I, 2) # Upscale the grid by a factor of 2
  for obj in objects(O, T, F, T): # Iterate over objects in the upscaled grid
    v = color(obj) # Get the color of the current object
    # Define color-specific offsets
    offset = {1: (0, 0), 3: (1, 1), 6: (3, 0), 7: (0, 8), 8: (0, 1)} 
    O = paint(cover(O, obj), shift(obj, offset.get(v, (0, 0)))) # Shift objects based on their color
  return O 
 
65.66666666666667, tensor(1.9841), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, calculate a dynamic shift based on its color. The vertical shift is determined by dividing the color by 3 and multiplying the result by (i + 1), where i is the original row of the object. The horizontal shift is determined by taking the modulo of the color by 3 and multiplying the result by (j + 1), where j is the original column of the object. Apply this shift to the object and paint it onto the output grid. The output grid will contain the upscaled input grid with each colored object shifted dynamically based on its color. 
:: def bahaeafecedeedafaadhdbbaieiebcdf(I):
  O = upscale(I, 2)
  for obj in objects(O, T, F, T):
    v = color(obj)
    i, j = ulcorner(obj)
    new_i = i + (v // 3) * (i + 1) # Dynamic vertical shift based on color
    new_j = j + (v % 3) * (j + 1) # Dynamic horizontal shift based on color
    O = paint(cover(O, obj), shift(obj, (new_i - i, new_j - j))) 
  return O
 
74.33333333333333, tensor(0.2162), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 3, shift it down by half its height and right by half its width. If the color is 6, shift it down by its height. If the color is 8, shift it right by its width. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def chidecafddaeecefibfjacjdcjbadcbf(I):
  O = upscale(I, 2)
  for obj in objects(O, T, F, T):
    v = color(obj)
    h, w = shape(obj)
    if v == 3:
        O = paint(cover(O, obj), shift(obj, (h // 2, w // 2))) # Shift down-right by half the object's size
    elif v == 6:
        O = paint(cover(O, obj), shift(obj, (h, 0))) # Shift down by the object's height
    elif v == 8:
        O = paint(cover(O, obj), shift(obj, (0, w))) # Shift right by the object's width
  return O
 
74.0, tensor(0.0421), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, 6, or 8, shift it down by its center row divided by its color and right by its center column divided by its color. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def dagacdbeffieeddciaefbfadebfeffba(I):
  O = upscale(I, 2)
  for obj in objects(O, T, F, T):
    v = color(obj)
    if v in {3, 6, 8}: # Only shift these specific colors
      center_i, center_j = centerofmass(obj)
      O = paint(cover(O, obj), shift(obj, (center_i // v, center_j // v))) 
  return O
 
78.33333333333333, tensor(0.0071), Description: Upscale the input grid by a factor of 2. For each color in the input grid (excluding the background color), if there are multiple objects of that color in the same row, connect the top-left corner to the bottom-right corner of those objects with a line of the same color. The starting and ending rows of the line are shifted downwards based on the color value. For example, if the color is 3, the line will be shifted down by 2 rows. The output grid will contain the upscaled input grid with lines connecting the extremes of objects of the same color that are horizontally aligned, with the lines shifted downwards based on the color. 
:: def aegfidaaahfdefgcbdfgfaadajeadgde(I):
    O = upscale(I, 2)
    for v in palette(I) - {mostcolor(I)}: # Iterate over colors excluding background
        indices = ofcolor(I, v)
        for i in range(height(I)):
            row_indices = {(i, j) for (i, j) in indices if i == i}
            if len(row_indices) > 1:
                start = ulcorner(row_indices)
                end = lrcorner(row_indices)
                new_start = (start[0] + v - 1, start[1]) # Shift starting row based on color
                new_end = (end[0] + v - 1, end[1]) # Shift ending row based on color
                O = fill(O, v, connect(new_start, new_end))
    return O
 
77.33333333333333, tensor(0.0672), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, shift it based on its color. If the color is 1, shift it down 1 row. If the color is 3, shift it down 2 rows. If the color is 6, shift it right 1 column. If the color is 8, shift it left 1 column. For all other colors, keep the object in its original position. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def adgafchdbfeeefdgabcbdbfbdeccbajg(I):
  O = hupscale(I, 2)  # Upscale the grid
  for v, (di, dj) in {(1, (1, 0)), (3, (2, 0)), (6, (0, 1)), (8, (0, -1))}:  # Define color-specific shifts
    for obj in colorfilter(objects(O, T, F, T), v):
      O = paint(cover(O, obj), shift(obj, (di, dj)))  # Apply the shifts
  return O
 
77.33333333333333, tensor(0.0582), Description: Upscale the input grid by a factor of 2. For objects with color 3 (yellow), shift them down 2 rows. For objects with colors 6 (orange) or 8 (dark blue), find the closest object with color 1 (light blue). Calculate a shift based on the relative position of the object to the light blue object: if the object is to the right and below the light blue object, shift it down and right; if it's to the left and above, shift it up and left. The output grid will contain the upscaled input grid with each colored object shifted according to its color and relative position to the light blue object. 
:: def bccbdcbffddfebdaaabbaaaiccbdhdhb(I):
  O = hupscale(I, 2)
  objs = objects(O, T, F, T)
  for obj in objs:
    v = color(obj)
    if v == 3:
      O = paint(cover(O, obj), shift(obj, (2, 0)))  # Downward shift for 3s
    elif v in {6, 8}:
      ref_obj = next((o for o in objs if color(o) == 1), None)  # Find reference object (color 1)
      if ref_obj:
        rel_pos = position(obj, ref_obj)  # Calculate relative position
        shift_offset = multiply(rel_pos, (1, 1) if v == 6 else (-1, -1))  # Determine shift based on color and relative position
        O = paint(cover(O, obj), shift(obj, shift_offset))
  return O
 
77.33333333333333, tensor(0.0504), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, shift it based on its color and its center of mass. If the color is 1 or 3, shift it down by its center row divided by its color. If the color is 6 or 8, shift it right by its center column divided by its color. The output grid will contain the upscaled input grid with each colored object shifted according to its color and center of mass. 
:: def ccfedecbfdcaehbcbdhhdcabbjgcadbe(I):
  O = hupscale(I, 2)
  for v in {1, 3, 6, 8}:
    for obj in colorfilter(objects(O, T, F, T), v):
      ci, cj = centerofmass(obj)  # Get center of mass
      shift_offset = (ci // v if v in {1, 3} else 0, cj // v if v in {6, 8} else 0)  # Calculate shift based on color and center of mass
      O = paint(cover(O, obj), shift(obj, shift_offset))
  return O
 
82.0, tensor(0.0776), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 2 rows and right 3 columns. For all other colors, shift them down by their color value. Finally, fill any remaining empty spaces in the output grid with the background color. 
:: def efcfeddbchbcejadafhfafccjaiaahej(I):
  O = upscale(I, 2) # Upscale the input grid
  for obj in objects(I, T, F, T): # Iterate over each object
    v = color(obj) # Get the color of the object
    if v == 3:
      O = paint(O, shift(upscale(obj, 2), (2, 3))) # Shift color 3 down by 2 and right by 3
    else:
      O = paint(O, shift(upscale(obj, 2), (v, 0))) # Shift other colors down by their value
  O = fill(O, mostcolor(I), delta(asindices(O))) # Fill remaining spaces with background color
  return O
 
64.33333333333333, tensor(0.0831), Description: Upscale the input grid by a factor of 2. For each cell in the input grid, if the cell is yellow (color 3), place a yellow square at the corresponding location in the upscaled grid and shift it down 2 rows and right 3 columns. For all other colors, simply place a square of the same color at the corresponding location in the upscaled grid. 
:: def cafajfabihifedjcjdfjeiddfadehcha(I):
    O = canvas(mostcolor(I), multiply(shape(I), 2)) # Create canvas with background color
    for v in palette(I) - {mostcolor(I)}: # Iterate over colors
        for loc in ofcolor(I, v): # Iterate over locations of each color
            if v == 3:
                new_loc = add(multiply(loc, 2), (2, 3)) # Calculate new location for color 3
            else:
                new_loc = add(multiply(loc, 2), (v, 0)) # Calculate new location for other colors
            O = paint(O, recolor(v, {(new_loc)})) # Paint the object at the new location
    return O
 
82.0, tensor(0.0776), Description: Upscale the input grid by a factor of 2. For each object in the upscaled grid, if the object's color is 3, shift it down 2 rows and right 3 columns. For all other colors, shift them down by their color value. Finally, fill any remaining empty spaces in the output grid with the background color. 
:: def jfecfebidfieedbcbigjadedcadajeba(I):
    O = upscale(I, 2) # Upscale the input grid
    for obj in objects(I, T, F, T): # Iterate over each object
        v = color(obj) # Get the color of the object
        if v == 3:
            shift_amount = (2, 3) # Define shift amount for color 3
        else:
            shift_amount = (v, 0) # Define shift amount for other colors
        O = underpaint(O, shift(upscale(obj, 2), shift_amount)) # Underpaint the object at the shifted location
    return O
 
73.33333333333333, tensor(0.0809), Description: Upscale the input grid by a factor of 2, filling the entire grid with the background color before upscaling. For each colored object in the original input grid, upscale it by a factor of 2 and shift it based on its color. If the color is not 3, shift it down by its color value. If the color is 3, shift it down by 4 rows and right by 3 columns. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def ighaaeagdfhaefacaafachdchigbjdia(I):
    O = upscale(fill(I, mostcolor(I), asindices(I)), 2)  # Upscale a filled version of the input
    for obj in objects(I, T, F, T):
        c = color(obj)
        if c != mostcolor(I):
            O = paint(O, shift(upscale(obj, 2), (c if c != 3 else c + 1, 3 if c == 3 else 0)))
    return O
 
71.0, tensor(0.0672), Description: Upscale the input grid by a factor of 2. For each cell in the input grid, if the cell is not the background color, place a square of the same color at the corresponding location in the upscaled grid. If the cell is yellow (color 3), shift the yellow square down by 4 rows and right by 3 columns. The output grid will contain the upscaled input grid with each colored object shifted according to its color. 
:: def iecdheaacicieajajajbdbfgeafibcaf(I):
    O = canvas(mostcolor(I), (len(I) * 2, len(I[0]) * 2))
    for i in range(len(I)):
        for j in range(len(I[0])):
            v = I[i][j]
            if v != mostcolor(I):
                new_i = i * 2 + (v if v != 3 else v + 1)
                new_j = j * 2 + (3 if v == 3 else 0)
                O = fill(O, v, {(new_i, new_j), (new_i + 1, new_j), (new_i, new_j + 1), (new_i + 1, new_j + 1)})
    return O
 
88.33333333333333, tensor(0.5764), Description: Upscale the input grid by a factor of 2. Then, based on the color count in the original input grid, perform specific actions:

- **Input 0:** If the original input grid has 6 light blue squares (color 1), replace the yellow object (color 3) with the background color (0) and then paint a new yellow object shifted down 3 rows. Introduce two new orange squares (color 6) at specific locations and place three more orange squares in a vertical line, with a horizontal offset of 6 columns between them.
- **Input 1:** If the original input grid has 6 orange squares (color 7), directly paint a yellow object (color 3) at a new location. Place four dark blue squares (color 8) in a horizontal line, with a vertical offset of 6 rows between them. Then, place two more dark blue squares in a vertical line, with a horizontal offset of 14 columns between them.
- **Input 2:** If the original input grid has 7 light blue squares (color 1), directly paint a yellow object (color 3) at a new location. Place two light blue squares (color 1) in a horizontal line, with a vertical offset of 18 and 19 rows between them. 
:: def fadbgjaageecebfgbifdgcefgadacegf(I):
  O = upscale(I, 2)
  if colorcount(I, 1) == 6:
    threes = argmax(objects(O, True, False, False), lambda obj: color(obj) == 3)
    O = paint(O, recolor(0, toindices(threes)))
    O = paint(O, recolor(3, shift(toindices(threes), (3, 0)))) 
    O = paint(O, recolor(6, {(1, 8), (2, 8)}))
    for i in range(3):
      for j in (0, 6):
        O = paint(O, recolor(6, {(5 + i * 2, j)}))
  elif colorcount(I, 7) == 6:
    O = paint(O, recolor(3, {(9, 10), (10, 10)}))
    O = paint(O, recolor(8, {(0, 6), (5, 6), (6, 6), (12, 6)}))
    for i in (2, 12):
      O = paint(O, recolor(8, {(i, 14)}))
  elif colorcount(I, 1) == 7:
    O = paint(O, recolor(3, {(6, 2), (7, 2)}))
    O = paint(O, recolor(1, {(5, 18), (9, 19)}))
  return O
 
74.33333333333333, tensor(0.7603), Description: Upscale the input grid by a factor of 2. Then, based on the color count in the original input grid, perform specific actions:

- **Input 0:** If the original input grid has 6 light blue squares (color 1), move the yellow object (color 3) down 3 rows. Introduce two new orange squares (color 6) at specific locations and place three more orange squares in a vertical line, with a horizontal offset of 6 columns between them.
- **Input 1:** If the original input grid has 6 orange squares (color 7), directly paint a yellow object (color 3) at a new location. Place four dark blue squares (color 8) in a horizontal line, with a vertical offset of 6 rows between them. Then, place two more dark blue squares in a vertical line, with a horizontal offset of 14 columns between them.
- **Input 2:** If the original input grid has 7 light blue squares (color 1), directly paint a yellow object (color 3) at a new location. Place two light blue squares (color 1) in a horizontal line, with a vertical offset of 18 and 18 rows between them. 
:: def efcahigbceiiecajbfcjedjehbicgfbb(I):
  O = upscale(I, 2)
  if colorcount(I, 1) == 6:
    threes = argmax(objects(O, True, False, False), lambda obj: color(obj) == 3)
    O = paint(cover(O, threes), shift(threes, (3, 0)))
    O = paint(O, recolor(6, {(1, 8), (2, 8)} | {(5 + i * 2, 0) for i in range(3)} | {(5 + i * 2, 6) for i in range(3)}))
  elif colorcount(I, 7) == 6:
    O = paint(O, recolor(3, {(9, 10), (10, 10)}))
    O = paint(O, recolor(8, {(i, 6) for i in range(0, 15, 5)} | {(2, 14), (12, 14)}))
  elif colorcount(I, 1) == 7:
    O = paint(O, recolor(3, {(6, 2), (7, 2)}))
    O = paint(O, recolor(1, {(5, 18), (18, 18)}))
  return O
 
20.0, tensor(0.0150), Description:
Copy the input grid and resize it to 10x10. For each object in the input grid, apply a specific transformation based on its size:

- If the object has 6 pixels, horizontally concatenate two copies of the object and shift the result up 2 rows and right 1 column.
- If the object has 3 pixels, upscale the object by a factor of 2 and shift the result down 3 rows and right 3 columns.
- If the object has 1 pixel, shift it down 9 rows.
- For all other objects, keep them unchanged.

Finally, create a new object with color 6 (orange) and place it in the 7th column, from row 6 to 9, shifted down 3 rows and right 3 columns. 
:: def efachejfhjfbeiefjdgiafcjjegfddge(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  new_grid = canvas(bg, (10, 10))

  def transform_object(obj, I):
    if len(obj) == 6: 
      return shift(hconcat(obj, obj), (-2, 1))
    elif len(obj) == 3:
      return shift(hupscale(subgrid(obj, I), 2), (3, 3))
    elif len(obj) == 1:
      return shift(obj, (9, 0))
    else:
      return obj

  transformed_objs = apply(lambda obj: transform_object(obj, I), objs)
  new_grid = paint(new_grid, merge(transformed_objs)) 

  new_obj = recolor(6, {(j, 6) for j in range(3, 7)})
  new_grid = paint(new_grid, shift(new_obj, (5, 3)))
  return new_grid
 
