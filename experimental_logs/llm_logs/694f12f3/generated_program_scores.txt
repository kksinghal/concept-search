29.5, tensor(1.7869), Description: Shift the inner area of the top rectangle one space to the right and one space down. Shift the inner area of the bottom rectangle one space to the right and one space up. Fill the shifted inner areas with the colors 1 and 2 respectively. 
:: def ebabcbbeiegfeidbjeebafcaaffccade(I):
  top_rect = trim(tophalf(I)) # Extract the top half and trim the borders
  bottom_rect = trim(bottomhalf(I)) # Extract the bottom half and trim the borders
  inner_top = ofcolor(top_rect, mostcolor(top_rect))  # Find indices of inner area in the top rectangle
  inner_bottom = ofcolor(bottom_rect, mostcolor(bottom_rect))  # Find indices of inner area in the bottom rectangle
  O = fill(fill(I, 1, shift(inner_top, (1,1))), 2, shift(inner_bottom, (len(top_rect),1))) # Fill shifted inner areas
  return O
 
27.5, tensor(1.7064), Description: Divide the input grid horizontally into two halves. Fill the top half with color '1' and the bottom half with color '2', except for the border cells. 
:: def fjdaacbdgfjeedehiafbidaccdbgddcc(I):
  O = I # Initialize output as input
  for i in range(1, len(I) - 1): # Iterate through rows
    for j in range(1, len(I[0]) - 1): # Iterate through columns
      if I[i][j] != 0: # Check for non-zero values
        if i < len(I) // 2:
          O = fill(O, 1, {(i,j)}) # Fill top area with '1'
        else:
          O = fill(O, 2, {(i,j)}) # Fill bottom area with '2'
  return O
 
32.5, tensor(1.6219), Description: Divide the input grid horizontally into two halves. Fill all objects in the top half with color '1' and all objects in the bottom half with color '2'. 
:: def cjedfeaejaefehadjcahabcdacifdcic(I):
  objs = objects(I, True, False, True) # Extract objects without background
  for obj in objs:
    if uppermost(obj) < len(I) // 2: # Top object
      I = fill(I, 1, toindices(obj))
    else: # Bottom object
      I = fill(I, 2, toindices(obj))
  return I
 
58.0, tensor(1.7064), Description: Divide the input grid horizontally into two halves. Fill the top half with color '1' and the bottom half with color '2', except for the border cells. 
:: def edbddjchecfeebeajabccfghceaabbia(I):
  top_area = {(i, j) for i in range(1, len(I) // 2) for j in range(1, len(I[0]) - 1)} # Define top area
  bottom_area = {(i, j) for i in range(len(I) // 2, len(I) - 1) for j in range(1, len(I[0]) - 1)} # Define bottom area
  O = fill(I, 1, intersection(top_area, asindices(I))) # Fill top area with '1'
  O = fill(O, 2, intersection(bottom_area, asindices(I))) # Fill bottom area with '2'
  return O
 
12.5, tensor(1.7789), Description: 
The input grid contains two objects, one at the top and one at the bottom. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object. The position of the rectangles should be the same as the original objects, but shifted one space to the right and one space down for the top object, and one space to the right and one space up for the bottom object. 
:: def eaeifhddbbadegdeafdhaeefabhdaffe(I):
    O = I # Initialize output as input
    objs = objects(I, True, False, True)
    for obj in objs:
        if uppermost(obj) < 5: # Identify the top object
            O = paint(O, recolor(1, crop(canvas(0, shape(obj)), (uppermost(obj) + 1, leftmost(obj) + 1), (2, 2))))
        else: # Identify the bottom object
            if portrait(obj):
                O = paint(O, recolor(2, crop(canvas(0, shape(obj)), (uppermost(obj) + 1, leftmost(obj) + 1), (4, 3))))
            else:
                O = paint(O, recolor(2, crop(canvas(0, shape(obj)), (uppermost(obj) + 1, leftmost(obj) + 1), (2, 4))))
    return O
 
52.0, tensor(1.6733), Description: 
The input grid contains a pattern of black squares. The goal is to identify the black squares that are either entirely surrounded by black squares or have a black square shifted one space to the left and one space up from them. These identified black squares should be filled with the color '2' in the output grid. 
:: def gbehjcdegefdedacaacedjaiecccfaaj(I):
    # Identify '0' locations 
    x1 = ofcolor(I, ZERO)
    # Define a single-cell object at (0,0)
    x2 = astuple(ZERO, ORIGIN)
    x3 = initset(x2)
    # Upscale the object to 3x3
    x4 = upscale(x3, THREE)
    # Get indices of the upscaled object
    x5 = toindices(x4)
    # Create a function to shift the object
    x6 = lbind(shift, x5)
    # Create a function to find the difference with '0' locations
    x7 = rbind(difference, x1)
    # Calculate the size of the difference after shifting
    x8 = chain(size, x7, x6)
    # Check if the size is 0 (meaning the shifted object is entirely within '0' locations)
    x9 = matcher(x8, ZERO)
    # Shift the object by (-1,-1)
    x10 = lbind(add, NEG_UNITY)
    # Check if the shifted object is NOT entirely within '0' locations
    x11 = chain(flip, x9, x10)
    # Combine both checks - original and shifted
    x12 = fork(both, x9, x11)
    # Filter '0' locations based on the combined check
    x13 = sfilter(x1, x12)
    # Apply the shifting function to the filtered locations
    x14 = mapply(x6, x13)
    # Fill the resulting indices with '2'
    O = fill(I, TWO, x14) 
    return O
 
27.0, tensor(1.9402), Description: The input grid contains a single colored object. If the object is taller than it is wide, split it vertically into two halves. Then, split the bottom half horizontally into two halves. Fill the bottom right quadrant with color 1. If the object is wider than it is tall, split it horizontally into two halves. Then, split the right half vertically into two halves. Fill the bottom right quadrant with color 2. Finally, paint the resulting pattern onto the original input grid, replacing the original object. 
:: def faieheihcbigebdaiaecjcjcdjfdeehg(I):
  obj = first(objects(I, F, T, T)) # Assuming single object
  h = height(obj)
  w = width(obj)
  if h > w:
    top, bottom = vsplit(subgrid(obj, I), 2)
    bottom_left, bottom_right = hsplit(bottom, 2)
    bottom_right = fill(bottom_right, 1, asindices(bottom_right))
    bottom = hconcat(bottom_left, bottom_right)
    O = vconcat(top, bottom)
  else:
    left, right = hsplit(subgrid(obj, I), 2)
    top_right, bottom_right = vsplit(right, 2)
    bottom_right = fill(bottom_right, 2, asindices(bottom_right))
    right = vconcat(top_right, bottom_right)
    O = hconcat(left, right)
  return paint(cover(I, obj), asobject(O)) 
 
13.5, tensor(1.9449), Description: The input grid contains a single colored object. If the object is taller than it is wide, split it horizontally into two halves. Fill the bottom right quadrant with color 1. If the object is wider than it is tall, split it vertically into two halves. Fill the bottom right quadrant with color 2. 
:: def egjhfebdffcjebhjaiccfbgehcffcdhj(I):
  obj = first(objects(I, F, T, T)) # Assuming single object
  if portrait(obj):
    split_line =  uppermost(obj) + height(obj) // 2
    O = fill(I, 1, frozenset((i, j) for i, j in toindices(obj) if i >= split_line and j > leftmost(obj) + width(obj) // 2))
  else:
    split_line =  leftmost(obj) + width(obj) // 2
    O = fill(I, 2, frozenset((i, j) for i, j in toindices(obj) if j >= split_line and i > uppermost(obj) + height(obj) // 2))
  return O
 
25.0, tensor(1.9402), Description: The input grid contains a single colored object. If the object is taller than it is wide, split it vertically into two halves. Then, split the bottom half horizontally into two halves. Fill the bottom right quadrant with color 1. If the object is wider than it is tall, split it horizontally into two halves. Then, split the right half vertically into two halves. Fill the bottom right quadrant with color 2. Finally, paint the resulting pattern onto the original input grid, replacing the original object. 
:: def bihibbeejfhfeidbjjfdfebfcbcgecgc(I):
  obj = first(objects(I, F, T, T)) # Assuming single object
  h, w = shape(obj)
  if h > w:
    O = paint(cover(I, obj), asobject(vconcat(crop(I, ulcorner(obj), (h//2, w)), hconcat(crop(I, (h//2, 0), (1, w)), fill(crop(I, (h//2 + 1, 0), (h - h//2 - 1, w)), 1, asindices(crop(I, (h//2 + 1, 0), (h - h//2 - 1, w))))))))
  else:
    O = paint(cover(I, obj), asobject(hconcat(crop(I, ulcorner(obj), (h, w//2)), vconcat(crop(I, (0, w//2), (h, 1)), fill(crop(I, (0, w//2 + 1), (h, w - w//2 - 1)), 2, asindices(crop(I, (0, w//2 + 1), (h, w - w//2 - 1))))))))
  return O
 
17.0, tensor(1.7710), Description: The input grid contains a single colored object. If the object is taller than it is wide, split it vertically into two halves. Fill the top half with color 4 and the bottom half with color 1. If the object is wider than it is tall, split it horizontally into two halves. Fill the left half with color 4 and the right half with color 2. Finally, paint the resulting pattern onto the original input grid, replacing the original object. 
:: def cgcebegabgbaecdeaddicbbdbabfccaa(I):
  obj = first(objects(I, F, T, T))
  if portrait(obj):
    split_index =  len(toindices(obj)) // 2
    sorted_indices = order(toindices(obj), lambda x: x[0] * 100 + x[1])
    top_half = frozenset(sorted_indices[:split_index])
    bottom_half = frozenset(sorted_indices[split_index:])
    O = paint(cover(I, obj), combine(recolor(4, top_half), recolor(1, bottom_half)))
  else:
    split_index =  len(toindices(obj)) // 2
    sorted_indices = order(toindices(obj), lambda x: x[1] * 100 + x[0])
    left_half = frozenset(sorted_indices[:split_index])
    right_half = frozenset(sorted_indices[split_index:])
    O = paint(cover(I, obj), combine(recolor(4, left_half), recolor(2, right_half)))
  return O
 
65.0, tensor(1.9338), Description: The input grid contains one or more colored objects. For each object, if it is taller than it is wide, split it vertically into two halves. Then, split the bottom half horizontally into two halves. Fill the bottom right quadrant with color 1. If the object is wider than it is tall, split it horizontally into two halves. Then, split the right half vertically into two halves. Fill the bottom right quadrant with color 2. Finally, paint the resulting pattern onto the original input grid, replacing the original object. 
:: def gfdeabhbiedfeeacbdbdjbfigeabfhaf(I):
  objs = objects(I, F, T, T)
  O = I
  for obj in objs:
    if portrait(obj):
      O = vconcat(crop(O, (0, 0), (height(O) // 2, width(O))), hconcat(crop(O, (height(O) // 2, 0), (1, width(O))), fill(crop(O, (height(O) // 2 + 1, 0), (height(O) - height(O) // 2 - 1, width(O))), 1, asindices(crop(O, (height(O) // 2 + 1, 0), (height(O) - height(O) // 2 - 1, width(O)))))))
    else:
      O = hconcat(crop(O, (0, 0), (height(O), width(O) // 2)), vconcat(crop(O, (0, width(O) // 2), (height(O), 1)), fill(crop(O, (0, width(O) // 2 + 1), (height(O), width(O) - width(O) // 2 - 1)), 2, asindices(crop(O, (0, width(O) // 2 + 1), (height(O), width(O) - width(O) // 2 - 1))))))
  return O
 
11.5, tensor(1.5863), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the 2x2 square in the center of the object with color 1 if the object is in the top half of the grid, and color 2 if the object is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def jgdcfcjdacfbebiabchhfddhacibdcaf(I):
  def process_object(obj):
    if width(obj) >= 2 and height(obj) >= 2:
      i, j = ulcorner(obj)
      new_color = 1 if i < len(I) // 2 else 2
      return recolor(new_color, {(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)})
    else:
      return obj
  O = paint(I, merge(apply(process_object, objects(I, T, F, F))))
  return O
 
61.0, tensor(1.4490), Description: The input grid contains one or more colored objects. For each object, if it is larger than 2x2, fill the 2x2 square in the center of the object with color 1 if the object is in the top half of the grid, and color 2 if the object is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def fiddacdadfbfedebbfbfcdiajiacahjc(I):
  def recolor_if_big(obj):
    return recolor(1 if uppermost(obj) < len(I)//2 else 2,  {(i+1, j+1) for i in range(height(obj)-2) for j in range(width(obj)-2)}) if height(obj) > 2 and width(obj) > 2 else frozenset()
  return paint(I, merge(apply(recolor_if_big, objects(I, T, F, F))))
 
12.0, tensor(1.1271), Description: The input grid contains one or more colored objects. For each object, if it has 4 or more cells, replace the 2x2 square in the center of the object with color 1 if the object is in the top half of the grid, and color 2 if the object is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def fdehadegibcieedfjhcdfaaicdhaejah(I):
  def modify_obj(obj):
    if len(obj) >= 4:  
      ci, cj = centerofmass(obj) 
      new_color = 1 if ci < len(I) // 2 else 2 
      return recolor(new_color, {(ci, cj), (ci + 1, cj), (ci, cj + 1), (ci + 1, cj + 1)})
    else:
      return obj
  new_objs = apply(modify_obj, objects(I, T, F, F)) 
  return paint(I, merge(new_objs))
 
34.5, tensor(0.4523), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def jjdbfibagidgefbajdejjgdaaabhfbia(I):
  obj1 = first(objects(I, True, False, True))
  obj2 = other(objects(I, True, False, True), obj1)
  c1 = color(obj1)
  c2 = color(obj2)

  center1 = (uppermost(obj1) + height(obj1) // 2, leftmost(obj1) + width(obj1) // 2)
  center2 = (uppermost(obj2) + height(obj2) // 2, leftmost(obj2) + width(obj2) // 2)

  O = paint(canvas(0, shape(I)), recolor(1, {(c1, (center1[0]-1, center1[1]-1)), (c1, (center1[0]-1, center1[1])), (c1, (center1[0], center1[1]-1)), (c1, (center1[0], center1[1]))}))

  if portrait(obj2):
    rect2 = {(c2, (center2[0]-2, center2[1]-1)), (c2, (center2[0]-2, center2[1])), (c2, (center2[0]-2, center2[1]+1)),
           (c2, (center2[0]-1, center2[1]-1)), (c2, (center2[0]-1, center2[1])), (c2, (center2[0]-1, center2[1]+1)),
           (c2, (center2[0], center2[1]-1)), (c2, (center2[0], center2[1])), (c2, (center2[0], center2[1]+1)),
           (c2, (center2[0]+1, center2[1]-1)), (c2, (center2[0]+1, center2[1])), (c2, (center2[0]+1, center2[1]+1))}
  else:
    rect2 = {(c2, (center2[0]-1, center2[1]-2)), (c2, (center2[0]-1, center2[1]-1)), (c2, (center2[0]-1, center2[1])), (c2, (center2[0]-1, center2[1]+1)),
           (c2, (center2[0], center2[1]-2)), (c2, (center2[0], center2[1]-1)), (c2, (center2[0], center2[1])), (c2, (center2[0], center2[1]+1))}
  O = paint(O, rect2)

  return O
 
3.5, tensor(0.4523), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def feafcdcdcdecebdebfcgbdficcciebdh(I):
  obj1 = first(objects(I, True, False, True))
  obj2 = other(objects(I, True, False, True), obj1)

  O = I
  for i in range(uppermost(obj1) + height(obj1) // 2 - 1, uppermost(obj1) + height(obj1) // 2 + 1):
    for j in range(leftmost(obj1) + width(obj1) // 2 - 1, leftmost(obj1) + width(obj1) // 2 + 1):
      O = paint(O, {(1, (i, j))})

  if portrait(obj2):
    for i in range(uppermost(obj2) + height(obj2) // 2 - 2, uppermost(obj2) + height(obj2) // 2 + 2):
      for j in range(leftmost(obj2) + width(obj2) // 2 - 1, leftmost(obj2) + width(obj2) // 2 + 2):
        O = paint(O, {(2, (i, j))})
  else:
    for i in range(uppermost(obj2) + height(obj2) // 2 - 1, uppermost(obj2) + height(obj2) // 2 + 1):
      for j in range(leftmost(obj2) + width(obj2) // 2 - 2, leftmost(obj2) + width(obj2) // 2 + 2):
        O = paint(O, {(2, (i, j))})
  return O
 
8.5, tensor(0.4794), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def ffbeebgbeebeegjajieaabaaaajbbehh(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  center1 = center(obj1)
  center2 = center(obj2)
  square1 = frozenset({(center1[0] - 1, center1[1] - 1), (center1[0] - 1, center1[1]), (center1[0], center1[1] - 1), (center1[0], center1[1])})
  square2 = frozenset({(center2[0] - 1, center2[1] - 1), (center2[0] - 1, center2[1]), (center2[0], center2[1] - 1), (center2[0], center2[1])})
  O = fill(fill(I, 1, square1), 2, square2) if uppermost(obj1) < uppermost(obj2) else fill(fill(I, 2, square1), 1, square2)
  return O
 
32.5, tensor(0.4794), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def fafdfeafceefebgcibcfbcibdcafdifc(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  grid1 = subgrid(obj1, I)
  grid2 = subgrid(obj2, I)
  h1, w1 = shape(grid1)
  h2, w2 = shape(grid2)
  grid1 = vconcat(vconcat(crop(grid1, (0, 0), (h1 // 2 - 1, w1)), ((1,) * w1,)), crop(grid1, (h1 // 2 + 1, 0), (h1 // 2, w1)))
  grid2 = vconcat(vconcat(crop(grid2, (0, 0), (h2 // 2 - 1, w2)), ((2,) * w2,)), crop(grid2, (h2 // 2 + 1, 0), (h2 // 2, w2)))
  O = paint(paint(cover(I, obj1), asobject(grid1)), asobject(grid2))
  return O
 
14.0, tensor(1.7929), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, shifted one space to the right and one space down from its original position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, shifted one space to the right and one space down from its original position. 
:: def dffdjbacfefiejbdidebdjjfidcajahb(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  rel_pos = position(obj1, obj2)
  square = frozenset({(-1, -1), (-1, 0), (0, -1), (0, 0)})
  O = I
  if rel_pos[0] == 1:
    O = paint(O, recolor(1, shift(square, add(center(obj1), (1, 1)))))
    O = paint(O, recolor(2, shift(square, add(center(obj2), (1, 1)))))
  else:
    O = paint(O, recolor(2, shift(square, add(center(obj1), (1, 1)))))
    O = paint(O, recolor(1, shift(square, add(center(obj2), (1, 1)))))
  return O
 
41.5, tensor(0.4794), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def ejbabcjcdicaeebgaejdedfjgcjfhgif(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  center1 = center(obj1)
  center2 = center(obj2)
  subgrid1 = crop(I, (center1[0] - 1, center1[1] - 1), (2, 2))
  subgrid2 = crop(I, (center2[0] - 1, center2[1] - 1), (2, 2))
  I = cover(I, obj1)
  I = cover(I, obj2)
  if uppermost(obj1) < uppermost(obj2):
    I = paint(I, recolor(1, asobject(subgrid1)))
    I = paint(I, recolor(2, asobject(subgrid2)))
  else:
    I = paint(I, recolor(2, asobject(subgrid1)))
    I = paint(I, recolor(1, asobject(subgrid2)))
  return I
 
11.5, tensor(1.9219), Description: The input grid contains two colored objects. If the first object is taller than it is wide, fill the inner area of the first object with color 1 and the inner area of the second object with color 2. If the first object is wider than it is tall, fill the inner area of the first object with color 2 and the inner area of the second object with color 1. The inner area is defined as the area within the object, excluding the border cells. 
:: def jdaecgdcibajeacgihjdabgaffabgbfd(I):
  obj1 = first(objects(I, F, T, T))
  if portrait(obj1):
    obj2 = first(difference(objects(I, F, T, T), {obj1}))
    O = fill(I, 1, intersection(backdrop(obj1), frozenset((i, j) for i in range(uppermost(obj1) + 1, lowermost(obj1) - 1) for j in range(leftmost(obj1) + 1, rightmost(obj1) - 1))))
    O = fill(O, 2, intersection(backdrop(obj2), frozenset((i, j) for i in range(uppermost(obj2) + 1, lowermost(obj2) - 1) for j in range(leftmost(obj2) + 1, rightmost(obj2) - 1))))
  else:
    obj2 = first(difference(objects(I, F, T, T), {obj1}))
    O = fill(I, 2, intersection(backdrop(obj1), frozenset((i, j) for i in range(uppermost(obj1) + 1, lowermost(obj1) - 1) for j in range(leftmost(obj1) + 1, rightmost(obj1) - 1))))
    O = fill(O, 1, intersection(backdrop(obj2), frozenset((i, j) for i in range(uppermost(obj2) + 1, lowermost(obj2) - 1) for j in range(leftmost(obj2) + 1, rightmost(obj2) - 1))))
  return O
 
0.5, tensor(1.9219), Description: The input grid contains two colored objects. If the first object is taller than it is wide, fill the inner area of the first object with color 1 and the inner area of the second object with color 2. If the first object is wider than it is tall, fill the inner area of the first object with color 2 and the inner area of the second object with color 1. The inner area is defined as the area within the object, excluding the border cells. 
:: def bbefjifefhaheeeejaddgcfaaddfacej(I):
  obj1 = argmax(objects(I, F, T, T), size)
  if portrait(obj1):
    obj2 = argmax(difference(objects(I, F, T, T), {obj1}), size)
    O = paint(I, recolor(1, intersection(toindices(obj1), inbox(obj1))))
    O = paint(O, recolor(2, intersection(toindices(obj2), inbox(obj2))))
  else:
    obj2 = argmax(difference(objects(I, F, T, T), {obj1}), size)
    O = paint(I, recolor(2, intersection(toindices(obj1), inbox(obj1))))
    O = paint(O, recolor(1, intersection(toindices(obj2), inbox(obj2))))
  return O
 
11.5, tensor(1.9295), Description: The input grid contains two colored objects. If the first object is taller than it is wide, fill the area surrounding the first object with color 1 and the area surrounding the second object with color 2. If the first object is wider than it is tall, fill the area surrounding the first object with color 2 and the area surrounding the second object with color 1. The surrounding area is defined as the area outside the object, excluding the border cells. 
:: def heeaafdbafijedhabcbagadieeefacaj(I):
  obj1 = first(objects(I, F, T, T))
  if portrait(obj1):
    obj2 = first(difference(objects(I, F, T, T), {obj1}))
    O = fill(I, 1, difference(backdrop(obj1), box(obj1)))
    O = fill(O, 2, difference(backdrop(obj2), box(obj2)))
  else:
    obj2 = first(difference(objects(I, F, T, T), {obj1}))
    O = fill(I, 2, difference(backdrop(obj1), box(obj1)))
    O = fill(O, 1, difference(backdrop(obj2), box(obj2)))
  return O
 
11.5, tensor(1.7853), Description: The input grid contains one or more squares. If there are at least two squares, identify the topmost and bottommost squares. Fill the topmost square with color 1 if it is in the top half of the grid, and color 2 if it is in the bottom half. Fill the bottommost square with color 2 if the topmost square is in the top half of the grid, and color 1 if it is in the bottom half. Shift both squares one space to the right and one space down. If there are less than two squares, return the input grid unchanged. 
:: def iffcddebdbfheeedaaaegacaaacehhbh(I):
    squares = sorted(sfilter(objects(I, True, False, False), square), key=uppermost)
    if len(squares) >= 2:  # Ensure there are at least two squares
        top, bottom = squares[0], squares[-1]
        O = fill(I, 1 if uppermost(top) < len(I) // 2 else 2, toindices(shift(trim(subgrid(top, I)), (1, 1))))
        O = fill(O, 2 if uppermost(top) < len(I) // 2 else 1, toindices(shift(trim(subgrid(bottom, I)), (1, 1))))
        return O
    else:
        return I  # Return the input if there are less than two squares
 
28.5, tensor(0.4523), Description: The input grid contains two colored objects. The top object is always a 2x2 square. The bottom object can be either a 4x3 rectangle or a 2x4 rectangle, depending on its orientation.

The output grid should be the same size as the input grid. The top object should be replaced with a 2x2 square of color 1, centered on the original object's position. The bottom object should be replaced with a rectangle of color 2, with the same dimensions as the original bottom object, centered on the original object's position. 
:: def jjfjdejhdfcbeaidjibdfbfbicefijfc(I):
  obj1 = first(objects(I, True, False, True))
  obj2 = other(objects(I, True, False, True), obj1)
  
  O = paint(canvas(0, shape(I)), recolor(1, {(center(obj1)[0]-1+i, center(obj1)[1]-1+j) for i in range(2) for j in range(2)}))
  
  if portrait(obj2):
    O = paint(O, recolor(2, {(center(obj2)[0]-2+i, center(obj2)[1]-1+j) for i in range(4) for j in range(3)}))
  else:
    O = paint(O, recolor(2, {(center(obj2)[0]-1+i, center(obj2)[1]-2+j) for i in range(2) for j in range(4)}))
  return O
 
32.5, tensor(1.7838), Description: The input grid contains a pattern of gray squares. For each gray square, if it is not on the border and has a gray square directly to its right and below it, fill the 2x2 square to the right and below it with color 1 if the gray square is in the top half of the grid, and color 2 if it is in the bottom half. Otherwise, leave the grid unchanged. 
:: def ebhajidfadeheadcbdeaejecjficdghg(I):
  def process_region(i, j, grid):
    if 0 <= i + 1 < len(grid) and 0 <= j + 1 < len(grid[0]) and grid[i][j] == 4:
      new_color = 1 if i < len(grid) // 2 else 2
      grid = fill(grid, new_color, {(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)})
    return grid
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      O = process_region(i, j, O)
  return O
 
37.5, tensor(1.5147), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the 2x2 square in the center of the object with color 1 if the object is in the top half of the grid, and color 2 if the object is in the bottom half of the grid. Otherwise, leave the object unchanged. The output grid should be the same size as the input grid. 
:: def bbcebdihdbceeigjidaijjeeccagfibc(I):
  O = canvas(mostcolor(I), shape(I))  # Create a blank canvas
  for obj in objects(I, T, F, F):
    if width(obj) >= 2 and height(obj) >= 2:
      new_color = 1 if uppermost(obj) < len(I) // 2 else 2
      square = shift(crop(canvas(0, (2,2)), (0,0), (2,2)), (uppermost(obj)+1, leftmost(obj)+1))
      O = paint(O, recolor(new_color, toindices(square)))
  return O
 
39.5, tensor(1.7695), Description: The input grid contains two colored objects. If the first object is a square, fill the 2x2 square in the center of the object with color 1. If the first object is not a square, fill the 2x2 square in the center of the object with color 2. Repeat the same process for the second object. The output grid should be the same size as the input grid. 
:: def ebabfiabcgidebaficbfhcdhgeagchaa(I):
  obj1 = first(objects(I, True, False, True))
  obj2 = other(objects(I, True, False, True), obj1)
  
  O = paint(canvas(0, shape(I)), recolor(1 if square(obj1) else 2, crop(canvas(0, shape(obj1)), (center(obj1)[0]-1, center(obj1)[1]-1), (2,2))))
  O = paint(O, recolor(1 if square(obj2) else 2, crop(canvas(0, shape(obj2)), (center(obj2)[0]-1, center(obj2)[1]-1), (2,2))))
  
  return O
 
43.0, tensor(1.7838), Description: The input grid contains a pattern of gray squares. For each gray square, if it is not on the border and has a gray square directly to its right and below it, fill the 2x2 square to the right and below it with color 1 if the gray square is in the top half of the grid, and color 2 if it is in the bottom half. Otherwise, leave the grid unchanged. 
:: def bgedcjcdhdfheabjjbabhgfcfhhcbfha(I):
  def recolor_cell(i, j):
    if I[i][j] == 4 and i + 1 < len(I) and j + 1 < len(I[0]):
      new_color = 1 if i < len(I) // 2 else 2
      return new_color
    else:
      return I[i][j]
  O = canvas(0, shape(I))
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      O = paint(O, {(recolor_cell(i, j), (i + 1, j + 1))})
  return O
 
18.0, tensor(1.1386), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def ibadddcdbeefegeajfgfedfbhbcdfeeh(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = I
  for i, j in toindices(smaller_obj):
    O = fill(O, 1, {(i, j)})
  for i in range(uppermost(larger_obj), lowermost(larger_obj) + 1):
    for j in range(leftmost(larger_obj) + 1, rightmost(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
11.0, tensor(1.1365), Description: The input grid contains two colored objects. For each object, fill the inner area (excluding the border cells) with color 2 if the object is larger than the other object, and color 1 if it is smaller. The output grid should be the same size as the input grid. 
:: def cjjcffchfaaaecdfaagdaeaffidfefdc(I):
    objs = objects(I, True, False, True)
    obj1 = first(objs)
    obj2 = other(objs, obj1)
    O = I
    for i in range(height(I)):
      for j in range(width(I)):
        if (i, j) in toindices(obj1) and j not in (leftmost(obj1), rightmost(obj1)):
          O = fill(O, 2 if len(obj1) > len(obj2) else 1, {(i, j)})
        elif (i, j) in toindices(obj2) and j not in (leftmost(obj2), rightmost(obj2)):
          O = fill(O, 2 if len(obj2) > len(obj1) else 1, {(i, j)})
    return O
 
11.5, tensor(1.7934), Description: The input grid contains two colored objects. The topmost object should be replaced with a 2x2 square of color 1, shifted one space to the left and one space up from its original position. The bottommost object should be replaced with a 2x2 square of color 2, shifted one space to the left and one space up from its original position. The output grid should be the same size as the input grid. 
:: def cbbjcdefjjdfebaiidfggfbbdadaifeb(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, uppermost)
  obj2 = other(objs, obj1)
  O = paint(paint(I, recolor(1, toindices(shift(canvas(ZERO,(2,2)), subtract(center(obj1),(1,1)))))), 
             recolor(2, toindices(shift(canvas(ZERO,(2,2)), subtract(center(obj2),(1,1))))))
  return O
 
11.5, tensor(1.7934), Description: The input grid contains two colored objects. The topmost object should be replaced with a 2x2 square of color 1, shifted one space to the left and one space up from its original position. The bottommost object should be replaced with a 2x2 square of color 2, shifted one space to the left and one space up from its original position. The output grid should be the same size as the input grid. 
:: def bdbajfjdgcjjeeccjdhcfajabcejciai(I):
    objs = objects(I, True, False, True)
    obj1 = first(objs)
    obj2 = other(objs, obj1)
    fill_value1 = 1 if uppermost(obj1) < uppermost(obj2) else 2
    fill_value2 = 3 - fill_value1
    I = underfill(I, fill_value1, backdrop(shift(canvas(ZERO, (2, 2)), subtract(center(obj1), (1, 1)))))
    O = underfill(I, fill_value2, backdrop(shift(canvas(ZERO, (2, 2)), subtract(center(obj2), (1, 1)))))
    return O
 
27.5, tensor(1.1386), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def efhebageajiaehcdjdeacadgcbgjfcfh(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), recolor(1, inbox(toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
27.0, tensor(1.1395), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def jgbhdfjfbiidedbfbedhbfhahfhjeeda(I):
    objs = objects(I, True, False, True)
    obj1 = first(objs)
    obj2 = other(objs, obj1)
    smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
    larger_obj = obj2 if len(obj1) < len(obj2) else obj1
    
    O = paint(canvas(0, shape(I)), recolor(1, toindices(smaller_obj) - box(toindices(smaller_obj))))
    O = paint(O, recolor(2, toindices(larger_obj) - box(toindices(larger_obj))))
    return O
 
0.0, tensor(1.1403), Description: The input grid contains two colored objects. The larger object should be filled with color 2, excluding its border cells. The smaller object should be filled with color 1, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def bddfaegeabfdefcfbagebgdjdigieajj(I):
    objs = objects(I, True, False, True)
    obj1 = argmax(objs, size)
    obj2 = argmin(objs, size)

    O = I 
    for i in range(1, height(obj2)-1):
      for j in range(1, width(obj2)-1):
        O = fill(O, 1, {(i + uppermost(obj2), j + leftmost(obj2))})
    for i in range(1, height(obj1)-1):
      for j in range(1, width(obj1)-1):
        O = fill(O, 2, {(i + uppermost(obj1), j + leftmost(obj1))})
    return O
 
95.0, tensor(1.0108), Description: The input grid contains a single colored object. If the object is 6 rows tall, replace the color 4 in the middle rows with color 1. If the object is not 6 rows tall, replace the color 4 in the middle rows with color 2. The output grid should be the same size as the input grid. 
:: def ebccbbgbidcceidiafefdedabbaidbgh(I):
  obj = first(objects(I, T, F, T)) # Extract the only object (assuming single object)
  h = height(obj) 
  upper = crop(I, ulcorner(obj), (2, width(obj))) # Extract top two rows
  middle = crop(I, (ulcorner(obj)[0] + 2, ulcorner(obj)[1]), (h - 4, width(obj))) # Extract middle rows
  lower = crop(I, (ulcorner(obj)[0] + h - 2, ulcorner(obj)[1]), (2, width(obj))) # Extract bottom two rows
  recolored_middle = replace(middle, FOUR, ONE) if h == 6 else replace(middle, FOUR, TWO)
  O = vconcat(vconcat(upper, recolored_middle), lower) 
  return O
 
38.5, tensor(0.3881), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1. The larger object should be surrounded by a border of color 2. The output grid should be the same size as the input grid. 
:: def cbjbgafagdjbedfdaejcadecjacjfgbh(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), recolor(1, delta(toindices(smaller_obj))))
  O = paint(O, recolor(2, delta(toindices(larger_obj))))
  return O
 
12.5, tensor(1.7792), Description: The input grid contains one or more colored objects. For each object, if the object is 6 rows tall, fill the middle two rows with color 1. If the object is not 6 rows tall, fill the inner area of the object (excluding the border cells) with color 1 if the object is in the left half of the grid, and color 2 if it is in the right half. The output grid should be the same size as the input grid. 
:: def edfbbaejdfbfecagbebbebacbdeabdaf(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    h = height(obj)
    for i, j in toindices(obj):
      if h == 6:
        if i in interval(uppermost(obj) + 2, uppermost(obj) + 4, 1):
          O = fill(O, ONE, {(i, j)})
      else:
        if uppermost(obj) + 1 < i < lowermost(obj) - 1:
          O = fill(O, ONE if j < len(I[0]) // 2 else TWO, {(i, j)})
  return O
 
13.0, tensor(1.7792), Description: The input grid contains one or more colored objects. For each object, if the object is 6 rows tall, fill the middle two rows with color 1. If the object is not 6 rows tall, fill the inner area of the object (excluding the border cells) with color 1 if the object is in the left half of the grid, and color 2 if it is in the right half. The output grid should be the same size as the input grid. 
:: def djiicbagaebeeefcicacfcfjdffadcfe(I):
  O = I
  for obj in objects(I, T, F, T):
    upper = uppermost(obj)
    lower = lowermost(obj)
    h = lower - upper + 1
    if h == 6:
      O = fill(O, ONE, toindices(toobject(crop(I, (upper + 2, 0), (2, len(I[0]))), I)))
    else:
      for i in range(upper + 2, lower):
        for j in range(len(I[0])):
          if (i, j) in toindices(obj):
            O = fill(O, ONE if j < len(I[0]) // 2 else TWO, {(i, j)})
  return O
 
16.0, tensor(1.7865), Description: The input grid contains one or more colored objects. For each object, if the object is 6 rows tall, fill the inner area of the object (excluding the border cells) with color 1. If the object is not 6 rows tall, split the object horizontally into two halves. Fill the left half with color 1 and the right half with color 2. The output grid should be the same size as the input grid. 
:: def adiaedihbdacefbabfgifdaehecbbccb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if height(obj) == 6:
      O = underfill(O, ONE, inbox(obj))
    else:
      h = height(obj) // 2
      left_part = crop(I, (uppermost(obj) + 1, leftmost(obj) + 1), (h, width(obj) - 2))
      right_part = crop(I, (uppermost(obj) + h, leftmost(obj) + 1), (h, width(obj) - 2))
      O = underfill(O, ONE, asindices(left_part))
      O = underfill(O, TWO, asindices(right_part))
  return O
 
5.5, tensor(1.7854), Description: The input grid contains one or more colored objects. For each object, if the object is 6 rows tall, fill the inner area of the object (excluding the border cells) with color 1. If the object is not 6 rows tall, split the object vertically into two halves. Fill the left half with color 1 and the right half with color 2. The output grid should be the same size as the input grid. 
:: def icjdaddabgdeeaagaiddffbfadiifabd(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if height(obj) == 6:
      O = fill(O, ONE, inbox(obj))
    else:
      mid = leftmost(obj) + width(obj) // 2
      left_indices = frozenset((i, j) for i, j in toindices(inbox(obj)) if j < mid)
      right_indices = frozenset((i, j) for i, j in toindices(inbox(obj)) if j >= mid)
      O = fill(O, ONE, left_indices)
      O = fill(O, TWO, right_indices)
  return O
 
12.5, tensor(1.5863), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the 2x2 square in the center of the object with color 1 if the object is in the top half of the grid, and color 2 if the object is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def eafahdccdddfeaeiafgadbehahigjbcf(I):
    def recolor_subgrid(obj):
        if width(obj) >= 2 and height(obj) >= 2:
            i, j = ulcorner(obj)
            new_color = 1 if i < len(I) // 2 else 2
            sub = crop(I, (i+1, j+1), (2, 2))
            sub = replace(sub, sub[0][0], new_color)
            return toobject(frozenset({(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)}), sub)
        else:
            return obj
    return paint(I, merge(apply(recolor_subgrid, objects(I, T, F, F))))
 
11.5, tensor(1.7653), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the 2x2 square in the center of the object with color 1 if the object is above the horizontal midline of the grid, and color 2 if it is below the midline. Otherwise, leave the object unchanged. 
:: def hdjcjgfgiefaedbaadcffgjaeigfaabh(I):
    objs = objects(I, T, F, F)
    midline = len(I) // 2
    def recolor_relative(obj):
        if width(obj) >= 2 and height(obj) >= 2:
            i, j = ulcorner(obj)
            rel_pos = position(frozenset({(midline, 0)}), obj) # Position relative to the midline
            new_color = 1 if rel_pos[0] == -1 else 2
            return recolor(new_color, frozenset({(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)}))
        else:
            return obj
    return paint(I, merge(apply(recolor_relative, objs)))
 
11.5, tensor(1.7695), Description: The input grid contains two colored objects. If the first object is a square, fill the 2x2 square in the center of the object with color 1. If the first object is not a square, fill the 2x2 square in the center of the object with color 2. Repeat the same process for the second object. The output grid should be the same size as the input grid. 
:: def cdjfecfeaacbeedfjjjcddcabheajccf(I):
  obj1 = first(objects(I, True, False, True))
  obj2 = other(objects(I, True, False, True), obj1)

  O = I
  for i in range(center(obj1)[0] - (not square(obj1)), center(obj1)[0] + (not square(obj1)) + 1):
    for j in range(center(obj1)[1] - (not square(obj1)), center(obj1)[1] + (not square(obj1)) + 1):
      O = paint(O, {(1, (i, j))})

  for i in range(center(obj2)[0] - (not square(obj2)), center(obj2)[0] + (not square(obj2)) + 1):
    for j in range(center(obj2)[1] - (not square(obj2)), center(obj2)[1] + (not square(obj2)) + 1):
      O = paint(O, {(2, (i, j))})
  return O
 
10.5, tensor(1.1351), Description: The input grid contains one or more colored objects. For each object, if it is a square, replace the center cell of the object with color 1. If it is not a square, replace the 2x2 square centered on the object with the corresponding color (1 for the first object, 2 for the second, and so on). The output grid should be the same size as the input grid. 
:: def hfiddaigecbcejagjffdedbhfahgcahb(I):
  O = I
  for n, obj in enumerate(objects(I, True, False, True)):
    O = branch(
        square(obj), 
        paint(O, {(n + 1, center(obj))}), 
        paint(O, recolor(n + 1, crop(canvas(0, shape(obj)), subtract(center(obj), UNITY), astuple(2, 2)))))
  return O
 
12.5, tensor(1.7062), Description: The input grid contains one or more colored objects. For each object, if the object is taller than it is wide, fill the inner area of the object (excluding the border cells) with color 1. If the object is wider than it is tall, fill the inner area of the object (excluding the border cells) with color 1, and then fill the next row down with color 2. The output grid should be the same size as the input grid. 
:: def fcdajfihcjaceabciejjddiejbfhjceg(I):
  O = I
  for obj in objects(I, T, F, T):
    upper = uppermost(obj)
    h = height(obj)
    w = width(obj)
    if h > w:
      O = underfill(O, ONE, toindices(toobject(crop(I, (upper+1, 1), (h-2, 2)), I))) 
    else:
      O = underfill(O, TWO, toindices(toobject(crop(I, (upper+1, 1), (h-2, 2)), I)))
      O = underfill(O, ONE, toindices(toobject(crop(I, (upper+2, 1), (h-2, 2)), I)))
  return O
 
16.0, tensor(1.7875), Description: The input grid contains one or more colored objects. For each object, if the object is taller than it is wide, fill the area surrounding the object (excluding the border cells) with color 1. If the object is wider than it is tall, fill the area surrounding the object (excluding the border cells) with color 1, and then fill the area surrounding the object shifted one space down with color 2. The output grid should be the same size as the input grid. 
:: def fhcgjeidjjgdecabaibceiedhbfjdbgc(I):
  O = I
  for obj in objects(I, T, F, T):
    if portrait(obj):
      O = underfill(O, ONE, difference(box(obj), outbox(obj)))
    else:
      O = underfill(O, TWO, difference(box(obj), outbox(obj)))
      O = underfill(O, ONE, difference(box(shift(obj, DOWN)), outbox(shift(obj, DOWN))))
  return O
 
160.5, tensor(0.5875), Description: The input grid is divided horizontally into two halves. For each object in the top half, the 2x2 square in the center of the object is filled with color 1. For each object in the bottom half, the 2x2 square in the center of the object is filled with color 2. If an object is smaller than 2x2, it is left unchanged. The output grid should be the same size as the input grid. 
:: def gdagjfdaaafaedhdabcaaacfcdacbfff(I):
  def recolor_center(obj, color):
    if width(obj) >= 2 and height(obj) >= 2:
      ci, cj = centerofmass(obj)
      return recolor(color, {(ci, cj), (ci + 1, cj), (ci, cj + 1), (ci + 1, cj + 1)})
    return obj
  
  top, bottom = hsplit(I, 2)
  top_objs = apply(lambda obj: recolor_center(obj, 1), objects(top, T, F, F))
  bottom_objs = apply(lambda obj: recolor_center(obj, 2), objects(bottom, T, F, F))
  return vconcat(paint(top, merge(top_objs)), paint(bottom, merge(bottom_objs)))
 
60.0, tensor(1.7847), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the inner area of the object (excluding the border cells) with color 1 if the object is to the left of the vertical midline of the grid, and color 2 if it is to the right of the midline. Otherwise, leave the object unchanged. 
:: def afchehfhdaegechgaaaecbefbhjififa(I):
  def modify_object(obj, mid):
    if width(obj) >= 2 and height(obj) >= 2:
      ulx, uly = ulcorner(obj)
      lrx, lry = lrcorner(obj)
      return recolor(1 if (ulx + lrx) // 2 < mid else 2, {(i, j) for i in range(ulx + 1, lrx) for j in range(uly + 1, lry)})
    return obj

  midpoint = len(I) // 2
  modified_objs = apply(lambda obj: modify_object(obj, midpoint), objects(I, T, F, F))
  return paint(I, merge(modified_objs))
 
14.0, tensor(1.7725), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the 2x2 square in the top-left corner of the object with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def ddjdcaaajjidebbeiejhafbgfhbiefgf(I):
  def process_object(obj):
    w, h = width(obj), height(obj)
    if w >= 2 and h >= 2:
      ci, cj = centerofmass(obj)
      color = 1 if ci < len(I) // 2 else 2
      return recolor(color, {(ci, cj), (ci - 1, cj), (ci, cj - 1), (ci - 1, cj - 1)})
    return obj

  return paint(I, merge(apply(process_object, objects(I, T, F, F))))
 
36.0, tensor(1.2455), Description: The input grid contains one or more colored objects. For each object, if it is a 2x2 square or larger, fill the inner area of the object (excluding the border cells) with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half of the grid. Otherwise, leave the object unchanged. 
:: def jhfdejjaejeeefefjfebiiibafhdccfd(I):
  def color_middle(obj, middle):
    if width(obj) >= 2 and height(obj) >= 2:
      return recolor((1 if uppermost(obj) < middle else 2), {(i, j) for i, j in toindices(obj) 
                                                             if  uppermost(obj) < i < lowermost(obj) 
                                                             and leftmost(obj) < j < rightmost(obj)})
    return obj

  mid = len(I) // 2
  new_objects = apply(lambda x: color_middle(x, mid), objects(I, T, F, F))
  return paint(I, merge(new_objects))
 
15.0, tensor(1.7798), Description: The input grid contains one or more colored objects. For each object, if it is taller than it is wide, draw a vertical line of color 1 or 2 through the center of the object, depending on whether the object is in the top or bottom half of the grid. If the object is wider than it is tall, draw a horizontal line of color 1 or 2 through the center of the object, depending on whether the object is in the top or bottom half of the grid. If the object is a square, fill the 2x2 square in the top-left corner of the object with color 1 or 2, depending on whether the object is in the top or bottom half of the grid. The output grid should be the same size as the input grid. 
:: def ecccijbaafaheggfiaaegbgdcbaeiebe(I):
  O = I
  for obj in objects(I, True, False, False):
    h, w = shape(obj)
    fill_value = 2 if uppermost(obj) >= len(I) // 2 else 1
    if h > w:  # Vertical object
      start = (uppermost(obj) + h // 2 - 1, leftmost(obj))
      O = fill(O, fill_value, connect(start, add(start, (1, 0))))
    elif w > h:  # Horizontal object
      start = (uppermost(obj), leftmost(obj) + w // 2 - 1)
      O = fill(O, fill_value, connect(start, add(start, (0, 1))))
    else:  # Square object
      center_i, center_j = center(obj)
      O = fill(O, fill_value, frozenset({(center_i, center_j), (center_i - 1, center_j), (center_i, center_j - 1), (center_i - 1, center_j - 1)}))
  return O
 
11.0, tensor(1.7625), Description: The input grid contains one or more colored objects. For each object, fill the cells that are diagonally adjacent to the center cell of the object with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half. The output grid should be the same size as the input grid. 
:: def ejcjbfiiiiccedaebbbfiaebbbicjcad(I):
  O = I
  for obj in objects(I, True, False, False):
    fill_value = 2 if uppermost(obj) >= len(I) // 2 else 1
    center_i, center_j = center(obj)
    for di in range(-1, 1):
      for dj in range(-1, 1):
        if abs(di) != abs(dj):
          target = (center_i + di, center_j + dj)
          if contained(target, toindices(obj)):
            O = fill(O, fill_value, frozenset({target}))
  return O
 
25.0, tensor(0.8736), Description: The input grid contains one or more colored objects. For each object, if it is taller than it is wide, draw a vertical line of color 1 or 2 through the object, depending on whether the object is in the top or bottom half of the grid. If the object is wider than it is tall, draw a horizontal line of color 1 or 2 through the object, depending on whether the object is in the top or bottom half of the grid. The output grid should be the same size as the input grid. 
:: def jhdageefhbdfehfebcaagciefhfccegf(I):
  O = I
  for obj in objects(I, True, False, False):
    fill_value = 2 if uppermost(obj) >= len(I) // 2 else 1
    if portrait(obj):  # Vertical object
      O = fill(O, fill_value, connect(add(ulcorner(obj), (1, 0)), add(llcorner(obj), (-1, 0))))
    else:  # Horizontal object or square
      O = fill(O, fill_value, connect(add(ulcorner(obj), (0, 1)), add(urcorner(obj), (0, -1))))
  return O
 
32.5, tensor(1.1278), Description: The input grid contains one or more colored objects. The topmost object should be filled with color 1, excluding its border cells. The bottommost object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def fdacddbfffjaefijiadjgbejidbacibd(I):
  O = I
  objs = objects(I, True, False, False)
  top_obj = argmax(objs, lambda x: -uppermost(x))  # Get the topmost object
  bottom_obj = argmin(objs, lambda x: -uppermost(x))  # Get the bottommost object
  O = fill(O, 1, inbox(toindices(top_obj))) # Fill the 'inbox' of the top object with 1
  O = fill(O, 2, inbox(toindices(bottom_obj))) # Fill the 'inbox' of the bottom object with 2
  return O
 
9.5, tensor(1.7767), Description: The input grid contains one or more colored objects. For each object, if it is a square, fill the 2x2 square in the top-left corner of the object with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half of the grid. If the object is not a square, fill the two cells in the center of the object with color 1 if the object is vertical, and color 2 if the object is horizontal. The output grid should be the same size as the input grid. 
:: def edjaejbcedhaejagjddajdbgfdfedbbd(I):
  O = I
  for obj in objects(I, True, False, False):
    fill_value = 2 if uppermost(obj) >= len(I) // 2 else 1
    if square(obj):  # Square object
      center_i, center_j = center(obj)
      O = fill(O, fill_value, frozenset({(center_i, center_j), (center_i - 1, center_j), (center_i, center_j - 1), (center_i - 1, center_j - 1)}))
    else: # Non-square object
      c = centerofmass(obj)
      if portrait(obj): # Vertical
        O = fill(O, fill_value, {(c[0]-1, c[1]), (c[0], c[1])})
      else: # Horizontal
        O = fill(O, fill_value, {(c[0], c[1]-1), (c[0], c[1])})
  return O
 
8.5, tensor(1.1167), Description: The input grid contains one or more colored objects. For each object, if it is a square, replace the center cell of the object with the corresponding color (1 for the first object, 2 for the second, and so on). If it is not a square, replace the 2x2 square centered on the object with the corresponding color. The output grid should be the same size as the input grid. 
:: def eeeagcfibaecedfabcjghacbjeffhddc(I):
  objs = objects(I, True, False, True)
  O = I
  for n, obj in enumerate(objs):
    center_i, center_j = center(obj)
    if square(obj):
      O = paint(O, {(n + 1, (center_i, center_j))})
    else:
      O = paint(O, recolor(n + 1, {(center_i - 1 + i, center_j - 1 + j) for i in range(2) for j in range(2)}))
  return O
 
34.5, tensor(1.1167), Description: The input grid contains one or more colored objects. For each object, if it is a square, replace the center cell of the object with the corresponding color (1 for the first object, 2 for the second, and so on). If it is not a square, replace the 2x2 square centered on the object with the corresponding color. The output grid should be the same size as the input grid. 
:: def fbbdffbhdgdbeedeigbhdgdcdbfcbjia(I):
  objs = objects(I, True, False, True)
  O = canvas(0, shape(I))
  for n, obj in enumerate(objs):
    O = underpaint(O, recolor(n+1, branch(square(obj), {(center(obj))}, {(center(obj)[0]-1+i, center(obj)[1]-1+j) for i in range(2) for j in range(2)})))
  return O
 
158.5, tensor(1.1309), Description: The input grid is divided horizontally into two halves. For each object in the top half, the 2x2 square in the center of the object is filled with color 2 if there are no objects in the bottom half, and color 1 if there are objects in the bottom half. For each object in the bottom half, the 2x2 square in the center of the object is filled with color 1 if there are no objects in the top half, and color 2 if there are objects in the top half. If an object is smaller than 2x2, it is left unchanged. The output grid should be the same size as the input grid. 
:: def abdhfieiebedehjfihdeibefbeegafad(I):
  def modify_object(obj, value):
    if width(obj) >= 2 and height(obj) >= 2:
      i, j = ulcorner(obj)
      return recolor(value, {(i + 1, j + 1), (i + 1, j + 2), (i + 2, j + 1), (i + 2, j + 2)})
    return obj

  top, bottom = hsplit(I, 2)
  top_objs = apply(lambda obj: modify_object(obj, 2 if len(objects(bottom, T, F, F)) == 0 else 1), objects(top, T, F, F))
  bottom_objs = apply(lambda obj: modify_object(obj, 1 if len(objects(top, T, F, F)) == 0 else 2), objects(bottom, T, F, F))
  return vconcat(paint(top, merge(top_objs)), paint(bottom, merge(bottom_objs)))
 
58.0, tensor(1.7457), Description: Divide the input grid horizontally into two halves. Fill the top half with color 1 and the bottom half with color 2, except for the border cells. 
:: def jdjbbfbfhceaebigagaceigddcbadddd(I):
  def modify_cell(i, j):
    if i > 0 and j > 0 and i < len(I) - 1 and j < len(I[0]) - 1:
      return 2 if i >= len(I) // 2 else 1
    return I[i][j]

  return tuple(tuple(modify_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
51.5, tensor(1.7457), Description: Divide the input grid horizontally into two halves. Fill the top half with color 1 and the bottom half with color 2, except for the border cells. 
:: def adfachggcgbfeieiacfcddaehggefbca(I):
  h = len(I) // 2
  top = tuple(tuple(1 if i > 0 and j > 0 and i < h - 1 and j < len(I[0]) - 1 else I[i][j] for j in range(len(I[0]))) for i in range(h))
  bottom = tuple(tuple(2 if i > 0 and j > 0 and i < len(I) - 1 and j < len(I[0]) - 1 else I[i][j] for j in range(len(I[0]))) for i in range(h, len(I)))
  return vconcat(top, bottom)
 
57.5, tensor(1.7836), Description: Divide the input grid horizontally into two halves. Fill the inner cells of the top half with color 1 and the inner cells of the bottom half with color 2. The border cells remain unchanged. 
:: def fcagfacafbcdeiecbfehbhfcbbddabdi(I):
  def process_row(row, value):
    if len(row) >= 2:
      return (row[0],) + tuple(value for _ in range(1, len(row) - 1)) + (row[-1],)
    return row

  h = len(I) // 2
  return tuple(process_row(row, 1 if i in range(1, h) else 2 if i in range(h + 1, len(I) - 1) else I[i][0]) for i, row in enumerate(I))
 
19.5, tensor(0.0053), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. The outer border of the larger object should remain its original color. 
:: def acddedgfajfdegfbjcdeajjgeeecfbbj(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = paint(canvas(0, shape(I)), recolor(1, toindices(smaller_obj)))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  O = paint(O, recolor(color(larger_obj), toindices(larger_obj)))
  return O
 
11.5, tensor(0.0051), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def badbefcbhafcehbcjafjfdafdfeffggf(I):
  objs = objects(I, True, False, True)
  a, b = tuple(objs)
  smaller_obj = a if len(a) < len(b) else b
  larger_obj = b if len(a) < len(b) else a
  
  O = I
  for i, j in toindices(smaller_obj):
    O = fill(O, 1, {(i, j)})
  for i, j in inbox(toindices(larger_obj)):
    O = fill(O, 2, {(i, j)})
  return O
 
35.5, tensor(0.0053), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. The outer border of the larger object should remain its original color. 
:: def fdifhdegjdbieddcidcedibfbgadeceb(I):
  objs = order(objects(I, True, False, True), size)
  O = paint(canvas(0, shape(I)), recolor(1, toindices(objs[0])))
  O = underfill(paint(O, recolor(2,  box(toindices(objs[1])))), color(objs[1]), toindices(objs[1]))
  return O
 
11.0, tensor(0.0051), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def aefcaeefdbjfefdgbhcjifgjbgbaeafi(I):
  objs = objects(I, True, False, True)
  a, b = tuple(objs)
  smaller_obj = a if len(a) < len(b) else b
  larger_obj = b if len(a) < len(b) else a

  O = I
  for i in range(uppermost(smaller_obj), lowermost(smaller_obj) + 1):
    for j in range(leftmost(smaller_obj), rightmost(smaller_obj) + 1):
      if (i, j) in toindices(smaller_obj):
        O = fill(O, 1, {(i, j)})
  for i in range(uppermost(larger_obj) + 1, lowermost(larger_obj)):
    for j in range(leftmost(larger_obj) + 1, rightmost(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
35.5, tensor(0.8374), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be surrounded by a border of color 2. The output grid should be the same size as the input grid. 
:: def bdccbijffgggeccabiaidgfdefaejfaf(I):
  objs = order(objects(I, True, False, True), size)
  O = replace(I, color(objs[0]), 1)
  O = fill(O, 2, delta(toindices(objs[1])))
  return O
 
0.0, tensor(0.7053), Description: The input grid contains one or more colored objects. For each object, fill the inner area (excluding the border cells) with color 1 if the object is the smallest object in the grid, and color 2 if it is not the smallest object. The output grid should be the same size as the input grid. 
:: def cjdfhheceafaebhcafcfejifcfacfgfc(I):
  O = I
  for obj in objects(I, True, False, True):
    value = 1 if len(obj) == valmin(objects(I, True, False, True), len) else 2
    O = paint(O, recolor(value, toindices(obj)-box(toindices(obj))))
  return O
 
0.0, tensor(0.4515), Description: The input grid contains two or more colored objects. For each object, fill the inner area (excluding the border cells) with color 2 if the object is larger than the other object, and color 1 if it is smaller. If there are more than two objects, fill the inner area of each object with color 1. The output grid should be the same size as the input grid. 
:: def aadabidjeffeegadjbchfhhachfdeijd(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  O = I
  for obj in objs:
    if len(objs) == 2:
      O = fill(O, 2 if len(obj) > len(other(objs, obj)) else 1, difference(toindices(obj), box(obj)))
    else:
      O = fill(O, 1, difference(toindices(obj), box(obj))) 
  return O
 
0.0, tensor(0.0397), Description: The input grid contains two colored objects. The larger object should be filled with color 2, excluding its border cells. The smaller object should be filled with color 1, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def ddccceafabbfejjeicdcceebabgedhge(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, size)
  obj2 = other(objs, obj1)
  O = I
  for obj in objs:
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if (i, j) in toindices(obj):
          O = fill(O, 2 if obj == obj1 else 1, {(i, j)})
  return O
 
0.5, tensor(0.0397), Description: The input grid contains two colored objects. The larger object should be filled with color 2, excluding its border cells. The smaller object should be filled with color 1, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def faebfbgcaadbecdibggfaedagbdcifbc(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, size)
  obj2 = other(objs, obj1)
  O = paint(I, recolor(2, inbox(obj1)))
  O = paint(O, recolor(1, inbox(obj2)))
  return O
 
22.0, tensor(0.0248), Description: The input grid contains one or more colored objects. For each object, if the object has 20 or more cells, fill the cell with color 2. Otherwise, fill the cell with color 1. The output grid should be the same size as the input grid. 
:: def bgceefbfaeafefeciaiaebffahehdhab(I):
  O = I
  for i in range(1, height(I)-1):
    for j in range(1, width(I)-1):
      if I[i][j] != 0:
        obj = extract(objects(I, True, False, True), lambda obj: (i,j) in toindices(obj))
        O = fill(O, 2 if size(obj) >= 20 else 1, {(i, j)})
  return O
 
30.5, tensor(0.0080), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def gaebifcjghiceffaagfdcfcjfhfccabc(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(1, box(toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
27.5, tensor(0.0080), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def eheaideediaeecgbibifggddhddbfdjb(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = branch(size(obj1) < size(obj2), obj1, obj2)
  larger_obj = branch(size(obj1) < size(obj2), obj2, obj1)
  O = canvas(0, shape(I))
  O = paint(O, recolor(1, backdrop(toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
14.5, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells and the smaller object) should be filled. The output grid should be the same size as the input grid. 
:: def acjbbaeeebeiecieidbcdcbiageahcid(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  is_obj1_smaller = size(obj1) < size(obj2)
  smaller_obj = branch(is_obj1_smaller, obj1, obj2)
  larger_obj =  branch(is_obj1_smaller, obj2, obj1)
  O = I
  O = paint(O, recolor(1, box(toindices(smaller_obj))))
  O = paint(O, recolor(2, difference(inbox(toindices(larger_obj)), toindices(smaller_obj))))
  return O
 
11.0, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def fgifedajbeadeficiebdeejhjdcbhdaj(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = I
  for i, j in toindices(delta(inbox(toindices(smaller_obj)))):
    if index(I, (i, j)) != 0:
      O = fill(O, 1, {(i, j)})
  for i, j in toindices(delta(inbox(toindices(larger_obj)))):
    if index(I, (i, j)) != 0:
      O = fill(O, 2, {(i, j)})
  return O
 
38.0, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def babbeibegfieeaeaiifecggiccddjefh(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = argmin({obj1, obj2}, size)
  larger_obj = argmax({obj1, obj2}, size)

  O = paint(canvas(0, shape(I)), recolor(1, delta(inbox(toindices(smaller_obj)))))
  O = paint(O, recolor(2, delta(inbox(toindices(larger_obj)))))
  return O
 
11.5, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def idfdfgdichfaegcibeciccbjdcbccefc(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if size(obj1) < size(obj2) else obj2
  larger_obj = obj2 if size(obj1) < size(obj2) else obj1

  O = I
  O = underfill(O, 1, delta(inbox(toindices(smaller_obj))))
  O = underfill(O, 2, delta(inbox(toindices(larger_obj))))
  return O
 
38.5, tensor(0.0067), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. The background color of the output grid should be the most common color in the input grid. 
:: def cfgaaciebcebedcibfbfabdecbagehjf(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), toobject(delta(inbox(toindices(smaller_obj))), replace(I, mostcolor(I), 1)))
  O = paint(O, toobject(delta(inbox(toindices(larger_obj))), replace(I, mostcolor(I), 2)))
  return O
 
0.0, tensor(0.0088), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def eabbbfbiafbfebagijcdbeeaeddbbjeg(I):
  objs = sorted(objects(I, True, False, True), key=size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = I
  for i in range(uppermost(smaller_obj) + 1, lowermost(smaller_obj)):
    for j in range(leftmost(smaller_obj) + 1, rightmost(smaller_obj)):
      O = fill(O, 1, {(i, j)})
  for i in range(uppermost(larger_obj) + 1, lowermost(larger_obj)):
    for j in range(leftmost(larger_obj) + 1, rightmost(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
27.0, tensor(0.0612), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2. The output grid should be the same size as the input grid. 
:: def edgcfigejfegefdbifihadfigfgahddj(I):
  objs = objects(I, True, False, True)
  smaller_obj = argmin(objs, len)
  larger_obj = other(objs, smaller_obj)
  O = paint(canvas(0, shape(I)), recolor(1, toindices(smaller_obj)))
  O = paint(O, recolor(2, toindices(larger_obj)))
  return O 
 
22.0, tensor(0.5458), Description: The input grid contains two colored objects. For each object, fill the inner area (excluding the border cells) with color 2 if the object is larger than the other object, and color 1 if it is smaller. However, only fill the cells that are not bordering any other cells in the same row. If there are more than two objects, fill the inner area of each object with color 1. The output grid should be the same size as the input grid. 
:: def cjggcfcddaajebedaabhacgfbjffehfg(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if (i, j) in toindices(obj1) and not bordering({(i, j)}, I) and len(set(row)) > 1:
        O = fill(O, 2 if len(obj1) > len(obj2) else 1, {(i, j)})
      elif (i, j) in toindices(obj2) and not bordering({(i, j)}, I) and len(set(row)) > 1:
        O = fill(O, 2 if len(obj2) > len(obj1) else 1, {(i, j)})
  return O
 
8.5, tensor(0.3196), Description: The input grid contains one or more colored objects. For each object, if the object has 20 or more cells, fill the inner area (excluding the border cells) with color 2. Otherwise, fill the inner area (excluding the border cells) with color 1. The output grid should be the same size as the input grid. 
:: def fecachfficefecajijecadgeaicdifjh(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    O = paint(O, recolor(2 if size(obj) == 20 else 1, inbox(obj)))
  return O
 
35.5, tensor(0.0186), Description: The input grid contains one or more colored objects. For each object, if the object has 20 or more cells, fill the object with color 2. Otherwise, fill the object with color 1. The output grid should be the same size as the input grid. 
:: def bifdacaibfddecfdjbjchibjeicbddaa(I):
  return paint(
      paint(I, recolor(2, mfilter(objects(I, True, False, True), lambda obj: size(obj) == 20))),
      recolor(1, mfilter(objects(I, True, False, True), lambda obj: size(obj) != 20))
  )
 
22.5, tensor(0.0034), Description: The input grid contains two colored objects. The smaller object should be filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def dfiffedgijibebjbbaicdddaaddadcdi(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = argmin({obj1: size(obj1), obj2: size(obj2)}, lambda x: x)
  larger_obj = argmax({obj1: size(obj1), obj2: size(obj2)}, lambda x: x)
  O = I
  for i, j in toindices(smaller_obj):
    O = fill(O, 1, {(i, j)})
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
11.5, tensor(0.0039), Description: The input grid contains one or more colored objects. The smallest object should be filled with color 1. All other objects should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def iecgdeeieadfedfeiccbcjafecefadge(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    fill_color = 1 if size(obj) == min(size(o) for o in objs) else 2
    O = paint(O, recolor(fill_color, toindices(obj)) if fill_color == 1 else recolor(fill_color, inbox(toindices(obj))))
  return O
 
27.0, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def aiafajbdgbajeiegaghebacejfaeeaeg(I):
  objs = objects(I, True, False, True)
  smaller_obj = min(objs, key=len)
  larger_obj = max(objs, key=len)

  O = paint(canvas(0, shape(I)), recolor(1, backdrop(smaller_obj)))
  O = paint(O, recolor(2, backdrop(larger_obj)))
  return O
 
11.5, tensor(0.0072), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of the most common color within the object, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of the most common color within the object, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def bajdejcicdgjebjdaacgcffabhadjghi(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1
  O = paint(canvas(0, shape(I)), recolor(mostcolor(smaller_obj), toindices(smaller_obj)-inbox(toindices(smaller_obj))))
  O = paint(O, recolor(mostcolor(larger_obj), toindices(larger_obj)-inbox(toindices(larger_obj))))
  return O
 
0.5, tensor(0.0029), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def dafdaefjbccbeicejbfcibbdcecaaafc(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = argmin(objs, size)
  larger_obj = argmax(objs, size)
  O = paint(I, recolor(1, inbox(toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
27.5, tensor(0.0029), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def cbjcacgedffdecefbbedeigacdhcacge(I):
  objs = objects(I, True, False, True)
  smaller_obj = min(objs, key=lambda x: len(x))
  larger_obj = max(objs, key=lambda x: len(x))
  O = paint(canvas(0, shape(I)), recolor(1, inbox(toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
0.5, tensor(0.0316), Description: The input grid contains two colored objects. The larger object should be filled with color 2, excluding its border cells. The smaller object should be filled with color 1, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def fghaedfceedgeiadaciagabceijdccbh(I):
    objs = objects(I, True, False, True)
    obj1 = argmax(objs, size)
    obj2 = argmin(objs, size)
    return paint(paint(I, recolor(2, inbox(obj1))), recolor(1, inbox(obj2)))
 
11.5, tensor(0.1847), Description: The input grid contains two colored objects. If the first object is larger than the second object, surround the first object with a border of color 2 and the second object with a border of color 1. If the second object is larger than the first object, surround the first object with a border of color 1 and the second object with a border of color 2. The output grid should be the same size as the input grid. 
:: def cjddagcciabfedicafdbbceibaeidibg(I):
    objs = objects(I, True, False, True)
    obj1, obj2 = order(objs, size)
    return branch(len(obj1) > len(obj2), paint(paint(I, recolor(2, delta(obj1))), recolor(1, delta(obj2))), 
                   paint(paint(I, recolor(1, delta(obj1))), recolor(2, delta(obj2))))
 
0.0, tensor(0.0043), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def diheecjjgceheafaafficgiiceicbihd(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = I
  for i in range(uppermost(smaller_obj) + 1, lowermost(smaller_obj)):
    for j in range(leftmost(smaller_obj) + 1, rightmost(smaller_obj)):
      O = fill(O, 1, {(i, j)})
  for i in range(uppermost(larger_obj) + 1, lowermost(larger_obj)):
    for j in range(leftmost(larger_obj) + 1, rightmost(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
7.5, tensor(0.0080), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, but only the bottom row of the object should be filled. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def cdhieahcefhfedgfbihaebcdheeccdhf(I):
  objs = objects(I, True, False, True)
  a, b = tuple(objs)
  smaller_obj = a if len(a) < len(b) else b
  larger_obj = b if len(a) < len(b) else a
  
  O = I
  for i, j in toindices(smaller_obj):
    if i == lowermost(smaller_obj):
      O = fill(O, 1, {(i, j)})
  for i, j in inbox(toindices(larger_obj)):
    O = fill(O, 2, {(i, j)})
  return O
 
15.5, tensor(0.0041), Description: The input grid contains two colored objects. The smaller object should have its bottom row filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def agibhibhecacebfaadbbeccjbjdcaeai(I):
  objs = objects(I, True, False, True)
  a, b = tuple(objs)
  smaller_obj = a if len(a) < len(b) else b
  larger_obj = b if len(a) < len(b) else a

  O = I
  for j in range(leftmost(smaller_obj), rightmost(smaller_obj) + 1):
    O = fill(O, 1, {(lowermost(smaller_obj), j)})
  O = fill(O, 2, difference(box(larger_obj), toindices(larger_obj)))
  return O
 
27.0, tensor(0.2256), Description: The input grid contains one or more colored objects. For each object, fill the inner area (excluding the border cells) with color 2 if the object is larger than the other object, and color 1 if it is smaller. If there is only one object, fill the inner area of that object with color 1. The output grid should be the same size as the input grid. 
:: def abfgiecieebbeaafbefecbfiiigefcff(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1) if len(objs) > 1 else obj1
  O = I
  if len(objs) > 1:
    O = paint(cover(O, obj1), recolor(2 if len(obj1) > len(obj2) else 1, difference(toindices(obj1), box(obj1))))
    O = paint(cover(O, obj2), recolor(2 if len(obj2) > len(obj1) else 1, difference(toindices(obj2), box(obj2))))
  else:
    O = paint(cover(O, obj1), recolor(1, difference(toindices(obj1), box(obj1))))
  return O
 
11.5, tensor(0.0049), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def eefgccjjijeheefgjcedbcfigffajdge(I):
  objs = objects(I, True, False, True)
  small_obj = min(objs, key=len)
  large_obj = max(objs, key=len)
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i,j) in delta(toindices(small_obj)):
        O = paint(O, {(1, (i,j))})
      if (i,j) in delta(toindices(large_obj)):
        O = paint(O, {(2, (i,j))})
  return O
 
12.5, tensor(0.7494), Description: The input grid contains two colored objects. If the first object is larger than the second object, replace the 2x2 square centered on the first object with color 1 and the 2x2 square centered on the second object with color 2. If the second object is larger than the first object, replace the 2x2 square centered on the first object with color 2 and the 2x2 square centered on the second object with color 1. The output grid should be the same size as the input grid. 
:: def beaebbbadedbefacagcadfjfbeedjega(I):
  objs = objects(I, True, False, True)
  obj1, obj2 = order(objs, size)
  return paint(paint(I, recolor(1, crop(canvas(0, shape(obj1)), subtract(center(obj1), UNITY), astuple(2, 2)))), 
               recolor(2, crop(canvas(0, shape(obj2)), subtract(center(obj2), UNITY), astuple(2, 2))))
 
3.5, tensor(0.0032), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def fcfgcdceidgfeaeaabadeffiecdedfdc(I):
  objs = objects(I, True, False, True)
  s_obj = min(objs, key=lambda o: len(toindices(o)))
  l_obj = max(objs, key=lambda o: len(toindices(o)))
  O = fill(I, 1, delta(toindices(s_obj)))
  O = fill(O, 2, inbox(toindices(l_obj)))
  return O
 
12.5, tensor(0.6101), Description: The input grid contains two colored objects. If the first object is larger than the second object, replace the 2x2 square centered on the first object with color 2 and the 2x2 square centered on the second object with color 1. If the second object is larger than the first object, replace the 2x2 square centered on the first object with color 1 and the 2x2 square centered on the second object with color 2. The output grid should be the same size as the input grid. 
:: def hdbffcejccddegiabbbbbfjhfbaacage(I):
  objs = objects(I, True, False, True)
  obj1, obj2 = order(objs, size)
  return paint(paint(I, recolor(2, crop(canvas(0, shape(obj1)), subtract(center(obj1), UNITY), (2, 2)))), 
               recolor(1, crop(canvas(0, shape(obj2)), subtract(center(obj2), UNITY), (2, 2))))
 
11.5, tensor(0.0417), Description: The input grid contains two or more colored objects. The largest object should be filled with color 2, excluding its border cells. All other objects should be filled with color 1, also excluding their border cells. The output grid should be the same size as the input grid. 
:: def baidgaaafeaaejcaigfdieacbbeabeab(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  return paint(paint(I, recolor(2, inbox(toindices(largest_obj)))), 
               recolor(1, mfilter(objs - {largest_obj}, lambda obj: inbox(toindices(obj))))) 
 
7.5, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should have its top two rows filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def ccfifdfbabjeeghfafbcgbdfebefgfhb(I):
  objs = objects(I, True, False, True)
  a, b = tuple(objs)
  smaller_obj = a if len(a) < len(b) else b
  larger_obj = b if len(a) < len(b) else a
  O = I
  for i in range(2):
    O = fill(O, 1, {(uppermost(smaller_obj) + i, j) for j in range(leftmost(smaller_obj), rightmost(smaller_obj) + 1)})
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
28.5, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should have its top two rows filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def hhcbgeeedfddeaeebadabeaacjacejac(I):
  objs = objects(I, True, False, True)
  smaller_obj = argmin(objs, len)
  larger_obj = argmax(objs, len)
  O = paint(canvas(0, shape(I)), recolor(1,  {(i, j) for i, j in toindices(smaller_obj) if i in range(uppermost(smaller_obj), uppermost(smaller_obj) + 2)}))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
10.5, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should have its top two rows filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def beeahhfdeafheibbidccjfbdabeggddb(I):
  objs = objects(I, True, False, True)
  smaller_obj = min(objs, key=lambda x: len(x))
  larger_obj = max(objs, key=lambda x: len(x))
  O = I
  for i, j in toindices(smaller_obj):
    if uppermost(smaller_obj) <= i < uppermost(smaller_obj) + 2:
      O = fill(O, 1, {(i, j)})
  for i, j in toindices(larger_obj):
    if (uppermost(larger_obj) < i < lowermost(larger_obj) - 1) and (leftmost(larger_obj) < j < rightmost(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
3.0, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, excluding the border cells of the larger object itself, and the inner area of the larger object should be filled with black. The output grid should be the same size as the input grid. 
:: def dabahhiageedebijbfacadceigeffahf(I):
  objs = [obj for obj in objects(I, True, False, True)]
  smaller_obj = min(objs, key=lambda x: len(toindices(x)))
  larger_obj = [obj for obj in objs if obj != smaller_obj][0]
  O = I
  for idx in delta(toindices(smaller_obj)):
    O = fill(O, 1, {idx})
  for idx in difference(backdrop(larger_obj), box(larger_obj)):
    O = fill(O, 2, {idx})
  return O
 
16.5, tensor(1.9902), Description: The input grid contains two colored objects. If the first object is larger than the second object, fill the 2x2 square centered on the first object with color 2 and the 2x2 square centered on the second object with color 1. If the second object is larger than the first object, fill the 2x2 square centered on the first object with color 1 and the 2x2 square centered on the second object with color 2. The output grid should be the same size as the input grid. 
:: def ihafecfhchcaeacfadgebdbadheebbfa(I):
  objs = objects(I, True, False, True)
  obj1, obj2 = order(objs, size)
  c1 = add(center(obj1), DOWN)
  c2 = subtract(center(obj2), UP)
  return fill(fill(I, 2 if len(obj1) > len(obj2) else 1, {(c1), add(c1, DOWN), add(c1, RIGHT), add(c1, (1, 1))}), 
               1, {(c2), add(c2, RIGHT), add(c2, DOWN), add(c2, (1, 1))})
 
17.0, tensor(1.9902), Description: The input grid contains two colored objects. If the first object is larger than the second object, fill the 2x2 square centered on the first object with color 2 and the 2x2 square centered on the second object with color 1. If the second object is larger than the first object, fill the 2x2 square centered on the first object with color 1 and the 2x2 square centered on the second object with color 2. The output grid should be the same size as the input grid. 
:: def cbbcfhfeafehegbdjadechccbhedadah(I):
  objs = objects(I, True, False, True)
  obj1, obj2 = order(objs, size)
  return paint(paint(I, recolor(2, {(add(center(obj1), (1, 1))), add(center(obj1), (2, 1)), add(center(obj1), (1, 2)), add(center(obj1), (2, 2))})), 
               recolor(1, {(add(center(obj2), (0, 1))), add(center(obj2), (1, 1)), add(center(obj2), (0, 2)), add(center(obj2), (1, 2))}))
 
4.5, tensor(0.0041), Description: The input grid contains two colored objects. The smaller object should have its left two columns filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def bcggefaaehecebeaijddgjcefbcceeab(I):
  objs = objects(I, True, False, True)
  smaller_obj = argmin(objs, size)
  larger_obj = argmax(objs, size)

  O = I
  for i in range(uppermost(smaller_obj), lowermost(smaller_obj) + 1):
    for j in range(leftmost(smaller_obj) + 1, leftmost(smaller_obj) + 3):
      O = fill(O, 1, {(i, j)})
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
27.5, tensor(0.0041), Description: The input grid contains two colored objects. The smaller object should have its left two columns filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def ffjdgafjcfdfebbejieediedjfchceae(I):
  objs = objects(I, True, False, True)
  smaller_obj = min(objs, key=len)
  larger_obj = max(objs, key=len)

  O = paint(canvas(0, shape(I)), recolor(2, inbox(toindices(larger_obj))))
  O = paint(O, recolor(1, frozenset((i, j) for i in range(uppermost(smaller_obj), lowermost(smaller_obj) + 1) for j in range(leftmost(smaller_obj) + 1, leftmost(smaller_obj) + 3))))
  return O
 
4.0, tensor(0.0077), Description: The input grid contains two colored objects. The smaller object should have its left two columns filled with color 1, excluding the border cells of the smaller object itself. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def ghjebdecfhaceecajaheffedeefeifdf(I):
  objs = sorted(objects(I, True, False, True), key=len)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = I
  for i, j in toindices(smaller_obj):
    if leftmost(smaller_obj) + 1 <= j <= leftmost(smaller_obj) + 2:
      O = fill(O, 1, {(i, j)})
  for i, j in toindices(larger_obj):
    if (i, j) not in box(toindices(larger_obj)):
      O = fill(O, 2, {(i, j)})
  return O
 
30.0, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, excluding the border cells of the larger object itself, and the inner area of the larger object should be filled with black. The output grid should be the same size as the input grid. 
:: def fgfebhehfdhaedecaegceiiciafgbcbd(I):
  sa, la = sorted([obj for obj in objects(I, True, False, True)], key=lambda x: len(x))
  O = paint(canvas(0, shape(I)), recolor(1, delta(toindices(sa))))
  O = paint(O, recolor(2, difference(backdrop(toindices(la)), box(toindices(la)))))
  return O
 
11.0, tensor(0.1847), Description: The input grid contains two colored objects. If the first object is larger than the second object, surround the first object with a border of color 2 and the second object with a border of color 1. If the second object is larger than the first object, surround the first object with a border of color 1 and the second object with a border of color 2. The output grid should be the same size as the input grid. 
:: def dfcaeaaajbfeeidaaceffaccbbafjjgb(I):
  objs = objects(I, True, False, True)
  obj1, obj2 = order(objs, size)
  return paint(paint(I, recolor(2 if len(obj1) > len(obj2) else 1,  delta(inbox(obj1)))), 
               recolor(2 if len(obj2) > len(obj1) else 1, delta(inbox(obj2))))
 
38.5, tensor(1.9834), Description: The input grid contains two colored objects. If the first object is larger than the second object, fill the inner area (excluding the border cells) of the first object with color 2 and the inner area (excluding the border cells) of the second object with color 1. If the second object is larger than the first object, fill the inner area (excluding the border cells) of the first object with color 1 and the inner area (excluding the border cells) of the second object with color 2. The output grid should be the same size as the input grid. 
:: def gadddhgejafgeffeibideibdefcfddcb(I):
    objs = objects(I, True, False, True)
    obj1, obj2 = order(objs, size)
    return cellwise(I, paint(paint(canvas(0, shape(I)), recolor(2 if len(obj1) > len(obj2) else 1, inbox(obj1))),
                              recolor(2 if len(obj2) > len(obj1) else 1, inbox(obj2))), 0)
 
13.0, tensor(0.0316), Description: The input grid contains two colored objects. The larger object should be filled with color 2, excluding its border cells. The smaller object should be filled with color 1, also excluding its border cells. The output grid should be the same size as the input grid. 
:: def ffdfbaefajfjeeabbbbgibajhfeefcfd(I):
    objs = objects(I, True, False, True)
    obj1, obj2 = order(objs, size)
    O = I
    for obj in objs:
        for i in range(1, height(obj)-1):
            for j in range(1, width(obj)-1):
                if (i,j) in toindices(obj):
                    O = fill(O, 2 if len(obj) == max(size(o) for o in objs) else 1, {(i,j)})
    return O
 
11.5, tensor(0.0398), Description: The input grid contains two or more colored objects. The largest object should be surrounded by a border of color 2, excluding its border cells. All other objects should be surrounded by a border of color 1, also excluding their border cells. The output grid should be the same size as the input grid. 
:: def gfadbifagdeeefdcjbbcbbideigfagff(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  return paint(paint(I, recolor(2, delta(largest_obj))), recolor(1, merge(apply(delta, objs - {largest_obj}))))
 
27.0, tensor(0.0346), Description: The input grid contains two or more colored objects. The largest object should be filled with color 2. All other objects should be filled with color 1. The output grid should be the same size as the input grid. 
:: def ehbcfcgbdhjdegfejccebbbfhjafbejf(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  other_objs = objs - {largest_obj}
  return paint(paint(I, recolor(1, merge(apply(toindices, other_objs)))), recolor(2, toindices(largest_obj))) 
 
11.5, tensor(0.0040), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 2, also excluding the border cells of the larger object itself. The output grid should be the same size as the input grid. 
:: def egdefhcdgaecehigbebdiajafdcgibih(I):
  objs = objects(I, True, False, True)  # Identify objects in the grid
  smaller_obj = argmin(objs, size)      # Find the smaller object
  larger_obj = argmax(objs, size)      # Find the larger object
  O = I                                   # Initialize output grid
  O = paint(O, recolor(1, delta(toindices(smaller_obj)))) # Color smaller object trim
  O = paint(O, recolor(2, delta(toindices(larger_obj)))) # Color larger object trim
  return O
 
35.5, tensor(0.3504), Description: The input grid contains two colored objects. For each object, fill the cells that are bordering a black cell with color 1 for the first object and color 2 for the second object. The output grid should be the same size as the input grid. 
:: def iagbcdfjdjffehdbjbbehhaeffafeddj(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  O = I
  for i, j in toindices(obj1):
    if index(I, (i - 1, j)) == 0 or index(I, (i + 1, j)) == 0 or index(I, (i, j - 1)) == 0 or index(I, (i, j + 1)) == 0:
      O = fill(O, 1, {(i, j)})
  for i, j in toindices(obj2):
    if index(I, (i - 1, j)) == 0 or index(I, (i + 1, j)) == 0 or index(I, (i, j - 1)) == 0 or index(I, (i, j + 1)) == 0:
      O = fill(O, 2, {(i, j)})
  return O
 
7.5, tensor(0.0041), Description: The input grid contains two colored objects. The smaller object should have its right two columns filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def fbfbjabbcaadeahjjddiebaecdichcjc(I):
  objs = objects(I, True, False, True)
  smaller_obj = argmin(objs, size)
  larger_obj = argmax(objs, size)
  O = I
  for i, j in toindices(smaller_obj):
    if j in range(rightmost(smaller_obj)-1, rightmost(smaller_obj)+1):
      O = fill(O, 1, {(i, j)})
  for i, j in inbox(toindices(larger_obj)):
    O = fill(O, 2, {(i, j)})
  return O
 
29.0, tensor(0.0041), Description: The input grid contains two colored objects. The smaller object should have its right two columns filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def accceeaebaagecdjjifccdcafabdgcgd(I):
  objs = objects(I, True, False, True)
  smaller_obj = argmin(objs, len)
  larger_obj = argmax(objs, len)
  O = paint(canvas(0, shape(I)), recolor(2, inbox(toindices(larger_obj))))
  right_edge = rightmost(smaller_obj)
  for i in range(height(smaller_obj)):
    O = fill(O, 1, {(uppermost(smaller_obj) + i, right_edge-1)})
    O = fill(O, 1, {(uppermost(smaller_obj) + i, right_edge)})
  return O
 
38.5, tensor(0.7357), Description: The input grid contains one or more colored objects. For each object, fill the inner area (excluding the border cells) with the corresponding color (1 for the first object, 2 for the second, and so on). The output grid should be the same size as the input grid. 
:: def dbjbfadeccdeeghbabeaaddbeijeeace(I):
  objs = sorted(objects(I, True, False, True), key=len, reverse=True)
  O = I
  for i, obj in enumerate(objs):
    O = paint(cover(O, obj), recolor(i+1, difference(toindices(obj), box(obj))))
  return O
 
8.5, tensor(0.0330), Description: The input grid contains two or more colored objects. The largest object should have its border cells filled with its original color, while all other objects should be filled with color 1. The output grid should be the same size as the input grid. 
:: def fdhfibdjachiedfcicfgcbecfacgcjdc(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  O = I
  for obj in objs:
    if obj != largest_obj:
      O = paint(O, recolor(1, obj))
    O = paint(O, recolor(color(obj), box(obj))) 
  return O
 
73.0, tensor(0.0186), Description: The input grid contains two or more colored objects. The largest object should have its border cells filled with its original color, while all other objects should be filled with color 1. The output grid should be the same size as the input grid. The background of the output grid should be color 1. 
:: def aabbaafbadddedefbcbfgfdjacaffbgc(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  return paint(paint(fill(I, 1, asindices(I)), 
                     recolor(color(largest_obj), largest_obj)), 
               mfilter(objs, lambda obj: recolor(color(obj), box(obj))))
 
0.5, tensor(0.0039), Description: The input grid contains two colored objects. The smaller object should have its inner area (excluding the border cells) filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def eeaabffbdfdcehdbicahfhbifaaeheah(I):
  objs = objects(I, True, False, True)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)
  O = paint(I, recolor(1, frozenset((i,j) for i in range(uppermost(small_obj)+1, lowermost(small_obj)) for j in range(leftmost(small_obj)+1, rightmost(small_obj)))))
  return paint(O, recolor(2, inbox(toindices(large_obj))))
 
35.5, tensor(0.0050), Description: The input grid contains two colored objects. The smaller object should have its middle column filled with color 1. The larger object should be surrounded by a border of color 2, excluding its border cells. The output grid should be the same size as the input grid. 
:: def aidhgdbceejiehhiidbbaihacejedega(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(1, frozenset((i,j) for i,j in toindices(smaller_obj) if leftmost(smaller_obj)+width(smaller_obj)//2-1 <= j < leftmost(smaller_obj)+width(smaller_obj)//2+1)))
  O = paint(O, recolor(2, delta(toindices(larger_obj))))
  return O
 
29.0, tensor(0.0079), Description: The input grid contains two colored objects. The smaller object should have its middle column filled with color 1, except for the topmost cell of the column, which should remain its original color. The larger object should be filled with color 2, but only the inner area (excluding the border cells) should be filled. The output grid should be the same size as the input grid. 
:: def iceedfiaccaaeciciiadhdedecdeaegf(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(1, frozenset(((i, j-1) if j == leftmost(smaller_obj)+width(smaller_obj)//2 else (i, j))  for i, j in toindices(smaller_obj))))
  O = paint(O, recolor(2, inbox(toindices(larger_obj))))
  return O
 
45.0, tensor(0.0031), Description: The input grid contains two or more colored objects. The smallest object should be surrounded by a border of color 1, excluding the border cells of the smaller object itself. The largest object should be filled with color 2, but only the inner area (excluding the border cells and the smaller object) should be filled. The output grid should be the same size as the input grid. 
:: def cjicceabifhfefcajfebbcbdfcabddfj(I):
  smaller_obj = min(fgpartition(I), key=len)
  larger_obj = other(fgpartition(I), smaller_obj) if len(fgpartition(I)) > 1 else smaller_obj
  O = fill(I, 1, delta(toindices(smaller_obj)))
  return fill(O, 2, difference(inbox(toindices(larger_obj)), toindices(larger_obj)))
 
19.5, tensor(0.5685), Description: The input grid contains two or more colored objects. The largest object should be surrounded by a border of color 1. The inner area of the largest object should be filled with color 2. The output grid should be the same size as the input grid. 
:: def eadeafhcebecechfaefijecgefbbffde(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, lambda obj: size(toindices(obj)))
  O = paint(I, recolor(1, box(toindices(largest_obj))))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i, j) in inbox(toindices(largest_obj)):
        O = paint(O, {(2, (i, j))})
  return O
 
19.0, tensor(0.0328), Description: The input grid contains two or more colored objects. The largest object should have its border cells filled with its original color, while the inner area (excluding the border cells) should be filled with color 2. All other objects should have their inner area (excluding the border cells) filled with color 1. The output grid should be the same size as the input grid. 
:: def ecabcjffaffaedhfbdhbbffcejgeefej(I):
  def is_largest(obj):
    return size(obj) ==  max(size(o) for o in objects(I, True, False, True))
  return paint(paint(I, recolor(1, mfilter(objects(I, True, False, True), lambda obj: box(toindices(obj)) if is_largest(obj) else set()))), 
               recolor(2, mfilter(objects(I, True, False, True), lambda obj: inbox(toindices(obj)) if is_largest(obj) else set())))
 
19.5, tensor(0.0042), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, but only the inner area (excluding the border cells and the smaller object) should be filled. The output grid should be the same size as the input grid. The outer border of the larger object should remain its original color. 
:: def dhceibbfdhafecbajfgbahafdbabafgg(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(1, inbox(toindices(smaller_obj))))
  O = paint(O, recolor(2, difference(inbox(toindices(larger_obj)), box(toindices(larger_obj)))))
  return paint(O, larger_obj)
 
38.5, tensor(0.0045), Description: The input grid contains two colored objects. The smaller object should be filled with color 1, excluding its border cells. The larger object should be filled with color 2, but only the inner area (excluding the border cells and the smaller object) should be filled. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def ffbficfeehhieafcadbaddbcddaceddj(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  grid1 = paint(canvas(0, shape(I)), recolor(1, inbox(toindices(smaller_obj))))
  grid2 = paint(canvas(0, shape(I)), recolor(2, difference(inbox(toindices(larger_obj)), box(toindices(larger_obj)))))
  return cellwise(grid1, I, 0)
 
22.0, tensor(0.0039), Description: The input grid contains two colored objects. The smaller object should have its inner area (excluding the border cells) filled with color 1. The larger object should be filled with color 2, but only the inner area (excluding the border cells and the smaller object) should be filled. The output grid should be the same size as the input grid. The outer border of the larger object should remain its original color. 
:: def ffabfabcaadeejhjibedecaahcaghcag(I):
  objs = order(objects(I, True, False, True), size)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(2, difference(inbox(toindices(larger_obj)), box(toindices(larger_obj)))))
  inner_obj = shift(crop(I, (uppermost(smaller_obj)+1, leftmost(smaller_obj)+1), (height(smaller_obj)-2, width(smaller_obj)-2)), (-1,-1))
  O = paint(O, recolor(1, toindices(inner_obj)))
  return paint(O, larger_obj) 
 
68.0, tensor(0.0047), Description: The input grid contains one or more colored objects. For each object, paint a border around it with color '4', excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def addfdeehefjaeihaieedddcccacfhaeb(I):
  objs = objects(I, True, False, True)  # Identify objects
  O = I # Initialize output as input
  for obj in objs:
    O = paint(O, recolor(4, outbox(obj)))  # Paint outline with '4'
  return O
 
27.0, tensor(0.7955), Description: The input grid contains two or more colored objects. The smallest object should be filled with color 1. All other objects should be surrounded by a border of color 4, excluding the border cells of the object itself, and the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. 
:: def gbdgefbeacagecaeiafceabadaeefbgf(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = I
  for i, obj in enumerate(objs):
    if i == 0:
      if uppermost(obj) > len(I) // 2: 
        O = paint(cover(O, obj), recolor(4, difference(toindices(obj), box(obj))))
        O = paint(O, recolor(1, difference(toindices(obj),  delta(difference(toindices(obj), box(obj))))))
      else:
        O = paint(O, recolor(1, toindices(obj)))
    else:
      O = paint(cover(O, obj), recolor(4, difference(toindices(obj), box(obj))))
      O = paint(O, recolor(2, difference(toindices(obj), delta(difference(toindices(obj), box(obj))))))
  return O
 
23.0, tensor(0.7960), Description: The input grid contains one or more colored objects. The smallest object should be filled with color 1 if it is in the bottom half of the grid, and color 4 if it is in the top half. All other objects should be surrounded by a border of color 4, excluding the border cells of the object itself, and the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. 
:: def efaedgjcfeeheaghbdbdefigfefgjadd(I):
  O = I
  for obj in objects(I, True, False, True):
    if len(obj) == valmin(objects(I, True, False, True), len):
      value = 1 if uppermost(obj) > len(I) // 2 else 4
      O = paint(O, recolor(value, toindices(obj)))
    else:
      O = paint(cover(O, obj), recolor(4, difference(toindices(obj), box(obj))))
      O = paint(O, recolor(2, difference(toindices(obj), delta(difference(toindices(obj), box(obj))))))
  return O
 
36.5, tensor(0.7958), Description: The input grid contains one or more colored objects. Replace all instances of color 1 with color 2. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. All other objects in the bottom half of the grid should be surrounded by a border of color 4, excluding the border cells of the object itself. All other objects in the top half of the grid should be filled with color 1, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def jddddeaejhcgebejaagabbahaeafefdj(I):
  O = replace(I, 1, 2) 
  for obj in objects(I, True, False, True):
    if len(obj) == valmax(objects(I, True, False, True), len):
      O = paint(cover(O, obj), recolor(4, difference(toindices(obj), box(obj))))
    else:
      if uppermost(obj) > len(I) // 2:
        O = paint(O, recolor(4, difference(toindices(obj), box(obj))))
      else:
        O = paint(O, recolor(1, difference(toindices(obj), box(obj))))
  return O
 
11.5, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be filled with color 4. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself, and the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. The background of the output grid should be the same as the input grid. 
:: def bcaedejgbfdaeaebbcfhcjjfchfdagga(I):
  objs = sorted(objects(I, True, False, True), key=len)
  smaller_obj = objs[0]
  larger_obj = objs[1]
  O = paint(canvas(0, shape(I)), recolor(4, smaller_obj))
  O = paint(O, recolor(2, toobject(delta(inbox(toindices(larger_obj))), I)))
  O = paint(O, recolor(4, larger_obj)) 
  return O
 
23.5, tensor(0.8098), Description: The input grid contains a single colored object. Fill the inner area of the object (excluding the border cells) with color 2. Then, paint the border cells of the object with color 4. The output grid should be the same size as the input grid. 
:: def fbcacfabhaafegfibbffdcfahdfbdhee(I):
  obj = first(objects(I, T, F, T))
  O = paint(fill(I, 2, inbox(obj)), recolor(4, obj))
  return O
 
28.5, tensor(0.7999), Description: The input grid contains a single colored object. Fill the object with color 4. Then, fill the inner area of the object (excluding the corners) with color 2. The output grid should be the same size as the input grid. 
:: def hbhhedbaefdfedchiieifcebafdjhcfa(I):
  obj = toindices(first(objects(I, T, F, T)))
  O = fill(fill(I, 4, obj), 2, obj - corners(obj))
  return O
 
60.0, tensor(0.0042), Description: The input grid contains one or more colored objects. The largest object should be filled with color 2, excluding its border cells. All other objects should be filled with color 1, excluding their border cells. All objects should also have a border of color 4, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def dddjdgidbfdaebcijeeadadafbbbahff(I):
  objs = objects(I, True, False, True)
  return paint(I, merge(apply(lambda obj: recolor(branch(size(obj) == size(argmax(objs, size)), 2, 1), inbox(obj)), objs) | apply(lambda obj: recolor(4, outbox(obj)), objs)))
 
19.5, tensor(0.7969), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The smallest object should be filled with color 2 if its original color is not 1, and color 1 if its original color is 1. The output grid should be the same size as the input grid. 
:: def hbgcafgfejfeedjbijcebaejcfacecba(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = I
  if len(objs) > 1:
    outer = objs[-1]
    inner = objs[0]
    O = paint(O, recolor(4, toindices(outer)))
    O = paint(cover(O, inner), recolor(2 if color(inner) != 1 else 1, toindices(inner)))
  return O
 
81.0, tensor(0.7972), Description: The input grid contains one or more colored objects. The smallest object should be filled with color 2 if its original color is not 1, and color 1 if its original color is 1. All other cells in the grid should be filled with color 4. The output grid should be the same size as the input grid. 
:: def jhbbigcfcbadedhfahdhadejebfdifaa(I):
  small_obj = min(objects(I, True, False, True), key=len)
  O = paint(I, recolor(4, toindices(difference(asindices(I), toindices(small_obj)))))
  return paint(O, recolor(2 if color(small_obj) != 1 else 1, toindices(small_obj)))
 
3.5, tensor(0.0068), Description: The input grid contains two colored objects. The smaller object should be filled with color 4. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself, and the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. The background of the output grid should be the same as the input grid. 
:: def ajchabdcgchaedhaicaficfbedjdgiia(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), recolor(4, smaller_obj))
  if len(smaller_obj) > 1:
    O = paint(O, recolor(1, toobject(delta(toindices(smaller_obj)), I)))
  O = paint(O, recolor(4, larger_obj))
  O = paint(O, recolor(2, toobject(inbox(toindices(larger_obj)), I)))
  return O
 
14.0, tensor(0.0032), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. The inner area of the smaller object should be filled with color 1 if the cell is not bordering another cell of the same color. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. The inner area of the larger object should be filled with color 2 if the cell is bordering four other cells of the same color. The output grid should be the same size as the input grid. 
:: def hfjgacdechfbebfdbcdcdjbcidbbfdff(I):
  objs = sorted(objects(I, True, False, True), key=len)
  smaller_obj = objs[0]
  larger_obj = objs[1]

  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (val, (i, j)) in smaller_obj:
        O = paint(O, {(4, (i, j))})
        if len(dneighbors((i, j)) & toindices(smaller_obj)) < 4:
          O = paint(O, {(1, (i, j))})
      elif (val, (i, j)) in larger_obj:
        O = paint(O, {(4, (i, j))})
        if len(dneighbors((i, j)) & toindices(larger_obj)) == 4:
          O = paint(O, {(2, (i, j))})
  return O
 
0.0, tensor(0.0100), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. If the smaller object is larger than 1x1, the inner area (excluding the border cells and the border of color 4) should be filled with color 1. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. If the larger object is larger than 1x1, the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. The background of the output grid should be the same as the input grid. 
:: def hdejagagcadfedeeibghbaffdaddicca(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), recolor(4, toobject(box(toindices(smaller_obj)), I)))
  if len(smaller_obj) > 1:
    O = paint(O, recolor(1, toobject(delta(box(toindices(smaller_obj))), I)))
  O = paint(O, recolor(4, toobject(box(toindices(larger_obj)), I)))
  O = paint(O, recolor(2, toobject(delta(box(toindices(larger_obj))), I)))
  return O
 
38.5, tensor(0.7965), Description: The input grid contains one or more colored objects. The smallest object should be filled with color 4, excluding its border cells. All other objects should be filled with color 1, excluding their border cells. The border cells of all objects should remain their original color. The output grid should be the same size as the input grid. 
:: def jjbcdbccfaideeaejcegfbdbfcdfjjdh(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = I
  for i, obj in enumerate(objs):
    value = 4 if i == 0 else 1 
    O = paint(O, recolor(value, inbox(toindices(obj))))
    O = underpaint(O, obj)
  return O 
 
11.0, tensor(0.0051), Description: The input grid contains two colored objects. The smaller object should be filled with color 4, excluding its border cells. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself, and the inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. The background of the output grid should be the same as the input grid. 
:: def fcbbdabcdjddefjdjcecaccjdabbgfba(I):
  objs = objects(I, True, False, True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  smaller_obj = obj1 if len(obj1) < len(obj2) else obj2
  larger_obj = obj2 if len(obj1) < len(obj2) else obj1

  O = paint(canvas(0, shape(I)), recolor(4, toindices(smaller_obj)))
  O = paint(O, recolor(1, delta(inbox(toindices(smaller_obj)))))
  O = paint(O, recolor(4, toindices(larger_obj)))
  O = paint(O, recolor(2, delta(inbox(toindices(larger_obj)))))
  return O
 
11.0, tensor(0.0263), Description: The input grid contains one or more colored objects. For each object, paint a border around it with color '4', excluding the border cells of the object itself. Then, fill the inner area (excluding the border cells and the border of color '4') with the corresponding color (1 for the first object, 2 for the second, and so on). The output grid should be the same size as the input grid. 
:: def bebjhhcdceghegfjafaadcccaeejcabb(I):
  objs = objects(I, True, False, True)
  O = canvas(0, shape(I))
  for i, obj in enumerate(sorted(objs, key=len)):
    O = paint(O, recolor(4, box(obj)))
    O = paint(O, recolor(i + 1, delta(inbox(obj))))
  return O
 
21.0, tensor(0.7955), Description: The input grid contains one or more colored objects. The largest object should be filled with its most common color, excluding its border cells. The inner area (excluding the border cells and the largest object) should be filled with color 2. All other objects in the bottom half of the grid should be surrounded by a border of color 4, excluding the border cells of the object itself. All other objects in the top half of the grid should be filled with color 1, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def cefbdhdbicjgeeecafffaiagffagcbfd(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = I
  if len(objs) > 0:
    largest_obj = objs[-1]
    O = paint(O, recolor(mostcolor(largest_obj), toindices(largest_obj)))
    O = paint(O, recolor(2, difference(toindices(largest_obj), box(largest_obj)))) 
  for obj in objs[:-1]:
    if uppermost(obj) < len(I) // 2:
      O = paint(cover(O, obj), recolor(4, toindices(obj)))
    else:
      new_color = 1 if color(obj) != 1 else 2
      O = paint(cover(O, obj), recolor(new_color, toindices(obj)))
    O = paint(O, recolor(1, difference(toindices(obj), box(obj))))
  return O
 
132.5, tensor(1.9759), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. The inner area (excluding the border cells and the border of color 4) should be filled with color 1. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. The inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. The output grid should be divided into two halves, with the smaller object and its border on the left and the larger object and its border on the right. 
:: def abicgcegbaghehbjjjcdibcccgijebja(I):
  objs = sorted(objects(I, True, False, True), key=len)
  small_obj, large_obj = objs[0], objs[1]
  return hconcat(
      vconcat(
          paint(canvas(0, (5,10)), recolor(4, box(small_obj))),
          paint(canvas(0, (5,10)), recolor(1, delta(inbox(toindices(small_obj)))))
      ),
      vconcat(
          paint(canvas(0, (5,10)), recolor(4, box(large_obj))),
          paint(canvas(0, (5,10)), recolor(2, delta(inbox(toindices(large_obj)))))
      )
  )
 
5.5, tensor(0.2924), Description: The input grid contains one or more colored objects. For each object, paint a border around it with color '4', excluding the border cells of the object itself. Then, fill the area surrounding the object (excluding the border cells and the border of color '4') with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half. The output grid should be the same size as the input grid. 
:: def aachbdbecjaeecebiabbegejhafcafbb(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    new_color = 4 
    border_color = 1 if uppermost(obj) < len(I) // 2 else 2
    O = paint(cover(O, obj), recolor(new_color, toindices(obj)))
    O = paint(O, recolor(border_color, difference(toindices(obj), box(obj))))
  return O
 
11.5, tensor(0.2934), Description: The input grid contains one or more colored objects. For each object, paint a border around it with color '4', excluding the border cells of the object itself. Then, fill the inner area (excluding the border cells and the border of color '4') with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half. The output grid should be the same size as the input grid. The background of the output grid should be the most common color in the input grid. 
:: def gaddihbgjeccebffijfdfddgjcbfefba(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, True):
    border_color = 1 if centerofmass(obj)[0] < len(I) // 2 else 2
    O = underpaint(paint(O, recolor(4, toindices(obj))), recolor(border_color, inbox(toindices(obj)))) 
  return O
 
57.5, tensor(0.3046), Description: The input grid contains one or more colored objects. For each object, paint a border around it with color '4', excluding the border cells of the object itself. Then, fill the area surrounding the object (excluding the border cells and the border of color '4') with color 1 if the object is in the top half of the grid, and color 2 if it is in the bottom half. The output grid should be the same size as the input grid. The background of the output grid should be the most common color in the input grid. 
:: def bbefgbgfaffaedbaibbdcaeccfcbeefe(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != mostcolor(I):
        border_color = 1 if i < len(I) // 2 else 2
        O = paint(O, recolor(4, {(value, (i, j))}))
        O = paint(O, recolor(border_color, {(border_color, (i - 1, j)), (border_color, (i + 1, j)), (border_color, (i, j - 1)), (border_color, (i, j + 1))})) 
  return O
 
47.5, tensor(0.0035), Description: The input grid contains one or more colored objects. The largest object should be filled with color 2, excluding its border cells. The border cells of the largest object should be filled with color 4. The output grid should be the same size as the input grid. 
:: def bedahfifjbbieadiabfbbeeceeaghega(I):
  objs = objects(I, True, False, True) # Identify all objects in the grid
  largest_obj = argmax(objs, size) # Find the largest object
  O = paint(I, recolor(2, inbox(largest_obj))) # Fill the inbox of the largest object with '2'
  return paint(O, recolor(4, outbox(largest_obj))) # Draw the outline of the largest object with '4'
 
58.5, tensor(0.0032), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. All other objects should be filled with color 2, excluding their border cells. The output grid should be the same size as the input grid. 
:: def gaieebieaegfedcabbbbdgaafffaijeg(I):
  objs = objects(I, True, False, True)
  largest_size = size(argmax(objs, size)) # Get the size of the largest object
  def process_obj(obj):
    return recolor(4, outbox(obj)) if size(obj) == largest_size else recolor(2, inbox(obj))  # Outline the largest, inbox others
  return paint(I, merge(apply(process_obj, objs))) # Apply and merge changes
 
55.5, tensor(0.0036), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) should be filled with color 2. The output grid should be the same size as the input grid. 
:: def jacebdfdecbceaaeafddbcfbbbcadcbi(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  O = paint(I, recolor(4, outbox(largest_obj))) # Draw outline first
  return underpaint(O, recolor(2, inbox(largest_obj))) # Fill inbox without overwriting existing colors 
 
25.5, tensor(0.7939), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. The inner area (excluding the border cells and the border of color 4) of the larger object should be filled with color 2. The inner area (excluding the border cells and the border of color 4) of the smaller object should be filled with color 1. The output grid should be the same size as the input grid. 
:: def gafefgbaafijebdgbbbaecggafaiccga(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = paint(I, recolor(4, toindices(objs[-1]))) # Recolor larger object
  O = paint(O, recolor(4, box(objs[0]))) # Recolor border of smaller object
  O = paint(cover(O, objs[0]), recolor(1, toindices(objs[0]))) # Recolor inside of smaller object
  inner_box = crop(O, add(ulcorner(objs[-1]), (1,1)), subtract(shape(objs[-1]), (2,2))) # Define inner box
  O = paint(cover(O, toobject(asindices(inner_box), O)), recolor(2, asindices(inner_box))) # Recolor inner box
  return O
 
0.0, tensor(0.7939), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. The inner area (excluding the border cells and the border of color 4) of the larger object should be filled with color 2. The inner area (excluding the border cells and the border of color 4) of the smaller object should be filled with color 1. The output grid should be the same size as the input grid. 
:: def bagfcjdegagfeacdbjfgbiacgbhjhcdf(I):
  objs = objects(I, True, False, True)
  large_obj = max(objs, key=len) 
  small_obj = min(objs, key=len)
  O = paint(I, recolor(4, toindices(large_obj)))
  O = paint(O, recolor(4, box(small_obj)))
  O = underpaint(O, recolor(1, toindices(small_obj)))
  inner_start = add(ulcorner(large_obj), (1,1))
  inner_dims = subtract(shape(large_obj), (2, 2))
  O = paint(O, recolor(2, product(interval(inner_start[0], inner_start[0] + inner_dims[0], 1),
                                       interval(inner_start[1], inner_start[1] + inner_dims[1], 1))))
  return O 
 
14.5, tensor(0.7950), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the largest object should be filled with color 2. All other objects should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of all other objects should be filled with color 1. The output grid should be the same size as the input grid. 
:: def ahiccffigafjedgcicdafafcghadfajd(I):
  O = I
  for obj in objects(I, True, False, True):
    if size(obj) == valmax(objects(I, True, False, True), size): # Larger object
      O = paint(O, recolor(4, toindices(obj)))
      inner_box = crop(O, (uppermost(obj) + 1, leftmost(obj) + 1), (height(obj) - 2, width(obj) - 2))
      O = paint(cover(O, toobject(asindices(inner_box), O)), recolor(2, asindices(inner_box)))
    else: # Smaller object
      O = paint(O, recolor(4, box(obj)))
      O = underpaint(O, recolor(1, toindices(obj)))
  return O
 
54.5, tensor(1.9844), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the largest object should be filled with color 2 if the largest object is in the bottom half of the grid, and color 1 if it is in the top half. A vertical stripe of color 1 should be drawn to the left of the center of the largest object if the largest object is in the bottom half of the grid, and a vertical stripe of color 2 should be drawn to the left of the center of the largest object if the largest object is in the top half of the grid. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def abfbcaecebcdecifjdacacjadfacheaf(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  fill_color = 2 if uppermost(largest_obj) > len(I) // 2 else 1
  stripe_color = 1 if fill_color == 2 else 2
  outline = recolor(4, outbox(toindices(largest_obj)))
  filled_obj = recolor(fill_color, toindices(largest_obj))
  stripe_start = (uppermost(largest_obj), leftmost(largest_obj) + width(largest_obj) // 2 - 1) 
  stripe = set()
  for i in range(height(largest_obj)):
    for j in range(2):
      color = stripe_color if j == 0 else fill_color
      stripe.add((color, (i, j)))
  return paint(paint(paint(canvas(0, shape(I)), outline), shift(frozenset(stripe), stripe_start)), filled_obj)
 
8.5, tensor(0.7963), Description: The input grid contains one or more colored objects. The largest object should be filled with color 2, excluding its border cells. All other objects should be surrounded by a border of color 4, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def ffbiggdjhbehegfeicajcjbgifhebcje(I):
  O = I
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, lambda obj: len(toindices(obj)))
  for obj in objs:
    if obj == largest_obj:
      O = underfill(O, 2, toindices(obj))
    O = paint(O, recolor(4, box(obj)))
  return O 
 
71.0, tensor(0.0050), Description: The input grid contains one or more colored objects. The largest object should be filled with color 1, excluding its border cells. All other objects should be filled with color 2, excluding their border cells. All objects should also have a border of color 4, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def cffcccdiebbiedcaajibachcacdcggac(I):
  objs = objects(I, True, False, True)
  largest_size = size(argmax(objs, size))
  O = I
  for obj in objs:
    O = paint(O, recolor(4, outbox(obj)))
    O = paint(O, recolor(2 if size(obj) != largest_size else 1, inbox(obj)))
  return O
 
25.5, tensor(0.7956), Description: The input grid contains one or more colored objects. The largest object should be filled with its original color, excluding its border cells. All other objects in the bottom half of the grid should be filled with color 2, excluding their border cells. All other objects in the top half of the grid should be filled with color 1, excluding their border cells. All objects should also have a border of color 4, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def cchbdafgegifefecbfdjbfaabbfacacj(I):
  objs = sorted(objects(I, True, False, True), key=len)
  O = paint(I, recolor(4, merge(apply(box, objs)))) # Paint the frames first
  for i, obj in enumerate(objs):
    if i == len(objs) - 1: # Largest object
      O = paint(O, recolor(color(obj), toindices(obj))) 
    else:
      new_color = 1 if uppermost(obj) < len(I) // 2 else 2
      O = paint(O, recolor(new_color, difference(toindices(obj), box(obj))))
  return O 
 
53.5, tensor(1.9910), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the largest object should be filled with the original color of the largest object. A vertical stripe of color 1 should be drawn to the left of the center of the largest object. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def aafijadjdcbaeeiiijgaebjcabcifejd(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  obj_color = color(largest_obj)
  
  outline = recolor(4, outbox(toindices(largest_obj)))
  inner_outline = recolor(2, inbox(toindices(largest_obj)))
  
  stripe_start = (uppermost(largest_obj) + height(largest_obj) // 2, leftmost(largest_obj))
  stripe = frozenset({(1 if j % 2 == 0 else obj_color, (stripe_start[0], stripe_start[1] + j)) 
                      for j in range(width(largest_obj))})

  return paint(paint(paint(canvas(0, shape(I)), outline), inner_outline), stripe)
 
11.5, tensor(1.9906), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the largest object should be filled with the original color of the largest object. A vertical stripe of color 1 should be drawn to the left of the center of the largest object, alternating between color 1 and the original color of the largest object. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def iagcfidhdbbaefffiaacjiaffabhfeaf(I):
  def is_largest(obj):
    return size(obj) ==  max(size(o) for o in objects(I, True, False, True))

  objs = objects(I, True, False, True)
  largest_obj = extract(objs, is_largest)
  obj_color = color(largest_obj)

  modified_grid = I
  for i, j in toindices(largest_obj):
    if (i == uppermost(largest_obj) 
       or i == lowermost(largest_obj)
       or j == leftmost(largest_obj) 
       or j == rightmost(largest_obj)):
      modified_grid = fill(modified_grid, 4, {(i, j)})
    elif (i == uppermost(largest_obj) + 1
       or i == lowermost(largest_obj) - 1
       or j == leftmost(largest_obj) + 1 
       or j == rightmost(largest_obj) - 1):
      modified_grid = fill(modified_grid, 2, {(i, j)})
    elif i == uppermost(largest_obj) + height(largest_obj) // 2:
      modified_grid = fill(modified_grid, 1 if (j - leftmost(largest_obj)) % 2 == 0 else obj_color, {(i, j)})
  return modified_grid
 
53.5, tensor(1.9906), Description: The input grid contains one or more colored objects. The largest object should be surrounded by a border of color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the largest object should be filled with the original color of the largest object. A vertical stripe of color 1 should be drawn to the left of the center of the largest object, alternating between color 1 and the original color of the largest object. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def aehieaahdaieebdbjbdfaafcgefhfgbg(I):
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  obj_color = color(largest_obj)
  
  O = paint(canvas(0, shape(I)), largest_obj)
  O = paint(O, recolor(4, outbox(toindices(largest_obj))))
  O = paint(O, recolor(2, inbox(toindices(largest_obj))))
  for j in range(width(largest_obj)):
      O = fill(O, 1 if j % 2 == 0 else obj_color, {(uppermost(largest_obj) + height(largest_obj) // 2, leftmost(largest_obj) + j)})
  return O
 
9.5, tensor(0.7956), Description: The input grid contains one or more colored objects. The largest object should be filled with its original color, excluding its border cells. All other objects in the bottom half of the grid should be filled with color 2, excluding their border cells. All other objects in the top half of the grid should be filled with color 1, excluding their border cells. All objects should also have a border of color 4, excluding the border cells of the object itself. The output grid should be the same size as the input grid. 
:: def cfdgfbcfdbhaeebbibejcdccidbiegbd(I):
  objs = objects(I, True, False, True)
  O = paint(I, recolor(4, merge(apply(box, objs)))) # Frame the objects
  for obj in objs:
    new_color = color(obj) if len(obj) == len(max(objs, key=len)) else (1 if uppermost(obj) < len(I) // 2 else 2) 
    O = paint(O, recolor(new_color, difference(toindices(obj), box(obj))))
  return O
 
73.0, tensor(0.7957), Description: The input grid contains one or more colored objects. The largest object should be filled with its original color, excluding its border cells. All other objects in the bottom half of the grid should be filled with color 2, excluding their border cells. All other objects in the top half of the grid should be filled with color 1, excluding their border cells. The background of the output grid should be color 4. 
:: def bdabfdbafbihefiajccbgbbbgbdgjeag(I):
  objs = objects(I, True, False, True)
  largest_obj = max(objs, key=len)
  O = canvas(4, shape(I)) # Start with a canvas of '4'
  for obj in objs:
    if obj == largest_obj:
      O = cellwise(O, paint(I, recolor(color(obj), toindices(obj))), 4)
    else:
      new_color = 1 if uppermost(obj) < len(I) // 2 else 2
      O = cellwise(O, paint(canvas(0, shape(I)), recolor(new_color, difference(toindices(obj), box(obj)))), 4)
  return O
 
100.0, tensor(0.7957), Description: The input grid contains one or more colored objects. The largest object should be filled with its original color, excluding its border cells. All other objects in the bottom half of the grid should be filled with color 2, excluding their border cells. All other objects in the top half of the grid should be filled with color 1, excluding their border cells. The background of the output grid should be color 4. 
:: def ggiaeeecddfceedfacjijjdaecbicjfc(I):
  objs = objects(I, True, False, True)
  O = paint(canvas(4, shape(I)), recolor(0, merge(apply(toindices, objs)))) # Create a frame by inverting object pixels
  for obj in objs:
    new_color = color(obj) if len(obj) == len(max(objs, key=len)) else (1 if uppermost(obj) < len(I) // 2 else 2)
    O = underpaint(O, recolor(new_color, toindices(obj))) 
  return O
 
12.0, tensor(1.9559), Description: The input grid contains two colored objects. The smaller object should be surrounded by a border of color 4, excluding the border cells of the smaller object itself. The larger object should be surrounded by a border of color 4, excluding the border cells of the larger object itself. The inner area (excluding the border cells and the border of color 4) of the larger object should be filled with color 2. A vertical stripe of color 1 should be drawn to the left of the center of the larger object. The output grid should be the same size as the input grid. The background of the output grid should be black. 
:: def dbcaacfcbbeaeejeiabfehefdaffchij(I):
  objs = objects(I, True, False, True)
  small_obj = argmin(objs, len)
  large_obj = argmax(objs, len)
  O = canvas(0, shape(I))
  O = paint(paint(O, recolor(4, box(small_obj))), recolor(4, small_obj))
  O = paint(O, recolor(4, large_obj))
  O = paint(O, recolor(2, delta(inbox(large_obj))))
  O = paint(O, recolor(1, crop(I, (uppermost(large_obj) + 1, leftmost(large_obj) + width(large_obj) // 2 - 1), (height(large_obj) - 2, 2))))
  return O
 
88.5, tensor(0.7962), Description: The input grid contains one or more colored objects. The largest object should be filled with color 2, excluding its border cells. All other objects in the top half of the grid should be filled with color 1, excluding their border cells. The background of the output grid should be color 4. 
:: def febdddcdbgidehiaaccacfdehgbcbcdg(I):
  O = canvas(4, shape(I)) # Start with a canvas filled with '4'
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, len)
  for obj in objs:
    if obj != largest_obj:
      fill_color = 1 if uppermost(obj) < len(I) // 2 else 1
      O = underpaint(O, recolor(fill_color, toindices(obj))) # Directly paint based on position
  return underpaint(O, recolor(2, toindices(largest_obj))) # Paint largest object on top
 
22.5, tensor(1.1230), Description: The input grid contains a single colored object. The border cells of the object should be filled with color 4, excluding the border cells of the object itself. The inner area (excluding the border cells and the border of color 4) of the object should be filled with the original color of the object. The output grid should be the same size as the input grid. 
:: def ceccebbehbbbejfcbddfdgajbbajdadj(I):
  obj = first(objects(I, T, F, T))  # Extract the primary object
  outer = set() 
  inner = set()
  for i, r in enumerate(I):
    for j, v in enumerate(r):
      if (i, j) in toindices(obj):
        if any((i + di, j + dj) not in toindices(obj) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
          outer.add((i, j))
        else:
          inner.add((i, j))
  inner_value = index(I, first(inner))
  O = paint(fill(I, 4, frozenset(outer)), recolor(inner_value, toobject(frozenset(inner), I)))
  return O
 
