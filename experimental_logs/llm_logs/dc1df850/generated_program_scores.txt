10.0, tensor(0.0143), Description: Fill in the background of each colored shape with the color of the shape. 
:: def fdedefhiebdeecabjcdcjcbfggcfbcee(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  for obj in objs:
    I = underfill(I, ONE, backdrop(obj))
  O = I
  return O
 
23.666666666666668, tensor(1.8055), Description: Fill in the background of each colored shape with the color of the shape, except for the most common color. 
:: def fhdcccgdedicedcfaajddfhjebajadda(I):
  O = I
  for n in palette(I) - {mostcommon(I)}:
    indices = ofcolor(I, n)
    O = underfill(O, ONE, backdrop(indices))
  return O
 
8.666666666666666, tensor(0.0143), Description: Fill in the background of each colored shape with the color of the shape. 
:: def cdaeadaecdjbecbeiceaicdaeagbcegd(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  expansion = frozenset()
  for obj in objs:
    for (i, j) in toindices(obj):
      expansion = combine(expansion, dneighbors((i, j)))
  O = underfill(I, ONE, expansion)
  return O
 
23.666666666666668, tensor(1.8055), Description: Fill in the background of each colored shape with the color of the shape, except for the most common color. 
:: def jdgahaeacgceejchaddecbejcacffadf(I):
    O = I
    for i in range(1, height(I) - 1):
        for j in range(1, width(I) - 1):
            if index(I, (i, j)) != mostcommon(I):
                O = fill(O, ONE, dneighbors((i, j)))
    return O
 
10.0, tensor(0.0064), Description: For each shape that is red, draw a diagonal line of blue squares from the upper left corner of the shape to the lower right corner of the shape. The line should be as long as possible, and should not go outside the bounds of the shape. 
:: def igfbbcjhecbgeabdajbjjfjbbbacbgdd(I):
  objs = objects(I, False, False, True)
  for obj in objs:
    if color(obj) == 2:
      ul = ulcorner(obj)
      O = fill(I, 1, {(ul[0] - i, ul[1] + i) for i in range(1, min(height(obj), width(obj)))})
  return O 
 
10.0, tensor(0.0070), Description: Draw a diagonal line of blue squares from the upper left corner of the red shape to the lower right corner of the shape. The line should be as long as possible, and should not go outside the bounds of the shape. 
:: def effeecdfdbejebhhbbgjfdgfabdedefc(I):
  two_obj = extract(objects(I, False, False, True), lambda obj: color(obj) == 2)
  corner = ulcorner(two_obj)
  direction = (-1, 1)
  line = shoot(corner, direction)
  O = underfill(I, 1, line) 
  return O
 
10.0, tensor(0.0157), Description: For each red shape that touches the right edge of the grid, add a blue square to the right of each red square. The blue squares should be placed one square to the right of the red squares, and should not extend beyond the right edge of the grid. 
:: def beaeaieabeddeejajcijhehbjefefeei(I):
  obj_two = argmax(objects(I, False, False, True), lambda obj: color(obj) == 2 and lrcorner(obj)[0] == len(I) - 1)
  O = fill(I, 1,  {(i, j + 1) for i, j in toindices(obj_two) if index(I, (i - 1, j + 1)) == 0})
  return O
 
9.333333333333334, tensor(0.8792), Description: For each red shape, add a blue square to the right and below each red square, if the square is not already on the edge of the grid. 
:: def cdgbcbcdccgiebecbdcfedafjdjbebff(I):
  obj = extract(objects(I, False, False, True), lambda o: color(o) == 2)
  extension = {(i - 1, j + 1) for i, j in toindices(obj) if (i - 1, j + 1) not in toindices(obj) and 0 <= i - 1 < len(I) and 0 <= j + 1 < len(I[0])}
  O = fill(I, 1, extension)
  return O
 
10.0, tensor(1.1166), Description: For each colored square in the input grid, find the closest colored square (using Manhattan distance). If the closest square is one square away, draw a blue line connecting the two squares. 
:: def idbehbbaeaeeeifhajgcfccjchghfhhg(I):
  # 1. Identify non-zero elements and their locations
  non_zeros = [(I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != 0]  
  
  # 2. Iterate through each non-zero element
  for i in range(len(non_zeros)):
    v1, (i1, j1) = non_zeros[i]
    closest_dist = float('inf')
    closest_neighbor = None
    
    # 3. For each non-zero element, find the closest neighbor
    for j in range(len(non_zeros)):
      if i != j:
        v2, (i2, j2) = non_zeros[j]
        dist = abs(i1 - i2) + abs(j1 - j2)  # Manhattan distance
        if dist < closest_dist:
          closest_dist = dist
          closest_neighbor = (i2, j2)

    # 4. If a closest neighbor exists within a distance of 1, connect them
    if closest_neighbor and closest_dist == 1:
      line = connect((i1, j1), closest_neighbor)  # Get line indices
      I = fill(I, 1, line)  # Draw the connecting line

  return I
 
17.666666666666668, tensor(0.0408), Description: Fill in the background of each colored shape with the color of the shape. 
:: def ddedgjdbhjbdefbgbbdfcafhegbcdhge(I):
    non_zeros = difference(asindices(I), ofcolor(I, ZERO))
    bounding_box = backdrop(non_zeros)
    O = fill(I, ONE, difference(bounding_box, non_zeros))
    return O
 
12.666666666666666, tensor(0.0512), Description: Draw a horizontal blue line from the upper left corner of the colored shape to the upper right corner of the colored shape. Then draw a vertical blue line from the upper left corner of the colored shape to the lower left corner of the colored shape. 
:: def ffffefbfejdeedieieffdcadibaidfhe(I):
    nz = difference(asindices(I), ofcolor(I, ZERO))
    ul = ulcorner(nz)
    lr = lrcorner(nz)
    O = fill(I, ONE, connect(ul, (lr[0], ul[1])))
    O = fill(O, ONE, connect(ul, (ul[0], lr[1])))
    return O
 
10.333333333333334, tensor(1.9852), Description: For each colored square in the input grid, draw a blue square in each of the four adjacent squares. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def jaeeaeccdfafedigbaecdbdebahebdee(I):
    mask = canvas(ZERO, shape(I))
    nz = difference(asindices(I), ofcolor(I, ZERO))
    for idx in nz:
        mask = fill(mask, ONE, neighbors(idx)) 
    O = cellwise(I, mask, ONE)
    return O
 
9.666666666666666, tensor(0.0408), Description: Fill in the background of each colored shape with the color of the shape. 
:: def fbdcbgffcidceddfbbebdbbcgajdbccg(I):
    box = outbox(difference(asindices(I), ofcolor(I, ZERO)))
    O = underfill(I, ONE, box)
    return O
 
10.0, tensor(0.1117), Description: For each shape that is red, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. 
:: def hjecdhbaggfhecdfbfbjadbedfdiebcc(I):
  objs = objects(I, T, F, F)  # Extract objects from the input grid
  target_objs = colorfilter(objs, TWO) # Identify objects with color '2'
  padding = lambda obj: delta(toindices(obj)) # Define a function to get bounding box indices
  padded_objs = mapply(padding, target_objs)  # Apply the padding function to each object
  O = fill(I, ONE, padded_objs) # Fill the bounding box indices with '1'
  return O
 
12.666666666666666, tensor(0.3090), Description: Fill the entire output grid with the most common color in the input grid. Then, copy the input grid onto the output grid, but only copy the colored squares. The background of the output grid should remain the most common color. 
:: def agbdaadeaeahefhajebeeeecacchfhea(I):
    return cellwise(canvas(1, shape(I)), I, mostcolor(I))
 
10.666666666666666, tensor(1.8181), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. 
:: def adbcfeejhjccedcgjjhageejajbdceag(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  new_grid = I
  for obj in objs:
    new_grid = paint(fill(new_grid, 1, delta(toindices(obj))), obj)
  return new_grid
 
14.0, tensor(0.0105), Description: Copy the input grid four times, shifting each copy one space up, down, left, and right. Then, overlay the shifted grids onto the original input grid. The output grid should show the original input grid with the same pattern shifted in all four directions. 
:: def iacecbhibgaeeccgbbjcbbefcfcaejhc(I):
  shifted_grids = [
    shift(asobject(I), direction) for direction in [UP, DOWN, LEFT, RIGHT]
  ]
  new_grid = I
  for shifted_grid in shifted_grids:
    new_grid = underpaint(new_grid, shifted_grid)
  return new_grid
 
8.666666666666666, tensor(1.7554), Description: For each colored shape in the input grid, add a blue square to the right, left, above, and below the shape, if the square is not already on the edge of the grid. 
:: def aaedibfijegaecbfbacgfjddhdhddfbc(I):
  objs = objects(I, False, False, True)  # Get all objects
  extensions = [(i + di, j + dj) for obj in objs for di, dj in [(0,1),(1,0),(0,-1),(-1,0)] for i, j in toindices(obj) if (i + di, j + dj) not in toindices(obj) and 0 <= i + di < len(I) and 0 <= j + dj < len(I[0])]
  O = fill(I, 1, frozenset(extensions))
  return O
 
7.666666666666667, tensor(1.9830), Description: For each colored shape in the input grid, draw a blue square in each of the four adjacent squares. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def ccechhdhfdbgeabcacdecjfcbjcddfge(I):
  O = I
  for obj in objects(I, False, False, True):
    surrounding = mapply(neighbors, toindices(obj))
    extension = difference(surrounding, toindices(obj))
    O = fill(O, 1, extension)
  return O
 
12.666666666666666, tensor(1.1450), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, fill the background of the output grid with the most common color in the input grid. 
:: def ccgcifbjhhaaeajdbfbfehadeceafdba(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  new_objs = set()
  for obj in objs:
    surrounding = difference(box(obj), toindices(obj))
    new_objs.add(recolor(ONE, surrounding))
  O = paint(canvas(bg, shape(I)), merge(new_objs))
  return O
 
19.666666666666668, tensor(1.1450), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, fill the background of the output grid with the most common color in the input grid. 
:: def deebbcbdcacbeacciddahgfadccdddcf(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  new_objs = set()
  for obj in objs:
    shifted_obj = shift(obj, (ONE, ONE))
    surrounding = difference(backdrop(shifted_obj), toindices(shifted_obj))
    new_objs.add(recolor(ONE, surrounding))
  O = paint(canvas(bg, shape(I)), merge(new_objs))
  return O
 
11.333333333333334, tensor(0.0147), Description: For each colored shape in the input grid, draw a blue square in each of the four adjacent squares. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def aabgejhdheggecgeaidgdddcfjfaifbc(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  result = canvas(bg, shape(I))
  for obj in objs:
    for i, j in toindices(obj):
      for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        new_i, new_j = i + di, j + dj
        if 0 <= new_i < height(I) and 0 <= new_j < width(I) and (new_i, new_j) not in toindices(obj):
          result = fill(result, ONE, {(new_i, new_j)})
  return result
 
12.666666666666666, tensor(1.1220), Description: Invert the colors of the input grid, then for each colored shape in the inverted grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, fill the background of the output grid with black. 
:: def eecdgfafgefhecddihajcigebfifcadb(I):
  inverted = replace(I, mostcolor(I), ONE)
  inverted = replace(inverted, ONE, ZERO)
  objs = objects(inverted, False, False, True)
  result = canvas(ZERO, shape(I))
  for obj in objs:
    result = underpaint(result, recolor(ONE, obj))
  return result
 
14.0, tensor(0.0512), Description: Draw a horizontal blue line from the upper left corner of the colored shape to the upper right corner of the colored shape. Then draw a vertical blue line from the upper left corner of the colored shape to the lower left corner of the colored shape. 
:: def fjfabdahcfeceacbiabdbacfaeeaaaad(I):
  nz = difference(asindices(I), ofcolor(I, ZERO)) # Find indices of non-zero cells
  ul = ulcorner(nz) # Find the upper left corner of the bounding box
  lr = lrcorner(nz) # Find the lower right corner of the bounding box
  O = fill(I, ONE, connect(ul, (lr[0], ul[1]))) # Fill the top row with '1'
  O = fill(O, ONE, connect((lr[0], ul[1]-1), (lr[0], lr[1]))) # Fill the rightmost column with '1'
  return O
 
12.666666666666666, tensor(0.0512), Description: Draw a horizontal blue line from the upper left corner of the colored shape to the upper right corner of the colored shape. Then draw a vertical blue line from the upper left corner of the colored shape to the lower left corner of the colored shape. 
:: def efdaiddchbfdejbcbddcbcdebabjiacj(I):
  nz = difference(asindices(I), ofcolor(I, ZERO))
  ul = ulcorner(nz)
  lr = lrcorner(nz)
  top_row = frozenset({(ul[0], j) for j in range(ul[1], lr[1] + 1)}) # Explicitly define top row indices
  right_column = frozenset({(i, lr[1]) for i in range(ul[0], lr[0] + 1)}) # Explicitly define right column indices
  O = fill(I, ONE, top_row)
  O = fill(O, ONE, right_column)
  return O
 
10.666666666666666, tensor(1.7486), Description: Fill the top left cell with blue if there is a colored cell in the first column. Fill the bottom right cell with blue if there is a colored cell in the last column. 
:: def bcgfgddfhefbefedagjbagfchadaibab(I):
  O = I # Start with output as input
  for j in range(width(I)):
    if any(I[i][j] != ZERO for i in range(height(I))): # Check if column j has non-zero element
      O = fill(O, ONE, {(ZERO, j)}) # If yes, fill the top cell in column j with '1'
      break # Stop after filling one cell in top row
  for i in range(height(I)):
    if I[i][width(I)-1] != ZERO: # Check if last column has non-zero element in row i
      O = fill(O, ONE, {(i, width(I)-1)}) # If yes, fill that cell in rightmost column with '1'
  return O 
 
13.0, tensor(0.0511), Description: Draw a diagonal blue line from the top left corner of the colored shape to the top right corner of the colored shape. Then draw a vertical blue line from the top right corner of the colored shape to the bottom right corner of the colored shape. 
:: def caeeagbaafagejegjiejbheejacahegc(I):
  O = I
  nz = difference(asindices(I), ofcolor(I, ZERO))
  top_right = max(nz, key=lambda x: x[1]) # Find the top-rightmost non-zero cell
  O = fill(O, ONE, connect((ZERO, ZERO), top_right)) # Fill diagonally from (0,0) to top-right
  O = fill(O, ONE, connect((top_right[0] + 1, top_right[1]), lrcorner(nz))) # Fill right column from top-right+1 downwards
  return O
 
11.0, tensor(1.0847), Description: For each colored cell in the input grid, fill the top cell in the same column and the rightmost cell in the same row with blue. 
:: def ddhehffceeedeeahabecbiebaifcgeed(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != ZERO: # If a non-zero cell is found
        O = fill(O, ONE, {(ZERO, j)}) # Fill the top cell in that column
        O = fill(O, ONE, {(i, width(I)-1)}) # Fill the rightmost cell in that row
  return O
 
11.0, tensor(0.0494), Description: For each red shape in the input grid, fill the bounding box of the shape with blue. The bounding box is the smallest rectangle that completely encloses the shape. 
:: def iabcgeecaeedehhcbhbfeecaefcgeebc(I):
    objs = colorfilter(objects(I, T, F, F), TWO)  # Get objects of color '2'
    filled_boxes = apply(lambda obj: fill(I, ONE, backdrop(toindices(obj))), objs)  # Fill bounding boxes of each object
    O = last(filled_boxes) # Choose the last filled grid as the output
    return O
 
17.333333333333332, tensor(0.0982), Description: Draw a blue border around the red shape. The border should be one square thick and should not overlap with any other shapes. 
:: def chcafcfjfifeegefagagebbgfjficcdb(I):
    indices = ofcolor(I, TWO)  # Get indices of '2's
    min_i = minimum(frozenset({i for i, j in indices}))  # Find topmost row
    max_i = maximum(frozenset({i for i, j in indices}))  # Find bottommost row
    min_j = minimum(frozenset({j for i, j in indices}))  # Find leftmost column
    max_j = maximum(frozenset({j for i, j in indices}))  # Find rightmost column
    box_indices = frozenset({(i, j) for i in range(min_i, max_i + 1) for j in range(min_j, max_j + 1)})  # Generate bounding box indices
    O = fill(I, ONE, box_indices - indices)  # Fill bounding box excluding the original object
    return O
 
16.666666666666668, tensor(0.0190), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, fill the background of the output grid with the most common color in the input grid. Then, for each colored shape, shift the border one square to the right and one square up, and add these shifted borders to the original border. Finally, paint the original colored shapes onto the output grid. 
:: def ebdgbbaadaffejihbdhjjdfcdeiaagdc(I):
  O = canvas(mostcommon(I), shape(I))
  for n in palette(I) - {mostcommon(I)}:
    indices = ofcolor(I, n)
    border = difference(backdrop(indices), indices)
    shifted_right = shift(border, RIGHT)
    shifted_up = shift(border, UP)
    combined_border = border | shifted_right | shifted_up
    O = fill(O, ONE, combined_border)
    O = paint(O, recolor(n, indices))
  return O
 
14.0, tensor(0.1121), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, shift the border one square to the left and one square down, and remove the overlapping squares. Finally, fill the remaining squares in the border with blue. 
:: def ijehabcfbadheeffihcdcccdhbchdgce(I):
  O = I
  for obj in fgpartition(I):
    O = underfill(O, ONE,  difference(outbox(obj), shift(outbox(obj), (-1, -1))))
  return O
 
14.666666666666666, tensor(1.9831), Description: For each colored shape in the input grid, draw a blue square in each of the four adjacent squares. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def fcbhhebcjgcaehdfbdaibebffdcbccbe(I):
  O = I
  for n in palette(I) - {mostcommon(I)}:
    for obj in objects(I, True, False, False):
      if color(obj) == n:
        for (v, (i, j)) in obj:
          O = underfill(O, ONE, {(i+1, j), (i, j+1), (i-1, j), (i, j-1)})
  return O
 
8.666666666666666, tensor(0.1220), Description: For each colored shape in the input grid, draw a blue square in each of the four adjacent squares. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. Then, fill the background of the output grid with the most common color in the input grid. 
:: def ajebhaadbbdiegaijagdfdfebabaceda(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  result = canvas(bg, shape(I))
  for obj in objs:
    result = paint(result, obj) # paint original object first
    for i, j in toindices(obj):
      for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        new_i, new_j = i + di, j + dj
        if 0 <= new_i < height(I) and 0 <= new_j < width(I) and index(I, (new_i, new_j)) == bg: #check if the neighbor is background
          result = fill(result, ONE, {(new_i, new_j)})
  return result
 
18.333333333333332, tensor(1.1150), Description: Copy the input grid and add a one-square border around it. Then, fill in any squares that are adjacent to a colored square with blue. Finally, trim the border off the grid. 
:: def jfbefaffecejebfajfddaeabcejjebbe(I):
  padded = canvas(mostcolor(I), add(shape(I), (2,2)))
  padded = paint(padded, shift(asobject(I), (1,1)))
  
  for i in range(1, height(padded) - 1):
    for j in range(1, width(padded) - 1):
      if padded[i][j] == mostcolor(I) and any(padded[i+di][j+dj] != mostcolor(I) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        padded = fill(padded, ONE, {(i,j)})
        
  return trim(padded)
 
15.666666666666666, tensor(1.7985), Description: Draw a blue border around the colored shape. The border should be one square thick and should not overlap with any other shapes. 
:: def cddcgddbbbcdefecbgbgjgbcbfeajfcd(I):
  nz = difference(asindices(I), ofcolor(I, ZERO)) # Find indices of non-zero elements
  bounding_box = box(nz) # Directly get the bounding box indices
  return fill(I, ONE, bounding_box) # Fill the bounding box with '1's
 
19.666666666666668, tensor(0.2672), Description: Draw a blue border around the colored shape. The border should be one square thick and should not overlap with any other shapes. Then, mirror the result horizontally and vertically. 
:: def hadecjdajediefcjjcbdbacgdbjbjgfe(I):
  nz = difference(asindices(I), ofcolor(I, ZERO))
  O = fill(I, ONE, box(nz)) # Fill the bounding box with '1's
  return hmirror(vmirror(O)) # Mirror the result to get the desired output
 
11.666666666666666, tensor(1.1262), Description: For each cell in the input grid, if the cell is part of a red shape, replace it with a blue square. Otherwise, keep the original cell value. 
:: def cbeiffjcdddaedfcbbgbafachjjjjjah(I):
  def process_cell(i, j):
    obj = extract(objects(I, T, F, F), lambda obj: (i, j) in toindices(obj))  # Find object containing (i, j)
    return ONE if obj and color(obj) == TWO else I[i][j]  # If object is '2', return '1', else original value
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w)) # Create empty canvas
  O = tuple(tuple(process_cell(i, j) for j in range(w)) for i in range(h)) # Iterate and process each cell
  return O
 
1.6666666666666667, tensor(1.1247), Description: For each cell in the input grid, if the cell is adjacent to a red square, replace it with a blue square. Otherwise, keep the original cell value. 
:: def gcgfhcbdceabejfbjddfceabcciifbef(I):
  def is_near_two(i, j):
    return any(index(I, (i + di, j + dj)) == TWO 
               for di in range(-1, 2) for dj in range(-1, 2)) # Check if any neighbor is '2'
  h, w = len(I), len(I[0])
  O = tuple(tuple(ONE if is_near_two(i, j) else I[i][j] for j in range(w)) for i in range(h))  # Fill based on neighbor check
  return O
 
9.333333333333334, tensor(0.0352), Description: For each colored shape in the input grid, extend the shape one square down and one square to the right. The extended squares should be filled with blue. If the shape is already on the edge of the grid, do not extend it beyond the edge. 
:: def bjbhecaecafbebajagfbhgbhhccjjajc(I):
  def extend_object(obj):
    shifted_down = shift(obj, DOWN)
    shifted_right = shift(obj, RIGHT)
    extension = difference(combine(shifted_down, shifted_right), obj)
    return underfill(I, 1, toindices(extension))
  return last(apply(extend_object, objects(I, False, False, True)))
 
13.333333333333334, tensor(0.0512), Description: Draw a vertical blue line from the upper left corner of the colored shape to the lower left corner of the colored shape. Then draw a horizontal blue line from the upper right corner of the colored shape to the lower right corner of the colored shape. 
:: def hhbjffjebidcehjdbecbecabfbdeafbb(I):
    nz = difference(asindices(I), ofcolor(I, ZERO)) # Get indices of non-zero elements
    ul = ulcorner(nz) # Find upper-left corner of bounding box
    lr = lrcorner(nz) # Find lower-right corner of bounding box
    O = I
    for i in range(ul[0], len(I)): # Fill from top edge down
        O = fill(O, ONE, {(i, lr[1])}) 
    for j in range(ul[1], len(I[0])): # Fill from right edge left
        O = fill(O, ONE, {(ul[0], j)})
    return O 
 
12.666666666666666, tensor(0.0511), Description: Draw a vertical blue line from the upper right corner of the colored shape to the bottom right corner of the colored shape. Then draw a horizontal blue line from the upper right corner of the colored shape to the upper left corner of the colored shape. 
:: def bfahgfddhgbdecafacbcdhhffdgcehdc(I):
    nz = difference(asindices(I), ofcolor(I, ZERO))
    upper_right = urcorner(nz)
    right_edge = connect(upper_right, (len(I) - 1, upper_right[1]))
    top_edge = connect(upper_right, (upper_right[0], len(I[0]) - 1))
    O = fill(I, ONE, right_edge | top_edge)
    return O
 
11.0, tensor(0.0114), Description: Draw a blue line connecting the top left corner of the red shape to the bottom right corner of the red shape. Then, draw a blue line connecting the center of the first line to the center of either the orange or the grey shape, whichever is present in the input. 
:: def hbgcgfedfbbheefibcdecieagfijacih(I):
  obj2 = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 2))
  first2 = ulcorner(obj2)
  last2 = lrcorner(obj2)
  path1 = connect(first2, last2)
  if colorcount(I, 6) > 0:
    target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 6))
  elif colorcount(I, 8) > 0:
    target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 8))
  else:
    target = path1
  path2 = connect(centerofmass(path1), first(toindices(target)))
  O = I
  for i, j in path1:
    O = fill(O, 1, {(i, j)})
  for i, j in path2:
    O = fill(O, 1, {(i, j)})
  return O
 
3.6666666666666665, tensor(1.8124), Description: Draw a blue border around the red shape. The border should be one square thick and should not overlap with any other shapes. 
:: def ceahifdgecccedaaicigcicaffbhffbj(I):
    obj2 = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 2))
    if obj2:
        box_indices = outbox(obj2)
        O = I
        for i, j in box_indices:
            if 0 <= i < len(I) and 0 <= j < len(I[0]):
                O = fill(O, 1, {(i, j)})
        return O
    else:
        return I
 
23.0, tensor(0.2284), Description: For each colored square in the input grid, draw a blue square diagonally to the right and down from the colored square. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def ebejacghefgdeicdicabjgdgcbdhaaja(I):
  def diagonal_neighbors(i, j):
    return {(i + 1, j + 1)}
  extended_indices = mpapply(diagonal_neighbors, *zip(*[(i, j) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != mostcommon(I)]))
  return fill(I, 1, extended_indices)
 
9.0, tensor(0.0352), Description: For each colored shape in the input grid, extend the shape one square down and one square to the right. The extended squares should be filled with blue. If the shape is already on the edge of the grid, do not extend it beyond the edge. 
:: def cbhbcddbaeedeiddibcdcaacadgiicdb(I):
  def right_down_extension(obj):
    return difference(combine(shift(obj, DOWN), shift(obj, RIGHT)), obj)
  extended_objects = apply(right_down_extension, objects(I, False, False, True))
  return underpaint(I, recolor(1, merge(extended_objects)))
 
18.333333333333332, tensor(1.7701), Description: Draw a blue border around the colored shape. The border should be one square thick and should not overlap with any other shapes. Then, paint the original colored shape onto the output grid. 
:: def ccdaahgedhhdecehaabfbadabfciecai(I):
  nz = difference(asindices(I), ofcolor(I, ZERO))
  shifted_lr = add(lrcorner(nz), (1, 1))
  box = backdrop(frozenset({ulcorner(nz), shifted_lr}))
  O = fill(I, ONE, box)
  O = paint(O, toobject(nz, I))
  return O
 
9.666666666666666, tensor(0.0352), Description: For each colored shape in the input grid, extend the shape one square down and one square to the right. The extended squares should be filled with blue. If the shape is already on the edge of the grid, do not extend it beyond the edge. 
:: def aiegcedcfeaieccdaabbhchhfcbegedc(I):
  def is_foreground(obj):
    return any(I[i][j] != mostcommon(I) for i, j in toindices(obj))
  def extend_obj(obj):
    return {(1, (i + 1, j + 1)) for v, (i, j) in obj if 0 <= i + 1 < len(I) and 0 <= j + 1 < len(I[0])}
  extended_objects = frozenset({cell for obj in objects(I, False, False, True) 
                             if is_foreground(obj)
                             for cell in extend_obj(obj)})
  return paint(I, extended_objects)
 
9.333333333333334, tensor(1.8152), Description: Draw a blue rectangle that encloses all the colored shapes in the input grid. The rectangle should be as small as possible and should not overlap with any of the colored shapes. If there are no colored shapes in the input grid, return the input grid unchanged. 
:: def efbcghdcfaifedcgabaaagcefeffbhfc(I):
  nz = difference(asindices(I), ofcolor(I, ZERO))  # Find indices of non-zero elements
  if nz:  # Proceed if non-zero elements exist
    tr = max(nz, key=lambda x: x[1]) # Find top-rightmost non-zero index
    bl = min(nz, key=lambda x: x[0]) # Find bottom-leftmost non-zero index
    rect = product(interval(bl[0], tr[0]+1, 1), interval(bl[1], tr[1]+1, 1))  # Indices of the rectangle
    O = fill(I, ONE, rect) # Fill the rectangle with '1's
  else:
    O = I
  return O
 
20.333333333333332, tensor(1.8038), Description: Fill the background of the grid with blue if there are any colored shapes in the input grid. If there are no colored shapes, return the input grid unchanged. 
:: def abfbgjgbaeffecgfjhdahbaaabfdhbeb(I):
  nz = sfilter(asindices(I), lambda x: index(I, x) != ZERO) # Find indices of non-zero elements
  if nz: 
    O = fill(I, ONE, backdrop(nz)) # Fill the backdrop of non-zero elements with '1's
  else:
    O = I
  return O
 
12.0, tensor(0.0101), Description: For each colored shape in the input grid, extend the shape one square up and one square to the right. The extended squares should be filled with the same color as the shape. If the shape is already on the edge of the grid, do not extend it beyond the edge. 
:: def fdffafagidfeeaebacacfchbhdecgaab(I):
  objs = objects(I, True, False, True) # Get all foreground objects
  for obj in objs:
    for cell in obj:
      i, j = cell[1] # Get cell coordinates
      for di, dj in ((-1, 0), (0, 1)): # Up and Right directions
        new_i, new_j = i + di, j + dj
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]) and I[new_i][new_j] == mostcolor(I):
          I = fill(I, cell[0], {(new_i, new_j)}) # Fill if background
  return I
 
9.333333333333334, tensor(1.9822), Description: For each colored shape in the input grid, draw a blue square in the cell below and to the right of the shape, if the cell is not already on the edge of the grid. Then, fill the background of the output grid with the most common color in the input grid. 
:: def hbbbehddgfadejgiaebjcecfaaifeacb(I):
  objs = objects(I, False, False, True) # Identify objects excluding background
  bg = mostcolor(I) # Identify background color
  result = canvas(bg, shape(I)) # Create a canvas filled with background color
  for obj in objs:
    result = paint(result, obj) # Paint the object onto the result canvas
    for (i, j) in toindices(obj):
      if i < height(I) - 1 and j < width(I) - 1: # Check if not on bottom or right edge
        if index(I, (i + 1, j)) == bg: # Check if cell below is background
          result = fill(result, ONE, {(i + 1, j)}) # Fill below with "1"
        if index(I, (i, j + 1)) == bg: # Check if cell to the right is background
          result = fill(result, ONE, {(i, j + 1)}) # Fill right with "1"
  return result
 
17.666666666666668, tensor(1.9822), Description: For each colored shape in the input grid, draw a blue square in the cell below and to the right of the shape, if the cell is not already on the edge of the grid. Then, fill the background of the output grid with the most common color in the input grid. 
:: def ghifhegecadbeabdjbiiaaefaccbcfdd(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  result = canvas(bg, shape(I))
  for obj in objs:
    result = underpaint(result, obj) # Use underpaint to directly paint on the background
    for i in range(height(I) - 1): # Iterate through rows except the last one
      for j in range(width(I) - 1): # Iterate through columns except the last one
        if index(result, (i, j)) != bg: # Check if the cell is not background
          if index(result, (i + 1, j)) == bg:
            result = fill(result, ONE, {(i + 1, j)})
          if index(result, (i, j + 1)) == bg:
            result = fill(result, ONE, {(i, j + 1)}) 
  return result
 
9.0, tensor(1.9824), Description: For each colored shape in the input grid, draw a blue square in the cell below and to the right of the shape, if the cell is not already on the edge of the grid. Then, paint the original colored shape on top of the blue squares. Finally, fill the background of the output grid with the most common color in the input grid. 
:: def cbbceaifdgfbeaecjjcejeegfeejeejc(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  result = canvas(bg, shape(I))
  for obj in objs:
    shifted_down = shift(obj, (1, 0)) # Shift object down by one cell
    shifted_right = shift(obj, (0, 1)) # Shift object right by one cell
    halo_down = toindices(sfilter(shifted_down, lambda cell: 0 <= cell[1][0] < height(I) and 0 <= cell[1][1] < width(I) and index(I, cell[1]) == bg)) # Get valid halo locations below
    halo_right = toindices(sfilter(shifted_right, lambda cell: 0 <= cell[1][0] < height(I) and 0 <= cell[1][1] < width(I) and index(I, cell[1]) == bg)) # Get valid halo locations to the right
    result = fill(result, ONE, halo_down) # Fill halo locations below with "1"
    result = fill(result, ONE, halo_right) # Fill halo locations to the right with "1"
    result = paint(result, obj) # Paint the object on top
  return result
 
8.666666666666666, tensor(1.9853), Description: For each colored square in the input grid, draw a blue square in each of the four diagonal squares adjacent to it. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. 
:: def dffibffadajfeaacieabcdgdjfhaeadd(I):
  nz = difference(asindices(I), ofcolor(I, ZERO)) # Find indices of non-zero cells
  O = I
  for (i, j) in nz:
    for (ni, nj) in dneighbors((i,j)):
      if (ni, nj) in asindices(I):
        O = fill(O, ONE, {(ni, nj)})
  return O
 
8.0, tensor(1.5268), Description: For each colored shape in the input grid, draw a blue border around it. The border should be one square thick and should not overlap with any other shapes. Then, for each colored square, add a blue square diagonally to the right and down from the colored square. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. Finally, paint the original colored shapes onto the output grid. 
:: def cbbifdfiafbeeheaacgbffjbbcgbdebj(I):
  O = canvas(mostcommon(I), shape(I)) # Create a canvas of background color
  for n in palette(I) - {mostcommon(I)}: # Iterate over non-background colors
    indices = ofcolor(I, n) # Get indices of the current color
    extended_border = mapply(lambda idx: dneighbors(idx) | {(idx[0] - 1, idx[1] + 1)}, indices) # Calculate extended border indices
    O = underfill(O, ONE, extended_border) # Fill the extended border with '1' on the canvas
    O = paint(O, recolor(n, indices)) # Paint the original object on the canvas
  return O
 
11.333333333333334, tensor(0.0267), Description: For each colored shape in the input grid, draw a blue square in each of the four diagonal squares adjacent to it. If the colored square is on the edge of the grid, then only add the squares that are inside the grid. Then, combine the halo grid with the input grid, prioritizing the halo markings (blue squares). This means that if a cell is both a halo cell and a colored cell in the input, the output cell will be blue. 
:: def bjedbeccddceegegieafhbjgaffcbede(I):
  objs = objects(I, False, False, True) 
  bg = mostcolor(I)
  halo_grid = canvas(ZERO, shape(I))  # Create a separate halo grid
  for obj in objs:
    halo_grid = fill(halo_grid, ONE, mapply(lambda loc: dneighbors(loc) - toindices(obj), toindices(obj)))  # Mark halo cells on the separate grid
  return cellwise(halo_grid, I, ONE)  # Combine halo grid with the input, prioritizing the halo markings
 
12.666666666666666, tensor(1.8050), Description: Draw a blue border around each colored shape in the input grid. The border should be one square thick and should not overlap with any other shapes. 
:: def dceeaajdjccgeaeciccbcgfcdaefgeia(I):
    objs = objects(I, False, False, True) # identify objects in the grid, excluding the background
    return fill(I, ONE, merge([backdrop(obj) for obj in objs])) # fill the backdrop of each object with ONE
 
11.333333333333334, tensor(0.2306), Description: Draw a blue line connecting the bottom right corner of the red shape to the top left corner of either the orange or the grey shape, whichever is present in the input. If neither orange nor grey is present, fill the output grid with blue and paint the red shape onto it. 
:: def fbehbcbcgaebeeibaacceeeffajdiadd(I):
  obj2 = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 2))
  corner2 = lrcorner(obj2)
  if colorcount(I, 6) > 0:
    target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 6))
  elif colorcount(I, 8) > 0:
    target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 8))
  else:
    return fill(canvas(ONE, shape(I)), mostcolor(I), toindices(obj2))
  corner_target = ulcorner(target)
  path = connect(corner2, corner_target)
  O = I
  for i, j in path:
    O = fill(O, 1, {(i, j)})
  return O
 
25.666666666666668, tensor(1.7758), Description: Fill the output grid with blue and paint the red shape onto it. If either orange or grey is present in the input grid, fill the output grid with blue and paint the red shape onto it. 
:: def ifeffedaeagcedhejgabjadddcdbdhbi(I):
  obj2 = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 2))
  if colorcount(I, 6) > 0 or colorcount(I, 8) > 0:
    return paint(
      fill(canvas(ONE, shape(I)), mostcolor(I), toindices(obj2)), obj2
    )
  else:
    return fill(canvas(ONE, shape(I)), mostcolor(I), toindices(obj2))
 
10.333333333333334, tensor(0.0331), Description: Draw a blue line connecting the bottom right corner of the red shape to the top left corner of either the orange or the grey shape, whichever is present in the input. If neither orange nor grey is present, do nothing. 
:: def dcbbgcfhajddefahabbadeaddbebdfec(I):
  O = I
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      if colorcount(I, 6) > 0:
        target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 6))
      elif colorcount(I, 8) > 0:
        target = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 8))
      else:
        target = None
      if target is not None:
        start = lrcorner(obj)
        end = ulcorner(target)
        path = connect(start, end)
        for i, j in path:
          O = fill(O, 1, {(i, j)})
  return O
 
11.666666666666666, tensor(1.9963), Description: Fill the output grid with blue. Then, paint all the shapes in the input grid onto the output grid, except for the red shapes. 
:: def bibcbfaacaffeeeaijcddadcfeejaaej(I):
  O = fill(canvas(ONE, shape(I)), mostcolor(I), asindices(I))
  for obj in objects(I, True, False, True):
    if color(obj) != 2:
      O = paint(O, obj)
  return O
 
25.333333333333332, tensor(1.7753), Description: Fill the output grid with blue and paint the red shape onto it. If there are any other shapes in the input grid besides the red shape, paint those shapes onto the output grid as well. 
:: def habecafdffeceecebffbgchdbaeahffi(I):
  obj2 = first(sfilter(objects(I, True, False, True), lambda obj: color(obj) == 2))
  if len(objects(I, True, False, True)) > 1:
    O = fill(canvas(ONE, shape(I)), mostcolor(I), toindices(obj2))
    for obj in objects(I, True, False, True):
      if color(obj) != 2:
        O = paint(O, obj)
    return O
  else:
    return fill(canvas(ONE, shape(I)), mostcolor(I), toindices(obj2))
 
14.0, tensor(0.0066), Description: For each colored shape in the input grid, draw a diagonal blue line from the upper right corner of the shape to the lower left corner of the shape. The line should be as long as possible, and should not go outside the bounds of the shape. 
:: def adbaihdehiejebefjabfabhghabifceb(I):
  def draw_diagonal(obj):
    corner = urcorner(obj)
    trail = {corner}
    i, j = corner
    while 0 <= i + 1 < len(I) and 0 <= j + 1 < len(I[0]) and I[i + 1][j + 1] == 0:
      i, j = i + 1, j + 1
      trail.add((i, j))
    return trail
  filled_indices = merge([draw_diagonal(obj) for obj in objects(I, False, False, True)])
  return fill(I, 1, filled_indices)
 
15.666666666666666, tensor(1.9821), Description: For each colored cell in the input grid, draw a horizontal blue line extending to the right and left until it encounters another colored cell or the edge of the grid. Also, draw a vertical blue line extending downwards until it encounters another colored cell or the edge of the grid. Finally, fill the background of the output grid with the most common color in the input grid. 
:: def fbahibdgbeefebehjideedcachhidajh(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != bg:
        O = paint(O, {(val, (i,j))}) # Paint the original object
        for k in range(j+1, width(I)): # Extend rightward
          if index(I, (i, k)) == bg:
            O = paint(O, {(ONE, (i,k))})
          else:
            break
        for k in range(j-1, -1, -1): # Extend leftward
          if index(I, (i, k)) == bg:
            O = paint(O, {(ONE, (i,k))})
          else:
            break
        if i < height(I) - 1: # Extend downward
          if index(I, (i+1, j)) == bg:
            O = paint(O, {(ONE, (i+1,j))})
  return O
 
17.666666666666668, tensor(1.9835), Description: For each colored shape in the input grid, extend the shape one square to the right, left, and down until it encounters another colored shape or the edge of the grid. The extended squares should be filled with blue. If the shape is already on the edge of the grid, do not extend it beyond the edge. Then, paint the original colored shape on top of the blue squares. Finally, fill the background of the output grid with the most common color in the input grid. 
:: def beefdacdafagecajiebcebehccfbffed(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    O = paint(O, obj) # Paint the original object
    for direction in [RIGHT, LEFT, DOWN]:
      extension = set()
      for k in range(1, max(height(I), width(I))):
        shifted_obj = shift(obj, multiply(direction, k))
        if not any(index(I, (i, j)) != bg for _, (i, j) in shifted_obj):
          extension |= shifted_obj
        else:
          break
      O = paint(O, recolor(ONE, extension))
  return O
 
8.666666666666666, tensor(1.1801), Description: Draw a blue border around each colored shape in the input grid. The border should be one square thick and should not overlap with any other shapes. Then, paint the original colored shapes onto the output grid. Finally, fill the background of the output grid with the most common color in the input grid. 
:: def ibdahjcedchaeacjiddfgchaghjfdcdi(I):
  bg = mostcolor(I)
  obj_indices = set((i, j) for i in range(height(I)) for j in range(width(I)) if I[i][j] != bg)
  border = set()
  for i, j in obj_indices:
    for di, dj in [(0, 1), (0, -1), (1, 0)]:
      ni, nj = i + di, j + dj
      if 0 <= ni < height(I) and 0 <= nj < width(I) and (ni, nj) not in obj_indices and (ni, nj) not in border:
        border.add((ni, nj))
  O = canvas(bg, shape(I))
  for i, j in obj_indices:
    O = paint(O, {(I[i][j], (i, j))})
  for i, j in border:
    O = paint(O, {(ONE, (i, j))})
  return O
 
13.666666666666666, tensor(1.7701), Description: Draw a blue border around the colored shape. The border should be one square thick and should not overlap with any other shapes. Then, paint the original colored shape onto the output grid. 
:: def dibjaacffadgebjdjaacbbjddbbjbjdh(I):
  # Object representing all non-zero cells
  nz_obj = toobject(difference(asindices(I), ofcolor(I, ZERO)), I)
  # Paint the object onto a canvas of 1s
  O = paint(fill(I, ONE, box(nz_obj)), nz_obj) 
  return O
 
26.333333333333332, tensor(1.7648), Description: Fill the entire output grid with blue. Then, paint the colored shapes from the input grid onto the output grid. If a cell is both blue and a colored shape in the input, the output cell will be the color of the shape. 
:: def fheedgbbchgceedebggcjecfcaddigif(I):
  # Find non-zero indices and create object
  nz_indices = difference(asindices(I), ofcolor(I, ZERO))
  nz_obj = toobject(nz_indices, I) 
  # Create a grid of 1s with the same dimensions as input
  ones_grid = canvas(ONE, shape(I)) 
  # Combine the ones_grid and nz_obj, prioritizing nz_obj values
  O = cellwise(paint(ones_grid, nz_obj), ones_grid, ONE)
  return O
 
4.666666666666667, tensor(1.7827), Description: For each red shape in the input grid, draw a blue square one square to the left, one square to the right, one square above, and one square below the shape. If the shape is already on the edge of the grid, do not extend it beyond the edge. 
:: def hdhaefafijdhecgcjdgjbiaacbaeaahd(I):
  O = I
  for obj in colorfilter(objects(I, T, F, F), TWO):
    O = underfill(O, ONE, toindices(shift(obj, (-1, 0))))
    O = underfill(O, ONE, toindices(shift(obj, (1, 0))))
    O = underfill(O, ONE, toindices(shift(obj, (0, -1))))
    O = underfill(O, ONE, toindices(shift(obj, (0, 1))))
  return O
 
0.0, tensor(0.4465), Description: For each red shape in the input grid, draw a blue square in each of the eight squares surrounding it (above, below, left, right, and diagonals). If the red shape is on the edge of the grid, then only add the squares that are inside the grid. 
:: def beeeadcfeihceadfieiaccgbbaabgfhc(I):
  def expand_and_paint(grid, obj):
    for di in range(-1, 2):
      for dj in range(-1, 2):
        if (di, dj) != (0, 0):
          grid = underfill(grid, ONE, toindices(shift(obj, (di, dj))))
    return grid

  O = I
  for obj in colorfilter(objects(I, T, F, F), TWO):
    O = expand_and_paint(O, obj)
  return O
 
