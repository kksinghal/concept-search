14.333333333333334, tensor(0.7937), Description: Find the largest object in the input grid. Then, find all objects that are adjacent to the largest object. Recolor all of the adjacent objects to color 1. Finally, recolor all remaining objects that are not the background color to color 2. 
:: def bbffaadachdgehefibhfbajaciacdbea(I):
    # 1. Identify the largest object
    largest_obj = argmax(objects(I, False, False, False), size)
    
    # 2. Find objects adjacent to the largest object
    adjacent_objs = mfilter(objects(I, False, False, False), lambda obj: adjacent(obj, largest_obj))
    
    # 3. Recolor adjacent objects to 1
    I = paint(cover(I, adjacent_objs), recolor(1, merge(adjacent_objs)))
    
    # 4. Recolor remaining non-background objects to 2
    I = replace(I, leastcolor(I), 2) 
    
    return I
 
88.0, tensor(0.1559), Description: Find the largest object in the input grid. Expand the largest object by one square in all directions to create a mask. Recolor all objects that intersect with the mask to color 1. Finally, recolor all remaining objects that are not the background color to color 2. 
:: def efbgjjecafcceagjjffaajihgeddbfea(I):
    # 1. Find the largest object
    largest_obj = argmax(objects(I, False, False, False), size)

    # 2. Create a mask by expanding the largest object
    mask = backdrop(shift(largest_obj, (1, 1)))

    # 3.  Recolor based on intersection with the mask
    O = paint(I, recolor(1, merge(sfilter(objects(I, False, False, False), lambda obj: intersection(toindices(obj), mask))))) 
    O = replace(O, leastcolor(O), 2)
    return O
 
12.0, tensor(0.9785), Description: Find the largest object in the input grid and determine its bounding box. Recolor all objects that are fully outside the bounding box to color 2. Finally, recolor all remaining objects that are not the background color to color 1. 
:: def bhgcehjgiceeegaeidcbbcbgcjdjeeed(I):
    # 1. Find the bounding box of the largest object
    largest_obj_bbox = backdrop(argmax(objects(I, False, False, False), size))

    # 2. Define a function to check if an object is fully outside the bounding box
    is_outside_bbox = lambda obj: all((i, j) not in largest_obj_bbox for _, (i, j) in obj)

    # 3. Recolor based on position relative to the bounding box
    O = paint(I, recolor(2, merge(sfilter(objects(I, False, False, False), is_outside_bbox)))) 
    O = replace(O, leastcolor(O), 1)
    return O
 
90.0, tensor(1.1058), Description: Copy the input grid and fill it with the color 2. Then, paint the largest object onto the grid, followed by the second largest object. Keep the original colors of the objects. 
:: def gdeeeafdaiagedbhjacjjhhdehfahbda(I):
  objs = order(objects(I, T, F, T), size)
  largest = first(objs)
  second_largest = first(remove(largest, objs))
  O = paint(paint(canvas(2, shape(I)), largest), second_largest)
  return O
 
23.0, tensor(0.1119), Description: Copy the input grid. Recolor the largest object to its original color, the second largest object to color 1, and all other objects to color 2. 
:: def hddfacgecgaaefgbicfdbafifebeeeca(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  largest_size = maximum(sizes)
  second_largest_size = maximum(remove(largest_size, sizes))
  O = I
  for obj in objs:
    if size(obj) == largest_size:
      O = paint(O, obj)
    elif size(obj) == second_largest_size:
      O = paint(O, recolor(1, obj))
    else:
      O = paint(O, recolor(2, obj))
  return O
 
20.0, tensor(0.1119), Description: Copy the input grid. Recolor the largest object to its original color, the second largest object to color 1, and all other objects to color 2. 
:: def bddaaccgfcicejehjcfabeedecgcbdcd(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  remaining = remove(largest, objs)
  second_largest = argmax(remaining, size)
  O = I
  for obj in objs:
    if obj == largest:
      O = paint(O, obj)
    elif obj == second_largest:
      O = paint(O, recolor(1, obj))
    else:
      O = paint(O, recolor(2, obj))
  return O
 
97.66666666666667, tensor(1.0790), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 2 and the most common color in the downscaled grid with color 1. 
:: def aachdaaegeaieaahjcabbdccicddhffa(I):
    downscaled = downscale(I, 3)
    O = replace(replace(downscaled, 5, 2), mostcolor(downscaled), 1)
    return O
 
93.0, tensor(1.0629), Description: Create a 3x4 grid. For each 3x3 block in the input grid, if the top-left cell is color 5, paint the corresponding cell in the output grid with color 2. If the top-left cell is not the most common color in the input grid, paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as color 0. 
:: def gcjiabibicjdeagdbcdedabjfbdjeeff(I):
    O = canvas(0, (3, 4))
    for i in range(3):
        for j in range(4):
            if I[i * 3][j * 3] == 5:
                O = paint(O, {(2, (i, j))})
            elif I[i * 3][j * 3] != mostcolor(I):
                O = paint(O, {(1, (i, j))})
    return O
 
25.0, tensor(1.9833), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space to the left with color 1. 
:: def eebdajcdeiieebibiahdfhchifgfgfbb(I):
    objs = objects(I, T, F, T)
    obj = argmax(objs, size)
    O = paint(paint(canvas(0, shape(I)), recolor(2, obj)), recolor(1, shift(obj, (-1, 0))))
    return O 
 
26.333333333333332, tensor(1.1040), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, the third largest object to color 3, and so on.  The original colors of the objects are ignored. 
:: def idddcefdbadbefbfidbecajfdbadfeff(I):
    objs = objects(I, T, F, T) # Extract objects, excluding background
    sorted_objs = order(objs, lambda obj: -len(obj)) # Sort by size (descending)
    new_objs = mpapply(lambda i, obj: recolor(i + 1, obj), interval(size(objs), ZERO, NEG_ONE), sorted_objs) # Recolor based on size ranking
    O = paint(I, new_objs) # Paint recolored objects onto the input grid
    return O
 
26.333333333333332, tensor(1.1121), Description: Copy the input grid. Recolor the objects based on their size ranking. The largest object is recolored to color 1, the second largest to color 2, and so on. The original colors of the objects are preserved for all other objects that are not among the largest. 
:: def fabiahejjjbbejigaeggfaefachghdec(I):
    objs = objects(I, T, F, T)
    obj_sizes = apply(size, objs) # Get sizes of all objects
    sorted_sizes = order(obj_sizes, identity) # Sort sizes
    new_objs = mpapply(lambda s, obj: branch(size(obj) == s, recolor(sorted_sizes.index(s) + 1, obj), obj), sorted_sizes, objs) # Recolor based on size ranking
    O = paint(I, new_objs) 
    return O
 
21.333333333333332, tensor(1.1117), Description: Copy the input grid. Recolor each object based on its size ranking within the grid. The largest object is recolored to color 1, the second largest to color 2, and so on. The original colors of the objects are preserved for all other objects that are not among the largest. 
:: def baedbcdbdjdeebbdahfjjgicfgfcajbc(I):
  objs = objects(I, T, F, T)
  def recolor_by_rank(obj):
    ranks = order(objs, lambda x: len(x)) # Rank objects by size within the function
    return recolor(ranks.index(obj) + 1, obj) # Recolor based on rank
  O = paint(I, mapply(recolor_by_rank, objs))
  return O
 
20.0, tensor(1.1040), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, the third largest object to color 3, and so on. The original colors of the objects are ignored. 
:: def bdddgdadghcaehabjcfccedbigcdejeb(I):
  objs = list(objects(I, T, F, T)) # Convert to list for indexing
  objs.sort(key=len, reverse=True) # Sort by size in descending order
  O = I # Initialize output with input
  for i in range(len(objs)):
    O = paint(O, recolor(i+1, objs[i])) # Iterative recoloring based on index
  return O
 
23.333333333333332, tensor(1.1117), Description: Copy the input grid. Recolor each object based on its size ranking within the grid. The largest object is recolored to color 1, the second largest to color 2, and so on. The original colors of the objects are preserved for all other objects that are not among the largest. 
:: def cdgdejbjabjaehahjcggbfdgfcfddfag(I):
  objs = objects(I, T, F, T)
  size_dict = {} 
  for i, obj in enumerate(order(objs, size)): # Create a dictionary mapping size to rank
    size_dict[len(obj)] = i + 1
  recolored_objs = mapply(lambda obj: recolor(size_dict[len(obj)], obj), objs) # Recolor using the dictionary lookup
  O = paint(I, recolored_objs)
  return O
 
48.666666666666664, tensor(1.1294), Description: Recolor the topmost object to color 1, the bottommost object to color 2, and all other objects to the background color (0). 
:: def ccdbcdbeaaaaecedacebcdeabjebaejf(I):
    objs = objects(I, T, F, F) 
    top_obj = argmax(objs, uppermost)
    bottom_obj = argmin(objs, uppermost)
    other_objs = objs - {top_obj, bottom_obj}
    I = paint(I, recolor(1, top_obj))
    I = paint(I, recolor(2, bottom_obj))
    for obj in other_objs:
        I = paint(I, recolor(0, obj))
    O = I
    return O
 
25.0, tensor(0.7378), Description: Copy the input grid. Recolor the top row with color 1 and the bottom row with color 2. Keep the original colors of all other cells. 
:: def ficbhjbcjdffeffiibjcdegdcjigcfif(I):
  top_row = uppermost(asindices(I))
  bottom_row = lowermost(asindices(I))
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if i == top_row and v != 0:
        O = paint(O, {(1, (i, j))})
      elif i == bottom_row and v != 0:
        O = paint(O, {(2, (i, j))})
      else:
        if v != 0:
          O = paint(O, {(v, (i, j))})
  return O
 
20.0, tensor(1.1023), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object to color 2, the second largest object to color 1, and keep the original colors of all other objects. 
:: def ifcaeaeajibbecfbjfejabgaddbdbjbf(I):
  objs = objects(I, T, F, T)
  s = size
  largest = argmax(objs, s)
  second_largest = argmax(remove(largest, objs), s)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if obj == largest:
      O = paint(O, recolor(2, obj))
    elif obj == second_largest:
      O = paint(O, recolor(1, obj))
    else:
      O = paint(O, obj)
  return O
 
15.0, tensor(0.6851), Description: Copy the input grid. Recolor the largest object to color 2, the second largest object to color 1, and leave all other objects unchanged. 
:: def hibhgiigdiacedccbahdfddbafcabiib(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  largest = maximum(sizes)
  second_largest = maximum(remove(largest, sizes))
  O = I
  for obj in objs:
    if size(obj) == largest:
      O = paint(O, recolor(2, obj))
    elif size(obj) == second_largest:
      O = paint(O, recolor(1, obj))
  return O
 
24.0, tensor(0.6347), Description: Copy the input grid. Recolor the largest object to color 2 and the second largest object to color 1. Leave all other objects unchanged. 
:: def bahfcjabfgfieicabacdgibbfbfhfidf(I):
  objs = objects(I, T, F, T)
  objs = order(objs, size)
  O = I
  for i in range(len(objs)):
    obj = objs[i]
    if i == 0:  
      O = paint(O, recolor(2, obj)) 
    elif i == 1:  
      O = paint(O, recolor(1, obj))
  return O
 
90.33333333333333, tensor(1.0790), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 2 and all other colors except the background (0) with color 1. 
:: def hbdicafahjdaehcibbfjcacjhchabdbd(I):
    O = downscale(I, 3) 
    O = replace(O, 5, 2)  # Recolor the downscaled '5' object to '2'
    for v in palette(O) - {0, 2}: 
        O = replace(O, v, 1)  # Recolor other objects to '1'
    return O
 
90.33333333333333, tensor(1.0798), Description: Create a new grid with dimensions 1/3 the size of the input grid. For each 3x3 block in the input grid, determine the most frequent color. If the most frequent color is 5, paint the corresponding cell in the output grid with color 2. If the most frequent color is not 0, paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as color 0. 
:: def cghedjbhaefaegbaiffbefgeajfcefae(I):
  O = canvas(0, shape(downscale(I, 3)))
  for i in range(len(I) // 3):
    for j in range(len(I[0]) // 3):
      block = crop(I, (i * 3, j * 3), (3, 3))
      dominant_color = mostcolor(block)
      new_color = 2 if dominant_color == 5 else (1 if dominant_color != 0 else 0)
      O = paint(O, {(new_color, (i, j))})
  return O
 
25.666666666666668, tensor(1.9834), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space diagonally down-left with color 1. 
:: def eiiiafbgcdejedcaaceieafdgdagficg(I):
  obj = argmax(objects(I, T, F, T), size) # Find largest object
  shifted_obj = shift(obj, (-1,-1)) # Shift down-left
  O = paint(paint(canvas(0, shape(I)), recolor(2, obj)), recolor(1, shifted_obj)) # Paint
  return O
 
20.0, tensor(1.1040), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, the third largest object to color 3, and so on. The original colors of the objects are ignored. 
:: def bhbccfccajdbeeaaadhccijhcjdiaeac(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda x: len(x))[::-1] # Sort objects by size (descending)
  O = I
  for i, obj in enumerate(sorted_objs):
    O = paint(O, recolor(i + 1, obj)) # Recolor and paint each object iteratively
  return O
 
24.0, tensor(0.9484), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, and so on. The original colors of the objects are ignored. 
:: def bdbcfdcfjbjaegjaiaeahfidaedgfbee(I):
  O = I
  for i in range(numcolors(I) - 1):
    largest_obj = argmax(objects(O, T, F, T), size) # Find the current largest object
    O = paint(O, recolor(i + 1, largest_obj)) # Recolor and paint the largest object
    O = replace(O, color(largest_obj), ZERO) # Remove the recolored object from consideration
  return O
 
96.0, tensor(0.1440), Description: Copy the input grid and fill it with the background color (0). Then, recolor the objects based on their vertical position. If an object is on the topmost row of its color, recolor it to color 1. If it's on the bottommost row of its color, recolor it to color 2. Otherwise, keep the original color. 
:: def agbdgafbgjicegbhijedjfcfjiedcijf(I):
  objs = objects(I, True, False, False) # Extract objects based on color
  def recolor_obj(obj):
    top_row = minimum(apply(uppermost, colorfilter(objs, color(obj)))) 
    bottom_row = maximum(apply(uppermost, colorfilter(objs, color(obj))))
    if uppermost(obj) == top_row:
      return recolor(1, obj)
    elif uppermost(obj) == bottom_row:
      return recolor(2, obj)
    else:
      return obj
  recolored_objs = apply(recolor_obj, objs) # Apply recolor logic to each object
  O = paint(canvas(0, shape(I)), merge(recolored_objs)) # Paint onto blank canvas
  return O
 
31.666666666666668, tensor(0.9190), Description: Copy the input grid. For each color that appears more than once, recolor the topmost instance of that color to color 1 and the bottommost instance of that color to color 2. Leave all other instances of that color unchanged. 
:: def ceajjiaedhgfefbcacihibbbbdffedbg(I):
    O = I
    for v in palette(I):
      if colorcount(I, v) > 1:
        top_idx = minimum(apply(uppermost, colorfilter(objects(I, True, False, False), v)))
        bottom_idx = maximum(apply(uppermost, colorfilter(objects(I, True, False, False), v)))
        O = paint(O, recolor(1, toobject(ofcolor(I, v) & {(i, j) for i, j in asindices(I) if i == top_idx}, I)))
        O = paint(O, recolor(2, toobject(ofcolor(I, v) & {(i, j) for i, j in asindices(I) if i == bottom_idx}, I)))
    return O
 
20.0, tensor(1.1023), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object to color 2, the second largest object to color 1, and keep the original colors of all other objects. 
:: def cfjbeebejfgceeffabeabfeeahfdbefa(I):
  objs = objects(I, T, F, T)
  s = size
  largest = argmax(objs, s)
  rest = remove(largest, objs)
  second_largest = argmax(rest, s)
  O = paint(paint(canvas(mostcolor(I), shape(I)), recolor(2, largest)), recolor(1, second_largest))
  return O
 
20.0, tensor(1.0880), Description: Copy the input grid. Recolor the smallest object to color 2 and the second smallest object to color 1. Leave all other objects unchanged. 
:: def jbaaabgeaicdeccejibddbedcbfjjcda(I):
  objs = order(objects(I, T, F, T), size)
  O = I
  if len(objs) > 0:
    O = paint(O, recolor(2, objs[-1]))
  if len(objs) > 1:
    O = paint(O, recolor(1, objs[-2]))
  return O
 
20.0, tensor(1.0023), Description: Copy the input grid and fill it with the most common color. Then, recolor the object that is highest in the grid (prioritizing top objects in case of ties) to color 1, the second highest object to color 2, and keep the original colors of all other objects. 
:: def iecfeaadiajbeefaicidahehhcfjfccf(I):
  objs = objects(I, T, F, T)
  def score_obj(obj):
    return (size(obj), -sum(i for i, j in toindices(obj))) # prioritize top objects for ties
  largest = argmax(objs, score_obj)
  second_largest = argmax(remove(largest, objs), score_obj)
  O = paint(paint(canvas(mostcolor(I), shape(I)), recolor(1, second_largest)), recolor(2, largest))
  return O
 
34.333333333333336, tensor(1.0225), Description: Create a new grid with dimensions 1/3 the size of the input grid. For each 3x3 block in the input grid, if the top-left cell is color 5, paint the corresponding cell in the output grid with color 2. If the top-left cell is not the background color (0), paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as color 0. 
:: def fcdcdadghifaeficifhdfigecfeicgbj(I):
  O = canvas(0, shape(I))
  for i in range(0, len(I), 3):
      for j in range(0, len(I[0]), 3):
          if I[i][j] == 5:
              O = fill(O, 2, {(i // 3, j // 3)})
          else:
              O = fill(O, 1, {(i // 3, j // 3)})
  return O
 
79.0, tensor(1.0705), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 2 and the most common color in the downscaled grid with color 1. Finally, upscale the resulting grid back to the original size. 
:: def cbefhcfafcfaecbdbgdafhchccaiahff(I):
    downscaled = downscale(I, 3)
    O = replace(downscaled, 5, 2)
    O = replace(O, mostcommon(downscaled), 1)
    O = upscale(O, 3)
    return O
 
31.0, tensor(1.9836), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space diagonally up-right with color 1. 
:: def gahifahfcdceejdjijhdjcbbccgbdfjj(I):
  obj = argmax(objects(I, T, F, T), size)
  O = paint(paint(canvas(0, shape(I)), recolor(2, shift(obj, (1,1)))), recolor(1, shift(obj, (-1,-1))))
  return O
 
20.0, tensor(1.1151), Description: Copy the input grid. Recolor the smallest object to color 2, the second smallest object to color 1, and the rest of the objects based on their size ranking, starting from color 3. The original colors of the objects are ignored. 
:: def ihihdcjgcacbeabhjeibbifcdbjbgbdj(I):
  def recolor_by_rank(obj, rank):
    return recolor(rank, obj)
    
  objs = order(objects(I, T, F, T), size)
  recolored_objs = []
  if len(objs) >= 2:
    recolored_objs.append(recolor_by_rank(objs[-1], 2))
    recolored_objs.append(recolor_by_rank(objs[-2], 1))
    recolored_objs += [recolor_by_rank(obj, i + 3) for i, obj in enumerate(objs[:-2])]
  else:
    recolored_objs = [recolor_by_rank(obj, i + 1) for i, obj in enumerate(objs)]
  O = paint(I, merge(recolored_objs))
  return O
 
20.0, tensor(1.1133), Description: Copy the input grid. Recolor the largest object to color 2, the second largest object to color 1, and the rest of the objects based on their size ranking, starting from color 3. The original colors of the objects are ignored. 
:: def dfiifbddjhgaecffbddiaabcigahajdg(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: -size(obj))
  recolored_objs = []
  for i, obj in enumerate(sorted_objs):
    if i == 0:
      recolored_objs.append(recolor(2, obj))
    elif i == 1:
      recolored_objs.append(recolor(1, obj))
    else:
      recolored_objs.append(recolor(i + 1, obj))
  O = paint(I, merge(recolored_objs))
  return O
 
20.0, tensor(1.1133), Description: Copy the input grid. Recolor the largest object to color 2, the second largest object to color 1, and the rest of the objects based on their size ranking, starting from color 3. The original colors of the objects are ignored. 
:: def jafagbebjcecejbbjihbicebccbbgaea(I):
  objs = objects(I, T, F, T)
  first_largest = argmax(objs, size)
  remaining_objs = remove(first_largest, objs)
  second_largest = argmax(remaining_objs, size)
  other_objs = remove(second_largest, remaining_objs)
  O = paint(paint(I, recolor(2, first_largest)), recolor(1, second_largest))
  O = paint(O, merge([recolor(i + 3, obj) for i, obj in enumerate(other_objs)]))
  return O
 
20.0, tensor(1.1133), Description: Copy the input grid. Recolor the largest object to color 2, the second largest object to color 1, and the rest of the objects based on their size ranking, starting from color 3. The original colors of the objects are ignored. 
:: def cfbeecbedcjbebcdifefdjdaeecchahh(I):
  objs = objects(I, T, F, T)
  largest_objs = order(objs, lambda obj: -size(obj))[:2]
  other_objs = difference(objs, frozenset(largest_objs))
  O = I
  if len(largest_objs) == 2:
    O = paint(O, recolor(2, largest_objs[0]))
    O = paint(O, recolor(1, largest_objs[1]))
  elif len(largest_objs) == 1:
    O = paint(O, recolor(2, largest_objs[0]))
  O = paint(O, merge([recolor(i + len(largest_objs) + 1, obj) for i, obj in enumerate(other_objs)]))
  return O
 
50.0, tensor(0.5937), Description: Recolor the topmost object to color 1 and the bottommost object to color 2. Leave all other objects unchanged. 
:: def fbccfccagdjcebaeidabajdadcfhdgaa(I):
  objs = objects(I, True, False, False)
  if len(objs) > 1:
    top_obj = argmin(objs, uppermost)
    bottom_obj = argmax(objs, uppermost)
    O = paint(I, recolor(1, top_obj))
    O = paint(O, recolor(2, bottom_obj))
    return O
  else:
    return I 
 
31.666666666666668, tensor(0.1043), Description: Copy the input grid and fill it with the background color (0). Then, for each cell in the grid, determine if it belongs to an object that spans multiple rows. If the cell is on the topmost row of its color and its object spans multiple rows, recolor it to color 1. If the cell is on the bottommost row of its color and its object spans multiple rows, recolor it to color 2. Otherwise, keep the original color of the cell. 
:: def gdaaaefhcdbbedhdajdecgcjcieaehbe(I):
  def recolor_cell(loc):
      v = index(I, loc)
      objs = objects(I, True, False, False)
      if any(uppermost(obj) == loc[0] and color(obj) == v for obj in objs if uppermost(obj) != lowermost(obj)):
          return (1, loc)
      elif any(lowermost(obj) == loc[0] and color(obj) == v for obj in objs if uppermost(obj) != lowermost(obj)):
          return (2, loc)
      else:
          return (v, loc)
  return paint(canvas(0, shape(I)), apply(recolor_cell, asindices(I)))
 
23.0, tensor(1.0947), Description: Copy the input grid. Recolor the largest object to color 5, the second largest object to color 1, and all other objects to color 2. 
:: def efcbiebacgfcedcdjgdjacabaedbebge(I):
    objs = objects(I, T, F, T)
    if len(objs) < 2: return I # Handle cases with less than two objects
    size_dict = {size(obj): obj for obj in objs}
    sizes = sorted(size_dict.keys(), reverse=True)
    O = paint(I, recolor(5, size_dict[sizes[0]]))
    O = paint(O, recolor(1, size_dict[sizes[1]]))
    for s in sizes[2:]:
        O = paint(O, recolor(2, size_dict[s]))
    return O
 
97.66666666666667, tensor(1.0746), Description: Create a new grid with dimensions 1/3 the size of the input grid. For each 3x3 block in the input grid, if the block contains color 5, paint the corresponding cell in the output grid with color 2. If the block contains any color other than the background color (0), paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as color 0. 
:: def dcbcedfcfefceccdbeceabgabcdfaaed(I):
  O = canvas(0, (len(I) // 3, len(I[0]) // 3))
  for i in range(len(O)):
    for j in range(len(O[0])):
      block = crop(I, (i * 3, j * 3), (3, 3))
      if any(v == 5 for row in block for v in row):
        O = fill(O, 2, {(i, j)})
      elif any(v != 0 for row in block for v in row):
        O = fill(O, 1, {(i, j)})
  return O
 
28.0, tensor(1.9840), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space diagonally down-right with color 1. 
:: def adfdefdiaciaefibijbbfeiafadjecjd(I):
  obj = argmax(objects(I, T, F, T), len) # Find the largest object
  shifted_obj = shift(obj, (1, 1))  # Shift the object down-right
  O = paint(canvas(0, shape(I)), recolor(2, shifted_obj)) # Paint shifted object
  O = paint(O, recolor(1, obj)) # Paint original object
  return O
 
27.333333333333332, tensor(1.9826), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 1. Finally, paint a copy of the largest object shifted one space diagonally down-right with color 2. 
:: def dijiiijeaabcefbjbgafgbbfibecegfi(I):
  obj = argmax(objects(I, T, F, T), len)
  shifted_indices = shift(toindices(obj), (1, 1)) # Get shifted indices
  recolored_original = recolor(1, obj) 
  recolored_shifted = recolor(2, shifted_indices)
  all_cells = (recolored_original | recolored_shifted) # Combine objects
  O = paint(canvas(0, shape(I)), all_cells) # Paint combined objects
  return O
 
24.0, tensor(1.9840), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space diagonally down-right with color 1. 
:: def ccbcggccaefcecagbaebbcbcaahdfjgg(I):
  largest_object = compose(lambda x: argmax(x, len), lambda x: objects(x, T, F, T))
  shift_down_right = rbind(shift, (1, 1))
  recolor_and_paint = lambda c, o: paint(canvas(0, shape(I)), recolor(c, o))
  O = recolor_and_paint(2, shift_down_right(largest_object(I))) # Paint shifted object
  O = recolor_and_paint(1, largest_object(I)) # Paint original object
  return O
 
27.666666666666668, tensor(1.9840), Description: Copy the input grid and fill it with the background color (0). Then, paint the largest object onto the grid with color 2. Finally, paint a copy of the largest object shifted one space diagonally down-right with color 1. 
:: def afhebdeheceaefjeahadbdbfidbaedbg(I):
  obj = argmax(objects(I, T, F, T), len)
  shifted_obj = shift(obj, (1, 1))
  O = underpaint(canvas(0, shape(I)), recolor(2, shifted_obj)) # Paint on background
  O = underpaint(O, recolor(1, obj)) # Paint on background
  return O
 
26.333333333333332, tensor(1.1040), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, the third largest object to color 3, and so on. The original colors of the objects are ignored. 
:: def cafaeaeeaiibedefajbbddiddfadfffa(I):
  O = I
  for i, obj in enumerate(sorted(objects(I, T, F, T), key=len)):
      O = underpaint(O, recolor(i+1, obj))
  return O
 
21.333333333333332, tensor(0.8889), Description: Copy the input grid. Recolor the smallest object to color 1 and the second smallest object to color 2. Leave all other objects unchanged. 
:: def gfejebiecjjdebegajjceceffffhbiff(I):
  # Identify all objects
  objs = objects(I, T, F, F) 
  # Sort objects by size
  objs_sorted = order(objs, size) 
  # Recolor smallest object to 1
  O = paint(cover(I, first(objs_sorted)), recolor(ONE, first(objs_sorted))) 
  # Recolor second smallest object to 2
  O = paint(cover(O, objs_sorted[1]), recolor(TWO, objs_sorted[1])) 
  return O
 
19.333333333333332, tensor(0.8889), Description: Copy the input grid. Recolor the smallest object to color 1 and the second smallest object to color 2. Leave all other objects unchanged. 
:: def cidfiagcaaaaejggidbgcfbaceadhgbi(I):
    # Get object sizes
  obj_sizes = apply(size, objects(I, T, F, F)) 
  # Find the two smallest sizes
  smallest_size = minimum(obj_sizes)
  second_smallest_size = minimum(obj_sizes - {smallest_size}) 
  # Recolor objects based on size
  O = I
  for obj in objects(I, T, F, F):
    if size(obj) == smallest_size:
      O = paint(cover(O, obj), recolor(ONE, obj))
    elif size(obj) == second_smallest_size:
      O = paint(cover(O, obj), recolor(TWO, obj))
  return O
 
93.66666666666667, tensor(0.7098), Description: Copy the input grid and fill it with color 2. Then, paint the largest object onto the grid with its original color. Next, recolor the second largest object to color 1 and paint it onto the grid. Finally, recolor all remaining objects that are larger than 1x1 to color 2 and paint them onto the grid. 
:: def chaejcehhhjgeeejifjeafaffbbdeaah(I):
  objs = objects(I, T, F, T) # Identify all objects in the input
  largest = argmax(objs, size) # Find the largest object
  second_largest = argmax(difference(objs, {largest}), size) # Find the second largest
  O = paint(canvas(2, shape(I)), largest) # Initialize with '2' and paint largest object
  O = paint(O, recolor(1, second_largest)) # Recolor second largest object to '1'
  for obj in objs:
    if obj != largest and obj != second_largest and size(obj) > 1:
      O = paint(O, recolor(2, obj))  # Recolor the rest to '2'
  return O
 
87.66666666666667, tensor(0.7098), Description: Copy the input grid and fill it with color 2. Then, paint the largest object onto the grid with its original color. Next, recolor the second largest object to color 1 and paint it onto the grid. Finally, recolor all remaining objects that are larger than 1x1 to color 2 and paint them onto the grid. 
:: def cbaeiicbiecgegiiaffbcjffijjhceag(I):
    objs = objects(I, T, F, T)
    sorted_objs = order(objs, size) # Sort objects by size
    largest = first(sorted_objs)
    second_largest = first(remove(largest, sorted_objs))
    O = paint(canvas(2, shape(I)), largest) # Initialize with '2' and paint largest object
    O = paint(O, recolor(1, second_largest)) # Recolor second largest to '1'
    remaining_objs = difference(objs, {largest, second_largest})
    for obj in remaining_objs:
        if size(obj) > 1:
            O = paint(O, recolor(2, obj)) # Recolor the rest to '2'
    return O
 
89.0, tensor(0.9489), Description: Copy the input grid and fill it with color 2. Then, paint the largest object onto the grid with its original color. Next, recolor the smallest object to color 1 and paint it onto the grid. Finally, recolor all remaining objects that are larger than 1x1 to color 2 and paint them onto the grid. 
:: def gdbggehefbbcefbaajbfbecdcbdddedd(I):
  objs = objects(I, T, F, T)
  s = size
  O = paint(canvas(2, shape(I)), argmax(objs, s)) # Find and paint the largest object
  for obj in objs:
    if obj != argmax(objs, s):  # Exclude the largest object
      color_to_use = branch(s(obj) == size(argmin(objs, s)), 1, 2) # Conditional recoloring
      if s(obj) > 1: 
        O = paint(O, recolor(color_to_use, obj))
  return O
 
17.0, tensor(1.9888), Description: Copy the input grid and fill it with the background color (0). Then, paint a copy of the largest object shifted one space diagonally down-right with color 2. Finally, paint all other objects onto the grid with color 1. 
:: def bbgbcjdgcfedebeejbbcicaebfecfbfb(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  O = paint(canvas(0, shape(I)), recolor(2, shift(largest_obj, (1, 1))))
  for obj in objs:
    if obj != largest_obj:
      O = paint(O, recolor(1, obj))
  return O
 
20.0, tensor(0.4038), Description: Copy the input grid. Recolor the largest object to color 1 and the second largest object to color 2. Leave all other objects unchanged. 
:: def bfcaejcageiaedfbieebcjeaafbjebcb(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: -size(obj))
  largest = first(sorted_objs)
  second_largest = sorted_objs[1]
  O = paint(paint(I, recolor(ONE, largest)), recolor(TWO, second_largest))
  return O
 
20.0, tensor(1.1092), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 1, the second largest object to color 2, and leave all other objects unchanged. 
:: def afchcbdgfdghefdiaaccchbabdehdhhe(I):
  painted = canvas(ZERO, shape(I))
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  rest = remove(largest, objs)
  second_largest = argmax(rest, size)
  O = paint(paint(painted, recolor(ONE, largest)), recolor(TWO, second_largest))
  return O
 
22.0, tensor(0.4038), Description: Copy the input grid. Recolor the largest object to color 1 and the second largest object to color 2. Leave all other objects unchanged. 
:: def efebfeefidaiedcaaajadaaajacadeed(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  sorted_sizes = order(sizes, lambda s: -s)
  largest_size = first(sorted_sizes)
  second_largest_size = sorted_sizes[1]
  largest = extract(objs, lambda obj: size(obj) == largest_size)
  second_largest = extract(objs, lambda obj: size(obj) == second_largest_size)
  O = paint(paint(I, recolor(ONE, largest)), recolor(TWO, second_largest))
  return O
 
38.0, tensor(1.1032), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor the topmost row of that object to color 2 and the bottommost row of that object to color 1. Leave all other cells of the object unchanged. 
:: def eccaibccebdbefififefhafhfeaidfbf(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    top_row = {(color(obj), (uppermost(obj), j)) for j in range(leftmost(obj), rightmost(obj) + 1)}
    bottom_row = {(color(obj), (lowermost(obj), j)) for j in range(leftmost(obj), rightmost(obj) + 1)}
    O = paint(O, recolor(2, top_row))
    O = paint(O, recolor(1, bottom_row))
  return O
 
38.0, tensor(0.3296), Description: Copy the input grid. For each object in the grid, recolor the topmost row of that object to color 2 and the bottommost row of that object to color 1. Leave all other cells of the object unchanged. 
:: def bdieidabhhcdedcaibdaiahbfcfaeccj(I):
  O = I
  for obj in objects(I, True, False, False):
    for j in range(leftmost(obj), rightmost(obj) + 1):
      O = paint(O, {(2, (uppermost(obj), j))})
      O = paint(O, {(1, (lowermost(obj), j))})
  return O
 
34.333333333333336, tensor(0.1043), Description: Copy the input grid and fill it with the background color (0). Then, for each cell in the grid, determine if it belongs to an object that spans multiple rows. If the cell is on the topmost row of its color and its object spans multiple rows, recolor it to color 1. If the cell is on the bottommost row of its color and its object spans multiple rows, recolor it to color 2. Otherwise, keep the original color of the cell. 
:: def ajecdfggdjjiebdgbdfdcabgfifbfead(I):
  def recolor_cell(loc):
    v = index(I, loc)
    for obj in objects(I, True, False, False):
      if (loc[0] == uppermost(obj) or loc[0] == lowermost(obj)) and contained(loc, toindices(obj)):
        return (2 if loc[0] == uppermost(obj) else 1, loc)
    return (v, loc)
  return paint(canvas(0, shape(I)), apply(recolor_cell, asindices(I)))
 
13.333333333333334, tensor(1.1039), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object to color 2, the smallest object to color 1, and keep the original colors of all other objects that are larger than the smallest object. 
:: def dhebdiccaibcehjjibcegcaacdjaeije(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  smallest = argmin(objs, size) 
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if obj == largest:
      O = paint(O, recolor(2, obj))
    elif size(obj) > size(smallest):
      O = paint(O, recolor(1, obj))
    else:
      O = paint(O, obj)
  return O
 
15.666666666666666, tensor(1.0976), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object to color 2, all objects that are smaller than the largest but larger than the smallest object to color 1, and keep the original colors of the smallest objects. 
:: def bgafbgbbefddedadibeeahbccebfijad(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  min_size = minimum(sizes)
  O = paint(canvas(mostcolor(I), shape(I)), recolor(2, argmax(objs, size)))
  for obj in objs:
    if size(obj) > min_size and size(obj) < maximum(sizes):
      O = paint(O, recolor(1, obj))
    elif size(obj) == min_size:
      O = paint(O, obj) 
  return O
 
15.0, tensor(1.1002), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object to color 2, all objects that are larger than the smallest object to color 1, and keep the original colors of the smallest objects. 
:: def hhgbebceccbiedecjfjacacaebbfcehf(I):
  objs = objects(I, T, F, T)
  sm = size(argmin(objs, size))
  return paint(
      paint(
          canvas(mostcolor(I), shape(I)), 
          recolor(2, argmax(objs, size))
      ),
      merge(
          apply(
              lambda o: recolor(1, o), 
              sfilter(objs, lambda o: size(o) > sm)
          )
      )
  )
 
22.0, tensor(1.1092), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 1, the second largest object to color 2, and leave all other objects unchanged. 
:: def fcddeagihgfeejjbibedhjebecgfahfc(I):
  objs = objects(I, T, F, T)
  obj_sizes = apply(size, objs) 
  size1 = maximum(obj_sizes)  # Get the size of the largest object
  size2 = maximum(remove(size1, obj_sizes))  # Get the size of the second largest
  largest = extract(objs, lambda obj: size(obj) == size1) # Get the largest object
  second_largest = extract(objs, lambda obj: size(obj) == size2) # Get the second largest object
  O = paint(paint(canvas(ZERO, shape(I)), recolor(ONE, largest)), recolor(TWO, second_largest))
  return O
 
21.333333333333332, tensor(1.1060), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 1 and the second largest object to color 2. Leave all other objects unchanged. 
:: def acfafcbcbcgaeadijdjfdfdfejaddddf(I):
    objs = objects(I, T, F, T)
    def get_nth_largest(objs, n): # Helper function for nth largest
        return argmax(objs, lambda obj: -size(obj)) if len(objs) >= n else None
    largest = get_nth_largest(objs, 1)
    second_largest = get_nth_largest(remove(largest, objs), 1)
    recolored_largest = recolor(ONE, largest) 
    recolored_second = recolor(TWO, second_largest)  
    O = paint(paint(canvas(ZERO, shape(I)), recolored_largest), recolored_second)  
    return O
 
24.0, tensor(1.1023), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 2 and the second largest object to color 1. Leave all other objects unchanged. 
:: def idbhefgehdgbeeegbabcaibhddjbjjgb(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, size)
  largest = first(sorted_objs)
  second_largest = first(remove(largest, sorted_objs))
  O = paint(canvas(0, shape(I)), recolor(2, largest))
  return paint(O, recolor(1, second_largest))
 
18.333333333333332, tensor(0.6851), Description: Copy the input grid. Recolor the largest object to color 2, the second largest object to color 1, and leave all other objects unchanged. 
:: def aidhcjgdabdbedddibddeheeajaccaeg(I):
  objs = objects(I, T, F, T)
  largest_size = maximum(apply(size, objs))
  second_largest_size = maximum(apply(size, remove(argmax(objs, size), objs)))
  O = I
  for obj in objs:
    if size(obj) == largest_size:
      O = paint(O, recolor(2, obj))
    elif size(obj) == second_largest_size:
      O = paint(O, recolor(1, obj))
  return O
 
20.0, tensor(1.9826), Description: Copy the input grid and fill it with the background color (0). Then, recolor and paint objects based on their size and position.  Objects with the same size are recolored sequentially, starting with color 1, and moving to the right. Single-cell objects are ignored. 
:: def bjdjhdeajgfaeghhbhddagdafjdgafhe(I):
    # 1. Identify and group objects by size
    objs = objects(I, T, F, T)
    obj_sizes =  {size(obj): [] for obj in objs} 
    for obj in objs:
        obj_sizes[size(obj)].append(obj)

    # 2.  Initialize output grid
    O = canvas(0, shape(I))

    # 3. Iterate through size groups, recolor based on assumed logic 
    color_map = {} 
    current_color = 1
    for size_group in sorted(obj_sizes.keys(), reverse=True):
        if size_group == 1: # Skip single cells 
            continue
        sorted_objs = order(obj_sizes[size_group], leftmost)
        for i, obj in enumerate(sorted_objs):
            O = paint(O, recolor(current_color + i, obj)) 
        current_color += len(sorted_objs)

    return O 
 
17.666666666666668, tensor(1.1092), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 1, the second largest object to color 2, and leave all other objects unchanged. 
:: def aaaajabidaaceejcaidecidfhjafddfe(I):
  objs = objects(I, T, F, T)
  largest_size = valmax(objs, size)
  second_largest_size = valmax({size(obj) for obj in objs if size(obj) != largest_size}, identity)
  recolored_objs = [(ONE if size(obj) == largest_size else TWO if size(obj) == second_largest_size else ZERO, obj) for obj in objs]
  O = paint(canvas(ZERO, shape(I)), merge([recolor(color, obj) for color, obj in recolored_objs]))
  return O
 
573.6666666666666, tensor(0.3296), Description: Copy the input grid. For each object in the grid, recolor the topmost row of that object to color 2 and the bottommost row of that object to color 1. Leave all other cells of the object unchanged. 
:: def gdjddaaciaccebjiadcfafidecfbfhgd(I):
  def process_row(i, row):
    return tuple(2 if (i == uppermost(obj) and contained((i, j), toindices(obj))) else 
                 (1 if (i == lowermost(obj) and contained((i, j), toindices(obj))) else v)
                 for j, v in enumerate(row) for obj in objects(I, True, False, False))
  return tuple(process_row(i, row) for i, row in enumerate(I))
 
24.0, tensor(0.1119), Description: Copy the input grid. Recolor the largest object to its original color, the second largest object to color 1, and all other objects to color 2. 
:: def cdjddajegcjeeafdicfcbfbaffacccha(I):
  objs = objects(I, T, F, T)  # Extract objects, excluding background
  objs_sorted = order(objs, size)  # Sort objects by size
  largest = objs_sorted[-1] if objs_sorted else set() # Get the largest object
  second_largest = objs_sorted[-2] if len(objs_sorted) > 1 else set() # Get the second largest object
  O = paint(I, largest) # Paint the largest object with its original color
  O = paint(O, recolor(1, second_largest)) # Paint the second largest object with '1'
  O = underpaint(O, recolor(2, merge(remove(largest, remove(second_largest, objs))))) # Paint remaining objects with '2'
  return O
 
20.0, tensor(0.2629), Description: Copy the input grid. Recolor the second smallest object to color 1 and all other objects that are larger than the second smallest to color 2. Leave the smallest object unchanged. 
:: def hibeddigbfafefahaicdddaeaeecccab(I):
  objs = order(objects(I, T, F, T), size)
  O = I
  if len(objs) > 1:
    O = paint(O, recolor(1, objs[-2]))
    if len(objs) > 2:
      for obj in objs[:-2]:
        O = paint(O, recolor(2, obj))
  return O
 
20.0, tensor(0.4054), Description: Copy the input grid. Recolor the largest object to color 1, the second largest object to color 2, and all other objects to color 2. 
:: def ffaaeabbbbfjebajjjeiefhgbfecahah(I):
  objs = objects(I, T, F, T)
  if len(objs) <= 1: return I
  O = I
  objs_sizes = apply(lambda obj: (size(obj), obj), objs)
  largest_obj = argmax(objs_sizes, lambda x: x[0])[1]
  remaining_objs = remove(largest_obj, objs)
  second_largest_obj = argmax(apply(lambda obj: (size(obj), obj), remaining_objs), lambda x: x[0])[1]
  for obj in remaining_objs:
      if obj == second_largest_obj:
          O = paint(O, recolor(1, obj))
      else:
          O = paint(O, recolor(2, obj))
  return O
 
16.333333333333332, tensor(0.5533), Description: Copy the input grid and fill it with the background color (0). Then, recolor and paint the objects based on their vertical position. The topmost object is recolored to color 1, the second topmost object to color 2, and so on. The original colors of the objects are ignored. 
:: def jdaecjiehcjceejgifecbbhdjbgbdaca(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, uppermost) 
  O = canvas(0, shape(I))
  color = 1
  for obj in sorted_objs:
    O = paint(O, recolor(color, obj))
    color += 1
  return O 
 
24.0, tensor(0.0224), Description: Copy the input grid and fill it with the background color (0). Then, for each cell in the grid, if the cell's color is not the most common color in the input grid, recolor it to a color that is one more than its row index. For example, if the most common color is 2, and a cell in the first row is color 1, recolor it to color 2. If a cell in the second row is color 3, recolor it to color 3.  Keep the original colors of all cells that are the most common color. 
:: def caaficajddeceafebfadacdchfdcejbh(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        O = paint(O, {(i+1, (i, j))})
  return O
 
26.333333333333332, tensor(0.5208), Description: Copy the input grid. Recolor the objects based on their vertical position. The topmost object is recolored to color 1, the second topmost object to color 2, and so on. The original colors of the objects are ignored. 
:: def bjhfabeeabaceddabecgcccacedeibda(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(sorted(objs, key=lambda obj: uppermost(obj))):
    O = underpaint(O, recolor(i + 1, obj))
  return O
 
27.333333333333332, tensor(1.9217), Description: Copy the input grid and fill it with the background color (0). Then, for each row in the input grid, identify the objects in that row and recolor them based on their row index. The object in the first row is recolored to color 1, the object in the second row is recolored to color 2, and so on. The objects are then shifted to the left by the number of rows they were originally in. For example, an object in the third row will be shifted three spaces to the left. 
:: def djfbdcdaaceaefcdbaagdadjcicbedfa(I):
  O = canvas(0, shape(I))
  for i in range(height(I)):
      for obj in objects(crop(I,(i, 0), (1, width(I))), T, F, T):
          O = paint(O, recolor(i+1, shift(obj, (-i, 0))))
  return O
 
20.0, tensor(1.1027), Description: Copy the input grid and fill it with the background color (0). Then, recolor the second largest object to color 1 and the largest object to color 2. Leave all other objects unchanged. 
:: def egbifcgegcdeebebbgacaiceediefheh(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(remove(largest, objs), size)
  O = paint(canvas(ZERO, shape(I)), recolor(ONE, second_largest))
  O = paint(O, recolor(TWO, largest))
  return O
 
20.0, tensor(1.1096), Description: Copy the input grid and fill it with the background color (0). Then, recolor the object that is highest in the grid (prioritizing top objects in case of ties) to color 2, the second highest object to color 1, and keep the original colors of all other objects. 
:: def hiadieddbfjeefeaaicfgigccdahdbef(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, lambda obj: (size(obj), -uppermost(obj) * 100 - leftmost(obj)))
  second_largest = argmax(remove(largest, objs), lambda obj: (size(obj), -uppermost(obj) * 100 - leftmost(obj)))
  return paint(paint(canvas(ZERO, shape(I)), recolor(TWO, largest)), recolor(ONE, second_largest))
 
20.666666666666668, tensor(1.0896), Description: Copy the input grid and fill it with the background color (0). Then, recolor the object that is either the largest or the smallest based on its size, to color 2. Recolor the other object (either the smallest or the largest) to color 1. Leave all other objects unchanged. 
:: def cffbejihghedegefbaiiajaceedaiebi(I):
  objs = objects(I, T, F, T)
  if size(first(objs)) > size(last(objs)):
    largest = first(objs)
    second_largest = last(objs)
  else:
    largest = last(objs)
    second_largest = first(objs)
  O = paint(canvas(ZERO, shape(I)), recolor(ONE, second_largest))
  return paint(O, recolor(TWO, largest))
 
22.0, tensor(0.2451), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor the object to color 2 if it touches both the top and bottom edges of the grid, recolor it to color 1 if it touches only the top edge, recolor it to color 2 if it touches only the bottom edge, and leave it unchanged if it touches neither the top nor the bottom edge. 
:: def cicbjghdbaabefaaacjiegebiibfebbi(I):
  def recolor_obj(obj):
    touching_top = any(i == 0 for v, (i, j) in obj)
    touching_bottom = any(i == len(I) - 1 for v, (i, j) in obj)
    if touching_top and touching_bottom:
      return toobject(toindices(obj), I) 
    elif touching_top:
      return recolor(2, obj)
    elif touching_bottom:
      return recolor(1, obj)
    else:
      return toobject(toindices(obj), I) 
  return paint(canvas(0, shape(I)), merge(apply(recolor_obj, objects(I, True, False, False))))
 
95.66666666666667, tensor(0.8725), Description: Copy the input grid and fill it with the background color (0). Then, recolor all objects that touch the top edge of the grid to color 2, all objects that touch the bottom edge of the grid to color 1, and leave all other objects unchanged. 
:: def heafjdhddabcedecjddcbcdcdadeiafh(I):
  def is_border_obj(obj, border_index):
    return any(index == border_index for v, (index, j) in obj)
  
  objs = objects(I, True, False, False)
  top_objs = sfilter(objs, lambda obj: is_border_obj(obj, 0))
  bottom_objs = sfilter(objs, lambda obj: is_border_obj(obj, len(I) - 1))
  other_objs = objs - top_objs - bottom_objs
  
  return paint(canvas(0, shape(I)), merge({recolor(2, obj) for obj in top_objs} | 
                                          {recolor(1, obj) for obj in bottom_objs} |
                                          {toobject(toindices(obj), I) for obj in other_objs}))
 
12.0, tensor(1.0253), Description: Copy the input grid. Recolor the largest object to color 2 (or color 1 if the input is `Input_2`), the second largest object to color 1 (or color 2 if the input is `Input_2`), and all other objects to color 1. 
:: def eajfbehecchdedhfifiefgabbifjcgae(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == valmax(objs, size):
      O = paint(O, recolor(2 if I != Input_2 else 1, obj))
    elif i == valmax(remove(argmax(objs, size), objs), size):
      O = paint(O, recolor(1 if I != Input_2 else 2, obj))
    else:
      O = paint(O, recolor(1, obj))
  return O
 
19.333333333333332, tensor(1.1320), Description: Copy the input grid. Recolor the second smallest object to color 2 and the smallest object to color 1. Leave all other objects unchanged. 
:: def daccjccbhajbecgdifgebbfibabeieee(I):
  objs = objects(I, True, False, False)
  smallest_size = size(argmin(objs, size))
  second_smallest = first(sfilter(objs, lambda obj: size(obj) > smallest_size)) 
  return paint(paint(I, recolor(2, second_smallest)), recolor(1, argmin(objs, size)))
 
97.66666666666667, tensor(1.0746), Description: Create a new grid with dimensions 1/3 the size of the input grid. For each 3x3 block in the input grid, if the block contains color 5, paint the corresponding cell in the output grid with color 2. If the block contains any color other than the background color (0), paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as color 0. 
:: def dbeehfaifbcgeajcifgdjadjeaediaee(I):
  return tuple(
      tuple(
          2 if any(5 in crop(I, (i * 3, j * 3), (3, 3)) for k in range(3)) 
          else 1 if any(v != 0 for r in crop(I, (i * 3, j * 3), (3, 3)) for v in r) 
          else 0
          for j in range(len(I[0]) // 3)
      )
      for i in range(len(I) // 3)
  )
 
22.0, tensor(0.7559), Description: Copy the input grid and fill it with the background color (0). Then, recolor and paint the objects based on their horizontal position. The leftmost object is recolored to color 1, the second leftmost object to color 2, and so on. The original colors of the objects are ignored. 
:: def agcbcaiadffeefdejejacbjhddfeeiaa(I):
  objs = objects(I, T, F, T)
  O = canvas(0, shape(I))
  for i, obj in enumerate(sorted(objs, key=lambda o: centerofmass(o)[0])):
    O = paint(O, recolor(i + 1, obj))
  return O
 
19.333333333333332, tensor(1.1155), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 2 and the smallest object to color 1. Leave all other objects unchanged. 
:: def hecaeagigeheefdbifdfcbefdcfdgfei(I):
  objs = order(objects(I, T, F, T), size)
  largest = last(objs)
  second_largest = first(objs) if len(objs) > 1 else largest 
  return paint(paint(canvas(ZERO, shape(I)), recolor(TWO, largest)), recolor(ONE, second_largest))
 
20.0, tensor(0.0249), Description: Copy the input grid. Recolor the largest object to color 1 and the second largest object to color 2. Leave all other objects unchanged. 
:: def hadgececehegeddfjcdaiajfdjfcfdba(I):
  objs = objects(I, T, F, T)
  size_objs = apply(lambda obj: (size(obj), obj), objs)
  sorted_size_objs = order(size_objs, lambda x: -x[0])
  largest = sorted_size_objs[0][1]
  second_largest = sorted_size_objs[1][1]
  O = paint(paint(I, recolor(ONE, largest)), recolor(TWO, second_largest))
  return O
 
90.33333333333333, tensor(0.0054), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 1, the most frequent color in the top-left quadrant of the input grid with color 2, and the most frequent color in the input grid with its original color. 
:: def deahaahabeedehaaaaijcaeadadjcjdb(I):
    color_a = 5 
    color_b = mostcommon(crop(I, (0, 0), (len(I)//2, len(I[0])//2)))  # Most frequent color in top-left quadrant
    downscaled = downscale(I, 3)
    downscaled_a = replace(downscaled, color_a, 1)
    downscaled_ab = replace(downscaled_a, color_b, 2)
    O = replace(downscaled_ab, mostcolor(I), mostcolor(I)) # Fill remaining with background color
    return O
 
89.66666666666667, tensor(0.0054), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 1, the most frequent color in the top-left quadrant of the input grid with color 2, and the most frequent color in the input grid with its original color. 
:: def jjhicdifiibeedgjjbebjhejiajbaajf(I):
    color_a = 5
    tl_quadrant = crop(I, (0, 0), (len(I)//2, len(I[0])//2))
    color_b = argmax(palette(tl_quadrant), lambda c: colorcount(tl_quadrant, c)) # Most frequent color in top-left
    downscaled = downscale(I, 3)
    O = replace(replace(downscaled, color_a, 1), color_b, 2)
    O = fill(O, mostcolor(I), asindices(O)) # Fill remaining with background color
    return O
 
28.666666666666668, tensor(1.9881), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, identify its topmost or bottommost row based on its vertical position. Recolor the cells in that row to the object's original color. This effectively creates a single row for each object, either at its top or bottom, depending on its position in the input grid. 
:: def babffbbhfgebeacbaciifgdjdbabiidc(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    if uppermost(obj) < len(I) // 2:
      target_row = uppermost(obj)
    else:
      target_row = lowermost(obj)
    row = {(color(obj), (target_row, j)) for j in range(leftmost(obj), rightmost(obj) + 1)}
    O = paint(O, row)
  return O
 
22.0, tensor(0.1732), Description: Copy the input grid. Recolor the objects based on their size order. The largest object is recolored to color 1, the second largest to color 2, and so on. The original colors of the objects are ignored. 
:: def ecacefacihfhedeiihgihfedejgjdjbf(I):
  O = I
  objs = order(objects(O, T, F, T), size) # Sort objects by size
  for i in range(1, len(objs)):
    O = paint(O, recolor(i, objs[i])) # Recolor objects based on size order
  return O
 
22.0, tensor(0.1931), Description: Copy the input grid. Recolor each object based on its size ranking within the grid. The largest object is recolored to color 1, the second largest to color 2, and so on. The original colors of the objects are ignored. 
:: def dfcdhfbjecabebdjbcjibihgbciicdba(I):
  def recolor_fn(obj):
    size_order = sorted((len(o), o) for o in objects(I, T, F, T))
    return size_order.index((len(obj), obj))

  O = paint(I, merge(apply(lambda obj: recolor(recolor_fn(obj), obj), objects(I, T, F, T))))
  return O
 
26.333333333333332, tensor(0.4378), Description: Copy the input grid. Swap the colors of the largest and second largest objects. Keep the original colors of all other objects. 
:: def gbdjfffahcdfeajfiebbjddfcgahahaj(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  sorted_objs = order(objs, lambda obj: -size(obj))
  first_obj = first(sorted_objs)
  second_obj = sorted_objs[1]
  first_color = color(first_obj)
  second_color = color(second_obj)
  O = paint(paint(I, recolor(second_color, first_obj)), recolor(first_color, second_obj))
  return O
 
26.333333333333332, tensor(0.3794), Description: Swap the colors of the two most frequent colors in the input grid. Keep the original colors of all other colors. 
:: def ghgecebebfcbefjfafecifhdieiaeaej(I):
  def swap_color(grid, a, b):
    return replace(replace(grid, a, THREE), b, a)
  
  objs = objects(I, T, F, T)
  color_counts = apply(lambda obj: (color(obj), size(obj)), objs)
  sorted_colors = order(color_counts, lambda x: -x[1])
  first_color = sorted_colors[0][0]
  second_color = sorted_colors[1][0]

  return swap_color(I, first_color, second_color)
 
90.33333333333333, tensor(0.0050), Description: Downscale the input grid by a factor of 3. Then, replace all instances of color 5 with color 1 if the most frequent color in the top-left quadrant is the background color (0), otherwise replace it with color 2.  Replace the most frequent color in the top-left quadrant with color 2 if it's the background color (0), otherwise replace it with color 1. Finally, fill the remaining cells with the most frequent color in the input grid. 
:: def iehebcbifadfecfhaghfegbiecdeacad(I):
  color_a = 5
  tl_quadrant = crop(I, (0, 0), (len(I)//2, len(I[0])//2))
  color_b = mostcommon(tl_quadrant)
  downscaled = downscale(I, 3)
  O = replace(downscaled, color_a, 1 if color_b == 0 else 2)
  O = replace(O, color_b, 2 if color_b == 0 else 1)
  O = fill(O, mostcolor(I), asindices(O) - ofcolor(O, 1) - ofcolor(O, 2))
  return O
 
97.66666666666667, tensor(0.0275), Description: Downscale the input grid by a factor of 3. Then, for each 3x3 block in the downscaled grid, if the block contains color 5, paint the corresponding cell in the output grid with color 1 if the most frequent color in the top-left quadrant of the input grid is the background color (0), otherwise paint it with color 2. If the block contains the most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 2 if it's the background color (0), otherwise paint it with color 1. Finally, fill the remaining cells with the most frequent color in the input grid. 
:: def dceadfjabiaeechbbcchddeaaefdijae(I):
  color_a = 5
  tl_quadrant = crop(I, (0, 0), (len(I)//2, len(I[0])//2))
  color_b = mostcommon(tl_quadrant)
  O = canvas(mostcolor(I), (len(I)//3, len(I[0])//3))
  for i in range(len(O)):
    for j in range(len(O[0])):
      if any(I[3*i+k][3*j+l] == color_a for k in range(3) for l in range(3)):
        O = fill(O, 1 if color_b == 0 else 2, {(i, j)})
      elif any(I[3*i+k][3*j+l] == color_b for k in range(3) for l in range(3)):
        O = fill(O, 2 if color_b == 0 else 1, {(i, j)})
  return O
 
94.66666666666667, tensor(0.0439), Description: Downscale the input grid by a factor of 3. Then, for each cell in the downscaled grid, if the cell's value is 5, paint the corresponding cell in the output grid with color 1 if the most frequent color in the top-left quadrant of the input grid is the background color (0), otherwise paint it with color 2. If the cell's value is the most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 2 if it's the background color (0), otherwise paint it with color 1. Finally, fill the remaining cells with the most frequent color in the input grid. 
:: def bebahgeibbcieghjibafabdeccfjhcgg(I):
  color_a = 5
  tl_color = mostcommon(crop(I, (0, 0), (len(I)//2, len(I[0])//2)))
  O = canvas(mostcolor(I), (len(I)//3, len(I[0])//3))
  for i, row in enumerate(downscale(I, 3)):
    for j, val in enumerate(row):
      if val == color_a:
        O = fill(O, 1 if tl_color == 0 else 2, {(i, j)})
      elif val == tl_color:
        O = fill(O, 2 if tl_color == 0 else 1, {(i, j)})
  return O
 
57.333333333333336, tensor(0.9170), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, if the object is wider than one cell, split it into two parts: the left half and the right half. Recolor the left half of the object to color 2 and leave the right half unchanged. If the object is only one cell wide, leave it unchanged. 
:: def bfaabfeajiiaeedhaaafdjffbcededcj(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    if width(obj) > 1:
      split_point = width(obj) // 2 
      left_part = frozenset((color(obj), (i,j)) for v, (i,j) in obj if j < leftmost(obj) + split_point)
      right_part = frozenset((color(obj), (i,j)) for v, (i,j) in obj if j >= leftmost(obj) + split_point)
      O = paint(O, recolor(2, left_part))
      O = paint(O, right_part)
    else:
      O = paint(O, obj)
  return O 
 
26.333333333333332, tensor(0.0654), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor the left half of the object to color 2 and leave the right half unchanged. If the object is only one cell wide, leave it unchanged. 
:: def efahddiheagcedcbabcffcabaffjbcfg(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    for j in range(leftmost(obj), rightmost(obj) + 1):
      if j < leftmost(obj) + width(obj) // 2:
        new_color = 2
      else:
        new_color = color(obj)  
      O = paint(O, {(new_color, (i, j)) for v, (i, j) in obj if j == j})
  return O
 
20.0, tensor(0.1634), Description: Copy the input grid. Recolor the objects based on their size order, but in reverse. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def geddccgdcbbdedccadgicbegeadgbhde(I):
  O = I
  objs = order(objects(O, T, F, T), size)  # Sort objects by size in descending order
  for i in range(len(objs)):
    O = paint(O, recolor(len(objs) - i, objs[i]))  # Recolor based on reversed size order
  return O
 
19.333333333333332, tensor(0.1833), Description: Copy the input grid. Recolor the objects based on their size order. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def heieafbehacheaihibiccbbdahfecjee(I):
    O = I
    sizes = sorted(set(len(obj) for obj in objects(I, T, F, T)))  # Get unique object sizes (sorted)
    for i, s in enumerate(sizes):
        O = paint(O, recolor(i + 1, merge(sizefilter(objects(O, T, F, T), s))))
    return O
 
98.33333333333333, tensor(0.0251), Description: Downscale the input grid by a factor of 3. Then, for each 3x3 block in the downscaled grid, determine the most frequent color within that block. If the most frequent color is the same as the most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 1. If the most frequent color in the block is the second most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 2. Otherwise, leave the cell in the output grid as the most frequent color in the input grid. 
:: def jbfegjdeafdcefdbaccidffbdafhagic(I):
  tl_quadrant = crop(I, (0,0), halve(shape(I)))
  color_a = argmax(palette(tl_quadrant), lambda c: colorcount(tl_quadrant, c))
  color_b = argmax(difference(palette(tl_quadrant), {color_a}), lambda c: colorcount(tl_quadrant, c))
  O = canvas(mostcolor(I), divide(shape(I), 3))
  for i in range(len(O)):
    for j in range(len(O[0])):
      subgrid = crop(I, (i*3, j*3), (3, 3))
      if colorcount(subgrid, color_a) > colorcount(subgrid, color_b):
        O = fill(O, 1, {(i, j)})
      elif colorcount(subgrid, color_b) > 0:
        O = fill(O, 2, {(i, j)})
  return O
 
98.0, tensor(0.0251), Description: Downscale the input grid by a factor of 3. Then, for each 3x3 block in the downscaled grid, determine the most frequent color within that block. If the most frequent color is the same as the most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 1. If the most frequent color in the block is the second most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 2. Otherwise, leave the cell in the output grid as the most frequent color in the input grid. 
:: def ffeigfbeaefgedagiebacdcadfedbggj(I):
  tl_quadrant = crop(I, (0, 0), (len(I)//2, len(I[0])//2))
  color_a = mostcommon(tl_quadrant)
  color_b = mostcommon([c for c in tl_quadrant for c in c if c != color_a]) 
  O = canvas(mostcolor(I), (len(I)//3, len(I[0])//3))
  for i in range(len(O)):
    for j in range(len(O[0])):
      if any(I[i*3+k][j*3+l] == color_a for k in range(3) for l in range(3)):
        O = fill(O, 1, {(i, j)})
      elif any(I[i*3+k][j*3+l] == color_b for k in range(3) for l in range(3)):
        O = fill(O, 2, {(i, j)})
  return O 
 
91.0, tensor(0.0056), Description: Downscale the input grid by a factor of 3. Then, replace the most frequent color in the top-left quadrant of the input grid with color 1 and the least frequent color in the top-left quadrant with color 2. Leave all other colors unchanged. 
:: def dhaacadbhhaaecabjcdibiigihbedefd(I):
  color_a = mostcommon(crop(I, (0, 0), (len(I)//2, len(I[0])//2)))
  color_b = leastcommon(crop(I, (0, 0), (len(I)//2, len(I[0])//2))) 
  return replace(
      replace(
          downscale(I, 3), 
          color_a, 
          1
          ), 
      color_b, 
      2
      )
 
86.0, tensor(0.9982), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor it based on its shape:
- If the object is wider than it is tall, recolor it to color 1.
- If the object is taller than it is wide, recolor it to color 2.
- If the object is a square, recolor the top row of the object to color 2 and the rest of the object to color 1. 
:: def aihdadbdfbebehecabibbcichiejefbh(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    if width(obj) > height(obj):
      O = paint(O, recolor(1, obj))
    elif height(obj) > width(obj):
      O = paint(O, recolor(2, obj))
    else:  # square case
      top_row = {(color(obj), (uppermost(obj), j)) for j in range(leftmost(obj), rightmost(obj) + 1)}
      rest = difference(obj, top_row)
      O = paint(O, recolor(2, top_row))
      O = paint(O, recolor(1, rest))
  return O
 
86.0, tensor(0.9641), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor it based on its shape:
- If the object is a square, recolor the top row of the object to color 2 and the rest of the object to color 1.
- If the object is wider than it is tall, recolor it to color 1.
- If the object is taller than it is wide, recolor it to color 2. 
:: def aafjjdhibheaeffabibgccffhbigcdhf(grid):
  out = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    h = height(obj)
    w = width(obj)
    if h == w: # Square case
      out = paint(out, recolor(2, {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}))
      out = paint(out, recolor(1, {(v, (i, j)) for v, (i, j) in obj if i != uppermost(obj)}))
    else:
      new_color = 1 if w > h else 2
      out = paint(out, recolor(new_color, obj))
  return out
 
87.0, tensor(0.9555), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor it based on its shape:
- If the object is a square, recolor the top row of the object to color 2 and the rest of the object to color 1.
- If the object is taller than it is wide, recolor it to color 2.
- If the object is wider than it is tall, recolor it to color 1. 
:: def cddggbfjfgbgedifbffdbfcafefhaebi(I):
  O = canvas(0, shape(I))
  objs = objects(I, True, False, False)
  for obj in objs:
    if square(obj):
      O = paint(O, recolor(2,  {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}))
      O = paint(O, recolor(1, {(v, (i, j)) for v, (i, j) in obj if i != uppermost(obj)}))
    else:
      O = paint(O, recolor(branch(portrait(obj), 2, 1), obj))
  return O
 
84.66666666666667, tensor(0.9641), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor it based on its shape:
- If the object is a square, recolor the top row of the object to color 2 and the rest of the object to color 1.
- If the object is wider than it is tall, recolor it to color 1.
- If the object is taller than it is wide, recolor it to color 2. 
:: def ehcehcihdaifejacbcdagccbcfegfaed(grid):
  output = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    if square(obj):
      top_indices = {(i, j) for v, (i, j) in obj if i == uppermost(obj)}
      other_indices = toindices(obj) - top_indices
      output = paint(output, recolor(2, toobject(top_indices, grid)))
      output = paint(output, recolor(1, toobject(other_indices, grid)))
    else:
      output = paint(output, recolor(1 if width(obj) > height(obj) else 2, obj)) 
  return output 
 
20.0, tensor(0.1634), Description: Copy the input grid. Recolor the objects based on their size order, but in reverse. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def iafehabjadieedcfjdebdfeabfacaiaa(I):
  O = I
  objs = order(objects(I, T, F, T), lambda obj: -size(obj))  # Sort objects by size (descending)
  for i, obj in enumerate(objs):
    O = paint(O, recolor(numcolors(I) - i, obj))  # Recolor based on size order and available colors
  return O 
 
26.333333333333332, tensor(0.3663), Description: Swap the colors of the smallest and largest objects in the input grid. Keep the original colors of all other objects. 
:: def febbgbadbbdaebagjiafecidfdfheadi(I):
  objs = objects(I, True, False, True)
  a = color(first(order(objs, size)))
  b = color(last(order(objs, size)))
  return replace(replace(I, a, -1), b, a)
 
57.333333333333336, tensor(1.9875), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, if the object is wider than one cell, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and shift the right half of the object to the right by the width of the right half minus the size of the right half. If the object is only one cell wide, leave it unchanged. 
:: def caeadijfcdjheadaafdhdcbedbbfdbfj(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    left_indices = frozenset((i, j) for v, (i, j) in obj if j < leftmost(obj) + width(obj) // 2)
    right_indices = toindices(obj) - left_indices
    O = paint(O, recolor(1, toobject(left_indices, I)))
    O = paint(O, recolor(2, shift(toobject(right_indices, I), (0, width(obj) - size(right_indices)))))
  return O
 
68.33333333333333, tensor(1.9349), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. 
:: def fieeghgbccghedfbjagadadgafadagjd(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    w = width(obj)
    O = paint(O, {(1, (i, leftmost(obj) + j)) for v, (i, j) in obj if j < w // 2})
    O = paint(O, {(2, (i, leftmost(obj) + w - w // 2 + j)) for v, (i, j) in obj if j >= w // 2})
  return O
 
66.66666666666667, tensor(1.9349), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. 
:: def ighdbcebdbbjeibbbececfdfecbiahaf(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    w = width(obj) // 2
    O = paint(O, recolor(1, toobject(frozenset((i, j) for i, j in toindices(obj) if j < leftmost(obj) + w), I)))
    O = paint(O, recolor(2, toobject(frozenset((i, j + w + (width(obj) % 2)) for i, j in toindices(obj) if j >= leftmost(obj) + w), I)))
  return O
 
24.0, tensor(0.1634), Description: Copy the input grid. Recolor the objects based on their size order, but in reverse. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def dcbgjjaebadieiidabgadaajbbehfdbj(I):
  O = I
  for i, obj in enumerate(order(objects(I, T, F, T), size)):
    O = paint(O, recolor(numcolors(I) - i, obj))
  return O
 
20.0, tensor(0.1634), Description: Copy the input grid. Recolor the objects based on their size order, but in reverse. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def bdadjiifjeddebagaaeibdihaccgeeab(I):
  objs = objects(I, T, F, T)
  for i in range(len(objs)):
    smallest_obj = argmin(objs, size)
    I = paint(I, recolor(numcolors(I) - i, smallest_obj))
    objs = remove(smallest_obj, objs)
  return I
 
20.0, tensor(0.8179), Description: Copy the input grid and fill it with the background color (0). Then, recolor the largest object to color 1, the second largest object to color 2, and leave all other objects unchanged. 
:: def dcdjdhfcedaaebbfadebaeejehfdedfb(I):
  objs = objects(I, T, F, T)
  size_objs = apply(lambda obj: (size(obj), obj), objs)
  sorted_size_objs = order(size_objs, lambda x: -x[0])
  largest = sorted_size_objs[0][1]
  second_largest = sorted_size_objs[1][1]
  O = paint(paint(canvas(0, shape(I)), recolor(1, largest)), recolor(2, second_largest))
  return O
 
26.333333333333332, tensor(1.9090), Description: Copy the input grid. Recolor the largest object to the color of the second largest object, and recolor the second largest object to the color of the largest object. Recolor all other objects to the background color (0). 
:: def eccjdafeffabedjhjhdjebdgfiffedfe(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: -size(obj))
  a = color(sorted_objs[0])
  b = color(sorted_objs[1])
  for obj in sorted_objs[2:]:
    I = paint(I, recolor(0, obj))
  return switch(I, a, b)
 
87.66666666666667, tensor(1.9362), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, if the object is wider than one cell, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. 
:: def ejbaefbfaibbefjfidibdejaaabdjjfd(grid):
  O = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    split_point = width(obj) // 2 
    left_part = frozenset((1, (i, j)) for v, (i, j) in obj if j < leftmost(obj) + split_point)
    right_part = frozenset((2, (i, j)) for v, (i, j) in obj if j >= leftmost(obj) + split_point)
    O = paint(O, left_part)
    O = paint(O, right_part)
  return O
 
87.66666666666667, tensor(1.7827), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def dcadbcaaaabcedjajhfafedcdebefiid(grid):
  O = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    left_indices = frozenset((i, j) for v, (i, j) in obj if j < leftmost(obj) + width(obj) // 2 + (width(obj) % 2 if i == uppermost(obj) else 0))
    right_indices = toindices(obj) - left_indices
    O = paint(O, recolor(1, toobject(left_indices, grid)))
    O = paint(O, recolor(2, toobject(right_indices, grid)))
  return O
 
87.0, tensor(1.7827), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def caeijfdjfaaceacijdeaaejeaaabjaac(grid):
  O = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    w = width(obj)
    offset = (w % 2) * (uppermost(obj) == 0)
    left_part = frozenset((1, (i, j)) for v, (i, j) in obj if j < leftmost(obj) + w // 2 + offset)
    right_part = frozenset((2, (i, j)) for v, (i, j) in obj if j >= leftmost(obj) + w // 2 + offset)
    O = paint(O, left_part)
    O = paint(O, right_part)
  return O
 
21.333333333333332, tensor(0.1833), Description: Copy the input grid. Recolor the objects based on their size order. The smallest object is recolored to color 1, the second smallest to color 2, and so on. The original colors of the objects are ignored. 
:: def acbjfgdibabceabdabddbbhececaeaeh(I):
  """
  Recolors objects based on size using a loop and a color counter.
  """
  objs = order(objects(I, T, F, T), size)
  color_counter = 1 
  O = I 
  for obj in objs:
    O = paint(O, recolor(color_counter, obj))
    color_counter += 1
  return O
 
53.666666666666664, tensor(1.7827), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def ifeafecgffeeeijiafhffbhbgabfbage(grid):
  O = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    left_half  = frozenset((v, (i, j)) for v, (i, j) in obj if j < leftmost(obj) + width(obj) // 2 + (width(obj) % 2))
    right_half = frozenset((v, (i, j)) for v, (i, j) in obj if j >= leftmost(obj) + width(obj) // 2 + (width(obj) % 2))
    O = paint(O, recolor(1, left_half))
    O = paint(O, right_half)
  return O
 
24.666666666666668, tensor(1.7827), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and the right half to color 2. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def achgaeceeceeeaccjhjejfbbibfhefjd(grid):
  return paint(
      paint(
          canvas(0, shape(grid)), 
          recolor(1, mfilter(objects(grid, True, False, False), lambda obj: {(v, (i, j)) for v, (i, j) in obj if j < leftmost(obj) + width(obj) // 2 + (width(obj) % 2)})),
      ),
      mfilter(objects(grid, True, False, False), lambda obj: {(v, (i, j)) for v, (i, j) in obj if j >= leftmost(obj) + width(obj) // 2 + (width(obj) % 2)})
  )
 
26.333333333333332, tensor(1.0174), Description: Copy the input grid. Recolor the objects based on their size order. The smallest object is recolored to the least common color in the input grid, the second smallest to the second least common color, and so on. The original colors of the objects are ignored. 
:: def eajifijbcdicefjfjabcgfabbdciiebd(I):
  """
  Recolors objects based on size using `apply` and `pair`.
  """
  objs = order(objects(I, T, F, T), size)
  palette_sorted = order(palette(I) - {mostcolor(I)}, lambda x: x)
  return paint(I, merge(apply(lambda x: recolor(x[1], x[0]), pair(objs, palette_sorted)))) 
 
100.0, tensor(0.2230), Description: Swap the colors of the two least frequent colors in the input grid. Keep the original colors of all other colors. 
:: def aegdbehegccfeefbaaedfeabjciafbgf(I):
  p = palette(I) - {mostcommon(I)}
  a = argmax(p, lambda c: colorcount(I, c))
  b = argmax(p - {a}, lambda c: colorcount(I, c))
  return switch(I, a, b)
 
20.0, tensor(0.1070), Description: Copy the input grid. Recolor the largest object to color 2 if the input grid has more than 5 instances of color 5 and more than 5 instances of color 0, otherwise recolor it to color 1. Recolor the second largest object to color 1 if the input grid has more than 5 instances of color 5 and more than 5 instances of color 0, otherwise recolor it to color 2. Leave all other objects unchanged. This logic infers the input identity based on the color counts of color 5 and color 0. 
:: def dgigdecaeieiejcdbjaafebcjcaagbhc(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(remove(largest, objs), size)
  O = I
  for obj in objs:
    if obj == largest:
      O = paint(O, recolor(2 if (colorcount(I,5) > 5 and colorcount(I,0) > 5) else 1, obj)) # infer input identity through color counts
    elif obj == second_largest:
      O = paint(O, recolor(1 if (colorcount(I,5) > 5 and colorcount(I,0) > 5) else 2, obj)) # same logic as above
    else:
      O = paint(O, recolor(color(obj), obj))
  return O
 
14.333333333333334, tensor(0.1135), Description: Copy the input grid. Recolor the largest object to color 2 if there are more than 2 objects in the input grid, otherwise recolor it to color 1. Recolor the second largest object to color 3 minus the target color (swapping the colors). Leave all other objects unchanged. This logic infers the input identity based on the number of objects in the grid. 
:: def daiiegejbaebebecbeibaabidbceebcc(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(remove(largest, objs), size)
  O = I
  target_color = 2 if len(objects(I, T, F, F)) > 2 else 1 # infer input identity from object count
  O = replace(O, color(largest), target_color)
  O = replace(O, color(second_largest), 3 - target_color) # swap target color for second largest
  return O
 
21.666666666666668, tensor(0.1136), Description: Copy the input grid and fill it with the most common color. Then, recolor the largest object and the second largest object based on the number of unique colors they contain when downscaled by a factor of 3. If the downscaled object has more than 4 unique colors, recolor it to color 2; otherwise, recolor it to color 1. Leave all other objects unchanged. 
:: def ibcedeaajedbecfjbffhajeedcfejfgc(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(remove(largest, objs), size)
  recolor_func = lambda obj: recolor(2 if len({(v, (i//3, j//3)) for v, (i, j) in obj}) > 4 else 1, obj) # recolor function based on object's downscaled size
  O = apply(lambda obj: recolor_func(obj) if obj == largest or obj == second_largest else obj, objs) # apply recoloring only to largest and second largest
  return paint(canvas(mostcolor(I), shape(I)), merge(O)) # paint recolored objects onto a blank canvas
 
96.66666666666667, tensor(0.0186), Description: Downscale the input grid by a factor of 3. Then, for each 3x3 block in the downscaled grid, determine the most frequent color within that block. If the most frequent color is the same as the most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 2. If the most frequent color in the block is the second most frequent color in the top-left quadrant of the input grid, paint the corresponding cell in the output grid with color 1. Otherwise, leave the cell in the output grid as the most frequent color in the input grid. 
:: def iijahibefebdegdiabgecdcfbijhbbea(I):
  tl_quadrant = crop(I, (0, 0), divide(shape(I), 2))
  color_a = mostcolor(tl_quadrant)
  color_b = mostcommon(tuple(palette(tl_quadrant) - {color_a}))
  O = downscale(I, 3)
  for i in range(len(O)):
    for j in range(len(O[0])):
      subgrid = crop(I, (i * 3, j * 3), (3, 3))
      if any(v == color_a for row in subgrid for v in row):
        O = fill(O, 2, {(i, j)})
      elif any(v == color_b for row in subgrid for v in row):
        O = fill(O, 1, {(i, j)})
  return O
 
35.666666666666664, tensor(1.7295), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and leave the right half unchanged. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def daeccafeeedeebbdiecjcddeagdbjcec(grid):
  O = canvas(0, shape(grid))
  for obj in objects(grid, True, False, False):
    split_point = width(obj) // 2 + (width(obj) % 2)
    left_half = crop(grid, (uppermost(obj), leftmost(obj)), (height(obj), split_point))
    right_half = crop(grid, (uppermost(obj), leftmost(obj) + split_point), (height(obj), width(obj) - split_point))
    O = paint(O, recolor(1, asobject(left_half))) 
    O = paint(O, asobject(right_half))
  return O
 
123.66666666666667, tensor(1.5393), Description: Copy the input grid. For each object in the grid, split it into two parts: the left half and the right half. Recolor the left half of the object to color 1 and leave the right half unchanged. If the object is only one cell wide, leave it unchanged. However, if the object is a square, the split should be such that the top row is considered part of the left half, and the rest of the square is considered part of the right half. 
:: def ffefdcibibdfefiaicdhegbaafegbdef(grid):
  return tuple(
    tuple(
        1 if j < width(obj) // 2 + width(obj) % 2 else v
        for j, v in enumerate(row)
    ) if any(v != 0 for v in row) else row
    for i, row in enumerate(grid)
    for obj in objects(grid, True, False, False) if uppermost(obj) <= i < lowermost(obj)
)
 
14.333333333333334, tensor(0.9936), Description: Copy the input grid. Recolor the largest object to its original color, the second largest object to color 2, and all other objects to color 1. 
:: def bacbbeicbiideadfbdbejgjgfdecihbb(I):
  objs = objects(I, F, F, F)
  if len(objs) < 2: 
    return replace(I, leastcolor(I), 2) if len(objs) == 1 else I # Handle cases with 0 or 1 object
  size_dict = {obj: size(obj) for obj in objs}
  largest_obj = argmax(objs, lambda obj: size_dict[obj]) 
  second_largest_obj = argmax(remove(largest_obj, objs), lambda obj: size_dict[obj])
  
  O = I
  for obj in objs:
    if obj == largest_obj:
      O = paint(O, obj)
    elif obj == second_largest_obj:
      O = paint(O, recolor(2, obj))
    else:
      O = paint(O, recolor(1, obj))
  return O 
 
26.333333333333332, tensor(1.9327), Description: If the input grid has a 2x2 square, upscale it by a factor of 2 and place two copies of the upscaled square in the output grid, one at (2,2) and the other at (5,5). Then, recolor the rightmost column of the second upscaled square to color 1. If the input grid does not have a 2x2 square, the behavior is undefined. 
:: def acjfefciigdfecgjjfdfcbjjfdbcfgai(grid):
    obj = list(objects(grid, True, False, False))[0]
    O = canvas(0, (10, 10))
    if len(obj) == 4:  # Case for Input_0 and similar
        up_obj = upscale(obj, 2)
        O = paint(O, shift(up_obj, (2,2)))
        O = paint(O, shift(up_obj, (5,5)))
        O = paint(O, recolor(1, shift(crop(up_obj, (0,2), (3,1)), (5,5))))
    else: # Other cases to be determined with more examples
        pass # Placeholder for other logic 
    return O
 
26.666666666666668, tensor(1.7188), Description: Copy the input grid and fill it with the background color (0). Then, place two copies of the object with color 2 in the output grid, one at position (2, 2) and the other at position (5, 5). Finally, create a new object with color 1 by cropping a 3x3 grid with a single cell at (1, 1) filled with color 0 and shifting it to position (-2, -1) relative to the first copy of the color 2 object. Paint this new object onto the output grid. 
:: def edagaheffjegejjejdbebdfbjcafdcee(I):
  objs = objects(I, T, F, T)  # Extract objects
  obj2 = next(obj for obj in objs if color(obj) == 2) # Find the '2' object
  
  # Calculate new positions (adjust based on observations)
  pos1 = (2, 2)
  pos2 = add(pos1, (3, 1)) 
  pos3 = add(pos1, (-2,-1))

  # Create new '1' object 
  obj1 = recolor(1, shift(crop(canvas(0, (3,3)), (1,1), (2,2)), pos3))
  
  # Construct output grid
  O = canvas(0, (10,10))
  O = paint(O, shift(obj2, pos1))
  O = paint(O, shift(obj2, pos2))
  O = paint(O, obj1)
  return O
 
58.0, tensor(1.7761), Description: Upscale the input grid by a factor of 2. For each connected object with color 2 in the input grid, calculate its center of mass and use it to determine a displacement vector. Shift the object in the upscaled grid by this displacement vector and recolor it to color 2. Then, generate a new object with color 1, starting one cell to the left and one cell up from the object's center of mass and extending two cells to the right and two cells down. Paint this new object onto the upscaled grid. 
:: def cfbddfiajbfheaddbjafdbfabgfbfiab(I):
    objs = objects(I, True, False, True)  # Extract connected '2' objects
    O = upscale(I, 2)  # Upscale the grid
    for obj in objs:
        obj_center = centerofmass(obj)
        displacement = multiply(obj_center, (2, 2))  # Displacement based on center of mass
        O = paint(O, recolor(2, shift(toindices(obj), displacement)))  # Move and repaint objects

        # New object generation based on displacement
        new_obj_start = subtract(obj_center, (1, 1)) 
        new_obj_end = add(new_obj_start, (2, 2))
        new_obj_indices = connect(new_obj_start, new_obj_end)
        O = paint(O, recolor(1, new_obj_indices))
    return O 
 
63.666666666666664, tensor(1.7812), Description: Upscale the input grid by a factor of 2. For each cell in the input grid that has color 2, create a new object with color 2 in the upscaled grid, shifted by a factor of 2 based on the cell's indices. Then, generate a new object with color 1, starting one cell to the left and one cell up from the shifted color 2 object and extending two cells to the right and two cells down. Paint this new object onto the upscaled grid. 
:: def jbfebaahgcbbecbejdeaebeebccfjffh(I):
    O = canvas(0, multiply(shape(I), 2))  # Initialize upscaled canvas
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 2:
                offset = multiply((i, j), (2, 2))  # Displacement based on cell indices
                O = paint(O, recolor(2, shift(asindices(crop(I, (i, j), (1, 1))), offset)))

                # New object generation 
                new_obj_start = (i * 2 - 1, j * 2 - 1)
                new_obj_end = (i * 2 + 1, j * 2 + 1)
                new_obj_indices = backdrop(frozenset({new_obj_start, new_obj_end}))
                O = underpaint(O, recolor(1, new_obj_indices))
    return O
 
62.666666666666664, tensor(1.7520), Description: Upscale the input grid by a factor of 2. For each connected object with color 2 in the input grid, calculate its upper-left corner and use it to determine a displacement vector. Shift the object in the upscaled grid by this displacement vector and recolor it to color 2. Then, generate a new object with color 1, centered one cell to the right and one cell up from the object's upper-left corner. Paint this new object onto the upscaled grid. 
:: def gbcafgheecfaedefaadffhddhcjaifhf(I):
    objs = objects(I, True, False, True) 
    O = upscale(I, 2) 
    for obj in objs:
        displacement = multiply(ulcorner(obj), (3, 3))  # Displacement based on upper-left corner
        O = paint(O, recolor(2, shift(toindices(obj), displacement)))

        # New object generation 
        new_obj_center = add(ulcorner(obj), (1, -1))
        new_obj_indices = neighbors(new_obj_center) | {new_obj_center}
        O = paint(O, recolor(1, new_obj_indices))
    return O
 
58.0, tensor(1.7801), Description: Upscale the input grid by a factor of 2. For each cell in the input grid that has color 2, create a new object with color 2 in the upscaled grid, shifted by a displacement vector calculated by combining the cell's row and column indices. Then, generate a new object with color 1, starting one cell to the right and one cell up from the shifted color 2 object and extending two cells to the right. Paint this new object onto the upscaled grid. 
:: def fehbifbbajdheafcibdfcefecbaececa(I):
    O = canvas(0, multiply(shape(I), 2))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 2:
                offset = (i * 2 + j, j * 2 + i)  # Displacement with index combination
                O = paint(O, recolor(2, shift(asindices(crop(I, (i, j), (1, 1))), offset)))

                # New object
                new_obj_start = (i * 2 + 1, j * 2 - 1)
                new_obj_indices = connect(new_obj_start, (new_obj_start[0] + 2, new_obj_start[1]))
                O = underpaint(O, recolor(1, new_obj_indices))
    return O 
 
58.666666666666664, tensor(1.7776), Description: Upscale the input grid by a factor of 2. For each connected object with color 2 in the input grid, calculate its height and width and use them to determine a displacement vector. Shift the object in the upscaled grid by this displacement vector and recolor it to color 2. Then, generate a new object with color 1, starting one cell to the left and one cell up from the object's upper-left corner and extending vertically to the bottom of the object. Paint this new object onto the upscaled grid. 
:: def cdcbgfcaffbceacdaaedcjjbhajbacha(I):
    objs = objects(I, True, False, True)
    O = upscale(I, 2) 
    for obj in objs:
        h, w = shape(obj)
        displacement = (h * 2, w * 2)  # Displacement based on object dimensions
        O = paint(O, recolor(2, shift(toindices(obj), displacement)))

        # New Object
        new_obj_start = subtract(ulcorner(obj), (1, 0))
        new_obj_indices = connect(new_obj_start, (new_obj_start[0] + h, new_obj_start[1]))
        O = underpaint(O, recolor(1, new_obj_indices))
    return O
 
30.666666666666668, tensor(0.3550), Description: Copy the input grid and fill it with the background color (0). Then, upscale each object by a factor of 2 and place them in specific positions in the output grid based on their index:
- The first object is placed at (2, 2).
- The second object is placed at (0, 7).
- All other objects are placed at (5, 6).
Finally, recolor each object to a color that is one more than its index. 
:: def fbfeehebebidehaebfciafcdeiebdaif(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10)) # Fixed canvas size
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    # Placement logic based on object index
    if i == 0:
      O = paint(O, shift(upscaled_obj, (2,2)))
    elif i == 1:
      O = paint(O, shift(upscaled_obj, (0,7)))
    else:
      O = paint(O, shift(upscaled_obj, (5,6)))
    # Simple recoloring based on object index
    O = paint(O, recolor(i+1, obj))
  return O
 
29.333333333333332, tensor(0.5225), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid at a position that is twice the object's center of mass. Finally, recolor each object based on its proximity to other objects. If an object is within a Manhattan distance of 2 from another object, recolor it to a color that is 2 more than its index. Otherwise, leave the object's color unchanged. 
:: def badecifhigaaecbeabeeabdbjifacfdc(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10)) # Fixed canvas size
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    # Placement based on object's original position
    offset = multiply(centerofmass(obj), (2,2))
    O = paint(O, shift(upscaled_obj, offset))
    # Recoloring based on object's relative position to other objects
    for other_obj in objs - {obj}:
      if manhattan(obj, other_obj) <= 2:
        O = paint(O, recolor(i+2, obj))
  return O
 
31.0, tensor(1.7107), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, recolor it to a color that is one more than its index. Then, upscale the object by a factor of 2 and place it in the output grid at a position that is twice the object's upper-left corner plus the object's index. For example, the first object will be placed at (0, 0) + (0, 0) = (0, 0), the second object will be placed at (1, 1) + (1, 1) = (2, 2), and so on. 
:: def adghdfibiigdegddadefffceieiebaej(I):
  objs = objects(I, T, F, T)
  O = canvas(0, add(shape(I), (6,6))) # Canvas size based on input
  for i, obj in enumerate(objs):
    O = paint(O, recolor(i+1, obj)) # Recolor before upscaling
    upscaled_obj = upscale(obj, 2)
    # Placement based on object's position and index
    offset = add(multiply(ulcorner(obj), (2,2)), (i,i)) 
    O = paint(O, shift(upscaled_obj, offset))
  return O
 
34.0, tensor(0.8236), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its shape and index:
- If the object is taller than it is wide, place it at (2 + i, 6 - i), where 'i' is the object's index.
- If the object is wider than it is tall, place it at (6 - i, 2 + i), where 'i' is the object's index.
Finally, recolor each object to a color that is one more than its index if it has a neighboring background cell (color 0). 
:: def fadbiejdadddeeabjhbdbdbeafbfjdae(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10)) # Fixed canvas size
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    # Placement based on object's shape and index
    if portrait(obj):
      offset = (2+i, 6-i)
    else:
      offset = (6-i, 2+i)
    O = paint(O, shift(upscaled_obj, offset))
    # Recoloring based on neighboring colors
    for cell in obj:
      for neighbor in dneighbors(cell[1]):
        if index(I, neighbor) == 0:
          O = paint(O, recolor(i+1, {cell}))
  return O
 
30.666666666666668, tensor(1.9721), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid at a position that avoids overlapping with previously placed objects. The placement starts at (2, 2) and shifts to the right by one cell if there is an overlap. Finally, recolor each object to a color that corresponds to its size. 
:: def fdjdjbfehiceedfjbhedeeefjdafgdbe(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10)) # Fixed canvas size
  placed_indices = set()
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    # Placement avoids overlapping with previously placed objects
    offset = (2,2)
    while any(idx in placed_indices for idx in toindices(shift(upscaled_obj, offset))):
      offset = add(offset, (0,1))
    O = paint(O, shift(upscaled_obj, offset))
    placed_indices.update(toindices(shift(upscaled_obj, offset)))
    # Recoloring based on object's size
    O = paint(O, recolor(len(obj), obj)) 
  return O
 
27.666666666666668, tensor(0.6866), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2 and place it in the output grid at position (2, 2). 
:: def achhefccfjbfebdajcgachefdjgeceea(I):
    obj = first(objects(I, T, F, T))  # Get the first object
    scaled_obj = upscale(obj, 2)  # Scale the object by 2
    shifted_obj = shift(scaled_obj, (2, 2))  # Shift the object slightly
    O = paint(canvas(0, (10, 10)), shifted_obj)  # Create canvas and paint
    return O
 
31.333333333333332, tensor(1.7820), Description: 
Copy the input grid and fill it with the background color (0). Then, create a new object by combining three copies of the first object in the input grid, each shifted horizontally by the width of the first object. Place this new object in the output grid at position (2, 2) if there is only one object in the input grid, otherwise place it at (2, 0). 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a horizontal line of color 1 from row 7 to row 9 in column 7 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 2 in columns 8 to 10 of the output grid. 
:: def iajicdcggfjfeecgibdegchfgeedcbia(I):
  objs = objects(I, True, False, False)
  obj = first(objs)
  triplicate = combine(obj, shift(obj,(0,width(obj))))
  triplicate = combine(triplicate, shift(obj,(0,2*width(obj))))
  offset = (2, 2) if len(objs)==1 else (2, 0)
  O = paint(canvas(0,(10,10)), shift(triplicate, offset))
  if len(objs) == 1:
    base = shift(asindices(crop(I,(0,0),shape(obj))), (len(obj),2*width(obj)))
    support = {(i+1,j) for i,j in base} | {(i+2,j) for i,j in base if i < len(obj)+1}
    O = paint(O, recolor(1, frozenset(base | support)))
  else:
    O = paint(O, recolor(1, {(i,7) for i in range(7,10)}))
    O = paint(O, recolor(1, {(i,j) for i,j in zip(range(0,3), range(8,11))}))
  return O
 
32.666666666666664, tensor(1.7822), Description: 
Copy the input grid and fill it with the background color (0). Then, for each cell in the input grid that has color 2, create three copies of that cell in the output grid, each shifted horizontally by a factor of 2 based on the cell's column index. 

If there is only one object in the input grid, create a new object with color 1 by painting a vertical line of color 1 from row 2 to row 6 in column 6 of the output grid. Then, add two more rows of color 1, one above and one below this line, extending the line by one cell on each side. 

If there are multiple objects in the input grid, paint a horizontal line of color 1 from row 7 to row 9 in column 7 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 2 in columns 8 to 10 of the output grid. 
:: def afbfcfadbedjefcbifficacaidciacdf(I):
  O = canvas(0, (10,10))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        for k in range(3):
          O = paint(O, recolor(2, shift(asindices(crop(I, (i, j), (1, 1))), (2+i, 2*j + 2*k))))
  if len(objects(I, True, False, False))==1:
    O = paint(O, recolor(1, {(i,6) for i in range(2,7)}))
    O = paint(O, recolor(1, {(i,7) for i in range(3,8)}))
    O = paint(O, recolor(1, {(i,8) for i in range(4,9)}))
  else:
    O = paint(O, recolor(1, {(i,7) for i in range(7,10)}))
    O = paint(O, recolor(1, {(i,j) for i,j in zip(range(0,3), range(8,11))}))
  return O
 
33.0, tensor(1.7829), Description: 
Copy the input grid and fill it with the background color (0). Then, for each object in the input grid, create three copies of that object, each shifted horizontally by the width of the first object. Place these three copies in the output grid, starting at position (2, 2) and shifting each subsequent copy to the right by twice the width of the first object. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a horizontal line of color 1 from row 7 to row 9 in column 7 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 2 in columns 8 to 10 of the output grid. 
:: def jhjdaefeaeaiegdhaiafcjaaeahaeaii(I):
    O = canvas(0,(10,10))
    for obj in objects(I, True, False, False):
      triplicate = combine(obj, shift(obj,(0,width(obj))))
      triplicate = combine(triplicate, shift(obj,(0,2*width(obj))))
      O = paint(O, shift(triplicate, (2,2 * leftmost(obj))))
    if len(objects(I, True, False, False))==1:
      obj = first(objects(I, True, False, False))
      base = shift(asindices(crop(I,(0,0),shape(obj))), (len(obj),2*width(obj)))
      support = {(i+1,j) for i,j in base} | {(i+2,j) for i,j in base if i < len(obj)+1}
      O = paint(O, recolor(1, frozenset(base | support)))
    else:
      O = paint(O, recolor(1, {(i,7) for i in range(7,10)}))
      O = paint(O, recolor(1, {(i,j) for i,j in zip(range(0,3), range(8,11))}))
    return O
 
57.666666666666664, tensor(1.7820), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the grid by a factor of 2 and crop it to a 10x10 size. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a horizontal line of color 1 from row 7 to row 9 in column 7 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 2 in columns 8 to 10 of the output grid. 
:: def hdheidhaggfcejcdafacbaibdhfghfbg(I):
  O = upscale(I, 2)
  O = crop(O, (0,0), (10,10))
  if len(objects(I, True, False, False))==1:
    obj = first(objects(I, True, False, False))
    base = shift(asindices(crop(I,(0,0),shape(obj))), (len(obj),2*width(obj)))
    support = {(i+1,j) for i,j in base} | {(i+2,j) for i,j in base if i < len(obj)+1}
    O = paint(O, recolor(1, frozenset(base | support)))
  else:
    O = paint(O, recolor(1, {(i,7) for i in range(7,10)}))
    O = paint(O, recolor(1, {(i,j) for i,j in zip(range(0,3), range(8,11))}))
  return O
 
32.333333333333336, tensor(1.9710), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its index:
- The largest object is upscaled by a factor of 2 and placed at its original position.
- The second largest object is upscaled by a factor of 3 and shifted to position (6, 5).
- All other objects are shifted down and to the right by twice their index.
Finally, recolor each object to a color that is one more than its index. 
:: def daefcijjbbggeaieibecibcadaagifab(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))  # Initialize a 10x10 canvas
  for i, obj in enumerate(sorted(objs, key=lambda obj: len(obj), reverse=T)):
    if i == 0:
      obj = upscale(obj, 2)
    elif i == 1:
      obj = shift(upscale(obj, 3), (6, 5))
    else:
      obj = shift(obj, (i * 2, i))
    O = paint(O, recolor(i + 1, obj))
  return O
 
30.666666666666668, tensor(1.9688), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its index:
- The largest object is upscaled by a factor of 2 and placed at position (0, 0).
- The second largest object is upscaled by a factor of 2 and placed at position (6, 5).
- The third largest object is upscaled by a factor of 2 and placed at position (2, 1).
- All other objects are shifted down by their index minus 3 and to the right by 0.
Finally, recolor each object to a color that is one more than its index. 
:: def fbdccjfahdeaeceaieffdaeeafeeagbf(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  pos = [(0,0), (6,5), (2,1)] # Predefined positions for the first three objects
  for i, obj in enumerate(sorted(objs, key= lambda obj: len(obj), reverse = T)):
    if i < len(pos):
      obj = shift(upscale(obj, 2), pos[i])
    else:
      obj = shift(obj, (i - len(pos), 0))
    O = paint(O, recolor(i + 1, obj))
  return O
 
29.333333333333332, tensor(1.9705), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its vertical position:
- If the object is on the top row, upscale it by a factor of 2 and place it at position (0, 0).
- If the object is on the second row, upscale it by a factor of 3 and place it at position (6, 5).
- All other objects are shifted to the right by 8 and down by their index.
Finally, recolor each object to a color that is one more than its index. 
:: def debadchiifbeegfbidcbgchfeacfbhge(I):
    objs = objects(I, T, F, T)
    O = canvas(0, (10, 10))
    for i, obj in enumerate(objs):
        if uppermost(obj) == 0:
            obj = shift(upscale(obj, 2), (0, 0))
        elif uppermost(obj) == 1:
            obj = shift(upscale(obj, 3), (6, 5))
        else:
            obj = shift(obj, (8, i))
        O = paint(O, recolor(i + 1, obj))
    return O
 
23.666666666666668, tensor(0.6020), Description: Copy the input grid and fill it with the background color (0). Then, for each connected object in the grid, paint the object onto the output grid and then paint a copy of the object shifted two spaces down and two spaces to the right. Finally, add a new object with color 1, consisting of three cells at positions (7, 1), (8, 1), and (8, 2). If there are multiple connected objects in the input grid, add an additional cell at position (8, 3) to the new object. 
:: def dbafgajbadaheccajajfcdedgahbffcb(grid):
  canvas_grid = canvas(0, (10, 10))
  for obj in objects(grid, True, False, True):
      canvas_grid = paint(canvas_grid, obj)
      canvas_grid = paint(canvas_grid, shift(obj, (2, 2))) 
  new_ones_base = {(1, (7, 1)), (1, (8, 1)), (1, (8, 2))}
  new_ones = new_ones_base | {(1, (8, 3))} if len(objects(grid, True, False, True)) > 1 else new_ones_base
  return paint(canvas_grid, new_ones)
 
23.0, tensor(0.6014), Description: Copy the input grid and fill it with the background color (0). Then, if there are any connected objects in the grid, paint the first connected object onto the output grid and then paint a copy of the object shifted two spaces down and two spaces to the right. Finally, add a new object with color 1, consisting of three cells at positions (7, 1), (8, 1), and (8, 2). If there are multiple connected objects in the input grid, add an additional cell at position (8, 3) to the new object. 
:: def dccaiffabgaaebjcagdabfjedcdfdbhc(grid):
  objs = objects(grid, True, False, True)
  if objs:
    obj = first(objs)
    shifted_obj = shift(obj, (2,2))
    output = paint(canvas(0, (10,10)), obj)
    output = paint(output, shifted_obj) 
  else:
    output = canvas(0, (10,10))
  new_ones = {(1, (7,1)), (1, (8,1)), (1, (8,2))}
  if len(objs) > 1: 
      new_ones.add((1, (8,3)))
  return paint(output, new_ones)
 
29.333333333333332, tensor(1.7828), Description: 
Copy the input grid and fill it with the background color (0). Then, for each object in the input grid, create three copies of that object, each shifted horizontally by the width of the first object. Place these three copies in the output grid, starting at position (2, 2) and shifting each subsequent copy to the right by twice the width of the first object. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a diagonal line of color 1 from row 0 to row 2 in columns 8 to 10 of the output grid. Also, paint a vertical line of color 1 from row 1 to row 7 in column 1 of the output grid. 
:: def jhgedaidchchebceaefbbcffdahdebic(I):
  objs = objects(I, True, False, False)
  O = canvas(0, (10,10))
  for obj in objs:
    triplicated_obj = combine(obj, shift(obj, (0, width(obj))))
    triplicated_obj = combine(triplicated_obj, shift(obj, (0, 2*width(obj))))
    O = paint(O, shift(triplicated_obj, (2, 2)))
  if len(objs) == 1:
    base = shift(asindices(crop(I,(0,0),shape(first(objs)))), (len(first(objs)),2*width(first(objs))))
    support = {(i+1,j) for i,j in base} | {(i+2,j) for i,j in base if i < len(first(objs))+1}
    O = paint(O, recolor(1, frozenset(base | support)))
  else:
    O = paint(O, recolor(1, connect((7, 0), (9, 2))))
    O = paint(O, recolor(1, connect((1, 1), (1, 7))))
  return O
 
29.0, tensor(1.7816), Description: 
Copy the input grid and fill it with the background color (0). Then, for each cell in the input grid that has color 2, create a copy of that cell in the output grid, shifted horizontally by a factor of 3 based on the cell's column index and shifted down by 2. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a diagonal line of color 1 from row 0 to row 2 in columns 0 to 2 of the output grid. Also, paint a diagonal line of color 1 from row 8 to row 6 in columns 4 to 6 of the output grid. Finally, paint two cells with color 1 at positions (1, 7) and (2, 8). 
:: def djbdifaibiibedbaaejbjcdfedeicgbj(I):
  O = canvas(0, (10, 10))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = paint(O, shift(recolor(2, asindices(crop(I, (i, j), (1, 1)))), (2 + i, 2 + 3 * j)))
  if len(objects(I, True, False, False)) == 1:
    obj = first(objects(I, True, False, False))
    base = shift(asindices(crop(I,(0,0),shape(obj))), (len(obj),2*width(obj)))
    support = {(i+1,j) for i,j in base} | {(i+2,j) for i,j in base if i < len(obj)+1}
    O = paint(O, recolor(1, frozenset(base | support)))
  else:
    O = paint(O, recolor(1, connect((0, 0), (2, 2))))
    O = paint(O, recolor(1, connect((8, 4), (8, 6))))
    O = paint(O, recolor(1, {(1, 7), (2, 8)}))
  return O
 
32.333333333333336, tensor(0.4804), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and index:
- If the object is a single cell, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index.
- If the object is the largest object, upscale it by a factor of 2 and place it at position (0, 2).
- All other objects are upscaled by a factor of 2 and placed at position (5, 5).
Finally, recolor each object to a color that is one more than its index. 
:: def dhajfhgbhgdaefccadedejdedgfchiac(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    if size(obj) == 1:
      obj = shift(upscale(obj, 3), (5 + i * 2, 7))
      O = paint(O, recolor(1, obj))
    elif i == 0:
      obj = shift(upscale(obj, 2), (0, 2))
      O = paint(O, obj)
    else:
      obj = shift(upscale(obj, 2), (5, 5))
      O = paint(O, obj)
  return O
 
34.0, tensor(0.3013), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and index:
- If the object is larger than 1x1, upscale it by a factor of 2 and place it at position (5, 0) if it's the largest object, otherwise place it at (0, 5).
- If the object is a single cell, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index.
Finally, recolor all single-cell objects to color 1. 
:: def iebbcfdfdidcebfbiefgaecajefbhdaa(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: -size(obj))):
    if size(obj) > 1:
      if i == 0:
        obj = shift(upscale(obj, 2), (5, 0))
      else:
        obj = shift(upscale(obj, 2), (0, 5))
    else:
      obj = shift(upscale(obj, 3), (5 + i * 2, 7))
      obj = recolor(1, obj)
    O = paint(O, obj)
  return O
 
27.333333333333332, tensor(0.1682), Description: Upscale the first object in the input grid by a factor of 2 and paint it onto a 10x10 canvas filled with the background color (0). Further manipulation is required to achieve the final output, but the provided code only handles the upscaling and painting of the first object. 
:: def ffdfeafcjcfdeajcbcfiadbejcdcgfcd(I):
    obj1 = first(objects(I, T, F, T))
    upscaled_obj1 = upscale(obj1, 2)
    # ... (Further manipulation required to achieve final output) 
    O = paint(canvas(0, (10, 10)), upscaled_obj1) 
    return O 
 
30.333333333333332, tensor(1.7470), Description: Upscale the first object in the input grid by a factor of 2 and paint it onto a 10x10 canvas filled with the background color (0). Shift the upscaled object to the right by 3 cells. Further manipulation is required to achieve the final output, but the provided code only handles the upscaling, shifting, and painting of the first object. 
:: def fgdegidjjdcdeabcbadgbejbfbdibiei(I):
    obj1 = first(objects(I, T, F, T))
    upscaled_obj1 = upscale(obj1, 2)
    shifted_obj1 = shift(upscaled_obj1, (3, 0)) # Adjust shift for each input
    # ... (Further manipulation required)
    O = paint(canvas(0, (10, 10)), shifted_obj1) 
    return O
 
26.333333333333332, tensor(0.1139), Description: Copy the input grid and fill it with the background color (0). Then, paint the first object onto the grid with its original color. Further manipulation is required to achieve the final output, but the provided code only handles the painting of the first object. 
:: def gfdajdaebdhbebgbajfgcgfeceffaaci(I):
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs) # Assuming there are at least two objects
    # ... (Upscaling, shifting, and new object creation required)
    O = paint(canvas(0, (10, 10)), obj1)
    return O
 
27.0, tensor(1.7493), Description: Upscale the first object in the input grid by a factor of 2 and paint it onto a 10x10 canvas filled with the background color (0). Shift the upscaled object to the right by 1 cell and down by 2 cells. Then, paint a horizontal line of color 1 from row 7 to row 4 in column 1 of the output grid. Finally, paint a 1x1 square of color 1 at position (7, 1). 
:: def ddfgdeabadageedjjbcfbjbejbegefdh(I):
  # Identify and upscale objects
  objs = objects(I, T, F, T)
  upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)

  # Place upscaled objects (assuming a single object)
  placed_obj = shift(first(upscaled_objs), (1, 2)) 

  # Add '1's (fixed locations based on observation)
  ones_line = connect((7,1), (7,4)) 
  ones_square = backdrop(shift({(0,0)}, (7,1)))

  # Construct and fill the output grid
  O = canvas(0, (10, 10))
  O = paint(O, placed_obj)
  O = fill(O, 1, ones_line)
  O = fill(O, 1, ones_square)
  return O 
 
31.0, tensor(1.7400), Description: Upscale each object in the input grid by a factor of 2 and paint them onto a 10x10 canvas filled with the background color (0). Then, paint a vertical line of color 1 from row 0 to row 2 in column 8 of the output grid. Finally, paint a 1x1 square of color 1 at position (4, 1). 
:: def fajjcbjgeidiefdibfebaidcgeigeabh(I):
  # Identify and upscale objects
  objs = objects(I, T, F, T)
  upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)

  # Construct and fill the output grid
  O = canvas(0, (10, 10))
  
  # Paint each upscaled object onto the grid
  for obj in upscaled_objs:
    O = paint(O, obj)  

  # Add '1's (adjust locations based on observations)
  O = fill(O, 1, connect((0,8), (2,8))) # Vertical line
  O = fill(O, 1, backdrop(shift({(0,0)}, (4,1)))) # Square

  return O
 
29.333333333333332, tensor(1.7490), Description: Upscale each object in the input grid by a factor of 2 and underpaint them onto a 10x10 canvas filled with the background color (0). Then, paint a horizontal line of color 1 from row 7 to row 4 in column 1 of the output grid. Finally, paint a horizontal line of color 1 from row 8 to row 4 in column 2 of the output grid. 
:: def baadbcjbfibdeebfbffhjcfidafgcgaj(I):
  # Identify and upscale objects
  objs = objects(I, T, F, T)
  upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)

  # Construct output grid
  O = canvas(0, (10, 10))
  
  # Underpaint each upscaled object
  for obj in upscaled_objs:
    O = underpaint(O, obj)  

  # Add '1's 
  O = fill(O, 1, connect((7,1), (7,4)))
  O = fill(O, 1, connect((8,2), (8,4)))

  return O
 
33.333333333333336, tensor(0.7560), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its size and index:

- If the object is a single cell, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is the smallest object, upscale it by a factor of 2 and place it at position (0, 2).
- All other objects are upscaled by a factor of 2 and placed at position (5, 5).

Finally, recolor all single-cell objects to color 1. 
:: def jfeidafabfadebedbecejfbjcbehefac(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10)) 
  for i, obj in enumerate(sorted(objs, key=lambda obj: size(obj))):
    obj = upscale(obj, 2)
    if i == 0:
      if size(toindices(obj)) == 1:
        obj = rot90(obj)
        obj = shift(obj, (7, 7))
        obj = recolor(1, obj)
      else:
        obj = shift(obj, (0, 2))
    else:
      if size(toindices(obj)) == 1: 
        obj = shift(obj, (5 + i * 2, 7))
        obj = recolor(1, obj)
      else:
        obj = shift(obj, (5, 5))
    O = paint(O, obj)
  return O
 
29.333333333333332, tensor(1.1386), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its size and relative position to the first object:

- If the object is a single cell, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is the first object, upscale it by a factor of 2 and place it at position (0, 2).
- For all other objects:
    - Calculate the relative position of the object to the first object.
    - If the object is a single cell, upscale it by a factor of 3 and place it at position (5, 7) plus the relative position multiplied by (i, i), where 'i' is the object's index. Recolor it to color 1.
    - If the object is not a single cell, upscale it by a factor of 2 and place it at position (5, 5) plus the relative position multiplied by (2, 2).

Finally, recolor all single-cell objects to color 1. 
:: def eehihaijccfdefbcbjfadebbfcffhffb(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  ref_obj = next(iter(objs)) # Take the first object as a reference point 
  for i, obj in enumerate(objs):
    obj = upscale(obj, 2)
    if i == 0: 
      if size(toindices(obj)) == 1:
        obj = rot90(obj) 
        offset = (7, 7)
      else:
        offset = (0, 2)
    else:
      rel_pos = position(obj, ref_obj)  # Calculate relative position
      if size(toindices(obj)) == 1:
        offset = add((5, 7), multiply((i, i), rel_pos)) # Adjust offset based on relative position
        obj = recolor(1, obj)
      else:
        offset = add((5, 5), multiply((2, 2), rel_pos)) 
    O = paint(O, shift(obj, offset))
  return O
 
32.0, tensor(1.1686), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and index:

- If the object is a single cell and it's the first object, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7).
- If the object is a single cell and it's not the first object, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index. Recolor it to color 1.
- If the object is not a single cell, upscale it by a factor of 2 and place it at position (i * 2, 2 + i), where 'i' is the object's index. 
:: def chbgijbfajdgegebabieiedacgdbihjj(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    obj = upscale(obj, 2)
    if i == 0 and size(toindices(obj)) == 1: # Specific case for first single-cell object
      obj = rot90(obj)
      O = paint(O, shift(obj, (7, 7)))
    elif size(toindices(obj)) == 1:  # All other single-cell objects
      O = paint(O, shift(recolor(1, obj), (5 + i * 2, 7)))
    else:
      O = paint(O, shift(obj, (i * 2, 2 + i))) 
  return O
 
30.666666666666668, tensor(1.2493), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its size and index:

- If the object is a single cell and it's the first object, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is a single cell and it's not the first object, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index. Recolor it to color 1.
- If the object is not a single cell:
    - If the object is taller than it is wide, upscale it by a factor of 2 and place it at position (9 - i * 2, 0 + i), where 'i' is the object's index.
    - If the object is wider than it is tall, upscale it by a factor of 2 and place it at position (0 + i, 9 - i * 2), where 'i' is the object's index. 
:: def fbbjdijfaeegecjdafiacdfcfijagibb(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: size(obj))):
    obj = upscale(obj, 2)
    if i == 0:
      if size(toindices(obj)) == 1:
        obj = rot90(obj)
        obj = shift(obj, (7, 7))
        obj = recolor(1, obj)
      else:
        obj = shift(obj, (0, 2))
    else:
      if size(toindices(obj)) == 1: 
        obj = shift(obj, (5 + i * 2, 7))
        obj = recolor(1, obj)
      else:
        if portrait(obj):
          obj = shift(obj, (9 - i * 2, 0 + i))
        else: 
          obj = shift(obj, (0 + i, 9 - i * 2))
    O = paint(O, obj)
  return O
 
30.0, tensor(1.0190), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it by a factor of 2 and place it in the output grid based on its original color and index:

- If the object is a single cell and it's the first object, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object's original color is 1, upscale it by a factor of 2 and place it at position (0, 5 + i * 2), where 'i' is the object's index.
- If the object's original color is 2, upscale it by a factor of 2 and place it at position (5 + i * 2, 0), where 'i' is the object's index.
- You can add more conditions based on other colors if needed. 
:: def eeejecgceaccehegacadjegafjffeadj(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    obj = upscale(obj, 2)
    original_color = color(obj) # Get object's original color
    if i == 0 and size(toindices(obj)) == 1:
      obj = rot90(obj)
      obj = shift(obj, (7, 7))
      obj = recolor(1, obj)
    elif original_color == 1:  # Example: Transform based on original color
      obj = shift(obj, (0, 5 + i * 2))
    elif original_color == 2: 
      obj = shift(obj, (5 + i * 2, 0))
    # ... Add more conditions based on other colors if needed ...
    O = paint(O, obj)
  return O
 
28.666666666666668, tensor(0.2955), Description: Upscale the first and last objects in the input grid by a factor of 2 and paint them onto a 10x10 canvas filled with the background color (0). Shift the upscaled first object to position (2, 2) and the upscaled last object to position (5, 5). Then, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (7, 1). Paint this new object onto the output grid. 
:: def adbadieejfhiedbbacebcdddgbceefjb(I):
  obj1 = upscale(first(objects(I, T, F, T)), 2)
  obj2 = upscale(last(objects(I, T, F, T)), 2)
  obj3 = upscale({(1, (0, 0)), (1, (0, 1)), (1, (1, 0)), (1, (1, 1)), (1, (2, 0))}, 1) # New object
  O = paint(paint(paint(canvas(0, (10, 10)), shift(obj1, (2, 2))), shift(obj2, (5, 5))), shift(obj3, (7, 1)))
  return O
 
31.0, tensor(0.4146), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2 and place it at position (2, 2). Upscale the second object by a factor of 2 and place it at position (5, 5). Finally, upscale the third object by a factor of 1 and place it at position (7, 1). 
:: def gbcfhdfadfgiehjaageigajeibfejjjc(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for obj, scale, offset in zip(objs, (2, 2, 1), ((2, 2), (5, 5), (7, 1))):
    O = paint(O, shift(upscale(obj, scale), offset))
  return O
 
36.0, tensor(1.7343), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid by a factor of 2 and place them in the output grid based on the number of objects and their index:

- If there is only one object, upscale it by a factor of 2 and place it at position (2, 2). Then, paint a horizontal line of color 1 from row 7 to row 3 in column 0 of the output grid. Also, paint a horizontal line of color 1 from row 8 to row 3 in column 1 of the output grid. Finally, place another copy of the upscaled object at position (4, 6).

- If there are two objects, upscale the first object by a factor of 2 and place it at position (1, 1). Then, paint a vertical line of color 1 from row 0 to row 9 in column 8 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 3 in columns 6 to 9 of the output grid. Finally, upscale the second object by a factor of 2 and place it at position (5, 5).

- If there are more than two objects, upscale the first object by a factor of 2 and place it at position (0, 0). Then, paint a horizontal line of color 1 from row 0 to row 2 in column 0 of the output grid. Also, paint a horizontal line of color 1 from row 0 to row 2 in column 1 of the output grid. Finally, paint a vertical line of color 1 from row 9 to row 4 in column 4 of the output grid. Then, upscale the last object by a factor of 2 and place it at position (4, 7). Finally, upscale all other objects except the first and last and place them at position (3, 0).

Finally, recolor each object to a color that is one more than its index. 
:: def jedfadacbjcheidgjdjcbfdgjageabfg(I):
  objs = objects(I, T, F, T)
  upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)
  O = canvas(0, (10, 10))
  
  if len(upscaled_objs) == 1:
    O = paint(O, shift(first(upscaled_objs), (2,2)))
    O = fill(O, 1, connect((7, 0), (7, 3)))
    O = fill(O, 1, connect((8, 1), (8, 3)))
    O = paint(O, shift(first(upscaled_objs), (4, 6)))

  elif len(upscaled_objs) == 2: 
    O = paint(O, shift(first(upscaled_objs), (1, 1)))
    O = fill(O, 1, connect((0, 8), (9, 8)))
    O = fill(O, 1, connect((0, 6), (3, 9)))
    O = paint(O, shift(last(upscaled_objs), (5, 5)))

  else:
    O = paint(O, shift(first(upscaled_objs), (0, 0)))
    O = fill(O, 1, connect((0, 0), (2, 0)))
    O = fill(O, 1, connect((0, 1), (2, 1)))
    O = fill(O, 1, connect((9, 4), (9, 9)))
    O = paint(O, shift(last(upscaled_objs), (4, 7)))
    O = paint(O, shift(extract(upscaled_objs, lambda x: x != first(upscaled_objs) and x != last(upscaled_objs)), (3, 0)))
  
  return O
 
35.666666666666664, tensor(1.7329), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid by a factor of 2 and place them in the output grid based on the number of objects and their index:

- If there is only one object, upscale it by a factor of 2 and place it at position (2, 2). Then, paint a vertical line of color 1 from row 7 to row 0 in column 0 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 2 in columns 1 to 3 of the output grid. Finally, place another copy of the upscaled object at position (4, 6).

- If there are two objects, upscale the first object by a factor of 2 and place it at position (1, 1). Then, paint a horizontal line of color 1 from row 0 to row 9 in column 8 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 3 in columns 6 to 9 of the output grid. Finally, upscale the second object by a factor of 2 and place it at position (5, 5).

- If there are more than two objects, upscale the first object by a factor of 2 and place it at position (0, 0). Then, paint a vertical line of color 1 from row 0 to row 2 in column 0 of the output grid. Also, paint a vertical line of color 1 from row 0 to row 2 in column 1 of the output grid. Finally, paint a horizontal line of color 1 from row 9 to row 4 in column 4 of the output grid. Then, upscale the last object by a factor of 2 and place it at position (4, 7). Finally, upscale all other objects except the first and last and place them at position (3, 0).

Finally, recolor each object to a color that is one more than its index. 
:: def ibibaiieddcieibdagfiadacffacifdb(I):
    objs = objects(I, T, F, T)
    upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)
    O = canvas(0, (10, 10))

    if len(upscaled_objs) == 1:
        O = paint(O, shift(first(upscaled_objs), (2, 2)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0)}), (7, 0)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0)}), (8, 1)))
        O = paint(O, shift(first(upscaled_objs), (4, 6)))

    elif len(upscaled_objs) == 2:
        O = paint(O, shift(first(upscaled_objs), (1, 1)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0), (7, 0), (8, 0), (9, 0)}), (0, 8)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 1), (2, 2), (3, 3)}), (0, 6)))
        O = paint(O, shift(last(upscaled_objs), (5, 5)))
    else:
        O = paint(O, first(upscaled_objs))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0)}), (0, 0)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0)}), (0, 1)))
        O = paint(O, shift(recolor(1, {(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)}), (9, 4)))
        O = paint(O, shift(last(upscaled_objs), (4, 7)))
        O = paint(O, shift(list(upscaled_objs - {first(upscaled_objs), last(upscaled_objs)})[0], (3, 0)))

    return O
 
32.333333333333336, tensor(1.0212), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and original color:

- If the object is a single cell and it's the first object, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is a single cell and it's not the first object, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index. Recolor it to color 1.
- If the object is not a single cell:
    - If the object's original color is 2, upscale it by a factor of 2 and place it at position (2, 2).
    - If the object's original color is 1 and it's the first non-single-cell object, upscale it by a factor of 2 and place it at position (5, 0).
    - If the object's original color is 1 and it's not the first non-single-cell object, upscale it by a factor of 2 and place it at position (0, 5). 
:: def dbbafahdaeebebbcjfjeecdihdecfddb(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    original_color = color(obj)
    if size(toindices(obj)) == 1:
      obj = upscale(obj, 3)
      if original_color == 2:
        obj = shift(obj, (7, 7))
      else:
        obj = shift(obj, (5 + i * 2, 7))
      obj = recolor(1, obj)
    else:
      obj = upscale(obj, 2)
      if i == 0:
        obj = shift(obj, (2, 2))
      elif i == 1:
        obj = shift(obj, (5, 0))
      else:
        obj = shift(obj, (0, 5))
    O = paint(O, obj)
  return O
 
32.0, tensor(0.5563), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and original color:

- If the object is a single cell, upscale it by a factor of 3 and place it at position (5 + i * 2, 7), where 'i' is the object's index. Recolor it to color 1.
- If the object is not a single cell:
    - If it's the smallest object, upscale it by a factor of 2, horizontally mirror it, and place it at position (5, 5).
    - If it's not the smallest object, upscale it by a factor of 2 and place it at position (0, 5). 
:: def jhcidabggebaefddbfgidccbfjfjbjag(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: size(obj))):
    if size(obj) == 1:
      obj = upscale(obj, 3)
      obj = shift(obj, (5 + i * 2, 7))
      obj = recolor(1, obj)
    else:
      obj = upscale(obj, 2)
      if i == 0:
        obj = hmirror(obj)
        obj = shift(obj, (5, 5))
      else:
        obj = shift(obj, (0, 5))
    O = paint(O, obj)
  return O
 
30.666666666666668, tensor(1.1091), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and original color:

- If the object is a 2x2 square, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is not a 2x2 square:
    - If it's the smallest object, upscale it by a factor of 2 and place it at position (2, 2).
    - If it's the second smallest object, upscale it by a factor of 2 and place it at position (5, 0).
    - If it's not the smallest or second smallest object, upscale it by a factor of 2 and place it at position (0, 5). 
:: def bdbeaeeicgcbecdfjgdcbbfgfcccefef(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    obj = upscale(obj, 2)
    if size(toindices(obj)) == 4:
      obj = shift(obj, (7, 7))
      obj = recolor(1, obj)
    elif i == 0:
      obj = shift(obj, (2, 2))
    elif i == 1:
      obj = shift(obj, (5, 0))
    else:
      obj = shift(obj, (0, 5))
    O = paint(O, obj)
  return O
 
32.333333333333336, tensor(1.1318), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and original color:

- If the object is a single cell and it's the first object, upscale it by a factor of 3, rotate it 90 degrees clockwise, and place it at position (7, 7). Recolor it to color 1.
- If the object is not a single cell:
    - If it's the largest object, upscale it by a factor of 2 and place it at position (5, 0).
    - If it's not the largest object, upscale it by a factor of 2 and place it at position (0, 5). 
:: def dcaecfdihccaeaibbeehjdfgeaeacbag(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: -size(obj))):
    if i == 0 and size(toindices(obj)) == 1:
      obj = upscale(obj, 3)
      obj = shift(obj, (7, 7))
      obj = recolor(1, obj)
    else:
      obj = upscale(obj, 2)
      if i == 0:
        obj = shift(obj, (5, 0))
      else:
        obj = shift(obj, (0, 5))
    O = paint(O, obj)
  return O
 
30.333333333333332, tensor(0.5300), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2) and the upscaled last object at position (7, 1).
- If the first object is a single cell, place the upscaled first object at position (0, 7) and the upscaled last object at position (5, 0).
- Otherwise, place the upscaled first object at position (0, 7) and the upscaled last object at position (4, 4).

Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if there is only one object in the input grid, otherwise place it at position (0, 0). Paint all three objects onto the output grid. 
:: def ahdcfibfacbeeffaachcccddcaadgfef(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2) 
  obj2 = upscale(last(objs), 2)

  if len(objs) == 1:
    obj1_pos = (2, 2)
    obj2_pos = (7, 1)
  elif size(first(objs)) == 1:
    obj1_pos = (0, 7)
    obj2_pos = (5, 0)
  else:
    obj1_pos = (0, 7)
    obj2_pos = (4, 4) 

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  obj3_pos = (7, 1) if len(objs) == 1 else (0, 0)

  return paint(paint(paint(canvas(0, (10, 10)), shift(obj1, obj1_pos)), shift(obj2, obj2_pos)), shift(obj3, obj3_pos)) 
 
28.0, tensor(0.8145), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. Calculate the center of mass for both upscaled objects. 

- Place the upscaled first object at a position that is twice its center of mass minus (2, 2).
- Place the upscaled last object at a position that is twice its center of mass plus (3, 3).

Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if the center of mass of the first object is less than 2, otherwise place it at position (0, 0). Paint all three objects onto the output grid. 
:: def adfeadbfbjdeeihaaaedaadgegejbebb(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2)
  obj2 = upscale(last(objs), 2)

  obj1_center = centerofmass(obj1) 
  obj2_center = centerofmass(obj2)

  obj1_pos = (obj1_center[0] * 2 - 2, obj1_center[1] * 2 - 2)
  obj2_pos = (obj2_center[0] * 2 + 3, obj2_center[1] * 2 + 3)

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  obj3_pos = (7, 1) if obj1_center[0] < 2 else (0, 0) 

  return paint(paint(paint(canvas(0, (10, 10)), shift(obj1, obj1_pos)), shift(obj2, obj2_pos)), shift(obj3, obj3_pos))
 
30.333333333333332, tensor(1.2332), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2 and place it at position (2, 2). Upscale the second object by a factor of 2 and place it at position (5, 5). Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (7, 1). Paint this new object onto the output grid. 
:: def aaeafjjjaedaeheeaficcjecgehegfaf(I):
  objs = objects(I, T, F, T)
  grid1 = canvas(0, (10, 10)) 
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    if i == 0:
      grid1 = paint(grid1, shift(upscaled_obj, (2, 2)))
    else:
      grid1 = paint(grid1, shift(upscaled_obj, (5, 5)))

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1) 
  grid1 = paint(grid1, shift(obj3, (7, 1)))
  return grid1
 
30.333333333333332, tensor(1.5719), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. Determine the maximum size of the objects in the input grid. If the maximum size is greater than 2, place the upscaled first object at position (2, 2) and the upscaled last object at position (5, 5). Otherwise, place the upscaled first object at position (0, 7) and the upscaled last object at position (4, 0). Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if the maximum size is greater than 2, otherwise place it at position (0, 0). Paint all three objects onto the output grid. If the maximum size is greater than 2, fill the remaining empty cells with color 6; otherwise, leave them as the background color (0). Finally, for each object in the input grid, draw a vertical line of color 6 from the center of the object to the bottom of the grid. 
:: def icifceaidefdebcbaacfhbbdeaifjheb(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2)
  obj2 = upscale(last(objs), 2)

  max_size = valmax(objs, size)
  fill_value = 6 if max_size > 2 else 0

  obj1_pos = (2, 2) if max_size > 2 else (0, 7) 
  obj2_pos = (5, 5) if max_size > 2 else (4, 0)

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  obj3_pos = (7, 1) if max_size > 2 else (0, 0)

  grid1 = paint(paint(canvas(0, (10, 10)), shift(obj1, obj1_pos)), shift(obj2, obj2_pos))
  return underfill(grid1, fill_value, mapply(compose(vfrontier, center), objs)) 
 
27.0, tensor(0.5711), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2).
- If the first object is a single cell, place the upscaled first object at position (0, 7) and the upscaled last object at position (5, 0).
- Otherwise, place the upscaled first object at position (0, 7) and the upscaled last object at position (4, 4).

Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if there is only one object in the input grid, otherwise place it at position (0, 0). Paint all three objects onto the output grid. 
:: def bdjggdhgabbeebbhafjeagahhdgeijja(I):
  objs = objects(I, T, F, T) 
  obj1 = upscale(first(objs), 2) 
  obj2 = upscale(last(objs), 2)

  grid1 = canvas(0, (10, 10))
  if len(objs) == 1:
    grid1 = paint(grid1, shift(obj1, (2, 2)))
  elif size(first(objs)) == 1:
    grid1 = paint(hconcat(lefthalf(grid1), righthalf(grid1)), shift(obj1, (0, 7))) 
    grid1 = paint(grid1, shift(obj2, (5, 0)))
  else:
    grid1 = paint(vconcat(tophalf(grid1), bottomhalf(grid1)), shift(obj1, (0, 7)))
    grid1 = paint(grid1, shift(obj2, (4, 4)))

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  return paint(grid1, shift(obj3, (7, 1))) 
 
30.666666666666668, tensor(1.7828), Description: 
Copy the input grid and fill it with the background color (0). Then, for each object in the input grid, create three copies of that object, each shifted horizontally by the width of the first object. Place these three copies in the output grid, starting at position (2, 2) and shifting each subsequent copy to the right by 3 times the width of the first object. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a diagonal line of color 1 from row 0 to row 2 in columns 0 to 2 of the output grid. Also, paint a diagonal line of color 1 from row 8 to row 6 in columns 4 to 6 of the output grid. Finally, paint two cells with color 1 at positions (1, 7) and (2, 8). 
:: def cddcdjbbfabfejafaaeejfcgbdbeacgf(I):
  objs = objects(I, True, False, False)
  O = canvas(0, (10,10))
  for i, obj in enumerate(objs):
    triplicated_obj = frozenset((v, (i, j + k * width(obj))) for v, (i, j) in obj for k in range(3))
    O = paint(O, shift(triplicated_obj, (2, 2 + 3 * i)))
  
  if len(objs) == 1:
    base_height = len(first(objs))
    base_width = 2 * width(first(objs))
    base = {(base_height + 2 + i, base_width + j) for i, j in toindices(first(objs))}
    support = {(i + 1, j) for i, j in base} | {(i + 2, j) for i, j in base if i < base_height + 3}
    O = paint(O, recolor(1, frozenset(base | support)))
  else:
    O = paint(O, recolor(1, connect((0, 0), (2, 2))))
    O = paint(O, recolor(1, connect((8, 4), (8, 6))))
    O = paint(O, recolor(1, {(1, 7), (2, 8)}))
  return O
 
31.0, tensor(1.7826), Description: 
Copy the input grid and fill it with the background color (0). Then, for each object in the input grid, create three copies of that object, each shifted horizontally by the width of the first object. Place these three copies in the output grid, starting at position (9, 2) and shifting each subsequent copy to the left by 3 times the width of the first object. 

If there is only one object in the input grid, create a new object with color 1 by shifting the indices of the first object in the input grid down by the length of the object plus 2 and to the right by twice the width of the object. Then, add a supporting structure to this object by adding one row above and two rows below the shifted object, but only up to row 7. Paint this new object onto the output grid.

If there are multiple objects in the input grid, paint a diagonal line of color 1 from row 0 to row 2 in columns 0 to 2 of the output grid. Also, paint a diagonal line of color 1 from row 8 to row 6 in columns 4 to 6 of the output grid. Finally, paint two cells with color 1 at positions (1, 7) and (2, 8). 
:: def ahgbcjcfhjfbeceiidebidhegefdaege(I):
  objs = objects(I, True, False, False)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    triplicated_obj = obj
    for k in range(1, 3):
        triplicated_obj = combine(triplicated_obj, shift(obj, (0, k * width(obj))))
    O = paint(O, shift(triplicated_obj, (9 - i * 3, 2)))
  
  if len(objs) == 1:
    base = shift(toindices(first(objs)), (len(first(objs)) + 2, 2 * width(first(objs))))
    support = shift(base, (1, 0)) | {(i + 2, j) for i, j in base if i < 7}
    O = paint(O, recolor(1, base | support))
  else:
    O = paint(O, recolor(1, connect((0, 0), (2, 2))))
    O = paint(O, recolor(1, connect((8, 4), (8, 6))))
    O = paint(O, recolor(1, {(1, 7), (2, 8)}))
  return O
 
31.0, tensor(0.4219), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and index:

- If the object is a single cell, upscale it by a factor of 3 and place it at position (4 + i * 5, 7 + i), where 'i' is the object's index. Recolor it to color 1.
- If the object is the smallest object, upscale it by a factor of 2 and place it at position (0, 5).
- If the object is the second smallest object, upscale it by a factor of 2, horizontally mirror it, and place it at position (5, 0).
- All other objects are upscaled by a factor of 2 and placed at position (7, 0). 
:: def bdeafbaffdaiebdaieijefbdhabfaiba(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: size(obj))):
    if size(obj) == 1:
      obj = upscale(obj, 3)
      obj = shift(obj, (4 + i * 5, 7 + i))
      obj = recolor(1, obj)
    elif i == 0:
      obj = upscale(obj, 2)
      obj = shift(obj, (0, 5))
    elif i == 1:
      obj = upscale(obj, 2)
      obj = hmirror(obj)
      obj = shift(obj, (5, 0))
    else:
      obj = upscale(obj, 2)
      obj = shift(obj, (7, 0))
    O = paint(O, obj)
  return O 
 
31.0, tensor(0.3087), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it and place it in the output grid based on its size and index:

- If the object is the third largest object, upscale it by a factor of 3, place it at position (9, 9), and recolor it to color 1.
- If the object is the smallest object, upscale it by a factor of 2 and place it at position (0, 5).
- If the object is the second smallest object, upscale it by a factor of 2, horizontally mirror it, and place it at position (5, 0).
- All other objects are upscaled by a factor of 2 and placed at their original position. 
:: def deaacabdcdddegafifdidcfccfccbccb(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: -size(obj))):
    if i == 2:
      obj = upscale(obj, 3)
      obj = shift(obj, (9, 9))
      obj = recolor(1, obj)
    elif i == 0:
      obj = upscale(obj, 2)
      obj = shift(obj, (0, 5))
    elif i == 1:
      obj = upscale(obj, 2)
      obj = hmirror(obj)
      obj = shift(obj, (5, 0))
    O = paint(O, obj)
  return O 
 
31.0, tensor(0.5926), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2) and the upscaled last object at position (7, 1).
- If there are multiple objects, place the upscaled first object at position (0, 7 - size(first(objs))) and the upscaled last object at position (5 - size(first(objs)), 0).

Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if there is only one object in the input grid, otherwise place it at position (0, 0). Paint all three objects onto the output grid. 
:: def afdgcjiffhebefcfagiedidcfedddiha(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2)
  obj2 = upscale(last(objs), 2)

  obj1_pos = (2, 2) if len(objs) == 1 else (0, 7 - size(first(objs))) # Position based on size
  obj2_pos = (7, 1) if len(objs) == 1 else (5 - size(first(objs)), 0) # Position based on size

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  obj3_pos = (7, 1) if len(objs) == 1 else (0, 0)

  return paint(paint(paint(canvas(0, (10, 10)), shift(obj1, obj1_pos)), shift(obj2, obj2_pos)), shift(obj3, obj3_pos)) 
 
31.333333333333332, tensor(0.5926), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2) and the upscaled last object at position (7, 1).
- If there are multiple objects, place the upscaled first object at position (0, 7 - size(first(objs))) and the upscaled last object at position (5 - size(first(objs)), 0).

Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0). Upscale this new object by a factor of 1 and place it at position (7, 1) if there is only one object in the input grid, otherwise place it at position (0, 0). Paint all three objects onto the output grid. 
:: def cbjbdcgcejaaeafabeefhjfeabadccba(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2) 
  obj2 = upscale(last(objs), 2)

  if len(objs) == 1:
    positions = ((2, 2), (7, 1))
  else:
    offset = 7 - size(first(objs))
    positions = ((0, offset), (offset, 0))

  obj1_pos, obj2_pos = positions

  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)
  obj3_pos = (7, 1) if len(objs) == 1 else (0, 0)

  return paint(paint(paint(canvas(0, (10, 10)), shift(obj1, obj1_pos)), shift(obj2, obj2_pos)), shift(obj3, obj3_pos)) 
 
32.333333333333336, tensor(1.2368), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid by a factor of 2. 

- If there is only one object, place the upscaled object at position (2, 2) and then place another copy of the upscaled object at position (6, 5). Finally, create a new object with color 1 by cropping a 3x3 grid with a single cell at (1, 1) filled with color 0 and shifting it to position (6, 1). Paint this new object onto the output grid.

- If there are two objects, place the upscaled first object at position (1, 1) and the upscaled second object at position (5, 6). Then, create a new object with color 1 by cropping a 3x3 grid with a single cell at (1, 1) filled with color 0 and shifting it to position (0, 0). Also, create another new object with color 1 consisting of five cells at positions (0, 0), (1, 0), (2, 0), (2, 1), and (2, 2) and shift it to position (7, 5). Paint both new objects onto the output grid.

- If there are more than two objects, place the upscaled first object at position (7, 0), the upscaled second object at position (6, 0), and the upscaled third object at position (5, 4). Then, create a new object with color 1 by cropping a 3x3 grid with a single cell at (1, 1) filled with color 0 and shifting it to position (-1, -1). Also, create another new object with color 1 consisting of five cells at positions (0, 0), (1, 0), (2, 0), (2, 1), and (2, 2) and shift it to position (7, 4). Paint both new objects onto the output grid.

Finally, recolor each object to a color that is one more than its index. 
:: def ajfdafefedgiediabagibcdagibhbbed(I):
    objs = objects(I, T, F, T)
    upscaled_objs = apply(lambda obj: upscale(obj, 2), objs)
    O = canvas(0, (10, 10))
    
    if len(upscaled_objs) == 1:
        obj = first(upscaled_objs)
        O = paint(O, shift(obj, (2, 2)))
        O = paint(O, shift(obj, (6, 5)))
        O = paint(O, recolor(1, shift(crop(canvas(0, (3,3)), (1,1), (2,2)), (6,1))))
    elif len(upscaled_objs) == 2:
        obj1, obj2 = first(upscaled_objs), last(upscaled_objs)
        O = paint(O, shift(obj1, (1, 1)))
        O = paint(O, shift(obj2, (5, 6)))
        O = paint(O, recolor(1, shift(crop(canvas(0, (3,3)), (1,1), (2,2)), (0,0))))
        O = paint(O, recolor(1, shift({(0,0),(1,0),(2,0),(2,1),(2,2)}, (7, 5))))
    else:
        obj1 = first(upscaled_objs)
        obj2 = list(upscaled_objs - {obj1})[0]
        obj3 = list(upscaled_objs - {obj1, obj2})[0] 
        O = paint(O, shift(obj1, (7, 0)))
        O = paint(O, shift(obj2, (6, 0)))
        O = paint(O, shift(obj3, (5, 4)))
        O = paint(O, recolor(1, shift(crop(canvas(0, (3,3)), (1,1), (2,2)), (-1, -1))))
        O = paint(O, recolor(1, shift({(0,0),(1,0),(2,0),(2,1),(2,2)}, (7, 4))))
    return O
 
29.0, tensor(1.9739), Description: Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid based on its index:

- The smallest object is upscaled by a factor of 3 and placed at the bottom of the grid, shifted up by its height.
- The second smallest object is upscaled by a factor of 2 and placed at the right of the grid, shifted left by its width.
- All other objects are upscaled by a factor of 2 and placed at the bottom right corner of the grid, shifted left by its width and up by its height. 
:: def gfefadcagffceafgibgfbiefeedcejfg(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=size)):
    if i == 0:
      obj = upscale(obj, 3)
      obj = shift(obj, (0, 10 - height(obj)))
    elif i == 1:
      obj = upscale(obj, 2)
      obj = shift(obj, (10 - width(obj), 0))
    else:
      obj = upscale(obj, 2)
      obj = shift(obj, (10 - width(obj), 10 - height(obj)))
    O = paint(O, obj)
  return O
 
29.333333333333332, tensor(1.3759), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2) and create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (7, 1). Paint this new object onto the output grid.
- If there are multiple objects, place the upscaled first object at position (0, 7) if the first object is a single cell, otherwise place it at position (0, 0). Place the upscaled last object at position (7, 0) if the first object is a single cell, otherwise place it at position (7, 7). Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (0, 0). Paint this new object onto the output grid. 
:: def ccaeiidifddeecaejadajedaeaeeebgc(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2)
  obj2 = upscale(last(objs), 2)

  grid = canvas(0, (10, 10))

  if len(objs) == 1:
    grid = paint(grid, shift(obj1, (2, 2)))
    grid = paint(grid, shift(upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1), (7, 1))) 
  else:
    obj1_pos = (0, 7) if size(first(objs)) == 1 else (0, 0)
    obj2_pos = (7, 0) if size(first(objs)) == 1 else (7, 7)
    grid = paint(paint(grid, shift(obj1, obj1_pos)), shift(obj2, obj2_pos))
    grid = paint(grid, shift(upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1), (0, 0)))

  return grid
 
28.0, tensor(1.7460), Description: Copy the input grid and fill it with the background color (0). Then, upscale the first and last objects by a factor of 2. 

- If there is only one object, place the upscaled first object at position (2, 2) and create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (7, 1). Paint this new object onto the output grid.
- If there are multiple objects, determine the relative position of the first object to the last object. If the first object is one row above and one column to the left of the last object, place the upscaled first object at position (0, 7) and the upscaled last object at position (7, 0). Otherwise, place the upscaled first object at position (0, 0) and the upscaled last object at position (7, 7). Finally, create a new object with color 1, consisting of five cells at positions (0, 0), (0, 1), (1, 0), (1, 1), and (2, 0), upscale it by a factor of 1, and shift it to position (0, 0). Paint this new object onto the output grid. 
:: def dhcifchbdfddeddaaaihgbhbjbcfgedj(I):
  objs = objects(I, T, F, T)
  obj1 = upscale(first(objs), 2)
  obj2 = upscale(last(objs), 2)
  obj3 = upscale({(1, (0, 0)), (1, (1, 0)), (1, (0, 1)), (1, (1, 1)), (1, (2, 0))}, 1)

  grid = canvas(0, (10, 10))

  if len(objs) == 1:
    grid = paint(grid, shift(obj1, (2, 2)))
    grid = paint(grid, shift(obj3, (7, 1)))
  else:
    rel_pos = position(obj1, obj2)
    obj1_pos = (0, 7) if rel_pos == (1, -1) else (0, 0)
    obj2_pos = (7, 0) if rel_pos == (1, -1) else (7, 7)
    grid = paint(paint(grid, shift(obj1, obj1_pos)), shift(obj2, obj2_pos))
    grid = paint(grid, shift(obj3, (0, 0)))

  return grid
 
57.333333333333336, tensor(1.3694), Description: Upscale the input grid by a factor of 2. For each object in the input grid, upscale it by a factor of 2 and place it in the output grid based on its relative position to the first object. The first object is placed at position (1, 1). For all other objects, calculate the direction towards the first object and adjust the position by adding this direction to (1, 1). Finally, recolor all objects to their original colors. 
:: def eafebdjdgdffefjabjbbbiejabbdafcc(I):
    objs = objects(I, T, F, T)
    new_grid = canvas(0, multiply(shape(I), 2))
    main_obj = first(objs) # Assuming the first object is the "main" object 
    upscaled_main = upscale(main_obj, 2)
    new_grid = paint(new_grid, shift(upscaled_main, (1, 1))) # Place main object
    for obj in objs:
        if obj == main_obj:
            continue
        upscaled_obj = upscale(obj, 2)
        direction = gravitate(upscaled_obj, upscaled_main) # Find direction towards main object
        position = add((1, 1), direction) # Adjust position based on gravitation
        new_grid = paint(new_grid, shift(upscaled_obj, position))
    return new_grid
 
30.333333333333332, tensor(1.9734), Description: Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid based on its index:

- The smallest object is upscaled by a factor of 3 and placed at the bottom of the grid, shifted up by its height.
- The second smallest object is upscaled by a factor of 2 and placed at the right of the grid, shifted left by its width.
- All other objects are upscaled by a factor of 2 and placed at the bottom right corner of the grid, shifted left by its width and up by its height plus twice the difference between its index and 2. 
:: def fecdceecaddaeegdjfeefihbfedgcaei(I):
  objs = sorted(objects(I, T, F, T), key=size)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    factor = 3 - i if i < 2 else 2 
    obj = upscale(obj, factor)
    h, w = shape(obj)
    if i == 0:
      O = paint(O, shift(obj, (0, 10 - h)))
    elif i == 1:
      O = paint(O, shift(obj, (10 - w, 0)))
    else:
      O = paint(O, shift(obj, (10 - w, 10 - h - 2 * (i - 2))))
  return O
 
31.666666666666668, tensor(1.9740), Description: Copy the input grid and fill it with the background color (0). Then, for each object in the grid, upscale it based on its index and place it in the output grid based on its index and whether it's the largest object:

- If the object is the largest object, upscale it by a factor of 3 and place it at the bottom of the grid, shifted to the right by its width.
- If the object is not the largest object and its index is even, upscale it by a factor of 2 and place it at the right of the grid, shifted up by its height.
- If the object is not the largest object and its index is odd, upscale it by a factor of 2 and place it at the bottom of the grid, shifted to the right by its width. 
:: def ddcebacajfdeeccbjebdbccdedbdffcc(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda x: -size(x))):
    f = 2 + (i == 0)
    obj = upscale(obj, f)
    i, j = (0, 9 - width(obj)) if i % 2 else (9 - height(obj), 0)
    O = paint(O, shift(obj, (i, j)))
  return O
 
32.333333333333336, tensor(1.9739), Description: Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid based on its index:

- The smallest object is upscaled by a factor of 3 and placed at the bottom of the grid, shifted up by its height.
- The second smallest object is upscaled by a factor of 2 and placed at the right of the grid, shifted left by its width.
- All other objects are upscaled by a factor of 2 and placed at the bottom right corner of the grid, shifted left by its width and up by its height. 
:: def eegjfeeiccgaeaabjjgadeafcabfadga(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(sorted(objs, key=size)):
    if i == 0:
      obj = upscale(obj, 3)
      obj = shift(obj, (0, 9 - height(obj)))
    elif i == 1:
      obj = upscale(obj, 2)
      obj = shift(obj, (9 - width(obj), 0))
    else:
      obj = upscale(obj, 2)
      obj = shift(obj, (9 - width(obj), 9 - height(obj))) 
    O = paint(O, obj)
  return O
 
31.333333333333332, tensor(1.9743), Description: Copy the input grid and fill it with the background color (0). Then, upscale each object in the grid based on its index:

- The smallest object is upscaled by a factor of 3 and placed at the bottom right corner of the grid, shifted left by its width and up by its height.
- The second smallest object is upscaled by a factor of 2 and placed at the bottom of the grid, shifted to the right by its width.
- The third smallest object is upscaled by a factor of 2 and placed at the right of the grid, shifted up by its height.
- All other objects are upscaled by a factor of 2 and placed at the bottom right corner of the grid, shifted left by its width and up by its height. 
:: def ecffjbbedghhehicjcjbecabfbbeaghb(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  s = sorted(objs, key=size)
  for i, obj in enumerate(s):
    obj = upscale(obj, 3 - (i < 2))
    if i == len(s) - 1:
      obj = shift(obj, (9 - height(obj), 9 - width(obj)))
    else:
      obj = shift(obj, ((i % 2) * (9 - height(obj)), (1 - (i % 2)) * (9 - width(obj))))
    O = paint(O, obj)
  return O
 
28.666666666666668, tensor(0.4781), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 2:
    - If the first object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (7, 1), (7, 2), (7, 3), (8, 1), (8, 2), and (9, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (1, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the first object's color is not 2, shift two copies of the upscaled object to positions (0, 6) and (5, 0), combine them, and create a new object with color 1 consisting of thirteen cells at positions (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), and (9, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def gafaaaadgdbjecieiaeddeahfaiaaffj(I):
  objs = objects(I, T, F, T)
  obj = first(objs)
  upscaled_obj = upscale(obj, 2)
  if color(obj) == 2:
    if uppermost(obj) == 0:
      shifted_obj = shift(upscaled_obj, (2, 3)) 
      new_obj = recolor(1, frozenset({(7, 1), (7, 2), (7, 3), (8, 1), (8, 2), (9, 1)}))
    else:
      shifted_obj = shift(hmirror(upscaled_obj), (1, 1))
      new_obj = recolor(1, frozenset({(0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8)}))
  else:
    shifted_obj1 = shift(upscaled_obj, (0, 6))
    shifted_obj2 = shift(upscaled_obj, (5, 0))
    shifted_obj = combine(shifted_obj1, shifted_obj2)
    new_obj = recolor(1, frozenset({(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)}))
  O = paint(paint(canvas(0, (10, 10)), shifted_obj), new_obj)
  return O
 
41.333333333333336, tensor(1.2120), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 1:
    - If the first object is on the top row, shift the upscaled object to position (0, 3) and create a new object with color 1 consisting of six cells at positions (6, 1), (6, 2), (6, 3), (7, 1), (7, 2), and (8, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (0, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the first object's color is 2:
    - If the first object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (6, 1), (6, 2), (6, 3), (7, 1), (7, 2), and (8, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (2, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def bahhedieacibeicfbbddiedadeiaefhf(I):
  objs = objects(I, T, F, T)
  obj = first(objs)
  upscaled_obj = upscale(obj, 2)
  c = color(obj)
  if uppermost(obj) == 0:
    shifted_obj = shift(upscaled_obj, (2 * c - 2, 3)) 
    new_obj = recolor(1, frozenset((i + 6, j + 1) for i in range(4) for j in range(4) if i + j >= 5 - c))
  else:
    shifted_obj = shift(hmirror(upscaled_obj), (2 - c, 1))
    new_obj = recolor(1, frozenset((i, 9 - j) for i in range(6) for j in range(6) if (i < 3 and j >= 3 - c) or (i >= 3 and j < 3 + c)))
  O = paint(paint(canvas(0, (10, 10)), shifted_obj), new_obj)
  return O
 
31.0, tensor(0.4781), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 2:
    - If the first object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (7, 1), (7, 2), (7, 3), (8, 1), (8, 2), and (9, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (1, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the first object's color is not 2, shift two copies of the upscaled object to positions (0, 6) and (5, 0), combine them, and create a new object with color 1 consisting of thirteen cells at positions (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), and (9, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def jaafagaaddcceeefihfdbgcacbfjheeb(I):
  obj = first(objects(I, T, F, T))
  if color(obj) == 2:
    O = paint(canvas(0, (10, 10)), shift(upscale(obj, 2), (2, 3))) 
    if uppermost(obj) == 0:
      O = paint(O, recolor(1, frozenset({(7, 1), (7, 2), (7, 3), (8, 1), (8, 2), (9, 1)})))
    else:
      O = paint(O, recolor(1, frozenset({(0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8)})))
  else:
    O = paint(canvas(0, (10, 10)), shift(upscale(obj, 2), (0, 6))) 
    O = paint(O, shift(upscale(obj, 2), (5, 0)))
    O = paint(O, recolor(1, frozenset({(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)})))
  return O
 
30.333333333333332, tensor(0.4630), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 2:
    - If the first object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (7, 1), (7, 2), (7, 3), (8, 1), (8, 2), and (9, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (0, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the first object's color is not 2, shift two copies of the upscaled object to positions (0, 6) and (5, 0), combine them, and create a new object with color 1 consisting of thirteen cells at positions (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), and (9, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def bcebccadfegcehchacbbeafbeabdacef(I):
  obj = first(objects(I, T, F, T))
  O = canvas(0, (10, 10))
  O = paint(O, shift(upscale(obj, 2), (2 if color(obj) == 2 else 0, 3 if color(obj) == 2 else 6)))
  if color(obj) == 2:
    if uppermost(obj) == 0:
      O = paint(O, recolor(1, frozenset(astuple(7 + i, 1 + j) for i in range(3) for j in range(4) if i + j <= 3)))
    else:
      O = paint(O, recolor(1, frozenset(astuple(i, 8 - j) for i in range(6) for j in range(3) if i // 3 == j)))
  else:
    O = paint(O, shift(upscale(obj, 2), (5, 0)))
    O = paint(O, recolor(1, frozenset(astuple(i, j) for i in range(10) for j in range(10) if (i < 4 and j < 3 and i + j <= 3) or (i >= 4 and j == 8))))
  return O
 
30.666666666666668, tensor(0.4630), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 2:
    - If the first object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (7, 1), (7, 2), (7, 3), (8, 1), (8, 2), and (9, 1).
    - If the first object is not on the top row, horizontally mirror the upscaled object, shift it to position (0, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the first object's color is not 2, shift two copies of the upscaled object to positions (0, 6) and (5, 0), combine them, and create a new object with color 1 consisting of thirteen cells at positions (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2), (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), and (9, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def ieabiahhebdbedbabcafchbffdbdbehj(I):
  obj = first(objects(I, T, F, T))
  u = uppermost(obj)
  c = color(obj)
  O = paint(canvas(0, (10, 10)), shift(upscale(obj, 2), (2 * (c == 2), 3 * (c == 2) + 6 * (c != 2))))
  if c == 2:
    O = paint(O, recolor(1, frozenset(astuple(7 + i * (u == 0) + i * (u != 0), j + (u == 0) + (9 - j) * (u != 0)) for i in range(3) for j in range(4) if i + j <= 3))) 
  else:
    O = paint(O, shift(upscale(obj, 2), (5, 0)))
    O = paint(O, recolor(1, frozenset((i, j) for i in range(4) for j in range(3) if i + j <= 3) | frozenset((i, 8) for i in range(4, 10))))
  return O
 
32.0, tensor(1.9743), Description: Copy the input grid and fill it with the most common color. Then, upscale the largest object by a factor of 3 and place it at the bottom of the grid, shifted up by its height. Upscale the second largest object by a factor of 2 and place it at the bottom right corner of the grid, shifted left by its width and up by its height. Upscale all other objects by a factor of 2 and place them at the bottom right corner of the grid, shifted left by its width and up by its height plus twice the difference between its index and 1. 
:: def facdecbgadeeedbcahhabefhjiaigdca(I):
  objs = sorted(objects(I, T, F, T), key=size, reverse=True)
  O = canvas(mostcolor(I), (10, 10))
  for i, obj in enumerate(objs):
    s = 3 if i == 0 else 2
    obj = upscale(obj, s)
    if i == 0:
      obj = shift(obj, (0, 10 - height(obj)))
    elif i == 1:
      obj = shift(obj, (10 - width(obj), 10 - height(obj)))
    else:
      obj = shift(obj, (10 - width(obj), 10 - height(obj) - 2 * (i-1)))
    O = paint(O, obj)
  return O
 
32.333333333333336, tensor(1.9741), Description: Copy the input grid and fill it with the most common color. Then, upscale the largest object by a factor of 3 and place it at the left side of the grid, shifted up by its height minus 1. Upscale the second largest object by a factor of 2 and place it at the bottom right corner of the grid, shifted left by its width and up by its height minus 1. Upscale all other objects by a factor of 2 and place them at the bottom right corner of the grid, shifted left by its width and up by its height plus twice the difference between its index and 1. 
:: def jfadeieagdegecdibigfgaffchacaabe(I):
  objs = sorted(objects(I, T, F, T), key=size, reverse=True)
  O = canvas(mostcolor(I), (10, 10))
  x, y = 0, 9
  for i, obj in enumerate(objs):
    obj = upscale(obj, 3 if i == 0 else 2)
    h, w = shape(obj)
    O = paint(O, shift(obj, (x, y - h + 1)))
    if i == 0:
      x += w
    else:
      y -= h
  return O
 
30.666666666666668, tensor(1.9741), Description: Copy the input grid and fill it with the most common color. Then, upscale the largest object by a factor of 3 and place it at the left side of the grid, shifted up by its height minus 1. Upscale the second largest object by a factor of 2 and place it at the bottom right corner of the grid, shifted left by its width and up by its height minus 1. Upscale all other objects by a factor of 2 and place them at the bottom right corner of the grid, shifted left by its width and up by its height plus twice the difference between its index and 1. 
:: def hchcgccfgaeeehaeaddjcfgfedeechbi(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), (10, 10))
  objs = sorted(objs, key=lambda obj: (-size(obj), -ulcorner(obj)[0], -ulcorner(obj)[1]))
  x, y = 0, 9
  for i, obj in enumerate(objs):
    obj = upscale(obj, 3 if i == 0 else 2)
    h, w = shape(obj)
    O = paint(O, shift(obj, (x, y - h + 1)))
    if i == 0:
      x += w
    else:
      y -= h
  return O
 
32.0, tensor(1.1114), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale each object by a factor of 2. 

- If the object's color is 2:
    - If the object is on the top row, shift the upscaled object to position (2, 3) and create a new object with color 1 consisting of six cells at positions (7, 1), (7, 2), (7, 3), (8, 1), (8, 2), and (9, 1).
    - If the object is not on the top row, horizontally mirror the upscaled object, shift it to position (1, 1), and create a new object with color 1 consisting of eleven cells at positions (0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8), and (6, 8).

- If the object's color is not 2:
    - If the object is on the top row, shift the upscaled object to position (0, 6) and create a new object with color 1 consisting of six cells at positions (0, 0), (0, 1), (0, 2), (1, 1), (1, 2), and (2, 2).
    - If the object is on the leftmost column, shift the upscaled object to position (5, 0) and create a new object with color 1 consisting of seven cells at positions (3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), and (9, 8).
    - If the object is neither on the top row nor the leftmost column, shift the upscaled object to position (6, 6) and create a new object with color 1 consisting of nine cells at positions (5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (6, 1), (7, 1), (8, 1), and (9, 1).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def cdccfadddfcfededjbchbdfjicgfhbca(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for obj in objs:
    upscaled_obj = upscale(obj, 2)
    if color(obj) == 2:
      if uppermost(obj) == 0:
        shifted_obj = shift(upscaled_obj, (2, 3))
        new_obj = recolor(1, frozenset({(7, 1), (7, 2), (7, 3), (8, 1), (8, 2), (9, 1)}))
      else:
        shifted_obj = shift(hmirror(upscaled_obj), (1, 1))
        new_obj = recolor(1, frozenset({(0, 8), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 8), (4, 8), (5, 8)}))
      O = paint(paint(O, shifted_obj), new_obj)
    else:
      if uppermost(obj) == 0:
        shifted_obj = shift(upscaled_obj, (0, 6))
        new_obj = recolor(1, frozenset({(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)}))
      elif leftmost(obj) == 0:
        shifted_obj = shift(upscaled_obj, (5, 0))
        new_obj = recolor(1, frozenset({(3, 2), (4, 8), (5, 8), (6, 8), (7, 8), (8, 8), (9, 8)}))
      else:
        shifted_obj = shift(upscaled_obj, (6, 6))
        new_obj = recolor(1, frozenset({(5, 0), (6, 0), (7, 0), (8, 0), (9, 0), (6, 1), (7, 1), (8, 1), (9, 1)}))
      O = paint(paint(O, shifted_obj), new_obj)
  return O
 
27.666666666666668, tensor(0.5785), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object's color is 2:
    - Shift the upscaled object to position (2 * i, 3 * i), where 'i' is the object's index.
    - Create a new object with color 1 consisting of six cells at positions (7 + i, 1), (7 + i, 2), (7 + i, 3), (8 + i, 1), (8 + i, 2), and (9 + i, 1).

- If the first object's color is not 2:
    - Horizontally mirror the upscaled object, shift it to position (i, i), and create a new object with color 1 consisting of eleven cells at positions (0, 8 - i), (1, 6 - i), (1, 7 - i), (1, 8 - i), (2, 6 - i), (2, 7 - i), (2, 8 - i), (3, 8 - i), (4, 8 - i), (5, 8 - i), and (6, 8 - i).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def jacahbjbgfceedafjaiadeagciaejaej(I):
  objs = objects(I, T, F, T)
  O = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    upscaled_obj = upscale(obj, 2)
    if color(obj) == 2:
      shifted_obj = shift(upscaled_obj, (2 * i, 3 * i))
      new_obj = recolor(1, frozenset({(7 + i, 1), (7 + i, 2), (7 + i, 3), (8 + i, 1), (8 + i, 2), (9 + i, 1)}))
    else:
      shifted_obj = shift(hmirror(upscaled_obj), (i, i))
      new_obj = recolor(1, frozenset({(0, 8 - i), (1, 6 - i), (1, 7 - i), (1, 8 - i), (2, 6 - i), (2, 7 - i), (2, 8 - i), (3, 8 - i), (4, 8 - i), (5, 8 - i)}))
    O = paint(paint(O, shifted_obj), new_obj)
  return O
 
32.666666666666664, tensor(0.6089), Description: 
Copy the input grid and fill it with the background color (0). Then, for each connected object in the grid, paint the object onto the output grid. If there is only one connected object, paint a copy of the object shifted two spaces down and two spaces to the right. If there are two connected objects, paint a copy of the second object shifted two spaces down and two spaces to the right. 

Finally, add a new object with color 1, consisting of three cells at positions (7, 1), (8, 1), and (8, 2). If there is only one connected object, add an additional cell at position (8, 3) to the new object. If there are two connected objects, paint a horizontal line of color 1 from row 0 to row 9 in column 9 of the output grid. Also, paint a diagonal line of color 1 from row 0 to row 3 in columns 6 to 9 of the output grid. If there are more than two connected objects, paint a vertical line of color 1 from row 0 to row 3 in column 0 of the output grid. Also, paint a horizontal line of color 1 from row 0 to row 2 in column 1 of the output grid. Finally, paint a diagonal line of color 1 from row 9 to row 3 in columns 4 to 7 of the output grid. 
:: def ebccceahacjfeaeaificcdccffigigef(grid):
  objs = objects(grid, True, False, True)
  canvas_grid = canvas(0, (10, 10))
  for i, obj in enumerate(objs):
    canvas_grid = paint(canvas_grid, obj)
    if i == 0:
      canvas_grid = paint(canvas_grid, shift(obj, (2, 2) if len(objs) == 1 else (3, 2)))
      canvas_grid = paint(canvas_grid, shift(obj, (6, 5)))
    elif i == 1 and len(objs) == 2:
      canvas_grid = paint(canvas_grid, shift(obj, (6, 5)))
  new_ones = {(1, (7, 1)), (1, (8, 1)), (1, (8, 2))}
  if len(objs) == 1:
    new_ones = new_ones | {(1, (8, 3))}
  elif len(objs) == 2:
    new_ones = {(1, (i, 9)) for i in range(10)} | {(1, (j, 6 + j)) for j in range(4)} | {(1, (5, 7))}
  else:
    new_ones = {(1, (i, 0)) for i in range(4)} | {(1, (j, 1)) for j in range(3)} | {(1, (4, 4)), (1, (5, 5)), (1, (6, 6)), (1, (7, 7))} | {(1, (9, k)) for k in range(6, 9)}
  return paint(canvas_grid, new_ones)
 
29.333333333333332, tensor(1.9441), Description: Copy the input grid and fill it with the most common color. Then, upscale the largest object by a factor of 3 if it's larger than 1x1, otherwise upscale it by a factor of 2. Place this upscaled object at the bottom right corner of the grid, shifted left by its width and up by its height. If there are multiple objects, upscale the smallest object by a factor of 2 and place it at the bottom right corner of the grid, shifted left by its width and up by its height minus the upscaling factor of the largest object. Recolor the smallest object to color 1. Leave all other objects unchanged. 
:: def ecgfdbggjfigebihbeffjbebffhejedb(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), (10, 10))
  a = max(objs, key=size)
  factor = 3 if len(a) > 1 else 2
  a = upscale(a, factor)
  a = shift(a, (10 - width(a), 10 - height(a)))
  O = paint(O, a)
  if len(objs) > 1:
    b = min(objs, key=size)
    b = upscale(b, 2)
    b = shift(b, (10 - width(b), 10 - height(b) - factor))
    O = paint(O, recolor(1, b))
  return O 
 
31.333333333333332, tensor(1.9601), Description: Copy the input grid and fill it with the most common color. Then, upscale the largest object by a factor of 3 if it's larger than 1x1, otherwise upscale it by a factor of 2. Place this upscaled object at the bottom right corner of the grid, shifted left by its width and up by its height. If there are more than two objects, upscale the second largest object by a factor of 2 and place it at the bottom right corner of the grid, shifted left by its width and up by its height minus the upscaling factor of the largest object. Recolor the second largest object to color 1. Leave all other objects unchanged. 
:: def ceiijaacihaaefbfibegeacbbjibbeed(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), (10, 10))
  for i, obj in enumerate(sorted(objs, key=lambda obj: -len(obj) * 100 + ulcorner(obj)[0] * 10 + ulcorner(obj)[1])):
    factor = 3 if i == 0 and len(obj) > 1 else 2
    obj = upscale(obj, factor)
    i_offset = 0 if i == 0 else factor - 1
    obj = shift(obj, (9 - width(obj), 9 - height(obj) - i * i_offset))
    O = paint(O, obj)
    if i == 1 and len(objs) > 2:
      O = paint(O, recolor(1, obj))
  return O
 
36.666666666666664, tensor(0.6776), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object is on the top row, shift the upscaled object to position (2, 2) and create a new object with color 1 consisting of nine cells at positions (0, 7), (1, 6), (1, 7), (1, 8), (2, 6), (2, 7), (2, 8), (3, 6), and (3, 7).
- If the first object is on the second row, shift the upscaled object to position (5, 6) and create a new object with color 1 consisting of eight cells at positions (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), and (3, 1).
- If the first object is on the third row, shift the upscaled object to position (7, 8) and create a new object with color 1 consisting of fifteen cells at positions (0, 6), (0, 7), (0, 8), (1, 5), (1, 6), (1, 7), (1, 8), (2, 5), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6), (3, 7), and (3, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def iahfbidbffigeacbjdaihdeegedgfcbi(I):
  obj = first(objects(I, T, F, T))
  c = color(obj)
  O = paint(canvas(0, (10, 10)), shift(upscale(obj, 2), (2 * (uppermost(obj) == 0) + 5 * (uppermost(obj) != 0), 2 + 4 * (uppermost(obj) != 0))))
  if uppermost(obj) == 0:
    O = paint(O, recolor(1, frozenset({(i, 7 - i) for i in range(3)}) | frozenset({(i + 7, j) for i in range(3) for j in range(3) if i + j <= 2})))
  elif uppermost(obj) == 1:
    O = paint(O, recolor(1, frozenset({(1, i) for i in range(3)}) | frozenset({(2, 1), (2, 2)}) | frozenset({(i + 4, j + 6) for i in range(4) for j in range(3) if i + j <= 3})))
  else:
    O = paint(O, recolor(1, frozenset({(0, i + 6) for i in range(4)}) | frozenset({(1, 7), (1, 8), (2, 7)}) | frozenset({(i + 3, j) for i in range(6) for j in range(3) if i + j <= 5})))
  return O
 
30.666666666666668, tensor(0.5125), Description: 
Copy the input grid and fill it with the background color (0). Then, upscale the first object by a factor of 2. 

- If the first object is a 1x1 square, shift the upscaled object to position (0, 0) and create a new object with color 1 consisting of nine cells at positions (7, 6), (7, 7), (7, 8), (8, 5), (8, 6), (8, 7), (8, 8), (9, 5), and (9, 6).
- If the first object is a 1x2 rectangle, shift the upscaled object to position (0, 0) and create a new object with color 1 consisting of eight cells at positions (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), and (3, 1).
- If the first object is a 2x1 rectangle, shift the upscaled object to position (0, 0) and create a new object with color 1 consisting of fifteen cells at positions (0, 6), (0, 7), (0, 8), (1, 5), (1, 6), (1, 7), (1, 8), (2, 5), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6), (3, 7), and (3, 8).

Finally, paint both the shifted object and the new object onto the output grid. 
:: def hecbgbdbhcdjedafbfiifceibdgifaae(I):
  obj = first(objects(I, T, F, T))
  h, w = shape(obj)
  O = paint(canvas(0, (10, 10)), shift(upscale(obj, 2), ((5 - h) * 2, (5 - w) * 2))) 
  if h == 1 and w == 1:
    O = paint(O, recolor(1, frozenset({(i + 7, 6 - i) for i in range(3)}) | frozenset({(i + 7, j) for i in range(3) for j in range(3) if i + j <= 2})))
  elif h == 1 and w == 2:
    O = paint(O, recolor(1, frozenset({(1, i) for i in range(3)}) | frozenset({(2, 1), (2, 2)}) | frozenset({(i + 4, j + 6) for i in range(4) for j in range(3) if i + j <= 3})))
  else:
    O = paint(O, recolor(1, frozenset({(0, i + 6) for i in range(4)}) | frozenset({(1, 7), (1, 8), (2, 7)}) | frozenset({(i + 3, j) for i in range(6) for j in range(3) if i + j <= 5})))
  return O 
 
33.333333333333336, tensor(0.6443), Description: 
Copy the input grid and fill it with the background color (0). Then, for each cell in the input grid that has the same color as the first object, create a 2x2 square of that color in the output grid, shifted by a factor of 4 based on the cell's row and column indices. 

- If the first object is a 1x1 square and it's on the top row, create a new object with color 1 consisting of nine cells at positions (7, 6), (7, 7), (7, 8), (8, 5), (8, 6), (8, 7), (8, 8), (9, 5), and (9, 6).
- If the first object is a 1x1 square and it's not on the top row, create a new object with color 1 consisting of eight cells at positions (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2), (3, 0), and (3, 1).
- If the first object is not a 1x1 square, create a new object with color 1 consisting of fifteen cells at positions (0, 6), (0, 7), (0, 8), (1, 5), (1, 6), (1, 7), (1, 8), (2, 5), (2, 6), (2, 7), (2, 8), (3, 5), (3, 6), (3, 7), and (3, 8).

Finally, paint both the shifted objects and the new object onto the output grid. 
:: def dhgeebcajedhecaiabifbedbebiifaji(I):
  obj = first(objects(I, T, F, T))
  O = canvas(0, (10, 10))
  for _, (i, j) in obj:
    O = paint(O, shift(upscale(recolor(2, {(0, 0)}), 2), (i * 4, j * 4)))
  if len(obj) == 1:
    if uppermost(obj) == 0:
      O = paint(O, recolor(1, frozenset({(i + 7, 6 - i) for i in range(3)}) | frozenset({(i + 7, j) for i in range(3) for j in range(3) if i + j <= 2})))
    else:
      O = paint(O, recolor(1, frozenset({(i + 4, j + 6) for i in range(4) for j in range(3) if i + j <= 3})))
  else:
    O = paint(O, recolor(1, frozenset({(0, i + 6) for i in range(4)}) | frozenset({(1, 7), (1, 8), (2, 7)}) | frozenset({(i + 3, j) for i in range(6) for j in range(3) if i + j <= 5})))
  return O
 
