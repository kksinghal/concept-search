15.333333333333334, tensor(0.0127), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position.  The shapes should be stacked on top of each other, with no gaps between them.  The background should be black. 
:: def daajbecjhfceeagfbfaajiahacidafba(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  moved_objs = frozenset()
  h, w = len(I), len(I[0])
  for obj in objs:
    oi, oj = ulcorner(obj)
    new_i = h - height(obj) + oi
    new_j =  oj
    moved_objs = moved_objs | shift(obj, (new_i - oi, new_j - oj))
  O = paint(canvas(ZERO, (h, w)), moved_objs)
  return O
 
12.333333333333334, tensor(1.7886), Description: Copy the input grid exactly.  If a square is colored in the input grid, it should be colored in the output grid.  If a square is black in the input grid, it should be black in the output grid. 
:: def dahbcgaaiebfedfhjfbjafjaafffecea(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h = len(I)
  return tuple(
      tuple(
          v if (v, (i, j)) in objs
        else ZERO
        for j, v in enumerate(row)
      ) 
    for i, row in enumerate(I)
  )
 
24.0, tensor(0.0558), Description: Move all pixels down. The colors do not change. Simply move all pixels down until they sit on top of each other. There should not be any black pixels between the same color in a column. 
:: def dfaidbahjhicefjgbheefieiiahhfcce(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for j in range(w):
    for i in range(h - 1, -1, -1):
      if I[i][j] != ZERO:
        new_i = h - 1
        while new_i > 0 and O[new_i][j] != ZERO:
          new_i -= 1
        O = paint(O, {(I[i][j], (new_i, j))})
  return O
 
21.666666666666668, tensor(0.0086), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def dbcejjbeibijedcdbcbffbcjbbebebfa(I):
  # Identify objects 
  objs = objects(I, T, F, T)
  
  # Create a canvas with the same dimensions as the input
  O = canvas(mostcolor(I), shape(I))
  
  # Calculate and apply shift for each object
  for i, obj in enumerate(order(objs, uppermost)):
    O = paint(O, shift(obj, (len(I) - lowermost(obj) - i, 0)))
  return O
 
19.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def fcgiehgjgehdebbbigdhddbaegbjbegb(I):
  # Identify objects
  objs = objects(I, T, F, T)
  
  # Find maximum height of all objects
  max_height = valmax(objs, height)
  
  # Calculate and apply shift for each object
  O = I
  for obj in objs:
    O = paint(cover(O, obj), shift(obj, (len(I) - lowermost(obj) - max_height, 0)))
  return O
 
18.333333333333332, tensor(0.0116), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bdecheecafhaegbdifddgdebdbbjdagf(I):
  # Reverse the input grid vertically
  I_reversed = vmirror(I)
  
  # Identify objects in the reversed grid
  objs = objects(I_reversed, T, F, T)
  
  # Calculate and apply shift for each object in reversed grid
  O = I_reversed
  for i, obj in enumerate(order(objs, uppermost)):
    O = paint(cover(O, obj), shift(obj, (-i, 0)))
  
  # Reverse the output grid vertically to get the final output
  O = vmirror(O)
  return O
 
16.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def habccacdeaddecadjicjaebbijgegebd(I):
  # Create a dictionary to store object information
  obj_data = {}
  for i, obj in enumerate(objects(I, T, F, T)):
    obj_data[i] = {'obj': obj, 'bottom': lowermost(obj)}
  
  # Sort object data based on bottom row index
  sorted_obj_data = dict(sorted(obj_data.items(), key=lambda item: item[1]['bottom']))
  
  # Calculate and apply shift for each object
  O = I
  shift_amount = 0
  for i in sorted_obj_data:
    obj = sorted_obj_data[i]['obj']
    O = paint(cover(O, obj), shift(obj, (len(I) - sorted_obj_data[i]['bottom'] + shift_amount, 0)))
    shift_amount += height(obj)
  return O
 
16.666666666666668, tensor(0.1613), Description: Move the red shape 6 squares up and the light blue shape 2 squares up. The background should be black. 
:: def fgbeadhaacdbeaeejhfaedfbccebjcbh(I):
  O = canvas(0, shape(I))
  for v in (2, 8):
    objs = colorfilter(objects(I, T, F, T), v)
    obj = merge(objs)
    offset = (-6, 0) if v == 2 else (-2, 0)
    O = paint(O, shift(obj, offset))
  return O
 
23.333333333333332, tensor(0.0137), Description: Move each colored square to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def fccchdcceffeefbgijacbffefacdehfa(I):
    bg = mostcolor(I)
    colored_indices = ofcolor(I, TWO) | ofcolor(I, EIGHT)
    target_indices = shift(colored_indices, (height(I) - 1 - lowermost(colored_indices), 0))
    O = I
    for i, j in colored_indices:
        O = fill(O, bg, ((i, j),))
    for i, j in target_indices:
        O = fill(O, I[i - height(I) + 1 + lowermost(colored_indices)][j], ((i, j),))
    return O
 
18.333333333333332, tensor(0.0137), Description: Move each colored square to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def ebdbcchcjeeeefgabfeffffdibadidca(I):
    O = canvas(mostcolor(I), shape(I))
    for i in range(height(I)):
        for j in range(width(I)):
            if I[i][j] in {TWO, EIGHT}:
                O = fill(O, I[i][j], ((height(I) - 1 - i, j),))
    return O
 
8.333333333333334, tensor(0.0154), Description: Move the largest colored shape to the bottom right corner of the grid, keeping its original orientation. The background should be black. 
:: def bgdhbaaifiaiecaaijdebdcgefggbdfb(I):
  x1 = objects(I, T, F, T)
  x2 = argmax(x1, size) 
  x3 = ulcorner(x2)
  x4 = subtract((len(I),0), shape(x2))
  x5 = add(x3, x4)
  x6 = shift(x2, x5)
  O = paint(cover(I, x2), x6)
  return O
 
12.333333333333334, tensor(0.0166), Description: Move each colored shape to the bottom right corner of the grid, keeping its original orientation. The background should be black. 
:: def habffbadfbibeggbihbjddhibhcechei(I):
  x1 = objects(I, T, F, T)
  O = I
  for x2 in x1:
    x3 = ulcorner(x2)
    x4 = subtract((len(I),0), shape(x2))
    x5 = add(x3, x4)
    x6 = shift(x2, x5)
    O = paint(cover(O, x2), x6)
  return O
 
16.0, tensor(0.0155), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def hajedgefcaaceehjabiefegaeaigcibc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  occupied = set()
  for i in range(h - 1, -1, -1):
    for j in range(w):
      if (i, j) not in occupied:
        for obj in objs:
          if (i, j) in toindices(shift(obj, (h - 1 - uppermost(obj), 0))):
            O = paint(O, shift(obj, (i - uppermost(obj), 0)))
            occupied = occupied | toindices(shift(obj, (i - uppermost(obj), 0)))
            break
  return O
 
21.0, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def cheagebbcgafecjgbbeeciccbbfdafca(I):
  # Identify objects
  objs = objects(I, T, F, T)

  # Create a list to store sorted objects
  sorted_objs = []

  # Iterate through rows from bottom to top
  for i in range(len(I)-1, -1, -1):
    # Iterate through objects
    for obj in objs:
      # If object's lowermost row is current row, add to sorted list
      if lowermost(obj) == i:
        sorted_objs.append(obj)

  # Calculate and apply shift for each object
  O = I
  for i, obj in enumerate(sorted_objs):
    O = paint(cover(O, obj), shift(obj, (len(I) - lowermost(obj) - i, 0)))
  return O
 
16.0, tensor(0.0191), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved:: def bbcbidgcfaededbaiabcddaabacdjfde(I):
  # Identify objects and maximum height
  objs = objects(I, T, F, T)
  max_height = valmax(objs, height)

  # Sort objects based on uppermost row index
  sorted_objs = order(objs, uppermost)

  # Calculate and apply shift for each object
  O = I
  for i, obj in enumerate(sorted_objs):
    shift_amount = len(I) - max_height - i * max_height
    O = paint(cover(O, obj), shift(obj, (shift_amount, 0)))
  return O
 
23.0, tensor(0.0097), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bacbabbabfdjebdaieejifeeaejaafbc(I):
  O = canvas(0, shape(I))
  offset = (0, 0)
  for v in sorted(palette(I) - {mostcolor(I)}):
    objs = colorfilter(objects(I, T, F, T), v)
    obj = merge(objs)
    O = paint(O, shift(obj, offset))
    offset = (offset[0] + height(obj), offset[1])
  return O
 
17.333333333333332, tensor(0.0116), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def bhddbcgfahfaeiecaeaedeaafacbdfdf(I):
    objs = sorted(objects(I, T, F, T), key=lambda obj: color(obj))
    g = canvas(0, shape(I))
    bottom = height(g)
    for obj in objs:
      g = paint(g, shift(obj, (bottom - height(obj), 0)))
      bottom -= height(obj)
    return g
 
61.0, tensor(0.0116), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def acjdjbaaaddcebcdbdccgefbbicigdfd(I):
  O = I
  for v in sorted(palette(I) - {mostcolor(I)}):
    obj = merge(colorfilter(objects(I, T, F, T), v))
    O = vconcat(cover(O, obj), paint(canvas(0, (height(obj), width(O))), obj))
  return O
 
9.666666666666666, tensor(0.0095), Description: Move each colored shape to the 9th row of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def icbcfhabefgbeaecafdcdbffcacgbeia(I):
    # Identify objects in the input grid
    objs = objects(I, T, F, T)
    
    # Function to move an object 
    def move_object(obj):
      # Calculate the vertical shift for the object
      shift_amount = ulcorner(obj)[0] - 9  # Replace 9 with the desired row index
      # Shift the object vertically
      return shift(obj, (shift_amount, 0))
    
    # Move all objects 
    moved_objs = apply(move_object, objs)
    
    # Paint the moved objects onto a blank canvas 
    O = paint(canvas(ZERO, shape(I)), merge(moved_objs))
    return O
 
15.333333333333334, tensor(0.0184), Description: Move the red shape to the 9th row and the light blue shape to the 11th row, keeping the same horizontal position. The background should be black. 
:: def ffcfaefdcdhgedcebbcfhbcjdeaebfbe(I):
  def move_obj(obj, shift_amount):
    return shift(obj, (shift_amount, 0))
  
  objs = objects(I, T, F, T)
  obj_2 = extract(objs, lambda obj: color(obj) == TWO)
  obj_8 = extract(objs, lambda obj: color(obj) == EIGHT)
  
  target_row_2 = 9 # Replace with desired target row for color 2
  target_row_8 = 11 # Replace with desired target row for color 8

  moved_obj_2 = move_obj(obj_2, target_row_2 - ulcorner(obj_2)[0])
  moved_obj_8 = move_obj(obj_8, target_row_8 - ulcorner(obj_8)[0])
  
  O = paint(cover(I, obj_2), moved_obj_2)
  O = paint(cover(O, obj_8), moved_obj_8)
  return O
 
14.333333333333334, tensor(0.1623), Description: Move the red shape 6 squares up and the light blue shape 2 squares up. The background should be black. 
:: def icdieebcgjcieabdjffbadcfbgbcffdd(I):
    # Function to calculate shift amount based on color
    def get_shift_amount(v):
        return {TWO: 6, EIGHT: 2}.get(v, 0) # Adjust shift values for each color

    objs = objects(I, T, F, T)

    def move_object(obj):
        shift_amount = get_shift_amount(color(obj))
        return shift(obj, (shift_amount, 0))

    moved_objs = apply(move_object, objs)
    O = paint(canvas(ZERO, shape(I)), merge(moved_objs))
    return O
 
23.0, tensor(0.0155), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bjfcgcfdbdacedjcjhajdfbcfcdhcihb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for obj in objs:
    target_i = h - height(obj)
    for i in range(h - 1, -1, -1):
      if len(intersection(toindices(shift(obj, (i - uppermost(obj), 0))), asindices(O))) > 0:
        break
      target_i = i
    O = paint(O, shift(obj, (target_i - uppermost(obj), 0)))
  return O
 
22.0, tensor(0.0149), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def dfcfeceidjbaeihebbfabdfeheheaefa(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for obj in sorted(objs, key=lambda obj: uppermost(obj)):
    for i in range(h - height(obj), -1, -1):
      if not any(index(O, (row, col)) != ZERO for row, col in toindices(shift(obj, (i - uppermost(obj), 0)))):
        O = paint(O, shift(obj, (i - uppermost(obj), 0)))
        break
  return O
 
24.0, tensor(0.0122), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. If there is no space for a shape at the top, it should be placed at its original position. 
:: def iacfbcfgfcgceacbaadfciidedfbaafc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for obj in objs:
    obj_height = height(obj)
    placed = False
    for i in range(h - obj_height, -1, -1):
      new_obj = shift(obj, (i - uppermost(obj), 0))
      if all(index(O, (row, col)) == ZERO for row, col in toindices(new_obj)):
        O = paint(O, new_obj)
        placed = True
        break
    if not placed: 
      O = paint(O, obj) # Place at original position if no space
  return O
 
21.0, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def fdbahgdbgjdcedfgibcaiffacedbgddc(I):
  # Identify objects and sort based on lowermost row
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lowermost)

  # Calculate and apply shift for each object
  O = I
  for i, obj in enumerate(sorted_objs):
    shift_amount = height(I) - lowermost(obj) - i * height(obj)
    O = paint(cover(O, obj), shift(obj, (shift_amount, 0)))
  return O
 
23.0, tensor(0.0105), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the highest bottommost row at the bottom and the shape with the lowest bottommost row at the top. 
:: def cbdeacahjhceebaabibcbeacbjejjdeb(I):
  # Identify objects
  objs = objects(I, T, F, T)

  # Create a canvas with background color and same dimensions as input
  O = canvas(mostcolor(I), shape(I))

  # Paint objects onto the canvas from bottom to top
  for i, obj in enumerate(order(objs, lambda obj: -lowermost(obj))):
    O = paint(O, shift(obj, (len(I) - lowermost(obj) - 1, 0)))
  return O
 
21.0, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def igiaggdffcahebdbbedaagcbghhhhjce(I):
  # Identify objects and their bottom row indices
  objs = objects(I, T, F, T)
  bottom_rows = apply(lowermost, objs)

  # Create a dictionary mapping bottom row to object
  row_to_obj = dict(zip(bottom_rows, objs))

  # Iterate through rows from bottom to top
  O = I
  current_row = len(I) - 1
  while current_row >= 0:
    if current_row in row_to_obj:
      obj = row_to_obj[current_row]
      shift_amount = current_row - uppermost(obj)
      O = paint(cover(O, obj), shift(obj, (shift_amount, 0)))
    current_row -= 1
  return O
 
18.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def edgjfggifcgcegecacfgfecjajceghhe(I):
  # Create a new grid with the same dimensions and background
  O = canvas(mostcolor(I), shape(I))

  # Iterate through rows from bottom to top
  for i in range(len(I) - 1, -1, -1):
    # Extract row and identify objects within it
    row = I[i]
    row_objs = objects(
        (row,), T, F, T
    )

    # Calculate and apply shift for each object in the row
    for obj in row_objs:
      shift_amount = len(I) - i - height(obj)
      O = paint(O, shift(obj, (shift_amount, 0)))

  return O
 
18.666666666666668, tensor(0.0093), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. 
:: def igaijghcbfaiebdgidbeggafaefiaeda(I):
  O = canvas(0, shape(I))
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj), reverse=T)
  bottom = height(I)
  for obj in objs:
    O = paint(O, shift(obj, (bottom - height(obj), 0)))
    bottom -= height(obj)
  return O
 
123.33333333333333, tensor(0.0108), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def gbbejfafcjeaegidbgiffefgjafhebei(I):
    objs = objects(I, T, F, T)
    h = height(I)
    return tuple(
        tuple(
            next((v for v, (i2, j2) in obj if i2 == i-h+height(obj) and j2 == j), 0) 
            for j in range(width(I))
        )
        for obj in objs
        for i in range(h)
    )
 
18.333333333333332, tensor(0.0100), Description: Move each colored square to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bbdagcbajbjjebiebdiicdedeafjaccc(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != mostcolor(I):
        O = paint(O, {(v,(len(I)-1-i,j))})
  return O
 
23.0, tensor(0.0108), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def chifdbejfebaefadbcjbbjadeedabjcf(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, shift(obj, (height(I)-height(obj)-uppermost(obj), 0)))
  return O
 
21.333333333333332, tensor(0.0210), Description:  Flip the input grid vertically. Then, sort the colored shapes in the flipped grid by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. Move each shape down, keeping the same horizontal position, so that the shapes are stacked on top of each other with no gaps. The background should be black. Finally, flip the grid vertically again to get the final output. 
:: def facdaaabafchebbjibbcfccdbfegebfc(I):
  O = vmirror(I)
  objs = sorted(objects(O, T, F, T), key=lambda obj: uppermost(obj))
  bottom = 0
  for obj in objs:
    O = paint(cover(O, obj), shift(obj, (bottom, 0)))
    bottom += height(obj)
  return vmirror(O)
 
15.333333333333334, tensor(0.0184), Description: Move the red shape to the 9th row and the light blue shape to the 11th row, keeping the same horizontal position. The background should be black. 
:: def eiffcdgfdfbeeifabicadgdbjddbiaii(I):
  def move_to_row(obj, target_rows):
    c = color(obj)
    return shift(obj, (target_rows.get(c, 0) - uppermost(obj), 0))
  target_rows = {TWO: 9, EIGHT: 11}
  objs = objects(I, T, F, T)
  moved_objs = frozenset(move_to_row(obj, target_rows) for obj in objs)
  return paint(cover(I, merge(objs)), merge(moved_objs))
 
23.0, tensor(0.0129), Description: Move each colored shape to the left edge of the grid, keeping the same vertical position. The shapes should be stacked next to each other, with no gaps between them. The background should be black. The shapes should be moved left so that the left edge of each shape is aligned with the left edge of the grid. The shapes should be stacked next to each other, with no gaps between them. The background should be black. 
:: def gabiiaijgacaebcdjeicadaacajbebdb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  moved_objs = frozenset()
  h, w = len(I), len(I[0])
  for obj in objs:
    new_i = h - height(obj) 
    new_j = leftmost(obj)
    moved_objs = moved_objs | shift(obj, (new_i - uppermost(obj), new_j - leftmost(obj))) 
  O = paint(canvas(ZERO, (h, w)), moved_objs)
  return O
 
20.666666666666668, tensor(1.9772), Description: Sort the colors in each column of the input grid from black to the most colored square.  The output grid should have the same colors in each column, but in the sorted order.  The background should be black. 
:: def gibdbafidfiaefgebfbffghhfhbccbhi(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for j in range(w):
    column = [I[i][j] for i in range(h)]
    sorted_column = sorted(column, key=lambda x: x == ZERO)
    for i, val in enumerate(sorted_column):
      O = fill(O, val, {(i, j)})
  return O
 
17.666666666666668, tensor(0.0558), Description: Move all pixels down. The colors do not change. Simply move all pixels down until they sit on top of each other. There should not be any black pixels between the same color in a column. 
:: def hafefdfbhdebefjbaabicccjaeabbcch(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  non_zero_indices = []
  for i in range(h):
    for j in range(w):
      if I[i][j] != ZERO:
        non_zero_indices.append((i, j))
  non_zero_indices.sort(key=lambda x: x[1]) 
  new_i = h - 1
  for i, j in non_zero_indices:
    while new_i >= 0 and O[new_i][j] != ZERO:
      new_i -= 1
    O = fill(O, I[i][j], {(new_i, j)})
    new_i -= 1 
  return O
 
15.333333333333334, tensor(0.0114), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def bebebafdbeeheaaabjfcjejcbgceefeh(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(order(objs, lambda obj: uppermost(obj))):
    O = paint(O, shift(obj, (len(I) - height(obj) - i * height(obj), 0)))
  return O
 
16.666666666666668, tensor(0.0094), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def bhcjfccfgcfiedeaahaejbbiajbaieed(I):
  objs = objects(I, T, F, T)
  cumulative_height = 0
  O = canvas(mostcolor(I), shape(I))
  for obj in order(objs, lambda obj: uppermost(obj)):
    O = paint(O, shift(obj, (len(I) - height(obj) - cumulative_height, 0)))
    cumulative_height += height(obj)
  return O
 
18.666666666666668, tensor(0.0095), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. 
:: def cdgddhfffjfgeeccibiibdfgdbbbjfji(I):
  objs = objects(I, T, F, T)
  bottom = len(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in order(objs, lambda obj: -uppermost(obj)):
    bottom -= height(obj)
    O = paint(O, shift(obj, (bottom, 0)))
  return O 
 
19.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def abdbchcgcicdebcfbeddaecfchjabbba(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: shift(obj, (len(I) - lowermost(obj), 0)), objs)))
  return O
 
18.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def bhebbbjbedabeaigbieijbfedbccgjid(I):
  objs = objects(I, T, F, T)
  shifted_objs = apply(lambda obj: shift(obj, (len(I) - lowermost(obj) - sum(height(o) for o in objs if uppermost(o) < uppermost(obj)), 0)), objs) 
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
20.666666666666668, tensor(0.0092), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def dbgbgeaafefcehadbjdafcacaadghdaa(I):
  O = canvas(0, shape(I))
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj))
  bottom = height(I)
  for obj in objs:
    O = paint(O, shift(obj, (bottom - height(obj) - uppermost(obj), 0)))
    bottom -= height(obj)
  return O
 
23.0, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def ccaifejffebjefecacfbfgcbcccdfdid(I):
  bg = mostcolor(I)
  h = height(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, True, False, False):
    if color(obj) in {TWO, EIGHT}:
      O = paint(O, shift(obj, (h - 1 - lowermost(obj), 0)))
  return O
 
22.666666666666668, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def fchefbcffcfiedijbdicibebcicgecfc(I):
  bg = mostcolor(I)
  h, w = shape(I)
  O = I
  for i in range(h):
    for j in range(w):
      if I[i][j] in {TWO, EIGHT}:
        O = fill(O, bg, ((i, j),))
        O = fill(O, I[i][j], ((h - 1 - (i - uppermost(ofcolor(I, I[i][j]))), j),))
  return O
 
23.333333333333332, tensor(0.1052), Description: Move all pixels down. The colors do not change. Simply move all pixels down until they sit on top of each other. There should not be any black pixels between the same color in a column. The colors in each column should be sorted from black to the most colored square. The background should be black. 
:: def ehbccgacgeaheiedjeeefididfahdcdb(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for j in range(w):
    column = {index(I, (i, j)) for i in range(h)} - {ZERO}
    offset = 0
    for c in sorted(column):
      obj = {(c, (i, j)) for i in range(h) if index(I, (i, j)) == c}
      O = paint(O, shift(obj, (h - uppermost(obj) - height(obj) - offset, 0)))
      offset += height(obj)
  return O
 
14.666666666666666, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def cfcjdfabdcdbeeddadeaidecgfeigfie(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(order(objs, lowermost)):
    O = paint(O, shift(obj, (-i * height(obj), 0)))
  return O
 
20.0, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def bbcacbageadieejfbacfacbacifcdjhh(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: lowermost(obj))
  h = height(I)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(obj, (h - lowermost(obj) - i * height(obj) - 1, 0)))
  return O
 
21.333333333333332, tensor(0.0112), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the highest bottommost row at the bottom and the shape with the lowest bottommost row at the top. 
:: def ejdcddfedbdceebdjfbhhdjffjeiddie(I):
  O = canvas(mostcolor(I), shape(I))
  y_offset = 0
  for i in range(height(I)-1, -1, -1):
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        obj = extract(objects(I, T, F, T), lambda obj: (i,j) in toindices(obj))
        O = paint(O, shift(obj, (y_offset, 0)))
        y_offset += height(obj)
        break
  return O
 
21.333333333333332, tensor(0.0086), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def bfaadbfdjjadeifaibeeiifacbfejedf(I):
  objs = objects(I, T, F, T)
  O = I
  occupied = set()
  for obj in sorted(objs, key=lambda obj: lowermost(obj)):
    shift_amount = len({i for i in range(height(O)) if any((i, j) in occupied for j in range(width(O)))})
    O = paint(cover(O, obj), shift(obj, (shift_amount, 0)))
    occupied = occupied.union(toindices(shift(obj, (shift_amount, 0))))
  return O
 
43.0, tensor(0.1025), Description: Move all pixels down. The colors do not change. Simply move all pixels down until they sit on top of each other. There should not be any black pixels between the same color in a column. The colors in each column should be sorted from black to the most colored square. The background should be black. 
:: def beiddfibcehaejghifcabddfdciehaed(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    column = tuple(I[i][j] for i in range(height(I)))
    non_bg = tuple((v, i) for i, v in enumerate(column) if v != mostcolor(I))
    y_offset = 0
    for v, i in non_bg:
      O = paint(O, {(v, (y_offset + k, j)) for k in range(i + 1)})
      y_offset += i + 1
  return O
 
24.0, tensor(0.0093), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. 
:: def babddbeecjdieaibiaefbedfefgfbagd(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj), reverse=True)
  g = canvas(0, shape(I))
  bottom = height(g)
  for obj in objs:
    g = paint(g, shift(obj, (bottom - uppermost(obj) - height(obj), 0)))
    bottom -= height(obj)
  return g
 
16.333333333333332, tensor(0.0091), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the highest bottommost row at the bottom and the shape with the lowest bottommost row at the top. 
:: def aibbbjbhdjaheiaajeiddcdchdgejdhb(I):
  objs = objects(I, T, F, T)
  h = height(I)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(sorted(objs, key=lambda obj: h - lowermost(obj))):
    O = paint(O, shift(obj, (-i * height(obj), 0)))
  return O
 
18.666666666666668, tensor(0.0091), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the highest bottommost row at the bottom and the shape with the lowest bottommost row at the top. 
:: def cjdbiihfgbcfehbdjeffifeaaheacgca(I):
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(sorted(objects(I, T, F, T), key=lambda x: -lowermost(x))):
    O = paint(O, shift(obj, (height(I) - (i + 1) * height(obj), 0)))
  return O
 
126.66666666666667, tensor(0.0092), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def iahbhadeffgcedfdiihhfheeadgcdbgb(I):
    return tuple(
        tuple(
            next(
                (v for v, (i2, j2) in obj if i2 == i - (height(I) - sum(height(o) for o in objects(I, T, F, T))) + uppermost(obj) and j2 == j),
                0,
            )
            for j in range(width(I))
        )
        for obj in sorted(objects(I, T, F, T), key=lambda x: uppermost(x))
        for i in range(height(I))
    )
 
22.666666666666668, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def geiefjcacabbefhdbeijgebfchfegbee(I):
  bg = mostcolor(I)
  h, w = shape(I)
  O = canvas(bg, (h, w))
  for obj in objects(I, True, False, False):
    if color(obj) in {2, 8}:
      for _, (i, j) in obj:
        O = fill(O, I[i][j], ((h - 1 - (i - uppermost(obj)), j),))
  return O
 
24.0, tensor(0.0174), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by height, with the tallest shape at the bottom and the shortest shape at the top. If there is no space for a shape at the top, it should be placed at its original position. 
:: def fichjhefbhacedehjehbedjhhcjicdab(I):
  objs = order(objects(I, univalued=True, diagonal=False, without_bg=True), compfunc=height)
  h = height(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    for i in range(h - height(obj), -1, -1):
      shifted_obj = shift(obj, (i, 0))
      if all(index(O, (si, sj)) == ZERO for _, (si, sj) in shifted_obj):
        O = paint(O, shifted_obj)
        break
  return O
 
20.0, tensor(0.0103), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their bottommost row, with the shape with the lowest bottommost row at the bottom and the shape with the highest bottommost row at the top. 
:: def cdefgecafgfaebfebbfgagjffdeddabb(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lowermost)
  O = I
  for obj in sorted_objs:
    O = paint(cover(O, obj), shift(obj, (lowermost(obj) - uppermost(obj), 0)))
  return O
 
19.333333333333332, tensor(0.0106), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def cdeghfiegdceeigeiifeafgbddfcjdic(I):
    objs = objects(I, T, F, T)
    O = canvas(0, shape(I))
    for obj in objs:
        shifted_obj = shift(obj, (len(I) - lowermost(obj), 0))
        O = paint(O, shifted_obj)
    return O
 
24.0, tensor(0.0541), Description: Move all pixels down. The colors do not change. Simply move all pixels down until they sit on top of each other. There should not be any black pixels between the same color in a column. The background should be black. 
:: def ffeccbbaigcieadfaabddiejabjiajff(I):
  h, w = len(I), len(I[0])
  O = list(list(0 for _ in range(w)) for _ in range(h))
  for j in range(w):
    non_zero = [(I[i][j], i) for i in range(h) if I[i][j] != 0]
    for k, (v, _) in enumerate(reversed(non_zero)):
      O[h - 1 - k][j] = v
  return tuple(tuple(row) for row in O)
 
21.333333333333332, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def eifabdbhdcbfeaedabdaiedejecghgde(I):
  bg = mostcolor(I)
  h = height(I)
  moved_cells = frozenset((I[i][j], (h - 1 - i + uppermost(obj), j)) for obj in objects(I, True, False, False) if color(obj) in {2, 8} for i in range(h) for j in range(width(I)) if (I[i][j] == 2 or I[i][j] == 8))
  O = paint(canvas(bg, shape(I)), moved_cells)
  return O
 
15.666666666666666, tensor(0.0184), Description: Move the red shape to the 9th row and the light blue shape to the 11th row, keeping the same horizontal position. The background should be black. 
:: def eabceegcadadecfcbheibdghddgefagj(I):
  def move_to_target(grid, value, target_row):
    objs = objects(grid, T, F, T)
    obj = extract(objs, lambda obj: color(obj) == value)
    return paint(cover(grid, obj), shift(obj, (target_row - uppermost(obj), 0)))
  
  O = move_to_target(I, 2, 9)
  O = move_to_target(O, 8, 11)
  return O
 
20.666666666666668, tensor(0.0183), Description: Description: Move the red shape to the 9th row and the light blue shape to the 11th row, keeping the same horizontal position. The background should be black. 
:: def gecagddcgficeibfibdaaieecfbgdedi(I):
  def move_to_row(obj, target_row):
    return paint(cover(I, obj), shift(obj, (target_row - uppermost(obj), 0)))

  objs = objects(I, T, F, T)
  obj_2 = extract(objs, lambda obj: color(obj) == 2)
  obj_8 = extract(objs, lambda obj: color(obj) == 8)
  
  O = move_to_row(obj_2, 9)
  O = move_to_row(obj_8, 11)
  return O
 
13.0, tensor(0.0136), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. If a shape would collide with another shape when moved down, it should be placed as high as possible without colliding. The background should be black. 
:: def ggcidccfdfdaebgbabecccfjjfbjacch(grid):
  """
  This version uses object manipulation and checks for collision before moving objects down.
  """
  objs = objects(grid, T, F, T)
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    offset = (0, 0)
    while offset[0] < height(grid) - height(obj):
      down_offset = (offset[0] + 1, 0)
      shifted_obj = shift(obj, down_offset)
      if any((i, j) in toindices(o) for o in objs - {obj} for i, j in toindices(shifted_obj)):
        break
      offset = down_offset
    new_grid = paint(new_grid, shift(obj, offset))
  return new_grid
 
20.666666666666668, tensor(0.0089), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, then by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def gcdffjfceebceceibgcachgfbbefcacf(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: (color(obj), uppermost(obj)))
  output_grid = canvas(0, shape(I))
  current_row = height(I)
  for obj in objs:
    current_row -= height(obj)
    output_grid = paint(output_grid, shift(obj, (current_row - uppermost(obj), 0)))
  return output_grid
 
24.666666666666668, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def jehcfbhjjfbjeecbjhfdbaijcdgaaaeg(I):
  O = canvas(0, shape(I))
  objs = sorted(objects(I, T, F, T), key=lambda o: color(o))
  offset = (height(I), 0)
  for obj in objs:
    offset = (offset[0] - height(obj), 0)
    O = paint(O, shift(obj, subtract(offset, ulcorner(obj))))
  return O
 
17.333333333333332, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def eifffbfjhhcfebgbigaeahbagheegdff(I):
    bg = mostcolor(I) # Identify background color
    h = height(I) # Get grid height
    new_grid = canvas(bg, shape(I)) # Create a new grid filled with the background color
    for i, row in enumerate(I): # Iterate over each row in the input grid
        for j, val in enumerate(row): # Iterate over each cell in the row
            if val in {2, 8}: # Check if the cell value is 2 or 8
                new_grid = fill(new_grid, val, ((h - 1, j),)) # Place the value at the bottom of the corresponding column
    return new_grid
 
19.333333333333332, tensor(0.0134), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def ffafcfbebgeeeefdaffhaeacebgceajc(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True) # Extract objects, excluding background
    moved_objs = apply(lambda obj: shift(obj, (height(I) - lowermost(obj), 0)), objs) # Move each object down
    return paint(canvas(bg, shape(I)), merge(moved_objs)) # Combine and paint objects onto a new canvas
 
12.333333333333334, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def ffdbhddhbaageijfbbbgjfbjeccdhihi(I):
  bg = mostcolor(I)
  h = height(I)
  return tuple(
      tuple(
          v if v not in {2, 8} else I[i - h + lowermost(ofcolor(I, v))][j]
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
23.0, tensor(0.0155), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def dfbcebafjiebehhdaigbfbfcagfbecfd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  h = height(I)
  O = canvas(ZERO, shape(I))
  for i in range(h):
    for obj in objs:
      if uppermost(obj) == i:
        O = paint(O, shift(obj, (h - height(obj) - i, 0)))
  return O
 
20.666666666666668, tensor(0.0094), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def caaedcabbgbdebaeiafefabcjcefffie(I):
  objs = objects(I, T, F, T)  # Identify objects without considering diagonals or background
  sorted_objs = order(objs, uppermost) # Sort objects by their uppermost row
  O = I
  current_height = height(I)  # Start placing objects from the bottom row of the grid
  for obj in sorted_objs:
    O = paint(cover(O, obj), shift(obj, (current_height - height(obj) - uppermost(obj), 0)))  # Shift object to its new position 
    current_height -= height(obj) # Update current height to place next object above
  return O
 
24.0, tensor(0.0095), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. 
:: def edecbfbaceacebgdjijbhejehiiafabj(I):
    objs = objects(I, T, F, T)
    O = canvas(mostcolor(I), shape(I)) # Create a blank canvas with the background color
    bottom = height(I)
    for obj in order(objs, lambda obj: -uppermost(obj)):  # Sort objects in descending order of their uppermost row
        O = underpaint(O, shift(obj, (bottom - uppermost(obj) - height(obj), 0))) # Paint each object at its new position from bottom to top
        bottom -= height(obj)
    return O
 
13.666666666666666, tensor(0.0105), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def febcfcdibibbeadgbcihbighccdahhia(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I) - {mostcolor(I)}):
    obj = merge(colorfilter(objects(I, T, F, T), c))
    O = vconcat(crop(O, (0, 0), (height(O) - height(obj), width(O))), 
                  paint(canvas(mostcolor(I), (height(obj), width(O))), obj))
  return O
 
23.0, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def cbjidhbahcfdegfcbejhdeeeaieadehe(I):
  def stack_objects(grid, objs):
    if not objs:
      return grid
    obj = objs[0]
    remaining_objs = objs[1:]
    new_grid = paint(grid, shift(obj, (height(grid) - height(obj) - uppermost(obj), 0)))
    return stack_objects(new_grid, remaining_objs)

  objs = sorted((obj for obj in objects(I, T, F, T) if color(obj) != mostcolor(I)), key=lambda obj: color(obj))
  return stack_objects(canvas(mostcolor(I), shape(I)), objs)
 
61.333333333333336, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def fegidgjbaddbedcfibjeffhaaeejecai(I):
  bg = mostcolor(I)
  h = height(I)
  return tuple(
      tuple(
          bg if v in {2, 8} else v 
          for v in row
      )
      for i, row in enumerate(I)
  ) + tuple(
      tuple(
          2 if I[i - h + lowermost(ofcolor(I, 2))][j] == 2 else (8 if I[i - h + lowermost(ofcolor(I, 8))][j] == 8 else bg)
          for j in range(len(I[0]))
      )
      for i in range(h - lowermost(ofcolor(I, 2)), h)
  )
 
19.333333333333332, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def fghechbiidajeddbbdgiiddefcfhbdfd(I):
  bg = mostcolor(I)
  h = height(I)
  new_grid = canvas(bg, shape(I))
  for c in {2, 8}:
    obj_indices = ofcolor(I, c)
    offset = h - lowermost(obj_indices)
    new_indices = shift(obj_indices, (offset, 0))
    new_grid = fill(new_grid, c, new_indices)
  return new_grid
 
63.333333333333336, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bfdebaefahcdefgcadcffebdacbcbeha(I):
  bg = mostcolor(I)
  h = height(I)
  return tuple(
    tuple(
      bg if any(I[k][j] == v for k in range(i)) and v in {2, 8} else v 
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
  ) + tuple(
    tuple(
      v if v not in {2, 8} else I[i - h + lowermost(ofcolor(I, v))][j] 
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I[h - lowermost(ofcolor(I, 2)):])
  )
 
61.333333333333336, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bcacfbdadjfdebfajbdidfecbeefeabj(I):
  bg = mostcolor(I)
  h = height(I)
  return tuple(
    tuple(
      bg if I[i][j] in {2, 8} else I[i][j] 
      for j in range(len(I[0]))
    ) 
    for i in range(h)
  ) + tuple(
    tuple(
      2 if any(I[k][j] == 2 for k in range(h)) else (8 if any(I[k][j] == 8 for k in range(h)) else bg)
      for j in range(len(I[0]))
    )
    for i in range(h - lowermost(ofcolor(I, 2)), h)
  )
 
16.666666666666668, tensor(0.0281), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. If a shape would collide with another shape when moved up, it should be placed as low as possible without colliding. The background should be black. 
:: def ebadadifjffcedbfibjccaiaieabcfeg(I):
  objs = sorted(objects(I, univalued=True, diagonal=False, without_bg=True), key=lambda obj: -uppermost(obj))
  grid = I
  for obj in objs:
    for i in range(1, height(I)):
      if not vmatching(shift(obj, (i, 0)), toobject(asindices(grid), grid)):
        grid = paint(cover(grid, obj), shift(obj, (i, 0)))
        break
  return grid 
 
21.333333333333332, tensor(0.0155), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def hjaabafdcfdbecaciceeicffeijcidei(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  output = canvas(ZERO, shape(I))
  for i in range(height(I) - 1, -1, -1):
    for j in range(width(I)):
      for obj in objs:
        if (i, j) in toindices(shift(obj, (height(I) - height(obj) - uppermost(obj), 0))):
          output = paint(output, {(index(I, (uppermost(obj), j)), (i, j))}) 
  return output
 
22.333333333333332, tensor(0.0111), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by color, with the lowest color at the bottom and the highest color at the top. 
:: def fbdfeecedefdeeddibagbcabejcaiecb(I):
  objs = [obj for obj in objects(I, T, F, T) if color(obj) != mostcommon(I)]
  output = canvas(mostcolor(I), shape(I))
  y = height(output) - 1
  for obj in sorted(objs, key=lambda obj: color(obj)):
    output = paint(output, shift(obj, (y - uppermost(obj) - height(obj), 0)))
    y -= height(obj)
  return output
 
19.333333333333332, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def bcehciagbaaeeebdadicfhjefjaidadi(I):
  bg = mostcolor(I) # Identify background color
  h = height(I) # Get the height of the grid
  new_grid = canvas(bg, shape(I)) # Create a blank canvas
  for obj in objects(I, True, False, False): # Iterate over connected components
    if color(obj) in {2, 8}: # Check if the object's color is 2 or 8
      new_obj = shift(obj, (h - lowermost(obj), 0)) # Shift the object to the bottom
      new_grid = paint(new_grid, new_obj) # Paint the shifted object onto the new grid
  return new_grid
 
14.333333333333334, tensor(0.0154), Description: Move each colored square (red or light blue) to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def efadddcdjaecebididehcbbdjbcahgba(I):
    bg = mostcolor(I)
    h = height(I)
    return tuple(
        tuple(
            bg if any(I[k][j] == v and v in {2, 8} for k in range(i + 1, h)) else v
            for j, v in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
16.666666666666668, tensor(0.0168), Description: Move each colored square (red or light blue) to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def adfaabhgeadaeeifibfddiafgeaffiae(I):
  bg = mostcolor(I)
  h = height(I)
  return tuple(
      tuple(
          next((I[k][j] for k in range(h - 1, i, -1) if I[k][j] == v), v) if v in {2, 8} else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
23.0, tensor(0.0119), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def feciebeaahgfecacadfhajddfhhaabai(I):
  def move_object_down(grid, obj):
    height_diff = height(grid) - height(obj) - uppermost(obj)
    return paint(cover(grid, obj), shift(obj, (height_diff, 0)))

  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = move_object_down(O, obj)
  return O
 
15.333333333333334, tensor(0.0102), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def jdchdcfcgdcbeacaijbdegjjgdeihdid(I):
  x1 = objects(I, T, F, T)
  x2 = sorted(x1, key=lambda o: uppermost(o))
  x3 = canvas(ZERO, shape(I))
  x4 = height(x3)
  O = x3
  for obj in x2:
    O = paint(O, shift(obj, (x4 - height(obj), 0)))
  return O
 
16.666666666666668, tensor(0.0270), Description: Move the red shape down so that its bottom row is aligned with the bottom row of the grid. The background should be black. 
:: def iibebeahfbejeeihjfddddccdfchbfdi(I):
  obj2 = first(colorfilter(objects(I, T, F, T), 2))
  distance = height(I) - lowermost(obj2) - 1
  offset = (distance, 0) 
  O = move(I, obj2, offset)
  return O
 
16.666666666666668, tensor(0.1442), Description: Move all colored shapes except the light blue shape down until they collide with another shape or the bottom of the grid. The light blue shape should remain in its original position. The background should be black. 
:: def abgbbadjbjbfeiafbghgdcdaiddciafe(grid):
    # Find all objects
  objs = objects(grid, T, T, T) 
  
  # Find the object with color 8
  fixed_obj = extract(objs, lambda obj: color(obj) == EIGHT) 
  
  # Get other objects
  movable_objs = objs - {fixed_obj} 
  
  # Define a function to move an object down until it collides
  def move_down(obj):
    shifted_obj = obj
    while True:
      new_obj = shift(shifted_obj, DOWN)
      if any(v != ZERO for v, (i, j) in new_obj if 0 <= i < height(grid) and 0 <= j < width(grid)) or not backdrop(new_obj).issubset(asindices(grid)):
        break
      shifted_obj = new_obj
    return shifted_obj
  
  # Move each object down
  moved_objs = apply(move_down, movable_objs)
  
  # Combine moved objects with the fixed object
  final_objs = moved_objs | {fixed_obj} 
  
  # Paint the objects on an empty canvas
  return paint(canvas(ZERO, shape(grid)), merge(final_objs))
 
16.666666666666668, tensor(0.1442), Description: Move all colored shapes except the light blue shape down until they collide with another shape or the bottom of the grid. The light blue shape should remain in its original position. The background should be black. 
:: def dibgcbcaaiedegfdbjecadehjebadbjg(grid):
  # Find all objects
  objs = objects(grid, T, T, T)
  
  # Find the object with color 8
  fixed_obj = extract(objs, lambda obj: color(obj) == EIGHT)
  
  # Create a canvas filled with background color
  output = canvas(mostcolor(grid), shape(grid))
  
  # Paint fixed object onto the canvas
  output = paint(output, fixed_obj)
  
  # Iterate through remaining objects
  for obj in objs - {fixed_obj}:
    # Get the bounding box indices of the object
    indices = toindices(obj)
    
    # Calculate downward shift based on the object's distance to the bottom or another object
    shift_amount = min(i for i in range(1, height(grid)) if any((a+i, b) in asindices(grid) and index(grid, (a+i, b)) != ZERO for a, b in indices) or (a+i >= height(grid) for a, b in indices))
    
    # Shift the object downwards
    shifted_obj = shift(obj, (shift_amount, 0))
    
    # Paint the shifted object onto the canvas
    output = paint(output, shifted_obj)
  
  return output
 
25.0, tensor(0.0105), Description: Move the largest colored shape (excluding the light blue shape) to the bottom of the grid, keeping the same horizontal position. The light blue shape should be moved to the bottom left corner of the grid. The background should be black. 
:: def ajefebbbaieaecaeijfafeccffdjeehc(I):
    objs = objects(I, T, F, T)
    obj2 = argmax(objs, lambda obj: (color(obj), -size(obj))) 
    obj8 = other(objs, obj2)
    bottom_left = (height(I) - height(obj8), 0)
    O = paint(paint(I, shift(obj8, subtract(bottom_left, ulcorner(obj8)))), shift(obj2, (height(I)-height(obj2)-1, 0)))
    return O 
 
15.333333333333334, tensor(0.0113), Description: Move the largest red shape to the bottom of the grid, keeping the same horizontal position. The light blue shape should also be moved to the bottom of the grid, keeping the same horizontal position. The background should be black. 
:: def bagggaadjebeecdiijchdbjggcebfbhc(I):
  objs = objects(I, T, F, T)
  obj2 = argmax(objs, lambda obj: (color(obj) == 2, size(obj)))
  obj8 = other(objs, obj2)
  new_obj2 = shift(obj2, (height(I)-height(obj2),0))
  new_obj8 = shift(obj8, (height(I)-height(obj8),0))
  O = paint(paint(canvas(0, shape(I)), new_obj2), new_obj8)
  return O
 
21.666666666666668, tensor(0.0208), Description: Move the largest red shape and the largest light blue shape to the bottom of the grid, keeping the same horizontal position. The background should be black. 
:: def djeehgeccadbejafahefjgbbbbedieac(I):
  objs = objects(I, T, F, T)
  obj2 = argmax(objs, lambda o: color(o) == 2)
  obj8 = argmax(objs, lambda o: color(o) == 8)
  target2 = (height(I) - height(obj2), 0)
  target8 = (height(I) - height(obj8), 0)
  new_obj2 = shift(obj2, subtract(target2, ulcorner(obj2)))
  new_obj8 = shift(obj8, subtract(target8, ulcorner(obj8)))
  O = paint(paint(canvas(0, shape(I)), new_obj2), new_obj8)
  return O
 
17.0, tensor(0.0118), Description: Move the largest red shape to the bottom of the grid, keeping the same horizontal position. The light blue shape should be moved to the bottom of the grid, keeping the same horizontal position. The background should be black. 
:: def ccaacbgagedhegefabddabjebajgiead(I):
  h = height(I)
  objs = objects(I, T, F, T)
  obj2 = argmax(objs, lambda obj: (color(obj) == 2, -size(obj)))
  obj8 = other(objs, obj2)
  O = paint(
      paint(canvas(0, shape(I)),
            shift(obj2, (h-height(obj2)-1, 0))), 
            shift(obj8, (h-height(obj8), 0))
  )
  return O
 
24.0, tensor(0.0660), Description: Move each colored shape down until it touches another shape or the bottom of the grid. The background should be black. If a shape would collide with another shape when moved down, it should be placed as high as possible without colliding. The background should be black. 
:: def hccchdaibbibejgijijcidgdgdbajcbe(I):
  moved = canvas(ZERO, shape(I))
  for obj in objects(I, True, True, True):
    shifted_obj = obj
    while not bordering(shifted_obj, I) and colorcount(toobject(shifted_obj, moved), ZERO) == len(obj):
      shifted_obj = shift(shifted_obj, DOWN)
    moved = paint(moved, shifted_obj)
  return moved
 
16.666666666666668, tensor(0.0431), Description: Move each colored shape down until it touches another shape or the bottom of the grid. The background should be black. If a shape would collide with another shape when moved down, it should be placed as high as possible without colliding. The background should be black. The shapes should be sorted by their topmost row, with the shape with the highest topmost row at the bottom and the shape with the lowest topmost row at the top. 
:: def icaebfibfbbjeceabadfffieibbhbdda(I):
  grid = I
  for obj in sorted(objects(I, True, True, True), key=lambda x: -uppermost(x)): 
      original_obj = obj
      while not bordering(obj, grid) and len(intersection(toindices(shift(obj, DOWN)), toindices(obj))) == 0:
          obj = shift(obj, DOWN)
      grid = paint(cover(grid, original_obj), obj) 
  return grid
 
10.666666666666666, tensor(0.0188), Description: Move the red shape to the bottom of the grid, keeping the same horizontal position. The background should be black. 
:: def afcfeibccffeecfgajdbifegdiaibdca(I):
  twos = toindices(first(colorfilter(objects(I, T, F, T), 2)))
  target_row = height(I) - height(twos)
  O = paint(
      cover(I, twos),
      recolor(2, frozenset((target_row + i, j) for i, j in toindices(twos)))
  )
  return O
 
16.0, tensor(0.0270), Description: Move the red shape down so that its bottom row is aligned with the bottom row of the grid. The background should be black. 
:: def gaaahbfdbaafeiejieadjdbfdbaiigce(I):
  two_obj = first(colorfilter(objects(I, T, F, T), 2))
  empty_rows = sum(1 for row in I if set(row) == {0})
  shift_amount = empty_rows - height(two_obj)
  O = paint(
      cover(I, two_obj),
      shift(two_obj, (shift_amount, 0))
  )
  return O
 
9.333333333333334, tensor(0.0709), Description: Move the red shape down so that its top row is aligned with the bottom row of the light blue shape. The background should be black. 
:: def edbgabajahffeacfiebebecfbaafjdjc(I):
  objs = objects(I, T, F, T)
  two_obj = first(colorfilter(objs, 2))
  other_obj = first(difference(objs, {two_obj}))
  shift_amount = lowermost(other_obj) - uppermost(two_obj) + 1
  O = paint(
      cover(I, two_obj),
      shift(two_obj, (shift_amount, 0))
  )
  return O
 
12.666666666666666, tensor(0.0188), Description: Move the red shape to the bottom of the grid, keeping the same horizontal position. The background should be black. 
:: def bbecbcafdjdeedebicfecbhdgcbhfdcb(I):
  two_indices = toindices(first(colorfilter(objects(I, T, F, T), 2)))
  target_indices = frozenset((height(I) - 1 - i, j) for i, j in two_indices)
  O = paint(
      cover(I, two_indices),
      recolor(2, target_indices)
  )
  return O
 
16.666666666666668, tensor(0.1442), Description: Move all colored shapes except the light blue shape down until they collide with another shape or the bottom of the grid. The light blue shape should remain in its original position. The background should be black. 
:: def bgdcebdiechfedjhidfcfgefibecaabe(grid):
  fixed_obj = extract(objects(grid, T, T, T), lambda obj: color(obj) == EIGHT)
  movable_objs = objects(grid, T, T, T) - {fixed_obj}
  new_grid = paint(canvas(ZERO, shape(grid)), fixed_obj)
  for obj in movable_objs:
    while True:
      shifted_obj = shift(obj, DOWN)
      if any((i + 1, j) in asindices(grid) and grid[i + 1][j] == ZERO for v, (i, j) in shifted_obj) and backdrop(shifted_obj).issubset(asindices(grid)):
        obj = shifted_obj
      else:
        break
    new_grid = paint(new_grid, obj)
  return new_grid
 
11.666666666666666, tensor(0.1442), Description: Move all colored shapes except the light blue shape down until they collide with another shape or the bottom of the grid. The light blue shape should remain in its original position. The background should be black. 
:: def gefdbbhjcbffehbdjcbcfieffceafecc(grid):
  fixed_obj = extract(objects(grid, T, T, T), lambda obj: color(obj) == EIGHT)
  movable_area = difference(asindices(grid), toindices(fixed_obj))
  def fall_object(loc):
    i, j = loc
    while (i + 1, j) in movable_area:
      i += 1
    return (i, j)
  new_grid = paint(canvas(ZERO, shape(grid)), fixed_obj)
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if (i, j) in movable_area and val != ZERO:
        new_grid = paint(new_grid, {(val, fall_object((i, j)))})
  return new_grid
 
19.666666666666668, tensor(0.1442), Description: Move all colored shapes except the light blue shape down until they collide with another shape or the bottom of the grid. The light blue shape should remain in its original position. The background should be black. 
:: def bfgbbbbdbfdeeabgifhedhadibhfhgdi(grid):
  fixed_obj = extract(objects(grid, T, T, T), lambda obj: color(obj) == EIGHT)
  new_grid = canvas(ZERO, shape(grid))
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val != ZERO:
        new_i = i
        while new_i + 1 < height(grid) and grid[new_i + 1][j] == ZERO and (new_i + 1, j) not in toindices(fixed_obj):
          new_i += 1
        new_grid = paint(new_grid, {(val, (new_i, j))})
  return new_grid
 
19.333333333333332, tensor(0.0114), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def gadfedfabhdjedacicagfabdfgbcjgdi(I):
  O = canvas(0, shape(I)) # Create an empty canvas
  for obj in objects(I, T, F, T):
    O = paint(O, shift(obj, (height(I) - lowermost(obj), 0))) # Shift and paint each object
  return O
 
19.333333333333332, tensor(0.0111), Description: Move each colored shape to the bottom of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved down so that the bottom of each shape is aligned with the bottom of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be sorted by their topmost row, with the shape with the lowest topmost row at the bottom and the shape with the highest topmost row at the top. 
:: def bdcccibbaabcebhjaeadfhfaeacffeec(I):
    x1 = objects(I, T, F, T)
    x2 = sorted(x1, key=lambda obj: uppermost(obj)) # Sort objects by their top row position
    O = I
    for i in range(len(x2)):
        obj = x2[i]
        O = paint(cover(O, obj), shift(obj, (height(I) - lowermost(obj), 0))) # Clear original position, then shift and paint
    return O
 
24.666666666666668, tensor(0.0660), Description: Move each colored shape down until it touches another shape or the bottom of the grid. The background should be black. If a shape would collide with another shape when moved down, it should be placed as high as possible without colliding. The background should be black. 
:: def djcdaaaehfjiefbaaeghiedaejehgfca(I):
  moved = canvas(ZERO, shape(I)) 
  for obj in objects(I, True, True, True):
    shifted_obj = obj
    while not bordering(shifted_obj, I) and colorcount(toobject(shift(shifted_obj, DOWN), moved), ZERO) == len(toindices(shift(shifted_obj, DOWN))):
      shifted_obj = shift(shifted_obj, DOWN)
    moved = paint(moved, shifted_obj)
  return moved
 
16.666666666666668, tensor(0.0611), Description: Move each colored shape down until it touches another shape or the bottom of the grid. The background should be black. If a shape would collide with another shape when moved down, it should be placed as high as possible without colliding. The background should be black. The shapes should be moved down so that they are as close as possible to the other shapes, without overlapping. The background should be black. 
:: def deichjeahidbebicjceehdiajeadabbd(I):
  moved = canvas(ZERO, shape(I))
  for obj in objects(I, True, True, True):
    shifted_obj = obj
    for other_obj in objects(moved, True, True, True):
      shifted_obj = shift(shifted_obj, gravitate(shifted_obj, other_obj))
    moved = paint(moved, shifted_obj)
  return moved
 
23.0, tensor(0.0124), Description: Move each colored shape to the top of the grid, keeping the same horizontal position. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. The shapes should be moved up so that the top of each shape is aligned with the top of the grid. The shapes should be stacked on top of each other, with no gaps between them. The background should be black. 
:: def faafdjdgfideeahfjidcefhacbbejjbg(I):
  objs = objects(I, T, F, T)
  h = height(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (h - uppermost(obj) - height(obj), 0)))
  return O
 
10.0, tensor(0.0720), Description: Move the red shape up so that its top row is aligned with the top row of the light blue shape. The background should be black. 
:: def bfjecaffbfjgecbjijcghgdeefhfiiif(I):
  two_obj = first(colorfilter(objects(I, T, F, T), 2))
  eight_obj = first(colorfilter(objects(I, T, F, T), 8))
  target_i = uppermost(eight_obj) - height(two_obj) 
  O = paint(
      cover(I, two_obj),
      shift(two_obj, (target_i - uppermost(two_obj), 0))
  )
  return O
 
12.666666666666666, tensor(0.0447), Description: Move the red shape up or down so that its top row is aligned with the bottom row of the light blue shape. The background should be black. 
:: def dicfcaifbfdcededaaabhjbhacbccfjg(I):
  twos = toindices(first(colorfilter(objects(I, T, F, T), 2)))
  eights = toindices(first(colorfilter(objects(I, T, F, T), 8)))
  diff = minimum(i for i, j in eights) - maximum(i for i, j in twos) - 1
  O = paint(
      cover(I, twos),
      recolor(2, frozenset(((i + diff) % height(I), j) for i, j in twos))
  )
  return O
 
0.0, tensor(0.5967), Description: Move the red shape so that it is as close as possible to the light blue shape without overlapping. The background should be black. 
:: def aebfadjcidgceiahbdfgaefeciagabfe(I):
  two_obj = first(colorfilter(objects(I, T, F, T), 2))
  eight_obj = first(colorfilter(objects(I, T, F, T), 8))
  offset = gravitate(two_obj, eight_obj)
  return paint(cover(I, two_obj), shift(two_obj, offset))
 
