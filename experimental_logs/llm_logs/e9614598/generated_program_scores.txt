21.5, tensor(1.7165), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def gcaefebhaeadegdabbbfgcgdafeecdca(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    square = {(center_i - 1 + i, center_j - 1 + j) for i in range(3) for j in range(3)}
    O = fill(O, THREE, square)
  return O
 
6.0, tensor(0.0641), Description: For each colored shape in the input grid, create a 3x3 green square and place it in the output grid such that the center of the green square aligns with the center of the colored shape in the input grid. 
:: def dchahhffjffdefbdjbiaccchgceacaid(I):
  objs = fgpartition(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    if len(obj) > 0:
      ci, cj = center(obj)
      O = paint(O, shift(recolor(THREE, {(i,j) for i in range(3) for j in range(3)}), (ci-1,cj-1)))
  return O
 
18.5, tensor(1.7165), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def aeejfafffdggeaddjdbbheaahccegdcb(I):
  O = I
  for i in range(1, height(I)-1):
    for j in range(1, width(I)-1):
      if I[i][j] != ZERO:
        O = fill(O, THREE, {(i-1+k,j-1+l) for k in range(3) for l in range(3)})
  return O
 
12.5, tensor(0.5350), Description: For each square that is colored with '1' in the input grid, draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. 
:: def ebaccfcaffhcebghidbdceeffgcabfce(I):
    # Define a function to create a plus shape around a given index
    def make_plus(idx): 
        i, j = idx
        return frozenset({(i-1, j), (i+1, j), (i, j-1), (i, j+1)})
    # Find all indices of digit '1'
    ones = ofcolor(I, ONE)
    # Generate plus shapes for each '1' index and merge them
    plus_indices = merge(apply(make_plus, ones))
    # Fill the input grid with '3' at the plus shape indices
    O = fill(I, THREE, plus_indices)
    return O
 
6.5, tensor(1.7218), Description: For each horizontal line of '1's in the input grid, draw a horizontal line of '3's one square above the line of '1's. The line of '3's should extend the full length of the line of '1's. 
:: def cbhggehefhceedeajhcadhjfaefbdeda(I):
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        width = 1
        while j + width < len(row) and I[i][j + width] == 1:
          width += 1
        start_j = j
        end_j = j + width - 1
        for k in range(start_j, end_j + 1):
          I = fill(I, 3, {(i - 1, k)})
  return I
 
9.0, tensor(1.7437), Description: Draw a horizontal line of '3's in the 5th row of the output grid. The line should extend from the leftmost colored square to the rightmost colored square in the input grid. If there are no colored squares in the input grid, the output grid should be all black. 
:: def hfeaedbeaegcebijagijecagiaidihhh(I):
  obj = objects(I, True, False, True)
  if obj:
    j = leftmost(extract(obj, lambda x: True))
    line = frozenset({(j-1, 4), (j, 4), (j+1, 4)})
    O = fill(canvas(0, shape(I)), 3, line)
  else:
    O = canvas(0, shape(I))
  return O
 
5.0, tensor(1.7264), Description: If there are any squares colored with '1' in the input grid, draw a horizontal line of '3's in the 5th row of the output grid. The line should extend from the leftmost '1' square to the rightmost '1' square. If there are no '1' squares in the input grid, the output grid should be the same as the input grid. 
:: def fbadebfhgieaeeejjcfecdbeagbbcjeb(I):
  indices_one = ofcolor(I, 1)
  if indices_one:
    j = leftmost(indices_one)
    O = fill(I, 3, {(4, j-1), (4, j), (4, j+1)})
  else:
    O = I
  return O
 
8.0, tensor(1.7453), Description: Draw a horizontal line of '3's in the 5th row of the output grid. The line should extend from the leftmost '1' square to the rightmost '1' square in the 5th row of the input grid. If there are no '1' squares in the 5th row of the input grid, the output grid should be all black. 
:: def bgdccajjafbaeaefjeeibegfaadcficc(I):
  O = canvas(0, shape(I))
  for j in range(width(I)):
    if index(I, (4, j)) == 1:
      return fill(O, 3, {(4, j-1), (4, j), (4, j+1)})
  return O
 
7.0, tensor(1.7682), Description: Draw a horizontal line of '3's in the 5th row of the output grid. The line should extend from the leftmost '1' square to the rightmost '1' square in the 5th row of the input grid. If there are no '1' squares in the 5th row of the input grid, the output grid should be the same as the input grid. 
:: def dejfgebihffaedfeibfihageeggejdca(I):
  for j in range(width(I)):
    if I[4][j] == 1:
      O = fill(canvas(0, shape(I)), 3, {(4, j-1), (4, j), (4, j+1)})
      return O
  return I
 
6.5, tensor(1.7437), Description: Draw a horizontal line of '3's in the 5th row of the output grid. The line should extend from the leftmost colored square to the rightmost colored square in the input grid. If there are no colored squares in the input grid, the output grid should be all black. 
:: def dgacacjfeaeheddejfcbdfdfdbddchah(I):
    obj = objects(I, True, False, True)
    if obj:
        center_j = centerofmass(extract(obj, lambda x: True))[1]
        O = fill(canvas(0, shape(I)), 3, {(4, center_j-1), (4, center_j), (4, center_j+1)})
    else:
        O = canvas(0, shape(I))
    return O
 
14.5, tensor(0.4192), Description: For each square that is colored with '1' in the input grid, draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. 
:: def baaajdbihfecedadicfbhhjhjdbhcfbh(I):
  return paint(I, merge(apply(lambda loc: recolor(3, shift(frozenset({(-1, 0), (0, -1), (0, 0), (0, 1), (1, 0)}), loc)), ofcolor(I, 1))))
 
10.5, tensor(0.0653), Description: For each colored square in the input grid, draw a vertical line of '3's that extends from one square above the center of the colored square to one square below the center of the colored square. The line should be centered on the colored square. 
:: def jcjddddjbfeceeiibecjbbfbccedeafi(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    start_i = center_i - 1
    end_i = center_i + 2
    for i in range(start_i, end_i):
      if 0 <= i < len(I):
        O = fill(O, 3, {(i, center_j)})
  return O
 
8.5, tensor(0.0615), Description: For each colored square in the input grid, draw a horizontal line of '3's that extends three squares to the right from the center of the colored square. The line should be centered on the colored square. 
:: def iffcdaebdfeceghhjhaacadffdjdgfbe(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center = centerofmass(obj)
    O = underfill(O, 3, shift(frozenset({(0,0), (1,0), (2,0)}), (center[0]-1, center[1])))
  return O
 
5.0, tensor(1.1966), Description: For each 1x1 block in the input grid, draw a horizontal line of '3's one square above the block. 
:: def gejcccibcccbebbfbfaddffjaecbgcfj(I):
  return fill(I, 3, mapply(lambda obj: {(i-1, j) for (v, (i, j)) in obj},  sizefilter(partition(I), 1)))
 
45.0, tensor(0.7974), Description: For each colored square in the input grid, draw a vertical line of '3's that extends the full height of the grid. The line should be centered on the colored square. If there are no colored squares in the input grid, the output grid should be all black. 
:: def gghbhficeehbeeffjadadcaehdecdfae(I):
  objs = objects(I, True, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    j = leftmost(obj)
    line = frozenset({(i, j-1) for i in range(10)} | {(i, j) for i in range(10)} | {(i, j+1) for i in range(10)})
    O = fill(O, 3, line)
  return O
 
11.0, tensor(1.7733), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def dfcdajidheaieeecbbfhgagcbaeegjdc(I):
  indices = ofcolor(I, 1)
  O = canvas(0, shape(I))
  for i, j in indices:
    for k in range(j-1, j+2):
      if 0 <= k < len(I[0]):
        O = fill(O, 3, {(i, k)})
  return O
 
26.0, tensor(0.1752), Description: For each colored square in the input grid, draw a vertical line of '3's that extends the full height of the grid. The line should be centered on the colored square. 
:: def cjiebcgbifeeehfhjadeifecedajhdec(I):
  ones = ofcolor(I, 1)
  line = lambda loc: frozenset({(i, loc[1]) for i in range(len(I))})
  return fill(I, 3, merge(apply(line, apply(center, objects(I, True, False, False)))))
 
25.0, tensor(0.2071), Description: For each colored square in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the colored square. The line should be centered on the colored square. 
:: def aejbceibbcaiedcabgbededfdfccabab(I):
  for obj in objects(I, True, False, False):
    I = fill(I, 3, hfrontier(center(obj)))
  return I 
 
17.0, tensor(0.2039), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def jeehiighbibjefbaidgahadfdfdedbce(I):
  lines = set()
  for i, j in ofcolor(I, 1):
    lines |= hfrontier((i, j)) 
  return fill(I, 3, frozenset(lines))
 
8.0, tensor(0.1068), Description: For each colored shape in the input grid, create a plus shape of '3's and place it in the output grid such that the center of the plus shape aligns with the center of the colored shape in the input grid. 
:: def aebcdcdibaaieedcbjccehdfaceecbgd(I):
  objs = fgpartition(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    if len(obj) > 0:
      ci, cj = centerofmass(obj)
      O = paint(O, shift(recolor(THREE, {(ci, cj), (ci - 1, cj), (ci + 1, cj), (ci, cj - 1), (ci, cj + 1)}), (-1, -1))) 
  return O
 
17.5, tensor(1.7165), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def eadcgcabddhcedfhahcffebgdcdadfed(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != ZERO:
        O = paint(O, recolor(THREE, {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j), (i + 1, j), (i + 1, j - 1), (i + 1, j + 1)}))
  return O
 
22.0, tensor(0.3162), Description: For each colored shape in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored shape. Then, draw a green square around each of the four corners of the colored shape. The center of each corner green square should be the same as the center of the corner of the colored shape. Finally, draw a green square around the colored shape itself. 
:: def ddfedcfccjafeddcbjbdhedhebefehag(I):
    objs = fgpartition(I)
    O = canvas(ZERO, shape(I))
    for obj in objs:
        O = underfill(O, THREE, shift(backdrop(obj), (1,1)))
        O = underfill(O, THREE, shift(backdrop(obj), (-1,-1)))
        O = underfill(O, THREE, shift(backdrop(obj), (1,-1)))
        O = underfill(O, THREE, shift(backdrop(obj), (-1,1)))
        O = underfill(O, THREE, backdrop(obj))
    return O
 
14.5, tensor(0.0663), Description: For each colored square in the input grid, draw a vertical and horizontal line of '3's that extends one square above and below, and one square to the left and right of the colored square. The lines should be centered on the colored square. 
:: def dbiddaceaaghefdjigbcefdfaieafdic(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != ZERO:
                for di in range(-1, 2):
                    O = underfill(O, THREE, {(i + di, j)})
                    O = underfill(O, THREE, {(i, j + di)})
    return O
 
8.5, tensor(0.0224), Description: For each row in the input grid that contains at least one '1', draw a horizontal line of '3's in the row below. The line should extend from the leftmost '1' in the row to the rightmost '1' in the row. 
:: def jdahbbaagabiejiciecfcgeefbddiead(I):
  # Find indices of '1's
  ones_indices = ofcolor(I, ONE)
  # Group indices by row
  rows = {}
  for i, j in ones_indices:
    rows.setdefault(i, []).append(j)
  # Create line indices for each row
  line_indices = set()
  for row, cols in rows.items():
    line_indices |= {(row + 1, j) for j in range(min(cols), max(cols) + 1)}
  # Fill the grid with '3's at line indices
  O = fill(I, THREE, frozenset(line_indices))
  return O
 
11.0, tensor(0.0242), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def ibcdbbfhabajebbgiehhcagedefjbjcc(I):
  O = I # Initialize output grid
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE: # If a '1' is found
        # Draw a horizontal line of '3's below it
        for k in range(max(0, j - 1), min(len(row), j + 2)):
          O = fill(O, THREE, {(i + 1, k)})
  return O
 
13.0, tensor(0.0242), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def ejjgcccjcbjfeccebebabidbdciiehcd(I):
  # Get grid dimensions
  h, w = len(I), len(I[0])
  # Create a canvas filled with '0's
  canvas_grid = canvas(ZERO, (h, w)) 
  # Find '1' indices
  ones_indices = ofcolor(I, ONE)
  # Generate horizontal line indices below each '1'
  line_indices  =  set()
  for i, j in ones_indices:
    line_indices.update({(i + 1, j - 1), (i + 1, j), (i + 1, j + 1)})
  # Fill the canvas with '3's at the line indices
  O = fill(canvas_grid, THREE, frozenset(line_indices))
  return O
 
85.0, tensor(1.4091), Description: For each colored square in the input grid, move the square one space down and change its color to green. The output grid should have the same colored squares as the input grid, but moved down one space and colored green. 
:: def gebcgeiabfabebhfjajcdcjdcjdccdbf(I):
    objs = objects(I, T, F, F)
    shifted_objs = frozenset(shift(obj, DOWN) for obj in objs)
    recolored_objs = frozenset(recolor(THREE, obj) for obj in shifted_objs)
    O = I
    for obj in recolored_objs:
        O = paint(O, obj)
    return O
 
82.5, tensor(1.6696), Description: For each colored square in the input grid, draw a horizontal line of '3's one square below the square. The line should extend the full width of the square. 
:: def gdfgfddfagajedihiadehiibegdbfgcj(I):
    O = I
    for obj in objects(I, T, F, F):
        O = underfill(O, THREE, shift(toindices(obj), DOWN))
    return O
 
7.0, tensor(0.9632), Description: For each colored square in the input grid, draw a green square one square below it. The green square should be in the same column as the colored square. If the colored square is in the bottom row, do not draw a green square below it. 
:: def aabafaagdbeaedaabefffdbaggeefgac(I):
  indices = asindices(I)
  shifted_indices = shift(indices, DOWN)
  new_indices = intersection(shifted_indices, asindices(I))
  O = I
  for i, j in new_indices:
    if I[i-1][j] != 0:
        O = paint(O, {(THREE, (i, j))})
  return O
 
9.5, tensor(1.6060), Description: For each colored square in the input grid that is colored with '1', draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. If the square is not colored with '1', the output grid should be the same as the input grid. 
:: def fidachcdhbhhefghjbedgbadbihcjbfh(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    if color(obj) == 1:
      i, j = centerofmass(obj)
      O = fill(I, 3, {(i, j-1), (i, j), (i, j+1), (i-1, j), (i+1, j)})
    else:
      O = I
  return O
 
14.5, tensor(1.5809), Description: For each square that is colored with '1' in the input grid, draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. 
:: def dcagabgeghhfecafjhjbhcfiajaagbbd(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        O = fill(O, 3, {(i, j-1), (i, j), (i, j+1), (i-1, j), (i+1, j)})
  return O
 
17.0, tensor(0.5558), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends the full height of the grid. The line should be centered on the '1' square. 
:: def baadadedefcgecceajhdbaghgifcjaff(I):
  lines = set()
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        lines.add(frozenset((k, j) for k in range(len(I))))
  return fill(I, 3, merge(lines))
 
6.5, tensor(0.0612), Description: For each colored shape in the input grid, draw a vertical line of '3's that extends three squares to the right from the center of the colored shape. The line should be centered on the colored shape. 
:: def babefcedacejeaeibcdabhbeggaccjac(I):
  objs = fgpartition(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    center_i = uppermost(obj) + height(obj) // 2
    O = underfill(O, THREE, frozenset({(center_i - 1, leftmost(obj)), (center_i, leftmost(obj)), (center_i + 1, leftmost(obj))})) 
  return O
 
12.5, tensor(0.0576), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends from the top to the bottom of the grid. The line should be centered on the '1' square. 
:: def cgbacbacdcfeeaajibdgfjadieeieabi(I):
  objs = [frozenset({(ONE, (i,j)) for i, row in enumerate(I) for j, val in enumerate(row) if val == ONE})]
  O = canvas(ZERO, shape(I))
  for obj in objs:
    start = (centerofmass(obj)[0], leftmost(obj))
    O = underfill(O, THREE, frozenset(shoot(start, UP) | shoot(start, DOWN)))
  return O
 
8.0, tensor(0.4168), Description: For each 3-cell window in the input grid where the center cell is colored with '1', draw a horizontal line of '3's one square below the window. The line should extend the full width of the window. 
:: def agefieejcjeieegbjggdfhdbfcefcjce(I):
  # Iterate through rows
  O = I
  for i in range(len(I) - 1):
    # Iterate through columns with a step of 3
    for j in range(1, len(I[0]) - 1, 3):
      # Check if the center cell of the 3-cell window is '1'
      if I[i][j] == ONE:
        # Fill the 3-cell window below with '3's
        O = fill(O, THREE, {(i + 1, j - 1), (i + 1, j), (i + 1, j + 1)})
  return O
 
12.5, tensor(1.5504), Description: For each square that is colored with '1' in the input grid, draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. 
:: def ebihejjhbeefeifajfbgbjfecebjdcga(I):
  # Find indices of '1's in the grid.
  ones = ofcolor(I, 1)
  # Create a set to store indices for '3's.
  threes = set()
  # Iterate over each '1' index.
  for one in ones:
    # Add indices surrounding the '1' to form a plus shape.
    threes.update({(one[0]-1, one[1]), (one[0]+1, one[1]), (one[0], one[1]-1), (one[0], one[1]+1)})
  # Fill the grid with '3's at the calculated indices.
  O = fill(I, 3, frozenset(threes)) 
  return O
 
14.5, tensor(1.5504), Description: For each square that is colored with '1' in the input grid, draw a plus shape around it using the color '3'. The plus shape should extend one square in each direction (up, down, left, right) from the center of the '1' square. 
:: def dcbecfdebcgaecebiabcecjfjhcbagdc(I):
  # Create a new grid filled with 0s, same size as input.
  O = canvas(0, shape(I))
  # Iterate over rows and columns of the input grid.
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If a cell contains '1', paint a plus shape around it with '3's.
      if I[i][j] == 1:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          # Boundary checks to avoid going out of the grid.
          if 0 <= i+di < len(I) and 0 <= j+dj < len(I[0]): 
            O = paint(O, {(3, (i+di, j+dj))})
  return O
 
10.5, tensor(1.7739), Description: For each colored square in the input grid, draw a vertical line of '3's that extends from one square above the center of the colored square to one square below the center of the colored square. The line should be centered on the colored square. 
:: def faceajcefijfebcjjachfdfefjdddcfe(I):
  objs = objects(I, True, False, True)
  O = I  # Start with the input grid
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    for i in range(center_i - 1, center_i + 2):
      if 0 <= i < len(I):  # Boundary check
        O = fill(O, 3, {(i, center_j)})
  return O
 
21.5, tensor(0.2056), Description: For each colored shape in the input grid, create a 3x3 green square and place it in the output grid such that the center of the green square aligns with the center of the colored shape in the input grid. 
:: def ebaedfcaffbfedbaidbjdbiaeafiefga(I):
    objs = objects(I, True, False, False)
    centers = apply(centerofmass, objs)
    square = canvas(3, (3, 3))
    shifted_squares = mapply(lambda c: shift(asobject(square), subtract(c, (1, 1))), centers)
    O = paint(I, shifted_squares)
    return O
 
95.0, tensor(0.2056), Description: For each colored shape in the input grid, create a 3x3 green square and place it in the output grid such that the center of the green square aligns with the center of the colored shape in the input grid. 
:: def efffebbehcigebidaaceecfcddefiebd(I):
  objs = objects(I, True, False, False)
  square_indices = frozenset({(i, j) for i in range(-1, 2) for j in range(-1, 2)})
  shifted_indices = mfilter(objs, lambda obj: shift(square_indices, centerofmass(obj)))
  O = fill(I, 3, shifted_indices)
  return O
 
11.0, tensor(0.0652), Description: For each colored square in the input grid, draw a horizontal line of '3's one square below the square. The line should extend one square to the left and one square to the right of the square. The line should be centered on the colored square. 
:: def abfahibcgfdiecahjghdhgfiajbdfbha(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    center = centerofmass(obj)
    line = {(center[0]+1, center[1]-1), (center[0]+1, center[1]), (center[0]+1, center[1]+1)}
    O = underfill(O, 3, line)
  return O
 
7.0, tensor(1.9940), Description: For each square that is colored with '1' in the input grid, draw a square of '3's one square below it. The '3' square should be in the same column as the '1' square. If the '1' square is in the bottom row, do not draw a '3' square below it. 
:: def aidcaifhcgfieggjbfajbhfdcedajbbe(I):
  O = I
  # Iterate through rows
  for i in range(len(I) - 1):
    # Iterate through columns
    for j in range(len(I[0])):
      # Check if the current cell is '1'
      if I[i][j] == ONE:
        # Paint the cell below with '3'
        O = paint(O, {(THREE, (i + 1, j))}) 
  return O
 
7.0, tensor(1.7739), Description: For each colored square in the input grid, draw a horizontal line of '3's that extends from the leftmost edge of the square to the rightmost edge of the square. The line should be centered on the colored square. 
:: def edcaebdbfgadejcajegjeaefejdadhfh(I):
  O = I
  for obj in objects(I, True, False, True):
    i, j = centerofmass(obj)
    left_edge = leftmost(obj)
    right_edge = rightmost(obj)
    O = fill(O, 3, {(i, j) for j in range(left_edge, right_edge + 1)})
  return O
 
6.5, tensor(1.7697), Description: For each row in the input grid, if there are any colored squares in that row, draw a horizontal line of '3's across the entire row. The line should extend from the leftmost colored square in the row to the rightmost colored square in the row. If there are no colored squares in a row, the row in the output grid should be the same as the row in the input grid. 
:: def gdhcbcceaejgecahjbaefahcefffhiai(I):
  def process_row(row, i):
    objs_in_row = [obj for obj in objects(I, True, False, True) if hmatching(obj, {(i, 0)})]
    if objs_in_row:
      left_edge = min(leftmost(obj) for obj in objs_in_row)
      right_edge = max(rightmost(obj) for obj in objs_in_row)
      return tuple(3 if left_edge <= j <= right_edge else v for j, v in enumerate(row))
    return row
  return tuple(process_row(row, i) for i, row in enumerate(I))
 
9.0, tensor(0.2063), Description: For each colored square in the input grid, draw a line of '3's that extends one square above and below the square if the square is vertical, or one square to the left and right of the square if the square is horizontal. The line should be centered on the colored square. 
:: def adajdaeejedcegbbbigcbjeficbiffcd(I):
    lines = frozenset()
    for obj in objects(I, True, False, False): # For each object of '1's
        c = centerofmass(obj) # Find the center
        if portrait(obj):  # Vertical line
            lines |= connect((c[0] - 1, c[1]), (c[0] + 1, c[1])) 
        else:  # Horizontal line
            lines |= connect((c[0], c[1] - 1), (c[0], c[1] + 1)) 
    return fill(I, 3, lines) # Fill lines with '3's
 
9.0, tensor(0.5094), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends one square below the '1' square. The line should be centered on the '1' square. 
:: def bjbgfbbedefeejiaaegcfdaiehjfcjbg(I):
  # Find '1' indices
  ones_indices = ofcolor(I, ONE) 
  # Create a set to store line indices
  line_indices = set()
  # Iterate over each '1' index
  for i, j in ones_indices:
    # Calculate the center bottom position
    bottom_i = i + 1
    center_j = j 
    # Add the line indices to the set
    line_indices.update({(bottom_i, center_j), (bottom_i - 1, center_j)})
  # Fill the grid with '3's at the line indices
  O = fill(I, THREE, frozenset(line_indices))
  return O
 
11.0, tensor(1.7473), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def dcefaeddbcdbeeebbfcgicfjbhiibcdb(I):
  O = I
  # Iterate through each cell in the grid.
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If the cell is '1', draw a horizontal line of '3's.
      if I[i][j] == 1:
        for k in range(max(0, j-1), min(j+2, len(I[0]))):
          O = paint(O, {(3, (i, k))})
  return O
 
17.0, tensor(1.7697), Description: For each row in the input grid, if there are any colored squares in that row, draw a horizontal line of '3's across the entire row. The line should extend from the leftmost colored square in the row to the rightmost colored square in the row. If there are no colored squares in a row, the row in the output grid should be the same as the row in the input grid. 
:: def iceadcdbjjcfegaeibdfaefgdiefbfbd(I):
  return tuple(
      tuple(
          3 if any(hmatching({(i, j)}, obj) for obj in objects(I, True, False, True))
          else I[i][j]
          for j in range(len(I[0])))
      for i in range(len(I))
  )
 
5.0, tensor(1.7124), Description: For each colored square in the input grid, draw a horizontal line of '3's that extends the full width of the square. The line should be centered on the colored square. 
:: def gbdbdjhejfffeadeaedbecafcbjafhfg(I):
  for obj in objects(I, True, False, True):
    i, _ = centerofmass(obj)
    indices = {(i, j) for _, (i, j) in obj}
    I = underfill(I, 3, indices)
  return I
 
7.0, tensor(1.9930), Description: Draw a line of '3's connecting the centers of the leftmost and rightmost colored squares in the input grid. The line should be as short as possible and should not pass through any other colored squares. 
:: def jbbchcbaafbfefbeajjbbcjfiffdfdda(I):
  objs = objects(I, True, False, False)
  obj1 = first(objs)
  obj2 = last(objs)
  center1 = center(obj1)
  center2 = center(obj2)
  line = connect(center1, center2)
  O = fill(I, 3, line)
  return O
 
9.0, tensor(0.5497), Description: Draw a horizontal line of '3's across the entire grid if the '1' squares are in the same row. Otherwise, draw a vertical line of '3's down the entire grid. The line should be centered on the '1' squares. 
:: def dafhcbbibdaeeicfjafcaaiagdaejdfi(I):
    indices = asindices(I)
    first_one = first(ofcolor(I, 1))
    line = branch(
        equality(first_one[0], last(ofcolor(I, 1))[0]),
        frozenset({(first_one[0], j) for j in range(len(I[0]))}),
        frozenset({(i, first_one[1]) for i in range(len(I))})
    )
    O = fill(I, 3, line)
    return O
 
12.0, tensor(0.5545), Description: Draw a horizontal line of '3's across the entire grid if the leftmost colored square is vertical. Otherwise, draw a vertical line of '3's down the entire grid. The line should be centered on the leftmost colored square. 
:: def caeejgdjfifcecdfbfbjfeadifgdaihi(I):
  objs = objects(I, True, False, False)
  obj1 = first(objs)
  obj2 = last(objs)
  h, w = shape(I)
  line = branch(
    portrait(obj1),
    {(center(obj1)[0], j) for j in range(w)},
    {(i, center(obj1)[1]) for i in range(h)}
  )
  O = fill(I, 3, line)
  return O
 
6.5, tensor(0.0650), Description: For each colored shape in the input grid, draw a vertical line of '3's that extends from one square above the center of the colored shape to one square below the center of the colored shape. The line should be centered on the colored shape. 
:: def cedecgefiaeeeibaihgcfaahddcdbecd(I):
  objs = fgpartition(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    center_j = leftmost(obj) + width(obj) // 2
    for i in range(uppermost(obj) - 1, lowermost(obj) + 2):
      O = underfill(O, THREE, frozenset({(i, center_j)}))
  return O
 
4.5, tensor(0.0650), Description: For each colored shape in the input grid, draw a vertical line of '3's that extends from one square above the center of the colored shape to one square below the center of the colored shape. The line should be centered on the colored shape. 
:: def fjafaiafidbeedfiabeagdhfabeefcfc(I):
  O = I
  for obj in fgpartition(I):
    center_j = leftmost(obj) + width(obj) // 2
    O = underfill(O, THREE, frozenset((i, center_j) for i in range(uppermost(obj) - 1, lowermost(obj) + 2)))
  return O
 
85.0, tensor(1.7472), Description: For each colored square in the input grid, draw a horizontal line of '3's one square to the left of the square. The line should extend the full width of the square. 
:: def bgceeebahjecejjabcajgdedhceehdcb(I):
  return paint(I, merge(apply(lambda obj: recolor(3, shift(toindices(obj), (-1, 0))), objects(I, True, False, False))))
 
9.5, tensor(1.7469), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's one square above the square. The line should extend one square to the left and one square to the right of the square. The line should be centered on the '1' square. 
:: def ijegibfeggbaeebbbgeaecfidffdffff(I):
  for i in range(1, len(I)):
    for j in range(1, len(I[0])-1):
      if I[i][j] == 1:
        I = fill(I, 3, {(i-1, j-1), (i-1, j), (i-1, j+1)})
  return I
 
9.5, tensor(1.7733), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def cfiefcchfabjebceihddaecbeaeafhda(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        line = hconcat(canvas(3, (1,1)), hconcat(canvas(3, (1,1)), canvas(3, (1,1))))
        O = paint(O, shift(asobject(line), (i - 1, j - 1)))
  return O
 
17.5, tensor(0.2064), Description: For each colored square in the input grid, draw a vertical line of '3's that extends two squares above and two squares below the square. The line should be centered on the colored square. Also, draw a horizontal line of '3's that extends one square to the left and one square to the right of the square. The line should be centered on the colored square. 
:: def ieiafdffcfgbeebcafjfecbejfdfcagf(I):
  lines = frozenset()
  for obj in objects(I, True, False, False):
    c = centerofmass(obj)
    lines |= connect((c[0] - 2, c[1]), (c[0] + 2, c[1]))
    lines |= connect((c[0], c[1] - 1, ), (c[0], c[1] + 1))
  return fill(I, 3, lines)
 
17.5, tensor(0.2031), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends two squares above and two squares below the square. The line should be centered on the '1' square. Also, draw a horizontal line of '3's that extends one square to the left and one square to the right of the square. The line should be centered on the '1' square. 
:: def jdfgefdceafcehggaedhfcbibjifddea(I):
  cross = frozenset()
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        cross |= connect((i-2, j), (i+2, j))
        cross |= connect((i, j-1), (i, j+1))
  return fill(I, 3, cross) 
 
16.0, tensor(0.2077), Description: For each colored square in the input grid, draw a horizontal line of '3's that extends two squares to the right from the upper-left corner of the square. Also, draw a vertical line of '3's that extends one square up and one square down from the center of the square. The lines should be centered on the colored square. 
:: def ajafcddfdcfhebebjbdcegbcaccifacg(I):
  O = I
  for obj in objects(I, True, False, False):
    ul = ulcorner(obj)
    O = fill(O, 3, connect((ul[0] + 1, ul[1]), (ul[0] + 3, ul[1])))
    O = fill(O, 3, connect((ul[0] + 2, ul[1] - 1), (ul[0] + 2, ul[1] + 1)))
  return O
 
6.0, tensor(0.0386), Description: For each colored shape in the input grid, draw a horizontal line of '3's in the row above the shape. The line should extend the full width of the shape. The line should be centered on the shape. 
:: def cdfeebffeaidecjeaejfcbdcbjgdeidb(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    left = leftmost(obj)
    right = rightmost(obj)
    center_j = left + (right - left) // 2
    for j in range(left, right + 1):
      O = fill(O, THREE, {(uppermost(obj), j)})
  return O
 
4.5, tensor(0.0386), Description: For each colored shape in the input grid, draw a horizontal line of '3's in the row above the shape. The line should extend the full width of the shape. The line should be centered on the shape. 
:: def ifgahahhdbcdebajaffabibdcdaigbfa(I):
  objs = fgpartition(I)
  return underfill(I, THREE, merge(frozenset(connect((uppermost(obj), leftmost(obj)), (uppermost(obj), rightmost(obj))) for obj in objs)))
 
4.0, tensor(0.1329), Description: For each colored shape in the input grid, draw a horizontal line of '3's that extends the full width of the shape. The line should be centered on the colored shape. 
:: def dcedgeafccjeeddcbebeedafibbhaeec(I):
  objs = fgpartition(I)
  lines = frozenset()
  for obj in objs:
    w = width(obj)
    c = centerofmass(obj)
    lines = lines | frozenset((c[0], c[1] + j - w // 2) for j in range(w))
  return underfill(I, THREE, lines)
 
7.0, tensor(0.0392), Description: For each colored square in the input grid, draw a horizontal line of '3's in the row above the square. The line should extend the full width of the square. The line should be centered on the square. 
:: def bbeibagbbadcedaabjceeaiifccijieb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    row = uppermost(obj)
    for j in range(leftmost(obj), rightmost(obj) + 1):
      O = fill(O, THREE, frozenset({(row, j)}))
  return O
 
6.5, tensor(0.0199), Description: For each colored square in the input grid, draw a horizontal line of '3's two squares below the square. The line should extend the full width of the square. The line should be centered on the square. 
:: def cibefgahhcgceeebaaaecbeeagijfjbh(I):
  O = I
  for obj in objects(I, True, False, True):
    left, right = leftmost(obj), rightmost(obj)
    bottom = lowermost(obj) + 2
    for j in range(left, right + 1):
      O = fill(O, THREE, {(bottom, j)})
  return O
 
10.5, tensor(1.6558), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends one square above and one square below the '1' square. The line should be centered on the '1' square. 
:: def bddgijedhbfceiicihddbdebfebeabcb(I):
  lines = frozenset()
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        lines = lines | connect((max(0, i-1), j), (min(i+1, len(I)-1), j))
  return fill(I, 3, lines)
 
9.5, tensor(1.7737), Description: For each colored square in the input grid, draw a horizontal line of '3's two squares above the square. The line should extend one square to the left and one square to the right of the square. The line should be centered on the square. 
:: def ccabehcfdbdaegfebfdjejccbbdjdccf(I):
  for obj in objects(I, True, False, True):
    I = fill(
        I, 
        3, 
        {(uppermost(obj) - 2, j) for j in range(leftmost(obj) - 1, rightmost(obj) + 2)}
    )
  return I
 
14.5, tensor(0.5374), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends two squares below the '1' square. The line should be centered on the '1' square. Also, draw a square of '3's one square below the '1' square. The '3' square should be in the same column as the '1' square. If the '1' square is in the bottom row, do not draw a '3' square below it. 
:: def bcicfdiaijeheacebhbhjfcjaebjeadj(I):
  O = I
  ones = ofcolor(I, ONE)
  for i, j in ones:
    O = fill(O, THREE, {(i+1, j-1), (i+1, j), (i+1, j+1), (i, j), (i+2, j)})
  return O
 
12.5, tensor(0.3675), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's one square below the square. The line should extend one square to the left and one square to the right of the square. The line should be centered on the '1' square. Also, draw a vertical line of '3's that extends one square above and one square below the '1' square. The line should be centered on the '1' square. 
:: def dbbjfgcbaeecefjaaihddeaeacaheaaf(I):
    O = I
    for i in range(len(I) - 2):  # Adjusted range to avoid out-of-bounds
        for j in range(1, len(I[0]) - 1):  # Adjusted range to avoid out-of-bounds
            if I[i][j] == ONE:
                O = fill(O, THREE, {(i+1, j-1), (i+1, j), (i+1, j+1)})  # Fill the horizontal line
                O = fill(O, THREE, {(i, j), (i+2, j)})  # Fill the vertical line
    return O
 
6.5, tensor(0.0146), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def gbghiicdbccjedgdjefefaaefebhcbha(I):
  # Find locations of '1's
  ones = ofcolor(I, ONE)  
  # Create horizontal line patch of length 3
  line = frozenset({(-1, 0), (0, 0), (1, 0)})
  # Shift and paint the line for each '1' location
  threes = mapply(lambda loc: shift(line, (center(ones)[0], loc[1])), ones)
  # Fill the grid with '3's at the calculated locations
  O = fill(I, THREE, threes) 
  return O 
 
11.0, tensor(0.0146), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def cjcecfhbdibcebgcaaedfbbdfbjcfgjb(I):
  # Iterate through each cell in the grid
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell value is '1'
      if I[i][j] == ONE:
        # Paint a horizontal line of '3's 
        for k in range(-1, 2):
          if 0 <= j + k < width(I):
            O = paint(O, {(THREE, (i, j + k))})
  return O
 
8.5, tensor(1.9826), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends three squares to the right of the '1' square. The line should be centered on the '1' square. 
:: def bdfccgidhaeaebicifbcbjahebiadfga(I):
  for i, j in ofcolor(I, ONE):
    I = fill(I, THREE, {(i, j + 1), (i, j + 2), (i, j + 3)})
  return I
 
6.5, tensor(1.8622), Description: For each row in the input grid, if there is at least one '1' in the row, draw a horizontal line of '3's across the entire row. The line should extend from the leftmost '1' in the row to the rightmost '1' in the row. If there are no '1's in a row, the row in the output grid should be the same as the row in the input grid. 
:: def dghdcaaacaciebccigeddfddcdeeifga(I):
  for i in range(len(I)):
    row = I[i]
    if 1 in row:
      first_one = row.index(1)
      last_one = len(row) - 1 - row[::-1].index(1)
      I = fill(I, 3, frozenset((i, j) for j in range(first_one, last_one + 1)))
  return I
 
26.5, tensor(1.7370), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def bgiecfedhdbaefffjigdafhejghifbgh(I):
  objs = objects(I, T, F, F)
  for obj in objs:
    top_left = ulcorner(obj)
    square = {(3, (top_left[0]-1, top_left[1]+i)) for i in range(3)}
    square |= {(3, (top_left[0], top_left[1]+i)) for i in range(3)}
    square |= {(3, (top_left[0]+1, top_left[1]+i)) for i in range(3)}
    I = paint(I, square)
  return I
 
20.5, tensor(1.7517), Description: For each colored square in the input grid that is not the most common color, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def ifajidhddddbedagiacaabcaedbdhagb(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) != mostcolor(I):
      top_left = ulcorner(obj)
      square = product(interval(top_left[0]-1, top_left[0]+2, 1), interval(top_left[1], top_left[1]+3, 1))
      I = fill(I, 3, square)
  return I
 
43.5, tensor(1.7500), Description: For each square in the input grid that is not the most common color, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. 
:: def bjfcbfbfjjiaebaabegdgcafbfbeadca(I):
  for i in range(1, len(I)):
    for j in range(len(I[0])-2):
      if I[i][j] != mostcolor(I):
        I = paint(I, {(3, (i-1,j)), (3, (i-1,j+1)), (3, (i-1,j+2)), (3, (i,j)), (3, (i,j+1)), (3, (i,j+2)), (3, (i+1,j)), (3, (i+1,j+1)), (3, (i+1,j+2))})
  return I
 
6.5, tensor(0.0108), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted one square to the left and one square up from the colored square. 
:: def aabecbcefcdbebccabgbbcbaaecibbdf(I):
  return paint(I, merge(apply(lambda obj: recolor(3, shift(toindices(obj), (-1,-1))), objects(I, True, False, True))))
 
19.5, tensor(0.3604), Description: For each square that is colored with '1' in the input grid, draw a green square one square below it, two squares to the right of it, and three squares to the right of it. The green squares should be in the same row as the '1' square. If the '1' square is too close to the right edge of the grid, do not draw green squares that would extend beyond the grid. 
:: def bcjibjcehhgceadjaafebhcafcidfjeg(I):
  ones = recolor(ONE, ofcolor(I, ONE))
  shadow = shift(ones, DOWN) | shift(ones, (TWO, ZERO)) | shift(ones, (THREE, ZERO))
  return underfill(I, THREE, mapply(dneighbors, toindices(shadow)))
 
9.0, tensor(0.3342), Description: For each square that is colored with '1' in the input grid, draw a square of '3's two squares to the right of it. The '3' square should be in the same row as the '1' square. If the '1' square is too close to the right edge of the grid, do not draw a '3' square that would extend beyond the grid. 
:: def aajacejehfceeecebiechjdfgbhdgaea(I):
  return underfill(I, THREE, backdrop(shift(recolor(ONE, ofcolor(I, ONE)), (TWO, ZERO))))
 
6.5, tensor(1.9591), Description: For each square that is colored with '1' in the input grid, draw a square of '3's two squares below it. The '3' square should be in the same column as the '1' square. If the '1' square is in the bottom row, do not draw a '3' square below it. 
:: def bbeibadibcbjejbajabeiecdfcbdecdi(I):
  obj = recolor(ONE, ofcolor(I, ONE))
  return paint(I, {(THREE, (i + 2, j)) for _, (i, j) in obj})
 
5.0, tensor(1.4221), Description: For each square that is colored with '1' in the input grid, draw a square of '3's around it. The '3' square should be one square larger in each direction (up, down, left, right) than the '1' square. 
:: def bjifdhdddcdeedebahcecgdajbadbajc(I):
  obj = toobject(ofcolor(I, ONE), I)  # Find the object made of '1's
  expanded_indices = delta(toindices(obj))  # Get indices surrounding the object
  O = fill(I, THREE, expanded_indices)  # Fill surrounding indices with '3'
  return O
 
12.5, tensor(1.4221), Description: For each square that is colored with '1' in the input grid, draw a square of '3's around it. The '3' square should be one square larger in each direction (up, down, left, right) than the '1' square. 
:: def adadfgfeeidbedgcjjfeabdfcedddaaa(I):
  obj = toindices(toobject(ofcolor(I, ONE), I))
  neighborhood = mapply(dneighbors, obj) # Find all direct neighbors of object cells
  expansion = neighborhood - obj  # Exclude original object cells
  O = fill(I, THREE, expansion)
  return O
 
93.0, tensor(0.9382), Description: Replace all '1's in the input grid with '3's. The rest of the grid should remain black. 
:: def fjdfjcdcchbaeaefbfddedbgbfbgbeej(I):
  modified_grid = canvas(THREE, shape(I))  # Create a canvas filled with '3'
  obj = toobject(ofcolor(I, ONE), I)
  O = underpaint(modified_grid, obj) # Paint the original '1's onto the modified grid
  return O
 
6.5, tensor(0.0099), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted three squares to the left and one square up from the colored square. 
:: def ejhfdcgechhiefdbbhedabbaadcccfdi(I):
  return paint(I, merge(apply(lambda obj: recolor(3, shift(toindices(obj), (-3, 1))), objects(I, True, False, True))))
 
13.0, tensor(0.0115), Description: For each colored square in the input grid, draw a 3x3 square of green above and to the right of the square. The green square should be shifted three squares to the left and one square up from the colored square. 
:: def cddbcjdbiehfegjfjaffagbfhbadcefb(I):
  objs = objects(I, True, False, True)
  squares = frozenset()
  for obj in objs:
    for i in range(uppermost(obj) - 3, uppermost(obj) - 1):
      for j in range(leftmost(obj) + 1, leftmost(obj) + 4):
        squares = squares | {(3, (i, j))}
  return paint(I, squares)
 
7.0, tensor(0.3699), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def dhafhabcabggebaabacaffcgbibfcegc(I):
  h = height(I)
  w = width(I)
  def line(i, j):
    return {(THREE, (i, j-1)), (THREE, (i, j)), (THREE, (i, j+1))}
  return paint(I, frozenset((v, (i, j)) 
                  for i in range(h) 
                  for j in range(w) 
                  for v, (x, y) in line(i, j)
                  if 0 <= y < w and I[i][j] == ONE)) 
 
10.5, tensor(0.2552), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends one square above and one square below the '1' square. The line should be centered on the '1' square. 
:: def aheebegjigbfebchbebeacbfcfhhddfb(I):
  # Iterate through each cell in the grid
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell value is '1'
      if I[i][j] == ONE:
        # Paint a vertical line of '3's
        for k in range(-1, 2):
          if 0 <= i + k < height(I):
            O = paint(O, {(THREE, (i + k, j))})
  return O
 
5.5, tensor(0.0099), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted three squares to the left and one square up from the colored square. 
:: def bifcfgfddfdfefchjcbfeehjjcbfbeie(I):
  def process_object(obj):
    ul = ulcorner(obj)
    return recolor(3, shift(toindices(obj), (ul[0] - 3, ul[1] + 1)))
  return paint(I, merge(apply(process_object, objects(I, True, False, True))))
 
11.0, tensor(0.3699), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def chcfcfchcecdechebhbegadjgehehddd(I):
  return underfill(I, THREE, 
                  frozenset((i+1, j+k) for i, j in ofcolor(I, ONE) for k in {-1, 0, 1}))
 
9.0, tensor(1.8696), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def ecdibadjechfecgebbcejchcdeddabec(I):
  obj = toobject(ofcolor(I, ONE), I) # Identify the object
  left_extension = shift(toindices(obj), (0, -1)) # Shift indices left
  right_extension = shift(toindices(obj), (0, 1)) # Shift indices right
  O = underfill(I, THREE, left_extension | right_extension) # Fill left and right extensions with '3'
  return O
 
7.0, tensor(0.0108), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted one square to the left and one square up from the colored square. 
:: def cdfbjcecajageedcahfdejdbaeeddafd(I):
  return paint(I, merge(apply(lambda obj: recolor(3, shift(backdrop(shift(toindices(obj), (-1, 0))), (1, -1))), objects(I, True, False, True))))
 
6.5, tensor(0.0101), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted two squares to the left and one square up from the colored square. 
:: def ehcfdjchfafcedbijfaedacdacaceijh(I):
  def paint_square(obj):
    center = centerofmass(obj)
    square = backdrop(shift({center}, (-2, -1)))
    return recolor(3, square)
  return paint(I, merge(apply(paint_square, objects(I, True, False, True))))
 
9.5, tensor(0.3538), Description: For each square that is colored with '1' in the input grid, draw a T-shape of '3's around it. The T-shape should extend one square to the left, one square to the right, and one square above the '1' square. The T-shape should be centered on the '1' square. 
:: def jcfegdeeeeecegegaddcbibahbbjcfcg(I):
  def t_shape(i, j):
    return {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j)}

  return underfill(I, THREE, 
                  {idx 
                   for i, row in enumerate(I)
                   for j, val in enumerate(row)
                   if val == ONE
                   for idx in t_shape(i, j)})
 
9.0, tensor(1.8696), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def eiaeefgcfifjehififfcijaaedddjddg(I):
  obj = toobject(ofcolor(I, ONE), I)  # Object formed by '1's
  h_extended_obj = frozenset(merge(apply(lambda cell: frozenset({(cell[0], (cell[1][0], cell[1][1] - 1)), (cell[0], (cell[1][0], cell[1][1])), (cell[0], (cell[1][0], cell[1][1] + 1))}), obj))) # Generate horizontally extended object
  O = underpaint(I, h_extended_obj)  # Underpaint extended object onto original grid
  return O
 
6.5, tensor(0.0102), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted one square to the left from the colored square. 
:: def eficddgaaagbehffijiffffhdbdihefb(I):
  return paint(I, merge(apply(lambda obj: recolor(3, backdrop(shift(toindices(obj), (-1, 0)))), objects(I, True, False, True))))
 
5.0, tensor(0.0102), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted one square to the left from the colored square. 
:: def hhdfehadebbheaehacgeaaacceaddbce(I):
  return paint(I, merge(apply(lambda obj: recolor(3, backdrop(shift(obj, (-1, 0))) - toindices(shift(obj, (-1, 0)))), objects(I, True, False, True))))
 
11.0, tensor(1.8696), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def hcabdadedaefedefjgfagcbfihccefde(I):
  return fill(I, THREE, mapply(lambda idx: connect(add(idx,(0,-1)), add(idx,(0,1))), ofcolor(I, ONE))) 
 
10.0, tensor(1.8698), Description: For each instance of the '1' object in the input grid, draw a horizontal line of '3's below it. The line should extend one square to the left and one square to the right of the '1' object. The line should be centered on the '1' object. 
:: def jbcdabbadcahehecjbafebhdadfbaaai(I):
  horizontal_line = canvas(THREE, (1, 3)) # Create a horizontal line of '3's
  obj_locations = occurrences(I, ((ONE, (0, 1)),))  # Find locations of the '1' object
  O = I
  for loc in obj_locations:
    O = paint(O, shift(asobject(horizontal_line), loc))  # Paint the horizontal line at each object location
  return O
 
8.5, tensor(0.3690), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends one square below the '1' square and two squares to the right of the '1' square. The line should be centered on the '1' square. 
:: def bdjbbefjiiageedcifaadebaabbbjcdf(I):
  return underfill(I, THREE, 
                  mapply(lambda loc: connect(add(loc, DOWN), add(loc, (TWO, 0))), 
                         ofcolor(I, ONE)))
 
9.0, tensor(0.5062), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends three squares below the '1' square. The line should be centered on the '1' square. 
:: def ceebhcdefbeeejebjbefbcaddajjehdd(I):
  ones = ofcolor(I, ONE)
  return underfill(I, THREE, 
                  frozenset((i + di, j) for i, j in ones 
                          for di in range(1, 4)))
 
9.5, tensor(1.9828), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's one square above the square. The line should extend two squares to the right of the '1' square. The line should be centered on the '1' square. 
:: def cbebhihgdfgfeedbjhjdjjbgcdecbife(I):
  for i, j in ofcolor(I, ONE):
    I = fill(I, THREE, {(i-1, j),(i-1, j+1),(i-1, j+2)}) 
  return I
 
85.0, tensor(0.3609), Description: For each colored square in the input grid, draw a green square one square below it, two squares to the right of it, and three squares to the right of it. The green squares should be in the same row as the '1' square. If the '1' square is too close to the right edge of the grid, do not draw green squares that would extend beyond the grid. 
:: def dfhdajccbbaeecjeicegbjcbehaebhbi(I):
  return paint(I, 
               merge(apply(lambda obj: 
                              recolor(THREE, shift(obj, DOWN)) | 
                              recolor(THREE, shift(obj, (TWO, 0))) |
                              recolor(THREE, shift(obj, (THREE, 0))),
                           objects(I, True, False, False))))
 
5.0, tensor(0.3971), Description: For each square that is colored with '1' in the input grid, draw a vertical line of '3's that extends one square above and one square below the '1' square. The line should be centered on the '1' square. However, only draw the line if there is another '1' square directly to the left or right of the current '1' square. 
:: def gciechefjcbcecbfjedccfabgdjfchea(I):
  lines = mfilter(
    asindices(I),  # Get all indices of the grid
    lambda loc: index(I, loc) == ONE and  # Check for '1' 
                  any(index(I, (loc[0] + k, loc[1])) == ONE 
                      for k in [-1, 1] if 0 <= loc[0] + k < height(I)) 
  )
  return fill(I, THREE, lines) # Fill the detected lines with '3's
 
9.5, tensor(1.9820), Description: For each square that is colored with '1' in the input grid, draw a horizontal line of '3's that extends one square to the left and one square to the right of the '1' square. The line should be centered on the '1' square. 
:: def feaechcddbgcebbdbbccechjadfaefda(I):
  return fill(I, THREE, mapply(lambda loc: connect((loc[0]-1, loc[1]-1), (loc[0]-1, loc[1]+1)), ofcolor(I, ONE)))
 
7.0, tensor(0.0101), Description: For each colored square in the input grid, draw a 3x3 square of green around it. The center of the green square should be the same as the center of the colored square. The green square should be shifted one square to the right from the colored square. 
:: def fciecabcbaabeacbafedjcehfaacbaba(I):
  return paint(I, merge(apply(lambda obj: recolor(3, shift(obj, (1, 0))), objects(I, True, False, True))))
 
7.0, tensor(0.8511), Description: Copy the shape that is colored with '3' from the input grid and place it in the output grid at position (3, 3). The output grid should be a 10x10 grid filled with black squares except for the copied shape. 
:: def hjjifjecdiihebfbbbfgjcbjafbccaaf(I):
  obj = toobject(ofcolor(I, 3), I)  # Extract the object formed by '3'
  O = canvas(0, (10, 10))  # Create a 10x10 canvas of '0's
  O = paint(O, shift(obj, (3, 3)))  # Paint the object at (3,3)
  return O
 
8.0, tensor(1.9900), Description: If the '3' object in the input grid is larger than a single square, place a single '3' square at position (4, 4) in the output grid. Otherwise, place a single '3' square at position (1, 1) in the output grid. The output grid should be a 10x10 grid filled with black squares except for the placed '3' square. 
:: def jbdghdcadidceeeabfjdfgbefcacddje(I):
  # Find the '3' object in the input grid
  x1 = ofcolor(I, THREE) 
  
  # Create a 1x1 object with '3' at the origin
  x2 = recolor(THREE, {(ZERO, ZERO)}) 
  
  # Calculate the position to place the shrunk object based on input
  x3 = branch(size(x1) > ONE, (FOUR, FOUR), (ONE, ONE)) 
  
  # Create a 10x10 canvas of '0's
  x4 = canvas(ZERO, (TEN, TEN))
  
  # Shift the shrunk '3' object to the calculated position
  x5 = shift(x2, x3) 
  
  # Paint the shifted object onto the canvas
  O = paint(x4, x5) 
  return O
 
6.0, tensor(0.0858), Description: If the input grid contains any squares colored with '3', draw a 'T' shape of '3's in the output grid. The 'T' shape should be centered at position (4, 4) and extend one square up, one square down, and one square to the left and right. If the input grid does not contain any squares colored with '3', draw a vertical line of '3's in the output grid. The line should be centered at position (4, 4) and extend one square up and one square down. The output grid should be a 10x10 grid filled with black squares except for the drawn 'T' shape or vertical line. 
:: def cdcibbbffgheefhcabgjehfbdjcafgca(I):
  # Find objects formed by the character '3'
  target_objects = colorfilter(objects(I, True, False, False), 3)
  
  # Create a blank canvas 
  canvas_size = (10, 10) 
  output = canvas(0, canvas_size)
  
  # If '3' forms an object, draw a 'T', else a vertical line
  if target_objects:
    output = fill(output, 3, connect((4,3),(4,5)))
    output = fill(output, 3, connect((3,4),(5,4)))
  else:
    output = fill(output, 3, connect((3,4),(5,4))) 

  return output
 
7.0, tensor(1.9546), Description: If the '3' object in the input grid is larger than a single square, place the '3' object at position (4, 4) in the output grid. Otherwise, place the '3' object at position (3, 3) in the output grid. The output grid should be a 10x10 grid filled with black squares except for the placed '3' object. 
:: def beeefijdaifjecabjicfcafcbeaacgdi(I):
  # Find the '3' object in the input grid
  three_obj = toobject(ofcolor(I, THREE), I)
  
  # Determine offset based on object size
  offset = (FOUR, FOUR) if size(three_obj) > ONE else (THREE, THREE) 

  # Create a 10x10 canvas of '0's
  O = canvas(ZERO, (TEN, TEN))
  
  # Paint the '3' object onto the canvas at the calculated offset
  O = paint(O, shift(three_obj, offset))
  return O
 
3540.0, tensor(0.0741), Description: Find the least common non-space character in the input grid. Draw a horizontal cross of '3's centered on the location of that character in the output grid. The cross should extend one square to the left and right, and one square above and below the center. The output grid should be a grid of '0's with the cross of '3's painted on it. 
:: def aacaedaecheceajfiiadhghchaehhdfa(grid):
  # Find the least common non-space character 
  char_counts = {}
  for row in grid:
    for char in row:
      if char != ' ':
        char_counts[char] = char_counts.get(char, 0) + 1
  target_char = min(char_counts, key=char_counts.get)

  # Find the target character's location
  target_loc = next((i, j) for i, row in enumerate(grid) for j, c in enumerate(row) if c == target_char)

  # Create a canvas of '0's
  output_grid = canvas('0', (len(grid), len(grid[0])))

  # Paint the horizontal cross
  output_grid = fill(output_grid, '3', {(target_loc[0] + i, target_loc[1]) for i in range(-1, 2)})
  output_grid = fill(output_grid, '3', {(target_loc[0], target_loc[1] + j) for j in [-1, 1]})
  
  return output_grid
 
7.0, tensor(0.0858), Description: If the input grid contains any squares colored with '3', draw a 'T' shape of '3's in the output grid. The 'T' shape should be centered at position (4, 4) and extend one square up, one square down, and one square to the left and right. If the input grid does not contain any squares colored with '3', draw a vertical line of '3's in the output grid. The line should be centered at position (4, 4) and extend one square up and one square down. The output grid should be a 10x10 grid filled with black squares except for the drawn 'T' shape or vertical line. 
:: def fdhfggbeijbfecdbafegcedijbbfddea(I):
  # Draw the T-shape
  output = fill(canvas(0, (10, 10)), 3, connect((4,3),(4,5)) | connect((3,4),(5,4)))
  
  # Determine the location of vertical lines based on the presence of color 3 in the input
  one_locations = {(1, 4), (8, 4), (1, 5), (8, 5)} if colorcount(asobject(I), 3) > 0 else {(0, 3), (8, 3), (0, 8), (8, 8)}
  
  # Draw the vertical lines
  return fill(output, 1, one_locations)
 
15.0, tensor(0.0615), Description: If the input grid contains any squares colored with '3', draw a 'T' shape of '3's in the output grid. The 'T' shape should be centered at position (4, 4) and extend one square up, one square down, and one square to the left and right. If the input grid does not contain any squares colored with '3', draw two vertical lines of '1's in the output grid. The lines should be centered at positions (4, 4) and (4, 5) and extend one square up and one square down. Also, draw two vertical lines of '8's in the output grid. The lines should be centered at positions (3, 4) and (8, 4) and extend one square up and one square down. The output grid should be a 10x10 grid filled with black squares except for the drawn 'T' shape or vertical lines. 
:: def chcddebbiaaieihfjicdggccbichidbf(I):
  # Define a function to draw a single vertical line
  draw_vline = lambda g, col, r_start, r_end: fill(g, 1, {(col, j) for j in range(r_start, r_end + 1)})
  
  # Create the canvas and draw the T-shape
  output = fill(canvas(0, (10, 10)), 3, connect((4,3),(4,5)) | connect((3,4),(5,4)))
  
  # Conditionally draw vertical lines using the helper function
  return branch(
      3 in palette(asobject(I)),
      lambda g: draw_vline(draw_vline(g, 1, 4, 5), 8, 4, 5),
      lambda g: draw_vline(draw_vline(g, 0, 3, 8), 8, 3, 8)
  )(output)
 
