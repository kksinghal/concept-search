3.7142857142857144, tensor(0.0193), Description: Move the 3x3 blue shape to the bottom middle of the grid. Move the 3x3 red shape to the bottom right corner of the grid. Keep the original colors. 
:: def eahaebifgadaechjjefjidbhagiffccj(I):
  objs = objects(I, T, F, F)
  threes = colorfilter(objs, 3)
  fours = colorfilter(objs, 4)
  three = first(threes)
  four = first(fours)
  new_three_loc = (height(I)-1, width(I)//2)
  new_four_loc = (height(I)//2, width(I)-1)
  O = paint(paint(cover(cover(I, three), four), shift(three, subtract(new_three_loc, ulcorner(three)))), shift(four, subtract(new_four_loc, ulcorner(four))))
  return O
 
3.857142857142857, tensor(0.0193), Description: Move the 3x3 blue shape to the bottom middle of the grid. Move the 3x3 red shape to the bottom right corner of the grid. Keep the original colors. 
:: def abgcfecaeeigedhbjddfefbibeagfdbj(I):
  threes = colorfilter(objects(I, T, F, F), 3)
  fours = colorfilter(objects(I, T, F, F), 4)
  bottom_center = (height(I) - 1, width(I) // 2)
  right_center = (height(I) // 2, width(I) - 1)
  moved_threes = apply(lambda x: shift(x, subtract(bottom_center, ulcorner(x))), threes)
  moved_fours = apply(lambda x: shift(x, subtract(right_center, ulcorner(x))), fours)
  O = paint(paint(I, merge(moved_threes)), merge(moved_fours))
  return O
 
3.4285714285714284, tensor(0.0112), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def jdcefjcedbdcecdeieacecgihcfgejeh(I):
  objs = objects(I, False, False, True)
  return paint(canvas(0, shape(I)), merge({shift(obj, (height(I) // 2 - center(obj)[0], 0)) for obj in objs}))
 
3.0, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def bicedcbceggdefbbidgcggffbeebccec(grid):
  objs = objects(grid, False, False, True)
  new_objs = frozenset()
  for obj in objs:
    i = uppermost(obj)
    width_obj = width(obj)
    offset = (0, len(grid[0]) // 2 - width_obj // 2)
    new_objs = new_objs | shift(obj, offset)
  return paint(canvas(0, shape(grid)), new_objs)
 
2.0, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def aaffjhegibeaegecjhbeicjcecacdbfe(grid):
  return tuple(
      tuple(
          v if (i, j) == (i, len(r) // 2 - r.count(v) // 2 + r.index(v)) else 0 
          for j, v in enumerate(r)
      )
      for i, r in enumerate(grid)
  )
 
3.4285714285714284, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ihhcafbbadggegcbbbfcfabifjfjfbja(I):
  objs = objects(I, False, False, True)
  grid_center = (len(I[0]) // 2) 
  moved_objs = frozenset()
  for obj in objs:
    obj_center = centerofmass(obj)[1]
    direction = (0, 1) if obj_center < grid_center else (0, -1)
    steps = abs(obj_center - grid_center)
    moved_objs = insert(shift(obj, multiply(direction, steps)), moved_objs)
  O = paint(I, merge(moved_objs))
  return O 
 
3.0, tensor(0.0083), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Move the 3x3 red shape to the middle of the grid horizontally. Keep the original colors. 
:: def ibacabbjaejfehbabeegebhbbjbdahde(I):
  obj3 = first(colorfilter(objects(I, False, False, True), 3))
  obj4 = first(colorfilter(objects(I, False, False, True), 4))
  grid_center = tojvec(len(I[0]) // 2)
  moved_obj3 = shift(obj3, subtract(grid_center, centerofmass(obj3)))
  moved_obj4 = shift(obj4, subtract(grid_center, centerofmass(obj4)))
  O = paint(paint(I, moved_obj3), moved_obj4)
  return O
 
3.4285714285714284, tensor(0.0077), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def aadagefdbdfgecjhaeeahdjbeefcebab(I):
  c = len(I[0]) // 2
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, {(v, (i, c))})
  return O
 
2.0, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def hjicaceacabcedhiafihicdfhgcadeji(I):
  g = len(I[0]) // 2
  return tuple(tuple(v if j == g else 0 for j, v in enumerate(row)) for row in I)
 
3.4285714285714284, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def bdaeebeaehfcedccieafejebbfdeegjb(I):
  objs = objects(I, F, F, T) 
  out = canvas(0, shape(I))
  for obj in objs:
    new_obj = shift(obj, (len(I) // 2 - centerofmass(obj)[0], 0))
    out = paint(out, new_obj) 
  return out 
 
4.571428571428571, tensor(0.0051), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def jgbdcgffdffjeiegafjjddadadccfcia(I):
  h = len(I)
  return tuple(
    tuple(
      index(I, (i - h//2 + j, k)) if 0 <= i - h//2 + j < h else 0
      for k in range(len(I[0]))
    )
    for i, row in enumerate(I)
    for j in range(h) if i - h//2 + j == h//2 
  )
 
3.0, tensor(0.0054), Description: Move each colored shape to the middle of the grid vertically and horizontally. Keep the original colors. 
:: def afjchdfibdfdeieaiahdffgebcfdjjjj(I):
    objs = objects(I, False, False, True)
    out = canvas(0, shape(I))
    for obj in objs:
        x_offset = centerofmass(obj)[1] - width(obj) // 2
        new_obj = shift(obj, (height(out) // 2 - centerofmass(obj)[0], -x_offset))
        out = paint(out, new_obj)
    return out
 
36.0, tensor(0.0051), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def eifecceafcdaeaegjdcjgacfihdhjcdb(I):
    return tuple(
        tuple(
            I[i - len(I) // 2 + centerofmass(obj)[0]][j] 
            if 0 <= i - len(I) // 2 + centerofmass(obj)[0] < len(I)
            else 0
            for j in range(len(I[0]))
        )
        for obj in objects(I, False, False, True)
        for i in range(len(I)) if i == centerofmass(obj)[0] 
    )
 
3.4285714285714284, tensor(0.0212), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the second to last column, middle row of the grid. Keep the original colors. 
:: def aejdfdbbdaaeebfdjjidafdgbcfgcecj(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  target_three = (height(I)-2, width(I)//2)
  target_four = (height(I)//2, width(I)-2)
  O = paint(paint(cover(cover(I, three), four), shift(three, subtract(target_three, ulcorner(three)))), shift(four, subtract(target_four, ulcorner(four))))
  return O
 
3.4285714285714284, tensor(0.0212), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the second to last column, middle row of the grid. Keep the original colors. 
:: def facbjcbcedbdefedieafbefccifhdajb(I):
  threes = colorfilter(objects(I, T, F, F), 3)
  fours = colorfilter(objects(I, T, F, F), 4)
  O = paint(paint(I, shift(first(threes), (height(I)-2-uppermost(first(threes)), width(I)//2-leftmost(first(threes))))),
                shift(first(fours), (height(I)//2 - uppermost(first(fours)), width(I)-2-leftmost(first(fours)))))
  return O
 
3.4285714285714284, tensor(0.0113), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def cccabdjiajafecbhaiebjicaagabdbcj(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), 0)) for obj in objects(I, False, False, True)}))
 
1.7142857142857142, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def cdcjdaedibeaebhcjbecedabgiehedfb(grid):
  return tuple(
      tuple(
          0 if j != len(row) // 2 - row.count(c) // 2 + i
          else c
          for j, c in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
3.4285714285714284, tensor(0.0077), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def cgjhjdabaddbedffjdihdjjdjffbecba(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (len(I) // 2 - uppermost(obj), 0)))
  return O
 
2.5714285714285716, tensor(0.0051), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bhebbabegadaecehjeaijjbdjdfcijbb(I):
  return tuple(
      tuple(
          next(
              (
                  v
                  for obj in objects(I, F, F, T)
                  for v, (i2, j2) in obj
                  if i2 == i + len(I) // 2 - centerofmass(obj)[0] and j2 == j
              ),
              0,
          )
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
3.5714285714285716, tensor(0.0213), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the second to last row, middle column of the grid. Keep the original colors. 
:: def fjjeebffbgceecceaeeihdeeadbifiag(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  O = paint(paint(cover(cover(I, three), four), 
                shift(three, (height(I)-1-2*ulcorner(three)[0], 0))), 
                shift(four, (height(I)-1-2*ulcorner(four)[0], 0)))
  return O
 
3.142857142857143, tensor(0.0168), Description: Move the 3x3 blue shape to the same row as the 3x3 red shape, but to the left of it. Move the 3x3 red shape to the same row as the 3x3 blue shape, but to the right of it. Keep the original colors. 
:: def fjffbbhgebbgefhgaeaacfiieehhhdga(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  three_center = center(three)
  four_center = center(four)
  O = paint(paint(cover(cover(I, three), four), 
                shift(three, (int(four_center[0]-three_center[0]), 0))),
                shift(four, (int(three_center[0]-four_center[0]), 0)))
  return O
 
3.4285714285714284, tensor(0.0112), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dgjgbdbcehdaegddachbijdadcjidieb(I):
    objs = objects(I, False, False, True)
    return paint(canvas(0, shape(I)), merge({shift(obj, (0, width(I) // 2 - center(obj)[1])) for obj in objs}))
 
3.4285714285714284, tensor(0.0112), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def gddeeeidjcaaejjdiafebifijeeigeee(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, (width(I) - width(obj)) // 2 - leftmost(obj))) for obj in objects(I, False, False, True)}))
 
3.2857142857142856, tensor(0.0112), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ajebfcidbbabefbgjdgfcagaffcjfcdd(I):
    objs = objects(I, False, False, True)
    centered_objs = []
    for obj in objs:
        x = centerofmass(obj)[1] 
        offset =  width(I) // 2 - x 
        centered_objs.append(shift(obj, (0, offset)))
    return paint(canvas(0, shape(I)), merge(centered_objs))
 
2.0, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dhdcffajefjgebbbifabhefgdabbadga(I):
  w = width(I) // 2
  return tuple(
    tuple(v if j == w else 0 for j, v in enumerate(
      tuple(v for v in row if v != 0) + tuple(0 for _ in range(len(row) - len(tuple(v for v in row if v != 0))))
    )) 
    for row in I
  )
 
3.4285714285714284, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def cdbgdcdcdibceiddidadfadbadfjccfd(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    obj = frozenset((v, (i, j)) for j, v in enumerate(row) if v != 0)
    if obj:
      O = paint(O, shift(obj, (0, len(I[0]) // 2 - centerofmass(obj)[1])))
  return O
 
49.0, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def gchbfdbdciefeccdjebcdbefaeihbgca(I):
  return tuple(
    tuple(
      next((v for v, (i2, j2) in obj if i2 == i and j2 == j + len(I[0])//2 - centerofmass(obj)[1]), 0)
      for j in range(len(I[0])))
    for i, row in enumerate(I)
    for obj in objects(I, F, F, T)
  )
 
3.2857142857142856, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dhfbebcajfbbeacdiacbjabgijbcfbgf(I):
  objs = objects(I, F, F, T)
  return tuple(
    tuple(
      next((v for obj in objs for v, (i2, j2) in shift(obj, (0, len(I[0])//2 - centerofmass(obj)[1])) if i2 == i and j2 == j), 0) 
      for j in range(len(I[0])))
    for i in range(len(I))
  )
 
2.0, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def fbjgjhgaebgceahdibfbaaidfjjebdaf(I):
  return tuple(
    tuple(
      next((I[i][j2] for obj in objects(I, F, F, T) 
            for i2, j2 in toindices(shift(obj, (0, len(I[0])//2 - centerofmass(obj)[1])))
            if i2 == i and j2 == j), 0) 
      for j in range(len(I[0])))
    for i in range(len(I))
  )
 
49.142857142857146, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def gdbbfejbicgdefdcifcdfbaehgajaigb(I):
  return tuple(
      tuple(
          index(I, (i, j + len(I[0]) // 2 - centerofmass(obj)[1]))
          if 0 <= j + len(I[0]) // 2 - centerofmass(obj)[1] < len(I[0])
          else 0
          for j in range(len(I[0]))
      )
      for i, row in enumerate(I)
      for obj in objects(I, F, F, T)
  )
 
3.142857142857143, tensor(0.0179), Description: Move the 3x3 blue shape to the right of the 3x3 red shape. Move the 3x3 red shape to the left of the 3x3 blue shape. Keep the original colors. 
:: def ecbjccdeiefdejcaicefbeceddefdjif(I):
    three_indices = ofcolor(I, 3)
    four_indices = ofcolor(I, 4)
    O = paint(paint(cover(cover(I, three_indices), four_indices), 
                  recolor(3, shift(three_indices, (0, rightmost(four_indices) - rightmost(three_indices))))), 
                  recolor(4, shift(four_indices, (0, leftmost(three_indices) - leftmost(four_indices))))) 
    return O
 
3.142857142857143, tensor(0.0179), Description: Move the 3x3 blue shape to the right of the 3x3 red shape. Move the 3x3 red shape to the left of the 3x3 blue shape. Keep the original colors. 
:: def ibbfdfgfbcifeibfaiedcccaifdajfcf(I):
    three_obj = extract(objects(I, T, F, F), matcher(color, 3))
    four_obj = extract(objects(I, T, F, F), matcher(color, 4))
    three_shift = (0, rightmost(four_obj) - rightmost(three_obj))
    four_shift = (0, leftmost(three_obj) - leftmost(four_obj))
    O = paint(paint(I, shift(three_obj, three_shift)), shift(four_obj, four_shift))
    return O
 
1.4285714285714286, tensor(0.0099), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def ddcceaafffbceabejafeiedcfbcejbfg(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  offset = (0, width(I) // 2 - center(three)[1])
  return paint(cover(I, three), shift(three, offset))
 
2.5714285714285716, tensor(0.0155), Description: Copy the input grid. Then, move each colored shape to the left by half the width of the grid. Keep the original colors. 
:: def gjdihidcfcbdejcgaahidbcafhcdgbdb(I):
  shifted_I = hconcat(righthalf(I), lefthalf(I)) 
  objs = objects(shifted_I, False, False, True)
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, -width(I) // 2)) for obj in objs}))
 
1.8571428571428572, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def bacceabaeehfeeacjcccbcadhbgddcaa(I):
  c = width(I) // 2
  return tuple(
      tuple(v if j == c else 0 for j, v in enumerate(sorted(row, key=lambda x: x != 0)))
      for row in I
  )
 
3.142857142857143, tensor(0.0094), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ajbddbcdcffcehjajffdeddacgaibeba(I):
  c = width(I) // 2
  return tuple(
    tuple(0 if j != c else next((v for v in row if v != 0), 0) for j in range(len(row)))
    for row in I
  )
 
3.2857142857142856, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def bhfgecfgagffehcfaecbeajgigccjhgf(I):
  objs = objects(I, F, F, T)
  out = canvas(0, shape(I))
  for obj in objs:
    new_obj = shift(obj, (0, len(I[0]) // 2 - centerofmass(obj)[1]))
    out = paint(out, new_obj)
  return out
 
2.7142857142857144, tensor(0.0179), Description: Move the 3x3 blue shape to the right of the 3x3 red shape. Move the 3x3 red shape to the left of the 3x3 blue shape. Keep the original colors. 
:: def hbbbebgbdjaeededbeebgbbbffcdbajg(I):
  three_obj = extract(objects(I, T, F, F), matcher(color, 3))
  four_obj = extract(objects(I, T, F, F), matcher(color, 4))
  O = paint(
      paint(cover(I, three_obj), recolor(3, shift(three_obj, tojvec(rightmost(four_obj) - rightmost(three_obj))))),
      recolor(4, shift(four_obj, tojvec(leftmost(three_obj) - leftmost(four_obj))))
  )
  return O
 
3.4285714285714284, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def jfaafgdgbficecaaiiebhddbgecfabac(grid):
  objs = objects(grid, True, False, True)
  center_col = len(grid[0]) // 2
  moved_objs = frozenset(shift(obj, (0, center_col - centerofmass(obj)[1])) for obj in objs)
  return paint(canvas(0, shape(grid)), merge(moved_objs))
 
2.0, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def jgjfebcfadfbeeaeaffecieejjdhgbfj(grid):
  h, w = len(grid), len(grid[0])
  center_col = w // 2
  return tuple(
      tuple(
        v if j == center_col else 0 
        for j, v in enumerate(
          sorted(r, key=lambda x: x != 0, reverse=True)
        )
      ) 
      for i, r in enumerate(grid)
  )
 
3.142857142857143, tensor(0.0075), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def afcijfddbcfjejdabccafiecffahfhid(grid):
    h, w = len(grid), len(grid[0])
    center = w // 2
    return tuple(
        tuple(
            next((v for v in row if v != 0), 0) if j == center and any(v != 0 for v in row) else 0 
            for j in range(w)
        ) for row in grid
    )
 
2.142857142857143, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dfddechefdjgehcciceciabhdaibcead(I):
  c = width(I) // 2
  return tuple(
    tuple(0 if j != c else row[k] for j, k in enumerate(range(-c, len(row) - c)))
    for i, row in enumerate(I)
  ) 
 
2.142857142857143, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ajdbhgeibiaeedjjjdccgcddfdggjcec(I):
    return tuple(
        tuple(
            I[i][j + len(I[0]) // 2 - (len(I[i]) + sum(1 for v in I[i] if v != 0)) // 2] 
            if j >= (len(I[i]) - sum(1 for v in I[i] if v != 0)) // 2 and j < (len(I[i]) + sum(1 for v in I[i] if v != 0)) // 2
            else 0
            for j in range(len(I[0])))
        for i in range(len(I))
    )
 
2.4285714285714284, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def daciebfdcbabeebdbbiejfdiefabddec(I):
  return tuple(
    tuple(
      next((I[i][k] for k in range(len(I[0])) if I[i][k] != 0 and k - j == len(I[0]) // 2 - (sum(1 for v in I[i] if v != 0) + 1) // 2), 0)
      for j in range(len(I[0])))
    for i in range(len(I))
  )
 
2.857142857142857, tensor(0.0161), Description: Move the 3x3 blue shape to the center of the grid. Move the 3x3 red shape to the bottom right corner of the grid. Keep the original colors. 
:: def ahbdegbdbiajebeajadbeeidcdccffai(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  center_three = (height(I)//2, width(I)//2) 
  bottom_right_four = (height(I)-1, width(I)-1)
  O = paint(paint(cover(cover(I, three), four), 
                 shift(three, subtract(center_three, ulcorner(three)))), 
                 shift(four, subtract(bottom_right_four, ulcorner(four))))
  return O
 
3.0, tensor(0.0113), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def ffbcgafaaedeeaaejegcbcfejdhaifea(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (subtract(halve(height(I)), halve(add(uppermost(obj), height(obj)))), 0)) for obj in objects(I, False, False, True)}))
 
3.4285714285714284, tensor(0.0113), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def eccfdabbigegedafadedjfdjghcdfcbc(I):
  centered_objs = []
  for obj in objects(I, False, False, True):
    shift_amount = (height(I) // 2) - (uppermost(obj) + height(obj) // 2)
    centered_objs.append(shift(obj, (shift_amount, 0)))
  return paint(canvas(0, shape(I)), merge(centered_objs))
 
3.142857142857143, tensor(0.0113), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bbfhjidceffaeedjibegdheddceadegd(I):
  new_objs = set()
  for value, (i, j) in asobject(I):
    if value != mostcommon(I):
      new_i = (height(I) // 2) - (i + 1) // 2 
      new_objs.add((value, (new_i, j)))
  return paint(canvas(0, shape(I)), frozenset(new_objs)) 
 
3.142857142857143, tensor(0.0089), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the bottom row, middle column of the grid. Keep the original colors. 
:: def ecdcbhhhigcdefbfaghfafcfgeghffgh(grid):
  objs = objects(grid, False, False, True)
  new_objs = frozenset()
  h, w = len(grid), len(grid[0])
  for obj in objs:
    value = color(obj)
    if value == 3:
      offset = (h // 2 - uppermost(obj) - 1, w // 2 - leftmost(obj) - width(obj) // 2)
    elif value == 4:
      offset = (h - uppermost(obj) - height(obj), 0)
    else:
      offset = (0, 0)
    new_objs = new_objs | shift(obj, offset)
  return paint(canvas(0, shape(grid)), new_objs)
 
45.857142857142854, tensor(0.0089), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the bottom row, middle column of the grid. Keep the original colors. 
:: def bfiacdffebfjeaecjebabdgffchcgbgf(grid):
  h, w = len(grid), len(grid[0])
  obj3 = recolor(0, extract(objects(grid, False, False, True), lambda obj: color(obj) == 3))
  obj4 = recolor(0, extract(objects(grid, False, False, True), lambda obj: color(obj) == 4))
  grid = paint(paint(canvas(0, shape(grid)), shift(obj3, (h // 2 - uppermost(obj3) - 1, w // 2 - leftmost(obj3) - width(obj3) // 2))), shift(obj4, (h - uppermost(obj4) - height(obj4), 0)))
  return replace(replace(grid, 0, 3), 0, 4)
 
8.142857142857142, tensor(0.1338), Description: Description: Place a blue square in the center of the grid, one row above the bottom row. Place a red square in the bottom right corner of the grid. Keep the original colors. 
:: def acahfgdecdheeifaaiejbbjaacfcedaa(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
    tuple(
      branch(j == w // 2 and i == h // 2 - 1, 3, branch(i == h - 1, 4, 0))
      for j in range(w)
    ) for i in range(h)
  )
 
8.0, tensor(0.0420), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. If the shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def bdbdcdebhdfdehaibeiiagebffefcgbb(I):
  w = width(I) 
  c = w // 2
  return tuple(
    tuple(0 for _ in range(c - len(row) // 2)) + tuple(v for v in row if v != 0) + tuple(0 for _ in range(c + len(row) // 2 - len(tuple(v for v in row if v != 0))))
    if len(row) <= w else
    tuple(v for v in row if v != 0)
    for row in I
  )
 
2.0, tensor(0.0443), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. If the shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def ceiecfaeggccefchjeceaaihabihjcaf(I):
  c = width(I) // 2
  return tuple(
    tuple(0 if j < c - len([v for v in row if v != 0]) // 2 or j >= c + len([v for v in row if v != 0]) // 2 else next((v for v in row if v != 0), 0) for j in range(len(row)))
    for row in I
  )
 
1.7142857142857142, tensor(0.0443), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. If the shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def ichdbcafeecfedebbfedhebcijfddhac(I):
  w = width(I)
  c = w // 2
  return tuple(
    tuple(0 if abs(j - c) >= len([v for v in row if v != 0]) // 2 else next((v for v in row if v != 0), 0) for j in range(w))
    for row in I
  )
 
3.142857142857143, tensor(0.0180), Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the bottom right corner of the grid. Keep the original colors. 
:: def gicdeebacabbebjdjbabcdbidcghgcbb(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  target_three = (height(I)-2, width(I)//2 - width(three)//2)
  target_four = (height(I)-1, width(I)-1)
  O = paint(paint(cover(cover(I, three), four), shift(three, subtract(target_three, ulcorner(three)))), shift(four, subtract(target_four, ulcorner(four))))
  return O
 
3.4285714285714284, tensor(0.0100), Description: Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bejbbeciafibeahbbecdigcjdfcacefa(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), 0)))
  return O
 
1.4285714285714286, tensor(0.0094), Description: Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def fiacaeidaacdecciadddbfifgfdefaaf(grid):
  objs = objects(grid, False, False, True)
  new_objs = frozenset()
  h, w = len(grid), len(grid[0])
  for obj in objs:
    value = color(obj)
    if value == 3:
      offset = (0, w // 2 - leftmost(obj) - width(obj) // 2)
    else:
      offset = (0, 0)
    new_objs = new_objs | shift(obj, offset)
  return paint(canvas(0, shape(grid)), new_objs)
 
3.5714285714285716, tensor(0.0099), Description: Copy the left half of the grid to the output. Then, copy the top row of the grid and fill in the black squares with blue squares. Finally, copy the right half of the grid to the output. 
:: def acegacbdjfijeddcbbbeadgigfdcidfj(grid):
  return hconcat(
      lefthalf(grid),
      hconcat(
          fill(
              crop(grid, (0, len(grid[0]) // 2), (len(grid), 1)),
              3,
              {(0, i) for i, v in enumerate(grid[0]) if v == 3}
          ),
          righthalf(grid)
      )
  )
 
3.4285714285714284, tensor(0.0078), Description: Move each colored shape to the middle of the grid vertically, keeping the original colors. The shapes should be ordered from top to bottom based on their uppermost row. 
:: def ccjbacfbjbcaejdbjdchgbciijcbbffb(I):
    objs = objects(I, False, False, True)
    O = canvas(0, shape(I))
    for i, obj in enumerate(sorted(objs, key=uppermost)):
        O = paint(O, shift(obj, (len(I) // 2 - center(obj)[0], 0)))
    return O
 
3.0, tensor(0.0077), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bchcdacfdcabeffcbaajbfabbfbfhhcg(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    offset = subtract((len(I) // 2, 0), centerofmass(obj))
    O = paint(O, shift(obj, offset))
  return O
 
3.2857142857142856, tensor(0.0094), Description: Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def hejedehdhcdfehabaeijdjifccfcfdfc(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, {(v, (i, len(I) // 2))})
  return O
 
3.4285714285714284, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def iaifeiideaajeeaejhajdjefdffadeej(I):
  objs = objects(I, False, False, True)
  out = canvas(0, shape(I))
  for obj in objs:
    x_offset =  centerofmass(obj)[1] - width(obj) // 2
    new_obj = shift(obj, (0, -x_offset))
    out = paint(out, new_obj)
  return out
 
3.4285714285714284, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def gdddheejbefeeaajbcideddieaiihjie(I):
  out = canvas(0, shape(I))
  for i, row in enumerate(I):
    obj_indices = [j for j, v in enumerate(row) if v != 0]
    if obj_indices:
      center_j = sum(obj_indices) // len(obj_indices)
      offset = center_j - len(row) // 2
      out = paint(out, {(v, (i, j - offset)) for j, v in enumerate(row) if v != 0})
  return out
 
1.1428571428571428, tensor(0.0137), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def iigfbcjjcjfjedaebecdccabgdcchice(I):
  objs = objects(I, T, F, F)  # Extract objects from the input grid.
  three = first(colorfilter(objs, 3))  # Get the object containing the digit "3".
  center_i = height(I) // 2  # Calculate the row index of the grid center.
  center_j = width(I) // 2  # Calculate the column index of the grid center.
  target = (center_i, center_j) # Define the target location as the grid center.
  offset = subtract(target, centerofmass(three))  # Calculate the offset to move the "3".
  O = paint(cover(I, three), shift(three, offset)) # Move the "3" to the center.
  return O
 
2.142857142857143, tensor(0.0137), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def adeieigjcchdeedaibcbbdedcdaiiifi(I):
  three = first(colorfilter(objects(I, T, F, F), 3)) # Find the "3" object.
  h, w = shape(I) # Get grid height and width.
  target = (h // 2, w // 2) # Calculate target location (center).
  O = paint(I, shift(three, subtract(target, ulcorner(three)))) # Move "3" to the target.
  return O
 
49.142857142857146, tensor(0.0113), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bcehbbhifdjeeeffaibhgdbdbcebfeeg(I):
  return tuple(
    tuple(
      next((v for v, (i2, j2) in obj if (i2, j2) == ((height(I) - height(obj)) // 2 + i - uppermost(obj), j)), 0) 
      for j in range(width(I))
    ) 
    for i, row in enumerate(I) for obj in objects(I, False, False, True)
  )
 
2.4285714285714284, tensor(0.0094), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def bebifbdjbjffehdciehedbfejbijeijd(grid):
  three_indices = ofcolor(grid, 3)
  return paint(canvas(0, shape(grid)), shift(recolor(3, three_indices), (0, len(grid[0]) // 2 - leftmost(three_indices) - width(three_indices) // 2))) 
 
2.4285714285714284, tensor(0.0094), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def jcdhebefffdcejddijbdaafadhbgabdc(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
          3 if (i, j) in shift(ofcolor(grid, 3), (0, w // 2 - leftmost(ofcolor(grid, 3)) - width(ofcolor(grid, 3)) // 2)) else v 
          for j, v in enumerate(r)
      )
      for i, r in enumerate(grid)
  )
 
35.42857142857143, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def jdbgjdfbcefhefedbcffdgfaedbdfede(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  c = width(I) // 2
  return tuple(
      tuple(next((v for (v, (i, j)) in obj if j == c), 0) if any(j == c for _, (i, j) in obj) else 0 for j in range(width(I)))
      for obj in objs
  )
 
2.4285714285714284, tensor(0.0062), Description: Move each colored shape to the center of the grid. Keep the original colors. 
:: def fbbagbbfajiieadbbaecjcjgecdfcggg(I):
  objs = objects(I, False, False, True)
  out = canvas(0, shape(I))
  for obj in objs:
    new_obj = shift(obj, (height(out) // 2 - centerofmass(obj)[0], len(out[0]) // 2 - centerofmass(obj)[1]))
    out = paint(out, new_obj)
  return out
 
34.857142857142854, tensor(0.0051), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def abbcjddfehfeeecbaahaegbaacghaeac(I):
    return tuple(
        tuple(
            I[i][j2] if (i2, j2) in {(i, len(I[0]) // 2) for i in range(len(I))} else 0
            for j2, (i2, j) in enumerate(
                (i, j) for obj in objects(I, False, False, True) for (i, j) in toindices(obj)
            )
        )
        for i in range(len(I))
    )
 
3.142857142857143, tensor(0.0173), Description: Move the 3x3 blue shape to the center of the grid. Move the 3x3 red shape to the center of the grid, but one row below the blue shape. Keep the original colors. 
:: def feadhabdicbbebjeigjcbdffhcdaabci(I):
  objs = objects(I, T, F, F)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  target_three = (height(I) // 2, width(I) // 2 - (width(I) % 2 == 0))
  O = paint(paint(cover(cover(I, three), four), shift(three, subtract(target_three, ulcorner(three)))), shift(four, subtract((target_three[0]+1, target_three[1]), ulcorner(four))))
  return O
 
2.0, tensor(0.0165), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. The offset for each row is calculated based on the position of the colored shapes in that row. 
:: def caaicjehfbhceaffjcbaidajfbbbicfd(I):
  return tuple(
      tuple(
          v if j == width(I) // 2 + j_offset(i, I) else 0 
          for j, v in enumerate(row)
      ) 
      for i, row in enumerate(I)
  )
 
2.5714285714285716, tensor(0.0165), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. The offset for each row is calculated based on the position of the colored shapes in that row. 
:: def fdbejhabdcijecadagccjediieicbeii(I):
  return tuple(
      tuple(
          I[i][j - (obj_horizontal_center(i, I) - width(I) // 2)] if j - (obj_horizontal_center(i, I) - width(I) // 2) in range(width(I)) else 0
          for j in range(width(I))
      )
      for i in range(height(I))
  )
 
2.142857142857143, tensor(0.0089), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def hgjbeaefbbjieabgjgiafjacdbjbdfad(grid):
  h, w = len(grid), len(grid[0])
  three_obj = extract(objects(grid, False, False, True), lambda obj: color(obj) == 3)
  return paint(canvas(0, (h, w)), shift(three_obj, (h // 2 - uppermost(three_obj) - height(three_obj) // 2, w // 2 - leftmost(three_obj) - width(three_obj) // 2)))
 
1.1428571428571428, tensor(0.0089), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def iaeffibfdbiaeeaeifaegcjjcabgddjf(grid):
  objs = objects(grid, False, False, True)
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  centered_three = shift(three_obj, (len(grid) // 2 - centerofmass(three_obj)[0], len(grid[0]) // 2 - centerofmass(three_obj)[1]))
  return paint(cover(grid, three_obj), centered_three)
 
7.0, tensor(1.7737), Description: If there is a blue square in the middle row, place a blue square in the middle row of the output grid. Otherwise, keep the original grid. 
:: def dfeegeedbfgfecheabcjddhchdjfjedc(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
    tuple(
      3 if (i == h // 2 and any(3 in row for row in grid)) else v
      for j, v in enumerate(r)
    )
    for i, r in enumerate(grid)
  ) 
 
3.0, tensor(1.8024), Description: Swap the colors of the blue and red squares. Keep the original colors of all other squares. 
:: def dhbfcfbbadaieahdaghffbhbeggeeefa(I):
  threes = ofcolor(I, THREE)
  fours = ofcolor(I, FOUR)
  O = fill(fill(I, ZERO, threes), ZERO, fours)
  O = fill(O, THREE, fours)
  O = fill(O, FOUR, threes)
  return O 
 
3.5714285714285716, tensor(0.0077), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from top to bottom based on their uppermost row. 
:: def fahefiffbgieedccbedbhccfejgfcfch(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: uppermost(obj))
  O = canvas(0, shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(normalize(obj), (i, len(I[0]) // 2 - width(obj) // 2)))
  return O
 
3.4285714285714284, tensor(0.0076), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. The shapes should be ordered from top to bottom based on their row number. 
:: def jacedccdhbfjeggdigeabbgicidddaee(I):
  O = canvas(0, shape(I))
  for i, j in sorted(((i, j) for i in range(len(I)) for j in range(len(I[0])) if I[i][j]), key=lambda x: x[0]):
    O = paint(O, {(I[i][j], (i, len(O[0])//2 - (j < len(I[0])//2)))})
  return O
 
2.857142857142857, tensor(0.0206), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from top to bottom based on their uppermost row. If a shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def fdbeececgbbfejcebcjebefedbjacfaf(I):
  O = tuple(
    tuple(
      next(
        (
          v 
          for obj in sorted(objects(I, False, False, True), key=lambda obj: uppermost(obj)) 
          for v, (i2, j2) in obj 
          if i2 == i and j2 == len(I[0]) // 2 - (sum(1 for _, (x, _) in obj if x == i2) < 2)
        ),
        0
      )
      for j in range(len(I[0]))
    )
    for i in range(len(I))
  )
  return O
 
2.0, tensor(0.0212), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from top to bottom based on their leftmost column. If a shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def cjabcecfebddeibdiddgecbfgcfddeeb(I):
  return tuple(
    tuple(
      next(
        (
          v
          for obj in sorted(objects(I, False, False, True), key=lambda obj: min(j for _, (i, j) in obj))
          for v, (i2, _) in obj
          if i2 == i and abs(centerofmass(obj)[1] - j) <= width(obj) // 2
        ), 
        0
      )
      for j in range(len(I[0]))
    )
    for i in range(len(I))
  ) 
 
2.4285714285714284, tensor(0.0136), Description: Move the 3x3 blue shape and the 3x3 red shape to the center of the grid. Keep the original colors. 
:: def eicdhgieeceaeeafieeibhcbfaiiecdb(I):
  three = first(colorfilter(objects(I, T, F, F), 3))
  four = first(colorfilter(objects(I, T, F, F), 4))
  offset = subtract(centerofmass(I), (centerofmass(three)[0] + 1, centerofmass(three)[1]))
  return paint(paint(canvas(0, shape(I)), shift(three, offset)), shift(four, offset))
 
2.142857142857143, tensor(0.2138), Description: Create a grid with a blue square in the center, one row above the bottom row. Place a red square in the bottom right corner of the grid. Keep the original colors. 
:: def fdheecdfbgbaedfiiajehghcdfhiahac(I):
  h, w = shape(I)
  target = (h // 2, w // 2 - (w % 2 == 0))
  top = canvas(0, (target[0], w))
  bottom = canvas(0, (h - target[0] - 1, w))
  middle = hconcat(hconcat(canvas(0, (1, target[1])), canvas(3, (1, 1))), canvas(0, (1, w - target[1] - 1)))
  return vconcat(vconcat(top, middle), bottom)
 
1.0, tensor(0.0153), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def dacjbbdcccgdejdbijdideadafebbffe(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  offset = (0, width(I) // 2 - center(toindices(three))[1])
  return paint(paint(canvas(0, shape(I)),shift(three, offset)),difference(asobject(I),three))
 
3.142857142857143, tensor(0.0081), Description: Move the 3x3 blue shape to the center of the grid. Move the 3x3 red shape to the center of the grid, but one row below the blue shape. Keep the original colors. 
:: def dijcgeafbdhfebeejaffdgbfgigbbbfd(grid):
  objs = objects(grid, False, False, True)
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  h, w = len(grid), len(grid[0])
  center_col = w // 2
  three_offset = (h // 2 - centerofmass(three_obj)[0], center_col - centerofmass(three_obj)[1])
  four_offset = (h // 2 + 1 - centerofmass(four_obj)[0], center_col - centerofmass(four_obj)[1])
  return paint(paint(canvas(0, shape(grid)), shift(three_obj, three_offset)), shift(four_obj, four_offset))
 
3.142857142857143, tensor(0.0081), Description: Description: Move the 3x3 blue shape to the center of the grid. Move the 3x3 red shape to the bottom row, middle column of the grid. Keep the original colors. 
:: def abdbeebjhhejeijcjeeijaaacbciahef(grid):
  objs = objects(grid, False, False, True)
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  return paint(paint(canvas(0, shape(grid)), shift(three_obj, (len(grid) // 2 - centerofmass(three_obj)[0], len(grid[0]) // 2 - leftmost(three_obj) - width(three_obj) // 2))), shift(four_obj, (len(grid) - uppermost(four_obj) - height(four_obj), len(grid[0]) // 2 - leftmost(four_obj) - width(four_obj) // 2)))
 
3.7142857142857144, tensor(0.0093), Description: Description: Move the 3x3 blue shape to the second to last row, middle column of the grid. Move the 3x3 red shape to the bottom row, middle column of the grid. Keep the original colors. 
:: def dabfbhgbaiaiebfcjfbcjgadcefcfdja(grid):
  h, w = len(grid), len(grid[0])
  obj3 = recolor(3, extract(objects(grid, False, False, True), lambda obj: color(obj) == 3))
  obj4 = recolor(4, extract(objects(grid, False, False, True), lambda obj: color(obj) == 4))
  grid = paint(canvas(0, (h, w)), shift(obj3, (h // 2 - uppermost(obj3) - 1, w // 2 - leftmost(obj3) - width(obj3) // 2)))
  return paint(grid, shift(obj4, (h - uppermost(obj4) - height(obj4), w // 2 - leftmost(obj4) - width(obj4) // 2)))
 
2.857142857142857, tensor(0.0089), Description: Move the 3x3 blue shape to the second column of the grid. Move the 3x3 red shape to the third column of the grid. Keep the original colors. 
:: def agbcjdadfidieaafjbaahdfjaefccfad(I):
  objs = objects(I, False, False, True)  # Extract objects from input grid
  three = first(colorfilter(objs, THREE))  # Get the object with value '3'
  four = first(colorfilter(objs, FOUR))  # Get the object with value '4'
  O = canvas(0, shape(I))  # Create an empty canvas with the input's shape
  O = paint(O, shift(three, (0, 1)))  # Place '3' in the second column
  O = paint(O, shift(four, (0, 2)))  # Place '4' in the third column
  return O
 
2.7142857142857144, tensor(0.0089), Description: Move the 3x3 blue shape to the second column of the grid. Move the 3x3 red shape to the third column of the grid. Keep the original colors. 
:: def hahebffjcabbedbeiefifdjaabddhdif(I):
  threes = ofcolor(I, THREE)  # Get indices of '3'
  fours = ofcolor(I, FOUR)  # Get indices of '4'
  O = canvas(0, shape(I))  # Create an empty canvas
  for i, j in threes:
    O = paint(O, {(THREE, (i, 1))})  # Paint '3' in the second column 
  for i, j in fours:
    O = paint(O, {(FOUR, (i, 2))})  # Paint '4' in the third column
  return O
 
3.0, tensor(0.0088), Description: Move the 3x3 blue shape to the second column of the grid. Move the 3x3 red shape to the second column of the grid. Keep the original colors. 
:: def feecabbbbfdaedgjiabbfdefebbbdbcd(I):
  three_obj = toobject(ofcolor(I, THREE), I)  # Get the '3' object
  four_obj = toobject(ofcolor(I, FOUR), I)  # Get the '4' object
  O = canvas(0, shape(I))  # Create an empty canvas
  O = paint(O, shift(three_obj, subtract((0, 2), centerofmass(three_obj)))) # Position '3'
  O = paint(O, shift(four_obj, subtract((0, 2), centerofmass(four_obj)))) # Position '4'
  return O
 
48.857142857142854, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ebedeafhbbhaeecebfaabbcibabbahfg(I):
  return tuple(
    tuple(
      v
      if (i, j) in shift(normalize(toobject(obj, I)), (i, len(I[0]) // 2 - width(obj) // 2))
      else 0
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
    for obj in objects(I, F, F, T) 
  )
 
50.0, tensor(0.0066), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dghfjbjdcdcdeaafjdgaagfdhadbadfa(I):
  return tuple(
    tuple(
      next((v for v, (a, b) in shift(toobject(obj, I), (0, len(row) // 2 - centerofmass(toobject(obj, I))[1])) if a == i and b == j), 0) 
      for j in range(len(row))
    )
    for i, row in enumerate(I)
    for obj in objects(I, F, F, T)
  )
 
49.285714285714285, tensor(0.0049), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def iahaefedgegceceaicbecdieicjfiaij(I):
  return tuple(
    tuple(
      index(I, (i, c + len(I[0]) // 2 - width(toobject(obj, I)) // 2))
      if (i, c) in toindices(obj) 
      else 0
      for c in range(len(row))
    )
    for i, row in enumerate(I)
    for obj in objects(I, F, F, T)
  )
 
3.4285714285714284, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def hbfaehddfddcebdcaegabajfhdcfjjci(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (subtract((height(I) // 2) - (height(obj) // 2), uppermost(obj)), 0)) for obj in objects(I, False, False, True)}))
 
2.7142857142857144, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bhehfeffajadejeibgdbdebcgdfjcagf(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), 0)) for obj in partition(I) if len(obj) > 0}))
 
3.4285714285714284, tensor(0.0061), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def idbdhcdbcigfeafbacbcfaacgeibibeg(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, (width(I) // 2) - (leftmost(obj) + width(obj) // 2))) for obj in objects(I, False, False, True)})) 
 
2.0, tensor(0.0126), Description: Move the 3x3 blue shape to the vertical center of the grid. Keep the original colors. 
:: def hbffceebbibbeifhabbghjdbccgaehdb(I):
  # Find the '3' object
  three = first(colorfilter(objects(I, False, False, True), 3))
  
  # Calculate the target position (vertical center)
  target_row = height(I) // 2 
  current_row = ulcorner(three)[0]
  offset = (target_row - current_row, 0)  
  
  # Move the '3' object
  return paint(cover(I, three), shift(three, offset)) 
 
2.857142857142857, tensor(0.0126), Description: Move the 3x3 blue shape to the vertical center of the grid. Keep the original colors. 
:: def afecebfecacgebbcjifdddiebchbadhh(I):
  # Find the '3' object's indices
  three_indices = ofcolor(I, 3)

  # Calculate vertical center and offset
  center_row = height(I) // 2
  offset = (center_row - uppermost(three_indices), 0)

  # Move '3' by modifying its indices and filling the grid
  return fill(I, 3, shift(three_indices, offset))
 
2.2857142857142856, tensor(0.0127), Description: Move the 3x3 blue shape to the middle row of the grid. Keep the original colors. 
:: def ibefdefeaceeeeaijbihdfabjgiccdce(I):
  # Directly modify the grid rows
  rows = list(I)
  three_row = next(i for i, r in enumerate(rows) if 3 in r) 
  rows[three_row], rows[height(I) // 2] = rows[height(I) // 2], rows[three_row]
  return tuple(rows)
 
2.4285714285714284, tensor(0.0054), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def ejcebdcggdajeadfbbgaedebdjecbdgh(I):
    three = first(colorfilter(objects(I, False, False, True), 3))
    offset = (0, width(I) // 2 - center(toindices(three))[1])
    return paint(I, shift(three, offset)) 
 
1.4285714285714286, tensor(0.0054), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def fbbdhccaagdeedigjcajfgfbcedfejbj(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  new_grid = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 3:
      offset = (0, width(I) // 2 - center(toindices(obj))[1])
      new_grid = paint(new_grid, shift(obj, offset))
    else:
      new_grid = paint(new_grid, obj)
  return new_grid
 
3.4285714285714284, tensor(0.0056), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ehadfibeffcfeeaaibbfjafcebafdacb(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, width(I) // 2 - center(obj)[1])) for obj in objects(I, False, False, True)}))
 
3.0, tensor(0.0056), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def iffbcehiggbaeciajjacajbfbjjcbeed(I):
  objs = objects(I, False, False, True)
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, (width(I) - width(extract(objs, lambda obj: True))) // 2 - leftmost(extract(objs, lambda obj: True)))) for obj in objs}))
 
3.0, tensor(0.0056), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def dfdfcecegcbeedgeiefabcbgehecgidh(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, subtract((width(I) // 2, 0), center(obj))) for obj in objects(I, False, False, True)}))
 
2.5714285714285716, tensor(0.0051), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ecaejhbcffffefagibifjcbjibfgfgfb(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, (width(I) - width(obj)) // 2 - leftmost(obj))) for obj in partition(I) if len(obj) > 0}))
 
37.142857142857146, tensor(0.0051), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ihifiaaehhdbecccibcefahdhiddfhfa(I):
  objs = objects(I, False, False, True)
  return tuple(tuple(next((I[i][k] for _, (i, k) in obj if k == j), 0) for j in range(len(I[0]))) for obj in objs)
 
2.0, tensor(0.0086), Description: If there is at least one colored square in a row, move all the colored squares in that row to the middle of the row. Otherwise, keep the row as it is. 
:: def fejdccgefeabeahdideedgbdfffdibec(I):
  return tuple(tuple(I[i][j] if any(I[i][k] != 0 for k in range(len(I[0]))) else 0 for j in range(len(I[0]))) for i in range(len(I)))
 
3.142857142857143, tensor(0.0042), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def efdidhifabdaejgfagfgfbdefijajcdj(I):
  objs = objects(I, False, False, True)
  centered_objs = {shift(obj, ((height(I) - height(obj)) // 2, 0)) for obj in objs}
  return paint(canvas(0, shape(I)), merge(centered_objs))
 
2.0, tensor(0.0084), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def ieidbaaeeageeebajjeebcachfbjjcdc(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  offset = (0, width(I) // 2 - center(toindices(three))[1])
  return paint(paint(canvas(0, shape(I)), shift(three, offset)), asobject(I))
 
2.4285714285714284, tensor(0.0105), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def cjbbecjdjdcfeaabadbggfbiaieeceff(I):
  three_indices = ofcolor(I, 3)
  center_col = width(I) // 2
  offset = (0, center_col - centerofmass(three_indices)[1])
  return fill(I, 3, shift(three_indices, offset))
 
1.4285714285714286, tensor(0.0084), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def bafiaecdfcgfefdaaghhefjhigeiagje(I):
  for obj in objects(I, False, False, True):
    if color(obj) == 3:
      offset = (0, width(I) // 2 - center(toindices(obj))[1])
      I = paint(cover(I, obj), shift(obj, offset))
  return I
 
2.857142857142857, tensor(0.0079), Description: Move the 3x3 blue shape to the middle of the grid vertically. Keep the original colors. 
:: def ebjdfgfghhhaebffbheadfaegifecdeb(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  center_index = center(toindices(three))
  offset = (height(I) // 2 - center_index[0], 0) 
  return paint(I, shift(three, offset))
 
3.2857142857142856, tensor(0.0056), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def efhegfjafjbdebfijahdbachcbfadccc(I):
  objs = objects(I, False, False, True)
  centered_objs = []
  for obj in objs:
    offset = (width(I) - width(obj)) // 2 - leftmost(obj)
    centered_objs.append(shift(obj, (0, offset)))
  return paint(canvas(0, shape(I)), merge(centered_objs))
 
3.4285714285714284, tensor(0.0146), Description: Move each colored shape to the center of the grid vertically and horizontally. Keep the original colors. The shapes should be aligned to the left edge of the grid. If a shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def ejdbabeibcdheidebgfcddebbaccegbc(I):
  objs = objects(I, False, False, True)
  max_height = max(height(obj) for obj in objs)
  return paint(canvas(0, shape(I)), merge({shift(obj, ((max_height - height(obj)) // 2, (width(I) - width(obj)) // 2 - leftmost(obj))) for obj in objs}))
 
3.0, tensor(0.0079), Description: Move the 3x3 blue shape to the middle of the grid vertically. Keep the original colors. 
:: def eafggiebfiheeejgajhaeijgfjbbaeda(I):
  objs = objects(I, False, False, True)
  three = first(colorfilter(objs, 3))
  offset = (height(I) // 2 - center(toindices(three))[0], 0)
  return paint(canvas(0, shape(I)), shift(three, offset))
 
3.0, tensor(0.0371), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. If the shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def aedacbdeagbfegbajahgbgcecggdcbbd(I):
  return tuple(tuple(v for j, v in enumerate(row) if j != (width(I) - 1) // 2) + tuple(v for k, v in enumerate(row) if k == (width(I) - 1) // 2) for row in I)
 
3.142857142857143, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def gihafiahbhjcecfabafadeacbjbcjfja(I):
  objs = objects(I, False, False, True)  # Extract objects
  h = height(I)  # Get grid height
  return paint(canvas(0, shape(I)), merge({shift(obj, ((h - height(obj)) // 2, 0)) for obj in objs}))  # Center vertically and paint
 
3.2857142857142856, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def aacbcdgbdcjcefcgidaiiehfbfgaaahe(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, subtract((height(I) // 2, 0), (height(obj) // 2, 0))) for obj in objects(I, False, False, True)}))
 
3.0, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bdffiacfggieedefiifabdegfffebdbi(I):
    objs = partition(I) # Extract all objects, including background
    centered_objs = {shift(obj, subtract((height(I) // 2, 0), (height(obj) // 2, 0))) for obj in objs if len(obj)>0}  # Center each non-empty object
    return paint(canvas(0, shape(I)), merge(centered_objs))  # Paint centered objects onto a blank canvas
 
2.4285714285714284, tensor(0.0073), Description: Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors. 
:: def jajfbegdbahaeafaifgbeccfgfhecejj(I):
  obj3 = first(colorfilter(objects(I, False, False, True), 3))
  return paint(canvas(0, shape(I)), shift(obj3, (0, width(I) // 2 - centerofmass(obj3)[1])))
 
3.857142857142857, tensor(0.0056), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def beafedafbgacebefijdafhjddibjgaee(I):
  return paint(canvas(0, shape(I)),  
               frozenset({(index(I, (i,j)), (i, width(I) // 2 - (j - width(I) // 2))) 
               for i in range(height(I)) for j in range(width(I)) if index(I, (i,j)) != 0}))
 
2.2857142857142856, tensor(0.0079), Description: Move the leftmost colored shape to the horizontal center of the grid. Keep the original colors of all other squares. 
:: def bbgfcaieieaeeheeaifebieicedabgda(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: leftmost(obj))
  if len(objs) > 0:
    leftmost_obj = objs[0]
    centered_obj = shift(leftmost_obj, (0, (width(I) - width(leftmost_obj)) // 2 - leftmost(leftmost_obj)))
    remaining_objs = merge(objs[1:])
    return paint(paint(canvas(0, shape(I)), centered_obj), remaining_objs)
  return I
 
2.857142857142857, tensor(0.0068), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from left to right based on their leftmost column. 
:: def jddbebceibebegdebfahaachhjddgjgc(I):
  objs = [(obj, leftmost(obj)) for obj in objects(I, False, False, True)]
  objs.sort(key=lambda x: x[1])
  offset = (width(I) - width(objs[0][0])) // 2 - objs[0][1]
  return paint(canvas(0, shape(I)), merge({shift(obj, (0, offset)) for obj, _ in objs}))
 
1.7142857142857142, tensor(0.0087), Description: Move the 3x3 blue shape to the horizontal center of the grid. Keep the original colors of all other squares. 
:: def ijbfjbceehfbefadadfeaacdcehcfehd(I):
  for i, row in enumerate(I): # Iterate over each row
    if 3 in row: # Check if '3' is present in the row
      three_j = row.index(3) # Get the column index of '3'
      target_j = width(I) // 2  # Calculate the target column index (center)
      new_row = [0] * len(row) # Create a new row filled with zeros
      new_row[target_j] = 3 # Place '3' at the target column
      I = tuple(tuple(r) for r in (I[:i] + (tuple(new_row),) + I[i+1:]))  # Update the grid with the modified row
      break
  return I
 
2.142857142857143, tensor(0.0118), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def bfgahbcdedbfefdfbcegaeeggfcdhdjd(I):
  three_obj = first(colorfilter(objects(I, False, False, True), 3)) # Find the '3' object
  target_col = width(I) // 2 # Calculate target column index (center)
  return paint(
      canvas(0, shape(I)), # Create a blank canvas
      shift(three_obj, (height(I) // 2 - centerofmass(three_obj)[0], target_col - centerofmass(three_obj)[1])) # Shift '3' to center
  )
 
3.2857142857142856, tensor(0.0082), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from top to bottom based on their vertical center. 
:: def abefhaddfeaeejfijcefbeebbbhdgcdf(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: center(obj)[0])
  h, w = shape(I)
  output = canvas(0, (h, w))
  for j, obj in enumerate(objs):
    output = paint(output, shift(obj, (0, w // 2 - center(obj)[1])))
  return output
 
2.0, tensor(0.0056), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def bhdecjbhchgcehdbiehjdigifbafeeaf(I):
    h, w = shape(I)
    return tuple(tuple(v if (i,j) in {(i, w // 2) for i in range(h)} else 0 for j, v in enumerate(row)) for i, row in enumerate(I))
 
2.0, tensor(0.0029), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def bifadgccbceeeddbacccieihhebajeeb(I):
  objs = partition(I) - {frozenset({(0, (i, j)) for i in range(height(I)) for j in range(width(I))})}
  mid = width(I) // 2
  return tuple(tuple(next((color(obj) for obj in objs if (row, col) in toindices(obj)), 0) if col == mid else 0 for col in range(width(I))) for row in range(height(I)))
 
3.2857142857142856, tensor(0.0029), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def ecadicafafadebcbjfeccacbfgiaebja(I):
  O = canvas(0, shape(I))
  for obj in objects(I, False, False, True):
    O = paint(O, shift(obj, (0, (width(I) // 2) - (leftmost(obj) + width(obj) // 2))))
  return O
 
3.5714285714285716, tensor(0.0188), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from left to right based on their leftmost column. If a shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def egbaecedbdebecaaacjafaiafbciacce(I):
  objs = objects(I, False, False, True)
  shifted_objs = []
  current_x = (width(I) - sum(width(obj) for obj in objs)) // 2
  for obj in objs:
    shifted_objs.append(shift(obj, (0, current_x)))
    current_x += width(obj)
  return paint(canvas(0, shape(I)), merge(shifted_objs))
 
2.4285714285714284, tensor(0.0084), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def hfgdbehccieeecdcjcbgbgfdbbfjbaei(I):
  obj_3 = extract(objects(I, False, False, True), lambda obj: color(obj) == 3)
  return paint(canvas(0, shape(I)), shift(obj_3, (0, width(I) // 2 - center(toindices(obj_3))[1])))
 
3.2857142857142856, tensor(0.0085), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def gcefegfabacdejddjcheghccachfadag(I):
  objs = objects(I, False, False, True)
  out = I
  for obj in objs:
    col = centerofmass(obj)[1]
    offset = (0,  width(I) // 2 - col)
    out = paint(cover(out, obj), shift(obj, offset))
  return out
 
2.0, tensor(1.9822), Description: For each row in the input grid, if the row contains the most common color, keep the row as is. Otherwise, replace all the elements in the row with the element in the middle of the row. 
:: def dffjacgacacbeahcihdcdjibdebiegci(I):
  w = width(I)
  return tuple(
    tuple(
      I[i][j] if I[i][j] == mostcolor(I) 
      else I[i][w // 2] 
      for j in range(w)
    )
    for i in range(height(I))
  )
 
19.428571428571427, tensor(0.0147), Description: Copy the left half of the grid to the output. Then, mirror the left half and copy it to the right half of the output. If the grid width is odd, trim the rightmost column of the right half before mirroring. 
:: def aedaieeefadbeadciaffacgdjbbfebje(I):
  left, right = hsplit(I, 2)
  return hconcat(left, hmirror(left)) if width(I) % 2 == 0 else hconcat(left, hmirror(trim(right)))
 
3.4285714285714284, tensor(0.0087), Description: Copy the input grid. Then, for each color in the input grid, move all the squares of that color to the horizontal center of the grid. Keep the original colors. 
:: def eccageahfaieefbebeefabhabagfbahh(I):
  bg = mostcolor(I)
  out = canvas(bg, shape(I))
  for c in palette(I) - {bg}:
    indices = ofcolor(I, c)
    center_col = centerofmass(indices)[1]
    offset = (0, width(I) // 2 - center_col)
    out = fill(out, c, shift(indices, offset))
  return out
 
3.4285714285714284, tensor(0.0581), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. If a shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def icbajajdecibejcjajciehbhjdeabcdf(I):
  objs = objects(I, False, False, True)
  centered_objs = []
  h, w = shape(I)
  for obj in objs:
    offset = (h - height(obj)) // 2 - uppermost(obj) 
    centered_objs.append(shift(obj, (offset, 0)))
  return paint(canvas(0, (h, w)), merge(centered_objs))
 
3.4285714285714284, tensor(0.0082), Description: Move each colored shape to the middle of the grid vertically, keeping the original colors. The shapes should be ordered from top to bottom based on their vertical center. 
:: def jchfdhcbbfacedcajhebfedfbdciebda(I):
  objs = objects(I, False, False, True)
  h, w = shape(I)
  output = canvas(0, (h, w))
  for obj in objs:
    output = paint(output, shift(obj, ((h // 2) - centerofmass(obj)[0], 0)))
  return output
 
2.2857142857142856, tensor(0.0079), Description: Move the leftmost colored shape to the horizontal center of the grid. Keep the original colors of all other squares. 
:: def dfhgfgebcffceccabfhcjfajffiichcd(I):
  leftmost_col = min(j for i, row in enumerate(I) for j, v in enumerate(row) if v != 0)
  leftmost_obj = next((obj for obj in objects(I, False, False, True) if leftmost(obj) == leftmost_col), None)
  if leftmost_obj:
    center_col = width(I) // 2
    offset = center_col - centerofmass(leftmost_obj)[1]
    return paint(cover(I, leftmost_obj), shift(leftmost_obj, (0, offset)))
  return I
 
1.7142857142857142, tensor(0.0079), Description: Move the leftmost colored shape to the horizontal center of the grid. Keep the original colors of all other squares. 
:: def aeiebcfdgeaeecifibaaceefbdcaeghg(I):
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        obj = next((o for o in objects(I, False, False, True) if (i, j) in toindices(o)), None)
        offset = (width(I) - width(obj)) // 2 - leftmost(obj)
        return paint(cover(I, obj), shift(obj, (0, offset)))
  return I
 
2.7142857142857144, tensor(0.0172), Description: Move each colored shape to the middle of the grid horizontally, keeping the original colors. The shapes should be ordered from left to right based on their horizontal center. If a shape is wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def febhhdbidadfecffbggcecijgfdffchd(I):
    objs = sorted(objects(I, False, False, True), key=lambda obj: centerofmass(obj)[1])
    total_width = sum(width(obj) for obj in objs)
    offset = (width(I) - total_width) // 2
    return paint(canvas(0, shape(I)), merge(frozenset(shift(obj, (0, offset + sum(width(o) for o in objs[:i]))) for i, obj in enumerate(objs))))
 
1.1428571428571428, tensor(0.0077), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def dbecaeedbhhbehjdbfcibdfcjdfhffba(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  center_i, center_j = center(toindices(three))
  target_i, target_j = height(I) // 2, width(I) // 2
  offset = (target_i - center_i, target_j - center_j)
  return paint(cover(I, three), shift(three, offset)) 
 
3.4285714285714284, tensor(0.0210), Description: Move each colored shape to the middle of the grid vertically, keeping the original colors. The shapes should be ordered from top to bottom based on their uppermost row. If a shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def efeacibcdgadeccgifjfhhgdcjhbdhaf(I):
  h, w = shape(I)
  output = canvas(0, (h, w))
  for j in range(w):
    column = frozenset((I[i][j], (i, j)) for i in range(h) if I[i][j] != 0)
    if len(column) > 0:
        offset = (h - height(column)) // 2 - uppermost(column)
        output = paint(output, shift(column, (offset, 0)))
  return output
 
5.428571428571429, tensor(0.0455), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. If the shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def fijabfaeciaaecbaiefdfjffieejeiee(I):
  return tuple(tuple(v for k, v in enumerate(column) if k == (len(column) - 1) // 2) + tuple(v for j, v in enumerate(column) if j != (len(column) - 1) // 2)  for column in zip(*I)) 
 
2.5714285714285716, tensor(0.0479), Description: Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. If the shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def ibhadcaciccbehacjiacabejjhijdaed(I):
  return tuple(zip(*(tuple(v for k, v in enumerate(column) if k == (len(column) - 1) // 2) + tuple(v for j, v in enumerate(column) if j != (len(column) - 1) // 2)  for column in zip(*I)))) 
 
5.0, tensor(0.0417), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. If the shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def hbdddcadeibgeafejbfaedfacbafgbga(I):
    h, w = shape(I)
    return tuple(tuple(0 if i != (h - 1) // 2 else row[j] for i in range(h)) for j, row in enumerate(zip(*I)))
 
3.4285714285714284, tensor(0.0031), Description: Move each colored shape to the middle of the grid vertically. Keep the original colors. 
:: def gfibdbeghcdeecgebjceicfggdbcggfc(I):
  O = canvas(0, shape(I))
  for obj in objects(I, False, False, True):
    O = paint(O, shift(obj, ((height(I) // 2) - (uppermost(obj) + height(obj) // 2), 0)))
  return O
 
2.5714285714285716, tensor(0.0061), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def fcdghgefaaeaebjbihbiagaecdjdcebc(I):
  return paint(canvas(0, shape(I)), merge(frozenset(shift(obj, (0, (width(I) - width(obj)) // 2 - leftmost(obj))) for obj in partition(I))))
 
2.142857142857143, tensor(0.0077), Description: Move the 3x3 blue shape to the center of the grid. Keep the original colors. 
:: def dadeahfaeedheefeacfafbaicccfbcge(I):
  three = first(colorfilter(objects(I, False, False, True), 3))
  center_index = (height(I) // 2, width(I) // 2)
  offset = subtract(center_index, centerofmass(three))
  return paint(I, shift(three, offset))
 
2.4285714285714284, tensor(0.0109), Description: Move the 3x3 blue shape so that its center is the same relative distance from the 3x3 red shape as it was in the input grid. Keep the original colors. 
:: def caaebdgffbegehifbjdgfcfaebgjfige(I):
  objs = objects(I, False, False, True)
  three = first(colorfilter(objs, 3))
  four = first(colorfilter(objs, 4))
  rel_pos = position(three, four)
  center_index = (height(I) // 2, width(I) // 2)
  target_pos = add(centerofmass(four), rel_pos)
  offset = subtract(target_pos, centerofmass(three))
  return paint(I, shift(three, offset)) 
 
2.5714285714285716, tensor(0.0146), Description: Move each colored shape to the center of the grid vertically and horizontally. Keep the original colors. The shapes should be aligned to the left edge of the grid. If a shape is taller than the grid, then only the part of the shape that fits in the grid is shown. 
:: def jejdbbhaabafefbjiaeiibgdfjbfbdhd(I):
  return paint(canvas(0, shape(I)), merge({shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), (width(I) - width(obj)) // 2 - leftmost(obj))) for obj in objects(I, False, False, True)}))
 
3.2857142857142856, tensor(0.0061), Description: Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def dfcgfjeiiefceacabdeefgcdefadcffg(I):
  objs = objects(I, False, False, True)
  centered_objs = []
  for obj in objs:
    offset = (width(I) - width(obj)) // 2 - leftmost(obj)
    centered_objs.append(shift(obj, (0, offset)))
  return paint(canvas(0, shape(I)), merge(centered_objs))
 
1.4285714285714286, tensor(0.0084), Description: Move the 3x3 blue shape to the middle of the grid horizontally. Keep the original colors of all other squares. 
:: def iifhdgjdjbcaeebdaffcbbfheijghgfi(I):
  three_obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 3)  # Extract the '3' object
  obj_width = width(three_obj)  # Calculate the width of the '3' object
  offset = (0, (width(I) - obj_width) // 2 - leftmost(three_obj))  # Calculate the offset for centering
  return paint(cover(I, three_obj), shift(three_obj, offset))  # Center the '3' object
 
3.4285714285714284, tensor(0.0029), Description: Move each colored shape to the middle of the grid horizontally. Keep the original colors. 
:: def cfeedagcdjbbechbaiedcddgbijbbbgb(I):
  return paint(
    canvas(0, shape(I)),
    mapply(
      lambda obj: shift(obj, (0, (width(I) // 2) - (leftmost(obj) + width(obj) // 2))),
      objects(I, False, False, True)
    )
  )
 
3.142857142857143, tensor(1.7490), Description: If there is a blue square in the row above the current row, place a blue square in the current row. If there is a red square in the bottom row, place a red square in the bottom row of the output grid. Otherwise, keep the original grid. 
:: def fahjedecdjaaeagbbdfbabechahgdcbc(I):
  h = len(I)
  return tuple(
    tuple(
      3 if (i-1) in range(h) and I[i-1][j] == 3 else (
      4 if i == h-1 and any(row[j] == 4 for row in I) else 0) 
      for j in range(len(I[0])))
    for i in range(h))
 
2.4285714285714284, tensor(1.5632), Description: Swap the colors of the blue and red squares. Keep the original colors of all other squares. 
:: def bcafbjehefejeeecbdbafjifbcbbfieb(I):
  indices3 = ofcolor(I, THREE)
  indices4 = ofcolor(I, FOUR)
  O = fill(fill(I,ZERO,indices3),THREE,indices4)
  return O
 
2.0, tensor(1.9084), Description: Replace all the black squares with blue squares and all the red squares with green squares. Keep the original colors of all other squares. 
:: def jbcdafabjcjdeifcbdfdeijdcaefcbje(I):
  grid3 = cellwise(I, canvas(THREE, shape(I)), ZERO)
  grid4 = cellwise(I, canvas(FOUR, shape(I)), ZERO)
  O = cellwise(grid3, grid4, ZERO)
  return O
 
3.142857142857143, tensor(1.7263), Description: Swap the colors of the blue and red squares. Swap the colors of the light blue and yellow squares. Keep the original colors of all other squares. 
:: def ifciiifefjcceihgaaahdjccjcahcgej(I):
    O = replace(replace(I, THREE, FIVE), FOUR, THREE)
    O = replace(O, FIVE, FOUR)
    return O
 
2.857142857142857, tensor(1.9813), Description: Copy the input grid. Then, move the smallest colored shape to the top left corner of the grid. Move the largest colored shape to the bottom right corner of the grid. Keep the original colors. 
:: def iefbaiaijffdeeffbbjabeghgeccefca(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    objs_sorted = order(objs, color)
    obj1, obj2 = first(objs_sorted), last(objs_sorted)
    h, w = shape(I)
    O = canvas(bg, (h, w))
    O = paint(O, shift(obj1, (h//2 -1, w//2 -1)))
    O = paint(O, shift(obj2, (h - 1, w - 1)))
    return O
 
2.857142857142857, tensor(1.9813), Description: Copy the input grid. Then, move the smallest colored shape to the second row, second column of the grid. Move the largest colored shape to the bottom right corner of the grid. Keep the original colors. 
:: def eccgafhegfddeeedbadcbgddebjcdbba(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    h, w = len(I), len(I[0])
    obj1 = extract(objs, lambda obj: color(obj) == min(palette(I)-{bg}))
    obj2 = extract(objs, lambda obj: color(obj) == max(palette(I)))
    O = canvas(bg, (h, w))
    O = paint(O, shift(obj1, (h//2 - 1, 1)))
    O = paint(O, shift(obj2, (h - 1, w - 1)))
    return O
 
3.4285714285714284, tensor(1.9708), Description: Place a blue square in the bottom row of the output grid, in the same column as the blue square in the input grid. Place a red square in the second to last row of the output grid, in the same column as the red square in the input grid. Keep the original colors. 
:: def fgfccfjcbhhdeefhagjdfgdiabjaedbd(I):
  h = height(I)
  O = canvas(ZERO, shape(I))
  for j, col in enumerate(dmirror(I)):
    if THREE in col:
      O = paint(O, {(THREE, (h - 1, j))})
    if FOUR in col:
      O = paint(O, {(FOUR, (h - 2, j))})
  return O
 
2.857142857142857, tensor(0.0271), Description: Swap the positions of the blue and red squares diagonally. Keep the original colors. 
:: def cbhffcaiidedeadcjgigedccfffhddcg(I):
  threes = frozenset((i + 1, len(I[0]) - j - 1) for i, row in enumerate(I) for j, v in enumerate(row) if v == 3)
  fours = frozenset((i, len(I[0]) - j - 1) for i, row in enumerate(I) for j, v in enumerate(row) if v == 4)
  return paint(paint(canvas(0, shape(I)), recolor(3, threes)), recolor(4, fours))
 
3.0, tensor(1.9818), Description: Copy the input grid. Then, move each colored shape to the center of the grid vertically and horizontally. Keep the original colors. The shapes should be ordered from top to bottom and left to right based on their top-left corner. If a shape is taller or wider than the grid, then only the part of the shape that fits in the grid is shown. 
:: def dhcfdabacfcjebjgadchdcjeehgifeib(I):
  x1 = objects(I, T, F, T) # Extract objects
  x2 = sorted(x1, key=lambda obj: (uppermost(obj), leftmost(obj))) # Sort by top-left corner
  x3 = mostcolor(I) # Get background color
  h, w = len(I), len(I[0]) # Input grid dimensions
  O = canvas(x3, (h, w)) # Create output canvas
  for i, obj in enumerate(x2):
    obj_h, obj_w = shape(obj) # Object dimensions
    offset = ((h - obj_h) // 2, (w - obj_w) // 2) # Calculate offset for centering
    O = paint(O, shift(obj, offset)) # Paint the object onto the output canvas
  return O
 
2.857142857142857, tensor(0.0216), Description: Move the 3x3 blue shape down one row. Flip the 3x3 red shape horizontally and vertically. Keep the original colors. 
:: def jghfcecbfafjebaciecgdihfcbchcifd(I):
  threes = ofcolor(I, 3)  # Identify '3' locations
  fours = ofcolor(I, 4)  # Identify '4' locations
  return paint(
      paint(canvas(0, shape(I)), recolor(3, shift(threes, DOWN))),  # Move and paint '3'
      recolor(4, frozenset((i, len(I[0]) - j - 1) for i, j in fours))  # Flip and paint '4'
  ) 
 
3.7142857142857144, tensor(0.3946), Description: Replace the blue and red squares with black squares. Place a blue square in the bottom row, middle column of the grid. Place a red square in the bottom row, leftmost column if the grid height is even, or in the bottom row, rightmost column if the grid height is odd. Keep the original colors of all other squares. 
:: def bjfebebebafbefdajbabdafefidiegcd(I):
  h, w = shape(I)
  O = replace(I, THREE, ZERO)
  O = replace(O, FOUR, ZERO)
  O = paint(O, {(THREE, (h - 1, w // 2))})
  O = paint(O, {(FOUR, (h - 1, 0 if even(h) else w - 1))})
  return O
 
3.4285714285714284, tensor(0.3946), Description: Replace the blue and red squares with black squares. Place a blue square in the bottom row, middle column of the grid. Place a red square in the bottom row, leftmost column if the grid height is even, or in the bottom row, rightmost column if the grid height is odd. Keep the original colors of all other squares. 
:: def bebdehecjeedeffcjfhjfbcddfcdcaae(I):
  h, w = shape(I)
  objs = objects(I, True, False, False)
  O = canvas(ZERO, (h, w))
  for obj in objs:
    color = first(obj)[0]
    if color == THREE:
      O = paint(O, {(color, (h - 1, w // 2))})
    elif color == FOUR:
      O = paint(O, {(color, (h - 1, 0 if even(h) else w - 1))})
  return O
 
2.857142857142857, tensor(0.0204), Description: Move the 3x3 blue shape down one row. Flip the 3x3 red shape horizontally. Keep the original colors. 
:: def cdeffcjehbcfehehjeacjhdcbgadjecj(I):
  threes = ofcolor(I, 3)  # Identify '3' locations
  fours = ofcolor(I, 4)  # Identify '4' locations
  shifted_threes = shift(threes, DOWN)  # Move '3' down
  flipped_fours = hmirror(recolor(4, fours))  # Flip '4' horizontally
  return paint(paint(canvas(0, shape(I)), recolor(3, shifted_threes)), flipped_fours)  # Combine and paint
 
2.142857142857143, tensor(0.0204), Description: Move the 3x3 blue shape down one row. Flip the 3x3 red shape horizontally. Keep the original colors. 
:: def aahgbbeccbeaejddaeibabhjechhagia(I):
  shifted_threes = shift(recolor(3, ofcolor(I, 3)), DOWN)
  flipped_fours = hmirror(recolor(4, ofcolor(I, 4)))
  return paint(
      fill(canvas(0, shape(I)), 3, toindices(shifted_threes)),
      toobject(toindices(flipped_fours), replace(I, 4, 0))
  )
 
3.7142857142857144, tensor(0.3933), Description: Replace the blue and red squares with black squares. Place a blue square in the bottom row, middle column of the grid. Place a red square in the bottom row, leftmost column of the grid. Keep the original colors of all other squares. 
:: def fbfdihfhddjaefeeacdfjfdiedaefacd(I):
  h, w = shape(I)
  three_idx = next(iter(ofcolor(I, THREE)), (0,0))
  four_idx = next(iter(ofcolor(I, FOUR)), (0,0))
  O = canvas(ZERO, (h, w))
  O = paint(O, {(THREE, (h - 1, w // 2))})
  O = paint(O, {(FOUR, (h - 1, 0))})
  return O
 
2.857142857142857, tensor(0.0232), Description: Move the 3x3 blue shape down one row. Move the 3x3 red shape down one row and one column to the right. Keep the original colors. 
:: def egefffeagjdhehibjfjgfffgbdcceihd(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  return paint(paint(canvas(0, shape(I)), recolor(3, shift(three_indices, DOWN))), recolor(4, shift(four_indices, add(DOWN, RIGHT))))
 
2.7142857142857144, tensor(0.5616), Description: Replace all squares with black except for the blue and red squares. Place the blue square in the center of the grid. Place the red square in the center of the grid, but one row below the blue square if the grid height is even, or in the same row as the blue square if the grid height is odd. Keep the original colors of the blue and red squares. 
:: def ffdhdbfcjibceiffidjjaafbbbiddjaf(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == THREE:
        O = fill(O, THREE, {(h // 2, w // 2)})
      if val == FOUR:
        O = fill(O, FOUR, {(h // 2 + (1 if h % 2 == 0 else 0), w // 2)})
  return O
 
2.857142857142857, tensor(1.9814), Description: Copy the input grid. Then, move the smallest colored shape to the top half of the grid, centered horizontally. Move the largest colored shape to the bottom half of the grid, centered horizontally. Keep the original colors. 
:: def dafffdfebceiegaabeeccfggabcddcbc(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    obj1, obj2 = first(objs), last(objs)
    h, w = shape(I)
    upper = paint(canvas(bg, (h // 2, w)), shift(obj2, (h // 4 - height(obj2) // 2, w // 2 - width(obj2) // 2)))
    lower = paint(canvas(bg, (h - h // 2, w)), shift(obj1, (h // 4 - height(obj1) // 2, w // 2 - width(obj1) // 2)))
    O = vconcat(upper, lower)
    return O
 
2.0, tensor(1.9814), Description: Copy the input grid. Then, move the smallest colored shape to the top half of the grid, centered horizontally. Move the largest colored shape to the bottom half of the grid, centered horizontally. Keep the original colors. 
:: def iafhadijaaifebbbbjaecfababebjdij(I):
  bg = mostcolor(I)
  objs = order(objects(I, T, F, T), lambda obj: centerofmass(obj)[0])
  obj1, obj2 = first(objs), last(objs)
  h, w = shape(I)
  O = canvas(bg, (h, w))
  for i in range(height(obj1)):
    for j in range(width(obj1)):
      if index(paint(canvas(bg, shape(obj1)), obj1), (i, j)) != bg:
        O = paint(O, {(index(paint(canvas(bg, shape(obj1)), obj1), (i, j)), (i + h // 4 - height(obj1) // 2, j + w // 2 - width(obj1) // 2))})
  for i in range(height(obj2)):
    for j in range(width(obj2)):
      if index(paint(canvas(bg, shape(obj2)), obj2), (i, j)) != bg:
        O = paint(O, {(index(paint(canvas(bg, shape(obj2)), obj2), (i, j)), (i + h // 2 + h // 4 - height(obj2) // 2, j + w // 2 - width(obj2) // 2))})
  return O
 
3.142857142857143, tensor(1.9814), Description: Copy the input grid. Then, move the smallest colored shape to the top half of the grid, centered horizontally. Move the largest colored shape to the bottom half of the grid, centered horizontally. Keep the original colors. 
:: def dififeffebbdefjbabibgcaehbjjadbb(I):
  bg = mostcolor(I)
  h, w = shape(I)
  objs = objects(I, T, F, T)
  obj1, obj2 = first(objs), last(objs)
  O = paint(canvas(bg, (h, w)), shift(obj1, (h // 4 - height(obj1) // 2, w // 2 - width(obj1) // 2)))
  O = paint(O, shift(obj2, (h // 2 + h // 4 - height(obj2) // 2, w // 2 - width(obj2) // 2)))
  return O
 
2.2857142857142856, tensor(0.0232), Description: Move the 3x3 blue shape down one row. Move the 3x3 red shape down one row and one column to the right. Keep the original colors. 
:: def aaeacccidfhaebgdbiadbbbdccaicbjc(I):
  objs = objects(I, True, False, True)
  three_obj = next((obj for obj in objs if color(obj) == 3), frozenset()) 
  four_obj = next((obj for obj in objs if color(obj) == 4), frozenset()) 
  return paint(cover(paint(canvas(0, shape(I)), shift(three_obj, DOWN)), shift(four_obj, DOWN)), shift(four_obj, RIGHT)) 
 
3.2857142857142856, tensor(0.0096), Description: Move the 3x3 blue shape to the center of the grid. Move the 3x3 red shape to the center of the grid, but one row below the blue shape. Keep the original colors. 
:: def ecfeecahfhcjeaejifdhceicbejgcaie(I):
  obj3 = argmax(objects(I,T,F,T), lambda obj: color(obj) == 3)
  obj4 = argmax(objects(I,T,F,T), lambda obj: color(obj) == 4)
  h, w = shape(I)
  O = canvas(0, (h, w))
  O = paint(O, shift(obj3, (h // 2 - uppermost(obj3) - height(obj3) // 2, w // 2 - leftmost(obj3) - width(obj3) // 2)))
  O = paint(O, shift(obj4, (h // 2 + height(obj3) - uppermost(obj4) - height(obj4) // 2, w // 2 - leftmost(obj4) - width(obj4) // 2)))
  return O
 
3.4285714285714284, tensor(0.3947), Description: Replace the blue and red squares with black squares. Place a blue square in the bottom row, middle column of the grid. Place a red square in the bottom row, rightmost column if the grid height is even, or in the bottom row, leftmost column if the grid height is odd. Keep the original colors of all other squares. 
:: def jgbcdfejhdcheedbicadcaebeffacbia(I):
  h, w = shape(I)
  O = replace(I, THREE, ZERO)  # Replace all '3's with '0'
  O = replace(O, FOUR, ZERO)  # Replace all '4's with '0'
  three_loc = next(iter(ofcolor(I, THREE)), None) # Get '3' location, handle if not found
  four_loc = next(iter(ofcolor(I, FOUR)), None) # Get '4' location, handle if not found
  if three_loc:
    O = paint(O, {(THREE, (h - 1, w // 2))})  # Paint '3' at the bottom middle
  if four_loc:
    O = paint(O, {(FOUR, (h - 1, w - 1 if even(h) else 0))})  # Paint '4' based on grid height
  return O
 
