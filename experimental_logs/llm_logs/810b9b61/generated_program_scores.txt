10.333333333333334, tensor(1.1248), Description: Replace all '1's in the input grid with '3's.  Keep all other values the same. 
:: def hedcgbjidbfaeceeacaegffddgeaaeja(I):
  """
  Replaces '1's with '3's directly on the grid.
  """
  O = tuple(tuple(3 if v == 1 else v for v in row) for row in I) 
  return O
 
23.0, tensor(1.1201), Description: Replace all '1's in the input grid with '0's. Then, find the largest object in the grid and recolor it to '3'. Finally, paint the recolored object onto the cleared grid. 
:: def fgebhcchdjcbebaebedgfdahbeihhcdf(I):
  objs = objects(I, T, F, T)  # Extract objects, excluding background
  largest_obj = argmax(objs, size) # Find the largest object
  recolored_obj = recolor(THREE, largest_obj) # Recolor the largest object to 3
  O = paint(replace(I, ONE, ZERO), recolored_obj) # Paint the recolored object onto a cleared grid 
  return O
 
21.333333333333332, tensor(1.1199), Description: Replace all '1's in the input grid with '0's. Then, find the largest object in the grid and recolor it to '3'. If any other object is '1', keep it the same color. Finally, paint the recolored object onto the cleared grid. 
:: def gcdceafaafjcebedbbdcbahabgbhgece(I):
  target_color = THREE 
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if color(obj) == ONE:
      O = paint(replace(O, ONE, ZERO), recolor(target_color, obj) if obj == argmax(objs, size) else obj)
  return O
 
15.666666666666666, tensor(1.1187), Description: Find the largest object in the input grid that has the color '1'. Recolor that object to '3' and paint it onto the original grid. Leave all other objects unchanged. 
:: def daeiaehheiffecddijdgbejidgjdbdbf(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  max_size = maximum(frozenset(sizes))
  O = I
  for obj in objs:
    if color(obj) == ONE and size(obj) == max_size:
      O = paint(O, recolor(THREE, obj)) 
  return O 
 
23.0, tensor(0.0141), Description: Find the largest object in the input grid. Recolor that object to '3' and paint it onto a blank canvas of the same size as the input grid. 
:: def dececbchgefeedffaajccecacebdbcjf(I):
  # Find the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size) 

  # Recolor the largest object to 3
  recolored_obj = recolor(THREE, largest_obj)

  # Paint the recolored object onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), recolored_obj)
  return O
 
10.333333333333334, tensor(0.0091), Description: Find the largest object in the input grid and recolor it to '3'. Keep all other values the same. 
:: def hdgcfcbjfifiebdbjcdaaddaaedbbaig(I):
  # Get grid dimensions
  h, w = shape(I)
  
  # Find the largest object and its color
  largest_obj = argmax(objects(I, T, F, T), size)
  target_color = color(largest_obj) 

  # Iterate through the grid and recolor
  O = tuple(tuple(THREE if I[i][j] == target_color else I[i][j] for j in range(w)) for i in range(h))
  return O
 
15.666666666666666, tensor(0.0099), Description: Find the largest object in the input grid. Recolor all the cells that are part of the largest object to '3'. Keep all other cells unchanged. 
:: def afbiaabbdbjbedadaejcbgidjabdfeae(I):
  # Find the largest object's indices
  indices = toindices(argmax(objects(I, T, F, T), size))

  # Create a function to recolor if index is present in largest object
  def recolor_if_present(loc):
    return THREE if loc in indices else index(I, loc)

  # Apply the function to all grid indices
  O = tuple(tuple(recolor_if_present((i, j)) for j in range(width(I))) for i in range(height(I)))
  return O
 
15.666666666666666, tensor(1.1085), Description: Replace the object with color '1' in the input grid with a new object of the same shape but with color '3'. Keep all other objects unchanged. 
:: def gbijfceaffdeefacacaaeiiefccgaded(I):
  objs = objects(I, True, True, False) # Get all objects in the grid
  target_obj = extract(objs, lambda obj: color(obj) == ONE) # Find the object with color '1'
  replaced_obj = recolor(THREE, target_obj) # Create a new object with color '3' and same shape
  O = paint(cover(I, target_obj), replaced_obj) # Replace the target object with the new object
  return O
 
10.333333333333334, tensor(1.1083), Description: Replace all '1's in the input grid with '3's. Keep the original shape of the '1' object. 
:: def jijddhbgcfcbefbajehhbdaejjdiffai(I):
  one_indices = ofcolor(I, ONE) # Find indices of all '1' cells
  obj_shape = shape(one_indices) # Determine the shape of the '1' object
  O = fill(I, THREE, one_indices) # Replace all '1' cells with '3'
  return O 
 
31.0, tensor(1.0437), Description: Replace all '1's in the input grid with '3's. Keep the original values for all other cells. 
:: def baabaejdbcacefiijfafahdeheehbeaa(I):
  objs = objects(I, T, F, F) # Find all connected objects
  target_objs = colorfilter(objs, ONE) # Filter objects with color '1'
  target_indices = mapply(toindices, target_objs) # Get indices of all cells in target objects
  filled_grid = fill(I, THREE, target_indices) # Fill target object indices with '3'
  O = cellwise(filled_grid, I, ZERO) # Restore original values for non-target cells
  return O 
 
20.666666666666668, tensor(1.0438), Description: Replace all '1's in the input grid with '3's, but only within the areas that are also black ('0'). Keep the original values for all other cells. 
:: def cccicdeajjbbecfeieehcggdfaabhjaj(I):
  def replace_in_object(obj):
    return recolor(THREE, intersection(toindices(obj), ofcolor(I, ZERO)))
  modified_objects = apply(replace_in_object, colorfilter(objects(I, T, F, F), ONE))
  O = I
  for obj in modified_objects:
    O = paint(O, obj)
  return O
 
10.333333333333334, tensor(1.1184), Description: Find the largest object in the input grid and replace all instances of its color with '3'. Keep all other values the same. 
:: def bjffbfhdbgadebfeidjcgdhehahcfddj(I):
  objs = objects(I, T, F, T)  # Extract objects, excluding the background
  largest_obj_color = color(argmax(objs, size)) # Find the color of the largest object 
  O = replace(I, largest_obj_color, THREE)  # Replace all instances of that color with '3'
  return O
 
20.666666666666668, tensor(1.1200), Description: Find the largest object in the input grid and recolor it to '3'. Paint the recolored object onto the input grid, but only where the background color currently exists. Leave all other objects unchanged. 
:: def addcecbcddaieejfieaidibhdhabdhfb(I):
  largest_obj = argmax(objects(I, T, F, T), size) # Extract objects and find the largest one
  recolored_obj = recolor(THREE, largest_obj) # Recolor the largest object to '3'
  O = underpaint(I, recolored_obj) # Paint the recolored object only where the background color currently exists
  return O
 
166.66666666666666, tensor(0.0048), Description: Find the color that appears most frequently in the input grid and replace all instances of that color with '3'. Keep all other values the same. 
:: def dcgbbabahcggebffjbdcbcbhdbeefcea(I):
  # Find the color with the maximum count
  target_color = argmax(palette(I), lambda c: colorcount(I, c))
  # Recolor cells with the target color to 3
  O = tuple(tuple(3 if I[i][j] == target_color else I[i][j] for j in range(width(I))) for i in range(height(I))) 
  return O
 
10.333333333333334, tensor(1.0438), Description: Replace all '1's in the input grid with '3's. Keep the original shape of the '1' objects. 
:: def gbhhhghcccfgebcbigejchedjcaciiej(I):
    objs = objects(I, T, F, F)  # Identify all objects
    filtered_objs = colorfilter(objs, ONE)  # Filter for objects with color '1'
    recolored_objs = apply(lambda obj: recolor(THREE, obj), filtered_objs) # Recolor to '3'
    O = paint(I, merge(recolored_objs))  # Paint the recolored objects back onto the grid
    return O
 
79.66666666666667, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's.  Keep all other values the same. 
:: def hdfhcabficjjegcejfeffcacffeaajjf(I):
    """
    Iteratively recolors connected '1's to '3's.
    """
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 1:
                O = underfill(O, 3, neighbors((i,j)))
    return O
 
156.33333333333334, tensor(1.1193), Description: Replace all '1's in the input grid with '0's. Then, find the object formed by the '1's and recolor it to '3'. Finally, paint the recolored object onto the cleared grid. 
:: def bbdhbfiaffdbehejideddbegjebcebhb(I):
  return paint(replace(I, ONE, ZERO), recolor(THREE, asobject(replace(I, ONE, THREE))))
 
85.33333333333333, tensor(1.0436), Description: Replace all the cells in the input grid that are part of the first object with the color '3'. Keep all other cells unchanged. 
:: def ieehajfgdddceejdjcebicjbfgibeaeg(I):
  obj = next(iter(objects(I, True, False, False)))
  O = fill(I, THREE, toindices(obj))
  return O
 
161.33333333333334, tensor(1.0438), Description: Replace all the cells in the input grid that are part of the largest object with the color '3'. Keep all other cells unchanged. 
:: def abeaeibajbcgedcejghdbdhbgeidjgcb(I):
  objs = objects(I, True, False, False)
  obj = argmax(objs, size)
  O = fill(I, THREE, toindices(obj))
  return O 
 
15.666666666666666, tensor(1.0441), Description: Replace the first object with color '1' in the input grid with a new object of the same shape but with color '3'. Keep all other objects unchanged. 
:: def ccadjjehjceaehdbjedceecdibaeeccf(I):
    for obj in objects(I, T, F, F):
        if color(obj) == ONE:
            O = fill(I, THREE, toindices(obj))
            break
    return O
 
31.0, tensor(0.0141), Description: Find the largest object in the input grid. Recolor that object to '3' and paint it onto a blank canvas of the same size as the input grid. 
:: def dgeffbadiaciejiibccbegfgfbfdefae(I):
  obj_sizes = apply(size, objects(I, T, F, T))
  largest_obj_index = argmax(enumerate(obj_sizes), lambda x: x[1])[0]
  largest_obj = totuple(objects(I, T, F, T))[largest_obj_index]
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, largest_obj))
  return O
 
22.0, tensor(1.0437), Description: Replace all the cells in the input grid that are part of the smallest object with the color '3'. Keep all other cells unchanged. 
:: def ededifefbfaaeadfahegebcjgcejfdcj(I):
    objs = objects(I, True, False, True)
    target_obj = min(objs, key=lambda obj: len(obj)) 
    O = fill(I, 3, toindices(target_obj))
    return O
 
15.333333333333334, tensor(1.0444), Description: Replace the first object with the least common color in the input grid with a new object of the same shape but with color '3'. Keep all other objects unchanged. 
:: def cbcciecficjceeagaeibdecgadbbeeef(I):
    for obj in objects(I, True, False, True):
        if color(obj) == leastcolor(I):
            I = fill(I, 3, toindices(obj))
    return I
 
70.0, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's.  Keep all other values the same. 
:: def daaaeeabbbdcebcbibbadcdeeeefabfh(I):
    """
    Iterates through the grid and recolors connected '1's to '3'.
    """
    O = canvas(0, shape(I))
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 1:
                O = underpaint(O, recolor(3, toobject(neighbors((i, j)), I)))
    return O
 
156.33333333333334, tensor(1.1082), Description: Replace all '1's in the input grid with '3's, but only if they form a complete object (i.e., are connected to other '1's). Keep all other values the same. 
:: def ajahdjfcffcjeffhaafbhhaeddejbfgj(I):
  """
  Recolors objects consisting solely of '1's to '3's.
  """
  ones_objects = objects(I, True, True, False)  # Find all objects made of '1's.
  O = I # Initialize the output grid
  for obj in ones_objects:
    O = paint(O, recolor(THREE, obj)) # Recolor and paint in a single step
  return O
 
31.0, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's. Keep all other values the same. 
:: def djeehdcafcgaegddijiagdagegbahiec(I):
  """
  Recolors connected '1's to '3's using cellwise replacement.
  """
  ones_threes = cellwise(I, replace(I, 1, 3), 0)  # Replace '1's with '3's, keeping other values unchanged. 
  return cellwise(I, ones_threes, 0) # Combine original grid and modified grid, prioritizing the original values.
 
9.666666666666666, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are adjacent to another '1' and not a '0'. Keep all other values the same. 
:: def bgeedgdeecdcedebaecdffcafeehgace(I):
  """
  Recolors cells based on neighborhood analysis.
  """
  def recolor_condition(loc):
      return any(index(I, n) == 1 for n in neighbors(loc)) and index(I, loc) != 0
  
  indices = asindices(I)
  recolored_indices = sfilter(indices, recolor_condition)
  return fill(I, 3, recolored_indices)
 
81.0, tensor(1.1249), Description: Replace all '1's in the input grid with '3's, including the '1's themselves and their immediate neighbors. Keep all other values the same. 
:: def afaaefbcaeciehbjjjeaaecdbjdbbeje(I):
  """
  Finds locations of '1's and their neighbors, then recolors to '3'.
  """
  ones_locations = ofcolor(I, 1)  # Find indices of all '1's.
  neighboring_locations = mapply(neighbors, ones_locations) # Find all neighbors of '1's.
  all_locations = ones_locations | neighboring_locations  # Combine locations of '1's and their neighbors.
  return fill(I, 3, all_locations) # Fill the grid with '3' at identified locations.
 
161.33333333333334, tensor(0.0120), Description: Find the largest object in the input grid. Recolor all other objects to '3' and paint them onto a blank canvas of the same size as the input grid. Leave the largest object unchanged. 
:: def ddabjfaiddjfecbdjgbbdhfdjaidbgbd(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)
  
  # Recolor all objects except the largest one
  O = paint(canvas(THREE, shape(I)), largest_obj) 
  return O
 
15.333333333333334, tensor(0.0120), Description: Find the largest object in the input grid. Recolor all other objects to '3' and paint them onto the original grid. Leave the largest object unchanged. 
:: def fcbecgacabaaehjjjhbfjhffacbbgaba(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)

  # Recolor other objects
  O = I
  for obj in objects(I, T, F, T):
    if obj != largest_obj:
      O = paint(O, recolor(THREE, obj))
  return O
 
156.33333333333334, tensor(0.0120), Description: Find the largest object in the input grid. Recolor all other objects to '3' and paint them onto a blank canvas of the same size as the input grid. Leave the largest object unchanged. 
:: def ebjeejaegcggefdhiebbffgbcedhjjfa(I):
  # Get all objects
  all_objects = objects(I, T, F, T)

  # Filter out the largest object
  smaller_objects = difference(all_objects, {argmax(all_objects, size)})

  # Recolor the smaller objects and merge them onto a blank canvas
  O = paint(canvas(THREE, shape(I)), merge(apply(lambda obj: recolor(THREE, obj), smaller_objects))) 
  return O
 
40.0, tensor(1.0435), Description: Replace all '1's in the top half of the input grid with '3's. Keep the original values for all other cells in the top half and the entire bottom half. 
:: def bccabheeahfbedfaafcfefiebcdadeei(I):
    # Split the grid horizontally
    top, bottom = tophalf(I), bottomhalf(I)

    # Recolor objects formed by '1' in the top half
    recolored_top = fill(canvas(0, shape(top)), 3, ofcolor(top, 1))

    # Combine the recolored top half with the original bottom half
    O = vconcat(recolored_top, bottom)
    return O
 
27.666666666666668, tensor(1.0437), Description: Replace all '1's in the input grid with '3's, but only if they form a complete object (i.e., are connected to other '1's). Keep all other values the same. 
:: def dfdccfeeaghdebifaadfjdahahhhabee(I):
  # Iterate over objects formed by '1'
  for obj in colorfilter(objects(I, True, False, False), 1):
      # Recolor the object to '3'
      I = paint(canvas(0, shape(I)), recolor(3, obj)) 
  return I
 
31.0, tensor(0.0111), Description: Find the largest object in the input grid. Recolor that object to '3' and paint it onto a blank canvas of the same size as the input grid. Keep the original values for all other cells. 
:: def abhceecedjfceeagjdebdifbddebbhfe(I):
    # Find the largest object
    largest_obj = argmax(objects(I, T, F, T), size)
    # Create a new grid, initially filled with zeros
    O = canvas(0, shape(I))
    # Paint the largest object, recolored to 3, onto the new grid
    O = paint(O, recolor(3, largest_obj)) 
    # Combine the new grid with the original grid, prioritizing the new grid's values
    O = cellwise(O, I, 0)
    return O
 
31.0, tensor(1.1084), Description: Replace all '1's in the input grid with '3's. If a cell is not a '1', use the value from the target grid (where '1's are replaced with '3's). If there are no '1's, use the value of the top-left cell of the target grid. 
:: def jbaaefcdbfidedehaajfbdbhjhdhdiee(I):
  target_grid = replace(I, 1, 3)  # Create a target grid with '1' replaced by '3'
  O = cellwise(I, target_grid, target_grid[0][0]) # Use cellwise matching, prioritizing the target grid
  return O
 
17.0, tensor(1.1247), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's and do not touch the bottom edge of the grid. Keep all other values the same. 
:: def dfhacicafaadebcaabaafhdgcedgefig(I):
  """
  Recolors connected '1's to '3's, excluding the object touching the bottom edge.
  """
  h = len(I)
  for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
    if lowermost(obj) < h - 1: # Check if the object touches the bottom edge
      I = paint(I, recolor(THREE, obj))
  return I
 
11.333333333333334, tensor(1.1249), Description: Replace all '1's in the input grid with '3's, but only if they are not in the bottom row. Keep all other values the same. 
:: def eeiaigddcahjedcjbcefbebbaiceiedf(I):
  """
  Creates a mask to protect the bottom row and then recolors '1's to '3's.
  """
  h, w = len(I), len(I[0])
  mask = canvas(ZERO, (h, w))
  mask = fill(mask, ONE, {(h - 1, j) for j in range(w)}) # Create a mask for the bottom row

  # Apply recoloring logic only where the mask is 0.
  O =  tuple(tuple(THREE if I[i][j] == ONE and mask[i][j] == ZERO else I[i][j] for j in range(w)) for i in range(h))
  
  return O
 
28.0, tensor(0.8641), Description: Find the largest object in the input grid and paint it onto a blank canvas of the same size as the input grid. Leave all other cells black. 
:: def jficibjeddicehjcjgcfdebbibejagad(I):
    objs = objects(I, T, F, T)
    largest_obj = lambda obj: len(obj) == size(argmax(objs, size))
    return paint(canvas(0, shape(I)), extract(objs, largest_obj)) 
 
91.0, tensor(1.1247), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's and do not touch the bottom edge of the grid. Keep all other values the same. 
:: def acehfdefbdihehjjibbfbfbeibadabjb(I):
  """
  Recolors connected '1's to '3's, preserving the bottom-most object.
  """
  # Get all connected objects of '1's
  one_objects = objects(I, univalued=True, diagonal=False, without_bg=False)

  # Find the object with the maximum 'i' coordinate (bottom-most)
  bottom_object = max(one_objects, key=lambda obj: lrcorner(obj)[0])

  # Recolor all objects except the bottom-most
  for obj in one_objects:
    if obj != bottom_object:
      I = paint(I, recolor(3, obj))
  return I
 
15.666666666666666, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's and are not the lowest object in the grid (based on the uppermost row index). Keep all other values the same. 
:: def efdadceafieceebfaegfgdgccedbbcca(I):
  """
  Recolors connected '1's to '3's, except the lowest one.
  """
  # Get a sorted list of objects based on their lowest row index.
  sorted_objects = sorted(objects(I, univalued=True, diagonal=False, without_bg=False), key=lambda obj: uppermost(obj))

  # Recolor objects starting from the second object (index 1).
  for obj in sorted_objects[1:]:
    I = paint(I, recolor(3, obj))

  return I
 
166.66666666666666, tensor(1.1250), Description: Replace all '1's in the input grid with '3's, but only if they are connected to other '1's and are not the lowest object in the grid (based on the uppermost row index). Keep all other values the same. 
:: def efehjgfdbfffedjhabfeaccfeicahcff(I):
  """
  Recolors connected '1's to '3's except the bottom-most object.
  """
  objs = partition(I) 
  bottom_object = max(objs, key=lambda obj: uppermost(obj))  
  objs_to_recolor = objs - {bottom_object} 
  for obj in objs_to_recolor:
    I = paint(I, recolor(3, obj))
  return I
 
10.333333333333334, tensor(0.0019), Description: Replace all '1's in the input grid with '3's, forming a single object. Keep the original values for all other cells. 
:: def ebbibceacdehedhhaacfbhdaebcdcadb(I):
  """
  Identifies objects formed by '1's and recolors them to '3's.
  """
  # Find indices of all '1's in the input grid
  ones_indices = ofcolor(I, ONE)
  # Create an empty object
  recolored_obj = initset((THREE, first(ones_indices))) if ones_indices else frozenset()
  # Add all the '1' indices to the object with color '3' 
  for index in ones_indices:
    recolored_obj = insert((THREE, index), recolored_obj)
  # Paint the object onto a blank canvas of the same size as the input
  return paint(canvas(ZERO, shape(I)), recolored_obj)
 
10.333333333333334, tensor(0.0238), Description: Replace all '1's in the input grid with '3's. Keep the original shape of the '1' objects. 
:: def dedabdfafaeiejafiidjbdiccfgfebfd(I):
  objs = objects(I, T, F, T) 
  return paint(I, merge({recolor(THREE, obj) if color(obj)==ONE else obj for obj in objs}))
 
10.333333333333334, tensor(0.0318), Description: Replace all '1's in the input grid with '3's. Keep all other values the same. 
:: def aecdehjicfdceehjbcbgeeaahfeehaej(I):
  return replace(I, ONE, THREE)
 
10.333333333333334, tensor(0.0157), Description: Replace all '1's in the input grid with '3's. Keep all other values the same. 
:: def bedcehhjfbcceadibhfacbjiechdjicb(I):
  return replace(I, ONE, THREE)
 
90.33333333333333, tensor(0.0152), Description: Replace all '1's in the input grid with '3's. Keep the original shape of the '1' objects. 
:: def cfjbbffefdfdeefdibcgjcbhcedbfffb(I):
  objs = objects(I, False, False, False)
  return paint(canvas(ZERO, shape(I)), merge(apply(lambda obj: recolor(THREE, obj) if color(obj) == ONE else obj, objs)))
 
10.333333333333334, tensor(0.0910), Description: Replace all '1's in the input grid with '3's. Keep all other values the same. 
:: def ecfbjebbhefdeacdiaieiehgcjhdbcjc(I):
  O = replace(I, ONE, THREE)
  return O
 
166.66666666666666, tensor(0.0021), Description: Replace all '1's in the input grid with '3's. Keep all other values the same. 
:: def hhdhfiigbghbebbbbijdgjciahjbbeed(I):
  """
  Applies a cellwise transformation to recolor '1's to '3's.
  """
  return cellwise(I, canvas(ONE, shape(I)), THREE)  # Cellwise comparison and recoloring
 
151.0, tensor(0.0317), Description: Replace all '1's in the input grid with '3's, except for the object that contains the bottom-right corner. Keep the original values for all other cells. 
:: def edaacfdeehbbedfcbebaieaedghffbhe(I):
  objs = objects(I, True, False, False)
  lr = lrcorner(asindices(I))
  lr_obj = extract(objs, lambda obj: lr in toindices(obj)) 
  return paint(replace(I, ONE, THREE), recolor(ONE, lr_obj)) 
 
161.33333333333334, tensor(0.0298), Description: Find the largest object in the input grid and recolor it to '3'. Paint the recolored object onto the original grid. Leave all other objects unchanged. 
:: def bgahgjhbehfceeghjahdhbdacjdeefia(I):
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  return paint(I, recolor(THREE, largest_obj))
 
167.0, tensor(0.0317), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object that has more than one cell. Keep the original shape of the '1' objects. 
:: def ciejbfdbgiebefigjfeeggfcehdaafeb(I):
  objs = objects(I, True, False, False)
  filtered_objs = sfilter(objs, lambda obj: size(obj) > 1) 
  return paint(replace(I, ONE, THREE), merge(apply(lambda obj: recolor(ONE, obj), filtered_objs)))
 
10.0, tensor(0.0317), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object that has only one cell. Keep the original shape of the '1' objects. 
:: def ifedacadadcbeichjjeefiagdcbhghde(I):
  objs = objects(I, True, False, False)
  small_objs = sfilter(objs, lambda obj: size(obj) == 1)
  return paint(replace(I, ONE, THREE), merge(apply(lambda obj: recolor(ONE, obj), small_objs)))
 
8.0, tensor(0.0023), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object whose topmost row is less than 2. If the topmost row of the object is 2 or greater, replace the '1's with '3's. Keep the original shape of the '1' objects. 
:: def jdafebbecdejedihbbdbjadcdacafdac(I):
  objs = objects(I, True, False, False)
  out = canvas(ZERO, shape(I))
  for obj in objs:
    if color(obj) == ONE:
      topmost_row = uppermost(obj)
      if topmost_row < 2: 
        out = paint(out, recolor(ONE, obj))
      else:
        out = paint(out, recolor(THREE, obj))
  return out
 
154.0, tensor(0.0016), Description: Replace all '1's in the input grid with '3's, except for those '1's that are part of an object whose topmost row is less than 2. For those objects, keep the '1's as they are. Keep the original shape of the '1' objects. 
:: def befcccefafhgeaadaaadaabbdadbeidc(I):
  top_objs = sfilter(objects(I, True, False, False), lambda obj: uppermost(obj) < 2)
  other_objs = difference(objects(I, True, False, False), top_objs)
  out = canvas(ZERO, shape(I))
  for obj in top_objs:
    out = paint(out, recolor(ONE, obj))
  for obj in other_objs:
    out = paint(out, recolor(THREE, obj))
  return out
 
9.333333333333334, tensor(0.0015), Description: Replace all '1's in the input grid with '3's, except for those '1's that are in the first two rows. For those '1's, keep them as they are. Keep the original shape of the '1' objects. 
:: def fhffffbhcbejecadbbcddegegbcbbjib(I):
  out = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        if i < 2:
          out = paint(out, {(ONE, (i, j))})
        else:
          out = paint(out, {(THREE, (i, j))})
  return out
 
31.0, tensor(0.7814), Description: Replace all '1's in the input grid with '3's. Then, find the most common color in the grid and use that color to create a new object with the same shape as the original '1' object. Finally, paint the new object onto the grid, replacing the original '1' object. 
:: def cjccdicbfhcieaeeifchgbgfabcbaebe(I):
  return paint(replace(I, ONE, THREE), asobject(replace(I, ONE, mostcolor(I)))) 
 
31.0, tensor(0.0157), Description: Replace all '1's in the input grid with '3's. Keep the original values for all other cells. 
:: def jfcfbaeceageehhfbiadbdfabcdgcidc(I):
    return cellwise(replace(I, ONE, THREE), I, ZERO)
 
31.0, tensor(0.0910), Description: Replace all '1's in the input grid with '3's. Keep all other values the same. 
:: def iihaefdaiiadeedgbgddfjcgdgdfcehb(I):
  O = cellwise(I, canvas(ONE, shape(I)), ZERO) # Create a mask where '1' is present in input
  O = cellwise(O, canvas(THREE, shape(I)), ZERO) # Use the mask to replace '1' with '3' in output
  return O
 
157.33333333333334, tensor(0.0016), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object whose topmost row is above the middle row of the grid. Keep all other values the same. 
:: def cbfdafecdjheedjciadadecfhcahajej(I):
  """
  Recolors objects above the middle row to '3', keeps others unchanged.
  """
  # Identify objects formed by connected '1's.
  objs = objects(I, True, False, False)
  # Create a blank canvas of the same size as the input.
  out = canvas(ZERO, shape(I))
  # Iterate over each object.
  for obj in objs:
    # Recolor based on vertical position.
    out = paint(out, recolor(THREE, obj) if uppermost(obj) < height(I) // 2 else obj)
  return out
 
40.0, tensor(0.0019), Description: Replace all '1's in the top half of the input grid with '3's. Keep the original values for all other cells in the top half and the entire bottom half. 
:: def hdchdebchdccebefjddbahcaifedafhc(I):
  """
  Splits the grid horizontally, recolors the top part, and recombines.
  """
  top_half = tophalf(I)  
  bottom_half = bottomhalf(I)
  top_recolored = replace(top_half, ONE, THREE) 
  return vconcat(top_recolored, bottom_half) 
 
16.0, tensor(0.0019), Description: Replace all '1's in the top half of the input grid with '3's. Keep the original values for all other cells in the top half and the entire bottom half. 
:: def jbafbddhfdacegfcibhigfgeeceaaeib(I):
  """
  Iterates through rows, recoloring '1's in the top half.
  """
  out = tuple() 
  for i, row in enumerate(I):
    if i < height(I) // 2:
      out += (tuple(THREE if v == ONE else v for v in row),)
    else:
      out += (row,)
  return out
 
5.333333333333333, tensor(0.0909), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object that has a width of at least 3. Keep the original shape of the '1' objects. 
:: def gbjhbdhecjfhegfaafgbihgbiaadheac(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    filtered_objs = sfilter(objs, lambda obj: color(obj) == ONE and width(obj) >= THREE)
    O = I
    for obj in filtered_objs:
        O = paint(O, recolor(THREE, obj))
    return O
 
17.666666666666668, tensor(0.0914), Description: Replace sequences of three consecutive '1's in a row with '3's, but only if they are not part of a longer sequence of '1's. In other words, find '111' patterns that are not surrounded by more '1's. Keep all other values the same. 
:: def egggfjdhefdcebbgahegecciaabaeecf(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])-2):
      if I[i][j] == I[i][j+1] == I[i][j+2] == ONE and (j == 0 or I[i][j-1] == ZERO) and (j == len(I[0])-3 or I[i][j+3] == ZERO):
        O = fill(O, THREE, ((i, j), (i, j+1), (i, j+2)))
  return O
 
7.666666666666667, tensor(0.0909), Description: Replace all '1's in the input grid with '3's, but only if they are part of a sequence of three consecutive '1's in a row. If a '1' is not part of such a sequence, keep it as '1'. Keep all other values the same. 
:: def aahigfdfadbcebbhjccbaaffeebedahb(I):
    h = len(I)
    w = len(I[0])
    O = canvas(ZERO, (h, w))
    for i in range(h):
        for j in range(w):
            if I[i][j] == ONE:
                if j < w - 2 and I[i][j + 1] == ONE and I[i][j + 2] == ONE:
                    O = fill(O, THREE, ((i, j), (i, j + 1), (i, j + 2)))
                elif j > 1 and I[i][j - 1] == ONE and I[i][j - 2] == ONE:
                    O = fill(O, THREE, ((i, j), (i, j - 1), (i, j - 2)))
                else:
                    O = fill(O, ONE, ((i, j),))
            else:
                O = fill(O, ZERO, ((i, j),))
    return O
 
13.0, tensor(0.0018), Description: Replace all '1's in the input grid with '3's, but only if they are in the top half of the grid. Keep all other values the same. 
:: def afbefcibhegdeccijhafedafebebeegg(I):
  """
  Iterates through the grid, checking the upper half condition for recoloring.
  """
  h, w = len(I), len(I[0])
  out = canvas(ZERO, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] == ONE:
        if any(I[k][j] == ONE and k < h // 2 for k in range(h)):
          out = paint(out, {(THREE, (i, j))})
        else:
          out = paint(out, {(ONE, (i, j))})
  return out
 
14.666666666666666, tensor(0.0020), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object that has at least one cell in the top half of the grid. If the object is entirely in the bottom half, keep the '1's as they are. Keep the original shape of the '1' objects. 
:: def ajfijiddjeceeffebbbddfjaheabdifj(I):
  """
  Leverages object detection and manipulation functions from DSL.
  """
  objs = objects(I, True, False, False)
  out = canvas(ZERO, shape(I))
  for obj in objs:
    if color(obj) == ONE:
      upper_half_check = len(intersection(toindices(obj), asindices(tophalf(I)))) > 0
      out = paint(out, recolor(THREE if upper_half_check else ONE, obj)) 
  return out
 
66.33333333333333, tensor(0.0021), Description: Replace all '1's in the input grid with '3's, but only if they are in the left half of the grid (when viewed after transposing the grid diagonally). Keep all other values the same. 
:: def bijbfbbaacbceaheabjbbbdfhfedhaaa(I):
  """
  Utilizes matrix transposition and column-wise operations.
  """
  transposed = dmirror(I)
  h = height(I)
  recolored_transposed = tuple(
      tuple(THREE if any(c == ONE for c in row[:h//2]) else v for v in row)
      for row in transposed
  )
  return dmirror(recolored_transposed)
 
20.666666666666668, tensor(0.0241), Description: Replace all '1's in the input grid with '3's, but only if they are part of a complete object (i.e., are connected to other '1's). Keep all other values the same. 
:: def eebeahebjbifegedbdbddjddiejjcifc(I):
  return paint(I, mfilter(objects(I, T, F, T), lambda obj: recolor(THREE, obj) if color(obj) == ONE else obj))
 
12.333333333333334, tensor(0.0019), Description: Replace all '1's in the input grid with '3's, but only if they are part of a complete object (i.e., are connected to other '1's) and do not touch the bottom row of the grid. Keep all other values the same. 
:: def chbefdjdbbajeeabbchbafcgafbcdghc(I):
  """
  Recolors objects consisting solely of '1's to '3's, 
  except for objects touching the bottom row.
  """
  objs = objects(I, True, False, False)
  out = canvas(ZERO, shape(I))
  for obj in objs:
    if color(obj) == ONE and lowermost(obj) < len(I) - 1:
      out = paint(out, recolor(THREE, obj))
    else:
      out = paint(out, obj) 
  return out
 
11.333333333333334, tensor(0.0018), Description: Replace all '1's in the input grid with '3's, but only if they are not in the last row. Keep all other values the same. 
:: def gheehdadbchdebchajhgefecafdefhba(I):
  """
  Iterates through the grid and recolors '1's to '3's, 
  except for '1's in the last row.
  """
  h, w = len(I), len(I[0])
  output = canvas(ZERO, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] == ONE and i < h-1:
        output = paint(output, {(THREE, (i,j))})
      else:
        output = paint(output, {(I[i][j], (i,j))})
  return output
 
20.666666666666668, tensor(0.0016), Description: Replace all '1's in the input grid with '3's, but only if they are part of an object that does not touch the bottom row of the grid. Keep all other values the same. 
:: def fidjfcfgfaadegfdbibhcibaccecffcf(I):
  """
  Creates a mask for the bottom row and uses it to selectively recolor objects.
  """
  h, w = len(I), len(I[0])
  mask = canvas(ZERO, (h, w))
  mask = paint(mask, recolor(ONE, {(h-1, j) for j in range(w)}))
  objs = objects(I, True, False, False)
  out = I
  for obj in objs:
    if color(obj) == ONE and not intersection(toindices(obj), toindices(asobject(mask))):
      out = paint(out, recolor(THREE, obj))
  return out
 
90.33333333333333, tensor(0.0316), Description: Replace all '1's in the input grid with '3's. Keep the original shape of the '1' objects. 
:: def cabecehfccedefjgidfgdchdbfdfcehd(I):
  objs = objects(I, F, F, F)
  O = I
  for obj in objs:
    if color(obj) == ONE:
      O = paint(O, recolor(THREE, obj))
  return O
 
166.66666666666666, tensor(0.0316), Description: Replace all '0's in the input grid with '3's, and then replace all '2's with '3's. Keep all other values the same. 
:: def gafaighgdehfeddeaghdaaeecbeaigdi(I):
  return replace(replace(I, ZERO, THREE), TWO, THREE)
 
22.666666666666668, tensor(0.0908), Description: Replace all '1's in the input grid with '3's, but only if they form a horizontal line. Keep the original shape of the '1' objects. 
:: def dcieiacebdfdecbgbdcgfahfebjfhcfa(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)  # Extract connected objects of '1's
  filtered_objs = sfilter(objs, hline)  # Keep only objects that are horizontal lines
  recolored_objs = apply(lambda obj: recolor(THREE, obj), filtered_objs)  # Recolor the lines to '3'
  O = I
  for obj in recolored_objs:
    O = paint(O, obj)  # Paint the recolored lines back onto the grid
  return O
 
20.666666666666668, tensor(0.0156), Description: Replace all '1's in the input grid with '3's, but only if they are part of a complete object (i.e., are connected to other '1's). Keep the original shape of the '1' objects. 
:: def bcaeeedbeeahecgjabfaeecfffeeedfe(I):
  return paint(I, recolor(THREE, merge(apply(lambda obj: obj if color(obj) != ONE else frozenset(), objects(I, T, F, T)))))
 
24.333333333333332, tensor(0.0906), Description: Replace all '1's in the input grid with '3's, but only if they form a horizontal line that is longer than one cell. Keep the original shape of the '1' objects. 
:: def aiddcbeaaefeeafbajedaeiafaabaaai(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
    if hline(obj) and size(obj) > 1:
      O = fill(O, THREE, toindices(obj))
  return O
 
14.333333333333334, tensor(0.0909), Description: Replace all '1's in the input grid with '3's, but only if they are part of a sequence of three consecutive '1's in a row. If a '1' is not part of such a sequence, keep it as '1'. Keep all other values the same. 
:: def aadajdhabdadebecbcdfbgfecdiehhai(I):
  def replace_line(row):
    return [THREE if j + 2 < len(row) and row[j] == row[j+1] == row[j+2] == ONE else v 
            for j, v in enumerate(row)]
  return tuple(tuple(replace_line(list(row))) for row in I)
 
31.0, tensor(0.0368), Description: Reposition each of the colored objects in the input grid based on a specific pattern. The exact repositioning logic (rotation and offset) needs to be determined based on the specific pattern in the examples. For instance, the example might involve rotating each object 90 degrees counterclockwise and shifting it to a new location. The output grid should contain the repositioned objects, with the background color set to 0. 
:: def aeacaebijdecegibicicjaajgdjaabfd(I):
    # 1. Extract 3-valued objects
    objs = objects(I, T, F, T)
    
    # 2. Define a function to reposition objects
    def reposition(obj):
        # Logic to determine new position and rotation based on object properties
        # (This logic needs to be determined based on the exact pattern in the examples)
        
        # Example: Rotate 90 degrees counterclockwise and shift
        new_obj = rot270(obj)
        new_obj = shift(new_obj, (offset_i, offset_j)) # Calculate offset based on pattern
        return new_obj
    
    # 3. Apply repositioning and paint on canvas
    new_objs = apply(reposition, objs)
    canvas_size = (height(I), width(I)) # Assuming canvas size is same as input
    O = canvas(0, canvas_size)
    O = paint(O, new_objs)
    
    return O
 
63.0, tensor(0.0088), Description: Copy the input grid. Then, for each '3' in the input, place a '3' in the output grid at a position that is 10 rows below and the same column as the original '3'. Additionally, copy any '1's that are present in the rotated and shifted version of the '1' object from the input grid, where the object is shifted 8 rows down and 11 columns to the right, and then rotated 90 degrees clockwise. Keep all other values the same. 
:: def ecdjiehedjaaeacgiedacjfehccfbcfc(I):
    O = canvas(0, shape(I))
    for i, j in asindices(I):
        if I[i][j] == 3:
            O = fill(O, 3, {(10 + (len(I) - 1 - i), j)})
        elif I[i][j] == 1 and (i, j) in rot90(shift(ofcolor(I, 1), (8, 11))):
            O = fill(O, 1, {(i, j)})
    return O 
 
156.33333333333334, tensor(0.0110), Description: Copy the input grid. Draw a diagonal line from the top left corner of the colored shape to the bottom right corner of the colored shape. Then draw a vertical line from the bottom of the colored shape to the bottom of the grid. The lines should be the same color as the colored shape. 
:: def jeiedaffibadecbcaceeacaadebfdfda(I):
    # Identify the '3' shape
    obj = asobject(I)  

    # Calculate center of the shape
    center_obj = centerofmass(obj)  

    # Diagonal line coordinates
    diag_start = add(center_obj, (-2, 2)) 
    diag_end = add(center_obj, (2, 6)) 
    diag_line = connect(diag_start, diag_end)

    # Vertical line coordinates
    vert_start = add(center_obj, (4, 0)) 
    vert_end = add(center_obj, (6, 0)) 
    vert_line = connect(vert_start, vert_end)

    # Combine lines
    all_lines = combine(diag_line, vert_line)

    # Draw lines on canvas
    O = fill(canvas(0, shape(I)), 1, all_lines)  
    O = paint(O, obj) # Paint original object

    return O
 
562.0, tensor(1.9834), Description: Copy the input grid. For each object in the input grid, calculate a horizontal and vertical shift based on the object's position and size. Shift the object by these calculated amounts. Paint the shifted objects onto a new canvas that is twice the size of the input grid. The background of the output grid should be black. 
:: def daahddffgdcheefcifdabhabeahbhgdc(I):
  objs = objects(I, T, F, T)  # Extract objects from the input grid
  new_objs = set()
  for i, obj in enumerate(objs):
    # Calculate horizontal and vertical shift based on object's position
    h_shift =  (i + 1) * width(obj) # Example: adjust multiplier as needed
    v_shift = (i + 1) * height(obj) # Example: adjust multiplier as needed
    new_objs.add(shift(obj, (v_shift, h_shift)))
  
  canvas_size = (height(I) * 2, width(I) * 2)  # Example: adjust canvas size as needed
  O = canvas(ZERO, canvas_size) 
  for obj in new_objs:
    O = paint(O, obj) 
  return O
 
72.66666666666667, tensor(0.0074), Description: Copy the input grid. Then, for each '3' in the input, place a '3' in the output grid at a position that is 10 rows below and the same column as the original '3' if the input grid is 15x15, otherwise place it 4 rows below. Additionally, copy any '1's that are present in the rotated and shifted version of the '1' object from the input grid, where the object is shifted 8 rows down and 11 columns to the right, and then rotated 90 degrees clockwise if the input grid is 15x15, otherwise shift 2 rows down and 3 columns to the right and rotate 90 degrees clockwise. Keep all other values the same. 
:: def faefefbcbfjgebhfjghdgfgfbaaaeffb(I):
    h, w = len(I), len(I[0])
    O = canvas(0, (h, w))
    for i in range(h):
        for j in range(w):
            if I[i][j] == 3:
                O = fill(O, 3, {(h - 1 - i + (10 if h == 15 else 4), j)})
            elif I[i][j] == 1:
                if h == 15:
                    new_i, new_j = j, 14 - i
                    new_i, new_j = new_i + 8, new_j + 11
                elif h == 9:
                    new_i, new_j = j, 8 - i
                    new_i, new_j = new_i + 2, new_j + 3
                else:
                    new_i, new_j = i, j
                O = fill(O, 1, {(new_i, new_j)})
    return O
 
31.0, tensor(0.0063), Description: 
Copy the input grid. For each '3' in the input, place a '3' in the output grid 10 rows below and in the same column if the input grid is 15x15, otherwise place it 4 rows below. Additionally, copy any '1's that are present in the rotated and shifted version of the '1' object from the input grid, where the object is shifted 8 rows down and 11 columns to the right, and then rotated 90 degrees clockwise if the input grid is 15x15, otherwise shift 2 rows down and 3 columns to the right and rotate 90 degrees clockwise. Keep all other values the same. 
:: def fbfeagfegegaecfcafbdaahdgbfffcaf(I):
  # Define conditional transformation function
  def transform_object(obj):
    if color(obj) == 3:
      return shift(hmirror(obj), (10 if len(I) == 15 else 4, 0))
    elif color(obj) == 1:
      return shift(rot90(obj), (8 if len(I) != 9 else 2, 11 if len(I) != 9 else 3))

  # Apply transformation to all objects
  transformed_objs = apply(transform_object, objects(I, T, F, T))
  
  # Paint transformed objects onto the canvas
  O = canvas(0, shape(I))
  for obj in transformed_objs:
    O = paint(O, obj)
  return O
 
156.33333333333334, tensor(0.0599), Description: 
Find the largest object in the input grid. If there is no object, place a 'U' shape at the bottom right corner of the grid. Otherwise, move the largest object to the bottom right corner of the grid. If the center of the largest object is above the middle row of the grid, rotate the 'U' shape 90 degrees clockwise. Paint the 'U' shape onto the grid. 
:: def ecadcdefbbbbeddbbadeecdjijegdaaf(I):
  # Find the largest object
  objs = objects(I, T, T, T)
  largest_obj = argmax(objs, size)
  
  # Get grid dimensions
  h = height(I)
  w = width(I)
  
  # Handle the case where there's no object to move 
  if largest_obj is None:
    target_pos = (h - 3, w - 3)
  else:  
    # Determine target position (bottom-right)
    target_pos = (h - height(largest_obj), w - width(largest_obj))
    # Move the largest object
    I = move(I, largest_obj, target_pos)

  # Determine if rotation is needed
  rotation_needed = centerofmass(largest_obj)[0] < h // 2 if largest_obj is not None else False 

  # Define the 'U' shape based on rotation
  if rotation_needed:
    u_shape = {(1, (target_pos[0] - 1, target_pos[1] + i)) for i in range(3)} 
  else:
    u_shape = {(1, (target_pos[0] + (height(largest_obj) if largest_obj is not None else 3), target_pos[1] + i)) for i in range(3)}
  
  # Paint the 'U' shape onto the grid
  O = paint(I, u_shape)
  return O 
 
38.333333333333336, tensor(0.0573), Description: 
Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and three columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's five rows from the bottom and two columns from the right. 
:: def bhjdhbieafcieaafihefebcjiddhdhdi(I):
  h, w = height(I), width(I)
  O = canvas(0, (h, w))  # Initialize with zeros
  
  # Place the '3' shape 
  three_shape = {(3, (i, j)) for i in range(h-4, h-1) for j in range(w-4, w-1)}
  O = paint(O, three_shape)

  # Place the '1' shapes based on grid size
  if h > w:
    one_shape_h = {(1, (h-2, w-3)), (1, (h-2, w-2)), (1, (h-2, w-1))}
    O = paint(O, one_shape_h)
  else:
    one_shape_v = {(1, (h-5, w-2)), (1, (h-4, w-2)), (1, (h-3, w-2))}
    O = paint(O, one_shape_v)

  return O
 
39.0, tensor(0.0568), Description: 
Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and four columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's six rows from the bottom and two columns from the right. 
:: def fcfjafcccjcbebhcaaghhfcfgijbhbgc(I):
  h, w = height(I), width(I)
  O = canvas(0, (h, w))  # Initialize with zeros

  # Define base '3' and '1' shapes
  three_shape = {(3, (i, j)) for i in range(3) for j in range(3)}
  one_shape_h = {(1, (0, i)) for i in range(3)}
  one_shape_v = {(1, (i, 0)) for i in range(3)}
  
  # Calculate shift offsets for shapes
  three_offset = (h-4, w-4)
  one_offset = (h-2, w-4) if h > w else (h-6, w-2)

  # Place shapes using calculated offsets
  O = paint(O, shift(three_shape, three_offset))
  O = paint(O, shift(one_shape_h if h > w else one_shape_v, one_offset))
  
  return O
 
37.0, tensor(0.0587), Description: 
Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and three columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's five rows from the bottom and two columns from the right. If the '3' shape is placed on the right side of the grid, mirror the '1' shape horizontally. 
:: def idicehffachfeebdiihjcgfiafgdffid(I):
  h, w = height(I), width(I)
  O = canvas(0, (h, w))

  # Create the base '3' shape at the origin 
  three_shape = {(3, (i, j)) for i in range(3) for j in range(3)}

  # Place '3' shape based on grid size
  if h > w:
    O = paint(O, shift(three_shape, (h-4, w-4)))
  else:
    O = paint(O, shift(hmirror(three_shape), (h-4, 0)))

  # Place '1' shape using mirroring based on '3' shape position
  if (h > w and O[h-2][w-3] == 1) or (h <= w and O[h-4][1] == 3):
    one_shape = {(1, (h-2, w-3)), (1, (h-2, w-2)), (1, (h-2, w-1))}
  else:
    one_shape = {(1, (h-5, w-2)), (1, (h-4, w-2)), (1, (h-3, w-2))}
  O = paint(O, one_shape)
  
  return O
 
135.66666666666666, tensor(0.0116), Description:
Copy the input grid and divide it into four quadrants. Mirror the top-left quadrant horizontally and vertically, then shift it to the bottom-right quadrant. Mirror the top-right quadrant horizontally, then shift it to the bottom-left quadrant. Mirror the bottom-left quadrant vertically, then shift it to the top-right quadrant. Leave the bottom-right quadrant unchanged. Finally, draw a vertical line of '1's from the middle of the top quarter of the grid to the middle of the bottom quarter of the grid. 
:: def bbeacgchegchejcdafedhbdjgfhfcbga(I):
    h, w = shape(I)
    O = canvas(0, shape(I))

    q1 = asobject(crop(I, (0, 0), (h // 2, w // 2)))
    q2 = asobject(crop(I, (0, w // 2), (h // 2, w // 2)))
    q3 = asobject(crop(I, (h // 2, 0), (h // 2, w // 2)))
    q4 = asobject(crop(I, (h // 2, w // 2), (h // 2, w // 2)))

    O = paint(O, shift(hmirror(vmirror(q1)), (h // 2, w // 2)))
    O = paint(O, shift(hmirror(q2), (h // 2, 0)))
    O = paint(O, shift(vmirror(q3), (0, w // 2)))
    O = paint(O, q4)

    center_j = width(I) // 2 
    O = paint(O, recolor(1, connect((h // 4, center_j), (h - h // 4 - 1, center_j))))

    return O
 
62.333333333333336, tensor(0.0638), Description: Copy the input grid and mirror it vertically. Then, find the center of the output grid and calculate the shift needed to center the mirrored object on the grid. Paint the mirrored and shifted object onto the output grid. Finally, draw a horizontal line of '1's across the center row of the grid, and a vertical line of '1's down the center column of the grid. 
:: def aidjbaehdfaieibbbgicdfcjadedadfj(I):
  obj = asobject(I)
  target_loc = centerofmass(canvas(0, shape(I)))  # Find the center of the output grid
  shift_vector = subtract(target_loc, centerofmass(obj))  # Calculate the shift to center the object
  O = paint(canvas(0, shape(I)), shift(vmirror(obj), shift_vector)) # Paint the mirrored and shifted object
  O = paint(O, recolor(1, connect((target_loc[0], 0), (target_loc[0], rightmost(shift(obj, shift_vector)))))) # Draw the horizontal line
  O = paint(O, recolor(1, connect((0, target_loc[1]), (lowermost(shift(obj, shift_vector)), target_loc[1])))) # Draw the vertical line
  return O
 
158.33333333333334, tensor(0.3988), Description: Copy the input grid and mirror it vertically. Then, find the center of the output grid and calculate the shift needed to center the mirrored object on the grid. Paint the mirrored and shifted object onto the output grid. Finally, draw a horizontal line of '1's across the center row of the grid, and a vertical line of '1's down the center column of the grid, filling only the background color. 
:: def fgjabjfigghdefbejfdecciijbagdeea(I):
  obj = asobject(I)
  grid_size = shape(I)
  center_point = (grid_size[0] // 2, grid_size[1] // 2)
  shifted_obj = shift(vmirror(obj), subtract(center_point, centerofmass(obj)))
  O = paint(canvas(0, grid_size), shifted_obj)
  O = underfill(O, 1, connect((center_point[0], 0), center_point))  # Vertical line, filling only background
  O = underfill(O, 1, connect((0, center_point[1]), center_point))  # Horizontal line, filling only background
  return O
 
39.0, tensor(0.0597), Description: 
Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and four columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's six rows from the bottom and two columns from the right. Then, place a 'U' shape two rows from the bottom and four columns from the right if the grid is taller than it is wide, or six rows from the bottom and two columns from the right if the grid is wider than it is tall. If the '3' shape is placed on the right side of the grid, mirror the 'U' shape horizontally. 
:: def beijaejcdjgdeaaejdbhgfijedgdcbea(I):
  h, w = height(I), width(I)
  u_shape = {(1, (h-2, w-4)), (1, (h-2, w-3)), (1, (h-2, w-2))}  # Define U shape
  square = {(3, (h-4, w-5)), (3, (h-4, w-4)), (3, (h-4, w-3)), 
            (3, (h-3, w-5)), (3, (h-3, w-3)), 
            (3, (h-2, w-5)), (3, (h-2, w-4)), (3, (h-2, w-3))} # Define square
  line = {(1, (h-3, i)) for i in range(w-6, w-3)}  # Define line
  if h > w:  # Rotate if taller than wide
    u_shape = rot90(u_shape)
    square = rot90(square)
    line = rot90(line)
  O = canvas(0, (h, w))  # Create empty canvas
  O = paint(O, u_shape) # Paint the 'U'
  O = paint(O, square) # Paint the square
  O = paint(O, line) # Paint the line
  return O
 
41.0, tensor(0.0597), Description: Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and four columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's six rows from the bottom and two columns from the right. Then, place a 'U' shape two rows from the bottom and four columns from the right if the grid is taller than it is wide, or six rows from the bottom and two columns from the right if the grid is wider than it is tall. If the '3' shape is placed on the right side of the grid, mirror the 'U' shape horizontally. 
:: def cbjacfcbbehieaebbdfbadcbbgaefdce(I):
  h, w = height(I), width(I)
  O = canvas(0, (h, w))  # Empty canvas
  O = fill(O, 3, {(i, w-3) for i in range(h-4, h-1)}) # Right vertical line of U
  O = fill(O, 3, {(h-2, j) for j in range(w-6, w-3)}) # Horizontal line of U
  O = fill(O, 3, {(h-4, w-5), (h-3, w-5), (h-2, w-5)}) # Left vertical line of U
  O = fill(O, 3, {(h-4, j) for j in range(w-8, w-5)}) # Connecting line
  O = fill(O, 3, {(i, j) for i in range(h-5, h-2) for j in range(w-6, w-3)}) # 3x3 Square
  if h > w: O = rot90(O) # Rotate if necessary
  return O
 
42.0, tensor(0.0597), Description: 
Create a grid of the same size as the input. Place a 3x3 block of '3's in the bottom right corner. If the input grid is taller than it is wide, place a horizontal line of '1's two rows from the bottom and four columns from the right. If the input grid is wider than it is tall, place a vertical line of '1's six rows from the bottom and two columns from the right. Then, place a 'U' shape two rows from the bottom and four columns from the right if the grid is taller than it is wide, or six rows from the bottom and two columns from the right if the grid is wider than it is tall. If the '3' shape is placed on the right side of the grid, mirror the 'U' shape horizontally. 
:: def jgcdecddjbabeegbaceifffccefadjgj(I):
  h, w = height(I), width(I)
  corner = (h-1, w-1)  # Find bottom-right corner
  O = canvas(0, (h, w))  # Create canvas
  O = fill(O, 1, {subtract(corner, (1, i)) for i in range(3)})  # Horizontal line of U 
  O = fill(O, 1, {subtract(corner, (i, 3)) for i in range(2)})  # Top part of right line of U
  O = fill(O, 1, {subtract(corner, (0, 5)), subtract(corner, (1, 5))}) # Bottom part of right line of U
  O = fill(O, 3, {subtract(corner, (3, i)) for i in range(4, 7)}) # Connecting line
  O = fill(O, 3, {subtract(corner, (i, j)) for i in range(2, 5) for j in range(5, 8)}) # 3x3 Square
  if h > w: O = rot90(O) # Rotate if needed
  return O
 
58.0, tensor(0.0139), Description: 
Create a grid of the same size as the input. For each pixel in the input grid, apply a transformation rule based on its location and value. The example rule provided shifts the pixel to the opposite row (mirroring vertically) while keeping the same column. You would need to add more rules to handle other pixel values and locations to complete the pattern. 
:: def daejedcdaedaeaiejbaejaebdabfefhc(I):
  h, w = shape(I)
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      # Apply transformation rules based on pixel location and value
      if i < h // 2 and j < w // 2:
        O = paint(O, {(I[i][j], (h - i - 1, j))})  # Example rule
      # ... other rules ...

  return O
 
42.0, tensor(1.7631), Description: 
Create a grid of the same size as the input. Draw a vertical line of '1's down the center column of the grid. You would need to add more line/shape drawings to complete the pattern based on the specific input characteristics. 
:: def ajeafhfdcbfcebgdjdfifbghdaehdahb(I):
  h, w = shape(I)
  O = canvas(0, (h, w))

  # Draw lines and shapes based on input characteristics
  center_j = w // 2
  O = paint(O, recolor(1, connect((0, center_j), (h - 1, center_j))))  # Example
  # ... other line/shape drawings ...

  return O
 
33.333333333333336, tensor(0.0121), Description: 
Create a grid of the same size as the input. If the input grid is 15x15, place a copy of the largest '3' object three times, shifted 5 rows down for each copy. If the input grid is 15x9, shift the largest '3' object 4 rows down and 3 columns to the right. If the input grid is 9x9, shift the largest '3' object 2 rows down and 3 columns to the right. If there is no '3' object, do not place any '3' objects. Then, place a '1' object based on the grid size:
- If the grid is 15x15, place a '1' object with a diagonal line from (1,11) to (2,11), a horizontal line from (2,12) to (2,13), and a vertical line from (13,1) to (13,3).
- If the grid is 15x9, place a '1' object with a diagonal line from (8, 6) to (10, 6) and a horizontal line from (10, 7) to (10, 8).
- If the grid is 9x9, place a '1' object with a vertical line from (6, 1) to (7, 1) and a horizontal line from (7, 1) to (7, 2). 
:: def iebdahffabhdehddiigceifjeagaadae(I):
  h, w = shape(I)
  threes = colorfilter(objects(I, True, False, True), 3)
  largest_three = argmax(threes, size) if threes else frozenset()

  if largest_three:
    if h == 15 and w == 15:
      transformed_three =  frozenset().union(*[shift(largest_three, (i * 5, 0)) for i in range(3)]) 
    else:
      row_offset = 4 if h == 15 else 2
      col_offset = 7 if h == 15 else 4
      transformed_three = shift(largest_three, (row_offset, col_offset - width(largest_three) // 2))
  else:
    transformed_three = frozenset()

  one_pattern = {
    (15, 15): recolor(1, frozenset().union(connect((1,11),(2,11)), connect((2,12),(2,13)), connect((13,1),(13,3)))),
    (15, 9):  recolor(1, frozenset().union(connect((8, 6), (10, 6)), connect((10, 7), (10, 8)))),
    (9, 9):   recolor(1, frozenset().union({(6, 1)}, {(7, 1)}, {(7, 2)}))
  }[(h, w)]

  O = paint(canvas(0, (h, w)), transformed_three | one_pattern)
  return O
 
135.33333333333334, tensor(0.0116), Description:
Copy the input grid and divide it into four quadrants. Mirror the top-left quadrant horizontally and vertically, then shift it to the bottom-right quadrant. Mirror the top-right quadrant horizontally, then shift it to the bottom-left quadrant. Mirror the bottom-left quadrant vertically, then shift it to the top-right quadrant. Leave the bottom-right quadrant unchanged. Finally, draw a vertical line of '1's from the middle of the top quarter of the grid to the middle of the bottom quarter of the grid. 
:: def fefejichbhgiebffbdciieejafbbabej(I):
  h, w = shape(I)
  O = canvas(0, (h, w))

  # Extract and transform quadrants
  q1 = asobject(crop(I, (0, 0), (h // 2, w // 2)))
  q2 = asobject(crop(I, (0, w // 2), (h // 2, w // 2)))
  q3 = asobject(crop(I, (h // 2, 0), (h // 2, w // 2)))
  q4 = asobject(crop(I, (h // 2, w // 2), (h // 2, w // 2)))

  q1 = shift(hmirror(vmirror(q1)), (h // 2, w // 2))
  q2 = shift(hmirror(q2), (h // 2, 0))
  q3 = shift(vmirror(q3), (0, w // 2))

  # Paint transformed quadrants
  O = paint(O, q1)
  O = paint(O, q2)
  O = paint(O, q3)
  O = paint(O, q4)

  # Draw vertical line based on input dimensions
  start_row = h // 4 if h > 8 else h // 2 - 1
  end_row = h - start_row - (1 if h % 2 == 0 else 0)
  center_j = w // 2
  O = paint(O, recolor(1, connect((start_row, center_j), (end_row, center_j))))

  return O
 
34.333333333333336, tensor(0.0151), Description: 
Create a grid of the same size as the input. If the input grid is 15x15, place a copy of the largest '3' object three times, shifted 5 rows down for each copy. If the input grid is 15x9, shift the largest '3' object 4 rows down and 3 columns to the right. If the input grid is 9x9, shift the largest '3' object 2 rows down and 3 columns to the right. If there is no '3' object, do not place any '3' objects. Then, place a '1' object based on the grid size:
- If the grid is 15x15, place a '1' object with a diagonal line from (1,11) to (2,11), a horizontal line from (2,12) to (2,13), and a vertical line from (13,1) to (13,3), and additional lines from (13, 3) to (14, 3), (1, 11) to (1, 12), and (1, 12) to (2, 12).
- If the grid is 15x9, place a '1' object with a diagonal line from (8, 6) to (10, 6) and a horizontal line from (10, 7) to (10, 8), and additional lines from (8, 6) to (8, 7), and (8, 7) to (9, 7).
- If the grid is 9x9, place a '1' object with a vertical line from (6, 1) to (7, 1) and a horizontal line from (7, 1) to (7, 2), and additional lines from (6, 1) to (6, 2), and (6, 2) to (7, 2). 
:: def eibebcibhabdecbeaabgahabejafhdbi(I):
  h, w = shape(I)
  threes = colorfilter(objects(I, True, False, True), 3)
  largest_three = argmax(threes, size) if threes else frozenset()

  transformed_three = branch(
      h == 15 and w == 15,
      frozenset().union(*[shift(largest_three, (i * 5, 0)) for i in range(3)]),
      shift(largest_three, ((4 if h == 15 else 2), (7 if h == 15 else 4) - width(largest_three) // 2))
  )

  one_pattern = {
      (15, 15): recolor(1, frozenset().union(
          connect((1, 11), (2, 11)), 
          connect((2, 12), (2, 13)), 
          connect((13, 1), (13, 3)),
          connect((13, 3), (14, 3)),
          connect((1, 11), (1, 12)),
          connect((1, 12), (2, 12))
      )),
      (15, 9):  recolor(1, frozenset().union(
          connect((8, 6), (10, 6)), 
          connect((10, 7), (10, 8)),
          connect((8, 6), (8, 7)),
          connect((8, 7), (9, 7))
      )),
      (9, 9):   recolor(1, frozenset().union(
          {(6, 1)}, 
          {(7, 1)}, 
          {(7, 2)},
          {(6, 1), (6, 2)},
          {(6, 2), (7, 2)}
      ))
  }[(h, w)]

  O = paint(canvas(0, (h, w)), transformed_three | one_pattern)
  return O
 
