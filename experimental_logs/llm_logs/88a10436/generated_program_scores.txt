12.333333333333334, tensor(0.8464), Description: Reflects the input grid diagonally using object manipulation. 
:: def dfecdhbahfgfebdibgcjjabbjbhddgff(I):
  """ Reflects the input grid diagonally using object manipulation."""
  objs = objects(I, False, False, False) 
  reflected_objs = frozenset({frozenset({(v, (j, i)) for v, (i, j) in obj}) for obj in objs})
  O = paint(canvas(ZERO, shape(I)), merge(reflected_objs)) 
  return O
 
28.333333333333332, tensor(0.9718), Description: Reflects the input grid diagonally using grid transformations. 
:: def fccgehddddaeecfjiifeigdcccjbiaic(I):
  """ Diagonal reflection using grid transformations. """
  return dmirror(I)
 
20.0, tensor(0.1176), Description: Reflects the grid diagonally using a combination of rotations. 
:: def hdcighdhchjgedajbaabbedchhgfdehf(I):
    """ Reflects the grid diagonally using a combination of rotations. """
    return rot270(hmirror(rot90(I)))
 
35.0, tensor(0.5334), Description: Reflects the input grid diagonally by individually mirroring and transposing. 
:: def acjhbachjbhcebbfbbdjbficejfeiegi(I):
    """ Diagonal reflection by individually mirroring and transposing. """
    return dmirror(vmirror(I)) 
 
17.666666666666668, tensor(0.0074), Description: Move the largest colored shape to the center of the grid. If the grid is larger than 7x7, move it to the center square. Otherwise, move it to the center square of the top row. 
:: def dgfgcfbjeicdegieiafeehhedgjeabfj(I):
  objs = objects(I, False, True, True)
  target_loc = (5, 5) if len(I) > 7 else (5, 1) 
  moving_obj = argmax(objs, size) 
  offset = subtract(target_loc, ulcorner(moving_obj))
  moved_obj = shift(moving_obj, offset)
  O = paint(cover(I, moving_obj), moved_obj)
  return O 
 
14.666666666666666, tensor(0.0073), Description: Move all colored shapes to the 5th row, keeping their original columns. If the shape is green, move it up one square. 
:: def bhdgjcbehfeaedhdjcgebciedfcfjcaf(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    up_offset = (1,0) if color(obj) == 3 else (0,0)
    if uppermost(obj) < 5:
      offset = subtract((5, leftmost(obj)), ulcorner(obj))
      I = paint(cover(I, obj), shift(obj, add(offset, up_offset)))
  return I
 
14.333333333333334, tensor(0.0076), Description: Move all colored shapes that are larger than 1x1 to the 5th row, keeping their original columns. 
:: def aaedaejfgbfaejdhaifdecgdcadgdidf(I):
  target_row = 5
  objs = objects(I, False, True, True)
  for obj in objs:
    if uppermost(obj) < target_row and size(obj) > 1:
      offset = (target_row - uppermost(obj), 0)
      I = paint(cover(I, obj), shift(obj, offset))
  return I
 
17.0, tensor(0.0067), Description: Move all colored shapes that are taller than 1x1 and shorter than 4x1 to the center of the grid. If the grid is smaller than 8x8, move them to the center square of the top row. Otherwise, move them to the center square of the grid. 
:: def bhcibagecfdbedjejadedchiccdbihdg(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    h = height(obj)
    if  h > 1 and h < 4:
      target_loc = (5, 1) if width(I) < 8 else (5, 5)
      offset = subtract(target_loc, ulcorner(obj))
      I = paint(cover(I, obj), shift(obj, offset))
  return I
 
19.0, tensor(0.0082), Description: Move all colored shapes that are not gray to the center column. If the grid is larger than 7x7, move them to the 5th column. Otherwise, move them to the 1st column. 
:: def hdfccggcdfbcebdcacedeeeifffdebdf(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    if color(obj) != 5:
      target_col = 5 if width(I) > 7 else 1
      offset = (0, target_col - leftmost(obj))
      I = paint(cover(I, obj), shift(obj, offset))
  return I
 
11.0, tensor(0.5930), Description: For each colored shape in the input grid, shift it down by a number of squares equal to its width.  The output grid will have the same shapes as the input, but shifted down. 
:: def dbbabccaigbdeeaajjefjejcdhdaddib(I):
    x1 = objects(I, F, F, T) # Extract non-background objects
    x2 = apply(lambda o: (o, width(o)), x1) # Pair each object with its width
    x3 = apply(lambda x: shift(x[0], (x[1], 0)), x2) # Shift each object down by its width
    O = I # Initialize output grid
    for obj in x3:
        O = paint(O, obj) # Paint each shifted object onto the output grid
    return O
 
17.333333333333332, tensor(0.3567), Description: Create an empty canvas with the same size and shape as the input grid, using the most common color in the input grid. Then, for each colored shape in the input grid, shift it to the right by a number of squares equal to its width and paint it onto the canvas. The output grid will have the same shapes as the input, but shifted to the right. 
:: def jbaibbgjaaadeadcagficaaabgecegei(I):
    O = canvas(mostcolor(I), shape(I)) # Create empty canvas
    for obj in objects(I, F, F, T):
        O = paint(O, shift(obj, (width(obj), 0))) # Paint shifted objects onto canvas
    return O
 
7.333333333333333, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def iecbdegdbehjeefajdbedbbbcchaadde(I):
    objs = objects(I, False, True, True)
    bg = mostcolor(I)
    for obj in objs:
        shifted_obj = obj
        for i in range(height(I)):
            down_shift = shift(shifted_obj, DOWN)
            if len(intersection(toindices(down_shift), asindices(I))) != len(down_shift) or any(index(I, loc) != bg for loc in toindices(down_shift)):
                break
            shifted_obj = down_shift
        I = paint(cover(I, obj), shifted_obj)
    O = I
    return O
 
9.333333333333334, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def hijeeadaedafeefeicjbcgbfbefacecg(I):
    objs = order(objects(I, False, True, True), lambda obj: uppermost(obj))
    bg = mostcolor(I)
    for obj in objs:
        temp_grid = I
        for i in range(height(I)):
            temp_grid = paint(cover(temp_grid, obj), shift(obj, (i, 0)))
            if any(index(temp_grid, (row, col)) != bg for row, col in toindices(shift(obj, (i + 1, 0)))):
                break
        I = temp_grid
    O = I
    return O 
 
15.0, tensor(0.0122), Description: Move each colored shape down one square. The output grid will have the same shapes as the input, but shifted down by one square. 
:: def cifdiaejfdbhegeajhgbddfgfajdacbj(I):
  objs = objects(I, F, T, T)
  g = I
  for i in range(height(I)):
    for obj in objs:
      g = paint(cover(g, obj), shift(obj, DOWN))
  O = g  
  return O
 
18.333333333333332, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def hjfaeggagagdejaaigdifdajgbdcbgic(I):
    objs = objects(I, F, T, T)
    h = height(I)
    for obj in objs:
        down_shift = shift(obj, (h, 0))
        for i in range(h):
            if len(intersection(toindices(shift(down_shift, (-i, 0))), asindices(I))) == len(obj):
                I = paint(cover(I, obj), shift(down_shift, (-i, 0)))
                break
    O = I
    return O
 
18.0, tensor(0.0148), Description: Move all the colored squares down one space, but only if the square below it is the background color. The output grid will have the same shapes as the input, but shifted down as far as possible without overlapping any other colored shapes or going outside the grid. 
:: def ifeiabbegcbeebibbcfcbaabdfhacgad(I):
    moved = False
    while not moved:
        moved = True
        for j in range(height(I) - 1, 0, -1):
            for i in range(width(I)):
                if index(I, (j, i)) == mostcolor(I) and index(I, (j - 1, i)) != mostcolor(I):
                    I = paint(cover(I, {(index(I, (j - 1, i)), (j - 1, i))}), {(index(I, (j - 1, i)), (j, i))})
                    moved = False
    O = I
    return O
 
11.0, tensor(0.0058), Description: Mirror each colored shape horizontally and then shift it to the right by half the width of the grid. The output grid will have the same shapes as the input, but mirrored horizontally and shifted to the right. 
:: def ihafbccajadfegadachccchffjhdcccd(I):
  objs = fgpartition(I)
  w = width(I)
  mirrored_objs = mapply(lambda obj: shift(hmirror(shift(obj, (0, -w // 2))), (0, w // 2)), objs)
  O = paint(canvas(mostcolor(I), shape(I)), mirrored_objs)
  return O
 
12.333333333333334, tensor(1.9836), Description: The output grid is a mirror image of the input grid, but only the right half is mirrored. The left half of the grid remains unchanged. 
:: def bhffeaegeacheccaiggfbacbjebdacbe(I):
    w = width(I)
    O = tuple(
        tuple(
            I[i][w - 1 - j] if j > w // 2 else I[i][j] 
            for j in range(w)
        ) 
        for i in range(height(I))
    )
    return O
 
10.666666666666666, tensor(0.0294), Description: The input grid is split vertically into two halves. The left half is kept as is, while the right half is mirrored horizontally and then concatenated with the left half. The output grid is a combination of the original left half and the mirrored right half. 
:: def fdhdiddbbcjaebjbaejfbaedjehaagfh(I):
    w = width(I)
    left = crop(I, (0, 0), (height(I), w // 2 + w % 2))
    right = crop(I, (0, w // 2), (height(I), w // 2))
    O = hconcat(left, hmirror(right))
    return O
 
19.0, tensor(0.0224), Description: The input grid is split vertically into two halves. The right half is mirrored horizontally, and then the mirrored right half is concatenated with the original left half. The output grid is a combination of the mirrored right half and the original left half. 
:: def agicdcafcijjeficbbfbcjicadeacdce(I):
  """
  Reflects the input grid using horizontal splitting and concatenation.
  """
  mid = width(I) // 2 
  left = crop(I, (0,0), (height(I), mid))
  right = crop(I, (0,mid), (height(I), width(I)-mid))
  return hconcat(hmirror(right), left)
 
6.333333333333333, tensor(0.3410), Description: Reflects the input grid horizontally by manipulating indices. 
:: def dafeiicccddbebcfjgjechgceacaddjd(I):
  """
  Reflects the input grid by manipulating indices.
  """
  indices = asindices(I)
  w = width(I)
  reflected_indices = frozenset({(i, (w - 1) - j) for i, j in indices})
  return paint(canvas(ZERO, shape(I)), toobject(reflected_indices, I))
 
13.0, tensor(0.0065), Description: Move all colored shapes that are larger than 1x1 to the bottom of the grid, keeping their original columns. If the grid is larger than 6x6, move them to the center square. Otherwise, move them to the center square of the right column. 
:: def cehceeegfcgfehieaahgdcccacfgfdcb(I):
  target_loc = (5, 5) if width(I) > 6 else (6, 1) 
  objs = objects(I, False, True, True)
  for obj in objs:
    if size(obj) > 1 and uppermost(obj) < target_loc[0]: 
      offset = subtract(target_loc, ulcorner(obj))
      I = paint(cover(I, obj), shift(obj, offset))
      target_loc = (target_loc[0] + 1, target_loc[1]) 
  return I
 
16.666666666666668, tensor(0.0085), Description: Move all colored shapes except the single gray square to the right of the gray square, keeping their original rows. The output grid will have the same shapes as the input, but shifted to the right of the gray square. 
:: def ehibacfddgdbehfdicbafjcbbaehaffg(I):
  fixed_obj = extract(objects(I, False, True, True), lambda obj: size(obj) == 1 and index(I, center(obj)) == 5)
  target_loc = add(ulcorner(fixed_obj), (1, 0)) 
  objs = objects(I, False, True, True)
  for obj in objs:
    if obj != fixed_obj:
      offset = subtract(target_loc, ulcorner(obj))
      I = paint(cover(I, obj), shift(obj, offset))
      target_loc = add(target_loc, (1, 0))
  return I
 
16.666666666666668, tensor(0.0065), Description: Move all colored shapes that are larger than 1x1 to the bottom of the grid, keeping their original columns. If the grid is larger than 6x6, move them to the center square. Otherwise, move them to the center square of the right column. 
:: def daaccjcjbcjaeajdjeghaaecbfjeajaf(I):
  target_col = 5 if width(I) > 6 else 1
  objs = objects(I, False, True, True)
  movable_objs = sfilter(objs, lambda obj: size(obj) > 1)
  for obj in movable_objs:
    target_row = uppermost(obj) + size(movable_objs) - 1 
    offset = (target_row - uppermost(obj), target_col - leftmost(obj))
    I = paint(cover(I, obj), shift(obj, offset))
  return I
 
11.0, tensor(0.0070), Description: Move all colored shapes that are larger than 1x1 to the 6th row if the grid is smaller than 8x8, otherwise move them to the 5th row, keeping their original columns. 
:: def fdjccdchcdfheegcacffifcecjjhfdcg(I):
  target_row =  6 if width(I) < 8 else 5
  objs = objects(I, False, True, True)
  for obj in objs:
    if size(obj) > 1:
      I = paint(I, shift(obj, (target_row - uppermost(obj), 0)))
  return I
 
9.0, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def dfddcbgjeebfeafhbaeebjbideiheabe(I):
  objs = objects(I, F, T, T)
  g = I
  for obj in objs:
    temp_grid = I
    for i in range(height(I)):
      temp_grid = paint(cover(temp_grid, obj), shift(obj, (i, 0)))
      if any(index(temp_grid, (row, col)) != mostcolor(I) for row, col in toindices(shift(obj, (i + 1, 0)))):
        break
    g = temp_grid
  O = g
  return O
 
13.0, tensor(1.9836), Description: The output grid is a mirror image of the input grid, but only the right half is mirrored. The left half of the grid remains unchanged. 
:: def fgfddaebabfeegfciebbbffaiccccffj(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if j >= w // 2:
        O = paint(O, {(I[i][w - 1 - j], (i, j))})
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
16.333333333333332, tensor(0.0294), Description: The input grid is split vertically into two halves. The left half is kept as is, while the right half is mirrored horizontally and then concatenated with the left half. The output grid is a combination of the original left half and the mirrored right half. 
:: def gfceadeeddbjehecbiajhhebdeagheei(I):
  h, w = shape(I)
  left_half = lefthalf(I)
  right_half = hmirror(left_half)
  return hconcat(left_half, right_half)
 
16.0, tensor(0.0195), Description: For each colored shape in the input grid, reflect it horizontally around its center. The output grid will have the same shapes as the input, but mirrored horizontally. 
:: def ccbfcheaggjcefbejffifhajhaddddie(I):
  """ 
  Reflects each object in the grid horizontally around its center.
  """
  O = I
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    O = paint(cover(O, obj), hmirror(shift(obj, (0, -leftmost(obj) - width(obj) // 2)))) 
  return O
 
17.333333333333332, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom left corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the top left corner of the grid. 
:: def fafeafdjgcahehejiccbafbbdgbfcafj(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    s = size(obj)
    if color(obj) != 0 and s > 1:
      target_row = 5 if s > 2 else 0
      target_col = 3 if s > 2 else 0
      offset = (target_row - uppermost(obj), target_col - leftmost(obj))
      I = paint(cover(I, obj), shift(obj, offset))
  return I
 
11.333333333333334, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom left corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the top left corner of the grid. 
:: def cgaddhehaacgejjcjgfaadjjdaabafae(I):
  for c in palette(I) - {0}:
    for obj in sizefilter(objects(I, False, True, True), c):
      s = size(obj)
      target_row = 5 if s > 2 else 0
      target_col = 3 if s > 2 else 0
      I = paint(cover(I, obj), shift(obj, (target_row - uppermost(obj), target_col - leftmost(obj))))
  return I
 
6.333333333333333, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def hffehgceeadfefjdajaccahefjcbaebf(I):
  h, w = shape(I)
  for obj in objects(I, False, True, True):
    if color(obj) != 0 and size(obj) > 1:
      target_row = (5 if len(obj) > 2 else h) - uppermost(obj)
      target_col = (3 if len(obj) > 2 else w) - leftmost(obj)
      I = paint(I, toobject(shift(toindices(obj), (target_row, target_col)), I))
  return I
 
18.333333333333332, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def fbfdebgbcjbeeefdaehedddbabgjjebh(I):
  g = I
  moved = True
  while moved: # Continue until no more movements are possible
    moved = False
    for obj in objects(g, False, True, True):
      if lowermost(obj) < height(I) - 1 and index(g, (lowermost(obj) + 1, leftmost(obj))) == mostcolor(g):
        g = paint(cover(g, obj), shift(obj, (1, 0)))
        moved = True # Flag that a movement happened 
  O = g
  return O
 
13.333333333333334, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def gbaadgbddbaaebdajjeddagcfcdhjbdd(I):
  g = I
  bottom_edge = {(i, 0) for i in range(height(I))} # Define the bottom edge of the grid
  for obj in objects(I, False, True, True):
    g = paint(cover(g, obj), shift(obj, gravitate(obj, bottom_edge))) # Move object towards the bottom edge
  O = g
  return O
 
8.666666666666666, tensor(0.0218), Description: Mirror each colored shape horizontally around its center. The output grid will have the same shapes as the input, but mirrored horizontally. 
:: def fbeedgjfebceeabjicdabigdffdaecac(I):
  objs = fgpartition(I)
  rm = rightmost(merge(objs)) - 1  # Find the mirroring axis
  mirrored_objs = mapply(
      lambda obj: shift(hmirror(shift(obj, (0, -rm))), (0, rm)), objs
  )
  O = paint(canvas(mostcolor(I), shape(I)), mirrored_objs)
  return O
 
12.0, tensor(1.9836), Description: The output grid is a mirror image of the input grid, but only the right half is mirrored. The left half of the grid remains unchanged. 
:: def efcbfiaecfdcejddihabhaejdjcgabba(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    for i in range(h):
      if index(I, (i, j)) != mostcolor(I):
        rm = rightmost(asobject(I)) - 1  # Mirroring axis
        mirror_j = rm - (j - rm) 
        O = paint(O, {(index(I, (i, j)), (i, mirror_j))})
  return O
 
61.333333333333336, tensor(0.0294), Description: The input grid is split vertically into two halves. The left half is kept as is, while the right half is mirrored horizontally and then concatenated with the left half. The output grid is a combination of the original left half and the mirrored right half. 
:: def abdcdcedcjedeaadjdbciadaidafciee(I):
  rm = rightmost(asobject(I))
  left_part = crop(I, (0, 0), (height(I), rm)) 
  right_part = hmirror(left_part)
  return hconcat(left_part, right_part)
 
11.0, tensor(0.0176), Description: For each colored shape in the input grid, mirror it vertically around its upper boundary. The output grid will have the same shapes as the input, but mirrored vertically. 
:: def ddabaeaidabeefceaieaajajbafgbfhc(I):
  """
  Mirrors each object downwards from its upper boundary.
  """
  O = I
  for obj in objects(I, False, False, True):
    shift_down = height(obj)
    O = paint(O, shift(obj, (shift_down, 0)))
  return O
 
10.666666666666666, tensor(1.5976), Description: For each colored shape in the input grid, create a new shape that is a vertical concatenation of the original shape with itself. Then, paint this new shape onto the output grid, using the background color of the original shape as the background color for the new shape. The output grid will have the same shapes as the input, but extended vertically by a factor of two. 
:: def cjgbbbfjdfdbefeabjidcaedebbgehfj(I):
  """
  Uses vertical concatenation to achieve reflection and extension.
  """
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    subgrid_obj = subgrid(obj, I)
    reflected_obj = vconcat(subgrid_obj, subgrid_obj)
    O = paint(O, toobject(backdrop(obj), reflected_obj))
  return O
 
17.0, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def eacgfdgafjcgecjcicdbbabbfeacebbb(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    s = size(obj)
    if s > 1:
      row_offset = 4 + (s > 2)
      col_offset = s - 1
      I = paint(cover(I, obj), shift(obj, (row_offset - uppermost(obj), col_offset - leftmost(obj))))
  return I
 
10.666666666666666, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def ddcadebgafceeehiaeagjgeijccghcah(I):
  def move_object(obj):
    s = size(obj)
    return shift(obj, (4 + (s > 2) - uppermost(obj), s - 1 - leftmost(obj))) if s > 1 else obj

  return paint(I, merge(apply(move_object, objects(I, False, True, True)))) 
 
7.333333333333333, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def ebdfddceeebceegjahfhcbfbjbfgbagb(I):
  def transform_object(obj):
    if size(obj) <= 1:
      return obj
    ul = ulcorner(obj)
    new_ul = (ul[0] + 4 + (size(obj) > 2), ul[1] + size(obj) - 1)
    return shift(obj, subtract(new_ul, ul))

  return paint(I, merge(apply(transform_object, objects(I, False, True, True))))
 
15.0, tensor(0.4156), Description: Move each colored shape down by a number of squares equal to its height. The output grid will have the same shapes as the input, but shifted down. 
:: def cdbejedbdfafebdfagaccabcfjcajhae(I):
    O = canvas(mostcolor(I), shape(I))
    for v, (i, j) in merge(objects(I, F, F, T)):
        O = paint(O, {(v, (i + height({(v, (i, j))}), j))})
    return O
 
17.333333333333332, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def ddfgadddbeabeaedifbegbgbgahgiaea(grid):
    h = height(grid)
    objs = objects(grid, False, True, True)
    for obj in objs:
        for i in range(h):
            shifted_obj = shift(obj, (i, 0))  # Shift object downwards
            if not any(0 <= x[0] < h and 0 <= x[1] < width(grid) and index(grid, x) != mostcolor(grid) for x in toindices(shifted_obj)):
                grid = paint(cover(grid, obj), shifted_obj) # If no overlap with existing objects, paint shifted object
                break  # Stop shifting once placed
    return grid
 
16.666666666666668, tensor(0.0164), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then concatenated with the original top-right quadrant. This creates a right half of the output grid. The left half of the input grid is kept as is. Finally, the left half and the right half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original left half and a vertically mirrored and extended right half. 
:: def dgcfcdcidjjcefibjbdecffdcehgccga(I):
  h, w = halve(shape(I)) # Find dimensions for splitting
  top_right = crop(I, (0, w), (h, w)) # Extract the top-right quadrant
  mirrored = vmirror(top_right) # Mirror it vertically
  bottom_right = crop(I, (h, w), (h, w)) # Extract the bottom-right quadrant (empty in this case)
  right_half = vconcat(top_right, mirrored) # Combine original and mirrored quadrants
  left_half = crop(I, (0, 0), (h * 2, w)) # Extract the left half of the input grid
  O = hconcat(left_half, right_half) # Concatenate to form the final output
  return O
 
13.0, tensor(0.0164), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then concatenated with the original top-right quadrant. This creates a right half of the output grid. The left half of the input grid is kept as is. Finally, the left half and the right half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original left half and a vertically mirrored and extended right half. 
:: def jgdeddddibdgeiecjdhehbcegjfhfebg(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w)) # Create an empty canvas
  for i in range(h // 2): # Iterate over rows of the top half 
    for j in range(w // 2, w): # Iterate over columns of the right half
      val = index(I, (i, j)) # Get the value at the current location
      O = paint(O, {(val, (i, j))}) # Paint the value at the original location
      O = paint(O, {(val, (h - i - 1, j))}) # Paint the value at the mirrored location
  return O
 
25.333333333333332, tensor(0.0311), Description: The input grid is split into four quadrants. The top half is mirrored vertically, and then concatenated with the original top half. This creates a top half of the output grid. The bottom half of the input grid is duplicated. Finally, the top half and the duplicated bottom half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original top half, its vertical mirror, and a duplicated bottom half. 
:: def hfjcahaefcedegjgbchedcbehciaefce(I):
  h, w = halve(shape(I))
  O = canvas(mostcolor(I), (h, w))
  top_half = crop(I, (0, 0), (h, w)) # Extract the top half
  mirrored_top = vmirror(top_half) # Mirror the top half vertically
  bottom_half = crop(I, (h, 0), (h, w)) # Extract the bottom half
  O = vconcat(top_half, mirrored_top) # Concatenate the top half and its mirror
  O = hconcat(O, vconcat(bottom_half, bottom_half)) # Concatenate with the duplicated bottom half
  return O
 
11.666666666666666, tensor(0.0168), Description: For each colored shape in the input grid, mirror it vertically around its center line. The output grid will have the same shapes as the input, but mirrored vertically. 
:: def ehceafcghbgbeeaaaiiccbajidaaecda(I):
  """
  Mirrors each object downwards from its center line.
  """
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    for v, (i, j) in obj:
      center_i = int(centerofmass(obj)[0])
      target_i = center_i + (center_i - i)
      O = fill(O, v, {(target_i, j)})
  return O
 
8.666666666666666, tensor(1.9828), Description: The input grid is split horizontally into two halves. The top half is mirrored vertically, and then concatenated with the original top half. If the input grid has an odd number of rows, the middle row is added to the bottom of the output grid. The output grid is essentially a combination of the original top half, its vertical mirror, and potentially the middle row of the input grid. 
:: def jdjdefcdedgeecigaafeiafbdcfiebhd(I):
  """
  Uses upper and lower halves to achieve the mirroring effect.
  """
  H = height(I)
  O = vconcat(tophalf(I), vmirror(tophalf(I)))
  if even(H):
    return O
  else:
    return vconcat(O, I[H//2:(H//2)+1])
 
13.0, tensor(0.0226), Description: The input grid is mirrored vertically around its center line. The output grid will have the same shapes as the input, but mirrored vertically. 
:: def gccjcjdjadadefdbabeachcdfcbbgbda(I):
  """
  Uses cell-by-cell mirroring based on the grid's center line.
  """
  H, W = shape(I)
  O = canvas(mostcolor(I), (H, W))
  for i in range(H):
    for j in range(W):
      if i <= H//2:
        O = fill(O, index(I, (i, j)), {(i, j)})
      else:
        target_i = H - i - 1
        O = fill(O, index(I, (target_i, j)), {(i, j)})
  return O
 
17.666666666666668, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def bcigdfgghgcbeaaiafdeefijedcdddjg(I):
  for obj in objects(I, False, True, True):
    h = height(obj)
    w = width(obj)
    if size(obj) > 1:
      I = paint(cover(I, obj), shift(obj, (4 + (size(obj) > 2) - uppermost(obj), w - 1 - leftmost(obj))))
  return I
 
17.666666666666668, tensor(0.0075), Description: Move all colored shapes that are larger than 1x1 to the bottom right corner of the grid. If the shape is larger than 2x2, move it to the center square of the grid. Otherwise, move it to the bottom right corner of the grid. 
:: def ffdjaedabjbcecadjcedbafecicdfdeb(I):
  shifted_objs = set()
  for obj in objects(I, False, True, True):
    h = height(obj)
    w = width(obj)
    if size(obj) > 1:
      shifted_objs.add(shift(obj, (4 + (size(obj) > 2) - uppermost(obj), w - 1 - leftmost(obj))))
  return paint(cover(I, merge(objects(I, False, True, True))), merge(shifted_objs))
 
6.333333333333333, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def fghcacbacfddehecbdbhecfahdaddfdb(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    for i in range(height(I)):
      if len(intersection(toindices(shift(obj, (i + 1, 0))), asindices(I))) == 0:
        obj = shift(obj, (1, 0))
      else:
        break
      I = paint(cover(I, obj), obj)
  O = I
  return O
 
10.666666666666666, tensor(0.0164), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then concatenated with the original top-right quadrant. This creates a right half of the output grid. The left half of the input grid is kept as is. Finally, the left half and the right half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original left half and a vertically mirrored and extended right half. 
:: def gbcaefbfjeadebdgahfddajafchbcgce(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w)) # Create an empty canvas
  for i in range(h // 2): # Iterate over rows of the top half 
    for j in range(w // 2, w): # Iterate over columns of the right half
      val = index(I, (i, j)) # Get the value at the current location
      O = paint(O, {(val, (i, j))}) # Paint the value at the original location
      O = paint(O, {(val, (h - i - 1, j))}) # Paint the value at the mirrored location
  for i in range(h // 2, h): # Iterate over rows of the bottom half
    for j in range(w // 2): # Iterate over columns of the left half
      val = index(I, (i, j))
      O = paint(O, {(val, (i, j))})
  return O
 
18.666666666666668, tensor(0.0104), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored horizontally and then rotated 180 degrees. This mirrored and rotated quadrant is then placed in the bottom-left quadrant of the output grid. The top-left and bottom-right quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left and bottom-right quadrants, and a mirrored and rotated top-right quadrant in the bottom-left position. 
:: def iagcbdejbaffeecdjjecahcfjdhbedfe(I):
  h, w = halve(shape(I))
  top_right = crop(I, (0, w), (h, w)) # Extract the top-right quadrant
  bottom_left =  rot180(hmirror(top_right)) # Mirror and rotate the quadrant
  O = hconcat(crop(I, (0, 0), (h, w)), top_right) # Construct the top half of the output grid
  O = vconcat(O, hconcat(bottom_left, crop(I, (h, 0), (h, w)))) # Construct the complete output grid
  return O
 
8.0, tensor(0.0164), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then concatenated with the original top-right quadrant. This creates a right half of the output grid. The left half of the input grid is kept as is. Finally, the left half and the right half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original left half and a vertically mirrored and extended right half. 
:: def fcicdfbhafdaehfaiaebdaciaafffjab(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w)) # Create an empty canvas
  for i, j in asindices(I):
    if i < h // 2 and j >= w // 2:
      O = paint(O, {(index(I, (i, j)), (i, j))})
      O = paint(O, {(index(I, (i, j)), (h - i - 1, j))})
    else:
      O = paint(O, {(index(I, (i, j)), (i, j))})
  return O
 
8.666666666666666, tensor(0.0106), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then the mirrored quadrant is placed in the bottom-right quadrant of the output grid. The top-left and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left and bottom-left quadrants, and a mirrored top-right quadrant in the bottom-right position. 
:: def hifddhbghfjaebabjeccaahhdcfdhifc(I):
  h, w = shape(I)
  O = I
  for i in range(h // 2):
    for j in range(w // 2, w):
      O = paint(O, {(index(I, (i, j)), (h - i - 1, j))})
  return O
 
19.0, tensor(0.0083), Description: Move each colored shape to the bottom right corner of the grid. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def dfbbafbbceeaeifcihfefcjedbcffdcd(I):
  shifted_objs = frozenset()
  for obj in objects(I, False, True, True):
    offset = (height(I) - 1 - lowermost(obj), width(I) - 1 - rightmost(obj))
    shifted_objs = insert(shift(obj, offset), shifted_objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
 
11.333333333333334, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def ehfjbiabdajjegbjbacafjeiafbidbba(I):
  objs = order(objects(I, False, True, True), lambda obj: uppermost(obj))
  O = I
  for obj in objs:
    for i in range(height(I)):
      if any(index(O, (row, col)) != mostcolor(I) for row, col in toindices(shift(obj, (i, 0)))):
        O = paint(cover(O, shift(obj, (i - 1, 0))), shift(obj, (i - 1, 0)))
        break
  return O 
 
11.333333333333334, tensor(0.0107), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def gcaaicaahcefecaiidbdjccefaegheia(I):
  objs = order(objects(I, False, True, True), lambda obj: uppermost(obj))
  bg = mostcolor(I)
  g = I
  for obj in objs:
    shifted_obj = shift(obj, (height(I), 0))
    for i in range(height(I)):
      if not any(index(g, (row, col)) != bg for row, col in toindices(shift(shifted_obj, (-i, 0)))):
        g = paint(cover(g, shift(shifted_obj, (-i + 1, 0))), shift(shifted_obj, (-i, 0)))
        break
  O = g
  return O
 
19.666666666666668, tensor(0.0182), Description: The input grid is split into four quadrants. The top-right quadrant is mirrored vertically, and then concatenated with the original top-right quadrant. This creates a right half of the output grid. The bottom-left quadrant is mirrored vertically, and then concatenated with the original bottom-left quadrant. This creates a left half of the output grid. Finally, the left half and the right half are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and their vertical mirrors. 
:: def ddcbeafbeefbehhajbhffahcachfdehj(I):
  h, w = shape(I)
  tl = crop(I, (0, 0), (h // 2, w // 2))
  tr = crop(I, (0, w // 2), (h // 2, w // 2))
  bl = crop(I, (h // 2, 0), (h // 2, w // 2))
  br = crop(I, (h // 2, w // 2), (h // 2, w // 2))
  O = hconcat(vconcat(tl, vmirror(tr)), vconcat(bl, br))
  return O
 
9.0, tensor(0.0097), Description: The input grid is split into four quadrants. The top-right quadrant is moved to the bottom-left quadrant of the output grid. The top-left and bottom-right quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left and bottom-right quadrants, and the top-right quadrant moved to the bottom-left position. 
:: def ddegffefdajdeeceihbadfcjafcdgieb(I):
  h, w = shape(I)
  O = I
  for i in range(h // 2):
    for j in range(w // 2, w):
      O = paint(O, {(index(I, (i, j)), (h // 2 + i, j - w // 2))})
  return O
 
11.666666666666666, tensor(0.0311), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is mirrored vertically and then concatenated with the top half. The output grid is essentially a combination of the original top half and the mirrored bottom half. 
:: def bedhhihgiffieidhaidjheajadfgedcd(I):
  """
  Reflects objects downwards from the middle row using shifting and mirroring.
  """
  H = height(I)
  top_half = I[:H // 2]
  bottom_half = I[H // 2:]
  reflected_bottom = vmirror(bottom_half)
  return vconcat(top_half, reflected_bottom)
 
11.333333333333334, tensor(0.0311), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is mirrored vertically and then concatenated with the top half. The output grid is essentially a combination of the original top half and the mirrored bottom half. 
:: def cbgideccbdcjejhdjbbjcaiafejdicec(I):
  """
  Reflects objects downwards using object manipulation and shifting.
  """
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    if uppermost(obj) >= height(I) // 2:
      mirrored = vmirror(shift(obj, (height(I) - 1 - 2 * uppermost(obj), 0)))
      O = paint(O, mirrored)
    else:
      O = paint(O, obj)
  return O
 
15.333333333333334, tensor(0.0226), Description: The input grid is mirrored vertically around its center line. The output grid will have the same shapes as the input, but mirrored vertically. 
:: def dbhbiaahfadeeaccbgcihddfehcbcbda(I):
  """
  Reflects objects downwards by manipulating indices.
  """
  H = height(I)
  W = width(I)
  O = canvas(mostcolor(I), shape(I))
  for i in range(H):
    for j in range(W):
      if i < H // 2:
        O = paint(O, {(I[i][j], (i,j))})
      else:
        O = paint(O, {(I[i][j], (H - i - 1, j))})
  return O
 
11.666666666666666, tensor(0.0311), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is mirrored vertically and then concatenated with the top half. The output grid is essentially a combination of the original top half and the mirrored bottom half. 
:: def fbagefffieccefiajbbfcgcbdaedciej(I):
  """
  Reflects objects downwards using a single loop and conditional shifting.
  """
  H = height(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
      offset = (H - 1 - 2 * uppermost(obj), 0) if uppermost(obj) >= H // 2 else (0, 0)
      O = paint(O, shift(obj, offset))
  return O
 
14.333333333333334, tensor(0.0059), Description: Move all colored shapes to the bottom right corner of the grid, stacking them vertically. The shapes should be ordered from bottom to top based on their lowermost row. The output grid will have the same shapes as the input, but shifted to the bottom right corner and stacked vertically. 
:: def difgfaaibfijeddgafddjecebefigead(I):
  objs = objects(I, False, True, True)
  h, w = shape(I)
  painted = canvas(mostcolor(I), (h, w))
  current_height = h - 1
  for obj in sorted(objs, key=lambda obj: lowermost(obj), reverse=True):
    obj_h, obj_w = shape(obj)
    painted = paint(painted, shift(obj, (current_height - (obj_h - 1), w - (obj_w))))
    current_height -= obj_h
  return painted 
 
19.0, tensor(0.0059), Description: Move all colored shapes to the bottom right corner of the grid, stacking them vertically. The shapes should be ordered from bottom to top based on their lowermost row. The output grid will have the same shapes as the input, but shifted to the bottom right corner and stacked vertically. 
:: def gfdebaaagdhaefdbifddfaigbgbedfah(I):
  def align_bottom_right(obj):
    return shift(obj, subtract((height(I) - 1, width(I) - 1), lrcorner(obj)))

  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(apply(align_bottom_right, sorted(objects(I, False, True, True), key=lowermost, reverse=True)))
  )
 
16.666666666666668, tensor(0.0077), Description: Move each colored shape to the bottom row of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def icabchebefhdeajaafcdfgeecfefadcb(I):
  objs = objects(I, False, False, True) 
  bg = mostcolor(I)
  moved_objs = frozenset(shift(obj, (height(I) - height(obj), 0)) for obj in objs)
  O = canvas(bg, shape(I))
  for obj in moved_objs:
    O = paint(O, obj)
  return O
 
16.666666666666668, tensor(0.0081), Description: Move each colored shape to the bottom of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def gefgdbhaagehejfdbejcbecbaaieeagd(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    top_row = min(i for i, j in toindices(obj))
    offset = height(I) - height(obj) - top_row
    O = paint(O, shift(obj, (offset, 0)))
  return O
 
11.0, tensor(0.0097), Description: The input grid is split into four quadrants. The top-right quadrant is moved to the bottom-left quadrant of the output grid. The top-left and bottom-right quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left and bottom-right quadrants, and the top-right quadrant moved to the bottom-left position. 
:: def iabfeifeecgceeddahfajjbjcdeefiac(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h // 2):
    for j in range(w // 2, w):
      O = paint(O, {(index(I, (i, j)), (i, j))})
      O = paint(O, {(index(I, (i, j)), (i + h // 2, j - w // 2))})
  return O
 
11.333333333333334, tensor(0.0128), Description: For each colored shape in the input grid, duplicate it and stack the duplicate directly below the original shape. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def hbfbbbaiagfjebcfiefafgjbhdbccgbb(I):
    """
    Duplicates and vertically stacks non-background objects.
    """
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    O = I
    for obj in objs:
        h = height(obj)
        O = paint(O, shift(obj, (h,0)))
    return O
 
11.333333333333334, tensor(0.0128), Description: For each colored shape in the input grid, duplicate it and stack the duplicate directly below the original shape. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def ddbbiedbcjdbeiaajgcghiabggffdabc(I):
  """
  Constructs output by combining original and shifted objects.
  """
  objs = objects(I, T, F, T)
  shifted_objs = apply(lambda obj: shift(obj, (height(obj), 0)), objs)
  O = I
  for obj in objs:
    O = paint(O, obj)
  for obj in shifted_objs:
    O = paint(O, obj)
  return O
 
16.666666666666668, tensor(0.3300), Description: For each colored shape in the input grid, shift it to the right by a number of squares equal to its height divided by its width. The output grid will have the same shapes as the input, but shifted to the right. 
:: def ifjcchfcifdaecdcjfcacedefeajheai(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(
          apply(
              lambda obj: shift(obj, (size(obj)//width(obj), 0)), 
              objects(I, F, F, T)
          )
      )
  )
 
68.0, tensor(0.0794), Description: Move all colored shapes to the leftmost column, keeping their original rows. The output grid will have the same shapes as the input, but shifted to the leftmost column. Then, remove any empty columns from the grid. The output grid will be compressed horizontally, with all colored shapes aligned to the left edge. 
:: def cfcabjabhiifedafifbecgbcbbcfebeb(I):
  objs = objects(I, False, True, True) # Identify all non-background objects
  g = I
  for obj in objs:
    g = paint(cover(g, obj), shift(obj, (-leftmost(obj), 0))) # Shift each object to the leftmost column
  O = compress(g) # Remove empty columns to compress the grid
  return O
 
50.0, tensor(1.9821), Description: Compress the input grid horizontally by removing any empty columns. Then, concatenate the compressed grid with a blank canvas of the same height and the original width minus the width of the compressed grid. The blank canvas should be filled with the background color of the input grid. The output grid will have the same shapes as the input, but compressed horizontally and padded with the background color to restore the original width. 
:: def bjfiaeaeechjeaccjifbegagchaejfea(I):
  compressed_grid = compress(I)  # Compress the grid first
  O = hconcat(compressed_grid, canvas(mostcolor(I), (height(I), width(I) - width(compressed_grid)))) 
  # Concatenate with a blank canvas to restore original width
  return O
 
18.333333333333332, tensor(0.0175), Description: The input grid is split into four quadrants. The top-left quadrant is duplicated and concatenated with itself horizontally. The bottom-left quadrant is kept as is. The top-left quadrant is mirrored both vertically and horizontally, and then concatenated with the bottom-left quadrant horizontally. Finally, the two resulting halves are concatenated vertically to form the output grid. The output grid is essentially a combination of the original top-left quadrant, its mirrored counterpart, and the original bottom-left quadrant. 
:: def fdfecghjbjefebbhiacbjccchbdbjgeh(I):
  h, w = shape(I)
  tl = crop(I, (0, 0), (h//2, w//2)) # Top left quadrant
  return vconcat(
      hconcat(tl, tl), # Concatenate top left with itself horizontally
      hconcat(crop(I, (h//2, 0), (h//2, w//2)), hmirror(vmirror(tl))) # Concatenate bottom left with mirrored top left 
  )
 
10.333333333333334, tensor(0.0128), Description: For each colored shape in the input grid, duplicate it and stack the duplicate directly below the original shape. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def efeccggbbbaeecadjahdaddafeebggcc(I):
  """
  Iterates through objects, duplicates, and paints them below.
  """
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = paint(O, obj)
    O = paint(O, shift(obj, (height(obj), 0)))
  return O
 
12.666666666666666, tensor(0.0141), Description: For each colored shape in the input grid, stack the shape directly below itself. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def ddhdeccchfcfeceabjciaecfcjbajbgf(I):
  """
  Applies a stacking function to each cell based on its object.
  """
  objs = objects(I, T, F, T)
  def stack_cell(i, j):
    for obj in objs:
      if (i,j) in toindices(obj):
        return index(I, (i + height(obj), j))
    return index(I, (i,j))
  h, w = shape(I)
  return tuple(tuple(stack_cell(i, j) for j in range(w)) for i in range(h))
 
18.333333333333332, tensor(0.0075), Description: Move all colored shapes to the bottom row of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def bjeibdfbeidaedejigebeedfjefacged(I):
  objs = objects(I, False, True, True)
  for obj in objs:
    offset = (height(I) - 1 - uppermost(obj) - height(obj) + 1, 0)
    I = paint(cover(I, obj), shift(obj, offset))
  return I
 
15.0, tensor(0.0061), Description: Move all colored shapes to the bottom of the grid, stacking them vertically. The shapes should be ordered from bottom to top based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the bottom and stacked vertically. 
:: def faeddfjadcbaebdajecdjccceacghcfa(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  O = canvas(mostcolor(I), shape(I))
  current_height = height(I)
  for obj in objs:
    O = paint(O, shift(obj, (current_height - height(obj) - uppermost(obj), 0)))
    current_height -= height(obj)
  return O
 
18.0, tensor(0.0082), Description: Move all colored shapes to the bottom of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def gbgighidegebeibgicjgdjbebfecaegf(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    column = tuple(I[i][j] for i in range(height(I)))
    filtered_column = tuple(v for v in column if v != mostcolor(I))
    O = paint(O, {(v, (i + height(I) - len(filtered_column), j)) for i, v in enumerate(filtered_column)})
  return O
 
18.333333333333332, tensor(0.0071), Description: Move each colored shape to the bottom row of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def ahajfaddaadaejhcicafdiejdgiaaacj(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, F, F, T):
    O = paint(O, shift(obj, (height(I) - lowermost(obj) - 1, 0)))
  return O
 
14.666666666666666, tensor(0.0069), Description: Move each colored shape to the right by 5 squares and down by 1 square. The output grid will have the same shapes as the input, but shifted to the right and down. 
:: def eebeidebebjbebdeabiajacdiabceifb(I):
  objs = objects(I, False, True, True)  # Extract non-background objects
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w)) # Create a blank canvas
  for obj in objs:
    i, j = ulcorner(obj) # Get the upper-left corner of the object
    offset = (i + 1, j + 5)  # Calculate the offset (adjust for each pair)
    O = paint(O, shift(obj, offset))  # Paint the shifted object onto the canvas
  return O
 
17.0, tensor(0.0068), Description: Move each colored shape down one square and then to the right by 5 squares. The output grid will have the same shapes as the input, but shifted down and to the right. 
:: def hacegdejbjacecbgbdeecjcdacabidad(I):
    objs = objects(I, False, True, True)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))  # Create a blank canvas
    for obj in objs:
        offset = gravitate(obj, shift(obj, (1, 5))) # Calculate offset using gravitate
        O = paint(O, shift(obj, offset))  # Paint the shifted object
    return O
 
16.666666666666668, tensor(0.0069), Description: Move each colored shape to the right by 5 squares and down by 1 square. The output grid will have the same shapes as the input, but shifted to the right and down. 
:: def dabigdhhbbdaeecfbbdeebjecfcfjffd(I):
  objs = objects(I, F, T, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    center_obj = centerofmass(obj)
    target_pos = add(center_obj, (1, 5)) # Calculate the target position
    offset = subtract(target_pos, center_obj) # Calculate the offset
    O = paint(O, shift(obj, offset))
  return O
 
17.333333333333332, tensor(0.2089), Description: For each colored shape in the input grid, shift it to the right by a number of squares equal to its width plus 2. The output grid will have the same shapes as the input, but shifted to the right. 
:: def gdefdfjbfcdaeheajfaadfcfaabddbdc(I):
  objs = objects(I, F, T, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    h_obj, w_obj = shape(obj)  # Get height and width of the object
    offset = (h_obj // 2, w_obj + 2)  # Offset calculated using dimensions
    O = paint(O, shift(obj, offset))
  return O 
 
6.666666666666667, tensor(0.0109), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored diagonally (across the center), and then the mirrored quadrant is placed in the bottom-right quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a diagonally mirrored top-left quadrant in the bottom-right position. 
:: def abihddehgajieecaaejihcadgibdjcad(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))  # Create a canvas
  for i, j in asindices(I):
    if i < h // 2 and j < w // 2:
      O = paint(O, {(index(I, (i, j)), (i, j))})  # Keep original pixel
      O = paint(O, {(index(I, (i, j)), (h - i - 1, w - j - 1))})  # Paint mirrored pixel
    else:
      O = paint(O, {(index(I, (i, j)), (i, j))})  # Keep other pixels same
  return O
 
78.66666666666667, tensor(0.0143), Description: Duplicate the input grid vertically, stacking it on top of itself. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def baadfdcdbfdjehbfaacadaeeicjidfcg(I):
  """
  Iterates through grid indices and conditionally paints duplicates.
  """
  h, w = shape(I)
  O = canvas(mostcolor(I), (h * 2, w))
  for i in range(h):
    for j in range(w):
      v = index(I, (i, j))
      O = fill(O, v, {(i, j), (i + h, j)})
  return O
 
12.666666666666666, tensor(0.8453), Description: Reflects the input grid diagonally using object manipulation. 
:: def figjeeaifbjdefddaegechdeeadbecch(I):
  objs = objects(I, False, True, True)
  return paint(
      I,
      frozenset(
          (v, (height(I) - 1 - i, j)) 
          for obj in objs 
          for v, (i, j) in dmirror(obj)
      )
  )
 
10.333333333333334, tensor(0.8453), Description: Reflects the input grid diagonally using object manipulation. 
:: def dcggbfaaahhiefecicihaejdfebebffc(I):
    h = height(I)
    return paint(
        I, 
        mapply(
            lambda obj: shift(dmirror(obj), (h - 1 - 2 * uppermost(obj), 0)),
            objects(I, False, True, True)
        )
    )
 
12.0, tensor(0.0064), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def acegcgggcjabedibaebidicfhebaffej(I):
  objs = order(objects(I, False, False, True), lambda obj: uppermost(obj))
  acc = canvas(mostcolor(I), shape(I))
  h = 0
  for obj in objs:
    acc = paint(acc, shift(obj, (h, leftmost(obj))))
    h += height(obj)
  return acc
 
11.333333333333334, tensor(0.0061), Description: Move all colored shapes to the bottom of the grid, stacking them vertically. The shapes should be ordered from bottom to top based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the bottom and stacked vertically. 
:: def abfecffijfgfeiaijcdcabbdbfhffbee(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(
          apply(
              lambda x: shift(x[1], (sum(height(o) for o in x[0]), leftmost(x[1]))), 
              pair(
                  initset(tuple()),
                  objects(I, False, False, True)
              )
          )
      )
  )
 
13.666666666666666, tensor(0.0066), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def iciecbhedbfjebccjjbiegdfbgbbeigc(I):
  objs = objects(I, False, False, True)
  acc = canvas(mostcolor(I), shape(I))
  y = 0
  for obj in objs:
    x = leftmost(obj)
    for v, (i, j) in obj:
      acc = paint(acc, {(v, (i + y, j - x))})
    y += height(obj)
  return acc 
 
12.666666666666666, tensor(0.0084), Description: Move all colored shapes to the bottom right corner of the grid. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def bcbeihbehacbeegjbdijcffeaeeddfed(I):
  objs = objects(I, False, True, True)
  corner = (height(I)-1, width(I)-1)
  moved_objs = frozenset()
  for obj in objs:
    moved_objs = insert(shift(obj, subtract(corner, lrcorner(obj))), moved_objs)
  O = paint(I, merge(moved_objs))
  return O
 
19.0, tensor(0.0084), Description: Move all colored shapes to the bottom right corner of the grid. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def efbacbeeecdceijcjfiehceaaecgjajb(I):
  g = I
  for obj in objects(I, False, True, True):
    g = paint(cover(g, obj), shift(obj, subtract((height(I)-1, width(I)-1), lrcorner(obj)))) 
  O = g
  return O
 
15.0, tensor(0.0075), Description: The input grid is split into four quadrants. The top-left quadrant is copied to the output grid. The remaining quadrants are mirrored vertically, and the mirrored quadrants are placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left quadrant and its vertical mirrors. 
:: def ddeafaeiddgaeffdbaeacahedacddfaf(I):
  h, w = shape(I)
  O = paint(canvas(mostcolor(I), (h, w)), asobject(crop(I, (0, 0), (h//2, w//2))))
  for i in range(h // 2):
    for j in range(w):
      if j < w // 2 or index(I, (i, j)) != mostcolor(I):
        O = paint(O, {(index(I, (i, j)), (h - i - 1, j))})
  return O
 
13.0, tensor(0.0215), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The remaining quadrants are mirrored vertically, and the mirrored quadrants are placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-left quadrant and its vertical mirrors. 
:: def dabbcfcfjcdjefcdjaafbebifjbfdceb(I):
  h, w = shape(I)
  O = I  # Start with the original grid
  for i in range(h // 2):
    for j in range(w):
      if j < w // 2 or index(I, (i, j)) != mostcolor(I):
        O = paint(O, {(index(I, (i, j)), (h - i - 1, j))}) # Mirror specific cells
  return O
 
16.0, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def gcecafdiafcfefabidecbcjbeeehgeei(I):
  objs = objects(I, True, False, True) 
  O = I
  for obj in objs:
    for i in range(1, height(I)):
      shifted = shift(obj, (i, 0))
      if len(intersection(toindices(shifted), asindices(I))) != len(obj) or lowermost(shifted) >= height(I):
        O = paint(cover(O, obj), shift(obj, (i-1, 0)))
        break
  return O 
 
16.333333333333332, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def eaiaiidjeifceeehibjabjdbefjcdbdd(I):
  O = canvas(mostcolor(I), shape(I)) 
  for obj in sorted(objects(I, True, False, True), key=lambda obj: uppermost(obj)):
    shifted = obj
    for i in range(height(I)):
      new_shifted = shift(shifted, (1, 0))
      if len(intersection(toindices(new_shifted), asindices(I))) == len(obj) and lowermost(new_shifted) < height(I):
        shifted = new_shifted
      else:
        break
    O = paint(O, shifted)
  return O
 
68.66666666666667, tensor(1.2918), Description: For each colored square in the input grid, find the closest background square below it. Swap the colors of the colored square and the background square. The output grid will have the same shapes as the input, but with the colors of each colored square swapped with the color of the closest background square below it. 
:: def bcccabhhjabfecdciadibfadajeabbea(I):
  O = I
  for i in range(height(I) - 1, 0, -1):
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        for k in range(i + 1, height(I)):
          if index(I, (k, j)) == mostcolor(I) and (k == height(I) - 1 or index(I, (k + 1, j)) != mostcolor(I)):
            O = switch(O, index(O, (i, j)), index(O, (k, j)))
            break
  return O
 
68.0, tensor(1.2918), Description: For each colored square in the input grid, find the closest background square below it. Swap the colors of the colored square and the background square. The output grid will have the same shapes as the input, but with the colors of each colored square swapped with the color of the closest background square below it. 
:: def ibaabdeabadeedccicaafbabacbgdbei(I):
  O = I
  for obj in objects(I, True, False, True):
    bottom_indices = [(i, j) for i, j in toindices(obj) if i == lowermost(obj)]
    for i, j in bottom_indices:
      for k in range(i + 1, height(I)):
        if index(I, (k, j)) == mostcolor(I) and (k == height(I) - 1 or index(I, (k + 1, j)) != mostcolor(I)):
          O = switch(O, index(O, (i, j)), index(O, (k, j)))
          break
  return O
 
70.66666666666667, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def ajafjaibdibfeabcabcjcgcgfdhecbfc(I):
  O = I
  for j in range(width(I)):
    empty_i = height(I) - 1
    for i in range(height(I) - 1, -1, -1):
      if index(I, (i, j)) != mostcolor(I):
        O = switch(O, index(O, (i, j)), index(O, (empty_i, j)))
        empty_i -= 1
  return O
 
9.333333333333334, tensor(0.0059), Description: Move each colored shape to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def acebbfiagcbfecabieiacjcbebchbcch(I):
  objs = fgpartition(I)
  moved_objs = frozenset()
  for obj in objs:
    lowest_row = lowermost(obj)
    shift_amount = (len(I) - lowest_row - 1, -leftmost(obj))
    moved_objs = moved_objs.union({shift(obj, shift_amount)})
  O = I
  for obj in moved_objs:
    O = paint(O, obj)
  return O
 
17.333333333333332, tensor(0.0059), Description: Move each colored shape to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def dgeefbeidfdheabajeiccediaegcbbca(I):
  objs = objects(I, False, False, True)
  new_objs = frozenset({shift(obj, (len(I) - lowermost(obj) - 1, -leftmost(obj))) for obj in objs})
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
16.0, tensor(0.0071), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def hcadcghacgcaefhciffdbdghdecibbfj(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(len(I[0])):
    column = tuple(I[i][j] for i in range(len(I)))
    if len(set(column)) > 1:
      O = paint(O, frozenset({(v, (len(I) - i - 1, 0)) for i, v in enumerate(column) if v != mostcolor(I)}))
  return O
 
15.333333333333334, tensor(0.0061), Description: Move all colored shapes to the bottom right corner of the grid, keeping their original columns. The shapes should be ordered from bottom to top based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the bottom right corner and stacked vertically. 
:: def adebecjcfeadedcjibacbdghbcgcdaca(I):
  objs = sorted(fgpartition(I), key=lambda x: -uppermost(x))
  O = I
  for obj in objs:
    shifted_obj = shift(obj, (len(I) - lowermost(obj) - 1, -leftmost(obj)))
    O = paint(cover(O, obj), shifted_obj) 
  return O
 
12.666666666666666, tensor(0.0135), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def haijacfaeiheeccjjcibihdabbaiefej(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj))
  O = canvas(ZERO, shape(I))
  for obj in objs:
    temp_grid = paint(O, obj)
    while not bordering(obj, I) and not any(index(temp_grid, (lowermost(obj) + 1, j)) != 0 for j in range(leftmost(obj), rightmost(obj) + 1)):
      obj = shift(obj, DOWN)
      temp_grid = paint(O, obj)
    O = paint(O, obj)
  return O
 
12.666666666666666, tensor(0.0135), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def ehhadcdfahibeacabaaheefefadedhed(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        O = cover(O, obj)
        bottom_row = lowermost(obj)
        while bottom_row < height(I) - 1 and all(index(I, (bottom_row + 1, j)) == 0 for j in range(leftmost(obj), rightmost(obj) + 1)):
            bottom_row += 1
        obj = shift(obj, (bottom_row - lowermost(obj), 0))
        O = paint(O, obj)
    return O
 
13.666666666666666, tensor(0.0906), Description: For each colored shape in the input grid, rotate it 90 degrees clockwise and then shift it down by a number of squares equal to its height and to the right by one square. The output grid will have the same shapes as the input, but rotated and shifted. 
:: def hceefeddjdajecehbegaafcfejejddbe(I):
    objs = objects(I, F, F, T)
    O = I
    for obj in objs:
        rotated_obj = asobject(rot90(togrid(obj, I)))
        O = paint(cover(O, obj), shift(rotated_obj, (height(obj), 1)))
    return O
 
12.666666666666666, tensor(0.0906), Description: For each colored shape in the input grid, rotate it 90 degrees clockwise and then shift it down by a number of squares equal to its height and to the right by one square. The output grid will have the same shapes as the input, but rotated and shifted. 
:: def dgbegjbebfejeeggidbbbddbbeddfgda(I):
  transformed_objects = []
  for obj in objects(I, F, F, T):
    h = height(obj)
    transformed_objects.append(shift(asobject(rot90(togrid(obj, I))), (h, 1))) 
  output_grid = I
  for obj in transformed_objects:
    output_grid = paint(output_grid, obj)
  return output_grid
 
14.666666666666666, tensor(0.0906), Description: For each colored shape in the input grid, rotate it 90 degrees clockwise and then shift it down by a number of squares equal to its height and to the right by one square. The output grid will have the same shapes as the input, but rotated and shifted. 
:: def fffdhfdbieeeeccfafghgeddehcjbiah(I):
    return paint(I, merge(apply(lambda obj: shift(asobject(rot90(togrid(obj, I))), (height(obj), 1)), objects(I, F, F, T))))
 
6.333333333333333, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def cjaiadcffcdcejbbigieefeaecabdfcd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(objs, key=lambda x: (uppermost(x), leftmost(x))):
    shifted_obj = obj
    for i in range(height(I)):
      if not intersection(toindices(shift(shifted_obj, DOWN)), asindices(I) - toindices(shifted_obj)):
        shifted_obj = shift(shifted_obj, DOWN)
      else:
        break
    O = paint(O, shifted_obj)
  return O
 
18.0, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def fjdcjbicgcbeefibaijggjdcdeafdfae(grid):
  h, w = len(grid), len(grid[0])
  O = canvas(mostcolor(grid), (h, w))
  for j in range(w):
    column = [grid[i][j] for i in range(h)]
    non_zeros = [x for x in column if x != mostcolor(grid)]
    new_column = [mostcolor(grid)] * (h - len(non_zeros)) + non_zeros
    for i in range(h):
      O = fill(O, new_column[i], {(i, j)})
  return O
 
12.666666666666666, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def iagdgfdfhdieebcdbcadagfbfdaghcag(grid):
  h, w = len(grid), len(grid[0])
  O = canvas(mostcolor(grid), (h, w))
  for i in range(h-1, -1, -1):
    for j in range(w):
      if grid[i][j] != mostcolor(grid):
        current_i = i
        while current_i + 1 < h and grid[current_i + 1][j] == mostcolor(grid):
          current_i += 1
        O = switch(O, index(O, (i, j)), index(O, (current_i, j)))
  return O 
 
68.66666666666667, tensor(0.0192), Description: Move all the colored squares up one space, but only if the square above it is the background color. The output grid will have the same shapes as the input, but shifted up as far as possible without overlapping any other colored shapes or going outside the grid. 
:: def giejbbcefbffeagibcejageedfigjbjf(grid):
  O = grid
  for i in range(height(grid)-1, 0, -1):
    for j in range(width(grid)):
      if index(O, (i, j)) == mostcolor(O) and index(O, (i-1, j)) != mostcolor(O):
        O = switch(O, index(O, (i, j)), index(O, (i-1, j)))
  return O
 
10.0, tensor(0.0135), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def bdihdbcigceaedfaadfebebcfgfegejb(I):
  objs = objects(I, T, F, T)
  O = I
  for i in range(height(I)-1,-1,-1):
    for obj in objs:
      if lowermost(obj) == i:
        offset = (0, 0)
        while not bordering(shift(obj, offset), I) and not any(obj != other_obj and hmatching(shift(obj, offset), other_obj) for other_obj in objs):
          offset = add(offset, DOWN)
        O = cover(O, obj)
        O = paint(O, shift(obj, offset))
  return O
 
13.0, tensor(0.0101), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. The shapes should be ordered from top to bottom based on their lowermost row. 
:: def ifbccjhjfeadedhbbaccbfabcgfjdajh(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: -lowermost(obj))
  O = I
  for obj in objs:
    offset = (0, 0)
    while not bordering(shift(obj, offset), I) and not any(obj != other_obj and hmatching(shift(obj, offset), other_obj) for other_obj in objs if lowermost(other_obj) < lowermost(obj)):
      offset = add(offset, DOWN)
    O = cover(O, obj)
    O = paint(O, shift(obj, offset))
  return O
 
10.333333333333334, tensor(0.0135), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def ifebbbegcjfiedecijfjdbbfbedbfhhc(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    for i in range(lowermost(obj) + 1, height(I)):
      if any((i, j) in toindices(other_obj) for j in range(leftmost(obj), rightmost(obj) + 1) for other_obj in objs if obj != other_obj):
        break
    O = cover(O, obj)
    O = paint(O, shift(obj, (i - lowermost(obj) - 1, 0)))
  return O
 
17.666666666666668, tensor(0.0110), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. The shapes should be ordered from top to bottom based on their uppermost row. 
:: def gfcghbcbefbaeeebaagfjddgbgbaaead(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in sorted(objs, key=lambda x: -uppermost(x)):
    O = cover(O, obj)
    for i in range(1, height(I)):
      shifted_obj = shift(obj, (i, 0))
      if intersection(toindices(shifted_obj), asindices(I)) == toindices(shifted_obj):
        obj = shifted_obj
      else:
        break
    O = paint(O, obj)
  return O
 
18.333333333333332, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def dgjeaeeefgdiebabbagbijccdibbbdcb(I):
    O = canvas(mostcolor(I), shape(I))
    for j in range(width(I)):
        column = frozenset((I[i][j], (i, j)) for i in range(height(I)) if I[i][j] != mostcolor(I))
        for k in range(height(I)):
            if (height(I) - 1 - k, j) in toindices(column):
                O = paint(O, shift(column, (k, 0)))
                break
    return O
 
14.333333333333334, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def bgbdadgfafjeecabadaddfebbabfabda(I):
    objs = objects(I, True, False, True)
    O = I
    for obj in objs:
        g = gravitate(obj, frozenset({(height(I)-1, 0)}))
        O = paint(cover(O, obj), shift(obj, g))
    return O
 
16.333333333333332, tensor(0.0084), Description: Move all colored shapes to the bottom of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def cbeabgibhjheedbcafggifgebddjcbeh(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), 0)))
  return O
 
15.666666666666666, tensor(0.0063), Description: Move all colored shapes to the bottom of the grid, stacking them vertically. The shapes should be ordered from bottom to top based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the bottom and stacked vertically. 
:: def ceaffbecfhfjedaebbeidjggabffgcbg(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  y_offset = 0
  for obj in sorted(objs, key=lambda obj: uppermost(obj)):
    O = paint(O, shift(obj, (height(I) - height(obj) - y_offset, 0)))
    y_offset += height(obj)
  return O
 
13.666666666666666, tensor(0.0070), Description: Move all colored shapes to the bottom of the grid, keeping their original columns. The shapes should be ordered from bottom to top based on their original position in the grid. The output grid will have the same shapes as the input, but shifted to the bottom and stacked vertically. 
:: def eagedgfdcfdiebegadcffbadfeajbifj(I):
    objs = objects(I, T, F, T)
    O = canvas(ZERO, shape(I))
    for j in range(width(I)):
        current_height = height(I)
        for i in range(height(I) - 1, -1, -1):
            if index(I, (i, j)) != ZERO:
                obj = extract(objs, lambda o: (i, j) in toindices(o))
                O = paint(O, shift(obj, (current_height - height(obj), 0)))
                current_height -= height(obj)
                break
    return O
 
17.333333333333332, tensor(0.0086), Description: Move each colored shape to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def ccghcaeeejfeebfeadaafaaccdfbdfce(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    O = paint(O, shift(obj, (height(grid) - uppermost(obj) - height(obj), -leftmost(obj))))
  return O
 
19.666666666666668, tensor(0.0250), Description: The input grid is mirrored vertically around its center line. The output grid will have the same shapes as the input, but mirrored vertically. 
:: def haiaibfdaehiebdebifefefjdfifdcce(grid):
  O = canvas(mostcolor(grid), shape(grid))
  for i, row in enumerate(grid):
    for j, value in enumerate(row):
      if value != mostcolor(grid):
        O = fill(O, value, {(len(grid) - 1 - i, j)})
  return O
 
12.666666666666666, tensor(0.0092), Description: Move each colored shape to the top left corner of the grid. The output grid will have the same shapes as the input, but shifted to the top left corner. 
:: def fgdajahbbbdbefdeaaceaaddacjdiidc(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  return paint(canvas(mostcolor(grid), shape(grid)), 
               merge({shift(obj, gravitate(obj, {(0, 0)})) for obj in objs}))
 
8.333333333333334, tensor(0.0574), Description: Copy the input grid. For each colored shape in the top half of the grid, reflect it diagonally. Leave the shapes in the bottom half of the grid unchanged. The output grid will have the same shapes as the input, but with the shapes in the top half reflected diagonally. 
:: def ecfbjacbagheeaggbcbjdgceabcbbbcg(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  h, w = shape(I)
  for obj in objs:
    if uppermost(obj) <=  (h - 1) / 2:
      O = paint(O, dmirror(obj))
    else:
      O = paint(O, obj)
  return O
 
9.0, tensor(0.0076), Description: The input grid is transposed. The output grid is a reflection of the input grid along the diagonal line from the top left corner to the bottom right corner.  The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def cdfbacdfgeghefedieeebgebabgfhfii(I):
  O = canvas(ZERO, shape(I))
  h, w = shape(I)
  for i in range(h):
    for j in range(w):
      if i <= j:
        O = paint(O, {(I[i][j], (j, i))})
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
34.333333333333336, tensor(0.0076), Description: The input grid is transposed. The output grid is a reflection of the input grid along the diagonal line from the top left corner to the bottom right corner.  The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def djajgbcddhcbeaacaefdfbdcecejafae(I):
  h, w = shape(I)
  return rot270(tuple(tuple(I[j][i] if i <= j else I[i][j] for j in range(w)) for i in range(h)))
 
9.666666666666666, tensor(0.0076), Description: The input grid is transposed. The output grid is a reflection of the input grid along the diagonal line from the top left corner to the bottom right corner.  The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def ifddajageajieeffbgifdhbdcdfjbcdc(I):
  h, w = shape(I)
  return tuple(tuple(I[i][j] if i > j else I[j][i] for j in range(w)) for i in range(h))
 
15.666666666666666, tensor(0.0059), Description: The input grid is reflected along the diagonal line from the top left corner to the bottom right corner. The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def ehjcefhfbaidecaajaiaedfbbcgagdde(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w)) # Create a canvas filled with the background color
  for i in range(h):
    for j in range(w):
      if i > j:  # Reflect only elements below diagonal
        O = fill(O, index(I, (j, i)), ((i, j), (i, j))) # Reflect from (j, i) to (i, j)
      else:
        O = fill(O, index(I, (i, j)), ((i, j), (i, j))) # Keep other elements same
  return O
 
44.666666666666664, tensor(0.0211), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored diagonally, and then concatenated with the original top-left quadrant vertically. This creates a left half of the output grid. The bottom-right quadrant is kept as is. Finally, the left half and the bottom-right quadrant are concatenated horizontally to form the output grid. The output grid is essentially a combination of the original top-left quadrant, its diagonal mirror, and the original bottom-right quadrant. 
:: def aidbccghhjbgeidfjjeeichafbhchfgf(I):
    h, w = height(I), width(I)
    upper_triangle = hsplit(vsplit(I, 2)[0], 2)[0] # Extract upper triangular part
    mirrored_upper = dmirror(upper_triangle) # Mirror upper triangle
    lower_triangle = hsplit(vsplit(I, 2)[1], 2)[1] # Extract lower triangular part
    left_part = vconcat(upper_triangle, mirrored_upper) # Combine upper and mirrored upper
    O = hconcat(left_part, lower_triangle) # Concatenate left part and lower triangle
    return O
 
12.333333333333334, tensor(0.0123), Description: Copy the top half of the input grid. For each colored shape in the top half, mirror it vertically and place the mirrored shape below the original shape. The output grid will have the same shapes as the input, but with the shapes in the top half mirrored vertically and stacked below their originals. 
:: def eaddiefjbbjaebdbiigcchjhjgbhbede(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    for i in range(height(I) // 2):
      if I[i][j] != mostcolor(I):
        obj = extract(objects(crop(I, (0, 0), (height(I) // 2, width(I))), T, F, T), lambda obj: (i, j) in toindices(obj))
        O = paint(O, obj)
        O = paint(O, shift(obj, (height(I) - 1 - 2 * uppermost(obj), 0)))
  return O 
 
13.666666666666666, tensor(0.0230), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is rotated 180 degrees and then concatenated with the top half. The output grid is essentially a combination of the original top half and the rotated bottom half. 
:: def ifaehbcfaejbedffjejiifccdibgdbed(I):
  top_half = crop(I, (0, 0), (height(I) // 2, width(I)))
  bottom_half = rot180(top_half)
  return vconcat(top_half, bottom_half)
 
16.0, tensor(0.0323), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is mirrored horizontally and then concatenated with the top half. The output grid is essentially a combination of the original top half and the mirrored bottom half. 
:: def jhaehdajjfbcegihjejfaeaeaajcbbej(I):
  top, bottom = vsplit(I, 2)
  return vconcat(top, hmirror(top))
 
10.0, tensor(0.0134), Description: Copy the input grid. For each colored shape in the top half of the grid, reflect it vertically and place the mirrored shape below the original shape. Leave the shapes in the bottom half of the grid unchanged. The output grid will have the same shapes as the input, but with the shapes in the top half mirrored vertically and stacked below their originals. 
:: def ceffbeacccgaedbeacgefiahfeegfeeb(I):
  objs = objects(I, T, F, T)
  h = height(I)
  mirrored_objs = frozenset({shift(obj, (h - 1 - 2 * uppermost(obj), 0)) for obj in objs if uppermost(obj) < h // 2})
  O = canvas(mostcolor(I), shape(I))
  for obj in objs | mirrored_objs:
    O = paint(O, obj)
  return O
 
82.66666666666667, tensor(0.0144), Description: For each colored shape in the input grid, duplicate it and stack the duplicate directly below the original shape. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def ggfacabgfbjdedhdbegafjbedaiehdbb(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, (height(I) * 2, width(I)))
  for i, obj in enumerate(objs):
    O = paint(O, shift(obj, (0, 0)))
    O = paint(O, shift(obj, (height(obj), 0)))
  return O
 
78.66666666666667, tensor(0.0152), Description: Duplicate the input grid vertically, stacking it on top of itself. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def cgefecfdehadebiejcfiiccigbfaaecb(I):
  O = canvas(ZERO, (height(I) * 2, width(I)))
  for i in range(height(I)):
    O = paint(O, {(I[i][j], (i, j)) for j in range(width(I))})
    O = paint(O, {(I[i][j], (i + height(I), j)) for j in range(width(I))})
  return O
 
78.66666666666667, tensor(0.0124), Description: Duplicate each row of the input grid vertically, stacking it on top of itself. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically. 
:: def cbjcdiafafgbehcfijahahbigebfbeif(I):
  return tuple(row + row for row in I) 
 
82.66666666666667, tensor(0.0185), Description: For each colored shape in the input grid, duplicate it and stack the duplicate directly below the original shape. Then, concatenate the resulting grid with the original input grid vertically. The output grid will have the same shapes as the input, but with each shape duplicated and stacked vertically, and the original input grid appended below. 
:: def ebhegabaggbjeeceaeddddjejbebcdaf(I):
  O = canvas(ZERO, (height(I), width(I)))
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    O = paint(O, shift(obj, (height(obj), 0)))
  return vconcat(O, I)
 
12.666666666666666, tensor(0.0059), Description: The input grid is reflected along the diagonal line from the top left corner to the bottom right corner. The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def cicbejedjfedecceidaffgfbdadjedba(I):
    h, w = height(I), width(I)
    O = canvas(mostcolor(I), (h, w))  # Create a blank canvas
    for i in range(h):
        for j in range(i, w):  # Iterate over the upper triangular part
            O = fill(O, I[j][i], ((i, j), (i, j))) # Mirror the value across the diagonal
    return O
 
14.0, tensor(0.1519), Description: For each colored shape in the input grid, rotate it 90 degrees clockwise and then shift it down by a number of squares equal to its height. If the shape is in the leftmost column, shift it down by its height, otherwise shift it up by its height. The output grid will have the same shapes as the input, but rotated and shifted. 
:: def cbfjffcffiihehffbaffgcjicjffdccb(I):
  objs = objects(I, F, F, T)
  O = I
  for obj in objs:
    rotated_obj = asobject(rot90(togrid(obj, I)))
    O = paint(O, shift(rotated_obj, (height(obj) * (1 - 2*(leftmost(obj)==0)), 0)))
  return O
 
18.0, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def efaefbejbgaiehjbafcjchdjbccffdfh(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    for i in range(height(grid)):
      shifted = shift(obj, (i, 0))
      if any(index(grid, (i, j)) != mostcolor(grid) and (i, j) not in toindices(obj)
             for i, j in toindices(shifted)):
        break
      obj = shifted
    O = paint(O, obj)
  return O
 
13.666666666666666, tensor(0.0065), Description: Move each colored shape diagonally down and to the right as far as possible without overlapping any other colored shapes or going outside the grid. The shapes should be ordered from top left to bottom right based on their upper-left corner. The output grid will have the same shapes as the input, but shifted diagonally down and to the right. 
:: def ijeifeahbjccebhfigddehgdjfebafbf(grid):
    objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
    O = canvas(mostcolor(grid), shape(grid))
    for obj in sorted(objs, key=lambda x: (uppermost(x), leftmost(x))):
        bottom_limit = height(grid) - height(obj)
        for i in range(bottom_limit + 1):
            shifted = shift(obj, (i, i))
            if i == bottom_limit or any(index(grid, (r, c)) != mostcolor(grid) for r, c in toindices(shifted) & delta(obj)):
                O = paint(O, shift(shifted, (-1, -1)))
                break
    return O
 
69.66666666666667, tensor(0.0163), Description: Copy the input grid. Then, for each colored square, find the closest background square to the right of it. Swap the colors of the colored square and the background square. The output grid will have the same shapes as the input, but with the colors of each colored square swapped with the color of the closest background square to the right of it. 
:: def aadaffcfbffheffgaaajefjefbbgiabe(grid):
  h, w = len(grid), len(grid[0])
  O = canvas(mostcolor(grid), (h, w))
  for i in range(h - 1, -1, -1):
    for j in range(w - 1, -1, -1):
      if grid[i][j] != mostcolor(grid):
        O = switch(O, index(O, (i, j)), grid[i][j])
        grid = fill(grid, mostcolor(grid), ((i, j),))
  return O
 
71.0, tensor(0.0211), Description: The input grid is mirrored both horizontally and vertically. The output grid will have the same shapes as the input, but mirrored across both axes. 
:: def ddjjafccaibcejdgbijgbgdifadgdccc(grid):
    h, w = len(grid), len(grid[0])
    O = canvas(mostcolor(grid), (h, w))
    for i in range(h):
        for j in range(w):
            if grid[i][j] != mostcolor(grid):
                new_i = h - 1 - i
                new_j = w - 1 - j
                O = switch(O, index(O, (new_i, new_j)), grid[i][j])
    return O
 
9.666666666666666, tensor(0.1316), Description: Reflect each colored shape diagonally. The output grid will have the same shapes as the input, but mirrored diagonally. 
:: def fegbfeafhjdceiiiicccjdcdgcjgehhj(I):
    objs = objects(I, T, F, T)
    O = canvas(ZERO, shape(I))
    for obj in objs:
        O = paint(O, dmirror(toobject(obj, I)))
    return O
 
28.333333333333332, tensor(0.9724), Description: Reflects the input grid diagonally using grid transformations. 
:: def ehafdhhbdeeiejjejdjdjbfedcidacfg(I):
  return dmirror(I)
 
12.333333333333334, tensor(0.0076), Description: The input grid is transposed. The output grid is a reflection of the input grid along the diagonal line from the top left corner to the bottom right corner.  The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def bdcfebabiihfedeababefefccagiagbh(I):
    h, w = shape(I)
    O = canvas(ZERO, (h, w))
    for i in range(h):
        for j in range(w):
            O = fill(O, I[i][j], {(j, i)})
    return O
 
28.333333333333332, tensor(0.9717), Description: Reflects the input grid diagonally using grid transformations. 
:: def cbbfbdhhddgeegebbcgchahbeibgfchj(I):
    return dmirror(I)
 
12.333333333333334, tensor(0.0059), Description: The input grid is reflected along the diagonal line from the top left corner to the bottom right corner. The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def ebiefddfjgbeehefibjeiejhbhfccfab(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(i, w): 
      O = fill(O, I[j][i], ((i, j), (i, j)))
      if i != j:
        O = fill(O, I[i][j], ((j, i), (j, i))) 
  return O
 
17.666666666666668, tensor(0.0140), Description: For each colored square in the input grid, move it down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def ejbbfaaacfddegdcafaaiehjagbabdhd(grid):
    objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
    O = grid
    for i in range(height(grid)-1, 0, -1):
        for j in range(width(grid)):
            if index(grid, (i, j)) != mostcolor(grid):
                for obj in objs:
                    if (i, j) in toindices(obj):
                        k = 1
                        while (i+k, j) not in toindices(obj) and index(O, (i+k, j)) == mostcolor(grid) and i+k < height(grid):
                            k += 1
                        O = move(O, obj, (k-1, 0))
                        break
    return O
 
18.333333333333332, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def fdgdjhcgbfajedhbbfebabgedeafgaff(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  O = grid
  for obj in objs:
    bottom_edge =  [(lowermost(obj), j) for j in range(leftmost(obj), rightmost(obj) + 1)]
    collision = False
    for i in range(1, height(grid)):
      for j in range(len(bottom_edge)):
        if index(grid, add(bottom_edge[j], (i, 0))) != mostcolor(grid) and add(bottom_edge[j], (i, 0)) not in toindices(obj):
          collision = True
          break
      if collision:
        O = move(O, obj, (i-1, 0))
        break
  return O
 
45.0, tensor(0.0067), Description: Move all colored shapes to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def bdgdficfgdbdefibachjbedfddaebcgf(I):
  objs = objects(I, False, False, True)
  h = max([lowermost(obj) for obj in objs] + [0]) + 1
  w = max([rightmost(obj) for obj in objs] + [0]) + 1
  grid = canvas(0, (h, w))
  for obj in objs:
    grid = paint(grid, shift(obj, (h - height(obj) - uppermost(obj), -leftmost(obj))))
  return grid
 
17.333333333333332, tensor(0.0064), Description: Move each colored shape to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def accefcfjdjbaeefjajedhechbehechcf(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, F, F, T):
        O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), -leftmost(obj))))
    return O
 
17.333333333333332, tensor(0.0064), Description: Move each colored shape to the bottom right corner of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom right corner. 
:: def dbehcdchbhbdeeiijjcebgadadgedici(I):
  objs = objects(I, F, F, T)
  h = height(I)
  w = width(I)
  return paint(canvas(0, (h, w)), merge({shift(obj, (h - height(obj) - uppermost(obj), -leftmost(obj))) for obj in objs}))
 
7.333333333333333, tensor(0.0146), Description: Move each colored shape down as far as possible without overlapping any other colored shapes or going outside the grid. The output grid will have the same shapes as the input, but shifted down as far as possible. 
:: def bcddacbddibdeegdjfccadfdebadigdc(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    shifted = obj
    while not bordering(shifted, grid) and all(index(grid, (i + 1, j)) == mostcolor(grid) for i, j in toindices(shifted)):
      shifted = shift(shifted, (1, 0))
    O = paint(O, shifted)
  return O
 
14.0, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def dgfcbeafgcceeeiejfhhffibjabdddbf(grid):
  O = canvas(mostcolor(grid), shape(grid))
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val != mostcolor(grid):
        k = i
        while k < len(grid) - 1 and grid[k + 1][j] == mostcolor(grid):
          k += 1
        O = paint(O, {(val, (k, j))})
  return O
 
14.0, tensor(0.1665), Description: For each colored shape in the input grid, shift it down by a number of squares equal to its height and to the right by a number of squares equal to its height minus its uppermost row. The output grid will have the same shapes as the input, but shifted down and to the right. 
:: def aahdaedgcheeeecbideeabbfbhfbjjie(I):
  O = canvas(ZERO, shape(I))
  return paint(O, merge(apply(lambda obj: shift(obj, (height(obj), height(obj) - uppermost(obj))), objects(I, F, F, T)))) 
 
16.333333333333332, tensor(0.0062), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def baadedceddcbeddiadfgfdhaefbdfafh(I):
  objs = objects(I, F, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (height(I) - uppermost(obj) - height(obj), leftmost(obj))))
  return O
 
85.0, tensor(0.6704), Description: For each colored shape in the input grid, shift it down by a number of squares equal to twice its height minus its uppermost row. The output grid will have the same shapes as the input, but shifted down. 
:: def caeefacdaffiefjfjhefdcedacfdeffd(I):
  O = canvas(ZERO, shape(I))
  return merge([paint(O, shift(obj, (height(obj) * 2 - uppermost(obj), 0))) for obj in objects(I, F, F, T)])
 
7.666666666666667, tensor(0.0182), Description: For each colored shape in the input grid, reflect it both horizontally and vertically. The output grid will have the same shapes as the input, but mirrored across both axes. 
:: def gfifdbjjcbaaeidgafbbdfgbaccibfbe(I):
  objs = objects(I, T, T, T) # Identify all objects in the grid
  O = I  # Initialize output as input
  for obj in objs:
    O = paint(cover(O, obj), hmirror(vmirror(obj))) # Reflect each object
  return O
 
11.333333333333334, tensor(0.8463), Description: Reflects the input grid diagonally using object manipulation. 
:: def bfghaieffhdeebjcbgheddcaddabdfff(I):
  objs = partition(I) # Partition the grid into objects based on color
  O = I  # Initialize output as input
  for obj in objs:
    reflected_obj = frozenset((c, (j, i)) for c, (i, j) in obj) # Reflect object coordinates
    O = paint(cover(O, obj), reflected_obj) # Cover original, paint reflected
  return O
 
13.333333333333334, tensor(0.0059), Description: The input grid is reflected along the diagonal line from the top left corner to the bottom right corner. The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. 
:: def biaifcbefcbcefeciiecaabiffbbbdeh(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))  # Initialize with background color
  indices = asindices(I)
  for i, j in indices:
    if (i > j): # Reflect only the lower triangle
      O = fill(O, index(I, (i, j)), ((j, i), (j, i)))  # Reflect (i, j) to (j, i)
  return O
 
19.0, tensor(0.0078), Description: The input grid is reflected along the diagonal line from the top left corner to the bottom right corner. The elements above the diagonal remain in their original positions, while the elements below the diagonal are mirrored across the diagonal. The colors of the elements are also swapped during the reflection. 
:: def fedbchdibeedebdcaaeeagcbdefbaaei(I):
  O = I # Start with the input grid
  for i in range(height(I)):
    for j in range(i): # Iterate over the lower triangle
      a = index(I, (i, j)) # Get color at (i, j)
      b = index(I, (j, i)) # Get color at (j, i)
      O = fill(fill(O, a, ((j, i), (j, i))), b, ((i, j), (i, j))) # Swap colors
  return O
 
13.0, tensor(0.2490), Description: For each colored shape in the input grid, rotate it 90 degrees clockwise and then shift it down by a number of squares equal to its height. The output grid will have the same shapes as the input, but rotated and shifted. 
:: def hdaeabdeaiabefefjaceaacedhgffbfh(I):
  transformed_objs = set()
  for obj in objects(I, F, F, T):
    rotated_grid = rot90(crop(I, ulcorner(obj), shape(obj)))
    shifted_grid = shift(asobject(rotated_grid), (height(obj), 0))
    transformed_objs.add(shifted_grid)
  return paint(I, merge(transformed_objs))
 
14.333333333333334, tensor(0.1922), Description: For each colored shape in the input grid, shift it down and to the right by a number of squares equal to its height minus its uppermost row. The output grid will have the same shapes as the input, but shifted down and to the right. 
:: def difddadabdebebagjgadjabhegcegbfd(I):
  objs = objects(I, F, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    h = height(obj)
    u = uppermost(obj)
    O = paint(O, shift(obj, (h - u, h - u)))
  return O
 
35.0, tensor(0.0142), Description: Rotate the input grid 270 degrees counterclockwise. 
:: def fbhehifjbcceefceijeaeahadbdiffaj(I):
  return rot270(I)
 
11.666666666666666, tensor(0.0084), Description: Move each colored shape to the top of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the top row. 
:: def gaidbaeffbjbeajcaajaceffbjhdabfb(I):
  objs = objects(I, F, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    u = uppermost(obj)
    O = paint(O, shift(obj, (-u, 0)))
  return O
 
13.0, tensor(0.0061), Description: Move each colored shape to the bottom right corner of the grid, stacking them diagonally. The shapes should be ordered from bottom right to top left based on their index in the `objects` list. The output grid will have the same shapes as the input, but shifted to the bottom right corner and stacked diagonally. 
:: def bgcdhfggeachecadjdfdfggeeefhhfdf(I):
  objs = objects(I, F, F, T)
  O = canvas(ZERO, shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(obj, (len(objs) - i - 1, len(objs) - i - 1)))
  return O
 
8.333333333333334, tensor(0.0115), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored diagonally (across the center), and then the mirrored quadrant is placed in the bottom-right quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a diagonally mirrored top-left quadrant in the bottom-right position. 
:: def djcefagdbhihefcdjfachhehgiacaffb(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))  # Initialize with background color
  for i in range(h):
    for j in range(w):
      if i < min(h//2, w//2) and j < min(h//2, w//2): # Upper-Left Quadrant condition
        O = fill(O, index(I, (i, j)), ((h - i - 1, w - j - 1), (h - i - 1, w - j - 1)))
      else:
        O = fill(O, index(I, (i, j)), ((i, j), (i, j)))
  return O
 
8.666666666666666, tensor(0.0115), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored diagonally (across the center), and then the mirrored quadrant is placed in the bottom-right quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a diagonally mirrored top-left quadrant in the bottom-right position. 
:: def beedhiffdhfhehbfigeideihcfbeddea(I):
  h, w = height(I), width(I)
  O = I # Direct assignment for efficiency
  for i in range(min(h//2, w//2)): # Only iterate over relevant quadrant
    for j in range(i, min(h//2, w//2)): # Iterate over half the quadrant and mirror
      temp = index(I, (i, j))
      O = fill(O, index(I, (h-i-1, w-j-1)), ((i, j), (i, j)))
      O = fill(O, temp, ((h-i-1, w-j-1), (h-i-1, w-j-1)))
  return O
 
21.666666666666668, tensor(0.0108), Description: The input grid is split into four quadrants. The top-left quadrant is rotated 180 degrees and placed in the bottom-right quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a rotated top-left quadrant in the bottom-right position. 
:: def fachbfaidbifeiegjgdffgbededfcabe(I):
  h, w = height(I), width(I)
  quadrant_size = min(h//2, w//2)
  upper_left = crop(I, (0, 0), (quadrant_size, quadrant_size))
  lower_right = rot180(upper_left)  
  O = hconcat(vconcat(upper_left, lower_right), crop(I, (0, quadrant_size), (h, w-quadrant_size)))
  return O
 
8.666666666666666, tensor(0.0115), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored diagonally (across the center), and then the mirrored quadrant is placed in the bottom-right quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a diagonally mirrored top-left quadrant in the bottom-right position. 
:: def adfijibaiiafebdcbcjdadbdejfadfja(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))
  indices = asindices(I)
  for i, j in indices:
    if i < min(h//2, w//2) and j < min(h//2, w//2):
      O = fill(O, index(I, (i, j)), ((h - i - 1, w - j - 1), (h - i - 1, w - j - 1)))
    else:
      O = fill(O, index(I, (i, j)), ((i, j), (i, j)))
  return O
 
7.333333333333333, tensor(0.0117), Description: The input grid is split into four quadrants. The bottom-right quadrant is mirrored diagonally (across the center), and then the mirrored quadrant is placed in the top-left quadrant of the output grid. The top-right and bottom-left quadrants of the input grid are kept as is and placed in the corresponding positions in the output grid. The output grid is essentially a combination of the original top-right and bottom-left quadrants, and a diagonally mirrored bottom-right quadrant in the top-left position. 
:: def dafhbbgjediaecdbabgcbcifgedjfade(I):
  h, w = height(I), width(I)
  O = I # Direct assignment for efficiency
  for i in range(min(h//2, w//2)):
    O = paint(O, recolor(index(I, (h-i-1, w-i-1)), {(i, i)}))
  return O
 
15.333333333333334, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def iaebcceicdcceeadjaidbacggaaaabhe(grid):
  output = canvas(mostcolor(grid), shape(grid))
  for j in range(width(grid)):
    column = frozenset((grid[i][j], (i, j)) for i in range(height(grid)) if grid[i][j] != mostcolor(grid))
    output = paint(output, shift(column, (height(grid) - height(column), 0)))
  return output
 
17.333333333333332, tensor(0.0086), Description: For each column in the input grid, move all the colored squares to the bottom of the column, leaving the background color in the spaces above. The output grid will have the same shapes as the input, but with all colored squares shifted to the bottom of their respective columns. 
:: def cfhhefjadbegehfgjefcbfeabccaajic(grid):
  output = list(list(row) for row in grid)
  for j in range(width(grid)):
    non_bg = [grid[i][j] for i in range(height(grid)) if grid[i][j] != mostcolor(grid)]
    k = 0
    for i in range(height(grid) - 1, -1, -1):
      if k < len(non_bg):
        output[i][j] = non_bg[k]
        k += 1
      else:
        output[i][j] = mostcolor(grid)
  return tuple(tuple(row) for row in output)
 
18.333333333333332, tensor(0.0073), Description: Move each colored shape to the bottom row of the grid, keeping their original columns. The output grid will have the same shapes as the input, but shifted to the bottom row. 
:: def fhccjbacbbbaebagaeabchfgehcaeegd(I):
  objs = objects(I, F, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (height(I) - lowermost(obj) - 1, 0)))
  return O
 
62.333333333333336, tensor(0.2646), Description: Rotate the input grid 180 degrees, compress it horizontally by removing empty columns, and then rotate it 180 degrees again. The output grid will have the same shapes as the input, but compressed horizontally and rotated 180 degrees. 
:: def jgjcfeechhccebgcigccfeadbdbcagai(I):
  return rot180(compress(rot180(I)))
 
13.0, tensor(0.2937), Description: For each colored shape in the input grid, shift it to the right by a number of squares equal to its color. The output grid will have the same shapes as the input, but shifted to the right. 
:: def cffadhjeecjcehcfbafbaiddeehjdcgf(I):
  objs = partition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    c = color(obj)
    O = paint(O, shift(obj, (c, 0)))
  return O
 
15.333333333333334, tensor(0.3113), Description: For each color in the input grid, replace all instances of that color with black, then shift the resulting shape to the right by a number of squares equal to the color value. The output grid will have the same shapes as the input, but shifted to the right based on their original color. 
:: def hhjeiccfbfigeceaaccffcggaabbgcdj(I):
  O = I
  for c in palette(I):
    O = paint(cover(O, recolor(0, ofcolor(I, c))), shift(recolor(c, ofcolor(I, c)), (c, 0)))
  return O
 
12.333333333333334, tensor(0.3066), Description: Shift each row of the input grid to the right by a number of squares equal to the value of the corresponding element in the row. For example, if the first row is `(1, 2, 3)`, the first row of the output grid will be shifted to the right by `(1, 2, 3)` squares respectively. The output grid will have the same shapes as the input, but shifted to the right based on the values in each row. 
:: def bdahdgfcjgafedbabihfecbdeaaiicee(I):
  h = height(I)
  return tuple(tuple(I[(i-v)%h][j] for j, v in enumerate(row)) for i, row in enumerate(I))
 
10.0, tensor(0.3066), Description: Shift each row of the input grid to the right by a number of squares equal to the value of the corresponding element in the row. For example, if the first row is `(1, 2, 3)`, the first row of the output grid will be shifted to the right by `(1, 2, 3)` squares respectively. The output grid will have the same shapes as the input, but shifted to the right based on the values in each row. 
:: def aefeddjdegdaeacdbacdabdbabjghcfc(I):
  O = list(list(row) for row in I)
  for i in range(len(I)):
    for j in range(len(I[0])):
      offset = I[i][j]
      new_i = (i + offset) % len(I)
      O[new_i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
223.33333333333334, tensor(0.0092), Description: Copy the left half of the input grid to the top half of the output grid. Then, mirror the right half of the input grid vertically and copy it to the bottom half of the output grid. 
:: def bgabhceecfhbejggaajeifjaagbbiafj(I):
    x1 = lefthalf(I)
    x2 = righthalf(I)
    x3 = vmirror(x2)
    O = vconcat(x1, x3)
    return O
 
223.33333333333334, tensor(0.0283), Description: The input grid is split horizontally into two halves. The top half is kept as is, while the bottom half is mirrored vertically and then concatenated with the top half. The output grid is essentially a combination of the original top half and the mirrored bottom half. 
:: def fcagaccicaeceefcbbejahdbcjfhihdi(I):
    h = height(I) // 2
    x1 = crop(I, (0, 0), (h, width(I)))
    x2 = crop(I, (h, 0), (h, width(I)))
    x3 = vmirror(x2)
    O = vconcat(x1, x3)
    return O
 
246.66666666666666, tensor(0.0135), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their index in the `objects` list. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def chcbeiebajdbegddibbabbfcafdhhbja(I):
  O = canvas(mostcolor(I), (height(I), width(I)))
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  for i, obj in enumerate(objs):
    O = paint(O, shift(normalize(obj), (i, 0)))
  return O
 
238.0, tensor(0.3055), Description: For each color in the input grid, replace all instances of that color with black, then shift the resulting shape to the right by a number of squares equal to the color value. The output grid will have the same shapes as the input, but shifted to the right based on their original color. 
:: def agefeeggceaiebdajgijaaiaihihbcdc(I):
    O = canvas(mostcolor(I), shape(I))
    j = 0
    for v in palette(I) - {mostcolor(I)}:
        O = paint(O, shift(normalize(recolor(v, ofcolor(I, v))), (j, 0)))
        j += 1
    return O
 
244.0, tensor(0.0150), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their center column, with the shape with the rightmost center column being placed furthest to the right. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def ieaebfdcbfdeeeejadgcbiabfdbajgjc(I):
    objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: -centerofmass(obj)[1])
    O = canvas(mostcolor(I), shape(I))
    for i, obj in enumerate(objs):
        O = paint(O, shift(normalize(obj), (i, 0)))
    return O
 
128.66666666666666, tensor(0.0146), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their height, with the tallest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def ajbfdffaaijfeaehaabeiffefefhgcgj(I):
    O = canvas(mostcolor(I), (max(height(obj) for obj in objects(I, univalued=False, diagonal=False, without_bg=True)), width(I)))
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    j = 0
    for obj in objs:
        O = paint(O, shift(normalize(obj), (j,0)))
        j += height(obj)
    return O
 
224.33333333333334, tensor(0.0102), Description: Move the object with the least number of colors to the top-left corner of the grid. The output grid will have the same shapes as the input, but with the target object shifted to the top-left corner. 
:: def iegccejfffaaecfabaiieffdggfciehd(I):
  # Find the object with the least number of colors (likely the target object).
  target_obj = argmin(objects(I, False, True, True), numcolors)
  
  # Calculate the shift required to move the top-left corner of the target object to (1, 1). 
  shift_amount = (1 - uppermost(target_obj), 1 - leftmost(target_obj))
  
  # Shift the target object.
  shifted_obj = shift(target_obj, shift_amount)
  
  # Paint the shifted object onto the original grid.
  O = paint(I, shifted_obj)
  
  return O
 
78.66666666666667, tensor(0.0518), Description: Split the input grid horizontally into two halves. Mirror the bottom half vertically. Find all objects in the mirrored bottom half and select the smallest one. Paint the selected object onto the top half. The output grid will have the same shapes as the input, but with the smallest object from the mirrored bottom half painted onto the top half. 
:: def bgaafihbcbgdeebjbgbdefagfgeacijb(I):
  # Split the grid horizontally into two halves.
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  
  # Mirror the bottom half vertically.
  mirrored_bottom = vmirror(bottom_half)
  
  # Find all objects in the mirrored bottom half.
  objs = objects(mirrored_bottom, False, True, True)
  
  # Select the smallest object.
  target_obj = argmin(objs, size)
  
  # Paint the selected object onto the top half.
  O = paint(top_half, target_obj)
  return O
 
224.66666666666666, tensor(0.0095), Description: Move the object with the least common color to the center of the grid. The output grid will have the same shapes as the input, but with the target object shifted to the center. 
:: def ddhafgegbfceefhdafabcbfddaaaedbd(I):
  # Assuming the target object has a unique color, find this color.
  target_color = leastcommon(merge(I))
  
  # Find the object with the target color.
  target_obj = first(colorfilter(objects(I, False, True, True), target_color))
  
  # Calculate the shift required to move the object's center of mass to (4, 4).
  shift_amount = subtract((4, 4), centerofmass(target_obj))
  
  # Shift the target object.
  shifted_obj = shift(target_obj, shift_amount)
  
  # Paint the shifted object onto the original grid.
  O = paint(I, shifted_obj)
  return O
 
223.33333333333334, tensor(0.0079), Description: Find the two smallest colored shapes in the input grid. Move the smaller shape towards the larger shape, taking the most direct route possible. The smaller shape should be placed wherever it touches the larger shape. The output grid will have the same shapes as the input, but with the smaller shape moved towards the larger shape. 
:: def cadbbejjfaahecibjfecfahijggichah(I):
  # Partition the grid into objects.
  objs = partition(I)
  
  # Sort objects by size, smallest first.
  sorted_objs = order(objs, size)
  
  # Select the two smallest objects.
  smallest_obj = first(sorted_objs)
  second_smallest_obj = first(remove(smallest_obj, sorted_objs))
  
  # Calculate the direction and amount to gravitate the smaller object towards the larger one.
  gravitation_amount = gravitate(smallest_obj, second_smallest_obj)
  
  # Move the smaller object.
  moved_obj = shift(smallest_obj, gravitation_amount)
  
  # Paint the moved object onto the original grid.
  O = paint(I, moved_obj)
  return O
 
512.6666666666666, tensor(0.0079), Description: Copy the left half of the input grid to the top half of the output grid. Then, if the input grid has an even number of rows, mirror the right half of the input grid vertically and copy it to the bottom half of the output grid. Otherwise, rotate the right half of the input grid 270 degrees counterclockwise and copy it to the bottom half of the output grid. Finally, fill the remaining empty space in the output grid with the background color. 
:: def bjiaeadbdjideaeiieceagdbeecccjee(I):
  x1 = lefthalf(I)
  x2 = righthalf(I)
  x3 = vmirror(x2) if even(len(I)) else rot270(x2)
  O = vconcat(hconcat(x1, x3), canvas(0, (height(x1), width(I))))
  return O
 
223.33333333333334, tensor(0.0270), Description: Copy the left half of the input grid to the output grid. Then, if the input grid has an even number of rows, mirror the right half of the input grid vertically and copy it to the right side of the output grid. Otherwise, rotate the right half of the input grid 270 degrees counterclockwise and copy it to the right side of the output grid. The output grid will have the same shapes as the input, but with the right half mirrored vertically or rotated 270 degrees counterclockwise, depending on the number of rows in the input grid. 
:: def bedaefjhcabdeefhadbibeafadffdaji(I):
    x1 = lefthalf(I)
    x2 = righthalf(I)
    x3 = branch(even(len(I)), vmirror(x2), rot270(x2))
    O = paint(canvas(0, shape(I)), asobject(hconcat(x1, x3)))
    return O
 
84.66666666666667, tensor(0.0824), Description: Copy the input grid. For each colored shape in the input grid, if the input grid has an even number of rows, mirror the shape vertically. Otherwise, rotate the shape 270 degrees counterclockwise. Then, merge all the transformed shapes into a single object. Finally, shift the merged object to the top of the output grid, keeping its original columns. The output grid will have the same shapes as the input, but mirrored vertically or rotated 270 degrees counterclockwise, depending on the number of rows in the input grid, and shifted to the top. 
:: def ebjefegchdeeeaiaifibecbhdbhaeahe(I):
    x1 = objects(I, T, F, T)
    x2 =  [(vmirror(obj) if even(len(I)) else rot270(obj)) for obj in x1]
    x3 = merge(x2)
    x4 = ulcorner(x3)
    O = paint(canvas(0, (height(I) // 2, width(I))), shift(x3, (-x4[0], 0)))
    return O
 
80.0, tensor(0.0824), Description: Copy the input grid. For each colored shape in the input grid, if the input grid has an even number of rows, mirror the shape vertically. Otherwise, rotate the shape 270 degrees counterclockwise. Then, merge all the transformed shapes into a single object. Finally, shift the merged object to the top of the output grid, keeping its original columns. The output grid will have the same shapes as the input, but mirrored vertically or rotated 270 degrees counterclockwise, depending on the number of rows in the input grid, and shifted to the top. 
:: def hhcfdcgfibaeeaecigfiaacdbejfgffa(I):
    objs = objects(I, T, F, T)
    transformed_objs = frozenset(vmirror(obj) if even(len(I)) else rot270(obj) for obj in objs)
    top_half = paint(canvas(0, (height(I) // 2, width(I))), merge(transformed_objs))
    return top_half
 
72.33333333333333, tensor(1.9826), Description: Find the smallest colored shape in the input grid. Create a new grid with the same dimensions as the smallest shape and fill it with the normalized version of the smallest shape. The output grid will be the same size as the smallest shape and will contain only the smallest shape, normalized to fit the grid. 
:: def agfcfdfchcececebbhdahjffdfdeegfi(I):
  objs = objects(I, F, F, T)
  min_obj = argmin(objs, size)
  dims = shape(min_obj)
  O = paint(canvas(ZERO, dims), normalize(min_obj))
  return O
 
89.66666666666667, tensor(0.0107), Description: Find the smallest colored shape in the input grid. Create a new grid with the same dimensions as the smallest shape and fill it with the smallest shape, shifted to the top-left corner. The output grid will be the same size as the smallest shape and will contain only the smallest shape, shifted to the top-left corner. 
:: def ieeedgjffdabeheijdcicbffeefdefhi(I):
  objs = fgpartition(I)
  min_obj = argmin(objs, size)
  h, w = shape(min_obj)
  O = paint(canvas(ZERO, (h, w)), shift(min_obj, (-uppermost(min_obj), -leftmost(min_obj))))
  return O
 
227.33333333333334, tensor(0.2268), Description: If the input grid has more blue squares than red squares, then move all blue squares one square to the right. If the input grid has more red squares than blue squares, then move all red squares one square to the right. If the input grid has an equal number of blue and red squares, then move all red squares three squares to the left.  The output grid will have the same shapes as the input, but with the blue or red squares shifted according to the rules above. 
:: def efefdjhfddfbedchiaidjjcafbdhahfc(I):
    target_color = 1 if colorcount(I, 1) > 0 else (6 if colorcount(I, 6) > 0 else 3)
    indices = ofcolor(I, target_color)
    offset = (1, 1) if target_color == 1 else ((3, 0) if target_color == 6 else (-1, 0))
    new_indices = shift(indices, offset)
    O = I
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if (i, j) in indices:
                O = fill(O, 0, {(i, j)})
            if (i, j) in new_indices:
                O = fill(O, target_color, {(i, j)})
    return O
 
183.0, tensor(0.0146), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their height, with the tallest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def hddhhaefgidbedjeijcfaaiidffabebg(I):
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objects(I, univalued=False, diagonal=False, without_bg=True)), width(I)))
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  i = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (i, 0)))
    i += height(obj)
  return O
 
171.0, tensor(0.0142), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def dfdcihbbcgchegbjbbhddcbeiaaadjec(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: ulcorner(obj)[0])
  height_sum = sum(height(obj) for obj in objs)
  O = canvas(mostcolor(I), (height_sum, width(I)))
  i = 0
  for obj in objs:
    O = paint(O, shift(obj, (i - uppermost(obj), 0)))
    i += height(obj)
  return O
 
189.0, tensor(0.0250), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Rotate this rectangle 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated rectangle and fill it with the rotated rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes, rotated to be either taller or wider depending on the original rectangle's dimensions. 
:: def ecdcccjgceahegedbcegidejdgjehbej(I):
  objs = objects(I, False, True, True)
  min_i = min(uppermost(obj) for obj in objs)
  min_j = min(leftmost(obj) for obj in objs)
  max_i = max(lowermost(obj) for obj in objs)
  max_j = max(rightmost(obj) for obj in objs)
  cropped = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  if len(cropped) > len(cropped[0]):
    rotated = rot90(cropped)
  else:
    rotated = rot270(cropped)
  O = canvas(0, shape(rotated))
  O = paint(O, asobject(rotated))
  return O
 
189.0, tensor(0.0250), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Rotate this rectangle 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated rectangle and fill it with the rotated rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes, rotated to be either taller or wider depending on the original rectangle's dimensions. 
:: def dafbibeahaafeeaeagdhcgahacbddceg(I):
  non_zeros = frozenset((i, j) for i, r in enumerate(I) for j, v in enumerate(r) if v != 0)
  min_i, min_j = ulcorner(non_zeros)
  max_i, max_j = lrcorner(non_zeros)
  cropped = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  rotation = rot90 if len(cropped) > len(cropped[0]) else rot270
  O = paint(canvas(0, shape(cropped)), asobject(rotation(cropped)))
  return O
 
6.333333333333333, tensor(0.0117), Description: Copy the top left quadrant of the input grid to the output grid. The output grid will be the same size as the top left quadrant of the input grid. 
:: def feadgccdeahjeaejbfccedhafjcfiicj(I):
    x1 = halve(shape(I))
    O = crop(I, ORIGIN, x1)
    return O
 
78.66666666666667, tensor(0.0062), Description: Rotate the input grid 90 degrees clockwise. Then, take the top half of the rotated grid. Finally, rotate this top half 270 degrees counterclockwise. The output grid will be the top half of the input grid, rotated 180 degrees. 
:: def hebbaciifeabechjbcgbedabeajdbbje(I):
    x1 = rot90(I)
    x2 = tophalf(x1)
    O = rot270(x2)
    return O
 
18.666666666666668, tensor(1.9819), Description: Reduce the size of the input grid by a factor of 2. The output grid will have the same shapes as the input, but with each dimension halved. 
:: def bfcaejfffeabeacbbhdihgdebbbdejba(I):
    x1 = downscale(I, TWO)
    O = x1
    return O
 
229.66666666666666, tensor(0.0119), Description: If the largest colored shape is blue, move it one square to the right and one square down. Otherwise, leave the grid unchanged. The output grid will have the same shapes as the input, but with the largest blue shape potentially shifted. 
:: def chcahebfdbfaecdcibcebaiibedghfhe(I):
  objs = objects(I, T, F, T)
  obj = argmax(objs, size) if objs else frozenset()
  offset = (1, 1) if color(obj) == 2 else (0, 0)
  moved_obj = shift(obj, offset)
  O = paint(canvas(0, shape(I)), moved_obj)
  return O
 
225.33333333333334, tensor(0.0153), Description: If the most common color in the input grid is blue, move all blue squares one square to the right and one square down. Otherwise, leave the grid unchanged. The output grid will have the same shapes as the input, but with the blue squares potentially shifted. 
:: def faebhhidaaddejfgiaaejbiiedbfbcda(I):
    color_to_move = mostcommon([v for row in I for v in row if v != 0])
    shifted_grid = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            if v == color_to_move:
                new_i, new_j = add((i, j), (1, 1) if color_to_move == 2 else (0, 0))
                if 0 <= new_i < height(I) and 0 <= new_j < width(I):
                    shifted_grid = paint(shifted_grid, {(v, (new_i, new_j))})
            else:
                shifted_grid = paint(shifted_grid, {(v, (i, j))})
    return shifted_grid
 
227.0, tensor(0.0153), Description: If the most common color in the input grid is blue, move all blue squares one square to the right and one square down. Otherwise, leave the grid unchanged. The output grid will have the same shapes as the input, but with the blue squares potentially shifted. 
:: def bejhdecaacdeedeajgdbbciaddfdgfea(I):
    target_value = mostcommon([v for r in I for v in r if v != 0])
    obj_indices = ofcolor(I, target_value)
    offset = (1, 1) if target_value == 2 else (0, 0)
    shifted_indices = shift(obj_indices, offset)
    O = canvas(0, shape(I))
    for i, r in enumerate(I):
        for j, v in enumerate(r):
            if (i, j) not in obj_indices:
                O = paint(O, {(v, (i, j))})
    for i, j in shifted_indices:
        if 0 <= i < height(I) and 0 <= j < width(I):
            O = paint(O, {(target_value, (i, j))})
    return O
 
100.66666666666667, tensor(0.0141), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def ecbabgdgaejdeeajbfdbhfddaagbceac(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: color(obj))
  height_sum = sum(height(obj) for obj in objs)
  O = canvas(mostcolor(I), (height_sum, max(width(obj) for obj in objs)))
  i = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (i, 0)))
    i += height(obj)
  return O
 
63.666666666666664, tensor(0.0141), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def cgjcbcjibiedeaccidfdddegdaabeiec(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), (len(objs), max(width(obj) for obj in objs)))
  for i, obj in enumerate(sorted(objs, key=lambda obj: color(obj))):
    O = paint(O, shift(normalize(obj), (i * height(obj), 0)))
  return O
 
90.66666666666667, tensor(0.0157), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. Within each color group, shapes are ordered from left to right based on their center column, with the shape with the rightmost center column being placed furthest to the right. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def jjdgjabaedjiecgejadbcifdaadadffb(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: (color(obj), -centerofmass(obj)[1]))
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objs), max(width(obj) for obj in objs)))
  i = 0
  for obj in objs:
    O = paint(O, shift(obj, (i - uppermost(obj), 0)))
    i += height(obj)
  return O
 
229.66666666666666, tensor(0.0250), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Rotate this rectangle 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated rectangle and fill it with the rotated rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes, rotated to be either taller or wider depending on the original rectangle's dimensions. 
:: def cecefghdbaedebfiafccfiaeebgaedie(I):
  # Identify non-empty rows and columns
  non_empty_rows = tuple(i for i, row in enumerate(I) if any(v != mostcommon(I) for v in row))
  non_empty_cols = tuple(j for j, col in enumerate(zip(*I)) if any(v != mostcommon(I) for v in col))
  
  # Crop the object
  cropped = crop(I, (min(non_empty_rows), min(non_empty_cols)), (max(non_empty_rows) - min(non_empty_rows) + 1, max(non_empty_cols) - min(non_empty_cols) + 1))
  
  # Rotate based on aspect ratio
  rotation = rot90 if height(cropped) > width(cropped) else rot270
  rotated = rotation(cropped)
  
  # Create canvas and paint
  return paint(canvas(mostcommon(I), shape(rotated)), asobject(rotated))
 
78.66666666666667, tensor(0.0251), Description: Copy the top left quadrant of the input grid to the left side of the output grid. Then, if the input grid has an even number of rows, mirror the top left quadrant vertically and copy it to the right side of the output grid. Otherwise, rotate the top left quadrant 270 degrees counterclockwise and copy it to the right side of the output grid. The output grid will have the same shapes as the input, but with the right half mirrored vertically or rotated 270 degrees counterclockwise, depending on the number of rows in the input grid. 
:: def bhejdbhjagaiebdaibddaeabhdabcdhc(I):
  quadrant = crop(I, (0, 0), (height(I) // 2, width(I) // 2))
  reflected_quadrant = branch(even(height(I)), vmirror(quadrant), rot270(quadrant))
  return hconcat(quadrant, reflected_quadrant)
 
78.66666666666667, tensor(1.9734), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The top-right quadrant is mirrored vertically if the input grid has an even number of rows, otherwise it is rotated 270 degrees counterclockwise. The bottom-left quadrant is mirrored horizontally if the input grid has an even number of rows, otherwise it is rotated 90 degrees clockwise. The bottom-right quadrant is kept as is. The output grid is a combination of these four quadrants, with the top-left quadrant in the top-left position, the top-right quadrant in the top-right position, the bottom-left quadrant in the bottom-left position, and the bottom-right quadrant in the bottom-right position. 
:: def jicibbcgjgebeifdaaahbhhcjeagcade(I):
  h, w = height(I) // 2, width(I) // 2
  return tuple(
    tuple(I[i][j] for j in range(w)) + tuple(I[h * 2 - i - 1][j] if even(height(I)) else I[j][w * 2 - i - 1] for j in range(w))
    for i in range(h)
  )
 
78.66666666666667, tensor(0.2153), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The bottom-left quadrant is mirrored vertically if the input grid has an even number of rows, otherwise it is rotated 270 degrees counterclockwise. The output grid is a combination of these two quadrants, with the top-left quadrant in the top-left position and the transformed bottom-left quadrant in the bottom-left position. 
:: def bfbiabgeddcdebhfbcjeggecdcabgeja(I):
    return hconcat(
        crop(I, (0, 0), (height(I) // 2, width(I) // 2)), 
        branch(
            even(height(I)), 
            vmirror(crop(I, (height(I) // 2, 0), (height(I) // 2, width(I) // 2))),
            rot270(crop(I, (0, 0), (height(I) // 2, width(I) // 2)))
        )
    )
 
151.0, tensor(1.9734), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The top-right quadrant is mirrored vertically if the input grid has an even number of rows, otherwise it is rotated 270 degrees counterclockwise. The bottom-left quadrant is mirrored horizontally if the input grid has an even number of rows, otherwise it is rotated 90 degrees clockwise. The bottom-right quadrant is kept as is. The output grid is a combination of these four quadrants, with the top-left quadrant in the top-left position, the top-right quadrant in the top-right position, the bottom-left quadrant in the bottom-left position, and the bottom-right quadrant in the bottom-right position. 
:: def dbahccedefdbegjjacebbebbaccfedca(I):
  h, w = height(I) // 2, width(I) // 2
  return tuple(
    I[i] + tuple(I[h * 2 - i - 1][j] if even(height(I)) else I[j][w * 2 - i - 1] for j in range(w))
    for i in range(h)
  )
 
65.33333333333333, tensor(0.0093), Description: Crop the input grid from the origin to the location of the topmost occurrence of value 2 in the 7th column, plus an offset of (1, 1). The output grid will be a smaller rectangle containing the topmost occurrence of value 2 in the 7th column and the squares above and to the left of it. 
:: def gfgjfjffadheebibbejabjeedehgbeec(I):
    # Find the index of the topmost occurrence of value 2 in the 7th column.
    x1 = tojvec(SIX)
    x2 = extract(asindices(I), rbind(equality, x1))
    # Crop the input grid from origin to the identified location plus (1, 1) offset.
    x3 = increment(x2)
    O = crop(I, ORIGIN, x3)
    return O 
 
83.66666666666667, tensor(0.0096), Description: Find the blue shape with the topmost upper-left corner. Crop the input grid from the origin to the location of the upper-left corner of this blue shape, plus an offset of (1, 1). The output grid will be a smaller rectangle containing the topmost blue shape and the squares above and to the left of it. 
:: def dadhdgiceeicehfbbibbbfedcfgaibfc(I):
    # Find objects with color 2, excluding background.
    x1 = objects(I, T, F, T)
    x2 = colorfilter(x1, TWO)
    # Find the object with the topmost upper-left corner among the filtered objects.
    x3 = argmin(x2, uppermost)
    # Crop the grid based on the object's upper-left corner plus an offset.
    x4 = add(ulcorner(x3), UNITY)
    O = crop(I, ORIGIN, x4)
    return O
 
71.33333333333333, tensor(0.0089), Description: Find the leftmost occurrence of the value '6' in the first row of the input grid. Crop the input grid from the origin to the location of this '6', plus an offset of (1, 1). The output grid will be a smaller rectangle containing the leftmost '6' and the squares above and to the left of it. 
:: def bdajfjdgidfaefgaidhbeidfcfdabajd(I):
    # Transpose the grid.
    x1 = dmirror(I)
    # Find the index of the leftmost '6' in the first row (now the first column).
    x2 = tojvec(ZERO)
    x3 = extract(asindices(x1), rbind(equality, x2))
    # Crop the transposed grid from origin to the identified location plus offset.
    x4 = increment(x3)
    x5 = crop(x1, ORIGIN, x4)
    # Transpose back to get the final cropped grid.
    O = dmirror(x5)
    return O
 
71.0, tensor(0.0088), Description: Find the smallest colored shape in the input grid. Crop the input grid from the origin to the location of the lower-right corner of this shape, plus an offset of (1, 1). The output grid will be a smaller rectangle containing the smallest shape and the squares below and to the right of it. 
:: def edcaacjhdchaehdciddibcbdcaddcfai(I):
    # Find the smallest object.
    x1 = objects(I, F, F, T)
    x2 = argmin(x1, size)
    # Calculate the crop dimensions based on the object's lower-right corner.
    x3 = increment(lrcorner(x2)) 
    O = crop(I, ORIGIN, x3)
    return O
 
68.0, tensor(1.0989), Description: Find the largest colored shape in the input grid. Create a new grid with the same dimensions as the input grid and paint the largest shape onto it. Then, crop the output grid to the size of the largest shape. The output grid will be the same size as the largest shape and will contain only the largest shape. 
:: def abigdaeifaijefhgjdbjeeaadjibijfd(I):
  obj =  max(objects(I, T, F, T), key=len)
  O = paint(canvas(0, shape(I)), obj)
  O = crop(O, (0, 0), (height(obj), width(obj)))
  return O
 
70.66666666666667, tensor(1.0989), Description: Find the largest colored shape in the input grid. Create a new grid with the same dimensions as the input grid and paint the largest shape onto it. Then, crop the output grid to the size of the largest shape. The output grid will be the same size as the largest shape and will contain only the largest shape. 
:: def aafecbcfafddefhcjfhafegadcfbaged(I):
  obj =  extract(objects(I, T, F, T), lambda x: len(x) == max(len(o) for o in objects(I, T, F, T)))
  O = paint(canvas(0, shape(I)), obj)
  O = subgrid(obj, O)
  return O
 
70.66666666666667, tensor(1.9816), Description: Find the largest colored shape in the input grid, considering both the number of squares and the position of the upper-left corner (prioritizing shapes with the leftmost and topmost corners). Create a new grid with the same dimensions as the input grid and paint the largest shape onto it. Then, crop the output grid to the size of the largest shape. The output grid will be the same size as the largest shape and will contain only the largest shape. 
:: def eedfabdgfahfeggabcbfaefagcedffea(I):
  objs = objects(I, T, F, T)
  obj = argmax(objs, lambda o: (len(o), -ulcorner(o)[0], -ulcorner(o)[1]))
  O = paint(canvas(0, shape(I)), obj)
  O = crop(O, ulcorner(obj), shape(obj))
  return O
 
136.33333333333334, tensor(0.0160), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. Within each color group, shapes are ordered from left to right based on their uppermost row, with the shape with the topmost row being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. 
:: def ibcabfeadadgeibcbeafhdafehbhbfad(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: (color(obj), uppermost(obj)))
  O = canvas(mostcolor(I), (max(height(obj) for obj in objs), sum(width(obj) for obj in objs)))
  j = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (0, j)))
    j += width(obj)
  return O 
 
100.0, tensor(0.0140), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def ejbhcbabjfbeeiedbiaiadebfbgfebae(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: leftmost(obj))
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objs), max(width(obj) for obj in objs)))
  i = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (i, 0)))
    i += height(obj)
  return O
 
237.0, tensor(0.0144), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. 
:: def gjfjgefadiidehceiccfhfabcfchbbac(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: uppermost(obj))
  O = canvas(mostcolor(I), (height(I), width(I)))
  j = 0
  for obj in objs:
    O = paint(O, shift(obj, (0, j - leftmost(obj))))
    j += width(obj)
  return O
 
134.66666666666666, tensor(0.0147), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their width, with the widest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. 
:: def jaadcebiecideccebcgicficdccgabjf(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), (max(height(obj) for obj in objs), sum(width(obj) for obj in objs)))
  j = 0
  for obj in objs:
    normalized_obj = normalize(obj)
    O = paint(O, shift(normalized_obj, (0, j)))
    j += width(normalized_obj)
  return O
 
93.33333333333333, tensor(0.0142), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def bfcibejeedfbefbibcabbcecfddadege(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objs), max(width(obj) for obj in objs)))
  i = 0
  for obj in objs:
    O = paint(O, shift(obj, (i - uppermost(obj), 0)))
    i += height(obj)
  return O
 
66.66666666666667, tensor(0.0250), Description: Find the largest colored shape in the input grid. Rotate this shape 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated shape and fill it with the rotated shape. The output grid will be the smallest possible rectangle that encloses the largest shape, rotated to be either taller or wider depending on the original shape's dimensions. 
:: def aaedghfbabfeedjabeibcdaffedfgjjb(I):
  # Find the largest object
  objs = objects(I, False, True, True)
  target_obj = argmax(objs, size)

  # Calculate the dimensions of the output grid
  out_h, out_w = width(target_obj), height(target_obj)

  # Determine rotation direction based on object's dimensions
  rotation = rot90 if height(target_obj) > width(target_obj) else rot270

  # Rotate and place the object on a blank canvas
  return paint(canvas(mostcommon(I), (out_h, out_w)), asobject(rotation(subgrid(target_obj, I)))) 
 
66.33333333333333, tensor(0.0250), Description: Find the largest colored shape in the input grid. Rotate this shape 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated shape and fill it with the rotated shape. The output grid will be the smallest possible rectangle that encloses the largest shape, rotated to be either taller or wider depending on the original shape's dimensions. 
:: def ahcfbfbbcjfcedaajibdcgaifceebaic(I):
  # Find the largest object
  obj = argmax(objects(I, False, True, True), size)

  # Calculate dimensions of the rotated object
  new_h, new_w = width(obj), height(obj)

  # Rotate the object based on dimensions
  rotated_grid = rot90(subgrid(obj, I)) if new_h > new_w else rot270(subgrid(obj, I))
  
  # Paint the rotated object onto a blank canvas
  return paint(canvas(mostcommon(I), (new_h, new_w)), asobject(rotated_grid)) 
 
20.0, tensor(0.5904), Description: Copy the top left quadrant of the input grid. If the input grid has an even number of rows, mirror the top left quadrant vertically. Otherwise, rotate the top left quadrant 270 degrees counterclockwise. Crop the transformed quadrant to the size of the original top left quadrant. The output grid will be the same size as the top left quadrant of the input grid, and will contain either a mirrored or rotated version of the original top left quadrant, depending on the number of rows in the input grid. 
:: def abbgecfgejgheafajjeedicfcdcicfhf(I):
  quadrant = crop(I, (0, 0), (height(I) // 2, width(I) // 2)) # Extract top-left quadrant
  transformed_quadrant = branch(even(height(I)), vmirror(quadrant), rot270(quadrant)) # Transform based on height
  return crop(transformed_quadrant, (0, 0), (height(I) // 2, width(I) // 2)) # Crop to output size
 
6.333333333333333, tensor(0.3513), Description: Copy the input grid. If the input grid has an even number of rows, mirror the input grid vertically. Otherwise, rotate the input grid 270 degrees counterclockwise. Then, crop the transformed grid to the size of the top left quadrant of the original input grid. The output grid will be the same size as the top left quadrant of the input grid, and will contain either a mirrored or rotated version of the original input grid, depending on the number of rows in the input grid. 
:: def fabbabacgiddefcaiehbcffdfebeehdj(I):
  return crop(branch(even(height(I)), vmirror(I), rot270(I)), (0, 0), (height(I) // 2, width(I) // 2))
 
12.666666666666666, tensor(0.4034), Description: Rotate the input grid 270 degrees counterclockwise. If the input grid has an even number of rows, keep the grid as is. Otherwise, reverse each row of the grid. Then, crop the transformed grid to the size of the top left quadrant of the original input grid. The output grid will be the same size as the top left quadrant of the input grid, and will contain either a rotated or a rotated and reversed version of the original input grid, depending on the number of rows in the input grid. 
:: def fbhibggjedjjeddabaaeeafagcdahiff(I):
  return crop(apply(lambda row: row if even(height(I)) else row[::-1], rot270(I)), (0, 0), (height(I) // 2, width(I) // 2))
 
125.0, tensor(0.0093), Description: Find the first occurrence of the value '2' in a row that is greater than the 4th row. Crop the input grid from that location to the end of the grid. The output grid will be a smaller rectangle containing the first occurrence of '2' in a row greater than the 4th row and all the squares below and to the right of it. 
:: def fgfbdbfhbcdeeaeaaddcjbfcdcggfedb(I):
    # Iterate through each row of the grid.
    for i, row in enumerate(I):
        # Iterate through each cell in the row.
        for j, value in enumerate(row):
            # Check if the cell value is '2' and the row index is greater than 4.
            if value == TWO and i > FOUR:
                # Crop the grid from the current cell.
                return crop(I, (i, j), shape(I))
 
165.0, tensor(0.0112), Description: Find the cell with value '2' that is closest to the point (5, 0) in the input grid. Crop the input grid from that cell to the end of the grid. The output grid will be a smaller rectangle containing the closest '2' to (5, 0) and all the squares below and to the right of it. 
:: def daajhbfgjacaecddidejaafdceibicej(I):
    # Find the indices of all cells with value '2'.
    x1 = ofcolor(I, TWO)
    # Define a function to calculate the Manhattan distance from (5, 0).
    dist_func = lambda x: abs(x[0] - FIVE) + abs(x[1])
    # Find the cell with value '2' closest to (5, 0).
    x2 = argmin(x1, dist_func)
    # Crop the grid from the identified cell.
    O = crop(I, x2, shape(I))
    return O
 
223.33333333333334, tensor(0.0099), Description: Find the colored shape that contains a cell with value '2' and a row index greater than 4. Crop the input grid from the top-left corner of this shape to the end of the grid. The output grid will be a smaller rectangle containing the identified shape and all the squares below and to the right of it. 
:: def dbgdgefjfcdbegehaficeaciiceddgfc(I):
  # Find all objects in the grid.
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  # Find the object containing a cell with value '2' and row index greater than 4.
  target_obj = extract(objs, lambda obj: any(v == TWO and i > FOUR for v, (i, j) in obj))
  # Find the top-left corner of the target object.
  corner = ulcorner(target_obj)
  # Crop the grid from the top-left corner of the target object.
  O = crop(I, corner, shape(I))
  return O 
 
85.0, tensor(0.0142), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def dfefebeihafeebdabeaabcfbaidjgdbd(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=lambda obj: (uppermost(obj), leftmost(obj)))
  height_sum = 0
  for obj in objs:
    height_sum += height(obj)
  O = canvas(mostcolor(I), (height_sum, max(width(obj) for obj in objs)))
  i = 0
  for obj in objs:
    O = paint(O, shift(obj, (i - uppermost(obj), 0)))
    i += height(obj)
  return O
 
113.66666666666667, tensor(0.0163), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their row, with the shapes in the top row being placed furthest to the left. Within each row, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def cachdjeceiaceccaibeaacadeciebeed(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), (len(I), max(width(obj) for obj in objs)))
  j = 0
  for i in range(len(I)):
    row_objs = sorted(filter(lambda obj: uppermost(obj) == i, objs), key=lambda obj: leftmost(obj))
    for obj in row_objs:
      O = paint(O, shift(obj, (j, 0)))
      j += height(obj)
  return O
 
92.66666666666667, tensor(0.0138), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their original position in the grid. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def caagcjfbidgfebcdbcdaiahbccfedaai(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  max_width = max(width(obj) for obj in objs)
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objs), max_width))
  current_height = 0
  for i in range(len(I)):
    for j in range(len(I[0])):
      if (I[i][j] != mostcolor(I)):
        obj = extract(objs, lambda obj: (i,j) in toindices(obj))
        O = paint(O, shift(obj, (current_height - uppermost(obj), 0)))
        current_height += height(obj)
        break 
  return O
 
118.66666666666667, tensor(0.0147), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their width, with the widest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. Then, rotate the grid 90 degrees clockwise. 
:: def ggeabjihdbfeegdjbgecchcfeecafjdg(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  max_height = max(height(obj) for obj in objs)
  O = canvas(mostcolor(I), (max_height, sum(width(obj) for obj in objs)))
  current_width = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (0, current_width)))
    current_width += width(obj)
  return rot90(O)
 
83.0, tensor(0.0163), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their row, with the shapes in the top row being placed furthest to the left. Within each row, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def dbbjecjgebciedaajebbafbjcifdabhb(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  max_width = max(width(obj) for obj in objs)
  O = canvas(mostcolor(I), (sum(height(obj) for obj in objs), max_width))
  y = 0
  for obj in sorted(objs, key=lambda obj: (uppermost(obj), leftmost(obj))):
    obj_height = height(obj)
    O = paint(O, shift(obj, (y, 0)))
    y += obj_height
  return O
 
68.66666666666667, tensor(0.0250), Description: Find the largest colored shape in the input grid. Rotate this shape 90 degrees clockwise if it is taller than it is wide, or 270 degrees clockwise if it is wider than it is tall. Create a new grid with the same dimensions as the rotated shape and fill it with the rotated shape. The output grid will be the smallest possible rectangle that encloses the largest shape, rotated to be either taller or wider depending on the original shape's dimensions. 
:: def eadbhdbjbfafeafejcbjbadgjafibcff(I):
  # Find the largest object
  objs = objects(I, False, True, True)
  target_obj = argmax(objs, size)
  
  # Find the bounding box of the largest object
  min_i, min_j = ulcorner(target_obj)
  max_i, max_j = lrcorner(target_obj)
  
  # Crop the grid to the bounding box
  cropped_grid = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  
  # Determine the rotation direction
  rotation = rot90 if max_i - min_i >= max_j - min_j else rot270
  
  # Rotate the cropped object
  rotated_grid = rotation(cropped_grid)
  
  # Paint the rotated object on a new canvas
  canvas_size = shape(rotated_grid)
  O = paint(canvas(mostcommon(I), canvas_size), asobject(rotated_grid))
  return O 
 
78.66666666666667, tensor(0.0331), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored vertically, and then concatenated with the original top-left quadrant. This creates a top half of the output grid. The bottom half of the input grid is kept as is. Finally, the top half and the bottom half are concatenated vertically to form the output grid. The output grid is essentially a combination of the original top-left quadrant, its vertical mirror, and the original bottom half. 
:: def ebedicadebieedefaafccchcabfgacda(I):
    h = height(I) // 2
    w = width(I) // 2
    top_left = crop(I, (0, 0), (h, w)) 
    mirrored = vmirror(top_left)
    return vconcat(top_left, mirrored)
 
78.66666666666667, tensor(0.0331), Description: The input grid is split into four quadrants. The top-left quadrant is mirrored vertically, and then concatenated with the original top-left quadrant. This creates a top half of the output grid. The bottom half of the input grid is kept as is. Finally, the top half and the bottom half are concatenated vertically to form the output grid. The output grid is essentially a combination of the original top-left quadrant, its vertical mirror, and the original bottom half. 
:: def jgcddhbeahaaedbdjbfcficaheebdafd(I):
  q1 = crop(I,(0,0),(height(I)//2, width(I)//2))
  return tuple(q1[i] + q1[len(q1)-i-1] for i in range(len(q1)))
 
66.33333333333333, tensor(0.0895), Description: Find the top-left most object in the input grid. Crop the input grid to the size of this object, starting from its upper-left corner. The output grid will be the same size as the top-left most object and will contain only that object. 
:: def ccabiacefjcaeefeaebgfbddfbddjdbi(I):
    # Directly find the top-left most object
    x1 = objects(I, False, False, True)
    x2 = argmin(x1, lambda obj: ulcorner(obj)[0] * 100 + ulcorner(obj)[1]) # prioritize topmost, then leftmost
    # Crop based on object's dimensions
    O = crop(I, ulcorner(x2), shape(x2))
    return O
 
229.66666666666666, tensor(0.0117), Description: Find the smallest colored shape in the input grid that is not the background color. Move this shape to the center of the grid. The output grid will have the same shapes as the input, but with the smallest non-background shape moved to the center. 
:: def bbcbjfchefdheabfaabacbcbebeehfah(I):
  non_bg_objs = difference(objects(I, T, F, T), colorfilter(objects(I, T, F, T), mostcolor(I)))
  target = min(non_bg_objs, key=lambda obj: sum(ulcorner(obj)))
  O = paint(canvas(0, shape(I)), shift(target, tuple(a // 2 - b // 2 for a, b in zip(shape(I), shape(target)))))
  return O
 
101.66666666666667, tensor(0.0142), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def agdiefjbfcaaegcibeieabacfdhdccea(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  obj_width = width(first(objs))  # Assuming all objects have the same width
  output_height = sum(height(obj) for obj in objs)
  O = canvas(mostcolor(I), (output_height, obj_width))
  current_height = 0
  for obj in objs:
    O = paint(O, shift(obj, (current_height - uppermost(obj), 0)))
    current_height += height(obj)
  return O
 
127.66666666666667, tensor(0.0141), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. 
:: def eggegcejdjfbeddfafaccfbcdccighje(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  output_width = sum(width(obj) for obj in objs)
  max_height = max(height(obj) for obj in objs) 
  O = canvas(mostcolor(I), (max_height, output_width))
  current_width = 0
  for obj in objs:
    O = paint(O, shift(obj, (0, current_width - leftmost(obj))))
    current_width += width(obj)
  return O
 
181.33333333333334, tensor(0.0149), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. Each shape is stretched horizontally to fill the entire width of the output grid. 
:: def daifbceecefaeifaahadbaddeddjaeif(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  output_height = sum(height(obj) for obj in objs)
  output_width = len(I[0])  # Assuming output width matches input width
  O = canvas(mostcolor(I), (output_height, output_width))
  current_height = 0
  for obj in objs:
    obj_width = width(obj)
    stretched_obj = upscale(obj, output_width // obj_width) 
    O = paint(O, shift(stretched_obj, (current_height - uppermost(stretched_obj), 0)))
    current_height += height(stretched_obj)
  return O
 
91.33333333333333, tensor(0.0145), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their size, with the smallest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def ijbjhhdddbefegfbibgffhgfggchahej(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  objs = sorted(objs, key=len) # Sort by object size
  output_height = sum(height(obj) for obj in objs)
  max_width = max(width(obj) for obj in objs)
  O = canvas(mostcolor(I), (output_height, max_width))
  current_height = 0
  for obj in objs:
    O = paint(O, shift(obj, (current_height - uppermost(obj), 0)))
    current_height += height(obj)
  return O
 
88.33333333333333, tensor(0.0141), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def cgdfcdbhjcdbedabbehbicgjgbdafcab(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  objs = sorted(objs, key=lambda obj: color(obj)) # Sort by object color
  output_height = sum(height(obj) for obj in objs)
  max_width = max(width(obj) for obj in objs) 
  O = canvas(mostcolor(I), (output_height, max_width))
  current_height = 0
  for obj in objs:
    O = paint(O, shift(obj, (current_height - uppermost(obj), 0)))
    current_height += height(obj)
  return O
 
68.33333333333333, tensor(0.0207), Description: Find the largest colored shape in the input grid. Rotate this shape 90 degrees clockwise. Create a new grid with the same dimensions as the rotated shape and fill it with the rotated shape. The output grid will be the smallest possible rectangle that encloses the largest shape, rotated 90 degrees clockwise. 
:: def eebdgigciabfedbciaafcjagefaddcdb(I):
  # Find the largest object
  objs = objects(I, False, True, True)
  target_obj = argmax(objs, size)
  
  # Find the bounding box of the largest object
  min_i, min_j = ulcorner(target_obj)
  max_i, max_j = lrcorner(target_obj)
  
  # Crop the grid to the bounding box
  cropped_grid = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  
  # Rotate the cropped object 90 degrees clockwise
  rotated_grid = rot90(cropped_grid)
  
  # Create a canvas with the most common color from the input
  canvas_size = shape(rotated_grid)
  O = paint(canvas(mostcommon(I), canvas_size), asobject(rotated_grid))
  return O
 
229.66666666666666, tensor(0.0066), Description: Rotate the input grid 90 degrees clockwise. Then, take the top half of the rotated grid and concatenate it horizontally with a blank canvas of the same size, filled with the background color. Finally, rotate this concatenated grid 270 degrees counterclockwise. The output grid will be the top half of the input grid, rotated 180 degrees and extended horizontally with the background color. 
:: def deeffhiahhbeefgcabhihbcadacfgbif(I):
  x1 = rot90(I)
  x2 = tophalf(x1)
  x3 = hconcat(x2, canvas(mostcolor(I), shape(x2)))
  O = rot270(x3)
  return O
 
110.0, tensor(0.0077), Description: Rotate the left half of the input grid 90 degrees clockwise. Then, concatenate the rotated left half with a blank canvas of the same height and the original width minus the width of the rotated left half. The blank canvas should be filled with the background color of the input grid. The output grid will have the left half of the input grid rotated 90 degrees clockwise and placed on the left side, with the remaining space filled with the background color. 
:: def dhbgbabcchgaeeidigcbcgiajdafcdaj(I):
  w = width(I)
  x1 = lefthalf(I)
  x2 = rot90(x1)
  O = hconcat(x2, canvas(mostcolor(I), (height(x2), w - width(x2))))
  return O
 
187.66666666666666, tensor(0.0519), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Crop the input grid to this rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes. 
:: def hchjfjfdgdfdejdeiacfjcfecjighagd(I):
  objs = objects(I, T, F, T) 
  min_i = min(uppermost(obj) for obj in objs)
  max_i = max(lowermost(obj) for obj in objs)
  min_j = min(leftmost(obj) for obj in objs)
  max_j = max(rightmost(obj) for obj in objs)
  O = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  return O
 
189.0, tensor(0.0199), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Rotate this rectangle 90 degrees clockwise. Create a new grid with the same dimensions as the rotated rectangle and fill it with the rotated rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes, rotated 90 degrees clockwise. 
:: def ebfcaaabdebaedbcidfdaibbdcffaaeg(I):
  objs = objects(I, T, F, T)
  min_i = min(uppermost(obj) for obj in objs)
  max_i = max(lowermost(obj) for obj in objs)
  min_j = min(leftmost(obj) for obj in objs)
  max_j = max(rightmost(obj) for obj in objs)
  cropped = crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1))
  O = rot90(cropped)
  return O
 
20.333333333333332, tensor(0.0085), Description: Crop the input grid from the origin to the location (10, 8). The output grid will be a smaller rectangle containing the top-left portion of the input grid, up to row 10 and column 8. 
:: def bedgceccaghdebbejffcahcgejjgfdhe(I):
  O = crop(I, (0, 0), (10, 8))
  return O
 
71.0, tensor(1.9946), Description: Find the first colored shape in the input grid. Create a new grid with the same dimensions as the shape and fill it with the normalized version of the shape. The output grid will be the same size as the shape and will contain only the shape, normalized to fit the grid. 
:: def hebgiigcaccgeifdbajbbcgcdiccdadc(I):
  obj = first(objects(I, T, F, T))
  O = paint(canvas(0, shape(obj)), normalize(obj))
  return O
 
119.33333333333333, tensor(1.9819), Description: Remove the top and bottom rows of the grid if they contain any non-zero values. Then, rotate the grid 180 degrees and remove the top and bottom rows again if they contain any non-zero values. The output grid will be a smaller version of the input grid, with the top and bottom rows removed. 
:: def eddacaeecdfcechbbhaacddhaigicaaf(I):
  O = I
  while any(v != 0 for v in O[0]):
    O = trim(O)
  while any(v != 0 for v in O[-1]):
    O = trim(rot180(O))
  return O
 
62.333333333333336, tensor(0.0163), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their row, with the shapes in the top row being placed furthest to the left. Within each row, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def aefcbjiadjeeebidbgdebjdechgfehee(I):
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    unique_objs = list(dict.fromkeys(sorted(objs, key=lambda obj: (uppermost(obj), leftmost(obj)))))
    max_width = max(width(obj) for obj in unique_objs)
    O = canvas(mostcolor(I), (len(unique_objs), max_width))
    for i, obj in enumerate(unique_objs):
        obj_normalized = normalize(obj)
        for (v, (pi, pj)) in obj_normalized:
            O = paint(O, {(v, (i, pj))}) 
    return O
 
62.333333333333336, tensor(0.0154), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. Within each row, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. 
:: def bhecebahaacjefgeiaegeeaaabgcccdh(I):
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    unique_objs = set(tuple(sorted(obj)) for obj in objs)
    O = canvas(mostcolor(I), (len(unique_objs), max(width(obj) for obj in unique_objs)))
    for i, obj in enumerate(sorted(unique_objs, key=lambda obj: next((i for _, (i, j) in obj), (0, 0)))):
        for v, (pi, pj) in obj:
            O = paint(O, {(v, (i, pj))})
    return O
 
89.66666666666667, tensor(0.0124), Description: Move all colored shapes to the left side of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their uppermost row. Within each row, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the left and stacked horizontally. Only unique shapes are stacked, meaning if a shape appears multiple times, it will only be stacked once. 
:: def fccihcbddffcebhfjaedccgfegbhidjf(I):
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    seen_objects = set()
    filtered_objects = []
    for obj in objs:
        obj_hash = hash(tuple(sorted(obj)))
        if obj_hash not in seen_objects:
            seen_objects.add(obj_hash)
            filtered_objects.append(obj)
    max_height = sum([height(obj) for obj in filtered_objects])
    max_width = max([width(obj) for obj in filtered_objects])
    O = canvas(mostcolor(I), (max_height, max_width))
    current_height = 0
    for obj in filtered_objects:
        for v, (i, j) in obj:
            O = paint(O, {(v, (i + current_height, j))})
        current_height += height(obj)
    return O
 
228.66666666666666, tensor(1.2395), Description: Reflect the largest colored shape diagonally. The output grid will have the same shape as the input, but with the largest colored shape mirrored diagonally. 
:: def dfgfbfgigbgcedcdjiccjeecddcdcccf(I):
  objs = objects(I, T, F, T)
  obj = argmax(objs, size) if objs else frozenset()
  O = paint(canvas(mostcolor(I), shape(I)), 
            frozenset(((c, (j, i)) for c, (i, j) in obj))) # Rotate during painting
  return O
 
187.66666666666666, tensor(0.0433), Description: Find the smallest rectangle that encloses all the colored shapes in the input grid. Crop the input grid to this rectangle. The output grid will be the smallest possible rectangle that encloses all the colored shapes. 
:: def bccbbefaedfaechabdbgbdaefjcjdeja(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  min_i = min(uppermost(obj) for obj in objs)
  max_i = max(lowermost(obj) for obj in objs)
  min_j = min(leftmost(obj) for obj in objs)
  max_j = max(rightmost(obj) for obj in objs)
  return crop(I, (min_i, min_j), (max_i - min_i + 1, max_j - min_j + 1)) 
 
164.0, tensor(0.0786), Description: The input grid is split horizontally into two halves. The top half is downscaled by a factor of 2, and then concatenated horizontally with a mirrored and downscaled version of itself. The bottom half of the input grid is kept as is. Finally, the top half and the bottom half are concatenated vertically to form the output grid. The output grid is essentially a combination of a downscaled and mirrored top half, and the original bottom half. 
:: def jehajjghdfbheejdjfdbeibafdbbccaa(I):
  return vconcat(hconcat(downscale(crop(I, (0, 0), (height(I) // 2, width(I))), 2), downscale(hmirror(crop(I, (0, 0), (height(I) // 2, width(I)))), 2)), canvas(0, (height(I) // 2, width(I))))
 
85.0, tensor(0.0133), Description: Rotate the largest colored shape 90 degrees clockwise. Then, shift the rotated shape to the right half of the output grid, keeping its original row. The output grid will be half the height of the input grid and will contain only the rotated and shifted largest shape. 
:: def efhahfbageaeeceajdfgbgbebdfeffdj(I):
  objs = objects(I, T, F, T) # Extract objects, excluding background
  obj = argmax(objs, size) if objs else frozenset() # Find the largest object
  rotated_obj = asobject(rot90(crop(canvas(0, shape(I)), ulcorner(obj), shape(obj)))) # "Rotate" the object
  shifted_obj = shift(rotated_obj, (0, width(I)//2)) # Shift to the right half 
  O = paint(canvas(mostcolor(I), (height(I)//2, width(I))), shifted_obj) # Paint on a blank canvas
  return O
 
85.0, tensor(0.0119), Description: Rotate the largest colored shape 90 degrees clockwise. Then, shift the rotated shape to the right half of the output grid, keeping its original row. The output grid will be the same height as the left half of the input grid and will contain only the rotated and shifted largest shape. The background color of the output grid will be the same as the background color of the input grid. 
:: def biebbhacaiibeagfaccgeacbbbfbeffg(I):
  left = lefthalf(I) # Extract left half
  objs = objects(I, T, F, T)
  obj = argmax(objs, lambda o: (size(o), -height(o), width(o))) if objs else frozenset() # Find object based on size, then height, then inverse width
  rotated_obj = asobject(rot90(crop(canvas(0, shape(I)), ulcorner(obj), shape(obj)))) 
  shifted_obj = shift(rotated_obj, (0, width(I)//2)) 
  O = paint(canvas(mostcolor(I), shape(left)), shifted_obj) # Use left half's shape for the canvas
  return O
 
890.3333333333334, tensor(0.0193), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. Within each color group, shapes are ordered from left to right based on their width, with the widest shape being placed furthest to the left. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. The output grid will have a maximum width of 100.  There will be a space of 1 square between each group of shapes with the same color. 
:: def hccbicfdeedeeeabbdagbbebbafaefdi(I):
  objs = sorted(objects(I, univalued=False, diagonal=False, without_bg=True), key=color)
  max_height = max(height(obj) for obj in objs)
  O = canvas(mostcolor(I), (max_height, 100))  # Assuming maximum output width of 100
  x = 0
  prev_color = None
  for obj in objs:
    if color(obj) != prev_color:
      x = 0
      prev_color = color(obj)
    O = paint(O, shift(normalize(obj), (0, x)))
    x += width(obj) + 1 
  return O
 
235.66666666666666, tensor(0.0208), Description: Downscale the input grid by a factor of 2. Then, take the top half of the downscaled grid and for each row, concatenate the left half of the row with the reversed right half of the row. Finally, concatenate the resulting grid with a blank canvas of the same width and half the height of the input grid, filled with the background color. The output grid will be the same width as the input grid and half the height, with the top half containing a mirrored version of the top half of the downscaled input grid. 
:: def ccfeihbfabcfehfcbeebcacecgcccefd(I):
  return vconcat(tuple(row[:width(I)//2] + row[:width(I)//2][::-1] for row in downscale(I, 2)[:height(I)//2]), canvas(0, (height(I) // 2, width(I)))) 
 
229.66666666666666, tensor(0.0120), Description: Copy the top left quadrant of the input grid and shift it to the bottom right quadrant of the output grid. The output grid will be the same size as the input grid, with the top left quadrant moved to the bottom right. 
:: def igidcffadcajebdbjdbfcjificeijabi(I):
  return paint(canvas(0, shape(I)), toobject(shift(asindices(crop(I, (0, 0), divide(shape(I), 2))), divide(shape(I), 2)), I))
 
229.66666666666666, tensor(0.0107), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The top-right quadrant is kept as is. The bottom-left quadrant is kept as is. The bottom-right quadrant is kept as is. The output grid is a combination of these four quadrants, with the top-left quadrant in the top-left position, the top-right quadrant in the top-right position, the bottom-left quadrant in the bottom-left position, and the bottom-right quadrant in the bottom-right position. 
:: def chafegbabbcbebafagijbceffbbfajdf(I):
  h, w = shape(I)
  tl = crop(I, (0, 0), (h//2, w//2))
  O = vconcat(canvas(0, (h//2, w)), hconcat(canvas(0, (h//2, w//2)), tl))
  return O
 
63.333333333333336, tensor(0.0493), Description: Find the largest colored shape in the input grid. Create a new grid with the same dimensions as the input grid and paint the largest shape onto it. Then, crop the output grid to the size of the largest shape, but swap the rows and columns. The output grid will be the same size as the largest shape, but with the rows and columns swapped. 
:: def ihhiidaccaafehcdbbadbaaajhcifffd(I):
  objs = objects(I, False, False, True)
  obj = max(objs, key=size)
  O = paint(canvas(0, shape(I)), obj)
  O = crop(O, ulcorner(obj)[::-1], shape(obj)[::-1])
  return O
 
192.66666666666666, tensor(0.0259), Description: Find the largest colored shape in the input grid. Crop the input grid to the size of this shape, but swap the rows and columns. The output grid will be the same size as the largest shape, but with the rows and columns swapped. 
:: def aahgcbajjbhdejebbcgfjfdccfbdfcae(I):
  obj = max(partition(I), key=len)
  return crop(I, ulcorner(obj)[::-1], shape(obj)[::-1])
 
844.6666666666666, tensor(0.0225), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. Within each color group, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. The output grid will have a maximum height of 30. There will be a space of 1 square between each group of shapes with the same color. 
:: def dbefaibeehijeaahaaddehffcdafcche(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), (30, 30))  # Assuming maximum output dimension of 30x30
  y = 0
  for c in sorted(palette(I) - {mostcolor(I)}):
    for obj in sorted(colorfilter(objs, c), key=lambda o: leftmost(o)):
      O = paint(O, shift(normalize(obj), (y, -leftmost(obj) + y)))
      y += height(obj) + 1
    y += 1
  return O
 
242.66666666666666, tensor(0.0151), Description: Move all colored shapes to the top of the grid, stacking them horizontally. The shapes should be ordered from left to right based on their color, with the lowest color being placed furthest to the left. Within each color group, shapes are ordered from left to right based on their leftmost column. The output grid will have the same shapes as the input, but shifted to the top and stacked horizontally. There will be a space of 1 square between each group of shapes with the same color. 
:: def fdfgjciicgdceeaaaccccgdejccefjjj(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  O = canvas(mostcolor(I), shape(I)) # Output grid same shape as input
  y = 0
  for c in sorted(palette(I) - {mostcolor(I)}):
    x = 0
    for obj in sorted([o for o in objs if color(o) == c], key=lambda o: leftmost(o)):
      O = paint(O, shift(normalize(obj), (y, x)))
      x += width(obj) + 1
    y += max([height(o) for o in objs if color(o) == c], default=0) + 1
  return O
 
235.66666666666666, tensor(0.0183), Description: The input grid is split into four quadrants. The top-left quadrant is kept as is. The top-right quadrant is mirrored horizontally. The bottom-left quadrant is filled with zeros (black). The bottom-right quadrant is mirrored horizontally. The output grid is a combination of these four quadrants, with the top-left quadrant in the top-left position, the mirrored top-right quadrant in the top-right position, the black bottom-left quadrant in the bottom-left position, and the mirrored bottom-right quadrant in the bottom-right position. 
:: def ibcbfjhffahjeefgihbdicdficcbejha(I):
  return tuple(tuple(I[i//2][j//2] if i < height(I) // 2 and j < width(I) else I[i//2][width(I) - 1 - j//2] if i < height(I) // 2 else 0 for j in range(width(I))) for i in range(height(I)))
 
229.66666666666666, tensor(0.0121), Description: Copy the top left quadrant of the input grid and shift it to the bottom right quadrant of the output grid. The output grid will be twice the size of the input grid, with the top left quadrant moved to the bottom right. 
:: def adcbceejafadebjgjehfjjaejfbjfjgb(I):
  h = height(I) // 2
  w = width(I) // 2
  O = canvas(0, (h * 2, w * 2)) # Create a zero-filled canvas of double the size
  O = paint(O, toobject(shift(asindices(crop(I, (0, 0), (h, w))), (h, w)), crop(I, (0, 0), (h, w)))) # Directly paint shifted quadrant
  return O
 
