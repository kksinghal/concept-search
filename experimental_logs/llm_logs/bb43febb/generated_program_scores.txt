4.0, tensor(1.0693), Description: Recolor the inner part of the largest object in the input grid to red.  Keep the original colors of the outer border of the object. 
:: def bjhhhjfibaabefhdbhaifdeabbibaiec(I):
    obj = argmax(objects(I, T, F, T), size)  # Find the largest object
    inner =  inbox(obj) # Find indices one cell inside the object's bounding box
    recolored = recolor(TWO, toobject(inner, I)) # Recolor the inner part
    O = paint(I, recolored) # Paint the recolored object onto the original grid
    return O 
 
2.5, tensor(1.0693), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def aahedjbdcggceaeajcbjdhdgfiaefiid(I):
    obj = argmax(objects(I, T, F, T), size) # Find the largest object
    border = box(obj)  # Find indices outlining the object
    inner = difference(backdrop(obj), border) # Find the indices inside but not on the border
    recolored = recolor(TWO, toobject(inner, I)) # Recolor the inner part
    O = paint(I, recolored) # Paint the recolored object onto the original grid
    return O
 
21.5, tensor(0.0795), Description: Recolor all objects in the input grid except the largest object to red. Keep the original color of the largest object. 
:: def befhhaccffaaehidjcafbhefgcfjfeei(I):
    objs = objects(I, T, F, T) # Find all objects
    obj = argmax(objs, size) # Find the largest object
    other_objs = difference(objs, {obj}) # Objects other than largest
    O =  fill(I, TWO, mfilter(other_objs, backdrop))
    O = paint(O, obj) # Paint the object back onto the recolored grid
    return O
 
0.0, tensor(0.0908), Description: For each object in the input grid that is larger than 1x1, fill in the interior of the object with red. Leave the outer border of the object in its original color. 
:: def hdcbfaaeefcheiadadjefjifejcefbad(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if height(obj) > 1 and width(obj) > 1:
      for i in range(1, height(obj)-1):
        for j in range(1, width(obj)-1):
          O = paint(O, {(TWO, add(ulcorner(obj), (i, j)))})
  return O
 
9.0, tensor(0.1339), Description: Recolor the interior of all objects in the input grid that are larger than 4 squares to red. Leave the outer border of the object in its original color. 
:: def fghafgdfejdgececidbadefjjcajjjfe(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if size(obj) > 4:
      h = height(obj)
      w = width(obj)
      ul = ulcorner(obj)
      inner_region = difference(
        difference(
            backdrop(obj),
            {(ul[0], j) for j in range(ul[1], ul[1] + w)}
        ),
        {(ul[0] + h - 1, j) for j in range(ul[1], ul[1] + w)}
      )
      O = fill(O, TWO, intersection(toindices(obj), inner_region))
  return O
 
4.0, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def daefiaahcffdeeddacacjbcaibficiii(I):
  x1 = objects(I, F, F, T)  # Extract objects, excluding background
  x2 = argmax(x1, size)     # Find the largest object
  x3 = inbox(x2)            # Get the inbox indices of the largest object
  O = fill(I, TWO, x3)      # Fill the inbox with value 2
  return O
 
13.0, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def faihabbccgebehdbjjejgcbfbbegbgba(I):
  x1 = objects(I, F, F, T)  # Extract objects, excluding background
  x2 = max(x1, key=len)      # Find the largest object by size
  x3 = delta(x2)            # Find the indices in the bounding box but not in the object
  x4 = inbox(x2)            # Find the inbox indices
  x5 = intersection(x3, x4) # Intersect to ensure we only fill inside the object
  O = fill(I, TWO, x5)      # Fill the intersected indices with value 2
  return O
 
18.5, tensor(0.0304), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def ecccedejadcceidabehafdgedhbjehcf(I):
  x1 = partition(I)          # Partition the grid into objects based on color
  x2 = remove(first(x1), x1) # Assuming background is the first object, remove it
  x3 = argmax(x2, size)     # Find the largest object by size
  x4 = toindices(x3)        # Extract the indices of the largest object
  x5 = inbox(x4)            # Calculate the inbox indices
  O = underfill(I, TWO, x5) # Fill the inbox with value 2 only under background
  return O
 
1.5, tensor(0.1350), Description: Recolor the inner part of all objects in the input grid that are larger than 4 squares to red. Keep the original colors of the outer border of the object. 
:: def ehiacbafifgbebdiabafijidjeadcbfe(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  recolored_objs = frozenset({recolor(TWO, inbox(obj)) if size(obj) > 4 else obj for obj in objs})
  O = I
  for obj in recolored_objs:
    O = paint(O, obj)
  return O 
 
37.5, tensor(0.1368), Description: Recolor the inner part of all objects in the input grid that are larger than 4 squares to red. Keep the original colors of the outer border of the object and the background. 
:: def ciicjffbghfbeecdiecbdiddaedbifce(I):
  O = I
  for value in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, value), I)
    recolored_obj = recolor(TWO, inbox(obj)) if size(obj) > 4 else obj
    O = paint(cover(O, obj), recolored_obj)
  return O
 
1.5, tensor(0.1368), Description: Recolor the inner part of all objects in the input grid that are larger than 4 squares to red. Keep the original colors of the outer border of the object and the background. 
:: def hbfjeficibbeejhdaedacdfafdffebed(I):
  modified_grid = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if size(obj) > 4:
      modified_grid = underpaint(modified_grid, recolor(TWO, inbox(obj)))
      modified_grid = underpaint(modified_grid, toobject(box(obj), I)) 
    else:
      modified_grid = underpaint(modified_grid, obj)
  return modified_grid
 
36.5, tensor(0.8243), Description: For each object in the input grid, recolor all the squares except the top row, bottom row, and leftmost column to the object's original color. Keep the original colors of the top row, bottom row, and leftmost column. The background should be black. 
:: def aiadfecdaeafebfdbfgfacidggdceeei(I):
  objs = objects(I, T, F, T)  # Find all objects
  modified_objs = frozenset()
  for obj in objs:
    obj_indices = toindices(obj)
    top_row = uppermost(obj_indices)
    bottom_row = lowermost(obj_indices)
    left_col = leftmost(obj_indices)
    modified_indices = frozenset((i, j) for i, j in obj_indices 
                                 if i != top_row and i != bottom_row and j != left_col)
    modified_objs = insert(recolor(color(obj), modified_indices), modified_objs) 
  O = fill(I, ZERO, asindices(I))
  for obj in modified_objs:
    O = paint(O, obj)
  return O 
 
24.0, tensor(0.0831), Description: For each object in the input grid that is larger than 2 squares, remove the top and bottom rows of the object and recolor the remaining squares to the object's original color. Keep the original colors of the top and bottom rows. The background should be black. 
:: def hfehjfbcdjifedeajefecbdacffbadad(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if size(obj) > 2:
      eroded_obj = toobject(
          difference(
              toindices(obj),
              combine(
                  {(uppermost(obj), j) for j in range(leftmost(obj) + 1, rightmost(obj))},
                  {(lowermost(obj), j) for j in range(leftmost(obj) + 1, rightmost(obj))},
              ),
          ),
          I,
      )
      O = underpaint(cover(O, obj), eroded_obj)
  return O
 
13.5, tensor(1.1918), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the color '5'. Then, fill the interior of the object with the color '2'. The background should be black. 
:: def deabhegedacfeebcjedddfafffcfdffb(I):
    O = fill(canvas(ZERO, shape(I)), ZERO, asindices(I)) # Create empty canvas
    objs = objects(I, T, F, T)
    for obj in objs:
        if len(obj) > 1:
            O = paint(O, recolor(FIVE, box(obj))) # Draw the border
            O = underfill(O, TWO, shift(backdrop(obj), (1,1))) # Fill the inside with '2'
    return O
 
11.0, tensor(1.1810), Description: For each square in the input grid that is surrounded by four squares of the same color, change that square to red. Leave all other squares in their original color. 
:: def abdacbcfeabhehbajgbdjhefejheijee(I):
    O = I
    for i in range(1, height(I)-1):
        for j in range(1, width(I)-1):
            if index(I, (i,j)) == index(I, (i-1,j)) == index(I, (i+1,j)) == index(I, (i, j-1)) == index(I, (i, j+1)):
                O = paint(O, {(TWO, (i,j))}) # Change to '2' if surrounded by the same color
    return O
 
19.5, tensor(0.0656), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. Then, replace the largest object with the background color. Finally, place the recolored inner part back into the original grid, maintaining its original position. 
:: def ajjjijhfaeaheadcbchfbbeifegjfbej(I):
  x1 = objects(I, F, F, T)  # Extract objects, excluding background
  x2 = argmax(x1, size)     # Find the largest object by size
  x3 = ulcorner(x2)         # Find the upper-left corner of the object
  x4 = (add(x3, (1,1)), subtract(shape(x2), (2,2)))  # Calculate inner rectangle dimensions
  x5 = crop(I, x4[0], x4[1]) # Crop the inner rectangle from the original grid
  x6 = fill(x5, TWO, asindices(x5)) # Fill the cropped rectangle with '2'
  x7 = paint(I, recolor(ZERO, x2))  # Paint the largest object with background color
  O = paint(x7, shift(asobject(x6), x4[0]))  # Paint the filled rectangle back into position
  return O
 
19.5, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def cifgiageadgeeaadbbaaddbdehedhfce(I):
  x1 = objects(I, F, F, T)  # Extract objects, excluding background
  x2 = argmax(x1, size)     # Find the largest object by size
  x3 = toindices(x2)        # Get the indices of the object
  x4 = box(x3)               # Get the bounding box indices
  x5 = difference(x4, x3)    # Remove object indices from the bounding box
  x6 = difference(x3, x5)    # Remove border indices from object indices
  O = fill(I, TWO, x6)       # Fill the remaining indices with TWO
  return O
 
19.5, tensor(0.0656), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. Then, replace the largest object with the background color. Finally, place the recolored inner part back into the original grid, maintaining its original position. 
:: def bhjefcebedeaebadbjacchafaaejgeda(I):
  x1 = objects(I, F, F, T)  # Extract objects
  x2 = argmax(x1, size)     # Find the largest object
  x3 = ulcorner(x2)         # Get the upper-left corner
  x4 = subtract(shape(x2), (2, 0))  # Calculate new dimensions
  x5 = crop(I, add(x3, (1, 0)), x4) # Crop from the second row
  x6 = fill(x5, TWO, asindices(x5)) # Fill the cropped grid with '2'
  x7 = paint(I, recolor(ZERO, x2))  # Paint largest object with background
  O = paint(x7, shift(asobject(x6), add(x3, (1, 0)))) # Paint the filled grid
  return O
 
21.5, tensor(0.0567), Description: Recolor the inner part of the largest object in the input grid that is also the lowest object to red. Keep the original colors of the outer border of the object. 
:: def cjeeeahfififeaejjagabefjbhjcefcc(I):
  x1 = objects(I, F, F, T)  # Extract objects, excluding background
  x2 = lambda obj: (size(obj), -ulcorner(obj)[0]) # Custom sorting function
  x3 = first(order(x1, x2)) # Get the largest, lowest object
  x4 = toindices(x3)        # Get the indices of the object
  x5 = rbind(contained, x4) # Check if index is in the object
  x6 = lambda i: any(apply(x5, dneighbors(i))) # Check for neighbors within object
  x7 = sfilter(x4, x6)       # Filter for indices with internal neighbors 
  O = fill(I, TWO, x7)       # Fill those indices with TWO
  return O
 
0.0, tensor(0.1350), Description: Recolor the inner part of all objects in the input grid that are larger than 4 squares to red. Keep the original colors of the outer border of the object. 
:: def jcccfeaidejeegbgbaebbidgbighdbbf(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if size(obj) > 4:
      inner_box = difference(backdrop(obj), box(obj))
      O = paint(O, recolor(TWO, intersection(toindices(obj), inner_box)))
  return O
 
13.0, tensor(0.1368), Description: Recolor the inner part of all objects in the input grid that are larger than 4 squares to red. Keep the original colors of the outer border of the object and the background. 
:: def egjheeedfahfehfeieccfdabfhcgbedc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if size(obj) > 4:
      obj = difference(obj, toobject(inbox(obj), I))
    O = paint(O, obj)
  return O
 
46.0, tensor(1.5954), Description: For each object in the input grid that is larger than 4 squares, shift the object one square to the right and one square down, and recolor the inner part of the shifted object to red. Keep the original colors of the outer border of the object and the background. 
:: def dbfdbifjabfceajabecgajdbdehdfbfj(I):
  O = I
  for value in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, value), I)
    if size(obj) > 4:
      shifted_obj = shift(obj, (1, 1))
      O = underpaint(cover(O, obj), shifted_obj)
      O = underfill(O, TWO, shift(inbox(obj), (1, 1)))
  return O
 
10.0, tensor(1.1175), Description: Recolor all squares in the largest object in the input grid to red, except for the top and right edges of the object. Keep the original colors of the top and right edges. 
:: def hijfdbcahabaeifebbhdfdbhbcfccccc(I):
  obj = argmax(objects(I, T, F, T), size)
  right_edge =  sfilter(toindices(obj), lambda loc: (loc[0], loc[1] + 1) not in toindices(obj))  # Identify right edge indices
  top_edge =  sfilter(toindices(obj), lambda loc: (loc[0] - 1, loc[1]) not in toindices(obj)) # Identify top edge indices
  O = fill(I, TWO, toindices(obj) - right_edge - top_edge) # Fill everything except the top and right edges with '2'
  return O
 
22.0, tensor(0.0273), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def dbeebeafefafedaebajejfhcefbdaeej(I):
  obj = argmax(objects(I, T, F, T), size)
  inner_box =  crop(I, add(ulcorner(obj), (1,1)), subtract(shape(obj), (1,1))) # Extract the inner box as a subgrid
  filled_inner = fill(inner_box, TWO, asindices(inner_box)) # Fill the extracted subgrid with '2'
  O = paint(I, toobject(asindices(filled_inner), filled_inner))  # Paint the filled subgrid back onto the original grid
  return O
 
38.5, tensor(1.9893), Description: For each object in the input grid that is larger than 1x1, copy the inner part of the object (excluding the border) to the output grid, maintaining its original position. The background of the output grid should be black. 
:: def figdfdjfbdgbeeiajfdhedaijbbagcfd(I):
  objs = objects(I, T, F, T)  # Extract objects from the grid
  O = fill(I, ZERO, asindices(I))  # Create an empty grid of the same size
  for obj in objs:
    if size(obj) > 1: 
      O = paint(O, shift(toobject(inbox(obj), I), ulcorner(obj)))  # Paint the inbox of each object onto the empty grid
  return O
 
45.5, tensor(1.0710), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the object's original color. Then, fill the interior of the object with black. The background should be black. 
:: def ddbahdgebgiaeabfaeagiibbiaeibjeb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if size(obj) > 1:
      O = underpaint(fill(O, ZERO, obj), shift(toobject(box(obj), I), ulcorner(obj))) 
  return O
 
38.0, tensor(1.0710), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the object's original color. Then, fill the interior of the object with black. The background should be black. 
:: def abcbebajeejfeeafidffdcbcbagdafij(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      inner = difference(backdrop(obj), box(obj)) 
      O = paint(fill(O, ZERO, obj), shift(toobject(inner, I), ulcorner(obj)))
  return O
 
41.0, tensor(1.9890), Description: For each object in the input grid that is larger than 1x1, extract the object, trim its border, and paint it onto a blank canvas of the same size as the input grid, shifted one square to the right and one square down from its original position. The background of the output grid should be black. 
:: def adiabdeaigefeegiabfdedbcdfdjbdaf(I):
  O = canvas(ZERO, shape(I)) # Create a blank canvas
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      trimmed = trim(subgrid(obj, I)) # Extract and trim the object
      O = paint(O, shift(asobject(trimmed), add(ulcorner(obj), UNITY))) # Paint at offset position
  return O
 
1.5, tensor(0.1411), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object. 
:: def fdebedbcfbddeaeajefaaeebcfdbaeff(I):
    O = I
    objs = objects(I, T, F, T)
    for obj in objs:
      if len(obj) > 1:
        border = difference(backdrop(obj), inbox(obj))
        O = paint(O, recolor(TWO, difference(toindices(obj), border)))
    return O
 
14.0, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def ibadcffdeaafeaibafecahhechehccee(I):
  x1 = partition(I)            # Partition grid into objects based on color
  x2 = remove(first(x1), x1)   # Remove the background object (assuming it's the first)
  x3 = argmax(x2, size)       # Find the largest object
  x4 = toindices(x3)          # Get indices of the largest object
  x5 = inbox(x4)              # Find the inbox indices
  O = fill(I, TWO, x5)          # Fill the inbox with '2'
  return O
 
16.0, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def bceefdhfjafjeaaabdegffjdigajggab(I):
  x1 = partition(I)            # Partition grid into objects based on color
  x2 = remove(first(x1), x1)   # Remove the background object (assuming it's the first)
  x3 = argmax(x2, size)       # Find the largest object
  x4 = backdrop(x3)           # Get the backdrop indices of the largest object
  x5 = toindices(x3)          # Get indices of the largest object
  x6 = difference(x4, x5)      # Find the difference between backdrop and object indices (the 'border')
  x7 = inbox(x6)              # Calculate the inbox of the 'border' (desired area)
  O = fill(I, TWO, x7)          # Fill the calculated area with '2'
  return O 
 
29.5, tensor(0.1387), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def fdddbfaffaadeaeababdajjehcbjccbi(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    recolored_obj = recolor(TWO, inbox(obj))
    O = paint(O, recolored_obj)
  return O
 
28.0, tensor(0.1387), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def beaegchjdgccedecbafbjicfegccddij(I):
  return paint(
      fill(I, mostcolor(I), mfilter(objects(I, univalued=True, diagonal=False, without_bg=True), inbox)),
      recolor(TWO, mfilter(objects(I, univalued=True, diagonal=False, without_bg=True), inbox))
  )
 
41.0, tensor(0.1387), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def jfchchdgiiaeejfdjcecbabcfegdbiag(I):
  return cellwise(
      I,
      fill(I, TWO, mfilter(objects(I, univalued=True, diagonal=False, without_bg=True), inbox)),
      mostcolor(I)
  )
 
31.0, tensor(1.9886), Description: For each object in the input grid that is larger than 1x1, extract the object, trim its border, and paint it onto a blank canvas of the same size as the input grid, shifted one square to the right and one square down from its original position. The background of the output grid should be black. If the object is taller than it is wide, trim the right and bottom edges. If the object is wider than it is tall, trim the right edge. 
:: def adiaghgceedfeafcaeecjdjbaeecdecg(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      h = height(obj)
      w = width(obj)
      trimmed_obj = crop(I, add(ulcorner(obj),(1,1)), (h-2, w-2)) if h > w else crop(I, add(ulcorner(obj),(0,1)), (h, w-2)) 
      O = paint(fill(O, ZERO, obj), shift(asobject(trimmed_obj), add(ulcorner(obj), (1 if h>w else 0, 1)))) 
  return O
 
20.0, tensor(1.4267), Description: For each object in the input grid that is larger than 1x1, recolor the squares to the left of the object to red if the object is taller than it is wide, or recolor the squares above the object to red if the object is wider than it is tall. Keep the original colors of the object and the background. 
:: def dbeahcegjddbehdcijaibfbfgccfbbib(I):
  O = I 
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      t, l = ulcorner(obj)
      h, w = shape(obj)
      if h > w:
        O = paint(O, recolor(2, frozenset(((I[i][j], (i - 1, j)) for i in range(t + 1, t + h - 1) for j in range(l, l + w))))) 
      else:
        O = paint(O, recolor(2, frozenset(((I[i][j], (i, j - 1)) for i in range(t, t + h) for j in range(l + 1, l + w - 1))))) 
  return O
 
11.5, tensor(0.0282), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def igedfhjdbaejeefdajeebdejedjdcabh(I):
  largest_obj = argmax(objects(I, F, F, T), size) # Find the largest object
  top_left = ulcorner(largest_obj) # Find the top-left corner of the object
  bottom_right = lrcorner(largest_obj) # Find the bottom-right corner of the object
  inbox_area = frozenset((i,j) for i in range(top_left[0]+2, bottom_right[0]-1) 
                          for j in range(top_left[1]+2, bottom_right[1]-1)) # Calculate the inbox area
  O = fill(I, TWO, inbox_area)      # Fill the inbox area with '2'
  return O
 
22.0, tensor(1.7470), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. Then, shift the object one square to the right and one square down. Finally, place the recolored inner part back into the original grid, maintaining its original position. 
:: def abfbfdaaiabdefagjjehdjebfidddbdc(I):
  obj = argmax(objects(I, F, F, T), size)  # Find the largest object
  shifted_obj = shift(obj, (1,1))  # Shift the object diagonally down-right
  cropped_grid = subgrid(shifted_obj, I) # Get the subgrid containing shifted object
  filled_grid = fill(cropped_grid, TWO, asindices(cropped_grid)) # Fill the subgrid with '2'
  O = paint(I, shift(asobject(filled_grid), (-1,-1))) # Paint filled subgrid back onto original grid
  return O
 
2.5, tensor(0.0273), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def bjfjbffcbfgbeicibidcaehbjdiaiaac(I):
    obj = argmax(objects(I, T, F, T), size) # Find the largest object
    inner =  obj - toobject(box(obj), I)  # Identify inner cells by subtracting the box outline
    O = paint(I, recolor(2, inner)) # Recolor inner cells to 2 and paint onto original grid
    return O 
 
19.5, tensor(0.0548), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object.  The inner part is defined as the squares that have 4 direct neighbors (up, down, left, right) within the object. 
:: def ccaejafjdejfeghbjafeecdacdefahff(I):
  obj = argmax(objects(I, T, F, T), size)
  inner_indices = toindices(obj) - mfilter(toindices(obj), lambda loc: len(dneighbors(loc) & toindices(obj)) < 4) # Filter indices with less than 4 direct neighbors within the object
  O = fill(I, 2, inner_indices)
  return O
 
1.5, tensor(1.0661), Description: Recolor the inner part of all objects in the input grid that are larger than 1 square to red. Keep the original colors of the outer border of the object. 
:: def aefdieacbdffeacdjfjjfcebffgbffhi(I):
  framed_objs = frozenset(recolor(TWO, inbox(obj)) for obj in objects(I, T, F, T) if size(obj) > 1)
  return paint(I, merge(framed_objs))
 
41.0, tensor(1.0225), Description: For each object in the input grid that is larger than 1 square, recolor any square within the object that does not have 4 direct neighbors (up, down, left, right) within the object to red. Keep the original colors of the outer border of the object. 
:: def jdceajcbfabbeaibibceccbjcahgebej(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      for loc in toindices(obj):
        if len(dneighbors(loc) & toindices(obj)) < 4: 
          O = fill(O, TWO, {loc})
  return O
 
13.0, tensor(1.0314), Description: For each object in the input grid, recolor all the squares except the top row, bottom row, and leftmost column to red. Keep the original colors of the top row, bottom row, and leftmost column. The background should be black. 
:: def eabfgfeaacjceejdabjajiagjcdifbbe(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    for i, j in toindices(obj):
      if 1 <= i < height(obj) - 1 and 1 <= j < width(obj) - 1:
        O = paint(O, {(2, (i, j))})
      else:
        O = paint(O, {(index(I,(i,j)),(i,j))})
  return O
 
1.5, tensor(0.0300), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object. 
:: def fbaeaaccfbefedcaieeeejcefdafacag(I):
  x1 = objects(I, F, F, T)   # Extract objects, excluding background
  O = I                       # Initialize the output grid
  for obj in x1:
    O = fill(O, TWO, inbox(toindices(obj))) # Fill the inbox of each object with '2'
  return O
 
28.0, tensor(0.1394), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def eabdcbeicagcehjijjcbbahijiifbhgh(I):
  modified_grid = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if height(obj) > 1 and width(obj) > 1:
      modified_grid = underpaint(modified_grid, recolor(TWO, toindices(obj) - box(obj)))
    else:
      modified_grid = underpaint(modified_grid, obj)
  return modified_grid 
 
0.0, tensor(0.0293), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object. 
:: def efebefgedjaaefjibeiaeefjfdaifddd(I):
  objs = objects(I, T, F, T)  # Extract all objects excluding background
  recolored_objs = frozenset({recolor(2, obj - toobject(box(obj), I)) for obj in objs}) # Recolor inner cells of each object
  O = I  # Initialize output grid as input grid
  for obj in recolored_objs:
    O = paint(O, obj)  # Paint each recolored object onto the output grid
  return O
 
39.5, tensor(0.1411), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object. 
:: def idbhcafbdbdaedjeieihgdacagfcfdcf(I):
  O = I # Start with the input grid
  for obj in objects(I, T, F, T):
    if len(obj) > 1:
      inner_indices = difference(toindices(obj), inbox(obj))
      O = paint(O, recolor(2, inner_indices)) # Paint inner cells
  return O
 
23.0, tensor(1.0314), Description: For each object in the input grid, recolor all the squares except the top row, bottom row, and leftmost column to red. Keep the original colors of the top row, bottom row, and leftmost column. The background should be black. 
:: def ceghhaahbgebeddaiabecibbjgcegcdh(I):
  O = canvas(mostcolor(I), shape(I))
  h, w = shape(I)
  for i in range(h):
    for j in range(w):
      if 1 <= i < h - 1 and 1 <= j < w - 1 and index(I, (i, j)) != mostcolor(I):
        O = paint(O, {(2, (i, j))})
      else:
        O = paint(O, {(index(I, (i, j)), (i, j))})
  return O
 
29.5, tensor(0.0476), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object. The background should be black. 
:: def bebdjdeeffdjebdeadjhfaabfhdabfbj(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas of the same size as input.
  for obj in objects(I, F, F, T):          # Iterate through each object (excluding background).
    O = paint(O, recolor(TWO, inbox(toindices(obj)))) # Paint the object's inbox with '2' on the canvas.
  return O
 
13.0, tensor(0.1427), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def hibdedgcbaabeajebdghcabddcfbcdfe(I):
  largest_obj = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  return cellwise(
      I,
      fill(I, TWO, inbox(largest_obj)),
      mostcolor(I)
  )
 
21.0, tensor(0.1427), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def ibfebfghjbbgefihjijddeccbgdifbhf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if obj == argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size):
      O = paint(O, recolor(TWO, inbox(obj)))
    else:
      O = paint(O, obj)
  return O
 
4.0, tensor(0.1442), Description: Recolor the inner part of all objects in the input grid that have the same size as the largest object to red. Keep the original colors of the outer border of the object and the background. 
:: def gjbjdfdchfihebddbeecebdddeadbfab(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if size(obj) == size(argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)):
      O = fill(O, TWO, inbox(obj))
  return O
 
28.0, tensor(0.3014), Description: For each object in the input grid that is larger than 1x1, recolor all the squares except the bottom row to red. Keep the original colors of the bottom row. The background should be black. 
:: def bdhgidchdefhehhgbajedaahhcccghfb(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      bottom_row = {(v,(i,j)) for v,(i,j) in obj if i==lowermost(obj)}
      O = paint(cover(O, bottom_row), recolor(TWO, difference(obj, bottom_row)))
  return O
 
28.0, tensor(0.1415), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def aieiccciedhbeceiifgjaaejcjijdbcc(I):
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for obj in objects(I, T, F, T): # Loop through all objects
    if height(obj) > 1 and width(obj) > 1: # Check for object size
      inner_indices = difference(toindices(obj), box(obj)) # Get inner indices
      O = paint(O, recolor(2, inner_indices)) # Paint inner cells as '2'
    else:
      O = paint(O, obj) # Keep small objects unchanged
  return O
 
14.0, tensor(0.1387), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def fddbdfccebcdehieacaaegcgbagiabca(I):
    obj_indices = merge({toindices(obj) for obj in objects(I, univalued=True, diagonal=False, without_bg=True)})
    return tuple(
        tuple(
            TWO if (i, j) in {loc for loc in inbox(obj_indices)} else I[i][j] 
            for j in range(len(I[0]))
        ) 
        for i in range(len(I))
    )
 
26.5, tensor(1.4971), Description: For each object in the input grid that is larger than 2 squares, shift the object one square to the right and one square down, and recolor the inner part of the shifted object to red. Keep the original colors of the outer border of the object and the background. 
:: def iaechjhcdhgiedaaahcjjcidacfdbeah(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, T):
        if len(obj) > 2:
            O = paint(O, obj)
            O = underfill(O, 2, shift(toindices(obj), (1, 1)))
    return O
 
87.0, tensor(0.1322), Description: For each object in the input grid that is larger than 1x1, recolor all squares outside the object's bounding box to red. Keep the original colors of the object and the background. 
:: def jffeafacidbbefebjebfccefjcbadijd(I):
  O = I
  for obj in objects(I, T, F, T):
    if height(obj) > 1 and width(obj) > 1:
      border = box(obj)
      O = fill(O, 2, difference(asindices(I), border))
  return O
 
11.5, tensor(0.0435), Description: Recolor the middle third of the largest object in the input grid to red. Keep the original colors of the rest of the object and the background. 
:: def debgebhcafacedfabhedfaidgcdadeee(I):
  obj = max(objects(I, F, F, T), key=size) # Find largest object
  left = leftmost(obj) + width(obj) // 3  # Calculate left boundary of the slice
  right = left + width(obj) // 3        # Calculate right boundary of the slice
  indices = frozenset((i, j) for i, j in toindices(obj) if left <= j < right) # Get slice indices
  O = fill(I, TWO, indices)              # Fill slice with 2
  return O
 
11.0, tensor(0.0435), Description: Recolor the middle third of the largest object in the input grid to red. Keep the original colors of the rest of the object and the background. 
:: def cbbddiaajfibejbdbgfbdebefffiiicc(I):
  obj = max(objects(I, F, F, T), key=len) # Largest object
  indices = toindices(obj)
  slice_indices = frozenset((i, j) for i, j in indices if leftmost(indices) + width(indices) // 3 <= j < leftmost(indices) + 2 * width(indices) // 3)
  O = fill(I, TWO, slice_indices) 
  return O
 
10.5, tensor(0.0409), Description: Recolor the left third of the largest object in the input grid to red. Keep the original colors of the rest of the object and the background. 
:: def fafhjbgiajbbejgdibhffbeceecagbad(I):
  obj = max(objects(I, F, F, T), key=size)  # Largest object
  w = width(obj) 
  slice_start = (0, w // 3)
  for j in range(slice_start[1], 2 * slice_start[1]):
    for i in range(height(obj)):
      if (i, j) in toindices(obj):
        I = fill(I, TWO, frozenset({(i, j)}))
  return I
 
4.0, tensor(0.1485), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def egbfebadfebdebbaaeeedjcafeejccje(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  top_left = ulcorner(largest_object)
  modified_object = frozenset({(2, (i, j)) if top_left[0] + 1 <= i <= top_left[0] + 3 and top_left[1] + 1 <= j <= top_left[1] + 3  else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object) 
 
4.0, tensor(0.1485), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def hicafijecaieechcbadcgbbfgcehjddf(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  lr = lrcorner(largest_object)
  modified_object = frozenset({(2, (i, j)) if lr[0] - 3 <= i <= lr[0] - 1 and lr[1] - 3 <= j <= lr[1] - 1  else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object) 
 
2.5, tensor(0.1404), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def agjgaeffdaeeebdbjhfcddbihfbdicdd(I):
  obj = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  return paint(I, recolor(TWO, frozenset((i, j) for i in range(uppermost(obj) + 1, lowermost(obj)) for j in range(leftmost(obj) + 1, rightmost(obj))) & toindices(obj)))
 
9.5, tensor(1.0605), Description: Recolor the second row of the largest object in the input grid to red. Keep the original colors of the rest of the object and the background. 
:: def dgjeehedbegeegabjbdfdbfebeaeaefg(I):
  objs = objects(I, T, F, T) 
  obj = argmax(objs, size)
  O = paint(I, recolor(TWO, intersection(toindices(obj), 
                                        {(i, j) for i in range(uppermost(obj) + 2, uppermost(obj) + 3) 
                                        for j in range(leftmost(obj) + 1, rightmost(obj))})))
  return O
 
10.5, tensor(0.0570), Description: For each object in the input grid that is larger than 1x1, recolor the second row of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def hfbbjhhaaeeeefbhbcdaihafciaabiih(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      O = paint(O, 
               recolor(TWO, 
                       intersection(toindices(obj),
                                   {(i, j) for i in range(uppermost(obj) + 2, uppermost(obj) + 3) for j in range(width(obj)) if j != 0 and j != width(obj) - 1})))
  return O
 
10.5, tensor(0.0570), Description: For each object in the input grid that is larger than 1x1, recolor the second row of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def daacbagddgdgeaegjecfebbiahfddahf(I):
    for obj in objects(I, T, F, T):
        if size(obj) > 1:
            line = {(uppermost(obj) + 2, j) for j in range(leftmost(obj) + 1, rightmost(obj))}
            I = paint(I, recolor(TWO, intersection(toindices(obj), line)))
    return I
 
1.5, tensor(0.0293), Description: Recolor the inner part of all objects in the input grid to red. Keep the original colors of the outer border of the object. 
:: def jcddidejehbaeeaajabfefdbjbfidjaj(I):
  objs = objects(I, T, F, T)  # Extract all objects excluding background
  recolored_objs = frozenset({recolor(2, toobject(inbox(obj), I)) for obj in objs})  # Recolor inner cells of each object using 'inbox' function
  O = I  # Initialize output grid as input grid
  for obj in recolored_objs:
    O = paint(O, obj)  # Paint each recolored object onto the output grid
  return O 
 
24.0, tensor(1.0706), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. 
:: def fhdaeddideaaehicijbcadidegaceeea(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  O = paint(canvas(ZERO, shape(I)), largest_obj)
  if largest_obj:
    O = underpaint(O, recolor(TWO, difference(toindices(largest_obj), box(largest_obj))))
  return O
 
11.0, tensor(0.0310), Description: Recolor the middle third of the largest object in the input grid to red. Keep the original colors of the left third and the background. 
:: def iehdcebcicideaedbjbifcdceefbhbfj(I):
  obj = max(objects(I, F, F, T), key=size) # Largest object
  w = width(obj)
  left = lambda x: x[1] < w // 3
  middle = lambda x: w // 3 <= x[1] < 2 * w // 3
  O = paint(I, recolor(TWO, sfilter(toindices(obj), middle)))
  return paint(O, recolor(color(obj), sfilter(toindices(obj), left)))
 
11.5, tensor(0.0310), Description: Recolor the middle third of the largest object in the input grid to red. Keep the original colors of the left third and the background. 
:: def iddedjhgbfadeefbadbefccjaeeejhcd(I):
  obj = max(objects(I, F, F, T), key=size) # Largest object
  third_width = width(obj) // 3
  left_third = {(color(obj), (i, j)) for i, j in toindices(obj) if j < third_width}
  middle_third = {(TWO, (i, j)) for i, j in toindices(obj) if third_width <= j < 2 * third_width}
  return paint(paint(I, middle_third), left_third)
 
9.0, tensor(0.1499), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Also, recolor the rightmost column of the largest object to red. Keep the original colors of the outer border of the object and the background. 
:: def dabffibiaccdehaeicadfejbcbdciefc(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  top_left = ulcorner(largest_object)
  modified_object = frozenset({(2, (i, j)) if (top_left[0] + 1 <= i <= top_left[0] + 3 and top_left[1] + 1 <= j <= top_left[1] + 3) or j == rightmost(largest_object) else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object)
 
28.0, tensor(0.0811), Description: Recolor the inner part of all objects in the input grid that are at least 2x2 in size to red. Keep the original colors of the outer border of the object and the background. The inner part is defined as the squares that have 4 direct neighbors (up, down, left, right) within the object. 
:: def ceeeceebdfciegfibbdcaaeidfbeahcj(I):
  objs = objects(I, T, F, T)  # Find all objects
  recolored_objs = frozenset()
  for obj in objs:
    inner_indices = toindices(obj) - mfilter(toindices(obj), lambda loc: len(dneighbors(loc) & toindices(obj)) < 4)
    if len(inner_indices) >= 4: # Check if inner area is at least 2x2
      recolored_objs = recolored_objs | frozenset({recolor(2, toobject(inner_indices, I))})
  O = I 
  for obj in recolored_objs:
    O = paint(O, obj)
  return O
 
29.5, tensor(0.8649), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object. 
:: def bfabiaaeddhceacdijechcaieababheb(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      border = difference(obj, toobject(inbox(obj), I))
      O = paint(cover(O, obj), recolor(TWO, difference(obj, border)))
  return O
 
20.0, tensor(0.8418), Description: Recolor the inner part of all objects in the input grid that are larger than 1 square to red. Keep the original colors of the outer border of the object and the background. Also, keep the original colors of any objects that are bordering the edge of the grid. 
:: def ifhbabfchgdhefafbfebeahhbacadgdb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1 and not bordering(obj, I):
      O = underpaint(O, recolor(TWO, difference(obj, box(obj))))
    else:
      O = underpaint(O, obj)
  return O
 
13.0, tensor(0.8649), Description: Recolor the inner part of all objects in the input grid that are larger than 1 square to red. Keep the original colors of the outer border of the object. 
:: def icffcefjedfjehfbaeabjeabbdgdddfc(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      inner_indices = delta(delta(toindices(obj)))
      O = paint(O, recolor(TWO, toobject(inner_indices, I)))
  return O
 
0.0, tensor(0.8655), Description: Recolor the inner part of all objects in the input grid that are larger than 1 square to red. Keep the original colors of the outer border of the object and the background. 
:: def bbcheeafcgfdebdfidgcdgjddhdaabcb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      border = apply(lambda cell: (index(I, cell[1]), cell[1]), toobject(box(obj), I))
      inner  = recolor(TWO, difference(obj, border))
      O = underpaint(O, combine(border, inner))
  return O
 
28.0, tensor(0.1162), Description: For each object in the input grid that is larger than 2 squares, recolor the inner part of the object to red. Keep the original colors of the outer border of the object and the background. 
:: def ejhbgbdagdifeahcacgccfifagdgdcdj(I):
  objs = objects(I, T, F, F)
  for obj in objs:
    if len(obj) > 2:
      obj_indices = toindices(obj)
      inner_indices = difference(obj_indices, box(obj_indices))
      I = fill(I, TWO, inner_indices)
  O = I
  return O
 
10.5, tensor(1.1642), Description: For each square in the input grid that has the same color as its left and upper neighbors, change that square to red. Leave all other squares in their original color. 
:: def icdhfafcdabaeffdafcebjfdcaiifdcg(I):
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] != ZERO and I[i-1][j] == I[i][j] and I[i][j-1] == I[i][j]:
        I = fill(I, TWO, {(i, j)})
  O = I
  return O
 
51.0, tensor(0.1284), Description: Recolor the inner part of all objects in the input grid that are larger than 2 squares to red. Keep the original colors of the outer border of the object and the background. 
:: def ffghabicjaebefdcabedafaejcjjijgf(I):
  objs = objects(I, T, F, F)
  inner_cells = set()
  for obj in objs:
    if len(obj) > 2:
      obj_indices = toindices(obj)
      top_left = ulcorner(obj_indices)
      bottom_right = lrcorner(obj_indices)
      for i in range(top_left[0]+1, bottom_right[0]):
        for j in range(top_left[1]+1, bottom_right[1]):
          inner_cells.add((i,j))
  O = fill(I, TWO, inner_cells)
  return O
 
56.0, tensor(0.1107), Description: For each object in the input grid that is larger than 1x1, recolor the inner part of the object to red. Keep the original colors of the outer border of the object and the background. 
:: def dbadcebagdagebaebjabefecebghgbhd(I):
  painted = canvas(ZERO, shape(I))
  objs = objects(I, T, F, F)
  for obj in objs:
    if size(obj) > 1:
      ul = ulcorner(obj)
      lr = lrcorner(obj)
      for i in range(ul[0] + 1, lr[0]):
        for j in range(ul[1] + 1, lr[1]):
          painted = fill(painted, TWO, {(i, j)})
  O = paint(I, asobject(painted))
  return O 
 
20.0, tensor(1.1735), Description: For each square in the input grid that has at least two adjacent squares of the same color, change that square to red. Leave all other squares in their original color. 
:: def fecacehhccbfecadjjeeabibfbdccgab(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != ZERO:
        adjacent_same = 0
        for di in [-1, 1]:
          for dj in [-1, 1]:
            if 0 <= i+di < len(I) and 0 <= j+dj < len(I[0]) and I[i+di][j+dj] == I[i][j]:
              adjacent_same += 1
        if adjacent_same >= 2:
          O = fill(O, TWO, {(i,j)})
  return O
 
7.5, tensor(0.0473), Description: For each object in the input grid that is larger than 1x1, recolor the second row of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def ecddcgdafcagebddjfibdhjjgcafbchh(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      line = interval(leftmost(obj) + 1, rightmost(obj), 1)
      recolor_indices = {(uppermost(obj) + 1, j) for j in line}
      O = paint(O, recolor(TWO, intersection(toindices(obj), recolor_indices)))
  return O
 
13.0, tensor(0.0473), Description: For each object in the input grid that is larger than 1x1, recolor the second row of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def haacjdbhadbbeeagaafecebjbddgjddj(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      top = uppermost(obj)
      left = leftmost(obj)
      O = paint(O, shift(recolor(TWO, {(1, j) for j in range(1, width(obj) - 1)}), (top, left)))
      O = paint(O, obj)
  return O
 
14.5, tensor(0.0502), Description: For each square in the input grid that has the same color as its top and bottom neighbors, but a different color from itself, change that square to red. Leave all other squares in their original color. 
:: def fdeddaadfeaiefaaiafigfdjbfcdeadf(I):
  O = I
  for i in range(len(I)):
    for j in range(1, len(I[0]) - 1):
      if index(I, (i - 1, j)) == index(I, (i + 1, j)) and index(I, (i - 1, j)) != index(I, (i, j)):
        O = fill(O, TWO, {(i, j)})
  return O
 
7.0, tensor(0.0218), Description: Recolor the 2x3 inner rectangle of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. The rectangle starts one cell right and at half the height of the largest object. 
:: def ffbbbcfegbdgefceafifaecjceaicefc(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  h = height(largest_object) // 2  # Calculate half the height
  top_left = add(ulcorner(largest_object), (h, 1))  # Start one cell right and at half height
  modified_object = frozenset({(2, (i, j)) if top_left[0] <= i <= top_left[0] + 1 and top_left[1] <= j <= top_left[1] + 2  else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object)
 
11.0, tensor(1.5845), Description: Recolor the 2x3 inner rectangle of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. The rectangle starts at half the height of the largest object and extends to the right edge, covering the last 3 columns. 
:: def abdebibjegfeecddbdaabdidfccedebe(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  h, w = shape(largest_object)
  modified_object = frozenset({(2, (i, j)) if h // 2 <= i < h // 2 + 2 and w - 3 <= j < w else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object)
 
9.0, tensor(1.7404), Description: Recolor the 2x3 inner rectangle of each object in the input grid to red. Keep the original colors of the outer border of the object and the background. The rectangle starts at half the height of the object and extends to the right edge, covering the last 3 columns. Also, recolor the 2x2 inner square of each object to red, starting from the bottom right corner of the object and extending 2 squares to the left and 2 squares up. 
:: def acafgaddgcjfeefdiaefefhfbeffeajh(I):
  def modify_object(obj):
    h, w = shape(obj)
    return frozenset({(2, (i, j)) if (h // 2 <= i < h // 2 + 2 and w - 3 <= j < w) or (h - 3 <= i < h and w // 2 <= j < w // 2 + 2) else (v, (i, j)) for v, (i, j) in obj})

  return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
27.0, tensor(0.0294), Description: Recolor the middle third of the main object in the input grid to red. The main object is defined as the object with the most common color in the grid. If the object is taller than it is wide, recolor the middle third horizontally. If the object is wider than it is tall, recolor the middle third vertically. Keep the original colors of the rest of the object and the background. 
:: def gabjcffdfjiceibeacgjaegdgjbbdjif(I):
  # Find the most common color in the grid, representing the main object
  obj_color = mostcolor(I)
  # Get the indices of all cells belonging to the main object
  obj_indices = ofcolor(I, obj_color)
  # Calculate the center of the object
  center_i, center_j = centerofmass(obj_indices)
  # Identify the indices to recolor based on object's orientation
  recolor_indices = frozenset((i, j) for i, j in obj_indices if (
    (portrait(obj_indices) and center_i - 2 <= i <= center_i) or 
    (not portrait(obj_indices) and center_j <= j <= center_j + 2)
  ))
  # Recolor the selected indices
  O = fill(I, TWO, recolor_indices)
  return O
 
29.0, tensor(1.6786), Description: Recolor the inner part of the main object in the input grid to red. The main object is defined as the object with the most common color in the grid. If the object is taller than it is wide, shift the object one square to the right. If the object is wider than it is tall, shift the object one square down. Keep the original colors of the rest of the object and the background. 
:: def adbjacbdchcbeejdadhgdichfdaeadfg(I):
  obj_color = mostcolor(I)
  obj_indices = ofcolor(I, obj_color)
  h, w = shape(obj_indices)
  if h > w:
    shift_amount = (1, 0)
  else:
    shift_amount = (0, 1)
  shifted_indices = shift(obj_indices, shift_amount)
  intersection = obj_indices & shifted_indices
  recolor_indices = obj_indices - intersection
  O = fill(I, TWO, recolor_indices)
  return O
 
30.5, tensor(0.1281), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def fgdfcdejjfieecjdbdeaffdacaejadfd(I):
  objs = objects(I, T, F, F)
  for obj in objs:
    if size(obj) > 1:
      I = underfill(I, TWO, difference(toindices(obj), box(obj)))
  O = I
  return O
 
56.0, tensor(0.1606), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. Also, keep the original colors of any objects that are 1x1 in size. 
:: def dfgieeffifabeajebiaeagciabeeebei(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, F):
    if size(obj) > 1:
      O = paint(O, recolor(TWO, difference(toindices(obj), box(toindices(obj)))))
    else:
      O = paint(O, obj)
  return paint(I, asobject(O))
 
0.0, tensor(1.0558), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object. 
:: def fdffjebbdjcfedifbbabaagfefbihiea(I):
  O = I  # Initialize output as input
  for obj in objects(I, T, F, T): # Iterate over objects in the input grid
    if size(obj) > 1:  # Only consider objects with more than one cell
      for i in range(uppermost(obj) + 1, lowermost(obj)): # Iterate over rows within object
        for j in range(leftmost(obj) + 1, rightmost(obj)): # Iterate over columns within object
          if (i, j) in toindices(obj): # Check if current cell belongs to the object
            O = paint(O, {(TWO, (i, j))}) # Recolor the current cell to '2'
  return O
 
41.0, tensor(1.1117), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the background color. Keep the original colors of the object and the background. 
:: def jjaddjafdbejeiaeaebdhhagabfbhecb(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in objects(I, T, F, T): # Iterate over objects in the input grid
    if size(obj) > 1: # Only consider objects with more than one cell
      O = paint(O, obj)  # Paint the object onto the output
      O = paint(O, recolor(mostcolor(I), box(obj))) # Repaint the boundary with the background color
  return O
 
13.0, tensor(1.7561), Description: Recolor the 2x3 inner rectangle of each object in the input grid to red. Keep the original colors of the outer border of the object and the background. The rectangle starts at half the height of the object and extends to the right edge, covering the last 3 columns if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the first 3 columns. 
:: def fjcdbeefcgcfebacjebadccdfgccadee(I):
  def modify_object(obj):
    h, w = shape(obj)
    target_j = w - 3 if uppermost(obj) < len(I) // 2 else 1 # Right if in top half, else left
    top_left = add(ulcorner(obj), (h // 2, target_j)) 
    modified_object = frozenset({(2, (i, j)) if top_left[0] <= i <= top_left[0] + 1 and top_left[1] <= j <= top_left[1] + 2  else (v, (i, j)) for v, (i, j) in obj})
    return modified_object

  return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
17.5, tensor(1.7590), Description: Recolor the 2x3 inner rectangle of each object in the input grid to red. Keep the original colors of the outer border of the object and the background. The rectangle starts at the bottom right corner of the object and extends 2 squares to the left and 3 squares up if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at the top left corner and extends 2 squares to the right and 3 squares down. 
:: def bdffedcbgfadehbbbhcjbehidjacceia(I):
  def modify_object(obj):
    h, w = shape(obj)
    corner =  lrcorner(obj) if uppermost(obj) < len(I) // 2 else ulcorner(obj)
    target_area =  frozenset((corner[0] - i, corner[1] - j) for i in range(2) for j in range(3))
    return recolor(2, intersection(target_area, toindices(obj))) | (obj - toobject(target_area, I)) 
  return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
28.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def dfbbeghgjjibedhhjehfjjiaggjicchg(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  recolor_indices = (
    frozenset((i, j) for v, (i, j) in obj if uppermost(obj) + 1 <= i <= uppermost(obj) + 3) if h > w
    else frozenset((i, j) for v, (i, j) in obj if leftmost(obj) + 1 <= j <= leftmost(obj) + 3)
  )  # Determine indices to recolor
  O = fill(I, TWO, recolor_indices)  # Recolor the indices
  return O
 
28.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def icfbieahjbbfecacbdibaiibcafbbebb(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  recolor_func = (
      (lambda i, j: uppermost(obj) + 1 <= i <= uppermost(obj) + 3) if h > w 
      else (lambda i, j: leftmost(obj) + 1 <= j <= leftmost(obj) + 3)
  ) # Define recoloring condition function
  recolor_indices = frozenset((i, j) for i in range(h) for j in range(w) if recolor_func(i, j)) # Apply recolor condition
  O = fill(I, TWO, recolor_indices) 
  return O
 
28.0, tensor(0.8655), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def ecdhbecheejfefcdicfagbjjecdefejd(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      inner_indices = difference(toindices(obj), toindices(box(obj)))
      inner_obj = toobject(inner_indices, I)
      O = underpaint(O, recolor(TWO, inner_obj))
  return O
 
1.5, tensor(1.0575), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the object's original color. Then, fill the interior of the object with red. The background should be black. 
:: def aeabicidbiahebfaagjggacjdeebacbb(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output as a blank canvas 
  for obj in objects(I, T, F, T): # Iterate over objects
    if size(obj) > 1: # Only consider objects with interior cells
      O = paint(O, recolor(color(obj), box(obj))) # Paint the border with the original color
      O = paint(O, recolor(2, inbox(obj))) # Paint the interior with '2'
  return O
 
13.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def jdbaeefdheaeeafeaahhhggjadcagcgb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  modified_objs = frozenset()
  for obj in objs:
    h = height(obj)
    w = width(obj)
    shift_amount = 3 if uppermost(obj) < len(I) // 2 else -1
    target_indices = {(i, j + shift_amount) for v, (i, j) in obj if h // 2 <= i < h // 2 + 2 and (w - 3) // 2 <= j < (w - 3) // 2 + 3}
    modified_obj = frozenset({(2, idx) if idx in target_indices else (v, idx) for v, idx in obj})
    modified_objs = modified_objs | {modified_obj}
  return paint(I, merge(modified_objs))
 
24.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def ijcbcachacefehbbjdbccjfjbcjjecja(I):
  def modify_row(row, obj, shift_amount):
    w = width(obj)
    return tuple(2 if (w - 3) // 2 <= j < (w - 3) // 2 + 3 and any((i, j + shift_amount) in toindices(obj) for i in range(len(I) // 2, len(I) // 2 + 2)) else v for j, v in enumerate(row))

  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  modified_grid = list(list(row) for row in I)
  for obj in objs:
    shift_amount = 3 if uppermost(obj) < len(I) // 2 else -1
    for i in range(len(I)):
      modified_grid[i] = modify_row(modified_grid[i], obj, shift_amount)
  return tuple(tuple(row) for row in modified_grid)
 
26.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def edbfaeaihffcedghajbadbcgefafiddc(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  O = I
  for i in range(uppermost(obj) + 1, min(uppermost(obj) + 4, h + uppermost(obj))):
    for j in range(leftmost(obj) + (h <= w), min(leftmost(obj) + w - (h <= w), w + leftmost(obj))):
      O = fill(O, TWO, {(i, j)})
  return O
 
22.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def hcdicijhciabebcdacagcidiceifacbf(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  O = I
  for i in range(h):
    for j in range(w):
      if (h > w and uppermost(obj) + 1 <= i <= uppermost(obj) + 3 and 1 <= j <= w - 2) or \
         (w >= h and leftmost(obj) + 1 <= j <= leftmost(obj) + 3 and 1 <= i <= h - 2):
        O = fill(O, TWO, {(i + uppermost(obj), j + leftmost(obj))}) 
  return O
 
2.5, tensor(0.1200), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. 
:: def fbdbehgajbeeecggjgigdjffadcgdjgc(I):
  obj = argmax(objects(I, T, T, T), size)  # Find the largest object
  ul = add(ulcorner(obj), (ONE, ONE))     # Upper-left corner of the inner region
  lr = subtract(lrcorner(obj), (ONE, ONE)) # Lower-right corner of the inner region
  fill_region =  frozenset((i, j) for i in range(ul[0], lr[0] + 1) for j in range(ul[1], lr[1] + 1))  # Region to fill
  O = fill(I, TWO, fill_region)           # Fill the region with '2'
  return O 
 
9.5, tensor(0.1426), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. The inner part is defined as the squares that are not on the top, bottom, left, or right edges of the object. 
:: def dbhbjdfdfhidegefjgebceaedhdddfbh(I):
  obj = argmax(objects(I, T, T, T), size) # Find the largest object
  def is_inner(loc):
    i, j = loc
    return (ONE < i < lowermost(obj) - ONE) and (ONE < j < rightmost(obj) - ONE)
  fill_region = sfilter(backdrop(obj), is_inner) 
  O = fill(I, TWO, fill_region)
  return O
 
33.5, tensor(0.2345), Description: For each object in the input grid that is larger than 1x1, recolor the second and third rows of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def fhbbidcaadfiebahbeacgbddceaafaea(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in objects(I, T, F, T): # Iterate over objects in the input grid
    if size(obj) > 1: # Only consider objects with more than one cell
      for i in range(uppermost(obj) + 2, lowermost(obj)):  # Iterate through rows starting from the third row of the object
        line = {(i, j) for j in range(leftmost(obj), rightmost(obj) + 1)} # Create a horizontal line at row i spanning the object's width
        O = paint(O, recolor(2, intersection(toindices(obj), line)))  # Recolor the intersection of the line and the object with '2' 
  return O
 
14.5, tensor(0.1902), Description: For each object in the input grid that is larger than 1x1, recolor the third and fourth rows of the object (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def ahffecdcgagjecfcbhcdgeeibahbccfe(I):
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      top = uppermost(obj)
      for i in range(2): # Iterate twice for the third and fourth rows
        line = {(top + 2 + i, j) for j in range(leftmost(obj), rightmost(obj) + 1)} # Define the horizontal line for the current iteration
        I = paint(I, recolor(2, intersection(toindices(obj), line)))  # Recolor the intersection
  return I
 
28.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def efbcgedjicbbejcfbdjcabegaabbcddb(I):
  def process_object(obj):
    h = height(obj)
    w = width(obj)
    shift_amount = 3 if uppermost(obj) < len(I) // 2 else -1
    new_obj = frozenset({(2 if h // 2 <= i < h // 2 + 2 and (w - 3) // 2 <= j < (w - 3) // 2 + 3 else v, (i, j + shift_amount)) for v, (i, j) in obj})
    return new_obj

  return paint(I, merge(apply(process_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
22.0, tensor(0.8340), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the inner part excluding the first and last rows. If the object is wider than it is tall, recolor the inner part excluding the first and last columns. 
:: def caehgidcjejceebdacdcfihiecedhgee(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  inner_box = inbox(toindices(obj))
  recolor_area = (
      sfilter(inner_box, lambda loc: uppermost(obj) + 1 < loc[0] < lowermost(obj) - 1) if h > w
      else sfilter(inner_box, lambda loc: leftmost(obj) + 1 < loc[1] < rightmost(obj) - 1)
  )
  O = fill(I, TWO, recolor_area)
  return O
 
18.0, tensor(0.9012), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the inner part excluding the first and last columns. If the object is wider than it is tall, recolor the inner part excluding the first and last rows. 
:: def abaecehefcjaehfjidgdfeadfbaceadh(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  center_i, center_j = centerofmass(toindices(obj))
  recolor_area = (
      frozenset((i, j) for i in range(uppermost(obj) + 1, lowermost(obj)) for j in range(center_j - 1, center_j + 2)) if h > w
      else frozenset((i, j) for i in range(center_i - 1, center_i + 2) for j in range(leftmost(obj) + 1, rightmost(obj)))
  )
  O = fill(I, TWO, recolor_area)
  return O
 
0.0, tensor(0.1281), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def bcbbccadfiafeafdjbecdbfbafdiefgb(I):
  O = I
  for obj in objects(I, T, T, T):
    if size(obj) > 1:
      inner_region = difference(backdrop(obj), box(obj))
      O = fill(O, TWO, inner_region)
  return O
 
14.5, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def icbfdaecheaaedbbifagfaajbjahbfdf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  def modify_obj(obj):
    h, w = height(obj), width(obj)
    start_row = h // 2 + h % 2 - 1
    start_col = (w - 3) // 2
    shift_amount = 3 if uppermost(obj) < len(I) // 2 else -1
    modified_obj = set()
    for v, (i, j) in obj:
      new_j = j + shift_amount if start_row <= i < start_row + 2 and start_col <= j < start_col + 3 else j
      modified_obj.add((2 if start_row <= i < start_row + 2 and start_col <= new_j < start_col + 3 else v, (i, new_j)))
    return frozenset(modified_obj)

  return paint(I, merge(apply(modify_obj, objs)))
 
35.0, tensor(1.1300), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. If the object is wider than it is tall, remove the rightmost column of the inner part. 
:: def bdfiebgdcdifecicibebgcjdbbccgbgh(I):
  obj = argmax(objects(I, T, F, F), size) # Find the largest object
  
  # Create a mask of the object's inner area
  mask = inbox(obj) 
  if height(obj) <= width(obj): 
    mask = difference(mask, {(i, rightmost(obj)) for i in range(uppermost(obj) + 1, lowermost(obj))})
  
  # Fill the mask area with '2's
  O = fill(I, TWO, mask)
  return O
 
22.5, tensor(0.1048), Description: Recolor the inner part of the largest object in the input grid to red. Keep the original colors of the outer border of the object. If the object is taller than it is wide, recolor a 3x(height-2) strip in the middle of the object. If the object is wider than it is tall, recolor a (width-2)x3 strip in the middle of the object. 
:: def eadagdfechibebeiahdffeeaachifaed(I):
  obj = argmax(objects(I, T, F, F), size) # Find largest object
  h, w = shape(obj) # Get object height and width

  # Create a canvas representing the strip
  strip = canvas(TWO, (h - 2, 3)) if h > w else canvas(TWO, (3, w - 2))

  # Calculate the offset to position the strip correctly
  offset = (uppermost(obj) + 1, leftmost(obj) + 1) 

  # Paint the strip onto the original grid 
  O = underpaint(I, shift(asobject(strip), offset)) 
  return O
 
6.0, tensor(0.1281), Description: Recolor the inner part of all objects in the input grid that are larger than 1x1 to red. Keep the original colors of the outer border of the object and the background. 
:: def bachdajbbeefeigdjcafeffeedecjjce(I):
    return totuple(tuple(tuple(TWO if (i, j) in difference(toindices(obj), box(obj)) else v for j, v in enumerate(row)) for i, row in enumerate(I)) for obj in objects(I, T, F, T) if size(obj) > 1)[-1]
 
14.5, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def dijfajhccficeccibghedccbfjjdhafa(I):
  def modify_object(obj):
    h, w = height(obj), width(obj)
    offset = (0, 3) if uppermost(obj) < len(I) // 2 else (0, -1)
    target_area = frozenset((i, j) for i in range(h // 2 + h % 2 - 1, h // 2 + h % 2 + 1) for j in range((w - 3) // 2, (w - 3) // 2 + 3))
    return frozenset(((2, (i + offset[0], j + offset[1])) if (i, j) in target_area else (v, (i, j))) for v, (i, j) in obj)
  return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
30.0, tensor(0.0325), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second and third rows of the object. If the object is wider than it is tall, recolor the 3x3 square in the second and third columns of the object. 
:: def afbcedehdjabececadadgajbdehdchda(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  O = I
  for i in range(1, h-1):
    for j in range(1, w-1):
      if (h > w and j in [1, 2, w-2]) or (w >= h and i in [1, 2, h-2]):
        O = fill(O, TWO, {(i + uppermost(obj), j + leftmost(obj))})
  return O
 
1.5, tensor(0.8669), Description: For each object in the input grid that is larger than 1x1, draw a border around the object using the object's original color. Then, fill the interior of the object with red. The background should be black. 
:: def dffdfgaccbcaeigajfjeaaidbhaeaafb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      O = paint(paint(O,  toobject(box(obj), I)), recolor(TWO, toobject(inbox(obj), I)))
  return O
 
10.5, tensor(0.1281), Description: Recolor the inner part of the largest object in the input grid that is not a horizontal line to red. Keep the original colors of the outer border of the object and the background. 
:: def eacbhihchgbfeeidjeffhbbebdafchcd(I):
  def is_valid_object(obj):
    return size(obj) > 1 and not hline(obj)
  valid_objects = set(filter(is_valid_object, objects(I, T, F, T)))
  inner_areas = set(difference(backdrop(obj), box(obj)) for obj in valid_objects)
  return last(fill(I, TWO, area) for area in inner_areas)
 
19.5, tensor(0.0257), Description: For each object in the input grid that is larger than 1x1, recolor every other row (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def deieeacciiiceccaafdciahdecdabchh(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      O = paint(O, recolor(2, {(i, j) for i, j in toindices(obj) if even(i - uppermost(obj)) and j not in (leftmost(obj), rightmost(obj))}))
  return O
 
9.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def fijedddcagbceegcjeadfabfhfcefieb(I):
  def modify_object(obj):
    h, w = height(obj), width(obj)
    shift_direction = (1, 0) if uppermost(obj) < len(I) // 2 else (-1, 0)
    center_indices = frozenset((i, j) for i in range(h // 2 + h % 2 - 1, h // 2 + h % 2 + 1) for j in range((w - 3) // 2, (w - 3) // 2 + 3))
    target_indices = shift(center_indices, shift_direction) & toindices(obj)
    return recolor(2, target_indices) | (obj - toobject(target_indices, I))
  return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
11.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def aafaabcjbfghebfeijcdbfcceeaaicfg(I):
  def change_color(obj):
    h, w = height(obj), width(obj)
    row = h // 2 + h % 2 + (1 if uppermost(obj) < len(I) // 2 else -1)
    cols = (w - 3) // 2, (w - 3) // 2 + 1, (w - 3) // 2 + 2 
    to_change = frozenset((row, col) for col in cols) & toindices(obj)
    return recolor(2, to_change) | (obj - toobject(to_change, I))
  
  return paint(I, merge(apply(change_color, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
14.0, tensor(1.7707), Description: For each object in the input grid, recolor the 2x3 inner rectangle to red. The rectangle starts at half the height of the object and extends to the right edge, covering the middle third of the object's width if the object is in the top half of the grid. If the object is in the bottom half, the rectangle starts at half the height and extends to the left edge, covering the middle third of the object's width. Keep the original colors of the outer border of the object and the background. 
:: def affedadaagdfeibbahijfcgdajdchjcb(I):
  def modify(obj):
    h, w = height(obj), width(obj)
    row = h // 2 + h % 2 + (-1)**(uppermost(obj) < len(I) // 2)
    target_area = frozenset((row, (w - 3) // 2 + i) for i in range(3)) & toindices(obj)
    return recolor(2, target_area) | (obj - toobject(target_area, I))
  
  return paint(I, merge(apply(modify, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
4.5, tensor(0.0257), Description: For each object in the input grid that is larger than 1x1, recolor every other row (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def dafabeehcdaheaddbicfhfddejjdbecj(I):
  O = I  # Initialize output grid
  for obj in objects(I, T, F, T):  # Iterate through all objects
    if size(obj) > 1:  # Only modify objects larger than one cell
      for i in range(uppermost(obj) + 1, lowermost(obj) + 1):  # Loop through rows
        if (i + uppermost(obj)) % 2 == 1:  # Check if the row index is odd relative to the object's starting row
          row_indices = {(i, j) for j in range(leftmost(obj) + 1, rightmost(obj))}  # Generate indices for the current row within the object
          O = fill(O, 2, intersection(toindices(obj), row_indices))  # Replace the row with '2'
  return O
 
12.5, tensor(1.6994), Description: For each object in the input grid, recolor the 3x3 square centered around the object's center of mass to red. If the center of mass is closer to the top half of the grid, shift the 3x3 square one cell down. If the center of mass is closer to the bottom half of the grid, shift the 3x3 square one cell up. Keep the original colors of the outer border of the object and the background. 
:: def afjjcaagabfeeaabjfabaaiaffdddcgf(I):
    def modify_object(obj):
        c = centerofmass(obj)
        shift = 1 if c[0] < len(I) // 2 else -1
        return frozenset({(2 if abs(i - c[0] - shift) <= 1 and abs(j - c[1]) <= 1 else v, (i, j)) for v, (i, j) in obj})

    return paint(I, merge(apply(modify_object, objects(I, univalued=True, diagonal=False, without_bg=True))))
 
21.0, tensor(0.0566), Description: Recolor the second row of the largest object in the input grid to red if the object is wider than it is tall, or recolor the second column of the object to red if the object is taller than it is wide. Keep the original colors of the rest of the object and the background. 
:: def egchfacfbfeaeibjjefadcdjjeaeccdg(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)

  strip_indices = (
      lambda obj: {(uppermost(obj) + 1, j) for j in range(leftmost(obj) + 1, rightmost(obj))} 
      if w >= h 
      else {(i, leftmost(obj) + 1) for i in range(uppermost(obj) + 1, lowermost(obj))}
  )

  O = fill(I, TWO, strip_indices(obj))
  return O
 
4.0, tensor(0.1281), Description: Recolor the inner part of the largest object in the input grid that is not a horizontal line to red. Keep the original colors of the outer border of the object and the background. 
:: def idajdfddcbccehjcbecdbbfcjfjbcbaj(I):
  objs = objects(I, T, F, T)  # Extract objects, ignore background
  def fill_object(obj):
    return fill(I, TWO, difference(inbox(obj), box(obj))) if size(obj) > 1 and not hline(obj) else I
  return last(apply(fill_object, objs)) # Apply filling and return the last grid
 
11.5, tensor(0.1281), Description: Recolor the inner part of the largest object in the input grid that is not a horizontal line to red. Keep the original colors of the outer border of the object and the background. 
:: def eaeefijjadabeedeiaaeddecgcjafcdf(I):
  def process_object(obj):
    return fill(I, TWO, delta(sfilter(backdrop(obj), lambda loc: contained(loc, inbox(obj))))) if size(obj) > 1 and not hline(obj) else I
  return last(apply(process_object, objects(I, T, F, T)))
 
1.5, tensor(0.1281), Description: Recolor the inner part of the largest object in the input grid that is not a horizontal line to red. Keep the original colors of the outer border of the object and the background. 
:: def eabebafaijbaegdbaafeibcfddaeeecb(I):
  for obj in objects(I, T, F, T):
    if size(obj) > 1 and not hline(obj):
      I = fill(I, TWO, difference(inbox(obj), box(obj)))
  return I
 
4.0, tensor(0.0257), Description: For each object in the input grid that is larger than 1x1, recolor every other row (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def jdaaeidcdbfdecdajijafbfjcbhghggf(I):
  O = I  # Copy the input grid
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      for i, j in product(range(uppermost(obj) + 1, lowermost(obj), 2), range(leftmost(obj) + 1, rightmost(obj))):
        O = fill(O, 2, {(i, j)}) # Directly fill each cell with '2'
  return O
 
16.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def dffefdfjggbdegabaaddhcgiebahfgcb(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  offset = (1, 0) if h > w else (0, 1) 
  start = add(ulcorner(obj), offset)
  strip = frozenset({add(start, (i, 0)) for i in range(3)}) if h > w else frozenset({add(start, (0, j)) for j in range(3)})
  O = fill(I, TWO, strip)
  return O
 
22.0, tensor(0.7585), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object, excluding the first and last columns. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object, excluding the first and last rows. 
:: def eejcdbcddebgegfdabjgfcghijcfjice(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  strip = (
    frozenset((i, j) for v, (i, j) in obj if uppermost(obj) + 1 <= i <= uppermost(obj) + 3 and leftmost(obj) < j < rightmost(obj)) if h > w 
    else frozenset((i, j) for v, (i, j) in obj if leftmost(obj) + 1 <= j <= leftmost(obj) + 3 and uppermost(obj) < i < lowermost(obj))
  )
  O = fill(I, TWO, strip)
  return O
 
16.0, tensor(1.7742), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object, starting from the second column and extending to the second-to-last column. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object, starting from the second row and extending to the second-to-last row. 
:: def ddfjcafadhadeifebaccggidfjiajdfj(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  if h > w:
    strip = connect((uppermost(obj) + 1, leftmost(obj) + 1), (uppermost(obj) + 3, leftmost(obj) + 1))
  else:
    strip = connect((uppermost(obj) + 1, leftmost(obj) + 1), (uppermost(obj) + 1, leftmost(obj) + 3))
  O = fill(I, TWO, strip)
  return O
 
7.0, tensor(0.1281), Description: Recolor the inner part of the largest object in the input grid that is not a horizontal line to red. Keep the original colors of the outer border of the object and the background. 
:: def cbabjbadcjbeedbfafjabhghceecbeih(I):
  def process_object(grid, obj):
    if size(obj) > 1 and not hline(obj):
      inner_indices = difference(inbox(obj), box(obj))
      return fill(grid, TWO, inner_indices)
    return grid
  return last(papply(process_object, repeat(I, size(objects(I, T, F, T))), objects(I, T, F, T))) 
 
9.0, tensor(0.0487), Description: For each object in the input grid that is larger than 2 squares, recolor every other row (excluding the first and last columns) to red. Keep the original colors of the rest of the object and the background. 
:: def cdhijebecceheiedbbecaibbagebdaef(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(obj) > 2:
      indices_to_change = set()
      for i in range(uppermost(obj) + 2, lowermost(obj), 2):
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          indices_to_change.add((i, j))
      O = fill(O, 2, intersection(toindices(obj), frozenset(indices_to_change)))
  return O
 
13.0, tensor(1.6392), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the center of the object is closer to the top half of the grid, shift the 3x3 square one cell down. If the center of the object is closer to the bottom half of the grid, shift the 3x3 square one cell up. 
:: def gaheecgjchbcehbejaahfcdbceefgfff(I):
  largest_object = argmax(objects(I, univalued=True, diagonal=False, without_bg=True), size)
  h = height(largest_object)
  center_i = uppermost(largest_object) + h // 2
  shift = 1 if center_i < len(I) // 2 else -1
  w = width(largest_object)
  start_row = center_i + shift
  end_row = start_row + 3
  start_col = leftmost(largest_object) + (w - 3) // 2
  end_col = start_col + 3
  target_area = frozenset((i, j) for i in range(start_row, end_row) for j in range(start_col, end_col))
  modified_object = frozenset({(2, (i, j)) if (i, j) in target_area else (v, (i, j)) for v, (i, j) in largest_object})
  return paint(cover(I, largest_object), modified_object)
 
12.0, tensor(1.6845), Description: For each object in the input grid, recolor the 3 squares in the row that is closest to the object's center of mass to red. If the center of mass is closer to the top half of the grid, shift the 3 squares one cell down. If the center of mass is closer to the bottom half of the grid, shift the 3 squares one cell up. Keep the original colors of the rest of the object and the background. 
:: def jcibfbaejeaeefhcbdagaieiejejbgad(I):
  def modify_area(obj):
    h, w = height(obj), width(obj)
    c_i, c_j = centerofmass(obj)
    shift = 1 if c_i < len(I) // 2 else -1
    target_area = frozenset((c_i + shift, j) for j in range(c_j - 1, c_j + 2)) & toindices(obj)
    return recolor(2, target_area), toobject(toindices(obj) - target_area, I)
  modified_objects = [modify_area(obj) for obj in objects(I, univalued=True, diagonal=False, without_bg=True)]
  return paint(I, merge([a for a, _ in modified_objects] + [b for _, b in modified_objects])) 
 
17.0, tensor(1.7253), Description: For each object in the input grid, recolor the 3x3 inner square to red. Keep the original colors of the outer border of the object and the background. If the center of the object is closer to the top half of the grid, shift the 3x3 square one cell down. If the center of the object is closer to the bottom half of the grid, shift the 3x3 square one cell up. The 3x3 square should be centered horizontally within the object. 
:: def edcehcbjcadgegbajfdccefadheeaabj(I):
  def process_object(obj):
    center_i = uppermost(obj) + height(obj) // 2
    shift = 1 if center_i < len(I) // 2 else -1
    target_indices = frozenset(
      (i, j) for i in range(center_i + shift, center_i + shift + 3) 
      for j in range(leftmost(obj) + (width(obj) - 3) // 2, leftmost(obj) + (width(obj) - 3) // 2 + 3)
      if (i, j) in toindices(obj)
    )
    return recolor(2, target_indices), toobject(toindices(obj) - target_indices, I)

  modified_objects = [process_object(obj) for obj in objects(I, univalued=True, diagonal=False, without_bg=True)]
  recolored_parts, remaining_parts = zip(*modified_objects)
  return paint(I, merge(recolored_parts + remaining_parts))
 
13.0, tensor(0.0320), Description: Recolor the 3x3 inner square of the largest object in the input grid to red. Keep the original colors of the outer border of the object and the background. If the object is taller than it is wide, recolor the 3x3 square in the second row of the object. If the object is wider than it is tall, recolor the 3x3 square in the second column of the object. 
:: def eaaccbbibiafebajicebbeaejffahebg(I):
  obj = argmax(objects(I, T, F, F), size)
  h, w = shape(obj)
  O = I
  for i in range(3):
    for j in range(3):
      if (h > w and i == 1) or (w >= h and j == 1):
          O = fill(O, TWO, {(uppermost(obj) + 1 + i, leftmost(obj) + 1 + j)}) 
  return O
 
44.0, tensor(0.0240), Description: For each object in the input grid that is larger than 1x1, shift the object one square up and either right or left depending on its position in the grid. If the object is in the top half of the grid, shift it one square up and one square to the right. If the object is in the bottom half of the grid, shift it one square up and one square to the left. Keep the original colors of the object and the background. The background should be black. 
:: def dbbcaahcjhdeefigjaeeehfeeeiadchf(I):
  O = canvas(ZERO, shape(I)) # Create a blank canvas
  for obj in objects(I, T, F, T): # Iterate over each object
    if size(obj) > 1:
      if uppermost(obj) < halve(height(I)): # Check if object is in the top half
        O = paint(O, shift(obj, (NEG_ONE, ONE))) # Shift up and right
      else:
        O = paint(O, shift(obj, (NEG_ONE, NEG_ONE))) # Shift up and left
  return O
 
47.5, tensor(0.0239), Description: For each object in the input grid that is larger than 1x1, shift the object horizontally to the right edge of the grid if the object is taller than it is wide, or shift the object horizontally to the left edge of the grid if the object is wider than it is tall. Keep the original colors of the object and the background. The background should be black. 
:: def eeaedfccichaedffiifhbaaacbbbghbe(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      w = width(obj)
      if portrait(obj): # Check if object is taller than wide
        O = paint(O, shift(obj, (ZERO, w - 1))) # Shift right by width - 1
      else:
        O = paint(O, shift(obj, (ZERO, -(w - 1)))) # Shift left by width - 1
  return O
 
53.5, tensor(0.0260), Description: For each object in the input grid that is larger than 1x1, shift the object horizontally to the right edge of the grid if the object's center of mass is closer to the top half of the grid, or shift the object horizontally to the left edge of the grid if the object's center of mass is closer to the bottom half of the grid. Keep the original colors of the object and the background. The background should be black. 
:: def ciaabdihhcdceejfiddaacfjhbgdgfhc(I):
  objs = objects(I, T, F, T)
  O = fill(I, ZERO, asindices(I)) # Create a blank canvas
  for obj in objs:
    if size(obj) > 1:
      c = centerofmass(obj)
      if c[0] < halve(height(I)): # Check object's center of mass vertical position
        O = paint(O, shift(obj, (ZERO, width(obj) - 1))) # Shift right by width - 1
      else:
        O = paint(O, shift(obj, (ZERO, -(width(obj) - 1)))) # Shift left by width - 1
  return O
 
49.0, tensor(0.0192), Description: For each object in the input grid that is larger than 1x1, shift the object one square up and either right or left depending on its color. If the object is colored '5', shift it one square up and one square to the right. If the object is any other color, shift it one square up and one square to the left. Keep the original colors of the object and the background. The background should be black. 
:: def ggagjeiicehdedfcbidigbbjfcdhdcjg(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      if color(obj) == 5: # Check if object color is 5
        O = paint(O, shift(obj, (NEG_ONE, width(obj) - 1))) # Shift up and right by width - 1
      else:
        O = paint(O, shift(obj, (NEG_ONE, -(width(obj) - 1)))) # Shift up and left by width - 1
  return O
 
42.0, tensor(0.0211), Description: For each object in the input grid that is larger than 1x1, shift the object one square up and either right or left depending on its size. If the object is the largest, shift it one square up and one square to the right. If the object is any other size, shift it one square up and one square to the left. Keep the original colors of the object and the background. The background should be black. 
:: def ccfffeffbcfceaacaieadadahbhegcab(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    if size(obj) > 1:
      if obj == argmax(objects(I, T, F, T), size): # Check if object is the largest
        O = paint(O, shift(obj, (NEG_ONE, ONE))) # Shift up and right
      else:
        O = paint(O, shift(obj, (NEG_ONE, NEG_ONE))) # Shift up and left
  return O
 
58.5, tensor(0.0073), Description: Copy the input grid and make the background black. Then, move the red object one space to the right. Finally, enlarge the red object by a factor of two. 
:: def gjbffdicicedeedajjbeggdejbbdjbbg(I):
    obj2 = first(colorfilter(objects(I, T, F, F), TWO))
    obj5 = first(colorfilter(objects(I, T, F, F), FIVE))
    O = paint(paint(canvas(ZERO, shape(I)), shift(obj2, RIGHT)), upscale(obj2, TWO))
    return O
 
42.5, tensor(0.0073), Description: Copy the input grid and make the background black. Then, move the red object one space to the right. Finally, enlarge the red object by a factor of two. 
:: def aijdbcccbffbefgajhjejafcdfeebfad(I):
    objs = objects(I, T, F, F)
    obj2 = first(sfilter(objs, lambda obj: color(obj) == TWO))
    obj5 = first(sfilter(objs, lambda obj: color(obj) == FIVE))
    new_obj2 = upscale(shift(obj2, RIGHT), TWO)
    O = paint(paint(canvas(ZERO, shape(I)), new_obj2), obj5)
    return O
 
47.0, tensor(0.0084), Description: Copy the input grid and make the background black. Then, move the red object one space to the right. Finally, enlarge the red object by a factor of two. Keep the original gray object in its original position. 
:: def gibbfdhfjddcejeiiabgjcdbafbdcihi(I):
  bg = mostcolor(I)
  O = replace(I, bg, ZERO)
  for obj in objects(I, T, F, F):
    if color(obj) == TWO:
      O = paint(O, upscale(shift(obj, RIGHT), TWO))
    elif color(obj) == FIVE:
      O = paint(O, obj)
  return O
 
49.5, tensor(0.0084), Description: Copy the input grid and make the background black. Then, move the red object one space to the right. Finally, enlarge the red object by a factor of two. Keep the original gray object in its original position. 
:: def jdafjdfeccdbeejfbfecafccbddhcfdf(I):
    is_two = lambda obj: color(obj) == TWO
    is_five = lambda obj: color(obj) == FIVE
    obj2 = extract(objects(I, T, F, F), is_two)
    obj5 = extract(objects(I, T, F, F), is_five)
    O = paint(
        fill(canvas(ZERO, shape(I)), FIVE, toindices(upscale(obj2, TWO))), 
        shift(obj2, RIGHT)
    )
    return O 
 
87.5, tensor(0.0304), Description: Copy the input grid and make the background black. Then, move the gray object one space to the right and down. Finally, enlarge the red object by a factor of two, and change its color to gray. Keep the original gray object in its original position. 
:: def dcaadcbcffhbeeajiacdcbgfbgbdbfbc(I):
  obj2 = normalize(first(colorfilter(objects(I, T, F, F), 2)))
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  new_obj2 = frozenset()
  for v, (i, j) in obj2:
    new_obj2 = insert((5, (i, j)), new_obj2)
    new_obj2 = insert((5, (i + 1, j + 1)), new_obj2)
    if i > 0 and j > 0:
      new_obj2 = insert((5, (i + 1, j)), new_obj2)
  O = paint(paint(canvas(0, add(shape(I), (2, 2))), shift(obj5, (1, 1))), shift(new_obj2, add(ulcorner(first(colorfilter(objects(I, T, F, F), 2))), (1, 1))))
  return O
 
17.0, tensor(1.7886), Description: 
Copy the input grid. For each red square, if it is in the bottom right quadrant of the grid, change it to gray. If it is in the top left quadrant, change it to gray. If it is in the top right quadrant, change it to gray. If it is in the bottom left quadrant, change it to gray. If it is not in any of these quadrants, leave it red. 
:: def djfffeedeabheaejibcffffbecdceihb(I):
  bg = mostcolor(I)
  return tuple(
    tuple(
      branch(
        equality(v, bg), 0, branch(
          equality(v, 2), branch(
            both(greater(i, 2), greater(j, 2)), 5, branch(
              either(equality(i, 2), equality(j, 2)), 5, v
            )
          ), v
        )
      ) for j, v in enumerate(row)
    ) for i, row in enumerate(I)
  )
 
22.0, tensor(1.2096), Description: Copy the input grid and make the background black. Then, for each red square, create a 2x2 gray square with the red square in the top left corner of the gray square. Keep the original gray object in its original position. 
:: def gaaibdifffiaejdbachbaefgidcjebce(I):
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  O = canvas(0, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if contained((2, (i, j)), obj2):
        O = fill(O, 5, {(i, j), (i + 1, j), (i + 1, j + 1)})
      elif contained((5, (i, j)), obj5):
        O = fill(O, 5, {(i, j)})
  return O
 
95.0, tensor(0.0045), Description: 
Copy the input grid and make the background black. Then, move the first colored object to the right edge of the grid. Then, move the second colored object so that it is in the same relative position to the first colored object as it was in the original input grid. 
:: def hcehbceeedgbeacaiihfagfdjjbecbfh(I):
    objs = objects(I, T, F, T) 
    bg = mostcolor(I)
    canvas_size = astuple(TEN, TEN) 
    canvas_color = bg  
    
    obj1 = first(objs) 
    obj2 = last(objs)
    
    pos1 = ulcorner(canvas(ZERO, canvas_size)) 
    repositioned_obj1 = shift(obj1, add(pos1, (ZERO, width(obj1))))
    
    relative_pos = subtract(center(obj2), center(obj1))
    pos2 = add(center(repositioned_obj1), relative_pos)
    repositioned_obj2 = shift(obj2, pos2)
    
    O = paint(paint(canvas(canvas_color, canvas_size), repositioned_obj1), repositioned_obj2)
    return O
 
49.0, tensor(0.0059), Description: Copy the input grid and make the background black. Then, move the first colored object to the right edge of the grid, one space to the right and one space down. Then, move the second colored object so that it is in the same relative position to the first colored object as it was in the original input grid. 
:: def igeaddbehchaebafifajifiaegbccbdg(I):
    obj1, obj2 =  objects(I, T, F, T) 
    
    obj1_new_pos = (ONE, width(obj1) + ONE) 
    moved_obj1 = shift(obj1, subtract(obj1_new_pos, ulcorner(obj1)))
    
    obj2_new_pos = add(obj1_new_pos, subtract(center(obj2), center(obj1)))
    moved_obj2 = shift(obj2, subtract(obj2_new_pos, ulcorner(obj2)))
    
    O = paint(paint(canvas(ZERO, (TEN, TEN)), moved_obj1), moved_obj2)
    return O
 
45.0, tensor(0.0053), Description: Copy the input grid and make the background black. Then, move the largest colored object to the right edge of the grid, one space to the right and one space down. Then, move the other colored object so that it is in the same relative position to the largest colored object as it was in the original input grid. 
:: def cbbcdbebefdeecdjbjceaecdbjffadba(I):
    objs = objects(I, T, F, T)
    obj1 = argmax(objs, size)  
    obj2 = other(objs, obj1)
    
    canvas_size = (TEN, TEN)
    new_grid = canvas(ZERO, canvas_size)
    
    new_grid = paint(new_grid, shift(obj1, (ONE, width(obj1) + ONE)))
    new_grid = paint(new_grid, shift(obj2, add((ONE, width(obj1) + ONE), subtract(center(obj2), center(obj1)))))
    
    return new_grid
 
46.0, tensor(0.0052), Description: Copy the input grid and make the background black. Then, move both colored objects one space to the right and one space down. 
:: def fecceadfdiajecgbicbdadaciddibbbd(I):
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs)

    offset = subtract((ONE, width(obj1) + ONE), ulcorner(obj1))
    moved_obj1 = shift(obj1, offset)
    moved_obj2 = shift(obj2, offset)

    return paint(paint(canvas(ZERO, (TEN, TEN)), moved_obj1), moved_obj2)
 
79.0, tensor(0.0236), Description: Copy the input grid and make the background black. Then, for each red object, move it one space to the left. Then, copy the two rightmost columns of the red object and paste them two columns to the right of the red object. Keep the original colors of all other objects. 
:: def deafdiedeafbejbbacaaafbdgaiggich(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 2:
      O = paint(O, shift(obj, (NEG_ONE, ZERO)))
      O = paint(O, shift(toobject(crop(I, (uppermost(obj), rightmost(obj)-TWO), (height(obj), TWO)), I), (uppermost(obj), rightmost(obj)+TWO)))
    else:
      O = paint(O, obj)
  return O 
 
79.0, tensor(0.0230), Description: Copy the input grid and make the background black. Then, for each red object, move it one space to the left. Then, copy the two rightmost columns of the red object and paste them four columns to the right of the red object. Keep the original colors of all other objects. 
:: def bgadidbdecgceeffbbjbdceeadjbfcfg(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if color(obj) == 2:
      shifted_obj = shift(obj, (NEG_ONE, ZERO))
      replicated_part = toobject(crop(I, (uppermost(obj), rightmost(obj)-TWO), (height(obj), TWO)), I)
      shifted_replication = shift(replicated_part, (ZERO, FOUR))
      O = paint(paint(O, shifted_obj), shifted_replication)
    else:
      O = paint(O, obj)
  return O
 
42.5, tensor(0.0084), Description: Copy the input grid and make the background black. Then, move the red object one space to the right. Finally, enlarge the red object by a factor of two. Keep the original gray object in its original position. 
:: def cfedbecaddddegbfaeaahdigfaefacca(I):
  O = replace(I, mostcolor(I), ZERO)
  two_obj = extract(objects(I, T, F, F), lambda obj: color(obj) == TWO)
  five_obj = extract(objects(I, T, F, F), lambda obj: color(obj) == FIVE)
  O = paint(O, shift(upscale(two_obj, TWO), RIGHT))
  O = paint(O, five_obj)
  return O
 
29.0, tensor(0.0074), Description: Copy the input grid and make the background black. Then, for each red square, enlarge it by a factor of two and move it one space to the right. Keep the original gray object in its original position. 
:: def afahbhhfgadbeaeajhcccfffiifjfedg(I):
  O = canvas(ZERO, shape(I))
  for v, loc in asobject(I):
    if v == TWO:
      O = underpaint(O, shift({(v, (loc[0] * 2, loc[1] * 2))}, RIGHT)) 
    elif v == FIVE:
      O = underpaint(O, {(v, loc)})
  return O
 
28.5, tensor(0.1380), Description: Copy the input grid and make the background black. Then, move the gray object one space to the right and down. For each red square, if it is in an even column of the moved red object, change it to red. Otherwise, change it to gray. Keep the original gray object in its original position. 
:: def gjecfcbjjcedeghiibbfeifaffhbhdid(I):
  obj2 = toindices(first(colorfilter(objects(I, T, F, F), 2)))
  obj5 = toindices(first(colorfilter(objects(I, T, F, F), 5)))
  shifted_obj2 = shift(obj2, (1, 1))
  O = canvas(0, shape(I))
  for i, j in asindices(I):
    if contained((i,j), obj5):
      O = fill(O, 5, {(i, j)})
    elif contained((i,j), shifted_obj2) and even(j - leftmost(shifted_obj2)):
      O = fill(O, 2, {(i, j)})
    elif contained((i,j), shifted_obj2):
      O = fill(O, 5, {(i, j)})
  return O
 
79.0, tensor(0.0120), Description: Copy the input grid. Find the largest object and draw a frame around it using the color of the smaller object. Then, extend the frame upwards and to the left or right (depending on the position of the smaller object) using the color of the smaller object. Fill the area inside the frame with the color of the smaller object. Finally, paint the largest object back onto the grid, keeping its original color. 
:: def bfeddcagacdeebicbbdfdhfcbbcibhaa(I):
  bg = mostcolor(I)  
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  frame = box(large)
  top_extension = connect(ulcorner(frame), (0, ulcorner(frame)[1])) 
  side_extension = connect(ulcorner(frame), (ulcorner(frame)[0], 0)) if leftmost(small) < leftmost(large) else connect(urcorner(frame), (urcorner(frame)[0], len(I[0])-1))
  filled_extension = underfill(I, color(small), top_extension | side_extension)
  painted_frame = underfill(filled_extension, color(small), frame)
  O = paint(painted_frame, large)
  return O 
 
89.5, tensor(0.0120), Description: Copy the input grid and make the background black. Then, find the smaller object and draw a frame around the larger object using the color of the smaller object. Then, extend the frame upwards and to the left or right (depending on the position of the smaller object) using the color of the smaller object. Fill the area inside the frame with the color of the smaller object. Finally, paint the larger object back onto the grid, keeping its original color. 
:: def iagfjdbafcjfeibabhdaehfibdajdhch(I):
  small_color = leastcolor(trim(I)) # Extract color from trimmed grid 
  large = asobject(compress(replace(I, small_color, mostcolor(I)))) # Remove smaller object and compress to get larger object 
  frame = box(large)
  top_extension = connect(ulcorner(frame), (0, ulcorner(frame)[1]))
  side_extension = connect(ulcorner(frame), (ulcorner(frame)[0], 0)) if colorcount(I, small_color) < len(I[0]) // 2 else connect(urcorner(frame), (urcorner(frame)[0], len(I[0])-1))
  O = paint(underfill(canvas(mostcolor(I), shape(I)), small_color, frame | top_extension | side_extension), large)
  return O
 
86.0, tensor(0.0120), Description: Copy the input grid and make the background black. Then, find the smaller object and draw a frame around the larger object using the color of the smaller object. Then, extend the frame upwards and to the left or right (depending on the position of the smaller object) using the color of the smaller object. Fill the area inside the frame with the color of the smaller object. Finally, paint the larger object back onto the grid, keeping its original color. 
:: def cebahgbdagbhehiiaeffbbbgbfciddba(I):
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  f = box(large)
  top = connect(ulcorner(f), (0, ulcorner(f)[1]))
  side = connect(ulcorner(f), (ulcorner(f)[0], 0)) if centerofmass(small)[1] < centerofmass(large)[1] else connect(urcorner(f), (urcorner(f)[0], len(I[0]) - 1))
  O = paint(underfill(canvas(mostcolor(I), shape(I)), color(small), f | top | side), large)
  return O
 
95.0, tensor(0.0059), Description: Copy the input grid and make the background black. Then, move the first colored object to the right edge of the grid, one space to the right and one space down. Then, move the second colored object so that it is in the same relative position to the first colored object as it was in the original input grid. 
:: def jcahccjcichbeficiijdjjbgciaecdfe(I):
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs)

    canvas_size = astuple(TEN, TEN)
    canvas_color = mostcolor(I)

    pos1 = (ONE, width(obj1) + ONE)
    repositioned_obj1 = shift(obj1, pos1)

    relative_pos = subtract(center(obj2), center(obj1))
    pos2 = add(center(repositioned_obj1), relative_pos)
    repositioned_obj2 = shift(obj2, pos2)

    O = paint(paint(canvas(canvas_color, canvas_size), repositioned_obj1), repositioned_obj2)
    return O
 
95.0, tensor(0.0059), Description: Copy the input grid and make the background black. Then, move the first colored object to the right edge of the grid, one space to the right and one space down. Then, move the second colored object so that it is in the same relative position to the first colored object as it was in the original input grid. 
:: def febefafggfaeejdcifhaccfcjcjiaagj(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    obj1 = next(iter(objs))
    obj2 = next(iter(objs - {obj1}))

    offset = (ONE, width(obj1) + ONE)
    new_obj1 = shift(obj1, offset)
    new_obj2 = shift(obj2, add(offset, subtract(center(obj2), center(obj1))))

    return paint(paint(canvas(bg, (TEN, TEN)), new_obj1), new_obj2)
 
44.0, tensor(0.0056), Description: Copy the input grid and make the background black. Then, move the object with the most gray squares to the right edge of the grid, one space to the right and one space down. Then, move the object with the fewest gray squares so that it is in the same relative position to the first object as it was in the original input grid. 
:: def ebebifhbfifgegibafcbhdjfcfjffeig(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: colorcount(obj, FIVE))
  obj2 = argmin(objs, lambda obj: colorcount(obj, FIVE))
  
  offset = (ONE, width(obj1) + ONE)
  obj1_shifted = shift(obj1, offset)
  obj2_shifted = shift(obj2, add(offset, subtract(center(obj2), center(obj1))))
  
  return paint(paint(canvas(ZERO, (TEN, TEN)), obj1_shifted), obj2_shifted)
 
33.5, tensor(0.0081), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two, and place it to the right of the gray object. Keep the original gray object in its original position. 
:: def caedifhccafbebfiafciaabchjhbhigd(I):
  two_indices = toindices(extract(objects(I, T, F, F), matcher(color, TWO)))
  five_indices = toindices(extract(objects(I, T, F, F), matcher(color, FIVE)))
  new_two_indices = frozenset(
      {(i + height(five_indices), 2 * j + width(five_indices)) for i, j in two_indices} | 
      {(i + height(five_indices), 2 * j + width(five_indices) + 1) for i, j in two_indices}
  )
  return fill(fill(canvas(ZERO, shape(I)), FIVE, five_indices), TWO, new_two_indices)
 
52.0, tensor(0.0089), Description: Copy the input grid and make the background black. Then, move the gray object to the right edge of the grid. Then, enlarge the red object by a factor of two and place it above the gray object. Finally, enlarge the red object by a factor of two again and place it to the right of the gray object. Crop the output grid to the original size of the input grid. 
:: def hbfabcabfecdeifbacibjbfcehaabbfe(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  canvas_dims = (height(I), width(I) + width(obj2))
  O = paint(canvas(ZERO, canvas_dims), shift(obj5, (ZERO, width(obj2))))
  O = paint(O, shift(upscale(obj2, TWO), (height(obj5), ZERO)))
  O = paint(O, shift(upscale(obj2, TWO), (height(obj5), width(obj2))))
  return crop(O, (ZERO, ZERO), shape(I))
 
25.5, tensor(0.1266), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the closest position to the larger object. If the smaller object is above the larger object, change its color to red. Otherwise, keep its original color. Finally, fill the area around the larger object with the color of the larger object. 
:: def dfedieahcchaeiajiajcjbcjahdcbfbc(I):
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  O = paint(
      fill(canvas(0, shape(I)), color(large), backdrop(shift(large, gravitate(small, large)))),
      recolor(branch(centerofmass(small)[1] < centerofmass(large)[1], 2, color(small)), small)
  )
  return O
 
34.5, tensor(0.0937), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the closest position to the larger object. If the smaller object is to the right of the larger object, change the color of the larger object to red. Otherwise, keep the color of the larger object. Finally, fill the area around the larger object with the color of the larger object. 
:: def caeeeebcbgfjecjdbbcbiaeedbaahffa(I):
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  offset = gravitate(small, large)
  O = paint(
      paint(
          fill(canvas(0, shape(I)), color(large), backdrop(shift(large, offset))), 
          recolor(2, shift(small, offset))
      ),
      recolor(branch(offset[1] > 0, 2, color(large)), shift(large, offset))
  )
  return O
 
41.5, tensor(0.0317), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to red. Finally, fill the area around the larger object with the color of the larger object. 
:: def heafjfbgjfgeeabbadbajafhijafdeic(I):
    objs = objects(I, True, False, True)
    small = argmin(objs, size)
    large = argmax(objs, size)
    target_pos = (uppermost(large), leftmost(large) + width(large) + 1)
    shift_amount = subtract(target_pos, ulcorner(small))
    O = paint(fill(canvas(0, shape(I)), color(large), backdrop(shift(large, shift_amount))), shift(recolor(2, small), shift_amount))
    return O
 
33.5, tensor(0.0317), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to red. Finally, fill the area around the larger object with the color of the larger object. 
:: def igeffcahdfbcefbijgegfdcijajbfddj(I):
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  O = fill(canvas(0, shape(I)), color(large), backdrop(large))
  O = paint(O, shift(recolor(2, small), (uppermost(large) - uppermost(small), rightmost(large) - leftmost(small) + 1)))
  return O
 
41.0, tensor(0.0722), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it two spaces down and six spaces to the right, and move the second colored object one space up. Otherwise, move the first colored object one space down and one space to the right. Then, move the second colored object seven spaces down and four spaces to the right. If the second colored object is gray, change its color to red. Otherwise, keep its original color. 
:: def egejbaaebdieefjaajhajjgcgfgjcbei(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T) 
    obj1 = first(objs)
    obj2 = last(objs)

    if size(obj1) < size(obj2):
        obj1, obj2 = obj2, obj1 

    new_bg = 0 
    O = replace(I, bg, new_bg)

    if shape(obj1) == (2, 2):
        O = paint(O, shift(recolor(2, obj1), (2, 6)))
        O = paint(O, shift(obj2, (-1, 0)))
    else:
        temp = paint(canvas(new_bg, (10,10)), shift(obj1, (1, 1)))
        O = paint(temp, shift(recolor(branch(color(obj2)==5, 2, 5), obj2), (7, 4))) 
    return O
 
27.0, tensor(0.0722), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it two spaces down and six spaces to the right, and move the second colored object one space up. Otherwise, move the first colored object one space down and one space to the right. Then, move the second colored object seven spaces down and four spaces to the right. If the second colored object is gray, change its color to red. Otherwise, keep its original color. 
:: def ccbffdahdfbceacgicijeaccafgbjhee(I):
  objs = objects(I, T, F, T)
  obj1 = first(objs)
  obj2 = last(objs)
  bg = mostcolor(I)

  if len(obj1) < len(obj2):
    obj1, obj2 = obj2, obj1

  canvas_color = 0
  O = paint(canvas(canvas_color, (10, 10)), obj1) 

  if width(obj2) == TWO:
    O = paint(O, shift(recolor(TWO, obj2), add((TWO, SIX), ulcorner(obj1)))) 
  else:
    O = paint(O, shift(recolor(branch(equality(color(obj2), FIVE), TWO, FIVE), obj2), (SEVEN, FOUR)))
  return O
 
50.0, tensor(0.0684), Description: Copy the input grid and make the background black. Find the largest object and the smallest object. Move the largest object to the right edge of the grid. If the smallest object is a 2x2 square, move it two spaces down and one space to the right of the largest object. Otherwise, move the smallest object seven spaces down and four spaces to the right of the largest object. If the largest object is gray, change the color of the smallest object to red. Otherwise, keep the color of the smallest object. 
:: def gdgjajdjehbdeafciddebcbbdhddfaag(I):
  bg = mostcolor(I) 
  objs = objects(I, T, F, T)
  obj1 = next(iter(sfilter(objs, lambda obj: size(obj) == maximum(apply(size, objs)))))
  obj2 = next(iter(sfilter(objs, lambda obj: size(obj) == minimum(apply(size, objs)))))

  O = paint(canvas(0, (10, 10)), shift(obj1, (ZERO, width(obj1))))

  if width(obj2) == 2:
    O = paint(O, shift(recolor(2, obj2), add((TWO, width(obj1) + ONE), ulcorner(obj1))))
  else:
    O = paint(O, shift(recolor(branch(color(obj1)==5, 2, 5), obj2), (SEVEN, FOUR)))
  return O
 
55.5, tensor(0.0248), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it one space up and either left or right depending on its color. If the object is red, shift it one space up and one space to the right. If the object is any other color, shift it one space up and one space to the left. Keep the original colors of the object and the background. 
:: def cfgcchgibebcecfbjfediafhddcaefhd(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    direction = (1 if color(obj) == 2 else -1) * (width(obj) - 1)  # Calculate direction based on color
    O = paint(O, shift(obj, (-1, direction)))  # Shift up and left/right based on direction
  return O
 
28.5, tensor(1.8039), Description: Copy the input grid and make the background black. Then, for each red square, create a 2x2 square with the red square in the top left corner. If the red square is in an even column, the 2x2 square should be gray. If the red square is in an odd column, the 2x2 square should be light blue. Keep the original gray object in its original position. 
:: def dehbedjadjafedddjedcebbgcbadbbaa(I):
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  O = paint(canvas(0, shape(I)), obj5)
  for i, j in toindices(obj2):
    new_color = 5 - (j - leftmost(obj2)) % 2 * 3
    O = fill(O, new_color, {(i+1, j+1)})
  return O
 
50.5, tensor(0.0317), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to red. Finally, fill the area around the larger object with the color of the larger object. 
:: def hagcbfadbabdefcbacbdfgeafchiccdi(I):
  small = asobject(crop(I, ulcorner(argmin(objects(I, T, F, T), size)), shape(argmin(objects(I, T, F, T), size))))
  large = asobject(crop(I, ulcorner(argmax(objects(I, T, F, T), size)), shape(argmax(objects(I, T, F, T), size))))
  O = paint(
      fill(canvas(0, shape(I)), color(large), backdrop(large)),
      shift(recolor(2, small), (uppermost(large) - uppermost(small), rightmost(large) - leftmost(small) + 1))
  )
  return O
 
27.0, tensor(0.0203), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to red. If the smaller object is above the larger object, move it down to the same row as the larger object. Finally, fill the area around the larger object with the color of the larger object. 
:: def gggbifeagbeaedahibfgcccbhcdiific(I):
  objs = objects(I, T, F, T)
  small = argmin(objs, size)
  large = argmax(objs, size)
  v_offset = branch(centerofmass(small)[0] < centerofmass(large)[0], 0, height(large) - height(small))
  O = paint(
      fill(canvas(0, shape(I)), color(large), backdrop(large)),
      shift(recolor(2, small), (v_offset, width(large) + 1))
  )
  return O
 
50.0, tensor(0.0203), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to red. If the smaller object is above the larger object, move it down to the same row as the larger object. Finally, fill the area around the larger object with the color of the larger object. 
:: def eiahdcebdeffegedjjcebjifeaegedhi(I):
  objs = objects(I, T, F, T)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)
  small_idx = ulcorner(small_obj)
  large_idx = ulcorner(large_obj)
  O = paint(
      fill(canvas(0, shape(I)), color(large_obj), backdrop(shift(large_obj, (0, width(large_obj) - leftmost(large_obj))))),
      shift(recolor(2, small_obj), (branch(small_idx[0] < large_idx[0], 0, height(large_obj) - height(small_obj)), width(large_obj) - leftmost(large_obj) + 1))
  )
  return O
 
45.0, tensor(0.1266), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the closest position to the larger object. If the smaller object is above the larger object, change its color to red. Otherwise, keep its original color. Finally, fill the area around the larger object with the color of the larger object. 
:: def ebhadjfjaabeejgcjcfhaddcaefiefjd(I):
  small = asobject(crop(I, ulcorner(argmin(objects(I, T, F, T), size)), shape(argmin(objects(I, T, F, T), size))))
  large = difference(asobject(I), small)
  O = paint(
      fill(canvas(0, shape(I)), color(large), backdrop(shift(large, gravitate(small, large)))),
      recolor(branch(centerofmass(small)[1] < centerofmass(large)[1], 2, color(small)), small)
  )
  return O
 
34.0, tensor(0.0048), Description: Copy the input grid and make the background black. Then, move the first colored object to the top left corner of the grid. Then, move the second colored object so that it is in the same relative position to the first colored object as it was in the original input grid. 
:: def hjjdedjfddbjedfhjafdcabgijeedigg(I):
    objs = objects(I, T, F, T) 
    obj1 = first(objs)
    obj2 = last(objs)
    bg = ZERO 
    canvas_size = shape(I)  
    
    pos1 = ORIGIN  
    repositioned_obj1 = shift(obj1, pos1)
    
    relative_pos = subtract(center(obj2), center(obj1))
    pos2 = add(center(repositioned_obj1), relative_pos)
    repositioned_obj2 = shift(obj2, pos2)
    
    O = paint(paint(canvas(bg, canvas_size), repositioned_obj1), repositioned_obj2)
    return O
 
41.0, tensor(0.0052), Description: Copy the input grid and make the background black. Then, move the largest colored object to the top left corner of the grid. Then, move the smallest colored object so that it is in the same relative position to the largest colored object as it was in the original input grid. 
:: def fcaagdehbjbdegdebbidagcfdedaaifd(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, size) 
  obj2 = argmin(objs, size) 
  bg = ZERO
  canvas_size = shape(I)

  repositioned_obj1 = shift(obj1, subtract(ORIGIN, ulcorner(obj1))) 
  repositioned_obj2 = shift(obj2, subtract(center(repositioned_obj1), center(obj2)))

  O = paint(paint(canvas(bg, canvas_size), repositioned_obj1), repositioned_obj2)
  return O
 
42.5, tensor(0.0320), Description: Copy the input grid and make the background black. Then, find the object with the color gray (5). If the first object is gray, move it to the top left corner of the grid. Otherwise, move the last object to the top left corner of the grid. Then, move the other object so that it is in the same relative position to the first object as it was in the original input grid. 
:: def bgfbfbabicccecbfjhffdhajhfhgfaed(I):
  bg = ZERO
  canvas_size = shape(I)
  objs = objects(I, T, F, T)

  obj1 = first(objs) if color(first(objs)) == FIVE else last(objs)
  obj2 = first(remove(obj1, objs))

  repositioned_obj1 = shift(obj1,  subtract(ORIGIN, ulcorner(obj1))) 
  repositioned_obj2 = shift(obj2, subtract(center(repositioned_obj1), center(obj2)))

  O = paint(paint(canvas(bg, canvas_size), repositioned_obj1), repositioned_obj2)
  return O
 
45.5, tensor(0.0374), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color. If the object is gray (5), shift it one space to the right. If the object is red (2), shift it one space up and either left or right depending on its height and width. If the object is taller than it is wide, shift it one space up and one space to the left. If the object is wider than it is tall, shift it one space up and one space to the right. Keep the original colors of the object and the background. 
:: def cadcifceddhfeighbfdbhgebbfieabbb(I):
  O = fill(I, ZERO, asindices(I))  # Blank canvas
  for v in palette(I) - {mostcolor(I)}:
    obj = extract(objects(I, T, F, T), matcher(color, v))
    h, w = shape(obj)
    if v == 5:
      O = paint(O, shift(obj, (0, w - 1)))  # Shift 5 right
    elif v == 2:
      O = paint(O, shift(obj, (-1, -1 if h > w else (w - 1))))  # Shift 2 up and left/right
  return O
 
50.0, tensor(0.0242), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color. If the object is red (2), shift it one space up and either left or right depending on its height and width. If the object is taller than it is wide, shift it one space up and one space to the left. If the object is wider than it is tall, shift it one space up and one space to the right. If the object is any other color, shift it one space to the right. Keep the original colors of the object and the background. 
:: def igbdagbbacgheibdbeihddaafcccbdef(I):
  O = I
  for v in palette(I) - {mostcolor(I)}:
    obj = extract(objects(I, T, F, T), matcher(color, v))
    s = shape(obj)
    d = (1 if v == 2 else -1) * (s[1] - 1 if s[0] < s[1] else 1) 
    O = move(O, obj, (-1 if v == 2 else 0, d))
  return replace(O, mostcolor(I), ZERO)
 
46.5, tensor(0.0374), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color. If the object is gray (5), shift it one space to the right. If the object is red (2), shift it one space up and either left or right depending on its height and width. If the object is taller than it is wide, shift it one space up and one space to the left. If the object is wider than it is tall, shift it one space up and one space to the right. Keep the original colors of the object and the background. 
:: def bbbfbedaifibeacdjahjffgcfbffdhce(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    v = color(obj)
    h, w = shape(obj)
    if v == 5:
      O = paint(O, shift(obj, (0, w - 1)))
    elif v == 2:
      O = paint(O, shift(obj, (-1, -1 if h > w else (w - 1))))
  return O
 
98.0, tensor(0.0454), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color. If the object is gray (5), shift it one space to the right. If the object is red (2), shift it one space up and either left or right depending on its height and width. If the object is taller than it is wide, shift it one space up and one space to the left. If the object is wider than it is tall, shift it one space up and one space to the right. If the object is any other color, leave it in its original position. Keep the original colors of the object and the background. 
:: def fabhjbagejccefefidhdafiheecajjej(I):
  O = I
  for obj in objects(I, T, F, T):
    v = color(obj)
    if v != mostcommon(I):
      if v == 5:
        O = move(O, obj, (0, width(obj) - 1))
      else: 
        O = move(O, obj, (-1, (-1) * (width(obj) - 1)))
  return replace(O, mostcommon(I), ZERO) 
 
44.0, tensor(0.0454), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color. If the object is gray (5), shift it one space to the right. If the object is red (2), shift it one space up and either left or right depending on its height and width. If the object is taller than it is wide, shift it one space up and one space to the left. If the object is wider than it is tall, shift it one space up and one space to the right. If the object is any other color, leave it in its original position. Keep the original colors of the object and the background. 
:: def bbjfiaddddcjeiadiccffbadjajdicbc(I):
  O = fill(I, ZERO, asindices(I))
  for obj in objects(I, T, F, T):
    v = color(obj)
    if v != mostcommon(I):
      if v == 5:
        O = paint(O, shift(obj, (0, width(obj) - 1)))
      else:
        O = paint(O, shift(obj, (-1, -(width(obj) - 1))))
  return O
 
27.0, tensor(0.0075), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two and place it to the right of the gray object. Then, enlarge the red object by a factor of two again and place it below the gray object. Keep the original gray object in its original position. 
:: def ccdcdgdbgbdeeecbbahehjbdgbfbcddd(I):
  obj2 = extract(objects(I, T, F, F), lambda obj: color(obj) == TWO)
  obj5 = extract(objects(I, T, F, F), lambda obj: color(obj) == FIVE)
  O = fill(canvas(ZERO, shape(I)), FIVE, toindices(obj5))
  upscaled_obj2 = upscale(obj2, TWO)
  O = paint(O, shift(upscaled_obj2, (uppermost(obj5), rightmost(obj5) + 1)))
  O = paint(O, shift(upscaled_obj2, (lowermost(obj5) + 1, leftmost(obj5)))) 
  return O
 
43.5, tensor(0.0098), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, enlarge the red object by a factor of two, and move it one space to the left and up. Keep the original gray object in its original position. 
:: def fcbaicdddfjbegiaiecebecdicacddcc(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shifted_obj5 = shift(obj5, (-1, -1))
  expanded_obj2 = frozenset(
      (2, (i + di, j + dj)) 
      for di in range(2) 
      for dj in range(2) 
      for v, (i, j) in obj2
  )
  shifted_obj2 = shift(expanded_obj2, (-1, -1))
  O = paint(paint(canvas(0, shape(I)), shifted_obj5), shifted_obj2)
  return O
 
43.0, tensor(0.0096), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, transpose the red object (swap rows and columns) and move it one space to the left and up. Keep the original gray object in its original position. 
:: def efeccadhfcdaehebbhjbfdhbcjaedfda(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shifted_obj5 = shift(obj5, (-1, -1))
  transposed_obj2 = frozenset(
      (2, (j, i))
      for v, (i, j) in obj2
  )
  shifted_obj2 = shift(transposed_obj2, (-1, -1))
  O = paint(paint(canvas(0, shape(I)), shifted_obj5), shifted_obj2)
  return O
 
71.5, tensor(0.0096), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, enlarge the red object by a factor of two and move it two spaces to the left and up. Keep the original gray object in its original position. 
:: def caighfedchaaeabgbjfeaefdadbceagc(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(
      paint(canvas(0, shape(I)), shift(obj5, (-1, -1))), 
      shift(upscale(obj2, 2), (-2, -2))
  )
  return O
 
35.5, tensor(0.0086), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left. Finally, flip the red object diagonally and move it one space to the left and up. Keep the original gray object in its original position. 
:: def cjaedacdgecbeeedadagfagcdegdjfha(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(
      paint(canvas(0, shape(I)), shift(obj5, (0, -1))), 
      shift(dmirror(obj2), (-1, -1))
  )
  return O
 
59.5, tensor(0.0107), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. If the red object is taller than it is wide, flip it diagonally and move it one space to the left and up. Otherwise, enlarge the red object by a factor of two and move it two spaces to the left and up. Keep the original gray object in its original position. 
:: def gjcbfchfhbjcedgeidhbbceadfgfdjeb(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shift_amount = (-1, -1)
  if portrait(obj2):
    transformed_obj2 = shift(dmirror(obj2), shift_amount)
  else:
    transformed_obj2 = shift(upscale(obj2, 2), (-2, -2))
  O = paint(
      paint(canvas(0, shape(I)), shift(obj5, shift_amount)), 
      transformed_obj2
  )
  return O
 
33.0, tensor(0.0206), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it one space to the right and one space down, then create a 3x3 red square with the top left corner of the red square aligned with the top left corner of the first object. Otherwise, move the first colored object one space to the right and one space down. Then, move the second colored object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. If the second colored object is gray, change its color to red. Otherwise, keep its original color. 
:: def gebbgabaachdecgdbbcacchbjdadffbd(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs)

    if size(obj1) < size(obj2):
        obj1, obj2 = obj2, obj1

    O = paint(canvas(0, (10, 10)), shift(obj1, (-leftmost(obj1), 0)))

    if width(obj2) == 2:
        O = paint(O, shift(recolor(2, obj2), (uppermost(obj1) + 1, width(obj1) + 1)))
        O = underpaint(O, shift(recolor(2, obj2), (uppermost(obj1) + 2, width(obj1) + 2)))
        O = underpaint(O, shift(recolor(2, obj2), (uppermost(obj1) + 3, width(obj1) + 1)))
    else:
        O = paint(O, shift(recolor(2, obj2), (height(O) - height(obj2) - 1, 1)))
        O = paint(O, shift(hmirror(recolor(2, obj2)), (height(O) - height(obj2), width(obj2) + 1)))

    return O
 
37.0, tensor(0.0353), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. 
:: def ffdjcaffjfccehbajheehfecjcejdjfi(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    if color(obj) == 5:
      O = paint(O, shift(obj, (-1, 0)))  # Shift '5' object up by one unit
    elif color(obj) == 2:
      if width(obj) > 3:  # Identify the wider '2' object
        O = paint(O, shift(obj, (0, 1))) # Shift right by one unit
        O = paint(O, shift(obj, (4, 2)))  # Duplicate and shift down and right
      else:
        O = paint(O, obj) # Keep smaller '2' object in place
    else:
      O = paint(O, obj)  # Keep other objects unchanged
  return O
 
37.5, tensor(0.0208), Description: Copy the input grid and make the background black. Then, shift the gray object one space up. If the red object is wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and three spaces to the right. If the red object is not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. 
:: def bbdbiiadajfiegdijfjbhgbdahfbfjje(I):
  O = canvas(ZERO, shape(I))
  objs = objects(I, T, F, T)
  fives = first(sfilter(objs, matcher(color, 5)))
  twos = first(sfilter(objs, matcher(color, 2)))
  O = paint(O, shift(fives, (-1, 0))) # Shift '5' object up
  if width(twos) > 3:
    O = paint(O, shift(twos, (0, 1)))  # Shift right 
    O = paint(O, shift(twos, (4, 3)))  # Duplicate and shift down and right
  else:
    O = paint(O, twos)
  return O 
 
39.0, tensor(0.0210), Description: Copy the input grid and make the background black. Then, shift the gray object one space up. If the red object is wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the red object is not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. 
:: def hiaahfdafdebeebhihceegacbbhddace(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    c = color(obj)
    if c == 5:
      O = paint(O, shift(obj, (-1, 0)))
    elif c == 2:
      O = paint(O, shift(obj, (0, 1)))
      if width(obj) > 3:
        O = paint(O, shift(obj, (4, 2)))
  return O
 
48.5, tensor(0.0055), Description: Copy the input grid and make the background black. Then, move the gray object to the right edge of the grid. Then, enlarge the red object by a factor of two and place it above the gray object. Keep the original gray object in its original position. 
:: def iagjbddfiedaeeehaaibacddedgecjae(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  O = paint(canvas(ZERO, shape(I)), shift(obj5, (ZERO, width(obj2))))
  O = paint(O, shift(upscale(obj2, TWO), (uppermost(obj5), ZERO)))
  return O
 
40.0, tensor(0.0066), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two and place it to the left of the gray object, two spaces to the left of the gray object's leftmost column. Keep the original gray object in its original position. 
:: def dbfhbfbdbadbefhejcjjidbaeffiiidg(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  O = replace(I, mostcolor(I), ZERO)
  O = paint(O, shift(upscale(obj2, TWO), (uppermost(obj2), leftmost(obj5) - 2 * width(obj2))))
  O = paint(O, obj5)
  return O
 
47.5, tensor(0.0060), Description: Copy the input grid and make the background black. Then, move the gray object to the right edge of the grid. Then, enlarge the red object by a factor of two and place it above the gray object. Finally, crop the output grid to the original size of the input grid. 
:: def cbhjhffcecieebihbidbeghdhbahdhii(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  offset = (ZERO, width(obj2))
  O = paint(canvas(ZERO, (height(I), width(I) + width(obj2))), shift(obj5, offset))
  O = underpaint(O, shift(upscale(obj2, TWO), (uppermost(obj5), ZERO)))
  return crop(O, (ZERO, ZERO), shape(I))
 
40.0, tensor(0.0058), Description: Copy the input grid and make the background black. Then, move the gray object to the right edge of the grid. Then, for each row of the red object, create a horizontal line of red squares that extends to the left edge of the grid, twice the width of the original red object. Keep the original gray object in its original position. 
:: def dagdfgiffjbjeejeidhjjicedgbeecbb(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  O = paint(canvas(ZERO, shape(I)), shift(obj5, (ZERO, width(obj2))))
  for i in range(height(obj2)):
    O = paint(O, shift(recolor(TWO, {(ZERO, j) for j in range(2 * width(obj2))}), (uppermost(obj2) + i, ZERO)))
  return O
 
41.0, tensor(0.0265), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, transpose the red object (swap rows and columns) and move it one space to the left and up. Keep the original gray object in its original position. For each square in the transposed red object, if it is in an even column, keep it red. Otherwise, change it to gray. 
:: def cbdaecbcajehedfbbdbcbcdacadciadb(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shifted_obj5 = shift(obj5, (-1, -1))
  transposed_obj2 = frozenset((2, (j, i)) for v, (i, j) in obj2)
  shifted_obj2 = shift(transposed_obj2, (-1, -1))
  O = paint(canvas(0, shape(I)), shifted_obj5)
  for v, (i, j) in shifted_obj2:
    if even(j - leftmost(shifted_obj2)):
      O = paint(O, {(v, (i, j))})
    else:
      O = paint(O, {(5, (i, j))})
  return O
 
41.5, tensor(0.0265), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, transpose the red object (swap rows and columns) and move it one space to the left and up. Keep the original gray object in its original position. For each square in the transposed red object, if it is in an even column, keep it red. Otherwise, change it to gray. 
:: def dbcegdbbffhbeeieicdigcefafbfjccd(I):
  obj5 = toindices(first(colorfilter(objects(I, T, F, F), 5)))
  obj2 = toindices(first(colorfilter(objects(I, T, F, F), 2)))
  shifted_obj5 = shift(obj5, (-1, -1))
  transposed_obj2 = frozenset((j, i) for i, j in obj2)
  shifted_obj2 = shift(transposed_obj2, (-1, -1))
  O = canvas(0, shape(I))
  for i, j in asindices(I):
    if contained((i, j), shifted_obj5):
      O = fill(O, 5, {(i, j)})
    elif contained((i, j), shifted_obj2) and even(j - leftmost(shifted_obj2)):
      O = fill(O, 2, {(i, j)})
    elif contained((i, j), shifted_obj2):
      O = fill(O, 5, {(i, j)})
  return O
 
28.5, tensor(0.0144), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the center of the larger object. Change the color of the smaller object to the color of the larger object. Finally, fill the area around the larger object with the color of the larger object. 
:: def hdeifehacjafecahacidaaeegbhcebai(I):
    objs = objects(I, T, F, T)
    small = argmin(objs, size)
    large = argmax(objs, size)
    inner_box = shift(inbox(large), (1, 1))
    O = paint(
        fill(canvas(0, shape(I)), color(large), backdrop(large)),
        recolor(
            color(small),
            toobject(
                shift(toindices(small), subtract(center(inner_box), center(small))), 
                I
            )
        )
    )
    return O
 
27.0, tensor(0.0144), Description: Copy the input grid and make the background black. Then, find the smaller object and move it to the center of the larger object. Change the color of the smaller object to the color of the larger object. Finally, fill the area around the larger object with the color of the larger object. 
:: def gedigafebefdeeedbhicdehidfbecibj(I):
    objs = objects(I, T, F, T)
    small = argmin(objs, size)
    large = argmax(objs, size)
    inner_box = toindices(shift(inbox(large), (1, 1)))
    shifted_small = shift(small, subtract(center(inner_box), center(small)))
    O = fill(canvas(0, shape(I)), color(large), backdrop(large))
    for v, (i, j) in recolor(color(small), shifted_small):
        if (i, j) in inner_box:
            O = paint(O, {(v, (i, j))})
    return O
 
86.0, tensor(0.0206), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it one space to the right and one space down, then create a 3x3 red square with the top left corner of the red square aligned with the top left corner of the first object. Otherwise, move the first colored object one space to the right and one space down. Then, move the second colored object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. If the second colored object is gray, change its color to red. Otherwise, keep its original color. 
:: def hfaeeejbbaefehccbcjbjcaeaffebhea(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs)

    if size(obj1) < size(obj2):
        obj1, obj2 = obj2, obj1

    O = paint(canvas(bg, (10, 10)), shift(obj1, (-leftmost(obj1), 0)))
    O = paint(O, shift(recolor(2 if width(obj2) == 2 else color(obj2), obj2), (uppermost(obj1) + 1, width(obj1) + 1)))
    
    return O
 
97.5, tensor(0.0605), Description: Copy the input grid and make the background black. Find the smallest object and the largest object. Move the smallest object to the right edge of the grid. If the largest object is a 2x2 square, move it one space to the right and one space down of the smallest object. Otherwise, move the largest object seven spaces down and four spaces to the right of the smallest object. If the smallest object is gray, change the color of the largest object to red. Otherwise, keep the color of the largest object. 
:: def bceagfjjecjceciciaedgeagbchhejhc(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    obj1 = first(order(objs, size)) 
    obj2 = last(order(objs, size))

    O = paint(canvas(bg, (10, 10)), shift(obj1, (-leftmost(obj1), 0)))
    O = paint(O, shift(recolor(branch(equality(width(obj2), 2), 2, color(obj2)), obj2), add(ulcorner(obj1), (ONE, width(obj1) + ONE))))
    
    return O
 
57.5, tensor(0.0353), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. 
:: def abfcjbbaacfhedjaidabgibcjjihjcdi(I):
  O = canvas(ZERO, shape(I)) # Create a blank canvas
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) == 5:
      top_part = crop(I, ulcorner(obj), (height(obj) - 2, width(obj)))
      bottom_part = crop(I, (lowermost(obj) - 1, leftmost(obj)), (2, width(obj)))
      O = paint(O, shift(asobject(top_part), (-1, 0))) # Shift '5' object up by one unit
      O = paint(O, shift(recolor(2, asobject(bottom_part)), (0, width(obj) - 1))) # Transform to '2' and shift right
      O = paint(O, shift(recolor(2, asobject(bottom_part)), (4, width(obj) + 1)))  # Duplicate and shift down and right 
    elif color(obj) == 2:
      O = paint(O, shift(obj, (-1, -1))) # Shift '2' object up and left
    else:
      O = paint(O, obj)  # Keep other objects unchanged
  return O
 
48.5, tensor(0.0353), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. 
:: def bhcccdcfiefdeaebbafefdgeejebafhd(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    if color(obj) == 5:
      upper_indices = frozenset((i, j) for i, j in toindices(obj) if i < uppermost(obj) + height(obj) - 2)
      lower_indices = frozenset((i, j) for i, j in toindices(obj) if i >= uppermost(obj) + height(obj) - 2)
      O = paint(O, shift(recolor(5, upper_indices), (-1, 0))) # Shift upper part up
      O = paint(O, shift(recolor(2, lower_indices), (3, width(obj) - 1))) # Transform and shift lower part
    elif color(obj) == 2:
      O = paint(O, shift(obj, (-1, -1))) # Shift '2' object up and left
    else:
      O = paint(O, obj)
  return O
 
38.0, tensor(0.0075), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two and place it to the right of the gray object. Then, enlarge the red object by a factor of two again and place it below the gray object. Keep the original gray object in its original position. 
:: def hdaadicicaefeffcjdedabdcehecbafa(I):
  obj2 = extract(objects(I, T, F, F), lambda obj: color(obj) == TWO)
  obj5 = extract(objects(I, T, F, F), lambda obj: color(obj) == FIVE)
  new_obj2 = upscale(obj2, TWO)
  h1, w1 = shape(obj2)
  h2, w2 = shape(obj5)
  O = paint(canvas(ZERO, shape(I)), shift(new_obj2, (uppermost(obj5), rightmost(obj5) - w1 + 1)))
  O = paint(O, shift(new_obj2, (lowermost(obj5) - h1 + 1, leftmost(obj5))))
  O = paint(O, obj5)
  return O 
 
40.5, tensor(0.1060), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. For each square in the red object, if it is in an even column, change it to red. Otherwise, change it to gray. Keep the original gray object in its original position. 
:: def eefbdgehfejaedecijceaedeaffhcbde(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  twos = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  start_color = 2
  for i, j in shift(toindices(twos), (-1, -1)):
    O = fill(O, start_color, {(i, j)})
    start_color = 5 if start_color == 2 else 2
  return O
 
42.0, tensor(0.0810), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. For each square in the red object, if it is in an even column (counting from the leftmost column of the red object, and starting with the leftmost column as even), keep it red. Otherwise, change it to gray. Keep the original gray object in its original position. 
:: def hfgejfdfdajfeaeciaabbcidfagcajjb(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  twos = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  for i, j in shift(toindices(twos), (-1, -1)):
    O = fill(O, 2 if even(j - leftmost(twos) + (leftmost(twos) % 2)) else 5, {(i, j)})
  return O
 
40.0, tensor(0.1060), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. For each square in the red object, if it is in an even column, change it to red. Otherwise, change it to gray. Keep the original gray object in its original position. 
:: def gghddeaheeadebhdjcbbejajaedeeacf(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  twos = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  for i, row in enumerate(crop(O, ulcorner(shift(twos, (-1, -1))), shape(twos))):
    for j, v in enumerate(row):
      if v == 0:
        O = fill(O, 2 if even(j) else 5, {(i + uppermost(shift(twos, (-1, -1))), j + leftmost(shift(twos, (-1, -1))))})
  return O
 
42.0, tensor(0.0662), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. For each square in the red object, if it is in an even row, change it to red if it is in an even column and gray if it is in an odd column. If it is in an odd row, change it to gray if it is in an even column and red if it is in an odd column. Keep the original gray object in its original position. 
:: def jgefeefaffbcehjabadiffacbjaeejfh(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  twos = first(colorfilter(objects(I, T, F, F), 2))
  shifted_twos = shift(toindices(twos), (-1, -1))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  for i, j in shifted_twos:
    if (i - uppermost(shifted_twos)) % 2 == 0: 
      O = fill(O, 2 if even(j - leftmost(shifted_twos)) else 5, {(i, j)})
    else:
      O = fill(O, 5 if even(j - leftmost(shifted_twos)) else 2, {(i, j)})
  return O
 
36.0, tensor(0.0082), Description: Copy the input grid and make the background black. Then, move the larger object (the one with gray squares) one space up. Then, move the smaller object (the one with red squares) to the right of the larger object, one space to the right of the larger object's rightmost column. Change the color of the smaller object to the color of the larger object. Finally, keep the original colors of all other objects and the background. 
:: def didcfeicbcceeadfiebeebbcjfecbcde(I):
    objs = objects(I, T, F, T)
    obj1 = argmax(objs, size)  # Larger object (5s)
    obj2 = argmin(objs, size)  # Smaller object (2s)
    
    # Move obj1 up by one unit
    obj1_shifted = shift(obj1, (-1, 0))  
    
    # Position obj2 to the right of obj1
    obj2_pos = add(ulcorner(obj1_shifted), (1, width(obj1_shifted) + 1)) 
    obj2_shifted = shift(obj2, subtract(obj2_pos, ulcorner(obj2)))
    
    # Recolor obj2 to match obj1's color
    obj2_recolored = recolor(color(obj1), obj2_shifted)  
    
    return paint(paint(canvas(0, (10, 10)), obj1_shifted), obj2_recolored) 
 
91.0, tensor(0.0077), Description: Copy the input grid and make the background black. Then, move the object with the most gray squares one space up. Then, move the object with the fewest gray squares two spaces down and one space to the right of the first object. Change the color of the second object to the color of the first object. Finally, keep the original colors of all other objects and the background. 
:: def eeicddaebdafefdejfbfebdifejfhbfa(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: colorcount(obj, FIVE))
  obj2 = argmin(objs, lambda obj: colorcount(obj, FIVE))
  
  O = paint(canvas(bg, (10, 10)), shift(obj1, UP))
  O = paint(O, shift(recolor(color(obj1), obj2), add(ulcorner(obj1), (TWO, width(obj1) + ONE))))
  return O
 
33.0, tensor(0.0058), Description: Copy the input grid and make the background black. Then, move the larger object one space up. Then, move the smaller object one space to the right and one space down of the larger object. Change the color of the smaller object to the color of the larger object. Finally, keep the original colors of all other objects and the background. 
:: def bfbedefeajeaecchjbceadeecgeaiddh(I):
    objs = objects(I, True, False, True)
    big_obj = argmax(objs, size)
    small_obj = argmin(objs, size)
    target_pos = add(ulcorner(big_obj), (1, width(big_obj) + 1))
    return paint(paint(canvas(0, (10, 10)), shift(big_obj, (-1, 0))), shift(recolor(color(big_obj), small_obj), subtract(target_pos, ulcorner(small_obj)))) 
 
37.0, tensor(0.0130), Description: Copy the input grid and make the background black. Then, move the gray object one space up. Then, move the other object two spaces down and one space to the right of the gray object. Change the color of the other object to gray. Finally, keep the original colors of all other objects and the background. 
:: def abefeccdjcdjefdbicageeeibhgbcedf(I):
    objs = objects(I, T, F, T)
    obj1 = extract(objs, lambda o: color(o) == 5)
    obj2 = other(objs, obj1)
    return paint(paint(canvas(0, (10, 10)), shift(obj1, UP)), shift(recolor(5, obj2), add(ulcorner(obj1), (2, width(obj1) + 1))))
 
35.0, tensor(0.0075), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two and place it to the right of the gray object. Then, enlarge the red object by a factor of two again and place it below the gray object. Keep the original gray object in its original position. 
:: def gbhieedbaaehegfdidcaeecbhjjafhfd(I):
  obj2 = extract(objects(I, T, F, F), lambda obj: color(obj) == TWO)
  obj5 = extract(objects(I, T, F, F), lambda obj: color(obj) == FIVE)
  O = paint(canvas(ZERO, shape(I)), obj5)
  for i in range(height(obj2) * 2):
      for j in range(width(obj2) * 2):
          if i < height(obj2):
              new_i = uppermost(obj5) + i
              new_j = rightmost(obj5) - width(obj2) + 1 + j
          else:
              new_i = lowermost(obj5) - height(obj2) + i - height(obj2) + 1
              new_j = leftmost(obj5) + j
          if (i // 2, j // 2) in toindices(obj2):
              O = paint(O, {(TWO, (new_i, new_j))})
  return O
 
39.0, tensor(0.0074), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two. If the red object is above the gray object, place the enlarged red object to the right of the gray object and below the gray object. Otherwise, place the enlarged red object to the right of the gray object and above the gray object. Keep the original gray object in its original position. 
:: def ajeeffdefbchejaejejeebcafceaidad(I):
  obj2 = extract(objects(I, T, F, F), lambda obj: color(obj) == TWO)
  obj5 = extract(objects(I, T, F, F), lambda obj: color(obj) == FIVE)
  up_obj2 = upscale(obj2, TWO)
  O = canvas(ZERO, shape(I))
  h, w = shape(obj2)
  if uppermost(obj2) < uppermost(obj5):
    for i in range(h):
      for j in range(w):
        O = paint(O, {(TWO, (i + uppermost(obj5), j + rightmost(obj5) - w + 1))})
        O = paint(O, {(TWO, (i + lowermost(obj5) - h + 1, j + leftmost(obj5)))})
  else:
    for i in range(h):
      for j in range(w):
        O = paint(O, {(TWO, (i + lowermost(obj5), j + rightmost(obj5) - w + 1))})
        O = paint(O, {(TWO, (i + lowermost(obj5) + h, j + leftmost(obj5)))})
  O = paint(O, obj5)
  return O
 
45.5, tensor(0.0090), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, move the red object two spaces down and one space to the right of the gray object. Keep the original gray object in its original position. 
:: def faagdgcdgceheccebegfecbdddfdceaf(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  twos = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  O = underpaint(O, shift(twos, add(ulcorner(shift(fives, (-1, -1))), (2, 1))))
  return O
 
40.5, tensor(0.0102), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, copy the 2x2 red pattern from the input grid and paste it two spaces down and one space to the right of the gray object. Keep the original gray object in its original position. 
:: def ceahecdadbfeedibabcfgfedbbihhcai(I):
  fives = first(colorfilter(objects(I, T, F, F), 5))
  O = paint(canvas(0, shape(I)), shift(fives, (-1, -1)))
  for i, row in enumerate(crop(I, (2, 1), (2, 2))):
    for j, value in enumerate(row):
      if value == 2:
        O = fill(O, 2, {(i + uppermost(shift(fives, (-1, -1))) + 2, j + leftmost(shift(fives, (-1, -1))) + 1)})
  return O
 
41.5, tensor(0.0095), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. Finally, for each red square in the input grid, copy it one space to the left and up in the output grid. Keep the original gray object in its original position. 
:: def bgadbhdaecebefgbabachecjcfdbbfjb(I):
  O = replace(I, mostcolor(I), 0)
  fives = first(colorfilter(objects(O, T, F, F), 5))
  O = paint(canvas(0, shape(O)), shift(fives, (-1, -1)))
  for (v, (i, j)) in first(colorfilter(objects(I, T, F, F), 2)):
    O = fill(O, v, {(i - 1, j - 1)})
  return O 
 
40.5, tensor(0.0052), Description: Copy the input grid and make the background black. Then, move the largest colored object to the top left corner of the grid. Then, move the smallest colored object so that it is in the same relative position to the largest colored object as it was in the original input grid. 
:: def hechbbceaffceeeajiabcfchfgcaeffg(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: size(obj))
  obj2 = argmin(objs, lambda obj: size(obj))
  
  obj1_shifted = shift(obj1, subtract(ulcorner(obj1), (ZERO,ZERO)))
  relative_pos = subtract(ulcorner(obj2), ulcorner(obj1))
  obj2_shifted = shift(obj2, add(relative_pos, (height(obj1), ZERO)))
  
  return paint(paint(canvas(ZERO, (TEN, TEN)), obj1_shifted), obj2_shifted)
 
45.0, tensor(0.0076), Description: Copy the input grid and make the background black. Then, find the object with the most squares of the most common color. Move that object to the top left corner of the grid. Then, move the object with the fewest squares of the most common color to the bottom of the grid, aligning its leftmost column with the leftmost column of the first object. Keep the original colors of all other objects and the background. 
:: def daedbcfbbhgfeeidbegfcdehdadecbfe(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: colorcount(obj, mostcolor(I)))
  obj2 = argmin(objs, lambda obj: colorcount(obj, mostcolor(I)))
  
  topleft = ulcorner(asindices(I))
  obj1_shifted = shift(obj1, subtract(topleft, ulcorner(obj1)))
  obj2_shifted = shift(obj2, (uppermost(obj1) + height(obj1), leftmost(obj2)))
  
  return paint(paint(canvas(ZERO, shape(I)), obj1_shifted), obj2_shifted)
 
43.5, tensor(0.0064), Description: Copy the input grid and make the background black. Then, move the largest object to the top left corner of the grid. Then, move the smallest object to the bottom of the grid, aligning its leftmost column with the leftmost column of the first object. Keep the original colors of all other objects and the background. 
:: def hhecjadabgcceaacaebjcjfafbedjehb(I):
  objs = fgpartition(I)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  
  offset1 = (-uppermost(obj1), -leftmost(obj1))
  obj1_shifted = shift(obj1, offset1)
  offset2 = (height(obj1), -leftmost(obj2))
  obj2_shifted = shift(obj2, offset2)
  
  return paint(paint(canvas(ZERO, (TEN, TEN)), obj1_shifted), obj2_shifted)
 
52.0, tensor(0.0067), Description: Copy the input grid and make the background black. Then, find the object that is highest in the grid and move it to the top left corner. Then, move the object that is lowest in the grid so that it is in the same relative position to the first object as it was in the original input grid. Keep the original colors of all other objects and the background. 
:: def fijigcfgicjbecbfigaddceefddefacg(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: uppermost(obj))
  obj2 = argmin(objs, lambda obj: uppermost(obj))
  
  obj1_shifted = shift(obj1, (-uppermost(obj1), -leftmost(obj1)))
  obj2_shifted = shift(obj2, (-uppermost(obj2) + height(obj1), -leftmost(obj2) + leftmost(obj1)))
  
  return paint(paint(canvas(ZERO, (TEN, TEN)), obj1_shifted), obj2_shifted)
 
50.0, tensor(0.0071), Description: Copy the input grid and make the background black. Then, find the object with the most gray squares and move it to the top left corner of the grid. Then, find the object with the fewest red squares and move it to the bottom of the grid, aligning its leftmost column with the leftmost column of the first object. Keep the original colors of all other objects and the background. 
:: def fgdhaddcdfdfeaaejagcaeedeaibbcee(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda obj: colorcount(obj, FIVE))
  obj2 = argmin(objs, lambda obj: colorcount(obj, TWO))
  
  pos1 = (ZERO, ZERO)
  obj1_shifted = shift(obj1, subtract(pos1, ulcorner(obj1)))
  
  relative_pos = subtract(ulcorner(obj2), ulcorner(obj1))
  pos2 = (height(obj1), relative_pos[1])
  obj2_shifted = shift(obj2, pos2)
  
  return paint(paint(canvas(ZERO, (TEN, TEN)), obj1_shifted), obj2_shifted) 
 
42.0, tensor(0.0074), Description: Copy the input grid and make the background black. Then, enlarge the red object by a factor of two. If the red object is above the gray object, place the enlarged red object to the right of the gray object and below the gray object. Otherwise, place the enlarged red object to the right of the gray object and above the gray object. Keep the original gray object in its original position. 
:: def ecbbdchfddefeebaibiifebjdjbddfbj(I):
  obj2 = extract(objects(I, T, F, F), matcher(color, TWO))
  obj5 = extract(objects(I, T, F, F), matcher(color, FIVE))
  O = canvas(ZERO, shape(I))
  O = paint(O, obj5)
  for i in range(height(obj2)):
    for j in range(width(obj2)):
      if uppermost(obj2) < uppermost(obj5):
        O = paint(O, {(TWO, (uppermost(obj5) + 2 * i, rightmost(obj5) - width(obj2) + 1 + 2 * j))})
        O = paint(O, {(TWO, (uppermost(obj5) + 2 * i + 1, rightmost(obj5) - width(obj2) + 1 + 2 * j))})
        O = paint(O, {(TWO, (lowermost(obj5) - height(obj2) + 2 * i + 1, leftmost(obj5) + 2 * j))})
        O = paint(O, {(TWO, (lowermost(obj5) - height(obj2) + 2 * i + 2, leftmost(obj5) + 2 * j))})
      else:
        O = paint(O, {(TWO, (lowermost(obj5) + 2 * i, rightmost(obj5) - width(obj2) + 1 + 2 * j))})
        O = paint(O, {(TWO, (lowermost(obj5) + 2 * i + 1, rightmost(obj5) - width(obj2) + 1 + 2 * j))})
        O = paint(O, {(TWO, (lowermost(obj5) + height(obj2) + 2 * i, leftmost(obj5) + 2 * j))})
        O = paint(O, {(TWO, (lowermost(obj5) + height(obj2) + 2 * i + 1, leftmost(obj5) + 2 * j))})
  return O
 
50.5, tensor(0.0122), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. If the red object is taller than it is wide, flip it diagonally and enlarge it by a factor of two, then move it one space to the left and up. Otherwise, create a vertical line of red squares that is the same height as the red object and place it to the left of the gray object. Keep the original gray object in its original position. 
:: def efhcjgacfebceeefjgaahibdbcdeeghh(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shift_amount = (-1, -1)
  if portrait(obj2):
    transformed_obj2 = shift(dmirror(upscale(obj2, 2)), (-1, -1))
  else:
    transformed_obj2 = shift(
        frozenset((2, (i, leftmost(obj2))) for i in range(height(obj2))), 
        shift_amount
    )
  O = paint(
      paint(canvas(0, shape(I)), shift(obj5, shift_amount)), 
      transformed_obj2
  )
  return O
 
40.5, tensor(0.0124), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. If the red object is taller than it is wide, create a horizontal line of red squares that is the same width as the red object and place it to the left of the gray object. Otherwise, create a vertical line of red squares that is the same height as the red object and place it to the left of the gray object. Keep the original gray object in its original position. 
:: def gfhiagddhgaaedddjgdcebabdbcdbddi(I):
  obj5 = toindices(first(colorfilter(objects(I, T, F, F), 5)))
  obj2 = toindices(first(colorfilter(objects(I, T, F, F), 2)))
  shifted_obj5 = shift(obj5, (-1, -1))
  if portrait(obj2):
    transformed_obj2 = shift(
        frozenset((2, (i, j)) for i, j in obj2 for k in range(width(obj2))), 
        (-1, -1)
    ) 
  else:
    transformed_obj2 = shift(
        frozenset((2, (i, leftmost(obj2))) for i in range(height(obj2))), 
        (-1, -1)
    )
  O = canvas(0, shape(I))
  for i, j in asindices(I):
    if contained((i, j), shifted_obj5):
      O = fill(O, 5, {(i, j)})
    elif contained((i, j), transformed_obj2):
      O = fill(O, 2, {(i, j)})
  return O
 
35.0, tensor(0.0061), Description: Copy the input grid and make the background black. Then, move the largest object one space down. Then, move the smallest object one space to the right and two spaces down of the largest object. Keep the original colors of all other objects and the background. 
:: def ebheecchcfaaefedacaaafiaefifgbgi(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, lambda o: len(o))
  obj2 = argmin(objs, lambda o: len(o))
  return paint(paint(canvas(ZERO, (TEN, TEN)), shift(obj1, DOWN)), shift(obj2, (ONE, width(obj1) + TWO)))
 
70.0, tensor(0.0058), Description: Copy the input grid and make the background black. Then, find the object that is not the most common color and move it one space to the right and one space down. Then, move the other object so that it is in the same relative position to the first object as it was in the original input grid. Keep the original colors of all other objects and the background. 
:: def fajjhdchaicceefbigbbdgajgffjcebf(I):
  objs = sfilter(objects(I, T, F, F), lambda o: color(o) != mostcommon(I))
  obj1 = argmax(objs, size)
  obj2 = other(objs, obj1)
  return paint(paint(canvas(ZERO, shape(I)), shift(obj1, (ONE, ONE))), shift(obj2, add((ONE, width(obj1) + ONE), subtract(ulcorner(toindices(obj2)), ulcorner(toindices(obj1))))))
 
48.5, tensor(0.0322), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. For gray objects, split the object into two parts: the upper part and the lower part. Shift the upper part one space up. Transform the lower part by changing the color of the leftmost and rightmost columns to gray and the rest to red. Then, shift the transformed lower part three spaces down and one space to the right of the original gray object. 
:: def dadccbeecbbgecfeaihiahfechafccae(I):
  O = canvas(ZERO, shape(I)) 
  for obj in objects(I, T, F, T):
    if color(obj) == 5:
      split_index = height(obj) - 2
      upper_part = crop(I, ulcorner(obj), (split_index, width(obj)))
      lower_part = crop(I, (split_index + uppermost(obj), leftmost(obj)), (2, width(obj)))
      transformed_lower_part = recolor(5, {(i,j) for i,j in asindices(lower_part) if j == 0 or j == width(lower_part) - 1}) | recolor(2, {(i,j) for i,j in asindices(lower_part) if 0 < j < width(lower_part) - 1})
      O = paint(paint(O, shift(asobject(upper_part), (-1, 0))), shift(transformed_lower_part, (split_index - 1, width(obj) - 1))) 
    elif color(obj) == 2:
      O = paint(O, shift(obj, (-1, -1))) 
    else:
      O = paint(O, obj)
  return O
 
45.0, tensor(0.0322), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. For gray objects, split the object into two parts: the upper part and the lower part. Shift the upper part one space up. Transform the lower part by changing the color of the leftmost and rightmost columns to gray and the rest to red. Then, shift the transformed lower part three spaces down and one space to the right of the original gray object. 
:: def bcacdedccffdegdfachdgffeafcjhgbf(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    c = color(obj)
    if c == 5:
      h = height(obj)
      w = width(obj)
      O = paint(O, shift(asobject(crop(I, ulcorner(obj), (h - 2, w))), (-1, 0)))
      O = paint(O, shift(recolor(5, {(i, 0) for i in range(2)}) | recolor(2, {(i, j) for i in range(2) for j in range(1, w - 1)}) | recolor(5, {(i, w - 1) for i in range(2)}), (h - 3 + uppermost(obj), w - 1 + leftmost(obj))))
    elif c == 2:
      O = paint(O, shift(obj, (-1, -1)))
    else:
      O = paint(O, obj)
  return O
 
91.0, tensor(0.0322), Description: Copy the input grid and make the background black. Then, for each object in the grid, shift it based on its color and size. If the object is gray (5), shift it one space up. If the object is red (2) and wider than 3 squares, shift it one space to the right and duplicate it, shifting the duplicate four spaces down and two spaces to the right. If the object is red (2) and not wider than 3 squares, leave it in its original position. Keep the original colors of all other objects and the background. For gray objects, split the object into two parts: the upper part and the lower part. Shift the upper part one space up. Transform the lower part by changing the color of the leftmost and rightmost columns to gray and the rest to red. Then, shift the transformed lower part three spaces down and one space to the right of the original gray object. 
:: def ddddchicidchedhdibheaeeghefifgcc(I):
  O = I
  for obj in objects(I, T, F, T):
    if color(obj) == 5:
      u = ulcorner(obj)
      h = height(obj)
      w = width(obj)
      O = paint(cover(O, obj), shift(asobject(crop(I, u, (h - 2, w))), (-1, 0)))
      O = paint(O, shift(recolor(5, {(i, 0) for i in range(2)}) | recolor(2, {(i, j) for i in range(2) for j in range(1, w - 1)}) | recolor(5, {(i, w - 1) for i in range(2)}), (u[0] + h - 3, u[1] + w - 1)))
    elif color(obj) == 2:
      O = paint(cover(O, obj), shift(obj, (-1, -1)))
  return O
 
40.0, tensor(0.0118), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. If the red object is taller than it is wide, fill the area to the left of the gray object with red. Otherwise, create a vertical line of red squares that is the same height as the red object and place it to the left of the gray object. Keep the original gray object in its original position. 
:: def fbbhhicaibdheaccjfjdadffjdggddci(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  shift_amount = (-1, -1)
  transformed_obj2 = branch(
      portrait(obj2),
      recolor(2, backdrop(shift(obj5, shift_amount))),
      shift(
          frozenset((2, (i, leftmost(obj5) - 1)) for i in range(height(obj5))),
          shift_amount
      )
  )
  O = paint(paint(canvas(0, shape(I)), shift(obj5, shift_amount)), transformed_obj2)
  return O
 
39.5, tensor(0.0118), Description: Copy the input grid and make the background black. Then, move the gray object one space to the left and up. If the red object is taller than it is wide, fill the area to the left of the gray object with red. Otherwise, create a vertical line of red squares that is the same height as the red object and place it to the left of the gray object. Keep the original gray object in its original position. 
:: def aaddcbhhefbiegecafhgccfhaababhci(I):
  obj5 = first(colorfilter(objects(I, T, F, F), 5))
  obj2 = first(colorfilter(objects(I, T, F, F), 2))
  O = paint(
    paint(
        canvas(0, shape(I)), 
        shift(obj5, (-1, -1))
      ),
      branch(
        portrait(obj2),
        recolor(
          2,
          product(
            interval(uppermost(obj5) - 1, lowermost(obj5), 1),
            interval(leftmost(obj5) - 1, rightmost(obj5), 1)
          )
        ),
        shift(
          recolor(2, product(interval(uppermost(obj5) - 1, lowermost(obj5), 1), {leftmost(obj5) - 1})),
          (0, 0)
        )
      )
  )
  return O
 
89.5, tensor(0.0078), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it to the top left corner of the grid, then move the second colored object one space to the right and one space down of the first object. Otherwise, move the first colored object to the top left corner of the grid. Then, move the second colored object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. Keep the original colors of all other objects and the background. 
:: def dicaaaceabfeebbiijadefbiieajecdc(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  obj1 = first(objs)
  obj2 = last(objs)

  if size(obj1) < size(obj2):
    obj1, obj2 = obj2, obj1

  O = paint(canvas(bg, (10, 10)), shift(obj1, (-leftmost(obj1), -uppermost(obj1))))

  if width(obj2) == 2:
    O = paint(O, shift(obj2, (uppermost(obj1) + height(obj1) - 1,-leftmost(obj2)+1)))
    O = paint(O, shift(obj2, (uppermost(obj1) + height(obj1),-leftmost(obj2)+2)))
    O = paint(O, shift(obj2, (uppermost(obj1) + height(obj1) + 1,-leftmost(obj2)+1)))
  else:
    O = paint(O, shift(obj2, (height(O) - height(obj2), 1)))

  return O
 
42.0, tensor(0.0089), Description: Copy the input grid and make the background black. Find the largest object and the smallest object. Move the largest object to the top left corner of the grid. If the smallest object is a 2x2 square, move it one space to the right and one space down of the largest object, then create a 3x3 square with the top left corner of the red square aligned with the top left corner of the first object. Otherwise, move the smallest object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. Keep the original colors of all other objects and the background. 
:: def jgiadbdceefheaffabbgfaddhbddcjaf(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)

  O = paint(canvas(0, (10, 10)), shift(obj1, (-ulcorner(obj1)[0], -ulcorner(obj1)[1])))

  if width(obj2) == 2:
    for i in range(3):
      O = paint(O, shift(obj2, (uppermost(obj1) + height(obj1) - 1 + i, -leftmost(obj2) + 1 + (i % 2))))
  else:
    O = paint(O, shift(obj2, (height(O) - height(obj2), 1)))

  return O
 
43.5, tensor(0.0089), Description: Copy the input grid and make the background black. Find the largest object and the smallest object. Move the largest object to the top left corner of the grid. If the smallest object is a 2x2 square, move it one space to the right and one space down of the largest object, then create a 3x3 square with the top left corner of the red square aligned with the top left corner of the first object. Otherwise, move the smallest object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. Keep the original colors of all other objects and the background. 
:: def acchfacebaiaeeaeadgejchcbacbccdi(I):
    objs = objects(I, T, F, T)
    obj1 = next(iter(sizefilter(objs, max(map(size, objs)))))
    obj2 = next(iter(sizefilter(objs, min(map(size, objs)))))
    
    O = paint(canvas(0, (10, 10)), shift(obj1, (-ulcorner(obj1)[0], -ulcorner(obj1)[1])))

    if width(obj2) == 2:
      for i in range(3):
        O = paint(O, shift(obj2, (uppermost(obj1) + height(obj1) - 1 + i, -leftmost(obj2) + 1 + i - 2 * (i // 2))))
    else:
      O = paint(O, shift(obj2, (9 - height(obj2), 1)))

    return O
 
97.0, tensor(0.0078), Description: Copy the input grid and make the background black. If the first colored object is smaller than the second colored object, swap them. If the first colored object is a 2x2 square, move it to the top left corner of the grid, then move the second colored object one space to the right and one space down of the first object. Otherwise, move the first colored object to the top left corner of the grid. Then, move the second colored object to the bottom right corner of the grid, one space to the right of the rightmost column of the grid and one space above the bottom row of the grid. Keep the original colors of all other objects and the background. 
:: def fdbbdccbfehdebejihdgddbbabccfccb(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, T)
    obj1 = first(order(objs, size))
    obj2 = last(order(objs, size))
    
    O = paint(canvas(bg, (10, 10)), shift(obj1, (-leftmost(obj1), -uppermost(obj1))))

    if width(obj2) == 2:
      O = underpaint(O, shift(obj2, (uppermost(obj1) + height(obj1) - 1,-leftmost(obj2)+1)))
      O = underpaint(O, shift(obj2, (uppermost(obj1) + height(obj1),-leftmost(obj2)+2)))
      O = underpaint(O, shift(obj2, (uppermost(obj1) + height(obj1) + 1,-leftmost(obj2)+1)))
    else:
      O = paint(O, shift(obj2, (height(O) - height(obj2), 1)))

    return O
 
