12.666666666666666, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def bfcicabibcgfediajdadjfadfcefdcgc(I):
  one_loc = first(ofcolor(I, ONE)) # Find the location of digit "1"
  two_loc = first(ofcolor(I, TWO)) # Find the location of digit "2"
  
  # Determine relative position of "2" to "1"
  rel_pos = (sign(two_loc[0] - one_loc[0]), sign(two_loc[1] - one_loc[1]))
  
  # Define the shift direction for "2"
  shift_dir = (0, 1) if rel_pos[0] else (1, 0) if rel_pos[1] > 0 else (-1, 0)
  
  # Move "2" next to "1"
  O = move(I, toobject({two_loc}, I), shift_dir)
  
  # Move other digits above "1" while maintaining relative horizontal position
  for val in palette(I) - {0, 1, 2}:
    for loc in ofcolor(I, val):
      O = move(O, toobject({loc}, I), (-loc[0] + one_loc[0], 0))
  return O
 
13.0, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def icdaafecabbbebccjjiabfcfagdbbieg(I):
  one_loc = first(ofcolor(I, ONE))
  two = first(colorfilter(objects(I, T, T, T), TWO))
  
  # Calculate the offset to move "2" next to "1" 
  offset = (one_loc[0] - uppermost(two), one_loc[1] + 1 - leftmost(two)) if one_loc[0] != uppermost(two) \
           else (0, one_loc[1] - 1 - leftmost(two)) if one_loc[1] > leftmost(two) \
           else (0, one_loc[1] + 1 - leftmost(two))
  
  O = move(I, two, offset) # Move "2"
  
  for obj in objects(I, T, T, T) - {two}: # Move other objects
    new_loc = (one_loc[0] - uppermost(obj), leftmost(obj)) 
    O = move(O, obj, subtract(new_loc, ulcorner(obj)))
  return O 
 
17.333333333333332, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def echddigbffiaebcaiacechfbabacceee(I):
  one_idx = first(ofcolor(I, ONE))
  two_idx = first(ofcolor(I, TWO))

  # Calculate the new position for "2"
  new_two_idx = (one_idx[0], one_idx[1] + 1) if two_idx[0] != one_idx[0] \
               else (one_idx[0], one_idx[1] - 1) 
  
  O = I
  
  for i, row in enumerate(I): # Iterate through the grid
    for j, val in enumerate(row):
      if val == TWO:
        O = replace(O, TWO, ZERO) # Remove "2" from its original position
        O = fill(O, TWO, {new_two_idx}) # Place "2" in its new position
      elif val not in {ZERO, ONE}: 
        O = fill(O, val, {(one_idx[0], j)}) # Move other digits above "1"
  return O
 
11.666666666666666, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def ciefcicbgieceiecbabddfbeedbfagaa(I):
  one_loc = first(ofcolor(I, ONE))
  two_loc = first(ofcolor(I, TWO))
  
  # Shift direction for other digits
  v_shift = -1 if two_loc[0] < one_loc[0] else 1
  
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if (i, j) == two_loc: # Handle "2"
        new_j = one_loc[1] + 1 if two_loc[1] > one_loc[1] else one_loc[1] - 1
        O = fill(O, I[i][j], {(one_loc[0], new_j)})
        O = fill(O, ZERO, {(i, j)})
      elif I[i][j] not in {ZERO, ONE}: # Handle other digits
        O = fill(O, I[i][j], {(i + v_shift, j)})
        O = fill(O, ZERO, {(i, j)})
  return O
 
12.333333333333334, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def ddcdejebcfafeadeabacgfbbeaibiahf(I):
  one_loc = first(ofcolor(I, ONE))
  
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  
  for obj in objects(I, T, T, T):
    val = color(obj)
    if val == ONE:
      O = paint(O, obj) # Place "1" in its original position
    elif val == TWO:
      new_loc = (one_loc[0], one_loc[1] + 1) if uppermost(obj) != one_loc[0] \
               else (one_loc[0], one_loc[1] - 1)
      O = paint(O, shift(obj, subtract(new_loc, ulcorner(obj)))) # Move "2"
    else:
      new_loc = (one_loc[0], leftmost(obj))
      O = paint(O, shift(obj, subtract(new_loc, ulcorner(obj))))  # Move other objects
  return O
 
12.666666666666666, tensor(0.4003), Description: Center each of the colored shapes in the input grid. The output grid should have the same background color as the input grid. 
:: def jedbiejeedagejcebddaeigeeaifffed(I):
    # Identify and isolate key objects
    key_objects = objects(I, univalued=True, diagonal=False, without_bg=True) 
    
    # Initialize a blank canvas
    O = canvas(0, shape(I))
    
    for obj in key_objects:
        # Center each object
        offset = subtract(center(backdrop(obj)), center(obj))
        centered_obj = shift(obj, offset)
        
        # Place object onto the canvas (placement logic needs further specification)
        O = paint(O, centered_obj) 

    return O
 
7.333333333333333, tensor(0.0530), Description: For each color in the input grid, find the center of the shape formed by that color and place a single square of that color at that center point in the output grid. The output grid should have a black background. 
:: def gdbjeddbdehaebebbjahehabcfbcidbd(I):
    O = canvas(ZERO, shape(I))
    for value in palette(I) - {ZERO}:
        indices = ofcolor(I, value)
        if indices:
            center_i = (uppermost(indices) + lowermost(indices)) // 2
            center_j = (leftmost(indices) + rightmost(indices)) // 2
            O = fill(O, value, {(center_i, center_j)})
    return O
 
221.66666666666666, tensor(1.7827), Description:  The input grid contains a single colored shape.  The output grid should be filled with copies of this shape, tiled horizontally and vertically. The tiling should be such that the shape repeats in both directions with the same spacing as in the original shape. 
:: def gfjbdifcdifhedjhbddfhbcabgfbbfdd(I):
    obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
    hp = hperiod(obj)
    vp = vperiod(obj)
    O = canvas(ZERO, shape(I))
    for i in range(0, len(I), vp):
        for j in range(0, len(I[0]), hp):
            O = paint(O, shift(normalize(obj), (i, j)))
    return O
 
11.666666666666666, tensor(1.7514), Description: Move all the shapes with colors 1, 2, and 3 to the center of the grid horizontally, keeping their original vertical positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def ejeedcafijhiebfjabffdbcaefehhfee(I):
  objs = objects(I, T, F, F)
  target_objs = colorfilter(objs, 2) | colorfilter(objs, 3) | colorfilter(objs, 1)
  other_objs = difference(objs, target_objs)
  merged_target = merge(target_objs)
  center_j = centerofmass(merged_target)[1]
  center_offset = (0, len(I[0])//2 - center_j)
  shifted_target = shift(merged_target, center_offset)
  O = paint(paint(canvas(0, shape(I)), shifted_target), merge(other_objs))
  return O 
 
14.666666666666666, tensor(1.7514), Description: Move all the shapes with colors 1, 2, and 3 to the center of the grid horizontally, keeping their original vertical positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def bibbaacbfafdecjbidbaihjachdeabbb(I):
  target_indices = ofcolor(I, 1) | ofcolor(I, 2) | ofcolor(I, 3)
  min_j = leftmost(target_indices) 
  max_j = rightmost(target_indices)
  center_j = (min_j + max_j) // 2
  offset = (0, len(I[0])//2 - center_j)
  shifted_target = shift(target_indices, offset)
  O = fill(I, 0, target_indices)
  O = fill(O, 1, {(i, j) for i, j in shifted_target if 0 <= j < len(I[0])})
  O = fill(O, 2, {(i, j) for i, j in shifted_target if 0 <= j < len(I[0]) and I[i][j - offset[1]] == 2})
  O = fill(O, 3, {(i, j) for i, j in shifted_target if 0 <= j < len(I[0]) and I[i][j - offset[1]] == 3})
  return O
 
11.666666666666666, tensor(1.7514), Description: Move all the shapes with colors 1, 2, and 3 to the center of the grid horizontally, keeping their original vertical positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def acacheddfabbejefibfdbdaabfebiage(I):
  objs = objects(I, T, F, F)
  def is_target(obj): return any(v in {1, 2, 3} for v, _ in obj)
  target_obj = extract(objs, is_target)
  other_objs = difference(objs, {target_obj})
  center_j = (leftmost(target_obj) + rightmost(target_obj)) // 2
  offset = (0, len(I[0])//2 - center_j)
  shifted_target = shift(target_obj, offset)
  O = paint(paint(canvas(0, shape(I)), shifted_target), merge(other_objs))
  return O 
 
14.666666666666666, tensor(1.7514), Description: Move all the shapes with colors 1, 2, and 3 to the center of the grid horizontally, keeping their original vertical positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def cjfegbecfegeeifaacehefdebdfbagaa(I):
  target_cells = {(i, j) for i, row in enumerate(I) for j, v in enumerate(row) if v in {1, 2, 3}}
  min_j, max_j = min(j for _, j in target_cells), max(j for _, j in target_cells)
  center_j = (min_j + max_j) // 2
  offset = len(I[0]) // 2 - center_j 
  new_grid = list(list(row) for row in I)
  for i, j in target_cells:
    new_j = j + offset
    if 0 <= new_j < len(I[0]):
      new_grid[i][new_j] = I[i][j]
    new_grid[i][j] = 0 
  return tuple(tuple(row) for row in new_grid)
 
12.0, tensor(1.7514), Description: Move all the shapes with colors 1, 2, and 3 to the center of the grid horizontally, keeping their original vertical positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def gedabjchbhjiecccjaebeefbabghbebb(I):
  def process_row(row):
    target_values = [v for v in row if v in {1, 2, 3}]
    center_index = (len(row) - 1) // 2  
    new_row = [0] * len(row)
    start_index = center_index - (len(target_values) // 2)
    for i, v in enumerate(target_values):
      new_row[start_index + i] = v
    return tuple(new_row)
  return tuple(process_row(row) for row in I)
 
13.333333333333334, tensor(1.7771), Description: Move all the colored shapes to the leftmost column of the grid, maintaining their original vertical positions. The output grid should have a black background. 
:: def fihfefcgdejiebfcbfbfbcjgdgfdjbdf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True) 
  shifted_objs = frozenset()
  for obj in objs:
    leftmost_col = leftmost(obj)
    shift_offset = (0, -leftmost_col)  
    shifted_obj = shift(obj, shift_offset)
    shifted_objs = insert(shifted_obj, shifted_objs)
  O = paint(canvas(ZERO, shape(I)), merge(shifted_objs))
  return O
 
14.666666666666666, tensor(1.7775), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced two columns apart. The output grid should have a black background. 
:: def bfffhjhjfjchebebiffeejfacdbcahbc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  aligned_objs = frozenset()
  for i, obj in enumerate(sorted(objs, key=leftmost)):
    offset = (0, 2*i - leftmost(obj)) 
    aligned_objs = insert(shift(obj, offset), aligned_objs)
  O = paint(canvas(ZERO, shape(I)), merge(aligned_objs)) 
  return O
 
9.0, tensor(1.7780), Description: Move each column of colored squares to the left, maintaining their vertical positions. Each column should be shifted two columns to the left of the previous column. The output grid should have a black background. 
:: def hbhdddhaejffefecjbbjffbeccagfhid(I):
    O = canvas(ZERO, shape(I))
    for j in range(width(I)):
        column_obj = frozenset({(I[i][j], (i, j)) for i in range(height(I)) if I[i][j] != ZERO}) 
        if column_obj:
            O = paint(O, shift(column_obj, (0, -j * 2))) 
    return O
 
44.666666666666664, tensor(1.7775), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced two columns apart. The output grid should have a black background. 
:: def baebfgcffafeebhfijdaaechddjjjabf(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    O = canvas(ZERO, (height(I), 2 * len(objs) - 1)) 
    for i, obj in enumerate(sorted(objs, key=leftmost)):
        O = paint(O, shift(obj, (0, 2 * i - leftmost(obj)))) 
    return O
 
12.666666666666666, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def abjafbcdfhfgebadjjcageccbajjacab(I):
    objs = objects(I, F, F, T) # Extract non-background objects
    stacked = frozenset()
    offset = (0, 0)
    for i, obj in enumerate(objs):
        shifted = shift(obj, offset)
        stacked |= shifted
        offset = (offset[0] + height(obj), 0)  # Update offset for next object
    center_offset = ((15 - height(stacked)) // 2, (15 - width(stacked)) // 2) # Calculate center offset
    centered_objs = shift(stacked, center_offset) 
    O = paint(canvas(0, (15, 15)), centered_objs) # Paint objects onto empty canvas
    return O
 
12.666666666666666, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def fghafafafdfjebbibdeheabaegidfafb(I):
  objs = objects(I, F, F, T)
  height_acc = (0, 0)
  stacked = frozenset()
  for obj in objs:
    height_acc = (height_acc[0] + height(obj), 0)
    stacked = stacked | shift(obj, (height_acc[0] - height(obj), 0))
  center_offset = ((15 - height_acc[0]) // 2, (15 - width(stacked)) // 2)
  O = paint(canvas(0, shape(I)), shift(stacked, center_offset))
  return O 
 
14.0, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def bgaffcgcgabaejdijehedhadagfadidc(I):
  objs = objects(I, F, F, T)
  v_offset = (0, 0)
  new_objs = set()
  for i, obj in enumerate(objs):
    new_objs.add(shift(obj, v_offset))
    v_offset = (v_offset[0] + height(obj), 0)
  combined_obj = merge(new_objs)
  h_offset = ((15 - width(combined_obj)) // 2, 0)
  final_obj = shift(combined_obj, h_offset)
  O = paint(canvas(0, shape(I)), final_obj)
  return O
 
8.0, tensor(1.7839), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the left or right of "1" depending on its original position. The output grid should have a black background. 
:: def jddhfgcgebgheijhiicdjegefaefdidd(I):
  one_obj = first(colorfilter(objects(I, T, T, T), ONE)) 
  one_loc = ulcorner(one_obj) 
  
  O = I
  for obj in objects(I, T, T, T):
    target_j = one_loc[1] - 1 if one_loc[1] > leftmost(obj) else one_loc[1] + 1 
    new_loc = (one_loc[0], target_j) if hmatching(obj, one_obj) else (one_loc[0] - uppermost(obj), target_j)
    O = move(O, obj, subtract(new_loc, ulcorner(obj)))
  return O
 
7.0, tensor(1.7839), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the left or right of "1" depending on its original position. The output grid should have a black background. 
:: def fjdgehefdcbcedbbabcehdhfgiajdfaa(I):
  one_idx = first(ofcolor(I, ONE))
  
  O = I
  for obj in objects(I, T, T, T):
    offset = (0, one_idx[1] - 1 - leftmost(obj)) if one_idx[1] > leftmost(obj) \
             else (0, one_idx[1] + 1 - leftmost(obj))
    if not hmatching(obj, {one_idx}):
      offset = add(offset, (one_idx[0] - uppermost(obj), 0))
    O = move(O, obj, offset)
  return O
 
8.333333333333334, tensor(1.7836), Description: Move all the colored shapes to the same position as the digit "1", maintaining their relative positions. If a shape is already in the same position as "1", move it to the left or right of "1" depending on its original position. The output grid should have a black background. 
:: def iebfaifcbdifegdgjabeefcabfehbgac(I):
  one_obj = first(colorfilter(objects(I, T, T, T), ONE))
  
  def reposition(obj):
    if hmatching(one_obj, obj):
      return (0,  center(one_obj)[1] - center(obj)[1])
    else:
      return subtract(center(one_obj), center(obj))
  
  O = I 
  for obj in objects(I, T, T, T):
    O = move(O, obj, reposition(obj))
  return O 
 
8.0, tensor(1.7836), Description: Move all the colored shapes to the same position as the digit "1", maintaining their relative positions. If a shape is already in the same position as "1", move it to the left or right of "1" depending on its original position. The output grid should have a black background. 
:: def gdffggfacacieccdiacbjidefacefiaj(I):
  one_center = center(first(colorfilter(objects(I, T, T, T), ONE)))

  def new_position(obj):
    obj_center = center(obj)
    return (one_center[0] - obj_center[0], one_center[1] - obj_center[1] if hmatching(obj, {one_center}) else one_center[1] - 1 - obj_center[1])

  O = I
  for obj in objects(I, T, T, T):
    O = move(O, obj, new_position(obj))
  return O
 
9.333333333333334, tensor(1.7839), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the left or right of "1" depending on its original position. The output grid should have a black background. 
:: def bbejddhijebeebediadbfdgcbcafaaia(I):
    one_loc = ulcorner(first(colorfilter(objects(I, T, T, T), 1)))
    O = I
    for obj in objects(I, T, T, T):
        obj_loc = ulcorner(obj)
        new_loc = (one_loc[0], one_loc[1] - 1) if hmatching({one_loc}, obj) and one_loc[1] > obj_loc[1] \
            else (one_loc[0], one_loc[1] + 1) if hmatching({one_loc}, obj) and one_loc[1] <= obj_loc[1] \
            else (one_loc[0] - obj_loc[0], one_loc[1] - 1 - obj_loc[1])
        O = move(O, obj, new_loc)
    return O
 
9.333333333333334, tensor(1.7829), Description: Move all the colored shapes to the center of the grid horizontally, keeping their original vertical positions. The output grid should have a black background. 
:: def hbedjdcgcccdeebcaehdbaeaeccefjgf(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    center_j = (len(I[0]) - 1) // 2  # Central vertical line
    offset = subtract((ZERO, center_j), center(toindices(obj)))
    O = paint(O, shift(obj, offset))
  return O
 
9.333333333333334, tensor(1.7829), Description: Move all the colored shapes to the center of the grid horizontally, keeping their original vertical positions. The output grid should have a black background. 
:: def ehidgdgifagaeaaaafiiheabafjaegag(I):
  return paint(
      canvas(ZERO, shape(I)), 
      merge({shift(obj, subtract((ZERO, (len(I[0]) - 1) // 2), center(toindices(obj)))) 
             for obj in objects(I, univalued=True, diagonal=False, without_bg=True)})
  )
 
12.666666666666666, tensor(1.7829), Description: Move all the colored shapes to the center of the grid horizontally, keeping their original vertical positions. The output grid should have a black background. 
:: def jdfjafidcdcceejdbbheecffceajecei(I):
  O = canvas(ZERO, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != ZERO:
        offset = subtract((ZERO, (len(I[0]) - 1) // 2), (ZERO, j))
        O = paint(O, shift({(I[i][j], (i, j))}, offset))
  return O
 
13.666666666666666, tensor(1.7412), Description: Shift all the elements in the grid one position to the left, except for the elements in the middle column. The output grid should have a black background. 
:: def ddebeeefjfgfeeicifdbfcbgefaiafja(I):
  half_width = len(I[0]) // 2
  return tuple(
      tuple(
        ZERO if j == half_width else I[i][j - 1 if j > half_width else j] 
        for j in range(len(I[0]))
      ) 
      for i in range(len(I))
  )
 
10.333333333333334, tensor(1.7748), Description: Place the digit "1" in the top left corner of the output grid and the digit "2" directly below it. The output grid should have a black background. 
:: def dejfgaiacfaaefdgaicfcghgcidjeaae(I):
  obj1 = toobject(ofcolor(I, ONE), I) 
  obj2 = toobject(ofcolor(I, TWO), I)
  offset1 = subtract(ORIGIN, ulcorner(obj1))
  offset2 = subtract((height(obj1), ZERO), ulcorner(obj2))
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(obj1, offset1))
  O = paint(O, shift(obj2, offset2))
  return O
 
10.333333333333334, tensor(1.7780), Description: Place the digit "1" in the top left corner of the output grid and the digit "2" directly to the right of it. The output grid should have a black background. 
:: def fdgccjejjbegeiddbccbcifaegficeff(I):
  obj1 = normalize(toobject(ofcolor(I, ONE), I))
  obj2 = normalize(toobject(ofcolor(I, TWO), I))
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(obj1, (ZERO, width(obj2))))
  O = paint(O, shift(obj2, ORIGIN))
  return O
 
196.0, tensor(1.7748), Description: Place the digit "1" in the top left corner of the output grid and the digit "2" directly below it. The output grid should have a black background. 
:: def bdeiigfefadjebbhaihffgjafddecgcc(I):
  obj1 = normalize(toobject(ofcolor(I, ONE), I))
  obj2 = normalize(toobject(ofcolor(I, TWO), I))
  combined_obj = shift(obj2, (height(obj1), 0))
  O = paint(canvas(ZERO, (height(I), width(obj1) + width(obj2))), combined_obj)
  return O
 
10.333333333333334, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def chbhegjgfchaefbhbfdfiebiiciijdbd(I):
  objs = objects(I, F, F, T)
  stacked_grid = canvas(0, (15,15))
  v_offset = 0
  for obj in objs:
    obj_height = height(obj)
    stacked_grid = vconcat(stacked_grid[:v_offset], 
                             paint(stacked_grid[v_offset:], 
                                   shift(obj, ((15 - obj_height) // 2, (15 - width(obj)) // 2))))
    v_offset += obj_height
  return stacked_grid
 
11.666666666666666, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def hhbcebdbejfeedaabbigejdegiecdaid(I):
  objs = objects(I, F, F, T)
  canvas_center = (7, 7)  
  output_grid = canvas(0, (15, 15))
  current_height = 0
  for obj in objs:
    obj_height = height(obj)
    obj_width = width(obj)
    centered_obj = shift(obj, (canvas_center[0] - obj_height // 2 - current_height, 
                              canvas_center[1] - obj_width // 2))
    output_grid = paint(output_grid, centered_obj)
    current_height += obj_height
  return output_grid
 
12.666666666666666, tensor(1.7753), Description: For each colored shape in the input grid, move it towards the digit "1" in the direction it is gravitating towards "1". If the shape is already touching "1", do not move it. The output grid should have a black background. 
:: def dhfddfbdcffdejfbbfehffehicjaaafb(I):
  anchor = first(ofcolor(I, ONE))
  objs = objects(I, T, T, T)
  O = I 
  for obj in objs:
    if size(obj) > 1:
      direction = gravitate(obj, {anchor})
      O = paint(cover(O, obj), shift(obj, direction))
  return O
 
14.0, tensor(1.7833), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def ccefdcieaeideifijifdeefedbefbaah(I):
    O = canvas(0, shape(I))
    for value in palette(I) - {0}:
        obj = {(value, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == value}
        O = paint(O, shift(obj, (height(I) - lowermost(obj) - 1, 0)))
    return O
 
13.333333333333334, tensor(1.7833), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def ageefdecefdbefbiahehihcbagajgeab(I):
    O = canvas(0, shape(I))
    for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
        bottom_row = lowermost(obj)
        shift_amount = height(I) - bottom_row - 1
        shifted_obj = shift(obj, (shift_amount, 0))
        O = paint(O, shifted_obj)
    return O
 
13.333333333333334, tensor(1.7833), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def caidfchfeebfedjbjbbbdbcadidfiifi(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    return paint(canvas(0, shape(I)), merge({shift(obj, (height(I) - lowermost(obj) - 1, 0)) for obj in objs})) 
 
8.333333333333334, tensor(1.1288), Description: Replace each row with the most common color in that row. If a row is entirely black, keep it black. 
:: def dbdagefcbicfebjbbaecjaibjgfjicic(I):
    return tuple(tuple(0 for _ in range(len(I[0]))) for _ in range(len(I) - 1)) + (tuple(mostcommon(I[i]) if any(I[i]) else 0 for i in range(len(I))),)
 
11.333333333333334, tensor(1.7831), Description: Move all the colored squares to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def bjhbbejedjaeedafihchabhedbjceafg(I):
    O = list(list(row) for row in I)
    for j in range(len(I[0])):
        for i in range(len(I) - 1, -1, -1):
            if O[i][j] != 0:
                O[len(I) - 1][j] = O[i][j]
                O[i][j] = 0
                break
    return tuple(tuple(row) for row in O)
 
6.333333333333333, tensor(0.4720), Description: Place the largest shape containing the color "1" at the bottom of the grid, and the largest shape containing the color "2" in its original position. The output grid should have a black background. 
:: def dfhacaedcdeceehbjgfgbbfegdidceed(I):
  obj1 = argmax(objects(I, T, F, T), lambda o: (ONE in palette(o), -uppermost(o)))
  obj2 = argmax(objects(I, T, F, T), lambda o: (TWO in palette(o), -uppermost(o)))
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(obj1, (-(height(obj1) - 1), 0)))
  O = paint(O, obj2)
  return O
 
8.333333333333334, tensor(0.4720), Description: Place the largest shape containing the color "1" at the bottom of the grid, and the largest shape containing the color "2" in its original position. The output grid should have a black background. 
:: def bcjdjhbeecacecchigefcfihhbdhhcai(I):
  obj1 = extract(objects(I, T, F, T), lambda o: ONE in palette(o))
  obj2 = extract(objects(I, T, F, T), lambda o: TWO in palette(o))
  target1 =  extract(toindices(obj1), lambda loc: I[loc[0]][loc[1]] == ONE)
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(obj1, (-target1[0], 0)))
  O = paint(O, obj2)
  return O
 
11.0, tensor(1.7809), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape. The output grid should have a black background and be 15x15 in size. The stacked shapes should be centered within the grid. 
:: def fadejeafifcfehbbjjcfjhdacfjfdffe(I):
  objs = objects(I, F, F, T) # Extract objects, ignoring background
  O = canvas(0, (15, 15)) # Create a blank canvas
  for obj in objs:
    O = paint(O, shift(obj, (7 - height(obj) // 2, 7 - width(obj) // 2))) # Center and paint each object
  return O
 
225.0, tensor(1.7349), Description: Move each colored shape to the center of the grid, maintaining its original orientation. The output grid should have a black background and be compressed to remove any empty rows or columns. 
:: def ieffaeihefafedefbfadggbefedfdgbh(I):
    objs = objects(I, T, T, T)
    grid_center = centerofmass(asindices(I))
    
    def reposition(obj):
        return subtract(grid_center, centerofmass(obj))
    
    O = I
    for obj in objs:
        O = move(O, obj, reposition(obj))
    O = compress(O)
    return O
 
225.0, tensor(1.7396), Description: Move each colored shape to the center of the grid, maintaining its original orientation. The output grid should have a background color that is the most common color in the input grid and be compressed to remove any empty rows or columns. 
:: def dadcjjddbcabecdgaccicdjjdffdceaa(I):
    objs = objects(I, T, T, T)
    centered_objs = frozenset(shift(obj, subtract(centerofmass(asindices(I)), centerofmass(obj))) for obj in objs)
    O = canvas(mostcolor(I), shape(I))
    for obj in centered_objs:
        O = paint(O, obj)
    O = compress(O)
    return O
 
213.0, tensor(1.7706), Description: Move each colored shape to the center of the grid, maintaining its original orientation. The output grid should have a black background and be trimmed to remove any empty rows or columns. Then, remove any rows that are entirely black from the top and bottom of the grid. 
:: def dijafabhhbeheeccjacbcfeacdhdjeib(I):
  def reposition(obj):
    ci, cj = centerofmass(obj)
    gi, gj = centerofmass(asindices(I))
    return gi - ci, gj - cj
    
  O = I
  for obj in objects(I, T, T, T):
    O = move(O, obj, reposition(obj))
  O = trim(O)
  while len(set(O[0])) == 1: 
    O = O[1:]
  while len(set(O[-1])) == 1:
    O = O[:-1]
  return O
 
223.0, tensor(1.7831), Description: Move all the colored squares to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def acfgbjccehagedaeibcaacabfeafjeeg(grid):
  h = height(grid)
  for i in range(h - 1, 0, -1):
    for j in range(width(grid)):
      if index(grid, (i, j)) != mostcolor(grid):
        for k in range(i + 1, h):
          if index(grid, (k, j)) != mostcolor(grid):
            break
          grid = switch(grid, index(grid, (k - 1, j)), index(grid, (k, j)))
  return grid
 
16.0, tensor(1.7831), Description: Move all the colored squares to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def jcjjcgbdedfcedacjhdcffaebebdifef(grid):
  for j in range(width(grid)):
    column = tuple(grid[i][j] for i in range(height(grid)))
    new_column = tuple(0 for _ in range(height(grid)))
    idx = len(new_column) - 1
    for i in range(len(column) - 1, -1, -1):
      if column[i] != mostcolor(grid):
        new_column = tuple(new_column[:idx] + (column[i],) + new_column[idx+1:])
        idx -= 1
    grid = paint(grid, {(new_column[i], (i, j)) for i in range(height(grid))})
  return grid
 
15.333333333333334, tensor(1.7831), Description: Move all the colored squares to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def cfhecefbbibcefgdihbjehiijdgebjbj(grid):
  h, w = height(grid), width(grid)
  for i in range(h - 1, -1, -1):
    for j in range(w):
      if index(grid, (i, j)) != mostcolor(grid):
        k = i + 1
        while k < h and index(grid, (k, j)) == mostcolor(grid):
          k += 1
        grid = fill(grid, index(grid, (i, j)), {(k - 1, j)})
        grid = fill(grid, mostcolor(grid), {(i, j)})
  return grid
 
11.333333333333334, tensor(1.7745), Description: Move all the colored shapes to the same column as the digit "1", maintaining their original vertical positions. The output grid should have a black background. 
:: def fegcfhdaacbcejgbiehedffbjhcddeaf(I):
  one_col = first(ofcolor(I, ONE))[1]  # Find the column of '1'
  objs = objects(I, T, F, F)  # Extract all objects 
  shifted_objs = set()
  for obj in objs:
    upper = uppermost(obj)
    center = centerofmass(obj)[1] # Find center column of the object
    offset = (one_col - center, 0) # Center around '1' column 
    shifted_objs.add(shift(obj, offset)) 
  O = paint(canvas(ZERO, shape(I)), merge(shifted_objs))
  return O 
 
14.666666666666666, tensor(1.7823), Description: Move each colored shape towards the center of the grid, maintaining its original orientation. The movement should be proportional to the distance between the shape and the center. The output grid should have a black background. 
:: def abdjiabfaaafeehgihbefgcdheabbcbc(I):
  objs = objects(I, T, T, T)
  grid_center = centerofmass(asindices(I))
  
  def reposition(obj):
    direction = subtract(grid_center, centerofmass(obj))
    return divide(direction, double(manhattan(obj, {grid_center})))
  
  O = I
  for obj in objs:
    O = move(O, obj, reposition(obj))
  return O
 
12.333333333333334, tensor(1.7816), Description: Move each colored shape one step closer to the center of the grid, maintaining its original orientation. The output grid should have a black background. 
:: def cedddbgabajeebdjbadagfdfdaeabgfh(I):
  objs = objects(I, T, T, T)
  grid_center = centerofmass(asindices(I))
  
  def reposition(obj):
    return crement(subtract(grid_center, centerofmass(obj)))
  
  O = I
  for obj in objs:
    O = move(O, obj, reposition(obj))
  return O 
 
16.666666666666668, tensor(1.7816), Description: Move each colored shape one step closer to the center of the grid, maintaining its original orientation. The output grid should have a black background. 
:: def eddddbieebaaedababfgecddehdhcbcc(I):
    objs = objects(I, T, T, T)
    grid_center = center(asindices(I))

    def reposition(obj):
        diff = subtract(grid_center, centerofmass(obj))
        return (sign(diff[0]), sign(diff[1]))

    O = I
    for obj in objs:
        O = move(O, obj, reposition(obj))
    return O
 
14.0, tensor(1.7752), Description: Move the digit "2" to the right of the digit "1". If "2" is already to the right of "1", do nothing. Remove any other occurrences of "2" from the grid. The output grid should have a black background. 
:: def cfgidjacjcdfejdbbeahdfeeeighebad(I):
    anchor = first(ofcolor(I, ONE)) # Find the anchor '1'
    twos = ofcolor(I, TWO)  # Find all occurrences of '2'
    target = add(anchor, RIGHT) # Calculate target location for '2'
    relocate = intersection({target}, twos) # Check if '2' exists at target
    remove = difference(twos, relocate) # Find other '2's to remove
    O = paint(fill(I, ZERO, remove), {(TWO, target)}) # Fill and paint
    return O
 
7.333333333333333, tensor(0.4720), Description: Place the largest shape containing the color "1" at the bottom of the grid, and the largest shape containing the color "2" in its original position. The output grid should have a black background. 
:: def icdeceeehbcgedhciecbfdeeeedahdbe(I):
  obj1 = argmax(objects(I, T, F, T), lambda o: (ONE in palette(o), -uppermost(o)))
  obj2 = argmax(objects(I, T, F, T), lambda o: (TWO in palette(o), -uppermost(o)))
  O = paint(canvas(ZERO, shape(I)), shift(obj1, gravitate(obj1, obj2)))
  return paint(O, obj2)
 
8.333333333333334, tensor(0.4720), Description: Place the largest shape containing the color "1" at the bottom of the grid, and the largest shape containing the color "2" in its original position. The output grid should have a black background. 
:: def cabeaffgcceeegfdbhedccfcfcdaaceh(I):
  obj1 = argmax(objects(I, T, F, T), lambda o: (ONE in palette(o), -uppermost(o)))
  obj2 = argmax(objects(I, T, F, T), lambda o: (TWO in palette(o), -uppermost(o)))
  offset = (-(height(obj1) - 1), subtract(centerofmass(obj2), centerofmass(obj1))[1])
  O = paint(canvas(ZERO, shape(I)), shift(obj1, offset))
  return paint(O, obj2)
 
13.666666666666666, tensor(1.7660), Description: Move all shapes containing the digit "1" to the top of the grid, directly above the shape containing the digit "2", maintaining their original horizontal positions. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def befbajdeiabhebdgaaeifhhbbifaaabb(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, F, T):
        if ONE in palette(obj):
            two_obj = extract(objects(I, T, F, T), lambda o: TWO in palette(o))
            target = (uppermost(two_obj) - height(obj) + 1, leftmost(two_obj))
            O = paint(O, shift(obj, subtract(target, ulcorner(obj))))
        else:
            O = paint(O, obj)
    return O
 
12.333333333333334, tensor(1.7811), Description: Center each of the colored shapes vertically within the grid. The output grid should have the same background color as the input grid. 
:: def aceagdfcjafeefedaahcffhebbcdeide(I):
  objs = objects(I, F, F, T) # Extract all objects from the input grid
  canvas_height = height(I) # Determine the height of the input grid (and canvas)
  O = canvas(0, shape(I)) # Create a canvas with the same dimensions as the input, filled with the background color
  for obj in objs:
    O = paint(O, shift(obj, (canvas_height // 2 - height(obj) // 2, 0))) # Center each object vertically and paint it onto the canvas
  return O
 
13.0, tensor(1.7824), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background. 
:: def eadeddjecabeeddiijafjbjcacecaefa(I):
    objs = objects(I, T, T, T)
    grid_center_j = center(asindices(I))[1]
    
    O = I
    for obj in objs:
        obj_center_j = center(obj)[1]
        if obj_center_j < grid_center_j:
            O = move(O, obj, (0, grid_center_j - obj_center_j))
        elif obj_center_j > grid_center_j:
            O = move(O, obj, (0, grid_center_j - obj_center_j))
    return O
 
14.0, tensor(1.7824), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background. 
:: def ddfiifbficabefffjbddeageehacffgb(I):
    objs = objects(I, T, T, T)
    center_j = width(I) // 2
    
    O = I
    for obj in objs:
        obj_center = centerofmass(obj)
        direction = sign(subtract((0, center_j), obj_center))
        while abs(centerofmass(obj)[1] - center_j) > 0:
            O = move(O, obj, direction)
            obj = shift(obj, direction)  
    return O
 
12.666666666666666, tensor(1.7824), Description: Move all the colored shapes to the center of the grid horizontally, maintaining their original vertical positions. The output grid should have a black background. 
:: def efibejdfddajebecjejbiifhbfdfgfdf(I):
  objs = objects(I, T, T, T)
  grid_center_j = center(asindices(I))[1]

  def move_to_center(obj):
    obj_center_j = center(obj)[1]
    return shift(obj, (0, grid_center_j - obj_center_j))
  
  return paint(canvas(0, shape(I)), merge(apply(move_to_center, objs))) 
 
8.333333333333334, tensor(1.7833), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def iecddhaeeddiebfbagacgdbgjbbfjiec(I):
  anchor = first(ofcolor(I, ONE))
  digits = difference(asindices(I), ofcolor(I, ZERO))
  shifted_digits = frozenset((i + anchor[0] - len(I) + 1, j) for i, j in digits)
  cleared_grid = fill(I, ZERO, digits)
  painted_grid = paint(cleared_grid, {(I[i][j], (i, j)) for i, j in shifted_digits if 0 <= i < len(I) and 0 <= j < len(I[0])}) 
  return painted_grid
 
14.0, tensor(1.7846), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. 
:: def ffjfcfigcjcdeeaejcgbdacbhfachdfb(I):
  anchor_j = first(ofcolor(I, ONE))[1] 
  O = tuple(tuple(ZERO for _ in range(len(I[0]))) for _ in range(len(I)))
  for i, row in enumerate(I):
      for j, val in enumerate(row):
          if val != ZERO:
              new_j = anchor_j + j - i
              if 0 <= new_j < len(I[0]):
                  O = paint(O, {(val, (len(O) - 1, new_j))}) 
  return O
 
15.333333333333334, tensor(1.7530), Description: Move all the shapes with colors 1, 2, and 3 to the bottom row of the grid, maintaining their original horizontal positions. Leave the shapes with other colors in their original positions. The output grid should have a black background. 
:: def fgecjaebfhadebehbaigjfgdbedffidg(I):
  h, w = len(I), len(I[0])
  new_grid = [[0 for _ in range(w)] for _ in range(h)]
  for j in range(w):
    temp = []
    for i in range(h):
      if I[i][j] in {1, 2, 3}:
        temp.append(I[i][j])
      elif I[i][j] != 0:
        new_grid[i][j] = I[i][j]
    for i, v in enumerate(temp):
      new_grid[h - len(temp) + i][j] = v 
  return tuple(tuple(row) for row in new_grid)
 
12.666666666666666, tensor(1.5134), Description: Move the largest shape containing the color "3" one unit up. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def fgabcdcjficaefifaccebgdhbdfceaje(I):
  objs = objects(I, T, F, T)
  obj_to_move = argmax(objs, lambda o: color(o) == THREE)
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(obj_to_move, (NEG_ONE, ZERO))) # Shifting one unit up
  for obj in objs - {obj_to_move}:
    O = paint(O, obj)
  return O
 
10.666666666666666, tensor(1.6829), Description: Move the largest shape containing the color "3" towards the largest shape containing the color "2" in the direction it is gravitating towards "2". The output grid should have a black background. 
:: def gedgfjfdaigaeaabjfhicedjdbejedfd(I):
  obj1 = argmax(objects(I, T, F, T), lambda o: color(o) == THREE)
  obj2 = argmax(objects(I, T, F, T), lambda o: color(o) == TWO)
  direction = gravitate(obj1, obj2) 
  O = move(I, obj1, direction)  
  return O
 
10.666666666666666, tensor(1.7829), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered both horizontally and vertically. The output grid should have a black background and be the same size as the input grid. 
:: def ajdibcfcchdgefbbjgdaebehdajbcdhg(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj)) 
  offset = height(I) // 2 - height(first(objs)) // 2
  shifted_objs = [shift(obj, (offset + i * height(obj), width(I) // 2 - width(obj) // 2)) for i, obj in enumerate(objs)]
  return paint(canvas(0, shape(I)), merge(shifted_objs))
 
208.33333333333334, tensor(1.7448), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background and be compressed to remove any empty rows or columns. 
:: def dagaaiccfiabejhbjfebbecdebahdefe(I):
  objs = objects(I, T, T, T)
  grid_center_j = center(asindices(I))[1]

  def reposition(obj):
    return (0, grid_center_j - centerofmass(obj)[1])

  centered_objs = apply(lambda obj: shift(obj, reposition(obj)), objs)
  painted_grid = paint(I, merge(centered_objs))
  return compress(painted_grid)
 
225.0, tensor(1.7448), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background and be compressed to remove any empty rows or columns. 
:: def ihcdecjjdhgeeaebbdijebbdcbeafhah(I):
    return compress(paint(canvas(0, shape(I)), 
                          merge(apply(lambda obj:
                                       shift(obj, (0, center(asindices(I))[1] - centerofmass(obj)[1])), 
                                       objects(I, T, T, T))))) 
 
12.333333333333334, tensor(1.7846), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. 
:: def diehdafcaabcehbeiaedhfeaefcgabga(I):
  one_loc = first(ofcolor(I, ONE))[1]
  O = canvas(ZERO, shape(I))
  for j in range(len(I[0])):
    for i in range(len(I)):
      if I[i][j] != ZERO:
        O = paint(O, {(I[i][j], (len(I)-1, j + 8 - one_loc))})
  return O
 
12.333333333333334, tensor(1.7846), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. 
:: def cfccbhefgeadedbcihdbfejjhicffhae(I):
  one_loc = first(ofcolor(I, ONE))[1] 
  shifted_grid = shift(asobject(I), (0, 8 - one_loc))
  O = canvas(ZERO, shape(I))
  for v, (i, j) in shifted_grid:
    if v != ZERO:
      O = paint(O, {(v, (len(I) - 1, j))})
  return O
 
12.333333333333334, tensor(1.7846), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. 
:: def igafbgecdfffeibeijijdiadgidjdgjb(I):
  one_loc = first(ofcolor(I, ONE))[1]
  O = canvas(ZERO, shape(I))
  for j in range(len(I[0])):
    column = tuple(I[i][j] for i in range(len(I)))
    digit = next((x for x in column if x != ZERO), None)
    if digit is not None:
      O = paint(O, {(digit, (len(O)-1, 8 + j - one_loc))})
  return O
 
12.333333333333334, tensor(1.7846), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. 
:: def aijbfffchacdebecahefebfaacbdeade(I):
  one_loc = first(ofcolor(I, ONE))
  non_zeros = ((I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != ZERO)
  shifted_non_zeros = ((v, (len(I) - 1, j + 8 - one_loc[1])) for v, (i, j) in non_zeros)
  return paint(canvas(ZERO, shape(I)), frozenset(shifted_non_zeros))
 
11.0, tensor(1.7656), Description: Move all shapes with the color 7 to the top of the grid, connecting them vertically if they are in the same column. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def dcdjghchbabaeagbbhjfigfaddfceace(I):
  objs = objects(I, T, F, T)
  sevens = colorfilter(objs, SEVEN)
  target = argmax(sevens, lambda s: uppermost(s))
  others = sevens - {target}
  for other in others:
    if vmatching(target, other):
      direction = (1 if uppermost(target) < uppermost(other) else -1, 0)
      connection = connect(centerofmass(target), centerofmass(other))
      target = toobject(connection, I) | target
      I = cover(I, other)
  O = paint(canvas(ZERO, shape(I)), target)
  for obj in objs - sevens:
    O = paint(O, obj)
  return O
 
14.0, tensor(1.7332), Description: If there are two or more shapes with the color 7, connect them vertically if they are in the same column. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def chhiedabfbfbefcjjahddbbdggchffaa(I):
  objs = objects(I, T, F, T)
  sevens = colorfilter(objs, SEVEN)
  if len(sevens) > 1:
    top_seven = argmax(sevens, lambda s: uppermost(s))
    bottom_seven = argmin(sevens, lambda s: uppermost(s))
    if vmatching(top_seven, bottom_seven):
      connected = connect(centerofmass(top_seven), centerofmass(bottom_seven))
      I = fill(I, SEVEN, connected)
      I = cover(I, bottom_seven) 
  O = paint(canvas(ZERO, shape(I)), asobject(I))
  return O
 
21.0, tensor(1.7332), Description: If there are two or more shapes with the color 7, connect them vertically if they are in the same column. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def afifddeeddijeffdjejgacddggefjaha(I):
  objs = objects(I, T, F, T)
  sevens = colorfilter(objs, SEVEN)
  if len(sevens) > 1:
      y_coords = sorted(set(j for obj in sevens for i, j in toindices(obj)))
      if len(y_coords) > 1: 
          for i in range(len(y_coords) - 1):
              if y_coords[i+1] - y_coords[i] > 1:
                  I = fill(I, SEVEN, connect((0, y_coords[i]), (0, y_coords[i+1])))
      I = cover(I, argmin(sevens, lambda s: uppermost(s))) 
  O = paint(canvas(ZERO, shape(I)), asobject(I))
  return O
 
15.666666666666666, tensor(1.1437), Description: If any column contains both the target color (7) and another color, fill the entire column with the target color. Otherwise, leave the grid as is. The output grid should have a black background. 
:: def iaeedeaehbjeeacbbeaabddbfceejccc(I):
    objs = objects(I, True, False, True)
    target_color = SEVEN
    target_obj = argmax(objs, lambda o: color(o) == target_color)
    other_objs = objs - {target_obj}
    h, w = shape(I)
    for x in range(w):
        column = {(i, x) for i in range(h)}
        if any((i, x) in toindices(target_obj) for i in range(h)):
            for obj in other_objs:
                if any((i, x) in toindices(obj) for i in range(h)):
                    if color(obj) == target_color:
                        I = fill(I, target_color, column)
                        return paint(canvas(ZERO, shape(I)), asobject(I)) 
    return paint(canvas(ZERO, shape(I)), asobject(I))
 
11.0, tensor(1.7828), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def gcichhaaaiebefajifjcccjbceddghee(I):
  objs = objects(I, F, F, T)
  output = canvas(0, shape(I))
  for obj in objs:
    offset = (height(I) - lowermost(obj) - 1, width(I) // 2 - width(obj) // 2)
    output = paint(output, shift(obj, offset))
  return output
 
12.333333333333334, tensor(1.7839), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. 
:: def iddcecibjaaaeabfbgbgjcehheceigih(I):
  one_idx = first(ofcolor(I, ONE))
  two_idx = first(ofcolor(I, TWO))

  # Use a conditional statement to determine the new position of '2'
  new_two_idx = (one_idx[0], one_idx[1] + 1) if two_idx[1] >= one_idx[1] else (one_idx[0], one_idx[1] - 1)
  
  O = replace(I, TWO, ZERO) # Remove '2' from its original position

  O = fill(O, TWO, {new_two_idx}) # Place '2' in its new position
  
  for i, row in enumerate(O):
    for j, val in enumerate(row):
      if val not in {ZERO, ONE, TWO}:
        O = move(O, {(val, (i, j))}, (one_idx[0] - i, 0)) # Move other digits above "1"
  return O
 
12.666666666666666, tensor(1.7843), Description: Move the digit "2" to the right of the digit "1" if "2" is originally to the left of "1", or to the left of "1" if "2" is originally to the right of "1". Move all other digits to the same horizontal row as "1", maintaining their relative vertical positions. The output grid should have a black background. 
:: def dcfeaeabcbfheaebjcfhaegefaddffei(I):
  objs = objects(I, T, T, T)
  one_obj = first(sfilter(objs, lambda obj: color(obj) == ONE))
  two_obj = first(sfilter(objs, lambda obj: color(obj) == TWO))
  
  one_center = center(one_obj)[1]
  two_center = center(two_obj)[1]
  
  O = canvas(ZERO, shape(I)) # Create a blank canvas
  
  for obj in objs:
    val = color(obj)
    if val == ONE:
      O = paint(O, obj) # Paint '1' in its original position
    elif val == TWO:
      if two_center <= one_center:
        O = paint(O, shift(obj, (one_center - two_center, 1))) # '2' to the right of '1'
      else:
        O = paint(O, shift(obj, (one_center - two_center, -1))) # '2' to the left of '1'
    elif val != ZERO:
      O = paint(O, shift(obj, (center(one_obj)[0] - center(obj)[0], 0))) # Move other digits above '1'
  
  return O
 
12.666666666666666, tensor(1.7803), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits above "1" while maintaining their relative horizontal position. The output grid should have a black background. 
:: def hecbedaebhdaebddiccfdgfegcbejjad(I):
  one_idx = first(ofcolor(I, ONE))
  two_idx = first(ofcolor(I, TWO))

  # Define a lambda function to calculate the new 'j' coordinate for an index
  new_j = lambda idx: one_idx[1] + 1 if idx[1] > one_idx[1] else one_idx[1] - 1 

  O = canvas(ZERO, shape(I))

  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        O = fill(O, val, {(i, j)}) # Keep '1' at its original position
      elif val == TWO:
        if one_idx[0] != two_idx[0]: # '2' is in a different row
          O = fill(O, val, {(one_idx[0], one_idx[1] + 1)}) # '2' to the right of '1'
        else:
          O = fill(O, val, {(one_idx[0], new_j(two_idx))}) # '2' to the left or right of '1' based on its original position
      elif val != ZERO:
        O = fill(O, val, {(one_idx[0], j)}) # Move other digits to the row of '1'

  return O
 
9.333333333333334, tensor(1.7839), Description: Move the largest colored shape in the input grid to the center of the output grid. The output grid should have a background color that is the most common color in the input grid. 
:: def baddjefghadfefjgbfcbeafbeicdcicf(I):
  obj = first(objects(I, univalued=False, diagonal=False, without_bg=True))
  O = paint(canvas(mostcolor(I), shape(I)), shift(obj, (14 - uppermost(obj), 7 - leftmost(obj)))) 
  return O
 
12.666666666666666, tensor(1.7536), Description: Move all shapes with the color 7 to the center of the grid, maintaining their original orientation. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def dedeebechjejeaijjheehfcfahefbjea(I):
  sevens = frozenset(obj for obj in objects(I, T, F, T) if color(obj) == SEVEN)
  if sevens:
    merged_seven = toobject(merge(apply(toindices, sevens)), I)
    centered_seven = shift(merged_seven, subtract(center(asindices(I)), center(merged_seven)))
    O = paint(canvas(ZERO, shape(I)), centered_seven)
  else:
    O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T) - sevens:
    O = paint(O, obj)
  return O
 
9.333333333333334, tensor(1.7536), Description: Move all shapes with the color 7 to the center of the grid, maintaining their original orientation. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def bajedfdbbfifebheaideidadgdgfhfec(I):
  sevens_indices = ofcolor(I, SEVEN)
  if sevens_indices:
    connected_sevens = toobject(sevens_indices, I)
    target_center = center(asindices(I))
    offset = subtract(target_center, centerofmass(connected_sevens))
    moved_sevens = shift(connected_sevens, offset)
    O = paint(canvas(ZERO, shape(I)), moved_sevens)
  else:
    O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != SEVEN:
        O = paint(O, {(val, (i, j))})
  return O
 
12.0, tensor(1.7827), Description: Move the digit "2" next to the digit "1" in the direction it was originally located relative to "1". Then, move all other digits to the same horizontal row as "1", maintaining their relative vertical positions. The output grid should have a black background. 
:: def eiebfjeajdeaejaeicedieddabdfbbia(I):
  one_loc = center(first(colorfilter(objects(I, T, T, T), ONE)))
  two_loc = center(first(colorfilter(objects(I, T, T, T), TWO)))
  two_offset = (0, 1) if two_loc[1] > one_loc[1] else (0, -1)
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    value = color(obj)
    if value == ONE:
      O = paint(O, shift(obj, subtract((uppermost(obj), leftmost(obj)), one_loc)))
    elif value == TWO:
      O = paint(O, shift(obj, subtract((uppermost(obj), leftmost(obj)), add(one_loc, two_offset))))
    else:
      O = paint(O, shift(obj, (one_loc[0] - uppermost(obj), 0)))
  return O
 
14.0, tensor(1.7843), Description: Move the digit "2" to the right of the digit "1" if "2" is originally to the left of "1", or to the left of "1" if "2" is originally to the right of "1". Move all other digits to the same horizontal row as "1", maintaining their relative vertical positions. The output grid should have a black background. 
:: def dbbcjcdfgeghefaijdifdffjcibcbeaf(I):
  one_obj = first(colorfilter(objects(I, T, T, T), ONE))
  two_obj = first(colorfilter(objects(I, T, T, T), TWO))
  target_one = (0, (shape(I)[1] - width(one_obj)) // 2)
  two_offset = (0, width(one_obj)) if position(one_obj, two_obj)[1] == 1 else (0, -width(two_obj))
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    if color(obj) == ONE:
      O = paint(O, shift(obj, subtract(ulcorner(obj), target_one)))
    elif color(obj) == TWO:
      O = paint(O, shift(obj, subtract(ulcorner(obj), add(target_one, two_offset))))
    else:
      O = paint(O, shift(obj, (target_one[0] - uppermost(obj), 0)))
  return O
 
11.666666666666666, tensor(1.7844), Description: Move the digit "1" to the center of the grid horizontally, maintaining its original vertical position. Move the digit "2" to the right of "1" if "2" is originally to the left of "1", or to the left of "1" if "2" is originally to the right of "1". Move all other digits to the same horizontal row as "1", maintaining their relative vertical positions. The output grid should have a black background. 
:: def hcbgbhcajifeeegabadegehaedjeagjd(I):
  one_obj = first(colorfilter(objects(I, T, T, T), ONE))
  two_obj = first(colorfilter(objects(I, T, T, T), TWO))
  one_loc = (0, (shape(I)[1] - width(one_obj)) // 2)
  two_loc = add(one_loc, (0, width(one_obj)) if position(one_obj, two_obj)[1] == 1 else (0, -width(two_obj)))
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    target = one_loc if color(obj) == ONE else two_loc if color(obj) == TWO else (one_loc[0], leftmost(obj))
    O = paint(O, shift(obj, subtract(ulcorner(obj), target)))
  return O
 
9.333333333333334, tensor(1.7823), Description: Move each colored shape to the center of the grid, maintaining its original orientation. The output grid should have a black background. 
:: def ibgcjjeafdcfejeiajaebfjcfbaabegc(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    O = cover(O, obj)
    offset = subtract(center(asindices(I)), center(obj))
    O = paint(O, shift(obj, offset))
  return O
 
13.666666666666666, tensor(1.7823), Description: Move each colored shape to the center of the grid, maintaining its original orientation. The output grid should have a black background. 
:: def dhefefchfgcfefgcafdfheedjfdebhef(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return tuple(
      tuple(
          next((v for v, (k, l) in merge(
              [shift(obj, subtract(center(asindices(I)), center(obj))) for obj in objs]) 
                if (k, l) == (i, j)), I[i][j]) 
          for j in range(len(I[0])))
      for i in range(len(I)))
 
14.666666666666666, tensor(1.7506), Description: If a colored square (1, 2, or 3) is above a black square, move the colored square down one space. Repeat this process until all colored squares are in the bottom row. The output grid should have a black background. 
:: def ecddcebcghbdeaadbgbfdfegddfbhgcd(I):
  def fall_objects(grid):
    h, w = shape(grid)
    for j in range(w):
      for i in range(h-1, 0, -1):
        if grid[i][j] == 0 and grid[i-1][j] in {1, 2, 3}:
          grid = paint(cover(grid, {(grid[i-1][j], (i-1, j))}), {(grid[i-1][j], (i, j))})
    return grid

  return fall_objects(I)
 
12.0, tensor(1.7695), Description: Move all shapes containing the digit "1" to the bottom of the grid, directly above the shape containing the digit "2", maintaining their original horizontal positions. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def dafcbgdegaceebbfbfecgabbaaedcdbi(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  for obj in sorted(objs, key=lambda o: (-(ONE in palette(o)), -(TWO in palette(o)), uppermost(o))):
    target = argmax(objs, lambda target: (-(ONE in palette(target)), -(TWO in palette(target)), lowermost(target) < uppermost(obj), lowermost(target)))
    if target:
      O = paint(O, shift(obj, (lowermost(target) + 1 - uppermost(obj), 0)))
    else:
      O = paint(O, shift(obj, (height(I) - height(obj), 0)))
  return O
 
11.0, tensor(1.7695), Description: Move all shapes containing the digit "1" to the bottom of the grid, directly above the shape containing the digit "2", maintaining their original horizontal positions. Leave all other shapes in their original positions. The output grid should have a black background. 
:: def dcfjggbfdbibehdbajgjejideibcaacj(I):
  objs = sorted(objects(I, T, F, T), key=lambda o: (-colorcount(o, ONE), -colorcount(o, TWO), uppermost(o)))
  O = canvas(ZERO, shape(I))
  painted = set()
  for obj in objs:
    if obj in painted: 
      continue
    below = argmax(objs, lambda other: (other != obj, vmatching(obj, other), lowermost(other) < uppermost(obj), lowermost(other)))
    if below:
      offset = lowermost(below) + 1 - uppermost(obj)
      O = paint(O, shift(obj, (offset, 0)))
      painted.add(obj)
      painted.add(below)
    else:
      O = paint(O, shift(obj, (height(I) - height(obj), 0)))
      painted.add(obj)
  return O
 
14.666666666666666, tensor(1.7733), Description: For each shape containing either the digit "1" or "2", move it towards the closest shape containing either "1" or "2" (excluding itself) in the direction it is gravitating towards that shape. If a shape is already touching another shape containing "1" or "2", do not move it. The output grid should have a black background. 
:: def jbcbfahbbfajefcbabjddbjbdbffaafe(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if ONE in palette(obj) or TWO in palette(obj):
      O = paint(cover(O, obj), shift(obj, gravitate(obj, extract(objs, lambda x: (ONE in palette(x) or TWO in palette(x)) and x != obj))))
  return O
 
9.333333333333334, tensor(1.7828), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def cdgbacdaabefeaajbebejfeacecffcag(I):
  objs = objects(I, F, F, T)
  output = canvas(0, shape(I))
  for obj in objs:
    offset = (height(I) - height(obj), width(I) // 2 - width(obj) // 2)
    output = paint(output, shift(obj, offset))
  return output
 
12.666666666666666, tensor(1.7828), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def ehbfbahhgageegegbhbcedcibegadidi(I):
  objs = objects(I, F, F, T)
  h = height(I)
  w = width(I)
  return paint(
      canvas(0, (h, w)),
      frozenset(
          (v, (h - uppermost(obj) - 1, w // 2 + j - width(obj) // 2))
          for obj in objs
          for v, (i, j) in obj
      )
  )
 
7.0, tensor(1.7836), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the right of "1". The output grid should have a black background. 
:: def jadibbbbifccefcbjecfdiabeceacdej(I):
  one_loc = first(ofcolor(I, ONE))
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) != ONE:
      offset = (one_loc[0] - uppermost(obj), one_loc[1] + 1 - leftmost(obj))
      O = move(O, obj, offset)
  return O
 
8.333333333333334, tensor(1.7836), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the right of "1". The output grid should have a black background. 
:: def eebihiddiaigeeihieacdfcdfcahjffd(I):
  one_loc = ulcorner(first(colorfilter(objects(I, T, T, T), ONE)))
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) != ONE:
      new_loc = (one_loc[0], one_loc[1] + 1 + width(obj))
      O = move(O, obj, subtract(new_loc, ulcorner(obj)))
  return O
 
9.333333333333334, tensor(1.7836), Description: Move all the colored shapes to the same horizontal row as the digit "1", maintaining their relative vertical positions. If a shape is already in the same row as "1", move it to the right of "1". The output grid should have a black background. 
:: def ggcfcfcbcifaeajfiiiacadbicbdiedb(I):
  one_obj = first(colorfilter(objects(I, T, T, T), ONE))
  one_loc = ulcorner(one_obj)
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) != ONE:
      new_loc =  (one_loc[0] if uppermost(obj) < one_loc[0] else one_loc[0] + height(one_obj), one_loc[1] + width(one_obj) + 1)
      O = move(O, obj, subtract(new_loc, ulcorner(obj)))
  return O
 
10.333333333333334, tensor(1.7843), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a background color that is the most common color in the input grid. 
:: def cgdbcfjbhbhhegebbefbedaaadgfedbd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  bg = mostcolor(I)
  return tuple(
    tuple(
      next((v for v, (i2, j2) in merge([shift(obj, (height(I) - 1 - lowermost(obj), center(obj)[1] - center(asindices(I))[1])) for obj in objs]) if (i2, j2) == (i, j)), bg)
      for j in range(len(I[0])))
    for i in range(len(I)))
 
10.333333333333334, tensor(1.7843), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a background color that is the most common color in the input grid. 
:: def fhbhdcadgdcdebaibgfjejbdefaehjbi(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (height(I) - 1 - lowermost(obj), center(obj)[1] - center(asindices(I))[1])))
  return O
 
8.666666666666666, tensor(1.7843), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a background color that is the most common color in the input grid. 
:: def hdcjjeeiicecehceacfgehdcjiefggcb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  bg = mostcolor(I)
  return tuple(
      tuple(
          v if (i, j) in toindices(merge([shift(obj, (height(I) - 1 - lowermost(obj), center(obj)[1] - center(asindices(I))[1])) for obj in objs])) else bg
          for j, v in enumerate(row)
      ) for i, row in enumerate(I)
  ) 
 
13.333333333333334, tensor(1.7768), Description: Move all the colored shapes to the bottom of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def jbhajhdecjfeeecabjeahfeccbhcjbcj(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), 0)))
  return O
 
11.333333333333334, tensor(1.7768), Description: Move all the colored shapes to the bottom of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def dhhcfcaacaadehdhibechcfafhgccbaf(I):
  O = canvas(ZERO, shape(I))
  for color in palette(I) - {ZERO}:
    obj = extract(objects(I, T, F, T), lambda o: color in palette(o))
    O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), 0)))
  return O
 
13.333333333333334, tensor(1.7768), Description: Move all the colored shapes to the bottom of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def gffhghhjefggefccbccibabgcbfdgebi(I):
    return paint(canvas(ZERO, shape(I)), merge(apply(lambda obj: shift(obj, (height(I) - height(obj) - uppermost(obj), 0)), objects(I, T, F, T))))
 
8.333333333333334, tensor(1.7771), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def cbecddgacgaeegheidagfdacaddfdjba(I):
    objs = objects(I, T, F, T)
    return paint(
        canvas(ZERO, shape(I)), 
        merge(apply(lambda o: shift(o, (height(I) - lowermost(o), 0)), objs))
    )
 
12.666666666666666, tensor(0.1247), Description: Center each of the colored shapes within the grid. The output grid should have the same background color as the input grid. 
:: def bhihidfeaeacedjdaecfceeidbjdigbb(I):
    objs = objects(I, False, False, True)  # Extract non-background objects
    O = I
    for obj in objs:
        center_i = (uppermost(obj) + lowermost(obj)) // 2
        center_j = (leftmost(obj) + rightmost(obj)) // 2
        obj_center = (center_i, center_j)
        obj_ulcorner = ulcorner(obj)
        offset = subtract(obj_center, obj_ulcorner)
        O = paint(cover(O, obj), shift(obj, offset))
    return O
 
10.333333333333334, tensor(0.1247), Description: Center each of the colored shapes within the grid. The output grid should have the same background color as the input grid. 
:: def edbidjgigedfeceabjaffhebccehedhd(I):
    O = I 
    for v in palette(I) - {mostcolor(I)}: # Iterate over foreground colors
        obj = frozenset((v, (i, j)) for i, r in enumerate(I) for j, c in enumerate(r) if c == v)  # Get the object
        O = paint(cover(O, obj), shift(obj, subtract(centerofmass(obj), ulcorner(obj)))) # Center the object
    return O
 
9.333333333333334, tensor(0.0186), Description: Move each colored shape towards the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background. 
:: def bjfddjacejhfeiadigaadedfdgjfcbff(I):
    O = I
    for obj in objects(I, False, False, True):
        O = move(O, obj, gravitate(obj, {(0, center(asindices(I)))}))
    return O
 
13.666666666666666, tensor(0.0135), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def edbffafbdeihebfajhdeacjaaahfficg(I):
  objs = objects(I, F, F, T)
  out = I
  for obj in objs:
    if vline(obj):
      out = paint(out, shift(normalize(obj), (height(I) // 2 - height(obj) // 2, width(I) // 2 - width(obj) // 2)))
    else:
      out = paint(out, shift(normalize(obj), (height(I) // 2 - height(obj) // 2, width(I) // 2 - width(obj) // 2)))
  O = out
  return O
 
21.333333333333332, tensor(0.0135), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def aafgijbjihcfeccjbjadcafdgfbgegac(I):
  h = height(I)
  w = width(I)
  O = canvas(ZERO, (h, w))
  for j in range(w):
    col = frozenset((I[i][j], (i, j)) for i in range(h) if I[i][j] != ZERO)
    if len(col) > 0:
      O = paint(O, shift(normalize(col), (h // 2 - height(col) // 2, j)))
  for i in range(h):
    row = frozenset((I[i][j], (i, j)) for j in range(w) if I[i][j] != ZERO)
    if len(row) > 0:
      O = paint(O, shift(normalize(row), (i, w // 2 - width(row) // 2)))
  return O
 
12.666666666666666, tensor(0.0115), Description: Move each colored square to the center of the grid, maintaining its original position relative to the center. The output grid should have a black background and be the same size as the input grid. 
:: def fifafafjdaeaebiibehacabchcbebffe(I):
  h, w = height(I), width(I)
  O = canvas(ZERO, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != ZERO:
        target_i = h // 2 + (i - h // 2)
        target_j = w // 2 + (j - w // 2)
        O = paint(O, {(I[i][j], (target_i, target_j))})
  return O
 
17.0, tensor(0.0135), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def ccffjefgeagfeecfifcaidjchbdgfadh(I):
  h, w = height(I), width(I)
  O = canvas(ZERO, (h, w))
  for i in range(h):
    row_obj = frozenset((I[i][j], (i, j)) for j in range(w) if I[i][j] != ZERO)
    if row_obj:
      O = paint(O, shift(row_obj, (0, w // 2 - width(row_obj) // 2)))
  for j in range(w):
    col_obj = frozenset((I[i][j], (i, j)) for i in range(h) if I[i][j] != ZERO)
    if col_obj:
      O = paint(O, shift(col_obj, (h // 2 - height(col_obj) // 2, 0)))
  return O 
 
12.333333333333334, tensor(0.0109), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced one column apart. The output grid should have a black background and be the same size as the input grid. 
:: def cebffdafefffeaidbbacdcdffchaeceb(I):
  objs = objects(I, F, F, T)  # Extract objects excluding background
  shifted_objs = frozenset()
  current_row = 0
  for obj in objs:
    shifted_obj = shift(obj, (current_row, -leftmost(obj)))  # Shift left and down
    shifted_objs = combine(shifted_objs, shifted_obj) 
    current_row += height(obj) + 1  # Update row for the next object
  O = paint(canvas(0, shape(I)), shifted_objs)  # Paint on an empty canvas
  return O 
 
11.666666666666666, tensor(0.0100), Description: Move each column of colored squares to the left, maintaining their vertical positions. Each column should be shifted one column to the left of the previous column. The output grid should have a black background. 
:: def eadfcefhdbdeebjcigcbedabeagdhaej(I):
  O = canvas(0, shape(I)) # Start with an empty canvas
  h, w = shape(I)
  current_row = 0
  for j in range(w):
    column_obj = frozenset({(I[i][j], (i, j)) for i in range(h) if I[i][j] != 0})
    if column_obj:
      shifted_obj = shift(column_obj, (current_row, -j))
      O = paint(O, shifted_obj)
      current_row += height(column_obj) + 1
  return O
 
12.333333333333334, tensor(0.0109), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced one column apart. The output grid should have a black background and be the same size as the input grid. 
:: def cdcdgehidfbfedhcjiiaehiaebaccfeh(I):
  objs = objects(I, F, F, T)
  destination =  {(1, (0, 0))} # Dummy destination at the top-left
  shifted_objs = frozenset()
  current_row = 0
  for obj in objs:
    offset = gravitate(obj, destination) # Calculate downward shift
    shifted_obj = shift(obj, (offset[0] + current_row, -leftmost(obj))) 
    shifted_objs = combine(shifted_objs, shifted_obj)
    current_row += height(obj) + 1 
  O = paint(canvas(0, shape(I)), shifted_objs) 
  return O
 
12.333333333333334, tensor(0.0109), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced one column apart. The output grid should have a black background and be the same size as the input grid. 
:: def fejbaffidcfcegbdjaheedcahbdbihad(I):
  objs = objects(I, F, F, T)
  sorted_objs = order(objs, uppermost)  # Sort objects by top row
  shifted_objs = frozenset()
  current_row = 0
  for obj in sorted_objs:
    shifted_obj = shift(obj, (current_row, -leftmost(obj)))
    shifted_objs = combine(shifted_objs, shifted_obj)
    current_row += height(obj) + 1 
  O = paint(canvas(0, shape(I)), shifted_objs)
  return O
 
13.333333333333334, tensor(0.0109), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced one column apart. The output grid should have a black background and be the same size as the input grid. 
:: def bcdcciadagjfeaecjaddjaejdibbeced(I):
  O = canvas(0, shape(I))  # Empty canvas
  h, w = shape(I)
  current_row = 0
  for i in range(h):
    row_objs = objects(crop(I, (i, 0), (1, w)), F, F, T)  # Objects in the row
    if row_objs:
      for obj in row_objs:
        shifted_obj = shift(obj, (current_row, -leftmost(obj)))
        O = paint(O, shifted_obj)
      current_row += height(first(row_objs)) + 1
  return O
 
16.666666666666668, tensor(0.0111), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def bdbjabheiaabeecebjcbdaigbcacbaed(I):
    objs = objects(I, T, F, T) # Get all objects, treating diagonals as disconnected
    center_col = width(I) // 2  # Calculate the center column
    output = canvas(0, shape(I)) # Create an empty canvas of the same size as input
    
    current_row = 0 
    for obj in objs: 
        obj_width = width(obj)
        col_offset = center_col - (obj_width // 2) 
        output = paint(output, shift(normalize(obj), (current_row, col_offset)))
        current_row += height(obj)
    
    return output
 
16.666666666666668, tensor(0.0111), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def fedededhabffegddajebcifgcfhdghfc(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: -uppermost(obj))
  center_col = width(I) // 2
  output = canvas(0, shape(I))
  
  current_row = 0
  for obj in objs:
    obj_width = width(obj)
    col_offset = center_col - (obj_width // 2)
    output = paint(output, shift(normalize(obj), (current_row, col_offset)))
    current_row += height(obj)
    
  return output
 
14.0, tensor(0.0111), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def gbgfghaheiefebebifgcibgefchicbce(I):
  values = difference(palette(I), {0})  # Get unique non-zero values
  center_col = width(I) // 2
  output = canvas(0, shape(I))
  
  current_row = 0
  for value in values:
    indices = ofcolor(I, value) # Get indices of the current value
    obj_width = rightmost(indices) - leftmost(indices) + 1
    col_offset = center_col - (obj_width // 2)
    output = fill(output, value, shift(indices, (current_row - uppermost(indices), col_offset - leftmost(indices))))
    current_row += height(indices) 
  
  return output
 
16.666666666666668, tensor(0.0111), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def dbjdbaccdegfefhfbiabfaeabdjfacca(I):
    objs = sorted(objects(I, T, F, T), key=lambda obj: (leftmost(obj), uppermost(obj)))
    center_col = width(I) // 2
    output = canvas(0, shape(I))

    current_row = 0
    for obj in objs:
        obj_width = width(obj)
        col_offset = center_col - (obj_width // 2)
        output = paint(output, shift(normalize(obj), (current_row, col_offset)))
        current_row += height(obj)

    return output
 
9.333333333333334, tensor(0.0112), Description: Move each colored shape to the top left corner of the grid, maintaining its original orientation. The output grid should have a black background and be the same size as the input grid. Each shape should be centered horizontally within the grid. 
:: def gbedgfecfadcefbhjecibcjefjbbfefd(grid):
  objs = objects(grid,False,True,True)
  output = canvas(0, shape(grid))
  for obj in objs:
    w = width(obj)
    shifted_obj = shift(obj, (-uppermost(obj), -leftmost(obj) + (shape(grid)[1] - w) // 2))
    output = paint(output, shifted_obj)
  return output 
 
14.333333333333334, tensor(0.0155), Description: Center each of the colored shapes vertically within the grid. The output grid should have the same background color as the input grid. 
:: def eedcabehechfecifjdijedidabjbjhfe(grid):
  objs = fgpartition(grid)
  output = canvas(0, shape(grid))
  for obj in objs:
    normalized = normalize(obj)
    centered = shift(normalized, ((shape(grid)[0] - height(normalized)) // 2, 0))
    output = paint(output, centered)
  return output
 
9.333333333333334, tensor(0.0118), Description: Move each colored shape to the top left corner of the grid, maintaining its original orientation. The output grid should have a black background and be the same size as the input grid. Each shape should be centered both horizontally and vertically within the grid. 
:: def habfiedibefeegegbfgegfhifjfbgbah(grid):
  objs = objects(grid, True, True, True)
  output = canvas(0, shape(grid))
  for obj in objs:
    left_edge = leftmost(obj)
    right_edge = rightmost(obj)
    width = right_edge - left_edge + 1
    centered_obj = shift(obj, (
        -uppermost(obj) + (shape(grid)[0] - height(obj)) // 2,
        -left_edge + (shape(grid)[1] - width) // 2
    ))
    output = paint(output, centered_obj)
  return output
 
12.666666666666666, tensor(0.0155), Description: Center each of the colored shapes vertically within the grid. The output grid should have the same background color as the input grid. 
:: def ebfjaaagfbbbeifdaececadafgadfcea(grid):
  def process_object(obj):
    height = lowermost(obj) - uppermost(obj) + 1
    return shift(obj, ((shape(grid)[0] - height) // 2, 0))

  return paint(canvas(0, shape(grid)), merge(apply(process_object, fgpartition(grid))))
 
11.0, tensor(0.2846), Description: Center each of the colored shapes within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def eibjcbbaefdiefcgijccacffgbbhebch(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    O = underpaint(O, shift(obj, subtract(centerofmass(obj), center(obj))))
  return O 
 
15.333333333333334, tensor(0.2846), Description: Center each of the colored shapes within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def ebaadhbaffjdejcaififbahgbfabcdec(I):
  objs = tuple(normalize(obj) for obj in fgpartition(I))
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = paint(O, shift(obj, subtract(center(asindices(O)), center(obj))))
  return O
 
11.0, tensor(0.0143), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def dagdbbeedcbcecddiacgagcfcceeefbd(I):
  objs = objects(I, False, False, True)
  h, w = shape(I)
  O = canvas(0, (h, w))
  current_row = h
  for obj in objs:
    obj_h = height(obj)
    obj_w = width(obj)
    offset = (current_row - obj_h, w // 2 - obj_w // 2)
    shifted_obj = shift(obj, offset)
    O = paint(O, shifted_obj)
    current_row -= obj_h + 1
  return O
 
10.333333333333334, tensor(0.0143), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def ifcbfbfecehbefaejdiidghafeaebhed(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: -uppermost(obj))
  h, w = shape(I)
  O = canvas(0, (h, w))
  bottom = h - 1
  for obj in objs:
    obj_h = height(obj)
    offset = (bottom - (lowermost(obj) - uppermost(obj)), w // 2 - width(obj) // 2)
    O = paint(O, shift(obj, offset))
    bottom -= obj_h
  return O
 
9.666666666666666, tensor(0.0143), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def bijiegabgcigeehbjhegghbedcfffgaa(I):
  objs = objects(I, False, False, True)
  h, w = shape(I)
  O = canvas(0, (h, w))
  bottom = h 
  for obj in objs:
    bottom -= height(obj)
    O = paint(O, shift(obj, (bottom, w // 2 - width(obj) // 2)))
  return O
 
9.333333333333334, tensor(0.0143), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def eaidagaeeadaegfeadficacgghajfegc(I):
  h, w = shape(I)
  objs = sorted(objects(I, False, False, True), key=lambda obj: centerofmass(obj)[0])
  O = canvas(0, (h, w))
  current_bottom = h
  for obj in objs:
    obj_h = height(obj)
    O = paint(O, shift(obj, (current_bottom - obj_h, w // 2 - width(obj) // 2)))
    current_bottom -= obj_h 
  return O
 
9.333333333333334, tensor(0.0107), Description: Move each colored shape to the bottom right corner of the grid, maintaining its original orientation. The output grid should have a black background and be the same size as the input grid. Each shape should be centered horizontally within the grid. 
:: def hgfhgedcebfiejdfbccbadfjjjbiabdb(I):
  shifted_objs = set()
  h, w = shape(I)
  for obj in objects(I, False, False, True):
    obj_h, obj_w = shape(obj)
    new_obj = {(v, (i + h - obj_h, j + w // 2 - obj_w // 2)) for v, (i, j) in obj}
    shifted_objs |= new_obj
  return paint(canvas(0, (h, w)), frozenset(shifted_objs))
 
12.666666666666666, tensor(0.0164), Description: Place each colored shape in the grid, starting from the bottom right corner and moving diagonally upwards towards the top left corner. Each shape should be placed one row above and one column to the left of the previous shape. The output grid should have a black background and be the same size as the input grid. 
:: def ajdcdbfgafaceadhbbeadcbidfgbcfeb(grid):
  objs = fgpartition(grid)
  output = canvas(0, shape(grid))
  offset = (shape(grid)[0] - 1, (shape(grid)[1] - 1) // 2)
  for obj in objs:
    normalized = normalize(obj)
    placed = shift(normalized, (offset[0] - uppermost(normalized), offset[1]))
    output = paint(output, placed)
    offset = (offset[0] - 1, offset[1] + 1) 
  return output
 
13.0, tensor(0.0176), Description: Place each colored shape in the grid, starting from the bottom left corner and moving diagonally upwards towards the top right corner. Each shape should be placed one row above and one column to the right of the previous shape. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def bdgaeggdabebeacjafbagihccdffejcd(grid):
  output = canvas(mostcolor(grid), shape(grid))
  for i, obj in enumerate(fgpartition(grid)):
    output = paint(output, shift(normalize(obj), (len(grid) - 1 - i, i)))
  return output 
 
12.666666666666666, tensor(0.0176), Description: Place each colored shape in the grid, starting from the bottom right corner and moving diagonally upwards towards the top left corner. Each shape should be placed one row above and one column to the left of the previous shape. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def fjefjdhffgbiedbhaegfefgaddaffjff(grid):
  objs = sorted(fgpartition(grid), key=lambda obj: -uppermost(obj)) 
  output = canvas(mostcolor(grid), shape(grid))
  offset = (len(grid) - 1, (len(grid[0]) - 1) // 2)
  for obj in objs:
    output = paint(output, shift(normalize(obj), (offset[0], offset[1])))
    offset = (offset[0] - 1, offset[1] + 1)
  return output
 
11.0, tensor(0.0176), Description: Place each colored shape in the grid, starting from the bottom left corner and moving diagonally upwards towards the top right corner. Each shape should be placed one row above and one column to the right of the previous shape. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def jcdgdacbcdecefhcjdcdgfbhafcbfibi(grid):
  output = canvas(mostcolor(grid), shape(grid))
  diag = ((i, (len(grid[0]) - 1) // 2 + i) for i in range(len(grid))) 
  for i, (obj) in enumerate(fgpartition(grid)):
    output = paint(output, shift(normalize(obj), (next(diag)[0] - uppermost(obj), next(diag)[1])))
  return output
 
12.333333333333334, tensor(0.0170), Description: Place each colored shape in the grid, starting from the center and moving diagonally upwards towards the top right corner. Each shape should be placed one row above and one column to the right of the previous shape. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def egfbjceibjaaeedcjachdcbeidchbbje(grid):
    h, w = len(grid), len(grid[0])
    output = canvas(mostcolor(grid), (h, w))
    start = ((h - 1) // 2, (w - 1) // 2)
    for i, obj in enumerate(fgpartition(grid)):
        offset = (start[0] - i - uppermost(obj), start[1] + i)
        output = paint(output, shift(normalize(obj), offset))
    return output
 
14.666666666666666, tensor(0.0287), Description: Center each of the colored shapes vertically within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def giiadidceegiedjfibhedadedgdgeidc(I):
  O = canvas(mostcolor(I), shape(I))  # Create an empty canvas
  for obj in fgpartition(I):           # Iterate over foreground objects
    com_j = centerofmass(obj)[1]       # Get the column index of the center of mass
    O = paint(O, shift(obj, (0, len(I[0]) // 2 - com_j))) # Center vertically in the column
  return O
 
12.333333333333334, tensor(0.0105), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def abghajcbighiebdabhdjdhcbhebfiche(I):
    objs = fgpartition(I)
    return tuple(
        tuple(
            next((v for obj in objs for (v, (pi, pj)) in obj if pj == j and pi == i - centerofmass(obj)[0] + len(I) // 2), mostcolor(I))
            for j in range(len(I[0])))
        for i in range(len(I))
    )
 
16.0, tensor(0.0124), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. 
:: def cedhedfageebedfajfcahjaeaeedfjgd(I):
  objs = objects(I, F, F, T)  # Extract objects from the grid
  out = canvas(0, shape(I))    # Create an empty canvas
  h = height(I)
  w = width(I)
  current_height = 0
  for obj in objs:
    obj_height = height(obj)
    obj_width = width(obj)
    top_left_corner = (h // 2 - obj_height // 2 - current_height, w // 2 - obj_width // 2) 
    out = paint(out, shift(normalize(obj), top_left_corner))
    current_height += obj_height
  O = out
  return O
 
16.666666666666668, tensor(0.0133), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def icfgdeaggiffedajaggfbicghfcaagbi(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj)) # Extract and sort objects by their topmost row
  out = canvas(0, shape(I))                                         # Create an empty canvas
  current_height = 0
  for obj in objs:
    out = paint(out, shift(normalize(obj), (current_height, width(I) // 2 - width(obj) // 2))) # Paint objects, stacking vertically
    current_height += height(obj)                                   # Update current height on the canvas
  O = out
  return O
 
16.666666666666668, tensor(0.0124), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. 
:: def egfbebbeejabejabbfdjebddddcfeiif(I):
  objs = objects(I, F, F, T)                              # Extract objects
  canvas_height = height(I)                                # Get canvas dimensions
  canvas_width = width(I)
  out = canvas(0, (canvas_height, canvas_width))          # Create canvas
  total_object_height = sum([height(obj) for obj in objs]) # Calculate total height of objects
  current_y = canvas_height // 2 - total_object_height // 2 # Starting Y position
  for obj in objs:
    obj_width = width(obj)
    x_offset = canvas_width // 2 - obj_width // 2          # Calculate X offset for centering
    out = paint(out, shift(normalize(obj), (current_y, x_offset))) # Paint object
    current_y += height(obj)                              # Update Y for next object
  O = out
  return O
 
15.666666666666666, tensor(0.0124), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. 
:: def bdefjcbaefcbecfgacabahedbaebifgg(I):
  objs = objects(I, F, F, T)            # Extract objects from the input grid
  heights = apply(height, objs)           # Calculate the height of each object
  total_height = sum(heights)           # Calculate the total height of all objects
  centered_y = height(I) // 2 - total_height // 2  # Calculate the y-coordinate of the center of the objects
  out = canvas(0, shape(I))              # Create an empty canvas of the same size as the input
  current_y = centered_y                # Initialize the current y-coordinate
  for obj in objs:
    obj_width = width(obj)
    out = paint(out, shift(normalize(obj), (current_y, width(I) // 2 - obj_width // 2)))  # Paint the object, centered horizontally and stacked vertically
    current_y += height(obj)             # Update the current y-coordinate
  O = out
  return O
 
11.333333333333334, tensor(0.0150), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. If a shape is already above another shape in the same column, it should be placed directly above that shape. 
:: def agadfcecfcegefbeiaabdhcjjiiidcdb(I):
  h, w = shape(I)
  objs = objects(I, False, False, True)

  def new_position(obj):
    obj_h, obj_w = shape(obj)
    bottom_edge = h
    for other in objs:
      if vmatching(obj, other) and uppermost(other) < uppermost(obj):
        bottom_edge = min(bottom_edge, uppermost(other))
    return (bottom_edge - obj_h, w // 2 - obj_w // 2)

  return paint(
      canvas(0, (h, w)),
      frozenset(
          (v, add((i, j), new_position(frozenset({(v, (i, j))}))))
          for obj in objs
          for v, (i, j) in obj
      ),
  )
 
13.0, tensor(0.0094), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background and be the same size as the input grid. 
:: def bbjgabfhgcbaefiebcebhdcbcgahefag(I):
  objs = objects(I, False, False, True)
  center_col = width(I) // 2
  output = canvas(0, shape(I))
  for obj in objs:
    obj_center = centerofmass(obj)
    col_offset = center_col - obj_center[1]
    output = paint(output, shift(obj, (0, col_offset)))
  return output
 
12.666666666666666, tensor(0.0094), Description: Move each colored shape to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a black background and be the same size as the input grid. 
:: def ecgcafiigdebedacbgjahfbfecbfbaac(I):
    center_col = width(I) // 2
    return paint(canvas(0, shape(I)), 
                 merge({shift(obj, (0, center_col - centerofmass(obj)[1]))
                       for obj in objects(I, False, False, True)}))
 
14.666666666666666, tensor(0.0191), Description: Center each of the colored shapes horizontally within the grid. The output grid should have the same background color as the input grid. 
:: def idcejdaebcdhefjajbaaceabccehjahg(I):
    O = I
    for v in palette(I) - {0}:
        obj = {(v, (i, j)) for i, r in enumerate(I) for j, v2 in enumerate(r) if v == v2}
        center_j = centerofmass(obj)[1]
        offset = width(I) // 2 - center_j
        O = paint(cover(O, obj), shift(obj, (0, offset)))
    return O 
 
12.0, tensor(0.0142), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def gbhbaijbdageeajdjjfcfcjbabccfaec(grid):
  h, w = len(grid), len(grid[0])
  output = canvas(mostcolor(grid), (h, w))
  objs = sorted(fgpartition(grid), key=lambda obj: -uppermost(obj)) # Sort by uppermost row
  center_x = (w - 1) // 2
  bottom_y = h - 1
  for i, obj in enumerate(objs):
    offset = (bottom_y - height(obj) - i, center_x - width(obj) // 2)
    output = paint(output, shift(obj, offset))
  return output
 
12.0, tensor(0.0142), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def fcffbegbcfaheeahbfaegadhfcehcdea(grid):
  h, w = shape(grid)
  output = canvas(mostcolor(grid), (h, w))
  objs = list(fgpartition(grid))
  start_y = h - len(objs) - sum([height(obj) for obj in objs]) + 1  
  y = start_y
  for obj in objs:
    x = (w - width(obj)) // 2 
    output = paint(output, shift(obj, (y, x)))
    y += height(obj) + 1
  return output
 
13.333333333333334, tensor(0.0142), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def gjaffedieefaegfjibcchachffdefdje(grid):
  output = canvas(mostcolor(grid), shape(grid))
  objs = sorted(fgpartition(grid), key=lambda x: ulcorner(x)[0])
  y = len(grid) - 1
  for obj in objs:
    x = (len(grid[0]) - width(obj)) // 2
    output = paint(output, shift(obj, (y - height(obj) + 1, x)))
    y -= height(obj) + 1
  return output
 
13.333333333333334, tensor(0.0142), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. 
:: def bcdaibfeaaccedddjagfbcajcbhhfacg(grid):
  objs = sorted(fgpartition(grid), key=lambda obj: -uppermost(obj))
  height_sum = sum(height(o) for o in objs) + len(objs) - 1
  output = canvas(mostcolor(grid), (len(grid), len(grid[0])))
  y = len(grid) - height_sum
  for obj in objs:
    x = (len(grid[0]) - width(obj)) // 2
    output = paint(output, shift(obj, (y, x)))
    y += height(obj) + 1
  return output
 
13.333333333333334, tensor(0.0208), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. The shapes should be sorted by their topmost row, then by their width in descending order. 
:: def bafeahddaeciefeajdddeefgfbhfadge(grid):
  h, w = shape(grid)
  output = canvas(mostcolor(grid), (h, w))
  objs = sorted(fgpartition(grid), key=lambda obj: (uppermost(obj), -width(obj)))
  y = h - 1 
  for i, obj in enumerate(objs):
    x = (w - width(obj)) // 2
    output = paint(output, shift(obj, (y - height(obj) - i, x)))
    y -= height(obj) + 1
  return output
 
12.666666666666666, tensor(0.0107), Description: Move each colored square to the center of the grid horizontally, maintaining its original vertical position. The output grid should have a background color that is the most common color in the input grid. 
:: def bagcjdjjeaiaedceicacafefdfcaacjd(I):
  O = I 
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I): # For each non-background cell
        shift_amount = (len(I[0]) // 2) - j  # Calculate horizontal shift 
        O = paint(cover(O, {(I[i][j], (i, j))}), {(I[i][j], (i, j + shift_amount))}) # Move and paint
  return O
 
16.666666666666668, tensor(0.0133), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. 
:: def fadccjebffhbeadebbbbccbcbacefgfa(I):
  objs = objects(I, F, F, T)
  out = canvas(0, shape(I))
  y_offset = 0
  for obj in objs:
    obj_width = width(obj)
    x_offset = width(I) // 2 - obj_width // 2
    out = paint(out, shift(normalize(obj), (y_offset, x_offset)))
    y_offset += height(obj)
  return out
 
10.333333333333334, tensor(0.0191), Description: Center each of the colored shapes horizontally within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def gcebbceibeegecacjfcdiefgefcajjcg(grid):
  output = canvas(mostcolor(grid), shape(grid))
  for obj in fgpartition(grid):
    output = underpaint(output, shift(obj, (height(obj) // 2, 0)))
  return output
 
10.333333333333334, tensor(0.0214), Description: Center each of the colored shapes vertically within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def ijhibfdgeefgebdaaifedecfejfbgffb(grid):
  output = canvas(mostcolor(grid), shape(grid))
  for obj in fgpartition(grid):
    offset = (lowermost(obj) - uppermost(obj) + 1, 0)
    output = underpaint(output, shift(obj, offset))
  return output
 
11.0, tensor(0.0214), Description: Center each of the colored shapes vertically within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def hjhcdgeecchaebdcjejdfeeciejaceca(grid):
  h = len(grid)
  output = canvas(mostcolor(grid), shape(grid))
  for obj in fgpartition(grid):
    output = underpaint(output, shift(obj, (h - uppermost(obj) - height(obj) // 2, 0)))
  return output
 
10.0, tensor(0.0141), Description: Center each of the colored shapes horizontally within the grid. The output grid should have the same background color as the input grid. 
:: def dejiddeibaehedhbifcdjdbjbhedcdfc(grid):
  output = grid
  for obj in fgpartition(grid):
    output = paint(cover(output, obj), shift(obj, (height(obj) // 2, 0)))
  return output
 
13.0, tensor(0.0146), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a black background. 
:: def gdaabjahaaegeheaaejabjcbbeacabfa(I):
    O = I
    for obj in objects(I, False, False, True):
        O = move(O, obj, (len(I) // 2 - centerofmass(obj)[0], 0))
    return O
 
1658.3333333333333, tensor(0.0167), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def fcgciccacebbejhhbcafdefjiejfbabe(I):
  h, w = shape(I)
  objs = sorted(objects(I, False, False, True), key=lambda obj: -uppermost(obj))
  O = canvas(0, (h, w))
  current_bottom = h
  return merge([paint(O, shift(obj, (current_bottom - height(obj)*(i+1), w // 2 - width(obj) // 2))) for i, obj in enumerate(objs)])
 
22.666666666666668, tensor(0.0148), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, add a square of the same color one column to the left and one column to the right of the shape. The output grid should have the same background color as the input grid. 
:: def dccaaificbajejeebdccddaibfdeajab(grid):
  def process_object(obj):
    color = first(obj)[0]
    centered_obj = shift(obj, ((shape(grid)[0] - height(obj)) // 2, 0))
    expanded_obj = combine(centered_obj, {(color, (i, j-1)) for color, (i, j) in centered_obj})
    return combine(expanded_obj, {(color, (i, j+1)) for color, (i, j) in centered_obj})
  return paint(canvas(0, shape(grid)), merge(apply(process_object, fgpartition(grid))))
 
18.333333333333332, tensor(0.0160), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, add a square of the same color one column to the left, one column to the right, and one row above the shape. The output grid should have a background color that is the most common color in the input grid. 
:: def dfcijhfhfgfdecdeadacbgggccajbfcg(grid):
  def transform_object(obj):
    c = color(obj)
    i_min, j_min = ulcorner(obj)
    i_max, j_max = lrcorner(obj)
    new_obj = set()
    for i in range(i_min, i_max + 1):
      for j in range(j_min, j_max + 1):
        if (c, (i - (i_min + i_max - len(grid) + 1) // 2, j)) in obj:
          new_obj.add((c, (i - (i_min + i_max - len(grid) + 1) // 2, j - 1)))
          new_obj.add((c, (i - (i_min + i_max - len(grid) + 1) // 2, j)))
          new_obj.add((c, (i - (i_min + i_max - len(grid) + 1) // 2, j + 1)))
    return frozenset(new_obj)
  return paint(canvas(mostcolor(grid), shape(grid)), merge(apply(transform_object, fgpartition(grid))))
 
29.333333333333332, tensor(0.0161), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, add a square of the same color one column to the left, one column to the right, and one row below the shape. The output grid should have a background color that is the most common color in the input grid. 
:: def eedabffebcgbedcajejacdcafbbaejgd(grid):
  def process(obj):
    v_center = (uppermost(obj) + lowermost(obj)) // 2
    return frozenset({(color(obj), (i - v_center + len(grid) // 2, j + dj)) 
                        for dj in (-1, 0, 1) 
                        for _, (i, j) in obj})
  return paint(canvas(mostcolor(grid), shape(grid)), merge(apply(process, fgpartition(grid))))
 
13.0, tensor(0.0259), Description: Center each of the colored shapes horizontally within the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def ebihbicedejcebjdacdefbedfefagdad(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    O = paint(O, shift(obj, (0, len(I[0]) // 2 - centerofmass(obj)[1])))
  return O
 
9.333333333333334, tensor(0.1306), Description: Center the largest colored shape horizontally within the grid. The output grid should have a background color that is the most common color in the input grid. If there are no colored shapes in the input grid, leave the grid unchanged. 
:: def jadbgceabdeeeddbihbbdcaahcgdfbdf(I):
  obj_list = list(objects(I, False, False, True))
  if obj_list:
    main_obj = argmax(obj_list, size) 
    return paint(canvas(mostcolor(I), shape(I)), shift(main_obj, (0, len(I[0]) // 2 - centerofmass(main_obj)[1])))
  else:
    return I
 
1670.3333333333333, tensor(0.0116), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. The shapes should be moved such that the distance between the shape's center and the center of the grid vertically is less than or equal to half the distance between the shape's topmost row and the bottommost row of the grid. 
:: def ahajfdegbcedebbjjgdadjhdfcjgeecj(I):
    return tuple(
      tuple(
        next((v for (v, (pi, pj)) in obj if pj == j and abs(pi - centerofmass(obj)[0]) <= len(I) // 2 - abs(i - len(I) // 2)), mostcolor(I))
        for j in range(len(I[0])))
      for i in range(len(I)) for obj in objects(I, False, False, True) 
  )
 
15.333333333333334, tensor(1.9817), Description: For each row in the grid, find the colored square that is closest to the center of the grid horizontally. If there are multiple squares at the same distance, choose the one that is closest to the center of the grid vertically. Replace all other squares in the row with the background color. The output grid should have the same background color as the input grid. 
:: def befhfgfihfeceffhaaagbechaihjedgd(I):
  return tuple(
    tuple(
      next((I[i][k] for k in range(len(I[0])) if (I[i][k] != mostcolor(I) and abs(k - centerofmass(list(objects(I, False, False, True))[0])[1]) == abs(j - len(I[0]) // 2))), mostcolor(I))
      for j in range(len(I[0])))
    for i in range(len(I))
  )
 
15.666666666666666, tensor(0.0205), Description: If the first object in the grid is a single square with the color 1, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. Otherwise, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. The shapes should be spaced one column apart. 
:: def eefaijfcgfbjedgbjeidbchbcdfbegdd(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: -color(obj)) # Sort by color, anchor will be first if present
  out = canvas(0, shape(I))
  if size(objs[0]) == 1 and color(objs[0]) == 1:  # Check first object (anchor)
    return paint(out, merge({shift(normalize(obj), (i * height(obj), width(I) // 2 - width(obj) // 2)) for i, obj in enumerate(objs)}))
  else:
    return paint(out, merge({shift(normalize(obj), (height(I) // 2 - height(obj) // 2, sum(width(o) + 1 for o in objs[:i]))) for i, obj in enumerate(objs)})) 
 
11.0, tensor(0.0109), Description: Align all the colored shapes horizontally, starting from the leftmost column and moving to the right. The shapes should be spaced one column apart. The output grid should have a black background and be the same size as the input grid. 
:: def bhecbbieedhaefcaacebacfafihfijeb(I):
  objs = objects(I, F, F, T)
  shifted_objs = frozenset()
  current_row = 0
  for obj in objs:
    obj_height = height(obj)
    obj_width = width(obj)
    horizontal_shift = (width(I) - obj_width) // 2 
    shifted_obj = shift(obj, (current_row, horizontal_shift))
    shifted_objs = combine(shifted_objs, shifted_obj)
    current_row += obj_height + 1
  O = paint(canvas(0, shape(I)), shifted_objs)
  return O
 
11.0, tensor(0.0161), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def beecdadebbccebciijhffcefifgcaafa(I):
  objs = objects(I, F, F, T)
  O = canvas(0, shape(I))
  for obj in objs:
    O = underpaint(O, shift(obj, ((height(O)-height(obj))//2, (width(O)-width(obj))//2)))
  return O
 
9.333333333333334, tensor(0.0126), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def heaagijeaddbeecdagccfbfagcgfedid(I):
  objs = objects(I, False, False, True)
  grid = canvas(0, shape(I))
  for obj in objs:
    top = uppermost(obj)
    left = leftmost(obj)
    h = height(obj)
    w = width(obj)
    grid = paint(
        grid, 
        shift(
            obj, 
            (height(I) // 2 - (top + h // 2), 
             width(I) // 2 - (left + w // 2))
        )
    )
  return grid
 
9.333333333333334, tensor(0.0126), Description: Center each of the colored shapes both horizontally and vertically within the grid. The output grid should have the same background color as the input grid. 
:: def adhcdjcejbfeedjbacaggaeegheiagad(I):
  def center_obj(obj):
    return shift(
        obj,
        (height(I) // 2 - (uppermost(obj) + height(obj) // 2),
         width(I) // 2 - (leftmost(obj) + width(obj) // 2))
    )
  return paint(
      canvas(0, shape(I)),
      merge(apply(center_obj, objects(I, False, False, True)))
  )
 
221.66666666666666, tensor(0.0105), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def jhahdafaaadaefcgaffffaciideabffe(I):
    objs = objects(I, False, False, True)
    return tuple(
        tuple(
            next((v for obj in objs for (v, (i, j)) in shift(obj, (len(I) // 2 - centerofmass(obj)[0], 0))), mostcolor(I))
            for j in range(len(I[0])))
        for i in range(len(I))
    )
 
12.666666666666666, tensor(1.9817), Description: For each row in the grid, find the colored square that is closest to the center of the grid horizontally. If there are multiple squares at the same distance, choose the one that is closest to the center of the grid vertically. Replace all other squares in the row with the background color. The output grid should have the same background color as the input grid. 
:: def ifebhdejabaaeafbbaejcebfcjgbaefg(I):
  return tuple(
    tuple(
      next(
        (v for obj in objects(I, False, False, True) for (v, (pi, pj)) in obj if pj == j and abs(pi - centerofmass(obj)[0]) == abs(i - len(I) // 2)),
        mostcolor(I)
      ) for j in range(len(I[0])))
    for i in range(len(I))
  )
 
11.666666666666666, tensor(0.0121), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. The shapes should be moved such that the distance between the shape's center and the center of the grid vertically is less than or equal to half the distance between the shape's topmost row and the bottommost row of the grid. If the shape is already in the correct position, do not move it. 
:: def cfheafaacbfeecciifdiceicghhghgfg(I):
  h = len(I) // 2
  return tuple(
    tuple(
      next(
        (v for obj in fgpartition(I) for (v, (pi, pj)) in obj if pj == j and (pi < h and i == 2 * pi - centerofmass(obj)[0] or pi >= h and i == 2 * pi - centerofmass(obj)[0] - len(I) % 2)),
        mostcolor(I)
      ) for j in range(len(I[0])))
    for i in range(len(I))
  )
 
9.333333333333334, tensor(0.0209), Description: If the input grid contains a shape with the color 1, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. Otherwise, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. The shapes should be spaced one column apart. 
:: def jfbbddicbbciefeaidhchdddaffahdef(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: (-(1 in {v for v, _ in obj}), ulcorner(obj)))  # Sort objects, prioritizing anchor
  out = canvas(0, shape(I))
  anchor_present = objs[0] if (1 in {v for v, _ in objs[0]}) else None
  y_offset = uppermost(anchor_present) if anchor_present else height(I) // 2 - height(objs[0]) // 2
  x_offset = 0
  for obj in objs:
    out = paint(out, shift(normalize(obj), (y_offset, width(I) // 2 - width(obj) // 2))) if anchor_present else paint(out, shift(normalize(obj), (y_offset, x_offset)))
    x_offset += width(obj) + 1
  return out
 
14.0, tensor(0.0209), Description: If the input grid contains a shape with the color 1, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. Otherwise, stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally and vertically. The output grid should have a black background and be the same size as the input grid. The shapes should be spaced one column apart. 
:: def ceecbfbcbegdedfaiifbfhcbgeddhjji(I):
  objs = objects(I, F, F, T)
  anchor_index = next((i for i, obj in enumerate(objs) if 1 in {v for v, _ in obj}), None)  # Find anchor index
  out = canvas(0, shape(I))
  for i, obj in enumerate(objs):
    if anchor_index is not None:
      y_offset = (i - anchor_index) * height(obj)
    else:
      y_offset = height(I) // 2 - height(obj) // 2
    out = paint(out, shift(normalize(obj), (y_offset, width(I) // 2 - width(obj) // 2)))
  return out
 
11.333333333333334, tensor(0.0167), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def beabfdecfaadebecbhcgbejgabbfcbjd(I):
  def place_object(obj, idx, total_objs):
    obj_h = height(obj)
    obj_w = width(obj)
    grid_h, grid_w = shape(I)
    y_offset = grid_h - (idx + 1) * (obj_h + 1) + 1 
    x_offset = (grid_w - obj_w) // 2
    return shift(obj, (y_offset, x_offset))

  return paint(
      canvas(0, shape(I)),
      merge(
          papply(
              lambda obj, i: place_object(obj, i, size(objects(I, F, F, T))),
              order(objects(I, F, F, T), uppermost),
              interval(0, size(objects(I, F, F, T)), 1)
          )
      )
  )
 
1658.3333333333333, tensor(0.0117), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. The shapes should be moved such that the distance between the shape's center and the center of the grid vertically is less than half the distance between the shape's topmost row and the bottommost row of the grid. If the shape is already in the correct position, do not move it. 
:: def cfecdcdcfbciedbfjcfigadebcddibhd(I):
  return tuple(
      tuple(
        next((v for (v, (pi, pj)) in obj if pj == j and abs(pi - len(I) // 2) <  (height(obj) + 1) // 2), mostcolor(I))
        for j in range(len(I[0])))
      for i in range(len(I)) for obj in objects(I, False, False, True)
  )
 
1661.0, tensor(0.0127), Description: Move each colored shape to the center of the grid vertically, maintaining its original horizontal position. The output grid should have a black background. The shapes should be moved such that the distance between the shape's center and the center of the grid vertically is less than or equal to half the distance between the shape's topmost row and the bottommost row of the grid. If the shape is already in the correct position, do not move it. 
:: def ifcbfbgbjbdfeeehjhcjbccfaecgccaf(I):
  return tuple(
      tuple(
        next((v for (v, (pi, pj)) in obj if pj == j and abs(pi - len(I) // 2) <= height(obj) // 2), 0)
        if any(pj == j for _, (pi, pj) in obj) else I[i][j]
        for j in range(len(I[0])))
      for i in range(len(I)) for obj in objects(I, False, False, True)
  )
 
9.0, tensor(0.0133), Description: Center each of the colored shapes vertically within the grid. The output grid should have a background color that is the most common color in the input grid. The shapes should be moved such that the leftmost column of the shape is aligned with the center column of the grid. 
:: def jeacddcheacgefefaeabgfffghbechba(I):
    objs = objects(I, F, F, T)
    grid = canvas(mostcolor(I), shape(I))
    for obj in objs:
        obj_width = width(obj)
        leftmost_j = leftmost(obj)
        for i in range(height(obj)):
            for j in range(obj_width):
                cell_value = next((v for (v, (pi, pj)) in obj if pi == i and pj == j + leftmost_j), mostcolor(I))
                grid = fill(grid, cell_value, {(len(I) // 2 - height(obj) // 2 + i, leftmost_j + j)})
    return grid
 
9.333333333333334, tensor(0.0154), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def afhdbggghbadefcdaddaaffcebcebiae(I):
  objs = objects(I, F, F, T)
  return paint(
    canvas(0, shape(I)),
    merge(
      apply(
        lambda obj, i=0: shift(normalize(obj), (i * height(obj), width(I) // 2 - width(obj) // 2)),
        objs,
      )
    )
  )
 
10.666666666666666, tensor(0.0147), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, mirror it horizontally and compress it vertically by half. The output grid should have a background color that is the most common color in the input grid. 
:: def facgabichibgeachbdjdeceaihbbddde(grid):
    output = canvas(mostcolor(grid), shape(grid))  # Create empty canvas
    for obj in fgpartition(grid):  # Iterate over objects (without background)
      mirrored_obj = hmirror(obj)  # Mirror each object horizontally
      top = uppermost(mirrored_obj)  # Find top row of mirrored object
      bottom = lowermost(mirrored_obj)  # Find bottom row of mirrored object
      height = bottom - top + 1  # Calculate object height
      new_top = top + height // 2  # Calculate new top row after compression
      output = underpaint(output, shift(mirrored_obj, (new_top - top, 0)))  # Paint the compressed object onto the canvas
    return output 
 
12.666666666666666, tensor(0.0147), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, mirror it horizontally and compress it vertically by half. The output grid should have a background color that is the most common color in the input grid. 
:: def jbebhaaihbbeefhdifigeacgbcebdafc(grid):
  output = canvas(mostcolor(grid), shape(grid)) # Create empty canvas
  for obj in objects(grid, False, True, True): # Iterate through objects
    mirrored_obj = hmirror(obj) # Mirror each object
    center_row = centerofmass(mirrored_obj)[0] # Find the row index of the center of mass
    output = underpaint(output, shift(mirrored_obj, (center_row - uppermost(mirrored_obj), 0))) # Shift and paint object based on center of mass
  return output
 
10.333333333333334, tensor(0.0145), Description: Center each of the colored shapes horizontally within the grid. Then, for each shape, mirror it horizontally and compress it vertically by half. The output grid should have a background color that is the most common color in the input grid. 
:: def edbffjcbbhhbefiiajbacdfgggeaacha(grid):
    output = canvas(mostcolor(grid), (height(grid), width(grid)))
    for obj in fgpartition(grid):
        obj_height = height(obj)
        output = paint(output, shift(hmirror(obj), (obj_height // 2, 0)))
    return output
 
31.333333333333332, tensor(1.9822), Description: Mirror the input grid horizontally. Then, remove the rightmost half of the columns, keeping only the leftmost half. The output grid should have the same background color as the input grid. 
:: def ajfgjbaahgbeeibhjaabbfcjigegajae(grid):
    return tuple(
        tuple(
            v for j, v in enumerate(hmirror(row)) if j < len(row) // 2 or j >= len(row) - len(row) // 2
        ) for row in grid
    )
 
18.0, tensor(0.0102), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def hcdbejcbahafededifbibajjdedeeaeb(I):
  O = canvas(mostcolor(I), shape(I)) # Create empty canvas
  for obj in objects(I, False, False, True): # Loop over foreground objects
    O = paint(O, shift(obj, (0, len(I[0]) // 2 - centerofmass(obj)[1]))) # Center horizontally
    O = paint(O, shift(obj, (-uppermost(obj), 0))) # Move to top
  return O
 
17.666666666666668, tensor(0.0102), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def bedbffhabbdfebdajabacjfbaefdafbb(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I) - {mostcolor(I)}:
    obj = frozenset((v, (i, j)) for i, r in enumerate(I) for j, c in enumerate(r) if c == v)
    O = paint(O, shift(obj, subtract((0, centerofmass(obj)[1]), (0, ulcorner(obj)[1]))))
    O = paint(O, shift(obj, (-uppermost(obj), 0)))
  return O
 
9.333333333333334, tensor(0.0084), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. The output grid should have the same background color as the input grid. 
:: def cgdifgaidfhhecbgjhebhbfdabdgfcdf(I):
  O = I
  for obj in objects(I, False, False, True):
    O = cover(O, obj)
    centered_obj = shift(obj, (0, len(I[0]) // 2 - centerofmass(obj)[1]))
    O = paint(O, shift(centered_obj, (-uppermost(centered_obj), 0)))
  return O
 
13.333333333333334, tensor(0.0102), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def ajcadcffjdgbeefhachcejeiccgdhgaa(I):
  O = I
  for v in palette(I) - {mostcolor(I)}:
    obj = frozenset((v, (i, j)) for i, r in enumerate(I) for j, c in enumerate(r) if c == v)
    O = paint(cover(O, obj), shift(obj, (-uppermost(obj), len(I[0]) // 2 - centerofmass(obj)[1])))
  return O
 
9.333333333333334, tensor(0.0094), Description: Move each colored shape to the top of the grid, maintaining its original horizontal position. The shapes should be placed side-by-side, with no gaps between them. The output grid should have a black background and be the same size as the input grid. 
:: def eddaaddgefceebgbbhefiedacgabjgea(I):
  objs = objects(I, False, False, True)
  O = canvas(0, (height(I), width(I)))
  current_j = 0
  for obj in objs:
    O = paint(O, shift(normalize(obj), (-uppermost(obj), current_j)))
    current_j += width(obj)
  return O
 
16.666666666666668, tensor(0.0094), Description: Move each colored shape to the top of the grid, maintaining its original horizontal position. The shapes should be placed side-by-side, with no gaps between them. The output grid should have a black background and be the same size as the input grid. 
:: def hgdaahdccejgecddjcfdaefjcifdiaei(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  j = 0
  for obj in objs:
    O = paint(O, shift(obj, (-uppermost(obj), -leftmost(obj) + j)))
    j += width(obj)
  return O
 
209.66666666666666, tensor(0.1711), Description: Move each column of colored squares to the top of the grid, maintaining their vertical positions. The output grid should have a black background and be compressed to remove any empty rows or columns. 
:: def edcfbcafbdbdeecjjajffeffcgcfabfb(I):
  O = I
  for j in range(width(I)):
    if any(I[i][j] != mostcolor(I) for i in range(height(I))):
      column = frozenset((I[i][j], (i, j)) for i in range(height(I)))
      O = cover(O, column)
      O = paint(O, shift(column, (-uppermost(column), 0)))
  return compress(O)
 
40.333333333333336, tensor(0.0167), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def dddebaeiehdaeafcjgcjciacdgjbfcec(I):
  objs = order(objects(I, F, F, T), uppermost)
  h, w = shape(I)
  canvas_height = sum(height(obj) + 1 for obj in objs) - 1  # Total height needed
  O = canvas(0, (canvas_height, w))
  current_bottom = canvas_height 
  for obj in objs:
    obj_height = height(obj)
    offset = (current_bottom - obj_height, (w - width(obj)) // 2)
    O = paint(O, shift(obj, offset))
    current_bottom -= obj_height + 1
  return O
 
40.0, tensor(0.0167), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def fhagebegehddeihfafjbjfebbadbajbj(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  canvas_height = sum(height(obj) + 1 for obj in objs) - 1
  O = canvas(0, (canvas_height, w))
  return paint(
      O, 
      merge(
        apply(
          lambda obj: shift(
              obj, 
              (canvas_height - uppermost(obj) - height(obj), (w - width(obj)) // 2)
          ),
          objs
        )
      )
    )
 
1769.3333333333333, tensor(0.0172), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the input grid. 
:: def dhfdcjjffbbfebdjibbdfcjbdcehface(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  canvas_height = h * len(objs) + len(objs) - 1 
  O = canvas(0, (canvas_height, w))
  for i, obj in enumerate(order(objs, uppermost)):
    offset = (i * (h + 1), (w - width(obj)) // 2)
    O = paint(O, shift(obj, offset))
  return O
 
14.666666666666666, tensor(0.0554), Description: Center each of the colored shapes vertically within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def ddjaadefaiieejbdafddbfiagcfcajga(I):
    """
    Iterates through each column, identifies non-zero objects, 
    calculates the vertical offset for centering, and paints 
    the objects onto a blank canvas with the calculated offset.
    """
    h, w = height(I), width(I)
    O = canvas(0, (h, w))
    for j in range(w):
        column = {(I[i][j], (i, j)) for i in range(h) if I[i][j] != 0}
        if column:
            center_i = centerofmass(column)[0]
            offset = h // 2 - center_i
            O = paint(O, shift(column, (offset, 0))) 
    return O
 
13.0, tensor(0.0554), Description: Center each of the colored shapes vertically within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def bbdcihddccfaeabeiddaffgfjcbceejg(I):
    """
    Utilizes the `objects` function to identify individual 
    objects and centers them vertically using `shift` and `paint`.
    """
    h = height(I)
    O = canvas(0, shape(I))
    for obj in objects(I, False, False, True):
        center_i = centerofmass(obj)[0]
        offset = h // 2 - center_i
        O = paint(O, shift(obj, (offset, 0)))
    return O
 
13.0, tensor(0.0554), Description: Center each of the colored shapes vertically within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def aghdahgieafbeecfbeaecdagdfhecfbb(I):
    """
    Uses `apply` to apply a centering function to each 
    object identified by `objects`, then merges and paints them. 
    """
    h = height(I)
    return paint(
        canvas(0, shape(I)),
        merge(
            apply(
                lambda obj: shift(obj, (h // 2 - centerofmass(obj)[0], 0)),
                objects(I, False, False, True)
            )
        )
    )
 
21.0, tensor(0.0148), Description: Center each of the colored shapes vertically within the grid. Then, for each shape, add a square of the same color one column to the left and one column to the right of the shape. The output grid should have the same background color as the input grid. 
:: def fegfjicedhhbebhhiaafhhiceddcbiec(grid):
  def expand_and_center(obj):
    c = color(obj)
    return frozenset({(c, (i + (len(grid) - 1) // 2 - uppermost(obj), j - 1)) for c, (i, j) in obj} | 
                    {(c, (i + (len(grid) - 1) // 2 - uppermost(obj), j)) for c, (i, j) in obj} | 
                    {(c, (i + (len(grid) - 1) // 2 - uppermost(obj), j + 1)) for c, (i, j) in obj})
  return paint(canvas(0, shape(grid)), merge(apply(expand_and_center, fgpartition(grid))))
 
16.666666666666668, tensor(0.0151), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a background color that is the most common color in the input grid and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. 
:: def ffeefghbjajbeegcbfbfbdhidegaccbb(I):
  O = canvas(mostcolor(I), shape(I))
  objects_sorted = order(objects(I, False, False, True), lambda obj: uppermost(obj))
  current_height = 0
  for obj in objects_sorted:
    O = paint(O, shift(obj, (current_height - uppermost(obj), len(I[0]) // 2 - centerofmass(obj)[1])))
    current_height += height(obj)
  return O
 
9.333333333333334, tensor(0.0102), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. The output grid should have a background color that is the most common color in the input grid. 
:: def bcebbcadgdceecfbiddefecddeddicch(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != mostcolor(I):
        obj = extract(objects(I, False, False, True), lambda obj: (i, j) in toindices(obj))
        O = paint(O, shift(obj, (-uppermost(obj), len(I[0]) // 2 - centerofmass(obj)[1])))
  return O
 
225.0, tensor(0.0910), Description: Move each colored shape to the top left corner of the grid, maintaining its original orientation. The output grid should have a background color that is the most common color in the input grid and be compressed to remove any empty rows or columns. 
:: def jehcdbefjaccehdcbaefdcgiihbfehdd(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, True):
    O = paint(O, shift(obj, (-uppermost(obj), -leftmost(obj))))
  return compress(O)
 
225.0, tensor(0.0995), Description: Move each column of colored squares to the top left corner of the grid, maintaining their vertical positions. The output grid should have a background color that is the most common color in the input grid and be compressed to remove any empty rows or columns. 
:: def ibcgiaachabeedjfbdbjcfihhedacbfa(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    column = frozenset((I[i][j], (i, j)) for i in range(height(I)))
    if any(v != mostcolor(I) for v, _ in column):
      O = paint(O, shift(column, (-uppermost(column), -leftmost(column))))
  return compress(O)
 
1770.6666666666667, tensor(0.0172), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the input grid. 
:: def bidcaejacijfehdajdacaffdafadchic(I):
  def place_object(obj, top_left, grid_width):
    obj_width = width(obj)
    horizontal_offset = (grid_width - obj_width) // 2
    return shift(obj, (top_left[0], top_left[1] + horizontal_offset))

  objs = sorted(objects(I, F, F, T), key=uppermost)
  h, w = shape(I)
  top_left = (0, 0)
  output_grid = canvas(0, (h * len(objs) + len(objs) - 1, w))
  for i, obj in enumerate(objs):
    output_grid = paint(output_grid, place_object(obj, top_left, w))
    top_left = (top_left[0] + height(obj) + 1, 0)
  return output_grid
 
106.33333333333333, tensor(0.0111), Description: Center each of the colored shapes vertically within the grid. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the center of the shape is aligned with the center of the grid vertically. 
:: def hihhdbjabfacecfcafcbefadgeccacif(I):
  """
  Constructs output grid directly by calculating cell positions based on object centering.
  """
  h, w = height(I), width(I)
  return tuple(
      tuple(
          I[k][j] 
          if 0 <= i - (h // 2 - centerofmass(frozenset((I[k][j], (k, j)) for k in range(h) if I[k][j] != 0))[0]) < h 
             and I[k][j] != 0 and i == (h // 2 - centerofmass(frozenset((I[k][j], (k, j)) for k in range(h) if I[k][j] != 0))[0]) 
          else 0
          for i in range(h)
      )
      for j in range(w)
      for k in range(h) if I[k][j] != 0
  )
 
28.0, tensor(0.0149), Description: Center each of the colored shapes horizontally within the grid. Then, for each shape, add a square of the same color one column to the left and one column to the right of the shape. The output grid should have the same background color as the input grid. 
:: def giahceghffdcefaijhjfdbgeecffcfec(grid):
  def process_object(obj):
    c = color(obj)
    w = width(grid)
    shifted_obj = shift(obj, (0, (w - width(obj)) // 2 - leftmost(obj)))
    return frozenset({(c, (i, j - 1)) for c, (i, j) in shifted_obj} |
                   {(c, (i, j)) for c, (i, j) in shifted_obj} |
                   {(c, (i, j + 1)) for c, (i, j) in shifted_obj})
  return paint(canvas(0, shape(grid)), merge(apply(process_object, fgpartition(grid))))
 
167.66666666666666, tensor(0.0122), Description: For each colored shape in the input grid, expand it horizontally by one square on each side. The output grid should have the same background color as the input grid. 
:: def icdiajfebeefeiedbdaadegbdfdeeaaa(grid):
  def expand_horizontal(obj):
    return recolor(color(obj), frozenset((i, j) for i in range(uppermost(obj), lowermost(obj) + 1) 
                                        for j in range(leftmost(obj) - 1, rightmost(obj) + 2)))
  return paint(canvas(0, shape(grid)), merge(apply(expand_horizontal, fgpartition(grid))))
 
25.0, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def ehbebedcjjgbececaiaaaibcchbhacig(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  O = canvas(0, shape(I))
  for i, obj in enumerate(objs):
    offset = (i * height(obj) + (height(I) - sum(height(obj) for obj in objs)) // 2, width(I) // 2 - width(obj) // 2)
    obj_indices = toindices(obj)
    top_row = min(i for i, j in obj_indices)
    modified_obj = frozenset({(1 if i == top_row + 1 else 2 if i > top_row + 1 else v, (i, j)) for v, (i, j) in obj})
    O = paint(O, shift(modified_obj, offset))
  return O
 
101.33333333333333, tensor(0.1369), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", and all subsequent rows with the digit "2". 
:: def bcgifcfjdhbiejbhjedafdbebeccfcbe(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  canvas_height = sum(height(obj) for obj in objs)
  O = canvas(0, (canvas_height, w))
  current_height = (canvas_height - sum(height(obj) for obj in objs)) // 2
  for obj in sorted(objs, key=lambda obj: uppermost(obj)):
    obj_height = height(obj)
    offset = (current_height, (w - width(obj)) // 2)
    top_indices = {idx for v, idx in obj if idx[0] == uppermost(obj)}
    O = paint(O, shift(recolor(1, toindices(obj)-top_indices), offset))
    O = paint(O, shift(recolor(2, top_indices), offset))
    current_height += obj_height
  return O 
 
100.33333333333333, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def cjbecicidacdecgbabbdajhfidihaeba(I):
  objs = objects(I, F, F, T)
  output_height = sum(height(obj) for obj in objs)
  O = canvas(0, (output_height, width(I)))
  y_offset = (height(I) - output_height) // 2
  for i, obj in enumerate(sorted(objs, key=lambda obj: uppermost(obj))):
    x_offset = (width(I) - width(obj)) // 2
    obj = shift(obj, (y_offset + i * height(obj), x_offset))
    top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
    second_row = {(v, (i + 1, j)) for v, (i, j) in top_row if (i + 1, j) in toindices(obj)}
    O = paint(O, recolor(1, toindices(second_row)))
    O = paint(O, recolor(2, toindices(obj) - toindices(top_row) - toindices(second_row)))
    O = paint(O, top_row)
  return O
 
105.66666666666667, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def fjadcdcjfdddeceajiedfafgeiehfede(I):
  objs = objects(I, F, F, T)
  obj_heights = [height(obj) for obj in objs]
  total_height = sum(obj_heights)
  output = canvas(0, (total_height, width(I)))
  y_offset = (height(I) - total_height) // 2
  current_y = y_offset
  for obj in sorted(objs, key=lambda obj: uppermost(obj)):
    x_offset = (width(I) - width(obj)) // 2
    for v, (i, j) in obj:
      new_i = current_y + i - uppermost(obj)
      new_j = x_offset + j - leftmost(obj)
      color = v if new_i == current_y else 1 if new_i == current_y + 1 else 2
      output = paint(output, {(color, (new_i, new_j))})
    current_y += obj_heights.pop(0)
  return output
 
105.66666666666667, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def caidbchbbegheaddbdhccdjfbedecdjc(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  output_height = sum(height(obj) for obj in objs)
  O = canvas(0, (output_height, width(I)))
  current_y = (height(I) - output_height) // 2
  for obj in objs:
    x_offset = (width(I) - width(obj)) // 2
    shifted_obj = shift(obj, (current_y - uppermost(obj), x_offset))
    for i in range(height(obj)):
      for j in range(width(obj)):
        color = 1 if i == 1 else 2 if i > 1 else index(I, (uppermost(obj) + i, leftmost(obj) + j))
        O = paint(O, {(color, (current_y + i, x_offset + j))})
    current_y += height(obj)
  return O
 
26.0, tensor(0.1311), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to 1. The shapes should be sorted by their bottommost row, with the shape with the lowest bottom row being placed first. 
:: def cgibeeaafhaheefaihijfadaedcbdjbe(I):
  """
  Identifies and stacks objects based on their bottom-most row.
  """
  objs = objects(I, False, False, True)
  grid = canvas(0, shape(I))
  objs = order(objs, lambda obj: -lowermost(obj))
  offset = (0, 0)
  for obj in objs:
    obj_width = width(obj)
    offset = (offset[0] + 1, (width(grid) - obj_width) // 2)
    grid = underpaint(grid, shift(obj, offset)) 
  return grid
 
26.0, tensor(0.1311), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to 1. The shapes should be sorted by their bottommost row, with the shape with the lowest bottom row being placed first. 
:: def ihffhgccggfeeahiahcehijacbehhbfd(I):
  """
  Uses a recursive approach to stack objects.
  """
  def stack_objects(objs, grid, offset=(0, 0)):
    if not objs:
      return grid
    obj = argmax(objs, lambda obj: lowermost(obj)) 
    obj_width = width(obj)
    offset = (offset[0] + 1, (width(grid) - obj_width) // 2)
    grid = underpaint(grid, shift(obj, offset))
    return stack_objects(objs - {obj}, grid, offset) 
  return stack_objects(objects(I, False, False, True), canvas(0, shape(I)))
 
23.333333333333332, tensor(0.0089), Description: Move each colored shape to the bottom of the grid, maintaining its original horizontal position. The shapes should be placed such that the bottom row of each shape is aligned with the bottom row of the grid. The output grid should have a black background and be the same size as the input grid. 
:: def aiejigfahcfhebdfageadbefbdgdhefc(I):
  """
  Iterates through rows and places objects based on their horizontal center.
  """
  objs = objects(I, False, False, True)
  grid = canvas(0, shape(I))
  for i in range(height(I) - 1, -1, -1):
    row_objs = sfilter(objs, lambda obj: uppermost(obj) == i)
    for obj in row_objs:
      obj_width = width(obj)
      offset = (height(grid) - i, (width(grid) - obj_width) // 2)
      grid = underpaint(grid, shift(obj, offset))
  return grid
 
27.0, tensor(0.1311), Description: Stack the colored shapes vertically, starting from the bottom of the grid. Each shape should be placed directly above the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to 1. The shapes should be sorted by their bottommost row, with the shape with the lowest bottom row being placed first. 
:: def edgchiegeechecicibecejaaahgdacaj(I):
  """
  Constructs the output grid by directly calculating cell values.
  """
  h, w = height(I), width(I)
  return tuple(
      tuple(
          sum(color(obj) for obj in objects(I, False, False, True) if i == h - uppermost(obj) - 1 and j in range(leftmost(obj) + (w - width(obj)) // 2, leftmost(obj) + (w - width(obj)) // 2 + width(obj)))
          for j in range(w)
      )
      for i in range(h)
  )
 
24.666666666666668, tensor(0.0082), Description: Move each colored shape towards the bottom center of the grid, maintaining its original orientation. The output grid should have a black background and be the same size as the input grid. 
:: def ddeigcdjhedeeeaejadhacfefedhifdc(I):
  """
  Utilizes the 'gravitate' function for object placement.
  """
  objs = objects(I, False, False, True)
  grid = canvas(0, shape(I))
  bottom_center = (height(grid) - 1, width(grid) // 2)
  for obj in objs:
    offset = gravitate(obj, {bottom_center})
    grid = underpaint(grid, shift(obj, offset))
  return grid
 
29.0, tensor(0.0114), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one row and one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Move the digit "3" to the bottom row of the grid, maintaining its original horizontal position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def ccbbdaceddeieejiihcfbcaibbeebbdf(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  new_objs = []
  for obj in objs:
    v, (i, j) = first(obj)
    if v == 1:
      new_objs.append(shift(obj, (-i + h // 2, -j + w // 2)))
    elif v == 2:
      target_3 = extract(objs, lambda o: color(o) == 3 and hmatching(o, obj) and vmatching(o, obj))
      if target_3:
        new_objs.append(shift(obj, add(position(target_3, obj), (1, 1))))
      else:
        new_objs.append(obj)
    elif v == 3:
      new_objs.append(shift(obj, (h - 1 - i, 0)))
    else:
      new_objs.append(obj)
  return paint(canvas(0, shape(grid)), merge(new_objs))
 
31.0, tensor(0.0106), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def adbabjciiaaaecfebbcagjeajjcbdfca(grid):
  h, w = shape(grid)
  def new_pos(obj):
    v, (i, j) = first(obj)
    return (h // 2 if v == 1 else i, 
            w // 2 if v == 1 else (
                j + 1 if v == 2 and any(color(o) == 3 and hmatching(o, obj) and vmatching(o, obj) for o in fgpartition(grid)) else j))
  return paint(canvas(0, (h, w)), 
               merge(frozenset(frozenset((c, new_pos(frozenset({(c, (i, j))}))) for c, (i, j) in obj) for obj in fgpartition(grid))))
 
29.666666666666668, tensor(0.0124), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column of the input grid is in the first column of the output grid, the shape in the second column of the input grid is in the second column of the output grid, and so on. The shapes should be moved diagonally, with the shape in the first column being moved to the leftmost position in the bottom row, the shape in the second column being moved one position to the right, and so on. 
:: def dhifdhabaghbefjdjgjecijhcgefccec(I):
  O = canvas(0, shape(I))
  digits = sorted(((I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != 0), key=lambda x: x[1][0])
  h = 0
  for v, (i, j) in digits:
    O = paint(O, {(v, (h, len(I[0]) // 2 - j + i))})
    h += 1
  return O
 
23.666666666666668, tensor(0.0116), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the bottom row, the shape in the second column is moved one position to the right, and so on. The shapes should be sorted by their topmost row, then by their color in descending order. 
:: def edfgdacfhebdeccaifiaaigafiefhhbi(I):
  cells = ((I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])))
  return paint(canvas(0, shape(I)), {(v, (k, len(I[0]) // 2 - j + i)) for k, (v, (i, j)) in enumerate(sorted(cells, key=lambda x: (x[1][0], -x[0]))) if v != 0})
 
26.666666666666668, tensor(0.0072), Description: Move the shape with color 7 to the center of the grid horizontally, maintaining its original vertical position. Then, move all other shapes to the bottom of the grid, maintaining their original horizontal positions. The shapes should be moved such that the bottom row of each shape is aligned with the bottom row of the grid. The output grid should have a black background and be the same size as the input grid. 
:: def gifffjfhhbfaehddibebafjffjeacccc(grid):
  def transform_object(obj, line_center_x):
    if color(obj) == 1:
      return shift(obj, subtract((uppermost(line_obj) + height(line_obj) // 2 - height(obj) // 2, line_center_x), ulcorner(obj)))
    else:
      return shift(obj, (0 - lowermost(obj), line_center_x - leftmost(obj)))
  
  line_c = 7
  line_obj = extract(fgpartition(grid), lambda obj: color(obj) == line_c)
  line_center_x = (len(grid[0]) - width(line_obj)) // 2
  shifted_line = shift(line_obj, (0, line_center_x - leftmost(line_obj)))

  return paint(
      canvas(0, shape(grid)),
      merge(
        (shifted_line,) + 
        tuple(transform_object(obj, line_center_x) for obj in remove(line_obj, fgpartition(grid))) 
      )
  )
 
25.333333333333332, tensor(0.0116), Description: Move the largest shape containing the most common color to the center of the grid, both horizontally and vertically. Then, move all other shapes to the top of the grid if they are above the main shape, or to the bottom of the grid if they are below the main shape, maintaining their original horizontal positions. The output grid should have a background color that is the most common color in the input grid. 
:: def jcabhddfebadefgejdbbigjjaeifbaah(I):
  objs = objects(I, True, False, True) # Identify objects
  bg = mostcolor(I)
  grid = canvas(bg, shape(I)) # Create output grid
  most_common_color = mostcolor(I) # Find most common color
  main_obj = argmax(objs, lambda obj: colorcount(obj, most_common_color)) # Find the object with the most common color
  other_objs = objs - {main_obj}
  main_obj_width = width(main_obj)
  offset = ((height(grid) - height(main_obj)) // 2, (width(grid) - main_obj_width) // 2) # Calculate offset for center alignment
  grid = underpaint(grid, shift(main_obj, offset)) # Place the main object
  for obj in other_objs:
    if uppermost(obj) < uppermost(main_obj):
      new_offset = (uppermost(main_obj) - height(obj) - 1, (width(grid) - width(obj)) // 2)
    else:
      new_offset = (lowermost(main_obj) + 1, (width(grid) - width(obj)) // 2)
    grid = underpaint(grid, shift(obj, new_offset)) # Place other objects
  return grid
 
26.666666666666668, tensor(0.0099), Description: Move the largest shape containing the most common color to the center of the grid, both horizontally and vertically. Then, move all other shapes to the top of the grid, directly above the main shape, maintaining their original horizontal positions. The output grid should have a background color that is the most common color in the input grid. 
:: def adfbgceebabiefadiidieaddaecajebi(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  grid = canvas(bg, shape(I))
  target_color = mostcolor(I)
  main_obj = argmax(objs, lambda obj: colorcount(obj, target_color))
  other_objs = order(objs - {main_obj}, lambda obj: uppermost(obj))
  grid = paint(grid, shift(main_obj, ((height(grid) - height(main_obj)) // 2, (width(grid) - width(main_obj)) // 2)))
  current_height = uppermost(main_obj) - 1
  for obj in other_objs:
    obj_width = width(obj)
    grid = paint(grid, shift(obj, (current_height - height(obj) + 1, (width(grid) - obj_width) // 2)))
    current_height -= height(obj) 
  return grid
 
29.666666666666668, tensor(0.0111), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Move the digit "3" to the bottom row of the grid, maintaining its original horizontal position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def aaabefgaceeiehaejfcgijbegfhcfbca(grid):
  h, w = shape(grid)
  def transform(obj):
    v, (i, j) = first(obj)
    return shift(obj, {
      1: (-i + h // 2, -j + w // 2),
      2: (0, 1) if any(color(o) == 3 and hmatching(o, obj) and vmatching(o, obj) for o in fgpartition(grid)) else (0, 0),
      3: (h - 1 - i, 0),
    }.get(v, (0, 0)))
  return paint(canvas(0, (h, w)), merge(apply(transform, fgpartition(grid))))
 
26.0, tensor(0.0111), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Move the digit "3" to the bottom row of the grid, maintaining its original horizontal position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def fbbacibehaadeedibfdgdeciafcciiij(grid):
  h, w = shape(grid)
  return paint(
    canvas(0, (h, w)), 
    merge(apply(lambda obj: shift(obj, (
      -first(obj)[1][0] + h // 2 if first(obj)[0] == 1 else h - 1 - first(obj)[1][0] if first(obj)[0] == 3 else 0,
      -first(obj)[1][1] + w // 2 if first(obj)[0] == 1 else first(obj)[1][1] + 1 if any(color(o) == 3 and hmatching(o, obj) and vmatching(o, obj) for o in fgpartition(grid)) else first(obj)[1][1]
    )), fgpartition(grid)))
  )
 
32.0, tensor(0.0106), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column is moved to the center of the bottom row, the shape in the second column is moved one position to the right, and so on. 
:: def cefijcdibfcaeagebbeibdeiefbcbgfb(I):
  O = canvas(0, shape(I))
  digits = [(I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != 0]
  h = 0
  for v, _ in digits:
    O = paint(O, {(v, (h, len(I[0]) // 2))})
    h += 1
  return O
 
108.33333333333333, tensor(0.0106), Description: Move all the colored shapes to the bottom row of the grid, maintaining their relative horizontal positions. The output grid should have a black background. The shapes should be moved such that the shape in the first column is moved to the center of the bottom row, the shape in the second column is moved one position to the right, and so on. 
:: def fcddeaieicjeeehejhhcefhaaaacbbgj(I):
  O = canvas(0, (sum(1 for r in I for v in r if v != 0), len(I[0])))
  h = 0
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, {(v, (h, len(I[0]) // 2))})
        h += 1
  return O
 
103.66666666666667, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def gdbefaeageiaeijhaabecaafheabfgib(I):
  objs = objects(I, F, F, T)  # Isolate objects
  output_height = sum(height(obj) for obj in objs) # Calculate output height
  O = canvas(0, (output_height, width(I))) # Create output canvas
  current_y = 0
  for obj in sorted(objs, key=lambda obj: uppermost(obj)): # For each object, sorted by uppermost row
    x_offset = (width(I) - width(obj)) // 2 # Calculate horizontal offset
    for v, (i, j) in obj:
      color = v if i == uppermost(obj) else 1 if i == uppermost(obj) + 1 else 2
      O = paint(O, {(color, (current_y + i - uppermost(obj), x_offset + j))})
    current_y += height(obj)
  return O
 
101.33333333333333, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def fdifaddddaffeccgbfeacddfedgfceca(I):
  objs = objects(I, F, F, T)
  output_height = sum(height(obj) for obj in objs)
  O = canvas(0, (output_height, width(I)))
  current_y = 0
  for obj in sorted(objs, key=lambda obj: uppermost(obj)):
    x_offset = (width(I) - width(obj)) // 2
    top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
    second_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj) + 1}
    other_rows = obj - top_row - second_row
    O = paint(O, shift(recolor(2, other_rows), (current_y, x_offset)))
    O = paint(O, shift(recolor(1, second_row), (current_y, x_offset)))
    O = paint(O, shift(top_row, (current_y, x_offset)))
    current_y += height(obj)
  return O
 
104.0, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def heahcegjfdgaefcbbefedhabdcfifaaj(I):
  objs = objects(I, F, F, T)
  O = canvas(0, (sum(height(obj) for obj in objs), width(I)))
  y = 0
  for obj in sorted(objs, key=uppermost): 
    O = paint(O, shift(recolor(2, obj), (y - uppermost(obj), (width(I) - width(obj)) // 2)))
    O = paint(O, shift(recolor(1, {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj) + 1}), (y - uppermost(obj), (width(I) - width(obj)) // 2)))
    O = paint(O, shift({(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}, (y, (width(I) - width(obj)) // 2)))
    y += height(obj)
  return O
 
108.33333333333333, tensor(0.1819), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, centered horizontally. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def eieacegehcjiefjdiiaaajjbfhbcadcc(I):
  objs = objects(I, F, F, T)
  output_height = sum(map(height, objs))
  O = canvas(0, (output_height, width(I)))
  y = 0
  for obj in sorted(objs, key=lambda o: uppermost(o)):
    x = (width(I) - width(obj)) // 2
    for i in range(height(obj)):
      for j in range(width(obj)):
        cell_color = index(I, (uppermost(obj) + i, leftmost(obj) + j))
        new_color = branch(i == 0, cell_color, branch(i == 1, 1, 2)) 
        O = paint(O, {(new_color, (y + i, x + j))})
    y += height(obj)
  return O
 
25.666666666666668, tensor(0.0230), Description: Center each of the colored shapes both horizontally and vertically within the grid. If the shape's color is 3, move it two rows up. The output grid should have a background color that is the most common color in the input grid. 
:: def jgbhjdhcffcbebdfjdhajdaacaeciiah(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  out = canvas(bg, shape(I))
  t = lambda obj: (
    (height(out) - height(obj)) // 2 - 2 * (color(obj) == 3),
    (width(out) - width(obj)) // 2
  )
  return paint(out, merge(apply(lambda obj: shift(obj, t(obj)), objs)))
 
33.0, tensor(0.0111), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Move the digit "3" to the bottom row of the grid, maintaining its original horizontal position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def fjdccdbhagidedfbbebciidhdgaccadf(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  return paint(canvas(0, (h, w)), merge(
    apply(lambda obj: shift(obj, (h // 2 - uppermost(obj) - height(obj) // 2, w // 2 - leftmost(obj) - width(obj) // 2)) 
                      if color(obj) == 1 else obj, objs) |
    apply(lambda obj: shift(obj, (h - 1 - uppermost(obj), 0)) 
                      if color(obj) == 3 else obj, objs) |
    {shift(obj, (0, 1)) 
      for obj in objs if color(obj) == 2 and any(color(o) == 3 and hmatching(o, obj) and vmatching(o, obj) for o in objs)}
  ))
 
29.666666666666668, tensor(0.0111), Description: Move the digit "1" to the center of the grid both horizontally and vertically. Move the digit "2" one column to the right of the digit "3" if the digit "3" is in the same row and column as the digit "2". Otherwise, leave the digit "2" in its original position. Move the digit "3" to the bottom row of the grid, maintaining its original horizontal position. Leave all other digits in their original positions. The output grid should have a black background. 
:: def dbcbfdadhageegifjfjdbdaebdhgcddb(grid):
  h, w = shape(grid)
  return paint(canvas(0, (h, w)), merge(
    {shift(obj, (h // 2 - uppermost(obj) - height(obj) // 2, w // 2 - leftmost(obj) - width(obj) // 2)) for obj in fgpartition(grid) if color(obj) == 1} |
    {shift(obj, (h - 1 - uppermost(obj), 0)) for obj in fgpartition(grid) if color(obj) == 3} |
    {shift(obj, (0, 1)) for obj in fgpartition(grid) if color(obj) == 2 and any(color(o) == 3 and hmatching(o, obj) and vmatching(o, obj) for o in fgpartition(grid))} |
    {obj for obj in fgpartition(grid) if color(obj) not in {1, 2, 3}}
  ))
 
30.0, tensor(0.0111), Description: Move all the colored shapes to the middle row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the middle row, the shape in the second column is moved one position to the right, and so on. 
:: def jbjghaeiicijedbfjegdcbdjfaccageg(I):
  O = canvas(0, shape(I))  # Create output grid with same shape as input
  h = height(I) // 2 - 1 # Calculate starting height for placement
  k = 0  # Counter for non-zero elements
  for j in range(len(I[0])):  # Iterate through columns
    for i in range(len(I)):  # Iterate through rows within each column
      if I[i][j] != 0: 
        O = paint(O, {(I[i][j], (h + k, j))}) # Place non-zero element at calculated position
        k += 1
  return O
 
30.666666666666668, tensor(0.0111), Description: Move all the colored shapes to the middle row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the middle row, the shape in the second column is moved one position to the right, and so on. 
:: def hffbccdffcggecjciggafefaaijgedbe(I):
  nz = [(I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != 0] # Extract non-zero cells
  return paint(canvas(0, shape(I)), {(v, (k + len(I) // 2 - len(nz) // 2, j)) for k, (v, (i, j)) in enumerate(nz)}) # Paint on canvas
 
30.333333333333332, tensor(0.0111), Description: Move all the colored shapes to the middle row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the middle row, the shape in the second column is moved one position to the right, and so on. 
:: def acjdefafbfaeebiaigjbbibfebbaggbe(I):
  objs = objects(I, False, False, True)  # Extract objects from the grid
  return paint(canvas(0, shape(I)), {(color(obj), (k + len(I) // 2 - len(objs) // 2, centerofmass(obj)[1])) for k, obj in enumerate(objs)}) # Paint objects
 
28.666666666666668, tensor(0.0111), Description: Move all the colored shapes to the middle row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the middle row, the shape in the second column is moved one position to the right, and so on. 
:: def ficdgacedfjhedfbbfdehdgeghcjhhhc(I):
  O = canvas(0, shape(I)) # Create canvas
  nonzero_cols = [j for j in range(len(I[0])) if any(I[i][j] != 0 for i in range(len(I)))] # Find non-zero columns
  k = 0 # Counter
  for col in nonzero_cols: # Iterate through non-zero columns
    for i in range(len(I)): # Iterate through rows
      if I[i][col] != 0:
        O = paint(O, {(I[i][col], (len(I) // 2 + k - len(nonzero_cols) // 2, col))})  # Paint non-zero elements
        k += 1
  return O
 
31.0, tensor(0.0111), Description: Move all the colored shapes to the middle row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the leftmost position in the middle row, the shape in the second column is moved one position to the right, and so on. 
:: def jdagjedfggcaedbajacabdhdbeabcdda(I):
  O = canvas(0, shape(I)) # Create canvas
  for j in range(len(I[0])): # Iterate through columns
    col_vals = [I[i][j] for i in range(len(I)) if I[i][j] != 0] # Extract non-zero values from column
    start_row = len(I) // 2 - len(col_vals) // 2 # Calculate starting row for placement
    for k, val in enumerate(col_vals):
      O = paint(O, {(val, (start_row + k, j))}) # Place the non-zero values vertically
  return O
 
26.0, tensor(0.2364), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def egijcaedcgehecbdigfdeaacdabeageh(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  O = canvas(0, (height(I), width(I)))
  for i, obj in enumerate(objs):
    offset = (uppermost(objs[0]) + sum(height(o) for o in objs[:i]), leftmost(obj))
    obj_indices = toindices(obj)
    top_row = uppermost(obj)
    modified_obj = frozenset({(1 if i == top_row + 1 else 2 if i > top_row + 1 and i != top_row else v, (i, j)) for v, (i, j) in obj})
    O = paint(O, shift(modified_obj, offset))
  return O
 
105.33333333333333, tensor(0.2364), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def ibehgeigcadaebabiacceidddddfgbde(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  O = canvas(0, (sum(height(obj) for obj in objs), width(I)))
  current_y = 0
  for i, obj in enumerate(objs):
    x_offset = leftmost(obj)
    shifted_obj = shift(obj, (current_y - uppermost(obj), x_offset))
    for i in range(height(obj)):
      for j in range(width(obj)):
        color = 1 if i == 1 else 2 if i > 1 and i != 0 else index(I, (uppermost(obj) + i, leftmost(obj) + j))
        O = paint(O, {(color, (current_y + i, x_offset + j))})
    current_y += height(obj)
  return O
 
103.66666666666667, tensor(0.2364), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def ecjbjdaijefdeehdifhfbgcejbfcgbia(I):
  objs = sorted(objects(I, F, F, T), key=lambda o: uppermost(o))
  O = canvas(0, (sum(height(o) for o in objs), width(I)))
  y = 0
  for i, obj in enumerate(objs):
    O = paint(O, shift({(1 if row_index == 1 else 2 if row_index > 1 and row_index != 0  else value, (row_index + y, col_index)) for value, (row_index, col_index) in obj}, (-uppermost(obj), leftmost(obj))))
    y += height(obj)
  return O
 
103.66666666666667, tensor(0.2364), Description: Stack the colored shapes vertically, starting from the top of the grid. Each shape should be placed directly on top of the previous shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. The shapes should be stacked such that the distance between the bottom of one shape and the top of the next shape is equal to the height of the shape being placed. The top row of each shape should be colored with the digit "1", the second row with the digit "2", and all subsequent rows with the digit "3". 
:: def fecdcddficggejcdbfdjfefadfejccef(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: uppermost(obj))
  O = canvas(0, (sum(height(o) for o in objs), width(I)))
  y = 0
  for i, obj in enumerate(objs):
    for v, (r, c) in obj:
      O = paint(O, {(1 if r - uppermost(obj) == 1 else 2 if r - uppermost(obj) > 1 and r - uppermost(obj) != 0 else v, (r + y - uppermost(obj), c + leftmost(obj)))})
    y += height(obj)
  return O
 
34.0, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def ggbccbjbcbgcebbbaijjefhbbbeafghf(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  out = canvas(bg, shape(I))
  obj3 = extract(objs, matcher(color, 3))
  obj7 = extract(objs, matcher(color, 7))
  out = underpaint(out, shift(obj3, ((height(out) - height(obj3)) // 2 - 2, (width(out) - width(obj3)) // 2)))
  out = underpaint(out, shift(obj7, (height(out) - height(obj7) - 1, (width(out) - width(obj7)) // 2)))
  out = underfill(out, 1, connect((1, width(out) // 2), (height(out) - height(obj7) - 2, width(out) // 2)))
  return out
 
35.333333333333336, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def bfbgdcgiechcechbjeibceacfahaagaf(I):
  objs = objects(I, True, False, True)
  h, w = shape(I)
  out = canvas(mostcolor(I), (h, w))
  for obj in objs:
    if color(obj) == 3:
      out = paint(out, shift(obj, ((h - height(obj)) // 2 - 2, (w - width(obj)) // 2)))
    elif color(obj) == 7:
      out = paint(out, shift(obj, (h - height(obj) - 1, (w - width(obj)) // 2)))
      out = underfill(out, 1, connect((1, w // 2), (h - height(obj) - 2, w // 2)))
  return out
 
34.666666666666664, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def eaebhcdiddgaegjcaabbifdgadihjeef(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  h, w = shape(I)
  out = canvas(bg, (h, w))
  for obj in objs:
    if color(obj) == 3:
      out = paint(out, shift(obj, (h // 2 - height(obj) // 2 - 2, w // 2 - width(obj) // 2)))
    if color(obj) == 7:
      out = paint(out, shift(obj, (h - height(obj) - 1, w // 2 - width(obj) // 2)))
      out = underfill(out, 1, connect((1, w // 2), (h - height(obj) - 2, w // 2)))
  return out
 
31.666666666666668, tensor(0.0073), Description: Move each colored shape down until it touches another colored shape or the bottom of the grid. The output grid should have a black background and be the same size as the input grid. 
:: def fecgicgffajeefbhjbbefceccddcjhbg(I):
  objs = objects(I, False, False, True) 
  new_objs = set()
  for obj in objs:
    lowest_row = lowermost(obj)
    while lowest_row < len(I) - 1 and index(I, (lowest_row + 1, leftmost(obj))) == 0:
      obj = shift(obj, DOWN)
      lowest_row += 1
    new_objs.add(obj)
  return paint(canvas(0, shape(I)), merge(new_objs)) 
 
29.0, tensor(0.0129), Description: Move all the colored squares to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background. 
:: def cdggacecaehgedfhjhdejcheffjabhhg(I):
    result = canvas(0, shape(I))
    for j in range(len(I[0])):
        column = [(I[i][j], i) for i in range(len(I))]
        new_column = [0] * len(I)
        k = len(I) - 1
        for val, i in reversed(column):
            if val != 0:
                new_column[k] = val
                k -= 1
        for i in range(len(I)):
            result = fill(result, new_column[i], {(i, j)})
    return result
 
23.333333333333332, tensor(0.0113), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the rightmost position in the bottom row, the shape in the second column is moved one position to the left, and so on. 
:: def eeibgcejfeeeeccgidcecffdcjiajbec(I):
  g = canvas(0, shape(I))
  for x, r in enumerate(I):
    nz = [(v, i) for i, v in enumerate(r) if v != 0]
    g = paint(g, {(c, (x, i + len(r) - 1 - k)) for (c, i), k in zip(nz, range(len(nz) - 1, -1, -1))})
  return g
 
29.0, tensor(0.0057), Description: Center each of the colored shapes horizontally within the grid. Then, move each shape to the top of the grid, maintaining its original horizontal position. If the shape is a horizontal line, center it vertically as well. The output grid should have a black background and be the same size as the input grid. 
:: def cjffbecadcjcebffjdibebdgafcedhcc(grid):
  def reposition(obj):
    if hline(obj):
      return shift(obj, subtract(((len(grid) - 1) // 2, (len(grid[0]) - 1) // 2), center(obj)))
    return shift(obj, (0 - uppermost(obj), (len(grid[0]) - 1) // 2 - leftmost(obj)))
  return paint(canvas(0, shape(grid)), merge(apply(reposition, fgpartition(grid))))
 
25.666666666666668, tensor(0.0176), Description: Center the shape with color 7 vertically and horizontally. Mirror the shape with color 3 horizontally and place it three rows above the top of the shape with color 7, maintaining its horizontal centering. The output grid should have a black background and be the same size as the input grid. 
:: def ifbdiaadbaddebhdibdbffaahiaeacji(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  for obj in objs:
    c = color(obj)
    if c == 7:
      O = paint(O, shift(obj, ((h - height(obj)) // 2 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
    elif c == 3:
      O = paint(O, shift(hmirror(obj), (3 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
  return O
 
27.0, tensor(0.0164), Description: Center the shape with color 7 vertically and horizontally. Mirror the shape with color 3 horizontally and place it four rows above the top of the shape with color 7, maintaining its horizontal centering. The output grid should have a black background and be the same size as the input grid. 
:: def bfgjaabifdaaebhhjaeijgcbgecgjffa(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, shape(I))
  seven_obj = extract(objs, lambda obj: color(obj) == 7)
  three_objs = frozenset(obj for obj in objs if color(obj) == 3)
  three_obj =  normalize(merge(three_objs))
  O = paint(O, shift(seven_obj, ((h - height(seven_obj)) // 2 - uppermost(seven_obj), (w - width(seven_obj)) // 2 - leftmost(seven_obj))))
  O = paint(O, shift(hmirror(three_obj), (4 - uppermost(three_obj), (w - width(three_obj)) // 2 - leftmost(three_obj))))
  return O
 
25.666666666666668, tensor(0.0079), Description: Center the shape with color 7 vertically and horizontally. Mirror the shape with color 3 horizontally and place it four rows above the top of the shape with color 7, maintaining its horizontal centering. If the shape with color 3 is originally in the top half of the grid, mirror it horizontally before placing it. The output grid should have a black background and be the same size as the input grid. 
:: def dbcffieceffdeejiibcdabjgcbddciia(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  for obj in objs:
    if color(obj) == 7:
      O = paint(O, shift(obj, (h - height(obj) - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
    elif color(obj) == 3:
      if uppermost(obj) < h // 2:
        O = paint(O, shift(hmirror(obj), (4 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
      else:
        O = paint(O, shift(obj, (4 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
  return O
 
25.666666666666668, tensor(0.0071), Description: Center the shape with the lowest color value vertically and horizontally. Mirror all other shapes horizontally and place them four rows above the top of the centered shape, maintaining their horizontal centering. The output grid should have a black background and be the same size as the input grid. 
:: def ecjdfjcjceaceehdaheffgabfbcaadcf(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  for i, obj in enumerate(sorted(objs, key=lambda obj: color(obj))):
    if i == 0:
      O = paint(O, shift(obj, ((h - height(obj)) // 2 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
    else:
      O = paint(O, shift(hmirror(obj), (4 - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj))))
  return O
 
25.333333333333332, tensor(0.0104), Description: Center the shape with color 7 vertically and horizontally. If there are three shapes in total, mirror the shape with color 3 vertically and place it three rows above the top of the shape with color 7, maintaining its horizontal centering. Otherwise, mirror the shape with color 3 horizontally and place it three rows above the top of the shape with color 7, maintaining its horizontal centering. The output grid should have a black background and be the same size as the input grid. 
:: def cgcdfccdagehecbeifhfjffeejggcefd(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  for obj in objs:
    if color(obj) == 7:
      offset = ((h - height(obj)) // 2, (w - width(obj)) // 2)
      O = paint(O, shift(obj, offset))
    elif color(obj) == 3:
      if len(objs) == 3:
        offset = (3, (w - width(obj)) // 2)
        O = paint(O, shift(vmirror(obj), offset))
      else:
        offset = (3, (w - width(obj)) // 2)
        O = paint(O, shift(hmirror(obj), offset))
  return O
 
29.0, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def fhaegfdeaeijeddajfcedgedfibecacc(I):
  objs = objects(I, True, False, True)
  h, w = shape(I)
  canvas_color = mostcolor(I)
  out = canvas(canvas_color, (h, w))
  threes = colorfilter(objs, 3)
  sevens = colorfilter(objs, 7)
  three = argmax(threes, lambda obj: colorcount(obj, 3)) if threes else None
  seven = argmax(sevens, lambda obj: colorcount(obj, 7)) if sevens else None

  if three is not None:
    out = underpaint(out, shift(three, ((h - height(three)) // 2, (w - width(three)) // 2)))
  if seven is not None:
    out = underpaint(out, shift(seven, (h - height(seven), (w - width(seven)) // 2)))
    out = underfill(out, 1, connect((uppermost(seven) - 1, center(seven)[1]), (0, center(seven)[1])))
  return out
 
36.666666666666664, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def ddihghahebaeecdabchdegacciicibdc(I):
  objs = objects(I, True, False, True)
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objs:
    obj_h, obj_w = shape(obj)
    if color(obj) == 3:
      out = underpaint(out, shift(obj, ((h - obj_h) // 2, (w - obj_w) // 2)))
    if color(obj) == 7:
      target_pos = (h - obj_h, (w - obj_w) // 2)
      out = underpaint(out, shift(obj, target_pos))
      line_start = (target_pos[0] - 1, target_pos[1] + obj_w // 2)
      out = underfill(out, 1, connect(line_start, (0, line_start[1])))
  return out
 
37.333333333333336, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def fbddjjddbjciehifbdaadeidhbbfdbhc(I):
  h, w = shape(I)
  out = canvas(mostcolor(I), (h, w))
  for obj in objects(I, True, False, True):
    c, (i, j) = next(iter(obj))
    if c == 3:
      out = underpaint(out, shift(obj, ((h - height(obj)) // 2, (w - width(obj)) // 2)))
    elif c == 7:
      out = underpaint(out, shift(obj, (h - height(obj), (w - width(obj)) // 2)))
      for k in range(i - 1, -1, -1):
        out = underfill(out, 1, ((k, j + width(obj) // 2),)) 
  return out
 
28.666666666666668, tensor(0.0760), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def gfjfjdffacadebafagfjeffdbfibbcdj(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  def transform_object(obj):
    if color(obj) == 7:
      return shift(combine(obj, {(1, center(obj))}), (h // 2 - center(obj)[0], w // 2 - center(obj)[1]))
    elif color(obj) == 3:
      return shift(recolor(1 if size(obj) == 2 else color(obj), 
                          combine(obj, {(color(obj), (i, leftmost(obj) + width(obj) - 1)) for _, (i, _) in obj} | 
                                      {(color(obj), (i, leftmost(obj))) for _, (i, _) in obj})),
                   (h // 2 - uppermost(obj) - height(obj) - 1, w // 2 - width(obj) // 2))
    else:
      return shift(obj, (h // 2 - uppermost(obj) - height(obj), w // 2 - width(obj) // 2))
  return paint(canvas(0, (h, w)), merge(apply(transform_object, objs)))
 
27.0, tensor(0.0087), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. 
:: def cdeihedjgjffefdfbdadhcjfhcfcdfeg(I):
  objs = objects(I, False, False, True)
  g = canvas(0, shape(I))
  for obj in objs:
    g = paint(g, shift(obj, (height(I) - lowermost(obj) - 1, 0))) 
  return g
 
28.666666666666668, tensor(0.0105), Description: Move all the colored shapes to the top of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be moved such that the shape in the first column is moved to the bottommost position in the top row, the shape in the second column is moved one position up, and so on. 
:: def acffjbhhcbddefafjggecgggcfcdiaec(I):
    h = height(I)
    g = canvas(0, shape(I))
    for j in range(width(I)):
        column = [I[i][j] for i in range(h)]
        for i, v in enumerate(column):
            if v != 0:
                g = paint(g, {(v, (h - i, j))})
    return g
 
26.666666666666668, tensor(0.0087), Description: Move all the colored shapes to the bottom row of the grid, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. 
:: def bdadfdcdcdgdeedhjcaebdjdfjhbgbib(I):
    g = canvas(0, shape(I))
    for obj in objects(I, False, False, True):
        shifted_obj = {(v, (i + height(I) - 1 - uppermost(obj), j)) for v, (i, j) in obj}
        g = paint(g, shifted_obj)
    return g
 
30.0, tensor(0.0258), Description: If a colored square (1, 2, or 3) is above a black square, move the colored square down one space. Repeat this process until all colored squares are in the bottom row. The output grid should have a black background. 
:: def dbabiibbhbbdejdababbbffcdeeccbgg(I):
  g = I
  for i in range(height(I) - 1, 0, -1): 
    for j in range(width(I)):
      if g[i][j] == 0 and g[i - 1][j] != 0: 
        g = paint(cover(g, {(g[i - 1][j], (i - 1, j))}), {(g[i - 1][j], (i, j))})
  return g
 
31.0, tensor(0.0078), Description: Center the shape with the lowest color value vertically and horizontally. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def aiccfedaadahecjbjfgacdbeaefddfad(I):
  objs = sorted(objects(I, F, F, T), key=lambda obj: -color(obj))
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = first(objs)
  other_objs = objs[1:]
  # Transform main object
  O = paint(O, recolor(3, shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))))
  O = paint(O, {(2, (h // 2, w // 2))})
  # Place other objects
  bottom = h - 1
  for obj in other_objs:
    obj_h = height(obj)
    O = paint(O, recolor(color(obj), {(i, (w - width(obj)) // 2) for i in range(bottom - obj_h + 1, bottom + 1)}))
    bottom -= obj_h
  return O
 
29.666666666666668, tensor(0.0078), Description: Center the shape with the highest color value vertically and horizontally. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the bottom of the centered shape and extending up to the top of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def daehcjdddbfeeijbibcahgacceiafcch(I):
  h, w = shape(I)
  O = canvas(0, (h, w))
  objs = sorted(objects(I, F, F, T), key=lambda obj: color(obj), reverse=True)
  # Draw the object with the highest value
  main_obj = objs[0]
  O = paint(O, recolor(3, shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))))
  O = paint(O, {(2, (h // 2, w // 2))})
  # Draw the other objects as vertical lines
  current_height = lowermost(main_obj) + 1
  for i in range(1, len(objs)):
    obj = objs[i]
    O = paint(O, recolor(color(obj), {(j, (w - width(obj)) // 2) for j in range(current_height, current_height + height(obj))}))
    current_height += height(obj)
  return O
 
37.0, tensor(0.0096), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def gffdhfbjjadaecggbbfacaeeaecfhage(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  three = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 3))
  seven = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 7))
  out = paint(out, shift(three, (h // 2 - height(three) // 2, w // 2 - width(three) // 2)))
  out = paint(out, shift(seven, (h - height(seven), w // 2 - width(seven) // 2)))
  line_end = h - height(seven) 
  out = underfill(out, 1, connect((line_end - 1, w // 2), (0, w // 2)))
  return out
 
35.0, tensor(0.0760), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ffffcdabffifejdjbcdfdgdabcgceacg(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = extract(objs, lambda o: color(o) == 7)
  other_objs = objs - {main_obj}
  centered_main_obj = shift(main_obj, (h // 2 - uppermost(main_obj) - height(main_obj) // 2, 
                                     w // 2 - leftmost(main_obj) - width(main_obj) // 2))
  centered_main_obj = combine(centered_main_obj, {(1, (uppermost(centered_main_obj) + height(centered_main_obj) // 2, 
                                                  leftmost(centered_main_obj) + width(centered_main_obj) // 2))})
  transformed_objs = []
  for obj in other_objs:
    if color(obj) == 3:
      if size(obj) == 2:
        obj = recolor(1, obj) 
      else:
        obj = combine(obj, {(3, (i, j + 1)) for _, (i, j) in obj} | {(3, (i, j - 1)) for _, (i, j) in obj})
        obj = combine(obj, {(2, (uppermost(obj) + height(obj) // 2, leftmost(obj) + width(obj) // 2))})
    elif color(obj) == 2:
      # Add logic based on relative position to '3' or other rules
      pass 
    else: 
      # Handle unspecified_objs 
      pass
    transformed_objs.append(obj)
  return paint(canvas(0, (h, w)), merge([centered_main_obj] + transformed_objs))
 
25.666666666666668, tensor(0.0113), Description: Move the shape with color 3 one row down. If the shape with color 3 is taller than the shape with color 7, move the shape with color 7 up by the difference in height. Otherwise, move the shape with color 7 down by the difference in height. The output grid should have a black background and be the same size as the input grid. 
:: def gddddehediaceccejghffdcbcdedeicd(I):
  objs = objects(I, False, False, True)
  threes = first(sfilter(objs, lambda obj: color(obj) == 3))
  sevens = first(sfilter(objs, lambda obj: color(obj) == 7))
  height_diff = height(threes) - height(sevens)
  shift_direction = (1, 0) if height_diff > 0 else (-1, 0)
  sevens_shifted = shift(sevens, multiply(shift_direction, abs(height_diff))) 
  threes_shifted = shift(threes, (1, 0))
  return paint(paint(canvas(0, shape(I)), threes_shifted), sevens_shifted) 
 
25.666666666666668, tensor(0.0099), Description: Move the shape with color 3 one row down. Move the shape with color 7 to the left of the shape with color 3, maintaining its original vertical position. The output grid should have a black background and be the same size as the input grid. 
:: def ehhhechdfdfbebfijahadbdjjdbeefcb(I):
  objs = objects(I, False, False, True)
  threes = first(sfilter(objs, lambda obj: 3 in palette(obj)))
  sevens = first(sfilter(objs, lambda obj: 7 in palette(obj)))
  target_position = (uppermost(threes), leftmost(sevens))
  return paint(paint(canvas(0, shape(I)), shift(threes, (1, 0))), shift(sevens, subtract(target_position, ulcorner(sevens))))
 
25.333333333333332, tensor(0.0104), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it to the top of the grid. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. The output grid should have a background color that is the most common color in the input grid. 
:: def bffdiajcbidceebgafeggfibbbibhbfa(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objects(I, True, False, True):
    if color(obj) == 3:
      target = (h // 2, w // 2) 
      offset = subtract(target, center(obj))
      out = paint(out, shift(obj, offset))
    elif color(obj) == 7:
      target = (0, w // 2)
      offset = subtract(target, center(obj))
      out = paint(out, shift(obj, offset))
      out = underfill(out, 1, connect((0, w // 2), (uppermost(shift(obj, offset)) - 1, w // 2)))
  return out
 
36.0, tensor(0.0263), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def cebdfaeecdjfechgjchccadbdfiegfbe(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = argmax(objs, lambda o: color(o) == 7)
  other_objs = objs - {main_obj}

  def reposition(obj):
    if color(obj) == 7:
      return shift(obj, (h//2 - centerofmass(obj)[0], w//2 - centerofmass(obj)[1])) | {(1, centerofmass(obj))}
    elif color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(3, add(loc, (0, 1))) for _, loc in obj} | 
                           {(3, add(loc, (0, -1))) for _, loc in obj} | 
                           {(2, centerofmass(obj))})
    elif color(obj) == 2:
      closest_3 = argmin(sfilter(other_objs, lambda o: color(o) == 3), lambda o: manhattan(o, obj))
      if closest_3:
        return shift(obj, sign(subtract(centerofmass(closest_3), centerofmass(obj))))
      else:
        return obj
    else:
      return obj

  return paint(canvas(0, (h, w)), merge(apply(reposition, objs)))
 
36.0, tensor(0.0263), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ddaiecggfafdejfhjficbahgdcjbdddc(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  seven = extract(objs, lambda o: color(o) == 7)
  others = objs - {seven}

  def reposition(obj):
    c = color(obj)
    if c == 7:
      return shift(obj, subtract((h // 2, w // 2), centerofmass(obj))) | {(1, centerofmass(obj))}
    elif c == 3:
      return branch(size(obj) == 2, 
                 recolor(1, obj), 
                 obj | {(3, add(p, (0, 1))) for _, p in obj} | 
                      {(3, add(p, (0, -1))) for _, p in obj} | 
                      {(2, centerofmass(obj))})
    elif c == 2:
      closest_three = argmin(sfilter(others, lambda o: color(o) == 3), lambda o: manhattan(o, obj))
      return branch(closest_three,
                 shift(obj, crement(subtract(centerofmass(closest_three), centerofmass(obj)))),
                 obj)
    else:
      return obj

  return paint(canvas(0, (h, w)), merge(apply(reposition, objs)))
 
35.333333333333336, tensor(0.0263), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ecghiacaiecdeeaibbdaceebgdbiaiie(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)

  def process(obj):
    c = color(obj)
    if c == 7:
      return shift(obj | {(1, center(obj))}, 
                   subtract((h // 2, w // 2), center(obj)))
    elif c == 3:
      return branch(size(obj) == 2,
                 recolor(1, obj),
                 combine(obj, {(3, add(loc, (0, d))) for _, loc in obj for d in [-1, 1]} |
                         {(2, center(obj))}))
    elif c == 2:
      threes = sfilter(objs, lambda o: color(o) == 3)
      closest_three = argmin(threes, lambda o: manhattan(o, obj))
      return branch(closest_three,
                 shift(obj, sign(subtract(center(closest_three), center(obj)))),
                 obj)
    else:
      return obj

  return paint(canvas(0, (h, w)), merge(apply(process, objs)))
 
25.666666666666668, tensor(0.0079), Description: Center the largest colored shape vertically and horizontally. Then, move the smallest colored shape to the bottom of the grid, directly below the centered shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. 
:: def jcfjgfgeechbejhhbdifgafibgbecbii(I):
  objs = objects(I, False, False, True) 
  target_obj = argmax(objs, size)  
  other_obj = first(difference(objs, {target_obj}))  
  
  target_centered = shift(target_obj, (len(I) // 2 - uppermost(target_obj) - height(target_obj) // 2, 1))
  other_shifted = shift(other_obj, (lowermost(target_centered) + 1 - uppermost(other_obj), 0)) 
  
  return paint(paint(canvas(0, shape(I)), target_centered), other_shifted) 
 
25.666666666666668, tensor(0.0094), Description: Center the largest colored shape vertically and horizontally, then move it one column to the right. Then, move the second largest colored shape to the bottom of the grid, directly below the centered shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. 
:: def bbjdfbijfebjedafafgcccfabjggfcgb(grid):
  objs = sorted(objects(grid, False, False, True), key=size, reverse=True)
  main_obj, other_obj = objs[0], objs[1]
  
  mid_row = len(grid) // 2
  main_obj_shifted = shift(main_obj, (mid_row - centerofmass(main_obj)[0], 1))
  other_obj_shifted = shift(other_obj, (lowermost(main_obj_shifted) + 1 - uppermost(other_obj), 0))
  
  return paint(paint(canvas(0, shape(grid)), main_obj_shifted), other_obj_shifted)
 
25.333333333333332, tensor(0.0091), Description: Move the largest colored shape one column to the right. Then, move the second largest colored shape to the top of the grid, directly above the largest shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. 
:: def fefeecafehgcegdcafhjeeeabbdifffi(I):
  objs = objects(I, False, False, True)
  large_obj = argmax(objs, lambda obj: len(obj)) 
  other_obj = first(filter(lambda obj: obj != large_obj, objs)) 

  uppermost_large = uppermost(large_obj)
  uppermost_other = uppermost(other_obj)
  
  v_shift = (uppermost_large - uppermost_other - height(other_obj) + height(large_obj)) if uppermost_large > uppermost_other else (uppermost_large - uppermost_other)  
  
  new_large = shift(large_obj, (0, 1))  
  new_other = shift(other_obj, (v_shift, 0)) 

  return paint(paint(canvas(0, shape(I)), new_large), new_other)
 
24.333333333333332, tensor(0.0094), Description: Center the largest colored shape vertically and horizontally, then move it one column to the right. Then, move the second largest colored shape to the bottom of the grid, directly below the centered shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. 
:: def cfgeiddcdgdfegcdjfihdbgieeccbeab(grid):
  objects_list = sorted(list(objects(grid, False, False, True)), key=lambda x: -len(x))
  main_object = objects_list[0]
  secondary_object = objects_list[1]

  main_object_shifted = shift(main_object, ((len(grid) - height(main_object)) // 2, 1)) 
  secondary_object_shifted = shift(secondary_object, (lowermost(main_object_shifted) + 1 - uppermost(secondary_object), 0))

  return paint(paint(canvas(0, shape(grid)), main_object_shifted), secondary_object_shifted)
 
24.666666666666668, tensor(0.0094), Description: Center the largest colored shape vertically and horizontally, then move it one column to the right. Then, move the second largest colored shape to the bottom of the grid, directly below the centered shape, maintaining its original horizontal position. The output grid should have a black background and be the same size as the input grid. 
:: def bdjdcbgjdcefedacidbaheaigefdaahe(grid):
  objs = objects(grid, False, False, True)
  largest_obj = max(objs, key=len)
  other_obj = next(iter(objs - {largest_obj})) 

  grid_height = len(grid)
  largest_obj_height = height(largest_obj) 
  
  new_largest_obj = shift(largest_obj, (grid_height // 2 - largest_obj_height // 2, 1)) 
  new_other_obj = shift(other_obj, (lowermost(new_largest_obj) + 1 - uppermost(other_obj), 0))

  return paint(paint(canvas(0, shape(grid)), new_largest_obj), new_other_obj)
 
30.666666666666668, tensor(0.0098), Description: Center the largest colored shape vertically and horizontally. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be in the leftmost column of the grid. The output grid should have a black background and be the same size as the input grid. 
:: def ddbagcbbffjaefddbdbeiiaedcfacebf(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = max(objs, key=len)  # Main object is the largest
  other_objs = sorted(objs - {main_obj}, key=lambda obj: color(obj))
  # Main Object:
  main_obj_shifted = shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))
  O = paint(O, recolor(3, main_obj_shifted))
  O = paint(O, {(2, center(main_obj_shifted))})
  # Other Objects:
  current_y = uppermost(main_obj_shifted) - 1
  for obj in other_objs:
    obj_height = height(obj)
    O = paint(O, recolor(color(obj), {(i, 0) for i in range(current_y - obj_height + 1, current_y + 1)}))
    current_y -= obj_height
  return O
 
37.666666666666664, tensor(0.0107), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid.  Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def dejedebfhibgeeifjbbfdeecchfcgdfg(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objects(I, True, False, True):
    if color(obj) == 3:
      out = paint(out, shift(obj, (h // 2 - height(obj) // 2, w // 2 - width(obj) // 2)))
      out = underfill(out, 2, (center(obj),))
    elif color(obj) == 7:
      out = paint(out, shift(obj, (h - height(obj), w // 2 - width(obj) // 2)))
      line_start = (uppermost(obj) - 1, w // 2)
      line_end = (-1, w // 2)
      out = underfill(out, 1, connect(line_start, line_end))
  return out
 
34.666666666666664, tensor(0.0107), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid.  Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def bedbcbecahdfebiciifdheabijebdfgf(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objects(I, True, False, True):
    if color(obj) == 3:
      out = paint(out, shift(obj, (h // 2 - uppermost(obj) - height(obj) // 2, w // 2 - leftmost(obj) - width(obj) // 2)))
      out = underfill(out, 2, ((h // 2, w // 2),)) 
    elif color(obj) == 7:
      out = paint(out, shift(obj, (h - height(obj), w // 2 - leftmost(obj) - width(obj) // 2)))
      out = underfill(out, 1, connect((uppermost(obj) - 1, w // 2), (-1, w // 2)))
  return out
 
37.0, tensor(0.0107), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid.  Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def hedeeeaaabjfebajjbefeedaaeaabhad(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objects(I, True, False, True):
    target_row = h // 2 if color(obj) == 3 else h - height(obj)
    out = paint(out, shift(obj, (target_row - uppermost(obj) - height(obj) // 2, w // 2 - leftmost(obj) - width(obj) // 2)))
    if color(obj) == 3:
      out = underfill(out, 2, ((h // 2, w // 2),)) 
    elif color(obj) == 7:
      out = underfill(out, 1, connect((target_row - 1, w // 2), (-1, w // 2)))
  return out
 
35.0, tensor(0.0107), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the top of the grid. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def chfbeafbccgdehhcbbgfhfcbadgbdbbb(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for obj in objects(I, True, False, True):
    if color(obj) == 3:
      out = paint(out, shift(obj, (h // 2 - height(obj) // 2, w // 2 - width(obj) // 2)))
      out = paint(out, {(2, (h // 2, w // 2))})
    elif color(obj) == 7:
      out = paint(out, shift(obj, (h - height(obj), w // 2 - width(obj) // 2)))
      for i in range(uppermost(obj) - 1, -1, -1):
        out = paint(out, {(1, (i, w // 2))})
  return out
 
36.0, tensor(0.0258), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row or column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ebeiaeebacddeefeiadbcdbecaigejfd(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)

  def transform_obj(obj, other_objs):
    if color(obj) == 7:
      return shift(obj | {(1, centerofmass(obj))},
                   (h // 2 - centerofmass(obj)[0], w // 2 - centerofmass(obj)[1]))
    elif color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(3, (i, j + 1)) for _, (i, j) in obj if j < w - 1} |
                       {(3, (i, j - 1)) for _, (i, j) in obj if j > 0} |
                       {(2, centerofmass(obj))})
    elif color(obj) == 2:
      matching_3_obj = extract(other_objs, lambda o: color(o) == 3 and (hmatching(o, obj) or vmatching(o, obj)))
      if matching_3_obj:
        return shift(obj, position(obj, matching_3_obj))
    return obj

  return paint(canvas(0, (h, w)), merge(apply(lambda o: transform_obj(o, objs - {o}), objs)))
 
35.333333333333336, tensor(0.0258), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the leftmost and rightmost columns, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row or column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def bcbehfbdjdcdejchajdebfcbeiiaaaae(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)

  def transform_obj(obj, other_objs):
    c = color(obj)
    if c == 7:
      return shift(obj | {(1, center(obj))}, (h // 2 - center(obj)[0], w // 2 - center(obj)[1]))
    elif c == 3:
      return branch(size(obj) == 2,
                   recolor(1, obj),
                   combine(obj | {(3, (i, j + 1)) for _, (i, j) in obj} | {(3, (i, j - 1)) for _, (i, j) in obj},
                           {(2, centerofmass(obj))}))
    elif c == 2:
      match_found = False
      for other in other_objs:
        if color(other) == 3 and (hmatching(other, obj) or vmatching(other, obj)):
          obj = shift(obj, position(obj, other))
          match_found = True
          break
      return obj if match_found else obj
    return obj

  return paint(canvas(0, (h, w)), merge(apply(lambda o: transform_obj(o, objs - {o}), objs)))
 
30.666666666666668, tensor(0.0210), Description: Center the largest colored shape vertically and mirror it horizontally. Then, place all other shapes above the centered shape, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the distance between the bottom of the centered shape and the top of the next shape is equal to half the height of the centered shape. 
:: def bccebaejebcdedcbiafdaaccahfcfade(I):
  objs = objects(I, False, False, True) # Extract all objects, excluding background
  largest_obj = argmax(objs, size)  # Find the largest object by area
  h, w = shape(I)                  # Get height and width of the grid
  centered_obj = shift(hmirror(largest_obj), (h // 2 - uppermost(largest_obj) - height(largest_obj) // 2, 0)) # Center vertically and mirror horizontally 
  g = paint(canvas(0, (h, w)), centered_obj) # Paint the largest object onto a blank canvas
  for obj in objs - {largest_obj}:  # Paint other objects, shifting them down if necessary
    g = paint(g, shift(obj, (max(0, height(centered_obj) // 2 - uppermost(obj)), 0)))
  return g
 
29.333333333333332, tensor(0.0210), Description: Center the largest colored shape vertically and mirror it horizontally. Then, place all other shapes above the centered shape, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the distance between the bottom of the centered shape and the top of the next shape is equal to half the height of the centered shape. 
:: def febcehbbfafeebggadhfhabjddaaeafe(I):
  objs = sorted(objects(I, False, False, True), key=size, reverse=True) # Extract objects, sort by size
  h, w = shape(I)
  centered_obj = shift(hmirror(objs[0]), (h // 2 - uppermost(objs[0]) - height(objs[0]) // 2, 0)) # Center and mirror the largest object
  g = paint(canvas(0, (h, w)), centered_obj)
  for k in range(1, len(objs)):
    obj = objs[k]
    g = paint(g, shift(obj, (max(0, uppermost(centered_obj) - uppermost(obj)), 0))) # Shift based on uppermost row comparison
  return g 
 
31.333333333333332, tensor(0.0210), Description: Center the largest colored shape vertically and mirror it horizontally. Then, place all other shapes above the centered shape, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the distance between the bottom of the centered shape and the top of the next shape is equal to half the height of the centered shape. 
:: def fdfcbbbcacgfeffibbeedbidjeagfchf(I):
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  h, w = shape(I)
  offset = h // 2 - uppermost(largest_obj) - height(largest_obj) // 2
  return paint(
      paint(
        canvas(0, (h, w)), 
        shift(hmirror(largest_obj), (offset, 0))
      ), 
      merge([shift(obj, (max(0, offset), 0)) for obj in objs - {largest_obj}])
  )
 
30.666666666666668, tensor(0.0094), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def ebcgaaahbidfefccbjecffifaebaebfe(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = extract(objs, lambda obj: 7 in palette(obj))
  other_objs = sorted(objs - {main_obj}, key=lambda obj: -len(obj))
  # Center and Recolor Main Object
  centered_main = shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))
  O = paint(O, recolor(7, centered_main))
  O = paint(O, {(1, centerofmass(centered_main))})
  # Position Other Objects
  current_row = uppermost(centered_main) - 1
  for obj in other_objs:
    O = paint(O, recolor(color(obj), shift(obj, (current_row - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj)))))
    current_row -= height(obj)
  return O 
 
30.666666666666668, tensor(0.0094), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. 
:: def dgdicdgbfafbehadiffdhfbhdjiibbcb(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = extract(objs, lambda obj: 7 in palette(obj))
  other_objs = sorted(objs - {main_obj}, key=lambda obj: color(obj))
  # Center and Recolor Main Object
  centered_main = shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))
  O = paint(O, recolor(7, centered_main))
  O = paint(O, {(1, centerofmass(centered_main))})
  # Position Other Objects
  current_row = uppermost(centered_main) - 1
  for obj in other_objs:
    O = paint(O, recolor(color(obj), shift(obj, (current_row - uppermost(obj), (w - width(obj)) // 2 - leftmost(obj)))))
    current_row -= height(obj)
  return O
 
31.0, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the center of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def figdcegefbgjehajjebhjebdeifffehe(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  obj3 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 3))
  obj7 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 7))
  out = paint(out, shift(obj3, (h // 2 - height(obj3) // 2, w // 2 - width(obj3) // 2)))
  out = paint(out, shift(obj7, (h - height(obj7), w // 2 - width(obj7) // 2)))
  out = underfill(out, 2, ((h // 2, w // 2),))
  out = underfill(out, 1, connect((h // 2 - 1, w // 2), (h - height(obj7) - 1, w // 2)))
  return out 
 
25.666666666666668, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def bbeadabcfcheefgdbicihibceeecjdfe(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  obj3 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 3))
  obj7 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 7))
  out = paint(out, shift(obj3, (h // 2 - height(obj3) // 2, w // 2 - width(obj3) // 2)))
  out = paint(out, shift(obj7, (h - height(obj7), w // 2 - width(obj7) // 2)))
  for i in range(h - height(obj7), h // 2):
      out = underfill(out, 1, ((i, w // 2),))
  out = underfill(out, 2, ((h // 2, w // 2),))
  return out
 
30.0, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def ecieahfiagdeecacjbdeabedbhfbdjcd(I):
  h, w = shape(I)
  bg = mostcolor(I)
  obj3 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 3))
  obj7 = normalize(extract(objects(I, True, False, True), lambda obj: color(obj) == 7))
  line = frozenset(((1, (i, w // 2)) for i in range(h - height(obj7) - 1, h // 2, -1)))
  out = paint(canvas(bg, (h, w)), shift(obj3, (h // 2 - height(obj3) // 2, w // 2 - width(obj3) // 2)))
  out = paint(out, shift(obj7, (h - height(obj7), w // 2 - width(obj7) // 2)))
  return paint(fill(out, 2, ((h // 2, w // 2),)), line)
 
31.333333333333332, tensor(0.0465), Description: Center the shape with color 7 vertically and horizontally. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def dffabbbccadjejfebajfdjbejfebffjd(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)

  def transform_obj(obj):
    if color(obj) == 7:
      return shift(combine(obj, {(1, centerofmass(obj))}),
                   (h // 2 - centerofmass(obj)[0], w // 2 - centerofmass(obj)[1]))
    elif color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2))})
    elif color(obj) == 2:
      for _, (i, j) in obj:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          if index(grid, (i+di, j+dj)) == 3:
            return shift(obj, (di, dj))
    return obj

  return paint(canvas(0, (h, w)), merge(apply(transform_obj, objs)))
 
32.333333333333336, tensor(0.0123), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the left and right of the middle column, maintaining its vertical centering. Center the shape with color 3 vertically and horizontally, but move it one row up. If the shape with color 2 is in the same row as a shape with color 3, and the shape with color 2 is to the left of the shape with color 3, move the shape with color 2 one column to the right. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def fheefcgdjhjhebdbibdabegehhaajjcd(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)

  def transform_obj(obj):
    if color(obj) == 7:
      center_obj = (h // 2 - uppermost(obj) - height(obj) // 2,
                    w // 2 - leftmost(obj) - width(obj) // 2)
      return shift(combine(obj, {(1, add(center_obj, (height(obj) // 2, width(obj) // 2))) }),
                   center_obj)
    elif color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2)),
                              (3, (uppermost(obj), leftmost(obj) + width(obj) // 2 - 1)),
                              (3, (uppermost(obj), leftmost(obj) + width(obj) // 2 + 1))})
    elif color(obj) == 2:
      three_objs = sfilter(objs, lambda o: color(o) == 3)
      closest_3 = argmin(three_objs, lambda o: manhattan(o, obj)) if three_objs else None
      if closest_3:
        return shift(obj, (0, 1)) if leftmost(obj) < leftmost(closest_3) else obj
    return obj

  return paint(canvas(0, (h, w)), merge(apply(transform_obj, objs)))
 
30.333333333333332, tensor(0.0094), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the rightmost column of each shape is aligned with the center column of the grid. 
:: def fgiafheffgecebhhiacedbabbdgfcaea(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = extract(objs, lambda obj: 7 in palette(obj))
  other_objs = sorted(objs - {main_obj}, key=lambda o: lrcorner(o)[0])

  O = paint(O, recolor(7, shift(main_obj, ((h - height(main_obj)) // 2 - uppermost(main_obj), (w - width(main_obj)) // 2 - leftmost(main_obj)))))
  O = paint(O, {(1, centerofmass(main_obj))})

  current_pos = (uppermost(main_obj) - 1, (w - width(other_objs[0])) // 2)
  for obj in other_objs:
    O = paint(O, recolor(color(obj), shift(obj, subtract(current_pos, ulcorner(obj)))))
    current_pos = (current_pos[0] - height(obj), current_pos[1]) 

  return O
 
30.333333333333332, tensor(0.0094), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. Then, for each of the remaining shapes, create a vertical line of the same color, starting at the top of the grid and extending down to the bottom of the shape. The line should be centered horizontally within the grid. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the rightmost column of each shape is aligned with the center column of the grid. 
:: def iffegigadedceaeebefadecdgehffcea(I):
  objs = objects(I, F, F, T)
  h, w = shape(I)
  O = canvas(0, (h, w))
  main_obj = extract(objs, lambda obj: 7 in palette(obj))
  other_objs = sorted(objs - {main_obj}, key=lambda obj: -len(obj))

  O = paint(O, recolor(7, shift(main_obj, subtract(((h - height(main_obj)) // 2 , (w - width(main_obj)) // 2), ulcorner(main_obj)))))
  O = paint(O, {(1, centerofmass(main_obj))})

  y_offset = uppermost(main_obj) - 1
  for obj in other_objs:
    x_offset = (w - width(obj)) // 2 - leftmost(obj)
    O = paint(O, recolor(color(obj), shift(obj, (y_offset - uppermost(obj), x_offset))))
    y_offset -= height(obj)

  return O
 
24.333333333333332, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def ajfaebhjhhefebajjhagjaijbfefahji(I):
  h, w = shape(I)
  bg = mostcolor(I)
  obj3 = extract(objects(I, True, False, True), lambda obj: color(obj) == 3)
  obj7 = extract(objects(I, True, False, True), lambda obj: color(obj) == 7)
  out = paint(canvas(bg, (h, w)), shift(obj3, (h // 2 - height(obj3) // 2, w // 2 - width(obj3) // 2)))
  out = paint(out, shift(obj7, (h - height(obj7), w // 2 - width(obj7) // 2)))
  out = fill(out, 2, ((h // 2, w // 2),))
  out = fill(out, 1, tuple((i, w // 2) for i in range(h - height(obj7), h // 2))) 
  return out
 
25.666666666666668, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def hidadchfhbigefadagachjfgdhicjjbj(I):
  h, w = shape(I)
  bg = mostcolor(I)
  out = canvas(bg, (h, w))
  for v, obj in sorted(((color(obj), normalize(obj)) for obj in objects(I, True, False, True)), key=lambda x: x[0]):
    if v == 3:
      out = paint(out, shift(obj, (h // 2 - height(obj) // 2, w // 2 - width(obj) // 2)))
    elif v == 7:
      out = paint(out, shift(obj, (h - height(obj), w // 2 - width(obj) // 2)))
      out = fill(out, 1, tuple((i, w // 2) for i in range(h - height(obj), h // 2)))
  return fill(out, 2, ((h // 2, w // 2),)) 
 
30.666666666666668, tensor(0.0108), Description: Center the shape with color 3 vertically and horizontally. Center the shape with color 7 vertically and horizontally, but move it one row up. Draw a vertical line of color 1 connecting the bottom of the shape with color 7 to the center of the shape with color 3. Place a single square of color 2 in the center of the shape with color 3. The output grid should have a background color that is the most common color in the input grid. 
:: def baieeehjifbaeabciaebhhcfadibcdbe(I):
  h, w = shape(I)
  bg = mostcolor(I)
  obj3 = extract(objects(I, True, False, True), matcher(color, 3))
  obj7 = extract(objects(I, True, False, True), matcher(color, 7))
  out = paint(canvas(bg, (h, w)), shift(obj3, (h // 2 - height(obj3) // 2, w // 2 - width(obj3) // 2)))
  out = paint(out, shift(obj7, (h - height(obj7), w // 2 - width(obj7) // 2)))
  line = connect((h - height(obj7), w // 2), (h // 2 - 1, w // 2))
  out = fill(out, 1, line)
  return fill(out, 2, ((h // 2, w // 2),))
 
31.666666666666668, tensor(0.0346), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def edcbaibfagjdedebbaaihefgafeffcbe(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = extract(objs, lambda o: color(o) == 7)
  other_objs = objs - {main_obj}
  center_offset = (h // 2 - uppermost(main_obj) - height(main_obj) // 2, 
                  w // 2 - leftmost(main_obj) - width(main_obj) // 2)
  centered_main_obj = combine(shift(main_obj, center_offset), 
                              {(1, add(center_offset, (height(main_obj) // 2, width(main_obj) // 2)))})

  def transform_obj(obj):
    if color(obj) == 3:
      return branch(size(obj) == 2, 
                   recolor(1, obj),
                   combine(obj, {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2))}))
    elif color(obj) == 2:
      closest_3 = argmin(sfilter(other_objs, lambda o: color(o) == 3), lambda o: manhattan(o, obj))
      if closest_3:
        return shift(obj, gravitate(obj, closest_3))
    return obj

  return paint(canvas(0, (h, w)), merge(combine({centered_main_obj}, apply(transform_obj, other_objs))))
 
31.666666666666668, tensor(0.0346), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ibgigbgafgbfebiebbiaeebcedabbcea(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = extract(objs, matcher(color, 7))
  centered_main_obj = shift(main_obj, (h // 2 - centerofmass(main_obj)[0], w // 2 - centerofmass(main_obj)[1]))
  centered_main_obj = combine(centered_main_obj, {(1, centerofmass(centered_main_obj))})

  def transform_obj(obj):
    if color(obj) == 3:
      return branch(size(obj) == 2, 
                   recolor(1, obj),
                   combine(recolor(3, obj), {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2))}))
    elif color(obj) == 2:
      three_objs = sfilter(objs, lambda o: color(o) == 3)
      closest_3 = argmin(three_objs, lambda o: manhattan(o, obj)) if three_objs else None
      if closest_3:
        relative_pos = position(obj, closest_3)
        return shift(obj, (relative_pos[0], relative_pos[1]))
    return obj

  return paint(canvas(0, (h, w)), merge(combine({centered_main_obj}, apply(transform_obj, objs - {main_obj}))))
 
31.666666666666668, tensor(0.0131), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row as a shape with color 3, move the shape with color 2 one step to the right if it's to the left of the shape with color 3, and one step to the left if it's to the right of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def ghciefbehdjaebebjefcbjjedbjbjjcb(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = next((obj for obj in objs if color(obj) == 7), None) # Extract main object
  other_objs = objs - {main_obj}
  center_offset = (h // 2 - uppermost(main_obj) - height(main_obj) // 2,
                    w // 2 - leftmost(main_obj) - width(main_obj) // 2)
  centered_main_obj = combine(shift(main_obj, center_offset), 
                              {(1, (uppermost(main_obj) + center_offset[0] + height(main_obj) // 2, 
                                   leftmost(main_obj) + center_offset[1] + width(main_obj) // 2))})

  def transform_obj(obj):
    if color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj) 
      else:
        return combine(recolor(3, obj), {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2))})
    elif color(obj) == 2:
      # Find closest object of color 3
      closest_3 = min(sfilter(other_objs, lambda o: color(o) == 3), key=lambda o: manhattan(o, obj), default=None)
      if closest_3:
        return branch(leftmost(obj) < leftmost(closest_3),
                      shift(obj, (0, 1)), 
                      shift(obj, (0, -1))) 
    return obj

  return paint(canvas(0, (h, w)), merge([centered_main_obj] + list(apply(transform_obj, other_objs)))) 
 
31.666666666666668, tensor(0.0346), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row and column as a shape with color 3, move the shape with color 2 one step in the direction of the center of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def fdcfejhfagadecgdafccfgdjfbcajfda(grid):
  objs = fgpartition(grid)
  main_obj = extract(objs, lambda o: color(o) == 7)
  center_offset = ((height(grid) - height(main_obj)) // 2 - uppermost(main_obj),
                   (width(grid) - width(main_obj)) // 2 - leftmost(main_obj))
  centered_main_obj = shift(main_obj, center_offset)
  centered_main_obj = combine(centered_main_obj, {(1, add(centerofmass(centered_main_obj), center_offset))})

  def transform_obj(obj):
    if color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(2, tuple(add(centerofmass(obj), (0, 1))))})
    return obj

  return paint(canvas(0, shape(grid)), merge(combine({centered_main_obj}, apply(transform_obj, objs - {main_obj})))) 
 
31.333333333333332, tensor(0.0131), Description: Center the shape with color 7 vertically and horizontally. Place a single square of color 1 in the center of the shape with color 7. If the shape with color 3 has a size of 2, change its color to 1. Then, for the shape with color 3, add a square of the same color to the middle column, maintaining its vertical centering. If the shape with color 2 is in the same row as a shape with color 3, move the shape with color 2 one step to the right if it's to the left of the shape with color 3, and one step to the left if it's to the right of the shape with color 3. Otherwise, leave the shape with color 2 in its original position. Center all other shapes vertically and horizontally, but move them one row up. The output grid should have a black background and be the same size as the input grid. 
:: def eihcfcgejccbegjcigfficeccbgibcef(grid):
  h, w = shape(grid)
  objs = fgpartition(grid)
  main_obj = extract(objs, lambda obj: color(obj) == 7)
  other_objs = objs - {main_obj}

  centered_main_obj = shift(main_obj, 
                              (h // 2 - uppermost(main_obj) - height(main_obj) // 2,
                              w // 2 - leftmost(main_obj) - width(main_obj) // 2))
  centered_main_obj = combine(centered_main_obj, {(1, center(centered_main_obj))})

  def transform_obj(obj):
    if color(obj) == 3:
      if size(obj) == 2:
        return recolor(1, obj)
      else:
        return combine(obj, {(2, (uppermost(obj), leftmost(obj) + width(obj) // 2))})
    elif color(obj) == 2:
      threes = sfilter(other_objs, lambda o: color(o) == 3)
      if threes:
        closest_three = min(threes, key=lambda o: manhattan(o, obj))
        return branch(leftmost(obj) < leftmost(closest_three),
                      shift(obj, (0, 1)),
                      obj)
    return obj

  transformed_objs = apply(transform_obj, other_objs)
  return paint(canvas(0, (h, w)), merge([centered_main_obj] + list(transformed_objs)))
 
29.666666666666668, tensor(0.0210), Description: Center the largest colored shape vertically and mirror it horizontally. Then, place all other shapes above the centered shape, maintaining their original horizontal positions. The output grid should have a black background and be the same size as the input grid. The shapes should be placed such that the distance between the bottom of the centered shape and the top of the next shape is equal to half the height of the centered shape. 
:: def ghaciehdagacebaciiacejfbfbcdaffe(I):
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)
  mid = height(I) // 2
  transformed_objs = apply(lambda o: shift(branch(o == largest_obj, hmirror(o), o), (max(0, mid - uppermost(o)), 0)), objs)
  return paint(canvas(0, shape(I)), merge(transformed_objs))
 
