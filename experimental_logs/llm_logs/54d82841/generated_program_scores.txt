3.0, tensor(1.1360), Description: Fill the two squares in the bottom row with yellow. The squares should be in the middle of the bottom row. 
:: def aegccecgjhheeafbaddedhgfhjbefcbh(I):
  O = fill(I, 4, {(height(I)-1, width(I) // 2 - 1), (height(I)-1, width(I) // 2 + 1)})
  return O
 
6.333333333333333, tensor(1.9906), Description: Replace all the black squares in the bottom row with yellow, starting from the bottom row and going up, until you find a row that has at least one non-black square.  
:: def ebbahibefddfehegjeddcgbecjfcadag(I):
  # Find the height of the input grid
  x1 = height(I)
  # Iterate through rows from bottom to top
  for i in range(x1-1, -1, -1):
    # Extract the current row
    x2 = I[i]
    # Check if the row has any non-zero element
    x3 = any(x != 0 for x in x2)
    if x3:
      # Replace zeros with 4 in the row
      x4 = tuple(4 if x == 0 else x for x in x2)
      # Update the input grid with the modified row
      I = (*I[:i], x4, *I[i+1:])
      break
  # Return the modified grid
  O = I
  return O
 
7.666666666666667, tensor(1.9821), Description: Replace all the black squares in the last row with yellow, unless the last row already contains a non-black square. If the last row is all black, replace the black squares in the second-to-last row with yellow. 
:: def iecidccfheefejcciefiegbgadccgjed(I):
  # Check if the last row has any non-zero element
  x1 = any(x != 0 for x in I[-1])
  # If the last row is all zeros
  if not x1:
    # Replace zeros in the second last row with 4
    O = (*I[:-2], tuple(4 if x == 0 else x for x in I[-2]), I[-1])
  else:
    # Replace zeros in the last row with 4
    O = (*I[:-1], tuple(4 if x == 0 else x for x in I[-1]))
  return O
 
4.333333333333333, tensor(1.7290), Description: For each colored shape in the input grid, find the leftmost and rightmost squares in the bottom row of the shape. Fill those two squares with yellow. 
:: def hddhdjiffffheifdjfgcihcajieeabai(I):
    objs = fgpartition(I)
    for obj in objs:
        bottom_row = maximum(frozenset(i for i, j in toindices(obj)))
        leftmost_col = minimum(frozenset(j for i, j in toindices(obj) if i==bottom_row))
        rightmost_col = maximum(frozenset(j for i, j in toindices(obj) if i==bottom_row))
        I = fill(I, 4, {(bottom_row,leftmost_col)})
        I = fill(I, 4, {(bottom_row, rightmost_col)})
    return I 
 
4.333333333333333, tensor(1.7290), Description: For each colored shape in the input grid, find the leftmost and rightmost squares in the bottom row of the shape. Fill those two squares with yellow. 
:: def ecibfacigbbeeebebbjfdjdjbiecdcab(I):
    objs = objects(I, univalued=False, diagonal=True, without_bg=True)
    for obj in objs:
      bottom_indices = sfilter(toindices(obj), lambda x: x[0] == lowermost(obj))
      left_idx = argmin(bottom_indices, lambda x: x[1])
      right_idx = argmax(bottom_indices, lambda x: x[1])
      I = fill(I, 4, {left_idx})
      I = fill(I, 4, {right_idx})
    return I
 
2.6666666666666665, tensor(1.9820), Description: For each colored shape in the input grid, draw a horizontal line of yellow squares across the grid, centered on the shape. The line should be as wide as the shape. If the shape has an odd number of columns, the line should be centered on the leftmost column of the shape. 
:: def dgadcjbbjfgbeggibdiccjebebdcdfad(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  out = I
  for obj in objs:
    w = width(obj)
    offset = (len(I) - 1, leftmost(obj) + (w // 2) - (1 if even(w) else 0))
    line = recolor(4, {(offset[0], j) for j in range(offset[1], offset[1] + w)})
    out = paint(out, line)
  return out
 
3.3333333333333335, tensor(1.7605), Description: For each colored shape in the input grid, fill the entire bottom row of the shape with yellow. 
:: def bifbfaeccjdaedchibjicbefbafeceef(I):
  objs = objects(I, T, F, T)
  h = len(I)
  out = I
  for obj in objs:
    left = leftmost(obj)
    right = rightmost(obj)
    for j in range(left, right + 1):
      out = fill(out, 4, {(h - 1, j)})
  return out
 
3.6666666666666665, tensor(0.5028), Description: Find the topmost colored shape in the input grid.  Place two yellow squares in the bottom row of the grid, centered horizontally on the topmost shape. 
:: def bhffgbacdefiegjcaffdddeajddeeddb(I):
  # Identify the topmost object
  top_object = first(objects(I, T, F, T))
  
  # Calculate the horizontal center of the top object
  center_j = leftmost(top_object) + width(top_object) // 2
  
  # Construct the new '4' object
  new_object = {(4, (len(I) - 1, center_j - 1)), (4, (len(I) - 1, center_j + 1))}
  
  # Add the new object to the grid
  O = paint(I, new_object)
  return O
 
1.6666666666666667, tensor(0.5127), Description: Find the topmost colored shape in the input grid. Place two yellow squares in the bottom row of the grid, one square to the left of the topmost shape's leftmost square and the other square two squares to the right of the first yellow square. 
:: def cbdhadgadaccedfajdjejjgdgddeefed(I):
  # Find the top left corner of the top object
  corner = ulcorner(first(objects(I, T, F, T)))
  
  # Place the first '4' relative to the corner
  first_four = (len(I) - 1, corner[1] - 1)  
  
  # Place the second '4' two steps to the right
  second_four = add(first_four, (0, 2))  
  
  # Combine the new cells into an object
  new_object = recolor(4, frozenset({first_four, second_four})) 
  
  # Paint the new object onto the input grid
  O = paint(I, new_object)
  return O
 
3.6666666666666665, tensor(0.5122), Description: Find the leftmost colored shape in the input grid. Place two yellow squares in the bottom row of the grid, one square directly below the leftmost square of the shape and the other square two squares to the right of the first yellow square. 
:: def chfdhddcdgiaeebabdeacdedhbbddfga(I):
  # Partition the grid into objects
  objs = objects(I, T, F, T) 
  
  # Find the object with the smallest column index (leftmost)
  leftmost_obj = argmin(objs, leftmost)
  
  # Get the column index of the leftmost object's leftmost cell 
  target_j = leftmost(leftmost_obj) 
  
  # Create a new object with two '4's on the bottom row
  new_obj = {(4, (len(I) - 1, target_j)), (4, (len(I) - 1, target_j + 2))}
  
  # Paint the new object onto the input grid
  O = paint(I, new_obj) 
  return O
 
8.333333333333334, tensor(0.4243), Description: Find the topmost colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, centered horizontally on the topmost shape. The squares should be two squares apart. 
:: def ijjcbfddibahefibbgaiidcedafdfhch(I):
  # Find the uppermost object in the grid
  top_object = first(objects(I, T, F, T))
  
  # Calculate the width of the grid
  grid_width = len(I[0])
  
  # Create a new row filled with '0's
  new_row = (0,) * grid_width
  
  # Calculate the center index for the '4's
  center_index = leftmost(top_object) + width(top_object) // 2
  
  # Place the '4's in the new row
  new_row = new_row[:center_index-1] + (4, 0, 4) + new_row[center_index+2:]  
  
  # Concatenate the input grid with the new row
  O = vconcat(I, (new_row,))  
  return O
 
5.666666666666667, tensor(1.9819), Description: Find the rightmost column in the input grid that contains at least one non-black square. Replace all the black squares in that column with yellow. 
:: def jbjdabhgcaadechajejaigfdbjgaccce(I):
  # Find the rightmost column with a non-zero element
  target_col = max([j for j in range(width(I)) if any(I[i][j] != 0 for i in range(height(I)))], default=0)
  # Replace zeros in the target column with 4
  O = tuple(
      tuple(
          4 if j == target_col and I[i][j] == 0 else I[i][j] 
          for j in range(width(I))
      ) 
      for i in range(height(I))
  )
  return O
 
5.666666666666667, tensor(1.9819), Description: Find the leftmost column in the input grid that contains at least one non-black square. Replace all the black squares in that column with yellow. 
:: def ijgadfffdacaeahajijfdhbbgcccbehb(I):
  # Reverse the grid horizontally
  reversed_grid = hmirror(I)
  # Find the first column with any non-zero element
  target_col = next((j for j, col in enumerate(zip(*reversed_grid)) if any(col)), 0)
  # Modify the target column in the reversed grid
  modified_grid = tuple(
      tuple(
          4 if j == target_col and reversed_grid[i][j] == 0 else reversed_grid[i][j]
          for j in range(width(I))
      )
      for i in range(height(I))
  )
  # Reverse back to original orientation
  O = hmirror(modified_grid)
  return O
 
2.6666666666666665, tensor(1.9847), Description: Replace the rightmost black square in the bottom row with yellow. 
:: def jhegbeejbcececgeabejbceebcaiecbb(I):
  # Get indices of all zeros in the last row
  zero_indices = frozenset((height(I) - 1, j) for j in range(width(I)) if I[height(I) - 1][j] == 0)
  # Find the rightmost zero index
  target_index = max(zero_indices, key=lambda x: x[1], default=(0, 0))
  # Replace zeros in the target column with 4
  O = fill(I, 4, frozenset({target_index})) 
  return O
 
2.6666666666666665, tensor(1.9047), Description: Replace all the black squares in the bottom row with yellow, starting from the leftmost black square and going right, until you reach a non-black square. 
:: def ecjabifjgaeeeebeibbdcdbcbfciegde(I):
  # Get the last row of the grid
  last_row = I[height(I)-1]
  # Find the index of the last non-zero element
  last_non_zero_index =  max((j for j, x in enumerate(last_row) if x != 0), default=0)
  # Create a patch for the target column
  target_patch = frozenset((height(I)-1, j) for j in range(last_non_zero_index+1) if I[height(I)-1][j] == 0)
  # Fill the target patch with '4'
  O = fill(I, 4, target_patch)
  return O
 
4.333333333333333, tensor(1.7290), Description: For each colored shape in the input grid, find the leftmost and rightmost squares in the bottom row of the shape. Fill those two squares with yellow. 
:: def gdbaebbjbcfcecidbcdbjibicbebaeaj(I):
    objs = objects(I, univalued=False, diagonal=True, without_bg=True)
    for obj in objs:
        left_idx = (height(I) - 1, leftmost(obj))
        right_idx = (height(I) - 1, rightmost(obj))
        I = fill(I, 4, {left_idx})
        I = fill(I, 4, {right_idx})
    return I
 
8.333333333333334, tensor(0.5093), Description: Find the leftmost non-black square in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the found index and the other square to the right of the found index. 
:: def fbgbahajhjbbeefhbfciccadeiejiaaj(I):
  # Find the index of the first non-zero value in the top row
  j = next((j for j, v in enumerate(I[0]) if v != 0), 0) 
  
  # Create a new bottom row with two '4's flanking the found index
  new_bottom_row = tuple(4 if k in (j - 1, j + 1) else 0 for k in range(len(I[0])))
  
  # Concatenate the original grid with the new bottom row
  O = vconcat(I, (new_bottom_row,))
  return O
 
1.6666666666666667, tensor(0.5110), Description: Find the leftmost colored shape in the input grid. Place two yellow squares in the bottom row of the grid, one square to the left of the leftmost square of the shape and the other square to the right of the first yellow square.  The original grid should be preserved. 
:: def aeecfdcicdceejfhjhbdghbeafaadfhh(I):
  # Find the leftmost object without considering background
  obj = first(objects(I, T, F, T))

  # Get the column index of the top-left corner of this object
  j = ulcorner(obj)[1] 

  # Create a canvas of '0's with the same dimensions as the input
  O = canvas(0, shape(I)) 

  # Fill the bottom-left and bottom-right positions relative to the object with '4's
  O = fill(O, 4, {(len(I)-1, j-1), (len(I)-1, j+1)}) 
  
  # Paint the original grid over this canvas to preserve the original objects
  O = paint(O, asobject(I))
  return O
 
8.333333333333334, tensor(0.5049), Description: Find the leftmost non-black square in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the found index and the other square mirrored across the center of the grid. 
:: def edjdjfdfhabgecbfjcfeeaabhbafjchd(I):
  # Find the horizontal position of the first non-zero value in the top row
  j = next((j for j, v in enumerate(I[0]) if v != 0), len(I[0]) // 2)

  # Create a new bottom row by mirroring a single '4' across the center
  new_bottom_row = tuple(4 if k == j - 1 or k == len(I[0]) - j else 0 for k in range(len(I[0])))

  # Concatenate the original grid with the new bottom row
  O = vconcat(I, (new_bottom_row,))
  return O
 
4.0, tensor(1.9819), Description: Find the rightmost column in the input grid that contains at least one non-black square. Replace all the black squares in that column with yellow, alternating between yellow and black squares. 
:: def ehehfabcbdgeeiaejcfdeeeebdigcbgd(I):
    # Find the rightmost non-empty column
    target_col = max(j for j in range(width(I)) if any(I[i][j] != 0 for i in range(height(I))))
    # Generate a pattern of 4 and 0s
    pattern = tuple(4 if i % 2 == 0 else 0 for i in range(height(I)))
    # Replace the target column with the pattern, only where the original value is 0
    O = tuple(tuple(pattern[i] if j == target_col and I[i][j] == 0 else I[i][j] for j in range(width(I))) for i in range(height(I)))
    return O
 
3.3333333333333335, tensor(1.7112), Description: For each colored shape in the input grid, find the columns that contain at least one square of the shape. Fill the squares in the bottom row of those columns with yellow. 
:: def efiddjgbafcfeahbidbddcdeaddjhgda(I):
    bottom_row_indices = {(height(I) - 1, j) for j in range(width(I))}
    object_indices = mapply(toindices, objects(I, univalued=False, diagonal=True, without_bg=True))
    marker_cols = {j for i, j in object_indices if any((row, j) in object_indices for row in range(height(I)))}
    marker_indices = {(height(I) - 1, j) for j in marker_cols}
    return fill(I, 4, marker_indices & bottom_row_indices)
 
3.6666666666666665, tensor(1.7251), Description: Find the leftmost and rightmost columns in the input grid that contain at least one non-black square. Fill the squares in the bottom row of those columns with yellow. 
:: def djfffhfcdebbecfdjijaicedacbdecbj(I):
    def mark_edges(grid):
        leftmost_col = next((j for j in range(width(grid)) if any(grid[i][j] != mostcommon(grid) for i in range(height(grid)))), None)
        rightmost_col = next((j for j in range(width(grid) - 1, -1, -1) if any(grid[i][j] != mostcommon(grid) for i in range(height(grid)))), None)
        return {(height(grid) - 1, leftmost_col), (height(grid) - 1, rightmost_col)}
    
    return fill(I, 4, mark_edges(I))
 
5.0, tensor(1.7213), Description: Find the columns in the input grid that contain at least one non-black square. Fill the squares in the bottom row of those columns with yellow. 
:: def haebcbhhffehefdhjjafccbfdbdbgdff(I):
    def is_object_col(j):
        return any(I[i][j] != mostcommon(I) for i in range(height(I)))
    
    marker_indices = {(height(I) - 1, j) for j in range(width(I)) if is_object_col(j)}
    return fill(I, 4, marker_indices)
 
2.3333333333333335, tensor(1.7529), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, centered horizontally on the input grid. The squares should be one square apart. 
:: def fhjdbceaecihefjfbjeagigdcedcicdd(I):
  h = height(I)  
  w = width(I)
  mid = w // 2
  O = vconcat(I[:-1], (tuple(4 if j in {mid - 1, mid} else I[h - 1][j] for j in range(w)),))
  return O
 
4.0, tensor(1.9819), Description: Find the last row in the input grid that contains at least one non-black square. Replace all the black squares in the second-to-last row with yellow, alternating between yellow and black squares. 
:: def ccedicdbcffeefaeahdcgabeegcafbbb(I):
  # Find the index of the last non-empty row
  last_non_empty_row = max([i for i, row in enumerate(I) if any(row)], default=0)
  # Calculate the index of the second-to-last non-empty row
  target_row = last_non_empty_row - 1 if last_non_empty_row > 0 else 0
  # Modify the target row
  modified_row = tuple(
      4 if I[target_row][j] == 0 and j % 2 == 0 else I[target_row][j]
      for j in range(width(I))
  )
  # Construct the output grid
  O = tuple(
      modified_row if i == target_row else I[i]
      for i in range(height(I))
  )
  return O
 
8.333333333333334, tensor(0.4931), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, symmetrically around the center column. The squares should be two squares apart. 
:: def ddbbbibfjgbjeijhbcbbaehbaeidhefe(I):
  # Find the center column of the grid
  center_j = len(I[0]) // 2
  
  # Create a new row filled with '0's
  new_row = (0,) * len(I[0])
  
  # Place '4's symmetrically around the center column
  new_row = new_row[:center_j-1] + (4, 0, 4) + new_row[center_j+2:]
  
  # Concatenate the input grid with the new row
  O = vconcat(I, (new_row,))
  return O
 
8.333333333333334, tensor(0.5107), Description: Find the leftmost and rightmost non-black squares in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center column between the leftmost and rightmost squares and the other square to the right of the center column. 
:: def fiaddgebfachedihaiifaecadbajcjbc(I):
  # Find the leftmost and rightmost non-zero values in the top row
  leftmost_j = next((j for j, v in enumerate(I[0]) if v != 0), 0)
  rightmost_j = len(I[0]) - next((j for j, v in enumerate(I[0][::-1]) if v != 0), 0) - 1
  
  # Calculate the center column
  center_j = (leftmost_j + rightmost_j) // 2

  # Create the new bottom row
  new_row = tuple(4 if j == center_j - 1 or j == center_j + 1 else 0 for j in range(len(I[0])))

  # Concatenate the original grid with the new bottom row
  O = vconcat(I, (new_row,))
  return O
 
3.0, tensor(0.2135), Description: Replace the middle two squares in the bottom row with yellow. 
:: def aigdifbdciifebfejdfcjaadhchhcahc(I):
  w = width(I)
  mid = w // 2
  O = I[:-1] + (tuple(v if j != mid and j != mid + 1 else 4 for j, v in enumerate(I[-1])),)
  return O
 
4.0, tensor(1.9819), Description: Find the first non-empty row from the bottom of the input grid. Replace all the black squares in that row with yellow, alternating between yellow and black squares. 
:: def acgdcedjecbjebgcafdeefdafhhcfbba(I):
  # Find the target row index (first non-empty row from the bottom)
  target_row_index = max([i for i in range(height(I)) if any(I[i])], default=0) 
  # Extract the target row
  target_row = I[target_row_index]
  # Create a mirrored and modified bottom row
  bottom_row = tuple(4 if j % 2 == 0 and target_row[j] == 0 else target_row[j] for j in range(width(I)))
  # Construct the output grid by replacing the bottom row
  O = I[:height(I)-1] + (bottom_row,) 
  return O
 
3.0, tensor(1.7156), Description: For each colored square in the top row of the input grid, if there is at least one other colored square in the same column below it, fill the square in the bottom row of that column with yellow. 
:: def dajbdhcahiahebidaedhffhfbbhagbhd(I):
  marked_grid = I
  for j in range(width(I)):
    for i in range(height(I)):
      if I[i][j] != 0 and i == 0:
        if any(I[k][j] != 0 for k in range(i+1, height(I))):
          marked_grid = fill(marked_grid, 4, {(height(I) - 1, j)})
  return marked_grid 
 
8.333333333333334, tensor(0.5093), Description: Find the leftmost non-black square in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the found index and the other square to the right of the found index. 
:: def aaedbdijdjaaebcbjbchejhhehffaace(I):
  # Calculate the average x-coordinate of all non-background cells in the top row
  top_row_indices = [(0, j) for j in range(len(I[0])) if I[0][j] != mostcommon(I)]
  center_j = sum(j for i, j in top_row_indices) // len(top_row_indices) if top_row_indices else len(I[0]) // 2

  # Create a new row with '4's placed symmetrically around the center
  new_row = tuple(4 if j == center_j - 1 or j == center_j + 1 else 0 for j in range(len(I[0])))

  # Concatenate the new row to the input grid
  O = vconcat(I, (new_row,))
  return O
 
8.333333333333334, tensor(0.5107), Description: Find the leftmost and rightmost non-black squares in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center column between the leftmost and rightmost squares and the other square to the right of the center column. 
:: def cjeajeaajhbcegjdajcebfiibcfaibif(I):
  # Find the leftmost and rightmost non-zero elements in the top row
  leftmost_j = next((j for j, v in enumerate(I[0]) if v != 0), len(I[0]))
  rightmost_j = len(I[0]) - next((j for j, v in enumerate(I[0][::-1]) if v != 0), 0)
  
  # Calculate the center index
  center_j = (leftmost_j + rightmost_j) // 2 

  # Create the new row
  new_row = tuple(4 if j == center_j - 1 or j == center_j + 1 else 0 for j in range(len(I[0])))

  # Concatenate the input grid with the new row
  O = vconcat(I, (new_row,))
  return O
 
3.6666666666666665, tensor(1.7858), Description: For each colored shape in the input grid, find the leftmost and rightmost squares in the bottom row of the shape. Fill those two squares with yellow. 
:: def hacfedfaffggeedhjhbdgfjffifgbafc(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lowermost)
  left_j = leftmost(target_obj)
  right_j = rightmost(target_obj)
  bottom_i = height(grid) - 1
  markers = {(bottom_i, left_j), (bottom_i, right_j)}
  return paint(grid, recolor(4, markers)) 
 
3.3333333333333335, tensor(1.9821), Description: Replace all the black squares in the bottom row with yellow, unless there is a non-black square in the same column above it. 
:: def cgcddabfaagaedhabgbbbaacdfbeddhf(grid):
  bottom_row = grid[-1]
  modified_row = tuple(
    4 if any(grid[i][j] != 0 for i in range(height(grid) - 1)) else v 
    for j, v in enumerate(bottom_row)
  )
  return (*grid[:-1], modified_row)
 
3.0, tensor(1.7672), Description: Find the colored shape in the input grid that has the smallest combined value of its topmost row and its height. Fill the entire bottom row of that shape with yellow. 
:: def dgjiiaeibdefeacjijbddbecchbeehbg(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmin(objs, lambda obj: uppermost(obj) + height(obj))
  return paint(grid, recolor(4, {(height(grid) - 1, j) for j in range(leftmost(target_obj), rightmost(target_obj) + 1)}))
 
3.6666666666666665, tensor(1.7929), Description: Find the first non-empty row from the bottom of the input grid. Fill the leftmost and rightmost non-black squares in that row with yellow. 
:: def idibehjchifdegghadffchffafgceech(grid):
  for i in range(height(grid)-1, -1, -1):
    if any(v != 0 for v in grid[i]):
      target_row = i
      break
  left_j = next((j for j, v in enumerate(grid[target_row]) if v != 0), 0)
  right_j = max((j for j, v in enumerate(grid[target_row]) if v != 0), default=0)
  return fill(grid, 4, {(height(grid) - 1, left_j), (height(grid) - 1, right_j)})
 
6.666666666666667, tensor(1.9831), Description: For each colored shape in the input grid, find the horizontal center of the shape.  Fill all the squares in the bottom row of the grid with yellow, except for the square directly below the center of each shape. 
:: def eaieffjdfcegeachbghifjjagdbbfhcd(I):
  def gap_indices(obj):
    w = width(obj)
    center_j = leftmost(obj) + (w // 2) - (1 if even(w) else 0)
    return frozenset({(len(I) - 1, center_j)})
  all_gaps = mapply(gap_indices, objects(I, T, F, T))
  full_line = frozenset({(len(I) - 1, j) for j in range(len(I[0]))})
  line_with_gaps = difference(full_line, all_gaps)
  return fill(I, 4, line_with_gaps)
 
1.6666666666666667, tensor(1.9826), Description: For each colored shape in the input grid, find the leftmost square of the shape. Fill all the squares in the bottom row of the grid with yellow, except for the squares that are directly below the leftmost square of each shape. The original grid should be preserved. 
:: def ccdadfegjebjeacdjjfjdecaccbgbfch(I):
  def line_segment(obj):
    w = width(obj)
    start = (len(I) - 1, leftmost(obj))
    return frozenset({(start[0], j) for j in range(start[1], start[1] + w)})
  all_segments = mapply(line_segment, objects(I, T, F, T))
  line_with_gaps = difference(frozenset({(len(I) - 1, j) for j in range(len(I[0]))}), merge(all_segments))
  return paint(fill(I, 4, line_with_gaps), asobject(I))
 
0.0, tensor(0.4124), Description: Find the leftmost and rightmost colored shapes in the input grid. Place two yellow squares in the bottom row of the grid, centered horizontally on each of these shapes. The original grid should be preserved. 
:: def fjbceaaaaegeebgfbfcdaeahebeaaace(I):
  # Identify all non-background objects
  objs = objects(I, T, F, T)

  # Find the leftmost and rightmost objects
  leftmost_obj = argmin(objs, leftmost)
  rightmost_obj = argmax(objs, rightmost)

  # Calculate marker positions
  left_marker = (len(I) - 1, leftmost(leftmost_obj) + width(leftmost_obj) // 2)
  right_marker = (len(I) - 1, leftmost(rightmost_obj) + width(rightmost_obj) // 2)

  # Create markers 
  markers = { (4, left_marker), (4, right_marker) }

  # Paint markers onto the original grid
  O = paint(I, markers)
  return O
 
3.6666666666666665, tensor(1.5349), Description: Find the leftmost and rightmost non-black squares in the input grid. Fill the squares in the bottom row of those columns with yellow. 
:: def bdjiadfjfgfjefegjcghdefbidgabdaa(I):
  # Directly find the leftmost and rightmost occupied columns
  leftmost_col = min(j for i, r in enumerate(I) for j, v in enumerate(r) if v != mostcolor(I))
  rightmost_col = max(j for i, r in enumerate(I) for j, v in enumerate(r) if v != mostcolor(I))

  # Calculate marker positions
  left_marker = (len(I) - 1, leftmost_col)
  right_marker = (len(I) - 1, rightmost_col)

  # Create and paint markers in a single step
  O = fill(I, 4, {left_marker, right_marker})
  return O
 
3.0, tensor(0.9428), Description: Replace the middle and rightmost squares in the bottom row with yellow. 
:: def edfcfeacibcfebibjgefhaijdfajbdic(I):
  w = width(I)
  mid = w // 2
  O = I[:-1] + (tuple(4 if (j == mid or j == w - 1) and v == 0 else v for j, v in enumerate(I[-1])),)
  return O
 
31.333333333333332, tensor(1.1730), Description: Replace all black squares with yellow. Then, replace the middle square in the bottom row with yellow. 
:: def ejedcefdddhbecegiccbbabgejcgefeg(I):
  w = width(I)
  mid = w // 2
  O = replace(I, 0, 4) 
  O = O[:-1] + (tuple(4 if j == mid else v for j, v in enumerate(O[-1])),)
  return O
 
8.0, tensor(0.2861), Description: Replace the rightmost black square in the bottom row of the left half of the grid with yellow. 
:: def ffdfjdciaadbeacjaffhidhcegfcdfeh(I):
  w = width(I)
  mid = w // 2
  left, right = hsplit(I, 2)
  left = left[:-1] + (left[-1][:-1] + (4,),)
  O = hconcat(left, right)
  return O
 
2.0, tensor(1.9819), Description: Find the second-to-last row in the input grid. Replace all the black squares in that row with yellow, alternating between yellow and black squares. The bottom row should remain black. 
:: def debfdiacbbbeechdijffbfcfifdceeif(I):
  # Extract the second to last row
  penultimate_row = I[-2]
  # Create the modified bottom row
  bottom_row = tuple(4 if j % 2 == 0 and penultimate_row[j] == 0 else 0 for j in range(width(I)))
  # Construct the output grid by replacing the bottom row
  O = I[:-1] + (bottom_row,)
  return O
 
6.0, tensor(0.5095), Description: Find the topmost colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center of the shape and the other square to the right of the center of the shape. The squares should be two squares apart. 
:: def faggdehaaedaeaedibcaacbjdadiieci(I):
  obj = next((o for o in objects(I, T, F, T) if uppermost(o) == 0), None)
  if obj is None:
    return I  # Handle cases where no object is found at the top
  center_index = (leftmost(obj) + rightmost(obj)) // 2
  new_row = tuple(4 if j in (center_index - 1, center_index + 1) else 0 for j in range(len(I[0])))
  return vconcat(I, (new_row,))
 
3.3333333333333335, tensor(0.1002), Description: For each colored shape in the input grid, find the center square in the bottom row of the shape. Fill that square with yellow. 
:: def acefceafbecbecceiebafbfaccegfaee(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    w = width(obj)
    mid = w // 2
    bottom_row = max(i for i, j in toindices(obj))
    O = fill(O, 4, frozenset({(bottom_row, leftmost(obj) + mid)})) 
  return O
 
3.0, tensor(0.9388), Description: Copy the input grid and fill it with the most common color. Then, for each colored shape in the input grid, find the horizontal center of the shape and fill the square in the bottom row of the grid that is directly below the center with yellow. 
:: def bfbdcdddedebeeggbgecejeffeaabeaf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    c = centerofmass(obj)[1]
    bottom = max(i for i, j in toindices(obj))
    O = fill(paint(O, obj), 4, {(bottom, c)})
  return O
 
2.6666666666666665, tensor(1.1759), Description: For each colored shape in the input grid, if the shape has an odd number of columns and the current column is the center column of the shape, fill the square in that column with yellow. 
:: def bdbdjbfcjehbeadabgeacgehjageeaci(I):
  h, w = shape(I)
  O = I
  for j in range(w):
    for i in range(h - 1, -1, -1): 
      if I[i][j] != mostcolor(I):
        obj = extract(objects(I, False, False, True), lambda obj: (i, j) in toindices(obj))
        if width(obj) % 2 == 1 and j == leftmost(obj) + width(obj) // 2:
          O = fill(O, 4, {(i, j)})
        break
  return O
 
3.6666666666666665, tensor(1.7810), Description: Find the colored shape in the input grid that has the largest value when subtracting 0.1 times its topmost row from its width. Fill the leftmost and rightmost squares in the bottom row of that shape with yellow. 
:: def cgieffahechgedcbbeaefcjajgahadbc(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lambda obj: width(obj) - 0.1 * uppermost(obj)) 
  left_corner = llcorner(target_obj)
  right_corner = lrcorner(target_obj)
  markers = {left_corner, right_corner}
  return paint(grid, recolor(4, markers))
 
3.6666666666666665, tensor(1.7824), Description: Find the colored shape in the input grid that has the largest width, and if multiple shapes have the same width, choose the one with the smallest topmost row.  Fill the leftmost and rightmost squares in the top row of that shape with yellow. 
:: def ddececfcbeijeeaajhhjdbgdfbgdecab(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lambda o: (-uppermost(o), width(o)))
  offset = (height(grid) - 1 - lowermost(target_obj), 0)
  shifted_obj = shift(target_obj, offset)
  markers = {(0, leftmost(shifted_obj)), (0, rightmost(shifted_obj))}
  return paint(grid, recolor(4, markers))
 
3.6666666666666665, tensor(1.7823), Description: Find the colored shape in the input grid that has the largest width, and if multiple shapes have the same width, choose the one with the smallest topmost row. Fill the leftmost and rightmost squares in the bottom row of that shape with yellow. 
:: def faegaegfeaedebaeijbahcffejdcaedj(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = max(objs, key=lambda obj: (width(obj), -uppermost(obj)))
  bottom_row_index = lowermost(target_obj)
  bottom_row = {(v, (i, j)) for v, (i, j) in target_obj if i == bottom_row_index}
  corner_indices = {llcorner(bottom_row), lrcorner(bottom_row)}
  return paint(grid, recolor(4, corner_indices)) 
 
39.666666666666664, tensor(1.9920), Description: Replace all the black squares in the second-to-last row with yellow, unless there is a non-black square in the same column above it. 
:: def cadgcdcbcaceeaiiiaefdeehfiigbghd(I):
  last_row = I[height(I)-1] # Extract the last row
  target_row = height(I) - 2 # Calculate target row index
  return  tuple(tuple(4 if j in {idx for idx, val in enumerate(last_row) if val != mostcommon(I)} else I[i][j] for j in range(width(I))) for i in range(height(I)))
 
8.333333333333334, tensor(1.9920), Description: Replace all the black squares in the second-to-last row with yellow, unless there is a non-black square in the same column above it. 
:: def ahacdjhaccidehdiifgcaadefhffeacd(I):
    marker_indices = frozenset((height(I) - 2, j) for j in range(width(I)) if I[height(I) - 1][j] != mostcommon(I))
    return fill(I, 4, marker_indices) 
 
2.3333333333333335, tensor(1.4990), Description: Replace the middle and rightmost squares in the bottom row with yellow. If the width of the grid is odd, replace the middle square and the square to the right of the middle square with yellow. If the width of the grid is even, replace the middle square and the square to the right of the middle square with yellow. 
:: def hddjegcadgieebjdiebjdcdeabefdaha(I):
  w = width(I)
  mid = w // 2
  O = I[:-1] + (tuple(4 if j == mid or j == w - 1 - (w % 2) else v for j, v in enumerate(I[-1])),)
  return O
 
3.6666666666666665, tensor(1.7837), Description: Find the colored shape in the input grid that has the largest width, and if multiple shapes have the same width, choose the one with the largest bottommost row. Fill the leftmost and rightmost squares in the top half of that shape with yellow. 
:: def eeggdidcadbfeeebibadffcccbhbieag(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lambda obj: (width(obj), lowermost(obj)))
  target_indices = toindices(target_obj)
  half_height = height(target_indices) // 2
  bottom_indices = sfilter(target_indices, lambda loc: loc[0] >= uppermost(target_indices) + half_height)
  markers = frozenset({
      (uppermost(bottom_indices), leftmost(bottom_indices)),
      (uppermost(bottom_indices), rightmost(bottom_indices))
  })
  return paint(grid, recolor(4, markers))
 
3.6666666666666665, tensor(1.9918), Description: Find the colored shape in the input grid that has the largest width, and if multiple shapes have the same width, choose the one with the largest bottommost row. Fill the squares in the bottom half of that shape with yellow, except for the squares that are the same color as the background. 
:: def dibcbcacedijejhbbedfcbdiahdaaaab(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lambda obj: (width(obj), lowermost(obj)))
  target_grid = subgrid(target_obj, grid)
  bottom_grid = bottomhalf(target_grid)
  i = 0
  markers = frozenset()
  for j in range(width(bottom_grid)):
    if bottom_grid[i][j] != mostcolor(grid):
      markers = markers | {(i, j)}
  return paint(grid, recolor(4, shift(markers, ulcorner(target_obj))))
 
3.6666666666666665, tensor(1.7929), Description: Find the first non-empty row from the bottom of the input grid. Fill the leftmost and rightmost non-black squares in that row with yellow. 
:: def cabhcdffiahdeaacbefdcfbbjhehacea(grid):
  for i in range(height(grid)-1, -1, -1):
    row = grid[i]
    if any(v != mostcolor(grid) for v in row):
      target_row = i
      break
  leftmost_j = next(j for j, v in enumerate(grid[target_row]) if v != mostcolor(grid))
  rightmost_j = len(grid[target_row]) - next(j for j, v in enumerate(grid[target_row][::-1]) if v != mostcolor(grid)) - 1
  markers = {(target_row, leftmost_j), (target_row, rightmost_j)}
  return paint(grid, recolor(4, markers))
 
2.3333333333333335, tensor(0.5079), Description: Find the topmost colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, starting at the leftmost square of the shape and extending to the right for the width of the shape. The original grid should be preserved. 
:: def bhcbfdcjfeecehafbiccffbfdaccfcib(I):
  # Find the topmost object in the grid
  obj = first(objects(I, T, F, T))
  
  # Get the width of the object
  obj_width = width(obj)
  
  # Calculate the starting column for placing the '4's
  start_j = (len(I[0]) - obj_width) // 2 

  # Create a new object with '4's at the bottom row
  new_obj = recolor(4, {(len(I)-1, start_j), (len(I)-1, start_j + obj_width - 1)})
  
  # Paint the new object onto the input grid
  O = paint(I, new_obj)
  return O
 
3.6666666666666665, tensor(1.7929), Description: Find the first non-empty row from the bottom of the input grid. Fill the leftmost and rightmost non-black squares in that row with yellow. 
:: def ffgdjgidgefaeeciahejcedecadddbeb(grid):
  for i in range(height(grid)-1, -1, -1):
    if any(v != mostcommon(grid) for v in grid[i]):
      target_row = i
      break
  left_j = next((j for j, v in enumerate(grid[target_row]) if v != mostcommon(grid)), 0)
  right_j = max((j for j, v in enumerate(grid[target_row]) if v != mostcommon(grid)), default=0)
  return fill(grid, 4, {(height(grid) - 1, left_j), (height(grid) - 1, right_j)})
 
1.6666666666666667, tensor(1.7797), Description: Find the colored shape in the input grid that has the largest bottommost row. Fill the leftmost and rightmost non-black squares in the bottom row of that shape with yellow. 
:: def icecgeeicfagegddifbiefefcfjfgdbf(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  target_obj = argmax(objs, lambda obj: lowermost(obj))
  target_row = bottomhalf(subgrid(target_obj, grid))[0] 
  left_j = next((j for j, v in enumerate(target_row) if v != mostcommon(grid)), 0)
  right_j = max((j for j, v in enumerate(target_row) if v != mostcommon(grid)), default=0)
  return fill(grid, 4, {(height(grid) - 1, left_j), (height(grid) - 1, right_j)})
 
2.6666666666666665, tensor(1.7774), Description: For each colored shape in the input grid, find the center square in the second-to-last row of the shape. Fill that square with yellow. 
:: def ejbdccchfadeecbbifcedcdfebdfgbia(I):
  def mark_center(obj):
    j_min, j_max = leftmost(obj), rightmost(obj)
    return (lowermost(obj) + 1, (j_min + j_max) // 2)

  objs = objects(I, T, F, T)
  center_points = apply(mark_center, objs)
  return fill(I, 4, frozenset(center_points))
 
2.3333333333333335, tensor(0.4755), Description: Find the topmost colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square directly below the leftmost square of the shape and the other square mirrored across the center of the grid. The original grid should be preserved. 
:: def fefbaidchefeefedieaeabhgjeddbcjd(I):
  # Get the indices of the topmost object
  obj_indices = toindices(first(objects(I, T, F, T)))

  # Find the leftmost and rightmost column indices of the object
  left_j = minimum(apply(lambda x: x[1], obj_indices))
  right_j = maximum(apply(lambda x: x[1], obj_indices))

  # Calculate the column indices for the '4's
  new_left_j = left_j
  new_right_j = right_j + (len(I[0]) - right_j - 1) - (left_j - 0) 

  # Construct the new object with '4's
  new_obj = recolor(4, {(len(I) - 1, new_left_j), (len(I) - 1, new_right_j)})

  # Paint the new object onto the input grid
  O = paint(I, new_obj)
  return O
 
2.3333333333333335, tensor(0.4384), Description: Find the leftmost and rightmost non-black squares in the top row of the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square directly below the leftmost square of the shape and the other square mirrored across the center of the grid. The original grid should be preserved. 
:: def cfcfceidihaaechfbbehbiecfjjfibbf(I):
  # Directly find the indices of the leftmost and rightmost non-zero elements in the top row
  left_j = next((j for j, v in enumerate(I[0]) if v != 0), len(I[0]))
  right_j = len(I[0]) - next((j for j, v in enumerate(I[0][::-1]) if v != 0), 0) - 1

  # Calculate the column indices for the '4's on the bottom row
  new_left_j = left_j
  new_right_j = right_j + (len(I[0]) - right_j - 1) - (left_j - 0)

  # Construct the new object with '4's
  new_obj = recolor(4, {(len(I) - 1, new_left_j), (len(I) - 1, new_right_j)})

  # Paint the new object onto the input grid
  O = paint(I, new_obj)
  return O
 
5.0, tensor(1.7262), Description: For each colored shape in the input grid, find the leftmost and rightmost black squares in the bottom row of the shape. Fill those two squares with yellow. 
:: def agiaifbjdaacecddiiefbbadgdhieaee(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  indices = set()
  for obj in objs:
    bottom_row = lowermost(obj)
    row_indices = frozenset((bottom_row, j) for j in range(width(I)))
    leftmost_zero = extract(order(intersection(row_indices, asindices(I)), lambda x: x[1]), lambda x: I[x[0]][x[1]] == 0)
    rightmost_zero = extract(order(intersection(row_indices, asindices(I)), lambda x: -x[1]), lambda x: I[x[0]][x[1]] == 0)
    indices.add(leftmost_zero)
    indices.add(rightmost_zero)
  O = fill(I, 4, frozenset(indices))
  return O
 
7.666666666666667, tensor(1.7374), Description: For each row in the input grid, find the leftmost and rightmost black squares. Fill those two squares with yellow. 
:: def gdcacbfdijedefifidhgccddgafbeefd(I):
  O = I
  for i in range(height(I)):
    row = I[i]
    if any(v != 0 for v in row):
      leftmost_zero = next((j for j, v in enumerate(row) if v == 0), None)
      rightmost_zero = next((len(row) - j - 1 for j, v in enumerate(row[::-1]) if v == 0), None)
      if leftmost_zero is not None:
        O = fill(O, 4, frozenset({(i, leftmost_zero)}))
      if rightmost_zero is not None:
        O = fill(O, 4, frozenset({(i, rightmost_zero)}))
  return O
 
5.0, tensor(0.0788), Description: For each colored shape in the input grid, fill the leftmost and rightmost squares in the bottom row of the shape with yellow. 
:: def fgbdccdebbahecaajcdfieeaajafjbaf(I):
  objs = objects(I, T, F, T) 
  h = height(I)
  out = I
  for obj in objs:
    left = leftmost(obj)
    right = rightmost(obj)
    out = fill(out, 4, {(h-1, left), (h-1, right)}) 
  return out
 
8.333333333333334, tensor(0.0085), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, centered horizontally on the input grid. The squares should be one square apart. 
:: def ehidjdbdibfbejfhiaccadggbdefdfij(I):
  w = width(I)  # Get the width of the input grid
  new_row = tuple(4 if j in {w // 2 - 1, w // 2} else 0 for j in range(w)) # Create new row with 4s at center
  return vconcat(I, (new_row,)) # Concatenate input grid and the new row 
 
6.666666666666667, tensor(1.7972), Description: Find the color that appears the least often in the input grid, excluding the background color. Draw a horizontal line of that color across the bottom row of the grid. 
:: def ggdfecdcifjeeajabcbjbecdahecfegb(I):
  bg_color = mostcolor(I) 
  other_colors = difference(palette(I), {bg_color})
  target_color = leastcommon(totuple(other_colors))
  h = height(I)
  w = width(I)
  line = {(target_color, (h-1, j)) for j in range(w)}
  return paint(I, frozenset(line))
 
8.333333333333334, tensor(1.7972), Description: Find the color that appears the least often in the input grid, excluding the background color. Draw a horizontal line of that color across the bottom row of the grid. 
:: def bbcbjacffecaehfejebfjcafeaddaejf(I):
  non_bg_colors = [c for c in palette(I) if c != mostcolor(I)]
  target_color = min(non_bg_colors, key=non_bg_colors.count)
  new_row = [target_color for _ in range(width(I))]
  return tuple(list(row) for row in I) + (tuple(new_row),) 
 
3.6666666666666665, tensor(0.1796), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square directly below the leftmost square of the shape and the other square directly below the rightmost square of the shape. The original grid should be preserved. 
:: def hebggidcgdifeecejdecagiecfaigccg(I):
  obj = argmax(objects(I, False, False, True), size)
  bottom_row = lowermost(obj) + 1
  left_col = leftmost(obj) 
  right_col = rightmost(obj) 
  border = {(4, (bottom_row, left_col)), (4, (bottom_row, right_col))}
  O = paint(I, border)
  return O
 
4.333333333333333, tensor(1.5698), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Fill the squares in the new row that are directly below the shape with yellow. The original grid should be preserved. 
:: def dcieadieeciaebbbabddfdcdfbcggaaj(I):
  obj = argmax(objects(I, False, False, True), size)
  border_indices = {(lowermost(obj) + 1, j) for j in range(leftmost(obj), rightmost(obj) + 1)}
  border_obj = recolor(4, border_indices)
  O = underpaint(I, border_obj)
  return O
 
7.666666666666667, tensor(0.1740), Description: Copy the input grid. Then, for each non-black square in the bottom row, move that square one row down. The color of the square should remain the same. 
:: def bcjejaefjbgdehefaiciaegjafeehaif(I):
  x1 = bottomhalf(I)  # Extract the bottom row
  x2 = asindices(x1) # Get indices of bottom row
  x3 = sfilter(x2, lambda ij: I[ij[0]][ij[1]] != 0)  # Filter indices with non-zero values
  x4 = shift(x3, (1, 0)) # Shift indices one row down 
  O = fill(I, 4, x4) # Fill the shifted indices with '4'
  return O
 
10.666666666666666, tensor(0.1740), Description: Copy the input grid. Then, for each non-black square in the bottom row, move that square one row down. The color of the square should remain the same. 
:: def ebjaeafcjecjejbhiggibebddcecadhj(I):
  x1 = canvas(0, shape(I)) # Create a canvas of same shape as input, filled with '0's
  x2 = bottomhalf(I) # Extract the bottom row of the input grid
  x3 = asindices(x2) # Get indices of the bottom row
  x4 = sfilter(x3, lambda ij: x2[ij[0]][ij[1]] != 0) # Filter indices with non-zero values in the bottom row 
  x5 = apply(lambda ij: (ij[0]+1, ij[1]), x4) # Shift the filtered indices one row down
  O = fill(x1, 4, x5) # Fill '4' at the shifted indices in the canvas
  return O
 
8.333333333333334, tensor(0.0251), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center column and the other square to the right of the center column. The squares should be two squares apart. 
:: def becagcafdjjeegdbagdccdijefecjheh(I):
  return vconcat(I, ((lambda j: tuple(4 if abs(j - width(I) // 2) == width(I) // 4 else 0 for j in range(width(I))))(0),)) 
 
8.333333333333334, tensor(0.0246), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-quarter of the way from the left edge and the other square one-quarter of the way from the right edge. The squares should be two squares apart. 
:: def agdgddfdcgaaeaiiibdabegceddjabad(I):
  w = width(I)
  return vconcat(I, (tuple(4 if j in {w // 4, w - w // 4 - (1 if w % 4 else 0)} else 0 for j in range(w)),)) 
 
8.333333333333334, tensor(0.0249), Description: Find the color that appears the least often in the input grid, excluding the background color. Add a new row to the bottom of the grid. Place two squares of that color in the new row, one square in the leftmost column and the other square in the rightmost column. 
:: def ifadcajbfjeheggejfjajdaceahiicbh(I):
  bg = mostcolor(I)
  target_color = leastcommon([v for r in I for v in r if v != bg])
  new_row = [bg] * width(I)
  new_row[0] = new_row[-1] = target_color
  return I + (tuple(new_row),)
 
7.0, tensor(0.1274), Description: Add a new row to the bottom of the grid. Fill the new row with yellow squares. If the added row extends beyond the original grid, truncate it. 
:: def jidbdcdajbgfechcbddcadebjbaeceee(I):
  # Find the lowermost row index with non-zero elements
  row_index = max([i for i, row in enumerate(I) if any(row)])
  # Create a horizontal line of '4's with the same width as the input
  line = (4,) * len(I[0])
  # Insert the line one row below the identified row
  O = I[:row_index+1] + (line,) + I[row_index+1:]
  # If the added line extends beyond the original grid, truncate it
  return O[:len(I)]
 
15.333333333333334, tensor(0.1274), Description: Add a new row to the bottom of the grid. Fill the new row with yellow squares. If the added row extends beyond the original grid, truncate it. 
:: def fhiehdfeaiabefbhbhdbahfidcagidae(I):
    # Find the lowermost row containing a non-zero element
    lowermost_row = next((i for i, row in enumerate(I) if any(v != 0 for v in row)), len(I))
    # Create a new grid by adding a row of '4's below the lowermost row 
    O = I[:lowermost_row] + ((4,) * len(I[0]),) + I[lowermost_row:]
    # Return the new grid, truncated to the original size
    return O[:len(I)] 
 
17.0, tensor(0.1552), Description: Add a new column to the right of the grid. Fill the new column with yellow squares. If the added column extends beyond the original grid, truncate it. 
:: def iffcfdbbcdccebbdbccdbebbhbgbbecc(I):
  # Transpose the input grid
  transposed_grid = tuple(zip(*I))
  # Find the rightmost column index containing a non-zero element
  rightmost_col = next((j for j, col in enumerate(transposed_grid) if any(col)), len(transposed_grid[0]))
  # Create a new column of '4's with a height one greater than the input
  new_col = (4,) * (len(I) + 1)
  # Insert the new column to the right of the rightmost column
  O = transposed_grid[:rightmost_col+1] + (new_col,) + transposed_grid[rightmost_col+1:]
  # Transpose the grid back to its original orientation
  O = tuple(zip(*O))
  # Return the transposed grid, truncated to the original height
  return O[:len(I)]
 
16.666666666666668, tensor(0.1740), Description: Copy the input grid. Then, for each non-black square in the bottom row, move that square one row down. The color of the square should remain the same. 
:: def bicdjddhdebfejgbbbffhfjeajaijhcd(I):
  # 1. Find the height of the input grid.
  h = height(I)

  # 2. Extract the bottom row.
  bottom_row = I[h - 1]

  # 3. Find indices of non-zero values in the bottom row.
  non_zero_indices = frozenset((h - 1, j) for j, v in enumerate(bottom_row) if v != 0)

  # 4. Shift these indices one row down.
  shifted_indices = shift(non_zero_indices, DOWN)

  # 5. Fill '4' at the shifted indices.
  O = fill(canvas(0, (h + 1, width(I))), 4, shifted_indices)
  return O
 
17.333333333333332, tensor(0.1755), Description: Copy the input grid. Then, for each colored shape in the bottom row, move that shape one row down. The color of the shape should remain the same. 
:: def ibdeeceaaaabeegjbgfbjccdbcacaefc(I):
  # 1. Identify the objects in the bottom row
  objs = objects(bottomhalf(I), univalued=False, diagonal=False, without_bg=True) 

  # 2. Shift each object downwards
  shifted_objs = apply(lambda obj: shift(obj, DOWN), objs)

  # 3. Create a canvas for output
  O = canvas(0, (height(I)+1, width(I)))

  # 4. Paint each shifted object with value '4' onto the canvas
  for obj in shifted_objs:
    O = underpaint(O, recolor(4, obj))
  return O
 
8.333333333333334, tensor(0.0246), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-quarter of the way from the left edge and the other square one-quarter of the way from the right edge. The squares should be two squares apart. 
:: def bajdfhcbbcdeeihcbbeaedcbcehjaabd(I):
  w = width(I)
  center = w // 2
  offset = (w + 1) // 4  # Adjusts for odd widths
  indices_of_4 = {center - offset, center + offset - (w % 2)}  
  return vconcat(I, (tuple(4 if j in indices_of_4 else 0 for j in range(w)),)) 
 
8.333333333333334, tensor(0.0246), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-quarter of the way from the left edge and the other square one-quarter of the way from the right edge. The squares should be two squares apart. 
:: def afdgfacgdefaeddgbabfbchdfaefjeef(I):
  w = width(I)
  return vconcat(I, (tuple(branch(abs(j - w // 2) <= (w // 4), 4, 0) for j in range(w)),))
 
2.0, tensor(0.2389), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the leftmost square of the shape and two squares to the right of the rightmost square of the shape. The original grid should be preserved. 
:: def baefadiechdgehjbbcadbcahadfgecdi(I):
  obj = argmax(objects(I, False, False, True), size) # Identify the largest object
  bottom_row = lowermost(obj) + 1 # Find the bottom row of the object
  left_col = leftmost(obj) - 2 # Calculate the column for the left marker
  right_col = rightmost(obj) + 2 # Calculate the column for the right marker
  border = {(4, (bottom_row, left_col)), (4, (bottom_row, right_col))} # Create markers
  O = paint(I, border) # Add markers to the grid
  return O
 
2.3333333333333335, tensor(0.2419), Description: Find the largest colored shape in the input grid, and if multiple shapes have the same size, choose the one that is furthest to the left. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square directly below the leftmost square of the shape and the other square two squares to the right of the first yellow square. The original grid should be preserved. 
:: def abaaiajddedeecddadfhfjgahggebdej(I):
  obj = argmax(objects(I, False, False, True), lambda x: (size(x), -leftmost(x))) # Prioritize by size, then leftmost position
  bottom_left = (lowermost(obj) + 1, leftmost(obj) - 2) # Find bottom-left corner for marker placement
  markers = {(4, add(bottom_left, (0, i))) for i in (0, width(obj) + 2)} # Generate marker positions
  O = paint(I, markers) # Paint the markers
  return O
 
4.333333333333333, tensor(0.6003), Description: For each colored shape in the input grid, find the squares in the bottom row of the shape. Fill the squares directly below those squares with yellow. 
:: def eeejehfadcjfehehjfdabdbjadajfcdg(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  indices = set()
  for obj in objs:
    bottom_row = lowermost(obj)
    for j in range(width(I)):
      if (bottom_row, j) in toindices(obj):
        indices.add((bottom_row + 1, j))
  O = fill(I, 4, frozenset(indices))
  return O
 
15.0, tensor(1.7299), Description: For each column in the input grid, find the first non-black square from the bottom. Fill the square directly below that square with yellow. The original grid should be preserved. 
:: def fefjejffjbjceccaaddaefggebfeefhi(I):
  O = canvas(0, shape(I))
  for j in range(width(I)):
    for i in range(height(I) - 1, -1, -1):
      if I[i][j] != mostcolor(I):
        O = paint(O, {(4, (i+1, j))})
        break
  return O
 
8.333333333333334, tensor(1.7317), Description: Copy the input grid. Then, for each non-black square in the bottom row, fill the square directly below it with yellow. The original grid should be preserved. 
:: def abeacdbfejcbeccjibjcdcaadececafh(I):
  O = canvas(0, (height(I) + 1, width(I)))
  O = paint(O, asobject(I))
  for j in range(width(I)):
    if I[-1][j] != mostcolor(I):
       O = paint(O, {(4, (height(I), j))})
  return O
 
8.333333333333334, tensor(0.0246), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-quarter of the way from the left edge and the other square one-quarter of the way from the right edge. The squares should be two squares apart. 
:: def iddbcbfjhcgdeafdajecjgbgjiidchdd(I):
  w = width(I)
  new_row = tuple(4 if j // (w // 4) in {1, 3} else 0 for j in range(w))
  return vconcat(I, (new_row,))
 
2.0, tensor(0.2389), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the leftmost square of the shape and two squares to the right of the rightmost square of the shape. The original grid should be preserved. 
:: def abheiafciecgeabhjdfdacjcciaaedjc(I):
  obj = argmax(objects(I, False, False, True), size)  # Find the largest object
  bottom_row = lowermost(obj) + 1  # Row below the object
  left_marker = (leftmost(obj) - 2, bottom_row)  # Position of left marker
  right_marker = (rightmost(obj) + 2, bottom_row)  # Position of right marker
  markers = frozenset({(4, left_marker), (4, right_marker)})  # Create markers 
  O = paint(I, markers)  # Add markers to the grid
  return O 
 
2.0, tensor(0.2419), Description: Find the largest colored shape in the input grid, and if multiple shapes have the same size, choose the one that is furthest to the left. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square directly below the leftmost square of the shape and the other square two squares to the right of the first yellow square. The original grid should be preserved. 
:: def fdidjhijdcheeagdjjdhegcffjchedab(I):
  obj = argmax(objects(I, False, False, True), lambda x: (size(x), -uppermost(x))) # Largest, topmost object
  O = paint(paint(I, {(4, (lowermost(obj) + 1, leftmost(obj) - 2))}), 
            {(4, (lowermost(obj) + 1, rightmost(obj) + 2))})
  return O
 
2.0, tensor(0.2389), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the leftmost square of the shape and two squares to the right of the rightmost square of the shape. The original grid should be preserved. 
:: def deedhfdcehbfehgdaigaedicadfdfcai(I):
  obj = argmax(objects(I, False, False, True), size)
  bottom_row = lowermost(obj) + 1
  offset = width(obj) // 2 + 2
  left_marker = (4, (bottom_row, leftmost(obj) - offset))
  right_marker = (4, (bottom_row, rightmost(obj) + offset - 1))
  O = paint(paint(I, {left_marker}), {right_marker})
  return O
 
2.3333333333333335, tensor(0.2400), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the leftmost square of the shape and one square to the right of the rightmost square of the shape. The original grid should be preserved. 
:: def fcgdbciaacifeddbiggedbeeheabgeef(I):
  obj = argmax(objects(I, False, False, True), lambda o: len(o))
  bottom = len(I) - 1
  left_edge = leftmost(obj)
  right_edge = rightmost(obj)
  markers = {(4, (bottom, left_edge - 2)), (4, (bottom, right_edge + 1))}
  return paint(I, markers)
 
2.0, tensor(0.2400), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the leftmost square of the shape and one square to the right of the rightmost square of the shape. The original grid should be preserved. 
:: def ifigacedefebefcbaccbejaddddfbbhd(I):
  obj = max(objects(I, False, False, True), key=lambda x: len(x))
  h = len(I)
  w = width(obj)
  return paint(I, {(4, (h-1, leftmost(obj) - 2)), (4, (h-1, leftmost(obj) + w + 1))})
 
68.33333333333333, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def bgefbcaafeaeehcbiajabahcdfhjfhdi(I):
  # 1. Add a column of zeros to the right of the input grid.
  I = hconcat(I, tuple(((0,) * height(I),)))
  # 2. Create a new grid of zeros with the same dimensions as the modified input grid.
  O = canvas(0, shape(I))
  # 3. Iterate over each row of the input grid.
  for i in range(height(I)):
    # 4. Iterate over the current row from right to left, excluding the last element.
    for j in range(width(I) - 2, -1, -1):
      # 5. If the current element is non-zero:
      if I[i][j] != 0:
        # 6. Place a '4' in the new grid, one row below and one cell to the right.
        O = fill(O, 4, {(i + 1, j + 1)})
        break
  # 7. Concatenate the input grid and the new grid vertically.
  O = vconcat(I, O)
  return O
 
1.6666666666666667, tensor(0.0788), Description: For each colored shape in the input grid, fill the leftmost and rightmost squares in the bottom row of the shape with yellow. 
:: def ehfabhdgaifeeejaafeeffgbbbjddgec(grid):
    h = height(grid) - 1
    marked = set()
    for obj in objects(grid, T, F, T):
      for i, j in toindices(obj):
        if i == h:
          marked.add((h, leftmost(obj)))
          marked.add((h, rightmost(obj)))
          break 
    return paint(grid, frozenset((4, p) for p in marked))
 
2.6666666666666665, tensor(0.2430), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center of the shape and the other square to the right of the center of the shape. The squares should be two squares apart. The original grid should be preserved. 
:: def bdgfffdjbfadeccfabejabhafaacfddf(I):
  obj = argmax(objects(I, False, False, True), size)
  marker_row = lowermost(obj) + 1
  midpoint = centerofmass(obj)[1]
  offset = width(obj) // 2 + 1
  left_marker = (marker_row, midpoint - offset)
  right_marker = (marker_row, midpoint + offset)
  return paint(paint(I, {(4, left_marker)}), {(4, right_marker)})
 
2.3333333333333335, tensor(0.2402), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the center of the shape and one square to the right of the center of the shape. The original grid should be preserved. 
:: def gibhheffdjbdecdabfbbjchieheahcbj(I):
  largest_obj = argmax(objects(I, False, False, True), size)
  bottom = lowermost(largest_obj) + 1
  mid = leftmost(largest_obj) + width(largest_obj) // 2
  marker_left = (4, (bottom, mid - width(largest_obj) // 2 - 2))
  marker_right = (4, (bottom, mid + width(largest_obj) // 2 + 1))
  return paint(paint(I, {marker_left}), {marker_right}) 
 
2.0, tensor(0.2430), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square to the left of the center of the shape and the other square to the right of the center of the shape. The squares should be two squares apart. The original grid should be preserved. 
:: def eecfhfjbhhaheabhjaehbedabhaaefch(I):
  obj = argmax(objects(I, False, False, True), size)
  h = height(obj)
  w = width(obj)
  left = leftmost(obj)
  markers = {(4, (lowermost(obj) + 1, left + (w - 3) // 2 + i * (w + 3))) for i in range(2)}
  return paint(I, markers)
 
10.0, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def bibdcffifhacegfiicicecgjeefedged(I):
  # 1. Create output grid with one extra row filled with zeros.
  O = vconcat(I, canvas(0, (1, width(I))))
  # 2. Iterate through each row of input grid.
  for i, row in enumerate(I):
    # 3. Find index of rightmost non-zero element in the row.
    j = next((j for j in range(width(I)-1, -1, -1) if row[j] != 0), None)
    # 4. If a non-zero element is found, place '4' in the output grid.
    if j is not None:
      O = fill(O, 4, {(i+1, j+1)})
  return O
 
49.666666666666664, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def babdjggecafgebdejfbcafcbegeddfde(I):
  # 1. Create an empty set to store the indices for placing '4'.
  indices = set()
  # 2. Iterate through each row of the input grid with its index.
  for i in range(height(I)):
    # 3. Iterate through each element in the row from right to left.
    for j in range(width(I)-1, -1, -1):
      # 4. If a non-zero element is found:
      if I[i][j] != 0:
        # Add the index (one row below and one position right) to the set.
        indices.add((i + 1, j + 1))
        # Stop searching for non-zero elements in the current row.
        break
  # 5. Create the output grid by filling '4's at calculated indices.
  O = fill(canvas(0, (height(I) + 1, width(I))), 4, frozenset(indices))
  # 6. Concatenate the input grid with the output grid vertically.
  O = vconcat(I, O)
  return O
 
8.333333333333334, tensor(0.0248), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-quarter of the way from the left edge and the other square three-quarters of the way from the left edge. The squares should be two squares apart. If the width of the grid is not divisible by 4, the rightmost yellow square should be shifted one square to the left. 
:: def gdefeafcbicceaciacdebeiagbdaigic(I):
  w = width(I)
  return vconcat(I, (tuple(4 if (j * 4 + w % 2) % w == 0 or (j * 4 + w % 2) % w == 3 * w // 4 else 0 for j in range(w)),))
 
2.3333333333333335, tensor(0.2369), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, three squares to the left of the center of the shape and two squares to the right of the center of the shape. The original grid should be preserved. 
:: def giaaeiicibfceafcbefbadhfdgfgdfha(I):
  largest_obj = argmax(objects(I, False, False, True), size)
  shifted_obj = shift(largest_obj, (lowermost(largest_obj) + 1, 0))
  center_col = centerofmass(shifted_obj)[1]
  markers = {(4, (lowermost(shifted_obj), center_col - 3)), (4, (lowermost(shifted_obj), center_col + 2))}
  return paint(I, markers)
 
18.0, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def abaiadbaifieedbiicegfiafgicbfade(I):
  # 1. Create a canvas for the output with an extra row.
  O = canvas(0, (height(I) + 1, width(I))) 
  # 2. Iterate over each row of the input grid.
  for i, row in enumerate(I):
    # 3. Find the rightmost non-zero element's index in the row.
    j = next((j for j in range(width(I)-1, -1, -1) if row[j] != 0), None)
    # 4. If found, place a '4' in the output grid.
    if j is not None:
      O = fill(O, 4, {(i+1, j+1)})
  return O
 
18.0, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def ecjhfdabhfdbeddcijbccchdhajeefhb(I):
  # 1. Find all objects in the grid (excluding background).
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  # 2. Create an empty set to store the indices to be filled with '4'.
  indices = frozenset()
  # 3. Iterate over each object.
  for obj in objs:
    # 4. Get the row index of the lowermost cell in the object.
    bottom_row = lowermost(obj)
    # 5. Iterate over columns in the bottom row.
    for j in range(width(I)):
      # 6. If the cell at (bottom_row, j) belongs to the current object, 
      # add the index below and to the right to the set.
      if (bottom_row, j) in toindices(obj):
        indices = indices.union({(bottom_row + 1, j + 1)})
  # 7. Create the output grid by filling '4's at the collected indices.
  O = fill(canvas(0, (height(I) + 1, width(I))), 4, indices)
  return O
 
3.3333333333333335, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def aceedfbiiefcedbdbiabdaicbdacdbif(I):
  O = I
  # Iterate over the rows of the input grid.
  for i in range(height(I)):
    # Find the rightmost non-zero element's index in the row.
    for j in range(width(I) - 1, -1, -1):
      if I[i][j] != 0:
        # If a non-zero element is found, fill the position below and to the right with '4'.
        if i + 1 < height(I) and j + 1 < width(I):
          O = fill(O, 4, {(i + 1, j + 1)})
        break
  return O
 
8.333333333333334, tensor(0.0222), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, symmetrically around the center column. The squares should be two squares apart. If the width of the grid is odd, the rightmost yellow square should be shifted one square to the left. 
:: def ehacdjedcaefejfejhiebeediefdjaba(I):
  w = width(I)
  offset = (w - 1) // 2 if even(w) else w // 2
  return vconcat(I, (tuple(4 if j in {offset, w - 1 - offset} else 0 for j in range(w)),))
 
1.6666666666666667, tensor(0.2439), Description: Find the largest colored shape in the input grid. Add a new row to the bottom of the grid. Place two yellow squares in the new row, two squares to the left of the upper-left corner of the shape and two squares to the right of the upper-right corner of the shape. The original grid should be preserved. 
:: def efeifjeacfcaecjaijaecedcgaajgcfa(I):
  obj = argmax(objects(I, False, False, True), lambda x: width(x) * height(x))
  offset = (height(I), -(width(obj) // 2 + 2))
  markers = {(4, add(ulcorner(obj), offset)), (4, add(urcorner(obj), offset))}
  return paint(I, markers)
 
21.0, tensor(0.1758), Description: Copy the input grid. Then, for each non-black square in the grid, move that square one row down and one column to the right. The color of the square should remain the same.  The output grid should be twice the height and width of the input grid. 
:: def afgfeaceagbiefjdaeeebgcddfihcadi(I):
  # Transpose the grid, reverse each row, find the first non-zero element's index,
  # transpose back, shift down, then fill.
  transposed = dmirror(I)
  reversed_rows = tuple(row[::-1] for row in transposed)
  first_nonzero_indices = frozenset((j, i) for i, row in enumerate(reversed_rows) for j, val in enumerate(row) if val != 0)
  shifted_indices = shift(first_nonzero_indices, (1, 0))
  O = fill(canvas(0, (height(I) + 1, width(I))), 4, shifted_indices)
  return O
 
8.333333333333334, tensor(0.0231), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-third of the way from the left edge and the other square two-thirds of the way from the left edge. The squares should be two squares apart. 
:: def iiecdgbdbgcfejdcbdeagbbcagaagbda(I):
  w = width(I)
  return vconcat(I, (tuple(4 if j in {w // 3, 2 * w // 3} else 0 for j in range(w)),))
 
8.333333333333334, tensor(0.0227), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-third of the way from the left edge and the other square one-third of the way from the right edge. The squares should be two squares apart. If the width of the grid is not divisible by 3, the rightmost yellow square should be shifted one square to the left. 
:: def bgahhjfchgbdeagjidiideaiibbeffde(I):
  w = width(I)
  offset = w // 3
  return vconcat(I, (tuple(4 if abs(j - offset) <= offset // 2 or abs(j - (w - offset)) <= offset // 2 else 0 for j in range(w)),))
 
8.333333333333334, tensor(0.0226), Description: Add a new row to the bottom of the grid. Place two yellow squares in the new row, one square one-third of the way from the left edge and the other square two-thirds of the way from the left edge. The squares should be two squares apart. If the width of the grid is not divisible by 3, the rightmost yellow square should be shifted one square to the left. 
:: def fbdcedadcdaeecijbiegcffddfaheffe(I):
  w = width(I)
  t = w // 3
  row = tuple(0 for _ in range(w))
  new_row = tuple(4 if i in {t, 2 * t} else row[i] for i in range(len(row)))
  return vconcat(I, (new_row,))
 
8.333333333333334, tensor(0.5715), Description: Find the color that appears the least often in the input grid, excluding the background color. Add a new row to the bottom of the grid. Fill the new row with that color, except for the first and last squares, which should be the background color. 
:: def fchbbdeheaccebfbahiebfbaffefhedd(I):
  bg = mostcolor(I)
  target_color = min((c for c in palette(I) if c != bg), default=bg)
  new_row = canvas(target_color, (1, width(I)))
  inner_line = interval(1, width(I) - 1, 1)
  modified_row = fill(new_row, bg, frozenset((0, j) for j in inner_line))
  return vconcat(I, modified_row)
 
35.666666666666664, tensor(0.0643), Description: Copy the input grid and place it in the top left corner of the output grid. Duplicate the input grid and place it to the right of the original copy. Duplicate the input grid again and place it below the original copy. Finally, add two yellow squares in the bottom row of the output grid, two squares to the right of the leftmost square of the input grid and two squares to the left of the rightmost square of the input grid. 
:: def efbgaeebeaieedfabcbcedfbhcbgfbbc(I):
  obj = toobject(asindices(I), I)
  O = canvas(0, (8, 8))
  O = paint(O, shift(obj, (-1, -1)))  # Original object shifted
  O = paint(O, shift(obj, (-1, 3)))  # Duplicate to the right
  O = paint(O, shift(obj, (2, -1)))  # Duplicate below
  O = fill(O, 4, {(7, 2), (7, 6)})  # Add the '4's
  return O
 
33.666666666666664, tensor(0.0643), Description: Copy the input grid and place it in the top left corner of the output grid. Duplicate the input grid and place it to the right of the original copy. Duplicate the input grid again and place it below the original copy. Finally, add two yellow squares in the bottom row of the output grid, two squares to the right of the leftmost square of the input grid and two squares to the left of the rightmost square of the input grid. 
:: def hfghdidfdfaaeejdaabebdaaahfddgah(I):
    O = canvas(0, (8, 8))
    for obj in objects(I, T, F, F):
        O = paint(O, shift(obj, (-1, -1)))
        if len(obj) > 1:  # Place duplicates only for multi-cell objects
            O = paint(O, shift(obj, (-1, 3)))
            O = paint(O, shift(obj, (2, -1)))
    O = fill(O, 4, {(7, 2), (7, 6)})
    return O
 
35.333333333333336, tensor(0.1050), Description: Copy the input grid and place it in the top left corner of the output grid. Duplicate the input grid and place it to the right of the original copy, changing the color of the duplicated grid to green. Duplicate the input grid again and place it below the original copy, changing the color of the duplicated grid to either 6 or 8 depending on the height of the input grid (if the height is greater than 5, use 6, otherwise use 8). Finally, add two yellow squares in the bottom row of the output grid, two squares to the right of the leftmost square of the input grid and two squares to the left of the rightmost square of the input grid. 
:: def eaggagcgdfdcecjdjfeacfcbiaaacifi(I):
    O = canvas(0, (8, 8))  # Initialize output canvas
    obj = asobject(I)      # Treat the entire input as a single object
    
    O = paint(O, shift(obj, (-1, -1)))  # Paint the first replica
    O = paint(O, shift(recolor(3, obj), (-1, 3)))  # Paint the second replica (recolored)
    O = paint(O, shift(recolor(6 if len(I) > 5 else 8, obj), (2, -1)))  # Third replica (conditional recoloring)
    
    O = fill(O, 4, {(7, 2), (7, 6)})  # Add the '4' elements
    return O 
 
36.333333333333336, tensor(0.1050), Description: Copy the input grid and place it in the top left corner of the output grid. Duplicate the input grid and place it to the right of the original copy, changing the color of the duplicated grid to green. Duplicate the input grid again and place it below the original copy, changing the color of the duplicated grid to either 6 or 8 depending on the height of the input grid (if the height is greater than 5, use 6, otherwise use 8). Finally, add two yellow squares in the bottom row of the output grid, two squares to the right of the leftmost square of the input grid and two squares to the left of the rightmost square of the input grid. 
:: def ghgbhaeacacfejehbdaccahaifebbaif(I):
  O = canvas(0, (8, 8))
  obj = asobject(I)
  for i in range(3):
    offset = ((-1) ** i, (i * 2) - 1)  # Calculate offset based on iteration
    color_value =  [0, 3, (6 if len(I) > 5 else 8)][i]  # Conditional color
    O = paint(O, shift(recolor(color_value, obj), offset)) 
  O = fill(O, 4, {(7, 2), (7, 6)})
  return O
 
33.333333333333336, tensor(0.1050), Description: Copy the input grid and place it in the top left corner of the output grid. Duplicate the input grid and place it to the right of the original copy, changing the color of the duplicated grid to green. Duplicate the input grid again and place it below the original copy, changing the color of the duplicated grid to either 6 or 8 depending on the height of the input grid (if the height is greater than 5, use 6, otherwise use 8). Finally, add two yellow squares in the bottom row of the output grid, two squares to the right of the leftmost square of the input grid and two squares to the left of the rightmost square of the input grid. 
:: def fjecgefdbfeheaffaibegbiidghadjge(I):
  O = canvas(0, (8, 8))
  objs = objects(I, T, F, F) 
  for i, obj in enumerate(objs):
    for j in range(3):
      if i == 0 or j == 0:  # Paint the original object and the first replica of each
        offset = ((-1) ** j, (j * 2) - 1) 
        color_value = [0, 3, (6 if len(I) > 5 else 8)][j] 
        O = paint(O, shift(recolor(color_value, obj), offset)) 
  O = fill(O, 4, {(7, 2), (7, 6)})
  return O
 
