14.5, 30.264742, def fedbcfffeiabebicaebedgfcdceaefci(I):
    # Find all "2" locations
    target_locations = ofcolor(I, TWO) 
    # Generate adjacent locations for each "2" location
    adjacent_locations = mapply(dneighbors, target_locations) 
    # Combine all adjacent locations into a single set
    all_adjacent_locations = merge(adjacent_locations) 
    # Filter for locations that are "0" in the input grid
    zero_locations = ofcolor(I, ZERO)
    fill_locations = intersection(all_adjacent_locations, zero_locations)
    # Fill the selected locations with "3"
    O = fill(I, THREE, fill_locations) 
    return O
 
227.0, 31.209042, def jcaagidefebeecfaicddbcbeedecebha(I):
  # Create a shifted grid in all four directions
  shifted_up = shift(asobject(I), UP)
  shifted_down = shift(asobject(I), DOWN)
  shifted_left = shift(asobject(I), LEFT)
  shifted_right = shift(asobject(I), RIGHT)
  
  # Find overlaps where a "2" exists in the shifted grids and a "0" in the original
  overlap_up = intersection(toindices(shifted_up), ofcolor(I, ZERO))
  overlap_down = intersection(toindices(shifted_down), ofcolor(I, ZERO))
  overlap_left = intersection(toindices(shifted_left), ofcolor(I, ZERO))
  overlap_right = intersection(toindices(shifted_right), ofcolor(I, ZERO))

  # Combine all overlaps
  all_overlaps = merge([overlap_up, overlap_down, overlap_left, overlap_right])
  
  # Fill the overlapped locations with "3"
  O = fill(I, THREE, all_overlaps)
  return O 
 
37.0, 28.793962, def bjbfhhhgbffceebdahebccebeeffejbf(I):
    # Iterate over each cell in the grid
    h, w = len(I), len(I[0])
    O = [[I[i][j] for j in range(w)] for i in range(h)]
    for i in range(h):
        for j in range(w):
            # Check if the current cell is "0"
            if I[i][j] == ZERO:
                # Check for adjacent "2" values
                if any(I[k][l] == TWO for k, l in dneighbors((i, j)) if 0 <= k < h and 0 <= l < w):
                    O[i][j] = THREE
    return tuple(tuple(row) for row in O)
 
41.0, 27.39085, def dgbdbjejhdcbedcjafjfhcfjcafcdifa(I):
  # Apply a lambda function to each cell
  O = apply(
      lambda cell: (THREE if any(index(I, n) == TWO for n in dneighbors(cell[1]) 
                              if 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0])) 
                    else cell[0], cell[1]),
      asobject(I)
  )
  # Convert the object back to a grid
  return paint(canvas(ZERO, shape(I)), O)
 
14.5, 30.264742, def dahddcidcaedefadbahagfjfacfheaia(I):
  objs = objects(I, diagonal=True, univalued=True, without_bg=False)
  filtered_objs = sfilter(objs, lambda obj: color(obj) == 2)
  border_indices = mapply(delta, apply(toindices, filtered_objs))
  O = fill(I, 3, border_indices)
  return O
 
28.0, 29.963219, def edecgaeejbffeigiaebicjbaechfbhad(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2 and any(0 <= i + di < len(I) and 0 <= j + dj < len(I[0]) and I[i + di][j + dj] == 0 for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (-1, -1), (1, -1), (-1, 1)]):
        O = fill(O, 3, {(i, j)})
  return O
 
60.0, 16.919737, def gfahfcbheihdedhfabeddccfcafcaejd(I):
  padded_grid = canvas(1, (len(I) + 2, len(I[0]) + 2))
  padded_grid = fill(padded_grid, 0, backdrop(asindices(I)))
  padded_grid = paint(padded_grid, asobject(I))
  O = canvas(0, (len(I), len(I[0])))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if padded_grid[i+1][j+1] == 2 and any(padded_grid[i+di][j+dj] == 0 for di in range(3) for dj in range(3)):
        O = fill(O, 3, {(i, j)})
      else:
        O = fill(O, padded_grid[i+1][j+1], {(i, j)})
  return O
 
30.5, 8.862364, def adfecjehcdghecbcbcigbcheiiaebfaf(I):
  objs = objects(I, T, F, T) 
  output = I
  for obj in objs:
    c = color(obj)
    for cell in obj:
      i, j = cell[1]
      output = fill(output, c, {(i,j-1),(i,j),(i,j+1)})
  return output
 
42.5, 11.618548, def adibihdhcddbehbfbgfdfbbbiacbceba(I):
  twos = ofcolor(I, 2)
  output = replace(I, 2, 3)
  for i, j in twos:
    output = fill(output, 2, {(i-1,j-1),(i+1,j+1)})
  return output 
 
241.0, 34.12097, def badeefcabdahebccbdebfdbfcdaaabcb(I):
  twos = ofcolor(I, 2)
  output = canvas(3, shape(I))
  for i, j in twos:
    square_3x3 = {(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)}
    output = fill(output, 2, {(i-1,j-1),(i+1,j+1)}) if len(intersection(square_3x3, twos)) == 1 else output
  return output
 
114.5, 30.723356, def fjajcaifciieejeejcbdedhdccfhcdeb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  lines = frozenset()
  for obj in objs:
    c = color(obj)
    w = width(obj)
    center_j = leftmost(obj) + w // 2
    start_j = center_j - w // 2
    line = {(THREE, (i, j)) for i, j in product(interval(0, height(I), 1), interval(start_j, start_j + w, 1))}
    lines = lines | line
  O = paint(I, lines)
  return O
 
240.5, 59.46244, def ibheadehdbcfehaajedgdbccafhfedde(I):
  objs = partition(I)
  lines = frozenset()
  for obj in objs:
    if color(obj) != ZERO:
      start_j = leftmost(obj)
      w = width(obj)
      line = {(THREE, (i, j)) for i, j in product(interval(0, height(I), 1), interval(start_j, start_j + w, 1))}
      lines |= line
  O = paint(I, lines)
  return O
 
14.5, 30.264742, def dfafddbifcicefdaaddfjffacbecahah(I):
  objs = objects(I, F, T, T)
  padded_objs = mapply(lambda o: delta(toindices(o)), objs)
  O = fill(I, THREE, merge(padded_objs))
  return O
 
57.5, 25.125113, def befegjdedgfgecgaifaddaadffjaahcf(I):
    O = I
    for obj in objects(I, F, T, T):
        upper_left = ulcorner(obj)
        lower_right = lrcorner(obj)
        for i in range(upper_left[0] - 1, lower_right[0] + 2):
            for j in range(upper_left[1] - 1, lower_right[1] + 2):
                if 0 <= i < height(I) and 0 <= j < width(I):
                    if I[i][j] != 2:
                        O = fill(O, THREE, {(i, j)})
    return O
 
57.5, 15.524397, def dcjfgjefbbbheaagjfddbhdciajbbffd(I):
  indices = ofcolor(I, TWO)  # Get indices of all '2' cells
  obj = toobject(indices, I)  # Create an object from the indices
  box_indices = box(indices)  # Create bounding box indices
  O = underfill(I, THREE, box_indices) # Fill bounding box with '3'
  return O
 
50.0, 20.89728, def ahicfebbhdfceccaihbffhfdcaafeacd(I):
    h, w = len(I), len(I[0])
    O = [[I[i][j] for j in range(w)] for i in range(h)]
    for i in range(1, h - 1):
        for j in range(1, w - 1):
            if I[i][j] == 2 and any(I[ni][nj] == 0 for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]):
                for ni, nj in [(i - 1, j - 1), (i - 1, j), (i - 1, j + 1), (i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)]:
                    if 0 <= ni < h and 0 <= nj < w:
                        O[ni][nj] = 3
    return tuple(tuple(row) for row in O)
 
61.0, 13.661997, def eadgdccddbfbececicddcbccbjjdbeef(I):
  shifted_left = paint(canvas(3, shape(I)), shift(asobject(I), LEFT))
  shifted_right = paint(canvas(3, shape(I)), shift(asobject(I), RIGHT))
  output = cellwise(I, shifted_left, 3)
  output = cellwise(output, shifted_right, 3)
  return output
 
76.0, 20.504232, def dcihhgbecicdeachbdabaddhdcjdedjc(I):
  objs = objects(I, True, False, True)
  new_objs = frozenset()
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    square = frozenset((i, j) for i in range(center_i - 1, center_i + 2) for j in range(center_j - 1, center_j + 2))
    new_objs = combine(new_objs, recolor(3, square))
  O = paint(I, new_objs)
  return O
 
37.0, 28.793962, def babbaeddfjcgedefadjadjbaeccccefa(I):
    objs = objects(I, True, False, True)
    border_cells = frozenset()
    for obj in objs:
        for i, j in toindices(obj):
            border_cells = combine(border_cells, dneighbors((i, j))) 
    border_cells = difference(border_cells, toindices(merge(objs)))
    O = paint(I, recolor(3, border_cells))
    return O
 
57.5, 25.125113, def hfjbaffecbihecggjdjdcafgdaafaaei(I):
  objs = objects(I, True, False, True)
  border = frozenset()
  for obj in objs:
    for cell in toindices(obj):
      border = combine(border, difference(neighbors(cell), toindices(obj)))
  O = paint(I, recolor(3, border))
  return O
 
14.5, 30.264742, def dcejffgicdfbecfaidgiacijchdcggbc(I):
  objs = objects(I, True, False, True)
  new_grid = canvas(0, shape(I))
  for obj in objs:
    for i, j in toindices(obj):
      for di in range(-1, 2):
        for dj in range(-1, 2):
          new_grid = fill(new_grid, 3, {(i+di, j+dj)})
  O = paint(new_grid, asobject(I)) 
  return O
 
61.5, 16.622139, def eaaajgcefdegeaiijjabijfaegccahfa(I):
  padded = canvas(THREE, add(shape(I), TWO)) # Create a padded canvas
  O = paint(padded, asobject(I)) # Paint the input onto the padded canvas
  return trim(O) # Trim the outer layer of the canvas
 
93.0, 26.29249, def jdaeacceedfeebghbefadcbafdfddeef(I):
  shifted_grids = (shift(asobject(I), d) for d in (UP, DOWN, LEFT, RIGHT)) # Create shifted versions of the input
  merged_grid = I
  for shifted in shifted_grids:
      merged_grid = cellwise(merged_grid, paint(canvas(THREE, shape(I)), shifted), THREE) # Merge shifted grids, filling with '3' where they differ
  return merged_grid
 
24.5, 10.781635, def jgeaaffcbcafeifijidbahcdafedbdei(I):
  objs = objects(I, True, False, True) # Find all objects of '2'
  for obj in objs:
    upper = uppermost(obj)
    lower = lowermost(obj)
    left = leftmost(obj)
    right = rightmost(obj)
    for i in range(upper, lower + 1):
      if left - 1 >= 0 and I[i][left-1] == 0:
        I = fill(I, THREE, ((i, left - 1),))  # Fill left with '3' if it's '0'
      if right + 1 < len(I[0]) and I[i][right+1] == 0:
        I = fill(I, THREE, ((i, right + 1),)) # Fill right with '3' if it's '0'
  return I
 
121.0, 43.24084, def efcgdfgdcaebeidbiaicbcbbbgbicadf(I):
  O = I  # Initialize the output grid
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        left = j - 1
        right = j + 1
        while left >= 0 and I[i][left] == 0: # Expand left while encountering '0'
          O = fill(O, THREE, ((i, left),))
          left -= 1
        while right < len(row) and I[i][right] == 0:  # Expand right while encountering '0'
          O = fill(O, THREE, ((i, right),))
          right += 1
  return O
 
38.0, 9.791275, def degfddghaeedeebbaedbfcdahfgdahgd(I):
  shifted_right =  paint(canvas(ZERO, shape(I)), shift(asobject(I), RIGHT)) # Shift the grid right
  shifted_left = paint(canvas(ZERO, shape(I)), shift(asobject(I), LEFT)) # Shift the grid left
  combined = cellwise(shifted_right, I, THREE)  # Where they differ, fill with '3'
  final = cellwise(combined, shifted_left, THREE) # Repeat for the left shift
  return final
 
240.5, 59.46244, def iddidajgceddecfdjfaifdffdajdbfhj(I):
  h, w = len(I), len(I[0])
  O = tuple(
      tuple(
          3 if any(I[i+di][j+dj] == 0 
                   for di, dj in [(0,1),(0,-1),(1,0),(-1,0)] 
                   if 0<=i+di<h and 0<=j+dj<w) 
               else I[i][j] 
          for j in range(w)
      ) 
      for i in range(h)
  )
  return O
 
25.5, 10.672666, def ddbdgddhaeifefbcidibffafchcdjdie(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    for v, (i, j) in obj:
      O = fill(O, 3, {(i, j-1), (i, j+1)})
  return O
 
80.0, 10.838702, def cfagghjcdhbdeeccibbdcbbadceaaegb(I):
  shifted_left =  hconcat(((0,),)*len(I), trim(I))
  shifted_right = hconcat(trim(I), ((0,),)*len(I))
  O = cellwise(shifted_left, I, 3)
  O = cellwise(shifted_right, O, 3)
  return O 
 
25.0, 10.792409, def bccceicddjcceeibaabjcbehfheejhef(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, {(v, (i, j))})
        if j > 0:
          O = paint(O, {(3, (i, j-1))})
        if j < len(row) - 1:
          O = paint(O, {(3, (i, j+1))})
  return O
 
71.0, 19.358435, def aedjcbfaeajfecjdihcgcebafffaecaa(I):
    # Get indices of all '2' cells
    two_indices = ofcolor(I, TWO)

    # Generate '3' shaped patch centered at (0, 0)
    base_patch = frozenset({(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 0), (0, 1), (1, -1), (1, 0), (1, 1)})

    # Shift and paint '3' shape for each '2' cell
    O = I
    for i, j in two_indices:
        O = paint(O, recolor(THREE, shift(base_patch, (i, j))))

    return O
 
71.0, 19.358435, def cffafbifgiehefdgaiaeiejbgbceecdd(I):
    objs = objects(I, F, T, T) # Find all objects in the grid
    expanded_boxes = set()
    for obj in objs:
        for cell in obj:
            i, j = cell[1]
            for di in range(-1, 2):
                for dj in range(-1, 2):
                    expanded_boxes.add((i + di, j + dj))
    O = fill(I, THREE, frozenset(expanded_boxes)) # Fill the expanded boxes in the grid
    return O
 
48.5, 21.680943, def dfbafegcdbfgedaiaddaafjcceccecbf(I):
    h, w = len(I), len(I[0])
    O = [[v for v in row] for row in I]
    for i in range(1, h - 1):
        for j in range(1, w - 1):
            if I[i][j] == 2 and any(I[i+di][j+dj] == 0 for di in [-1, 0, 1] for dj in [-1, 0, 1] if (di, dj) != (0, 0)):
                for di in [-1, 0, 1]:
                    for dj in [-1, 0, 1]:
                        if 0 <= i + di < h and 0 <= j + dj < w and I[i+di][j+dj] != 2:
                            O[i+di][j+dj] = 3
    return tuple(tuple(row) for row in O)
 
24.5, 10.781635, def cjbicjgfafgdedeeieddicbhhfgcahdd(I):
  objs = objects(I, T, F, T) 
  output = I
  for obj in objs:
    for v, (i, j) in obj:
      if j > 0 and output[i][j-1] == 0:
        output = fill(output, 3, {(i, j-1)})
      if j < len(output[0]) - 1 and output[i][j+1] == 0:
        output = fill(output, 3, {(i, j+1)})
  return output
 
37.0, 28.793962, def bajdfafihcgfeecaacbefhgaabeaehdb(I):
  output = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != 0:
        for ni, nj in dneighbors((i, j)):
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
            output = fill(output, 3, {(ni, nj)})
  return output
 
59.5, 24.04091, def aefgbiccbdcbecahifedbdjcffafejhg(I):
    # Get the dimensions of the input grid
    h, w = shape(I)
    
    # Create a new grid filled entirely with zeros
    O = canvas(ZERO, (h, w))
    
    # Iterate through the input grid
    for i in range(h):
        for j in range(w):
            # If a cell is non-zero, draw a 3x3 square of '3's around it 
            if I[i][j] != ZERO:
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < h and 0 <= nj < w:
                            O = paint(O, {(THREE, (ni, nj))})
                # Preserve the original non-zero value in the center
                O = paint(O, {(I[i][j], (i, j))})
    return O
 
38.0, 17.660585, def jidciibbadcaefhgjbhjaechdbecfiga(I):
  O = canvas(0, shape(I))
  objs = objects(I, T, F, T)
  for obj in objs:
    for cell in obj:
      i, j = cell[1]
      O = paint(O, {(3, (i, max(0, j - 1)))})
      O = paint(O, {(3, (i, min(len(I[0]) - 1, j + 1)))})
  return O
 
23.5, 8.898356, def cfaadfdechedecghacgedceejbdgihgg(I):
  O = I
  for i in range(len(I)):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] != 0 and (I[i][j - 1] == 0 or I[i][j + 1] == 0):
        O = fill(O, 3, {(i, j - 1), (i, j + 1)})
  return O
 
37.0, 28.793962, def dfibbbehaefdefbibdebddhgcaeabagc(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    frame = mapply(dneighbors, toindices(obj)) - toindices(obj)
    O = fill(O, 3, frame)
  return O
 
57.5, 25.125113, def aecebafcfhjdebbcbeheagffccifdiji(I):
  border_indices = set()
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 2 and ((i > 0 and I[i-1][j] == 0) or (i < height(I)-1 and I[i+1][j] == 0) or (j > 0 and I[i][j-1] == 0) or (j < width(I)-1 and I[i][j+1] == 0)):
        border_indices.add((i, j))
  frame_indices = set()
  for (i, j) in border_indices:
    for di in [-1, 1, 0, 0]:
      for dj in [0, 0, -1, 1]:
        if 0 <= i + di < height(I) and 0 <= j + dj < width(I) and (i + di, j + dj) not in border_indices:
          frame_indices.add((i + di, j + dj))
  return fill(I, 3, frame_indices)
 
22.5, 9.009652, def fiacbhefefiaeddejaggfceefcdfdega(I):
  O = I
  for i in range(len(I)):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] != 0:
        if I[i][j-1] == 0:
          O = fill(O, 3, {(i, j-1)})
        if I[i][j+1] == 0:
          O = fill(O, 3, {(i, j+1)})
  return O
 
38.0, 9.791275, def affhigaaecgdejafjafeaheeidhbggbd(I):
  O = canvas(0, shape(I)) 
  for obj in objects(I, False, True, True):
    extended_indices = {(i, j - 1) for _, (i, j) in obj if j > 0 and index(I, (i, j - 1)) == 0} | \
                       {(i, j + 1) for _, (i, j) in obj if j < len(I[0]) - 1 and index(I, (i, j + 1)) == 0} | \
                       toindices(obj)
    O = paint(O, recolor(3, extended_indices))
  return O
 
41.0, 27.39085, def gebiacegdgdeeeadieddfbabeahhjdfa(I):
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != ZERO:
        I = fill(I, THREE, dneighbors((i, j)))
  return I
 
61.5, 23.39666, def bffdfaabfbaaejedjcjcccebdgfdidfb(I):
  def mark_neighbors(index):
    return dneighbors(index) | ineighbors(index) - {index}
  non_zero_indices = ofcolor(I, ONE) | ofcolor(I, TWO)
  marked_indices = mapply(mark_neighbors, non_zero_indices)
  return fill(I, THREE, marked_indices) 
 
27.0, 9.875483, def ffeedjcadcffeajcbbhdacccafeffbfa(I):
  objs = objects(I, True, False, True)  # Extract connected '2' objects
  modified_grid = I
  for obj in objs:
    for j in range(leftmost(obj), rightmost(obj) + 1):
      # Fill top adjacent cell if it's background
      if uppermost(obj) > 0 and I[uppermost(obj) - 1][j] == 0:
        modified_grid = fill(modified_grid, THREE, ((uppermost(obj) - 1, j),))
      # Fill bottom adjacent cell if it's background
      if lowermost(obj) < len(I) - 1 and I[lowermost(obj) + 1][j] == 0:
        modified_grid = fill(modified_grid, THREE, ((lowermost(obj) + 1, j),)) 
  return modified_grid
 
38.0, 9.791275, def iebffjeicibdefecaaifjdjecbaebdae(I):
  painted = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != ZERO:
        for dj in (-1, 0, 1):
          if 0 <= j + dj < width(I):
            painted = fill(painted, THREE, {(i, j + dj)})
  return painted
 
28.0, 29.963219, def ceeaciddgccbebeajehdaejeaedebfdj(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas of the same size as I
  objs = objects(I, F, T, T)
  for obj in objs:
    perimeter =  set(toindices(obj)) # Start with all cells of the object
    for cell in toindices(obj):
      for neighbor in neighbors(cell):
        if index(I, neighbor) == color(obj):
          perimeter.discard(neighbor) # Remove cells that have a same-colored neighbor
    O = fill(O, THREE, perimeter) # Fill the remaining perimeter cells with '3'
  O = cellwise(I, O, THREE) # Combine the original grid and the perimeter
  return O
 
37.0, 28.793962, def hacaifdagafaeiiejdjhccaecadgdbee(I):
  objs = objects(I, F, T, T) 
  O = I
  for obj in objs:
    shifted_objs = [shift(obj, d) for d in [UP, DOWN, LEFT, RIGHT]]
    for shifted_obj in shifted_objs:
      O = underfill(O, THREE,  toindices(shifted_obj)) # Fill under shifted objects
  return O
 
23.0, 10.322759, def ecfcdbbdeeeaefeiijgbgdjacgefdiea(I):
  h, w = len(I), len(I[0])
  return tuple(
    tuple(papply(lambda x, y: 3 if (0 < y < w - 1 and (I[i][y - 1] != 0 or I[i][y + 1] != 0) and x == 0) else x,
                  row, range(w))) for i, row in enumerate(I))
 
28.0, 58.2238, def edahfjbbjgahefcfbeefdhidbdbacbda(I):
  O = canvas(0, shape(I)) 
  for i in range(len(I)):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] != 0:
        if I[i][j - 1] == 0:
          O = fill(O, I[i][j], {(i, j - 1)})
        if I[i][j + 1] == 0:
          O = fill(O, I[i][j], {(i, j + 1)})
  return cellwise(O, I, 0) 
 
46.5, 9.976306, def fhedefeddfbfecaebcebidebccbfefhf(I):
  def hline_to_non_zero(i, j):
    return {(i, k) for k in range(width(I)) if index(I, (i, k)) != ZERO and k <= j}
  filled_grid = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != ZERO:
        line_indices = hline_to_non_zero(i, j)
        start_j = leftmost(line_indices)
        end_j = rightmost(line_indices)
        filled_grid = fill(filled_grid, THREE, {(i, k) for k in range(start_j, end_j + 1)})
  return filled_grid
 
28.0, 29.963219, def bcbjbagcaeadefigbadcabedhchbbcbc(I):
  def line_segment(i, start_j, end_j):
    return {(THREE, (i, j)) for j in range(start_j, end_j + 1)}
  painted = I
  for i, row in enumerate(I):
    current_segment_start = None
    for j, val in enumerate(row):
      if val != ZERO and current_segment_start is None:
        current_segment_start = j
      elif val == ZERO and current_segment_start is not None:
        painted = paint(painted, line_segment(i, current_segment_start, j - 1))
        current_segment_start = None
    if current_segment_start is not None:
      painted = paint(painted, line_segment(i, current_segment_start, len(row) - 1))
  return painted
 
32.5, 24.049202, def eieaefdeehceeddfbjebcjadfhihehbe(I):
  O = I
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if I[i][j] == 2 and any(index(I, (i+di, j+dj)) == 0 for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          if 0 <= i + di < height(I) and 0 <= j + dj < width(I) and I[i+di][j+dj] != 2:
            O = fill(O, 3, {(i + di, j + dj)})
  return O
 
29.0, 11.385595, def ecjidaebcfabefefjbgfahadiaafbhed(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    if hline(obj):
      for v, (i, j) in obj:
        if j > 0 and I[i][j-1] == 0:
          O = fill(O, 3, {(i, j-1)})
        if j < len(I[0]) - 1 and I[i][j+1] == 0:
          O = fill(O, 3, {(i, j+1)})
  return O
 
14.5, 30.264742, def cbacjgifdjbfeheabfjcjdbbbajeefeb(I):
  O = I
  for obj in frontiers(I):
    if color(obj) != 0 and hline(obj): # Only extend non-background horizontal frontiers
      for v, (i, j) in obj:
        if j > 0 and I[i][j - 1] == 0:
          O = fill(O, 3, {(i, j - 1)})
        if j < len(I[0]) - 1 and I[i][j + 1] == 0:
          O = fill(O, 3, {(i, j + 1)})
  return O
 
43.5, 16.718191, def jeidbecbhbbheiaibechahjfiddfjbae(I):
  def paint_line(row):
    start = next((j for j, v in enumerate(row) if v != ZERO), len(row))
    end = next((len(row) - j for j, v in enumerate(row[::-1]) if v != ZERO), 0)
    return tuple(THREE if start <= j < len(row) - end else v for j, v in enumerate(row))
  return tuple(paint_line(row) for row in I)
 
88.5, 31.544968, def iegfdgegbafeeibbabhgbejeddcgcbgd(I):
  def process_row(row):
    painting = False
    new_row = []
    for v in row:
      if v != ZERO:
        painting = True
      new_row.append(THREE if painting else v)
    return tuple(new_row)
  return tuple(process_row(row) for row in I)
 
134.5, 36.390533, def ageacffchjbaefffbgbaafdbgbeadbab(I):
  return tuple(tuple(THREE if any(I[i][k] != ZERO for k in range(len(I[0]))) else ZERO for j in range(len(I[0]))) if any(v != ZERO for v in I[i]) else tuple(ZERO for _ in range(len(I[0]))) for i in range(len(I)))
 
24.5, 13.6127205, def effcjaechdajejfdiiegbcededdhjebe(I):
    bg = mostcolor(I)  # Identify background color
    target_color = other(palette(I), bg)  # Identify non-background color
    target_cells = ofcolor(I, target_color)  # Get indices of target color cells
    expanded = set()  
    for i, j in target_cells:
        for di, dj in [DOWN, RIGHT]:  # Check down and right neighbors
            ni, nj = i + di, j + dj
            if 0 <= ni < height(I) and 0 <= nj < width(I) and I[ni][nj] == bg:
                expanded.add((ni, nj))
    O = fill(I, THREE, frozenset(expanded))  # Fill expanded cells with 3
    return O
 
49.5, 24.21522, def abcjdgfaaeaieaaeacacacfhegiajagi(I):
  objs = objects(I, T, F, T)
  output = I
  for obj in objs:
    for v, (i, j) in obj:
      output = fill(output, THREE, {(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1)})
  return output
 
47.0, 24.94178, def eicjedidaadheffdjdcccjecfbbidbde(I):
  output = I
  for obj in objects(I, T, F, T):
      output = underpaint(output, recolor(THREE, shift(obj, (-1, 0))))
      output = underpaint(output, recolor(THREE, shift(obj, (-1, 1))))
      output = underpaint(output, recolor(THREE, shift(obj, (-1, -1))))
      output = underpaint(output, recolor(THREE, shift(obj, (0, -1))))
      output = underpaint(output, recolor(THREE, shift(obj, (0, 1))))
  return output
 
25.5, 10.672666, def afcbdaeidffeedidajaefgffjadcadjh(I):
  O = I
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  for obj in objs:
    for v, (i, j) in obj:
      if j > 0:
        O = fill(O, 3, {(i, j - 1)})
      if j < len(I[0]) - 1:
        O = fill(O, 3, {(i, j + 1)})
  return O
 
14.5, 30.264742, def jhaabidjbfjbeefhihfbbdaffdcjbaaf(I):
  O = replace(I, 2, 3)
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  for obj in objs:
    O = paint(O, obj)
  return O
 
24.5, 10.781635, def dafddbjdeafbejijacbgcddfecffadaa(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    indices = toindices(obj)
    extended_indices = set()
    for i, j in indices:
      extended_indices.add((i, j-1))
      extended_indices.add((i, j+1))
    O = underfill(O, 3, extended_indices)
  return O
 
30.0, 9.626948, def eidbdfgcdhhhejfdabhjifaieajagaaf(I):
  O = canvas(0, shape(I))
  for obj in objects(I, False, True, True):
    right_extension = {(i, j + 1) for _, (i, j) in obj if j < len(I[0]) - 1 and index(I, (i, j + 1)) == 0}
    down_extension = {(i + 1, j) for _, (i, j) in obj if i < len(I) - 1 and index(I, (i + 1, j)) == 0}
    extended_indices = toindices(obj) | right_extension | down_extension
    O = paint(O, recolor(index(I, first(toindices(obj))), extended_indices))
  return O
 
28.0, 29.963219, def hfbihecaciicecedbgecgccfaijeedab(I):
  objs = objects(I, True, False, True)
  painted = I
  for obj in objs:
    painted = fill(painted, THREE, box(toindices(obj)))
  return painted 
 
57.5, 25.125113, def eacgbhcafaacebgfagbadcffajdiebhb(I):
  painted = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        for di in (-1, 0, 1):
          for dj in (-1, 0, 1):
            if (di != 0 or dj != 0) and 0 <= i + di < height(I) and 0 <= j + dj < width(I):
              if I[i + di][j + dj] == ZERO:
                painted = fill(painted, THREE, {(i + di, j + dj)})
  return painted
 
54.5, 28.131428, def adaiegfdfacdebadbibbhdbhgdicacae(I):
  objs = objects(I, True, False, True) 
  for obj in objs:
    upper = uppermost(obj)
    for j in range(leftmost(obj), rightmost(obj) + 1):
      for i in range(upper - 1, -1, -1):
        if index(I, (i, j)) == 2:
          break
        I = fill(I, 3, {(i, j)})
  return I
 
187.0, 28.333603, def ebfeefcgfaebeadbaafbdgdijhacfdfc(I):
  for j in range(width(I)):
    for i in range(height(I) - 1, -1, -1):
      if I[i][j] == 2:
        break
      elif I[i][j] == 0:
        I = fill(I, 3, {(i,j)})
        for k in range(i - 1, -1, -1):
          if I[k][j] != 0:
            break
          I = fill(I, 3, {(k,j)})
  return I
 
60.0, 24.920788, def hbdecadbeiabefagifdcbcjdcjgiccba(I):
  return tuple(
      tuple(
          3 if any(I[k][j] == 2 for k in range(i + 1, height(I))) else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
14.5, 30.264742, def icfagaebeejaefcciaegafcdfdidhdba(I):
  objs = objects(I, T, F, T)
  borders = mapply(lambda obj: delta(toindices(obj)), objs)
  return fill(I, THREE, merge(borders)) 
 
37.0, 28.793962, def fdbjgabibbjhecbijidabebbidaaechi(I):
  def make_border(obj):
    return recolor(THREE, mapply(lambda c: dneighbors(c), toindices(obj)) - toindices(obj))
  return paint(I, merge(apply(make_border, objects(I, T, F, T))))
 
57.5, 25.125113, def hfbfcaefdabjehcejdcgahiiheedecdh(I):
  def expand_obj(obj):
    return difference(mapply(neighbors, toindices(obj)), toindices(obj))
  expanded_objs = apply(expand_obj, objects(I, T, F, T))
  return fill(I, THREE, merge(expanded_objs)) 
 
14.5, 30.264742, def ciddaajjgfegeeiibbfaaeggbibeafig(I):
  O = canvas(0, shape(I))
  for obj in objects(I, False, True, True):
    right_extension = {(i, j + 1) for _, (i, j) in obj if j < len(I[0]) - 1 and index(I, (i, j + 1)) == mostcommon(I)}
    down_extension = {(i + 1, j) for _, (i, j) in obj if i < len(I) - 1 and index(I, (i + 1, j)) == mostcommon(I)}
    extended_indices = toindices(obj) | right_extension | down_extension
    O = underpaint(O, recolor(color(obj), extended_indices))
  return O
 
39.0, 11.14321, def bceabdhbgjbfeiccjehgdhceeahdajie(I):
  objs = objects(I, True, False, True)
  painted = I
  for obj in objs:
    left_edge = leftmost(obj) - 1  
    right_edge = rightmost(obj) + 1
    for x in range(left_edge, right_edge + 1):
      if 0 <= x < width(I):
        painted = fill(painted, THREE, {(uppermost(obj), x)})
  return painted
 
24.5, 10.781635, def cbhjfbhffdabefdcjdadfcbidgaffbaf(I):
  objs = objects(I, True, False, True)
  painted = I
  for obj in objs:
    for i in range(uppermost(obj), lowermost(obj) + 1):
      painted = fill(painted, THREE, {(i, leftmost(obj) - 1)})
      painted = fill(painted, THREE, {(i, rightmost(obj) + 1)})
  return painted
 
25.5, 10.672666, def cjehecadfcafeefbbgficgfaeabideca(I):
  modified_grid = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        if j > 0:
          modified_grid = fill(modified_grid, THREE, {(i, j - 1)})
        if j < width(I) - 1:
          modified_grid = fill(modified_grid, THREE, {(i, j + 1)}) 
  return modified_grid
 
24.0, 10.210886, def jeagajghbefaecaficcbacafbbcicbda(I):
  h, w = len(I), len(I[0])
  return tuple(
    tuple(
      THREE if 0<j<w-1 and (I[i][j-1]==TWO or I[i][j+1]==TWO) else cell
      for j, cell in enumerate(row)
    ) for i, row in enumerate(I)
  )
 
68.0, 21.515951, def jdcaafjaddcfeibaiegjjfcgfahaaede(I):
  h = height(I)
  return tuple(
    tuple(3 if any(I[k][j] == 2 for k in range(i, h)) else I[i][j] for j in range(width(I))) 
    for i in range(h)
  )
 
30.0, 19.388245, def fegffgibeheeeahbjgjbbdefefffebdb(I):
  return paint(I, 
               merge({
                   recolor(3, connect((i, j), (-1, 0)))
                   for i, row in enumerate(I) for j, val in enumerate(row) if val == 2
               })
             )
 
22.5, 22.291536, def bceffbeabcgceeacaceiigbdbdbhibdg(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  twos = next(obj for obj in objs if color(obj) == 2)
  return paint(I, 
               merge({
                 recolor(3, {(k, j) for k in range(i - 1, -1, -1) if (k, j) not in toindices(twos)})
                 for (i, j) in toindices(twos)
               })
             )
 
20.0, 12.346359, def bicbjidiiacfeaecadfehgedcafcbjcg(I):
  twos = ofcolor(I, TWO)
  shifted_right = shift(twos, RIGHT)
  O = fill(I, THREE, shifted_right)
  return O
 
33.0, 33.304455, def ieeiaccfgcbjebfaaajjcheijjbchjja(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            O = branch(
                value == TWO,
                fill(O, THREE, {(i, j + 1)}),
                O
            )
    return O
 
239.5, 55.287655, def dedeidedbcgbefdiaciiaaidgafffbaf(I):
  h, w = shape(I)
  O = [[v for v in row] for row in I]  # Create a copy of the input grid
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcommon(I):  # For each non-background cell
        if j < w - 1: O[i][j + 1] = 3 # Right shadow
        if i < h - 1: O[i + 1][j] = 3 # Down shadow
  return tuple(tuple(row) for row in O)
 
30.0, 10.240304, def ddieheacabfdejbbjagejaeiebgehfee(I):
  objs = objects(I, True, False, True)
  output = I
  for obj in objs:
    backdrop_above = backdrop(shift(obj, (-1, 0)))
    backdrop_below = backdrop(shift(obj, (1, 0)))
    line_above = backdrop_above - delta(backdrop_above)
    line_below = backdrop_below - delta(backdrop_below)
    output = fill(output, THREE, line_above)
    output = fill(output, THREE, line_below)
  return output
 
75.0, 36.50156, def cchjddiffehdefefbbiceffiaaaabdae(I):
  def hline_extension(grid, i, j):
    line = set()
    for k in range(j, -1, -1): # Extend left
      if index(grid, (i, k)) != 0:
        break
      line.add((i, k))
    for k in range(j + 1, len(grid[0])): # Extend right
      if index(grid, (i, k)) != 0:
        break
      line.add((i, k))
    return line
  filled_grid = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        filled_grid = fill(filled_grid, 3, hline_extension(I, i, j))
  return filled_grid
 
14.5, 30.264742, def jihgjfgefcebeffabachecdbbcfeiibi(I):
  def extend_line(grid, i, j, direction):
    line = set()
    current_j = j
    while 0 <= current_j < len(grid[0]) and grid[i][current_j] == 0:
      line.add((i, current_j))
      current_j += direction
    return line
  filled_grid = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        filled_grid = fill(filled_grid, 3, extend_line(I, i, j, -1)) # Extend left
        filled_grid = fill(filled_grid, 3, extend_line(I, i, j, 1))  # Extend right
  return filled_grid
 
12.5, 24.716702, def ibdidifceffgeeaiaecbebdajgdjfehj(I):
  objs = objects(I, T, F, T)
  output = I
  for obj in objs:
    if color(obj) == TWO and width(obj) == 2 and height(obj) == 1:
      start = (uppermost(obj), leftmost(obj) - 1)
      end = (uppermost(obj), rightmost(obj) + 1)
      line = connect(start, end)
      output = fill(output, THREE, shift(line, DOWN)) 
  return output
 
23.0, 10.322759, def eehbaigedeebebchihgechdhefgeejhc(I):
  return tuple(
    tuple(
      THREE if 0<j<len(I[0])-1 and (I[i][j-1]==TWO or I[i][j+1]==TWO) and I[i][j] == 0 else cell
      for j, cell in enumerate(row)
    ) for i, row in enumerate(I)
  )
 
26.5, 29.54408, def deadibchaaidecbbbhdejfeciecdedif(I):
  def hline_from_object(obj):
    return frozenset({(uppermost(obj), j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return fill(I, 3, merge({hline_from_object(obj) for obj in objects(I, True, False, False) if color(obj) == 2}))
 
121.0, 43.24084, def eihbfceajhdcebbbabfdjfabcgcadafb(I):
  def hline_indices(grid, i, j):
    if grid[i][j] != 0:
      return frozenset()
    left_j = j
    while left_j >= 0 and grid[i][left_j] == 0:
      left_j -= 1
    right_j = j 
    while right_j < len(grid[0]) and grid[i][right_j] == 0:
      right_j += 1
    return frozenset({(i, k) for k in range(left_j + 1, right_j)})
  return fill(I, 3, merge({hline_indices(I, i, j) for i, row in enumerate(I) for j, val in enumerate(row) if any(index(I, (i, k)) == 2 for k in range(len(I[0])))})) 
 
13.5, 26.955303, def agadbeachbcaeccbafcfdbbdijccaffa(I):
  horizontal_pairs = sfilter(objects(I, T, F, T), lambda obj: color(obj) == TWO and width(obj) == 2 and height(obj) == 1)
  extended_lines = mfilter(horizontal_pairs, lambda obj: connect(ulcorner(obj), (uppermost(obj), rightmost(obj) + 1)))
  return fill(I, THREE, shift(extended_lines, DOWN)) 
 
26.5, 52.52653, def ehhieccaaccfejbeibbgefbddedaddhj(I):
  h = height(I)
  w = width(I)
  new_grid = canvas(ZERO, (h, w))
  for i in range(h-1):
    for j in range(w-1):
      if I[i][j] == TWO and I[i][j+1] == TWO:
        new_grid = fill(new_grid, THREE, {(i+1, j), (i+1, j+1), (i+1, j+2)})
  return new_grid
 
24.5, 13.6127205, def ibddgafdccdiefjbibjiaaibcbgcahef(I):
  shadow_color = 3
  shadow_offset = (RIGHT, DOWN)
  O = paint(canvas(mostcommon(I), shape(I)), asobject(I)) # Initialize with input
  for obj in objects(I, False, True, True):
    for offset in shadow_offset:
      shadow_obj = recolor(shadow_color, shift(toindices(obj), offset))
      O = underpaint(O, shadow_obj)
  return O
 
240.5, 59.46244, def feceafegcdbdefaiacffaddhihadjdfe(I):
  O = I
  for dx, dy in (RIGHT, DOWN):
    shifted = shift(asobject(I), (dx, dy))
    shadow = recolor(3, toindices(shifted))
    O = cellwise(paint(canvas(mostcommon(I), shape(I)), shadow), O, 3)
  return O
 
121.0, 43.24084, def fahjicfaeffceijaaefbefcahchbhcfe(I):
  objs = objects(I, True, False, True)
  output = I
  for obj in objs:
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(leftmost(obj) - 1, -1, -1):
        if index(output, (i, j)) != 0:
          break
        output = fill(output, THREE, ((i, j),))
      for j in range(rightmost(obj) + 1, len(I[0])):
        if index(output, (i, j)) != 0:
          break
        output = fill(output, THREE, ((i, j),))
  return output
 
131.0, 38.042526, def dcaffbbcacfhebddbdgchdbffgfajcda(I):
  output = I
  for i, row in enumerate(I):
    for obj in objects(I, True, False, True):
      if uppermost(obj) <= i <= lowermost(obj):
        left_edge = leftmost(obj)
        right_edge = rightmost(obj)
        output = fill(output, THREE, connect((i, 0), (i, left_edge - 1)))
        output = fill(output, THREE, connect((i, right_edge + 1), (i, len(row) - 1)))
  return output
 
95.0, 50.785225, def gbfbfbjbbbcdeceijdgdbfbbdeaafjdf(I):
  objs = objects(I, True, False, True)
  output = I
  for obj in objs:
    line = connect((centerofmass(obj)[0], 0), (centerofmass(obj)[0], len(I[0]) - 1))
    for i, j in line:
      if index(output, (i, j)) != 0 and (i, j) not in toindices(obj):
        break
      output = fill(output, THREE, ((i, j),))
  return output
 
14.5, 30.264742, def bdigaccfcdfeefeejebfajiiccffeaea(I):
  def extend_line(grid, start, direction):
    current = start
    while 0 <= current[0] < len(grid) and 0 <= current[1] < len(grid[0]):
      if index(grid, current) != 0:
        break
      grid = fill(grid, THREE, (current,))
      current = (current[0] + direction[0], current[1] + direction[1])
    return grid

  output = I
  for obj in objects(I, True, False, True):
    for j in range(leftmost(obj), rightmost(obj) + 1):
      output = extend_line(output, (centerofmass(obj)[0], j), (-1, 0))
      output = extend_line(output, (centerofmass(obj)[0], j), (1, 0))
  return output
 
240.5, 59.46244, def hfgabdaadccfehebbaecfacaibchbgbh(I):
  objs = objects(I, True, False, True)
  output = I
  for obj in objs:
    for j in range(leftmost(obj) - 1, -1, -1):
      column = {(i, j) for i in range(len(I))}
      if len(intersection(toindices(obj), column)) > 0:
        break
      output = fill(output, THREE, column)

    for j in range(rightmost(obj) + 1, len(I[0])):
      column = {(i, j) for i in range(len(I))}
      if len(intersection(toindices(obj), column)) > 0:
        break
      output = fill(output, THREE, column)
  return output
 
28.0, 14.514712, def eebcababcbgbedcgaccacaaebjiidcab(I):
  def connected_twos(i, j):
    return {(i, k) for k in range(width(I)) if contained((TWO, (i, k)), asobject(I)) and abs(k - j) <= 1}
  return tuple(
    tuple(
      THREE if any(len(connected_twos(i, j)) > 1 for i in range(height(I))) else v
      for j, v in enumerate(row)
    ) 
    for row in I
  )
 
25.0, 29.6207, def hjehcigheaefeaadjajhcghdeagbffhe(I):
  for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
    if color(obj) == TWO and hline(toindices(obj)):
      start_j = leftmost(obj)
      end_j = rightmost(obj)
      for j in range(start_j, end_j + 1):
        I = fill(I, THREE, {(uppermost(obj), j)})
  return I
 
14.5, 28.973742, def dedbeaeeddgbecbbaefbfeicebcifafa(I):
  """ 
  Identifies horizontally connected '2' pixels and 
  highlights them and their neighbors with '3'.
  """
  painted = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO and j + 1 < width(I) and I[i][j + 1] == TWO:
        painted = fill(painted, THREE, {(i, j - 1 if j > 0 else j), (i, j), (i, j + 1), (i, j + 2 if j + 2 < width(I) else j + 1)})
  return painted
 
39.5, 12.758958, def jcdedaccdbadeegdjgaceebhbebffegd(I):
  """
  Highlights horizontally connected '2' pixels 
  using object manipulation.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  for obj in objs:
    if color(obj) == TWO and hline(obj):
      I = paint(I, recolor(THREE,  obj))
      I = paint(I, recolor(THREE,  shift(obj, LEFT)))
      I = paint(I, recolor(THREE,  shift(obj, RIGHT)))
  return I 
 
15.5, 30.283802, def bggeehagfabieggcajhdgdfafdajbfbd(I):
  """
  Marks cells for highlighting based on 
  neighboring '2' pixels and then applies the change. 
  """
  marked = canvas(ZERO, shape(I))
  for i, r in enumerate(I):
    for j, v in enumerate(r):
      if v == TWO and ((j > 0 and I[i][j - 1] == TWO) or (j < width(I) - 1 and I[i][j + 1] == TWO)):
        marked = fill(marked, ONE, {(i, j)})
  return paint(I, recolor(THREE, toobject(ofcolor(marked, ONE), I)))
 
17.5, 28.099033, def cbgffcfcafggeehcjafcdbfaejjdjdcc(I):
  """
  Uses recursion to traverse and highlight 
  horizontally connected '2' pixels.
  """
  def highlight_connected(grid, i, j):
    if 0 <= j < width(grid) and grid[i][j] == TWO:
      grid = fill(grid, THREE, {(i, j - 1 if j > 0 else j), (i, j), (i, j + 1 if j + 1 < width(grid) else j)})
      grid = highlight_connected(grid, i, j + 1)
      return grid
    return grid

  painted = I
  for i in range(height(I)):
    painted = highlight_connected(painted, i, 0)
  return painted
 
14.5, 23.41951, def cjceajiefabaeedcjefjabiffgaeddfb(I):
  for i in range(len(I)-1):
    for j in range(len(I[0])-2):
      if I[i][j] == I[i][j+1] == TWO:
        for di in range(2):
          for dj in range(3):
            if 0 <= i+di < len(I) and 0 <= j+dj+1 < len(I[0]):
              I = fill(I, THREE, {(i+di, j+dj+1)})
  return I
 
240.5, 59.46244, def icddedgfbcicejdfabcebffhcfiafica(I):
  O = canvas(mostcommon(I), shape(I)) # Start with a canvas of background color
  for i, row in enumerate(I):
    start = None
    for j, val in enumerate(row):
      if val != mostcommon(I) and start is None: # Start of a segment
        start = j
      elif val != mostcommon(I) and start is not None: # End of a segment
        O = paint(O, recolor(3, frozenset((i, k) for k in range(start, j))))
        start = j
      elif val == mostcommon(I) and start is not None: # Inside a segment
        O = paint(O, {(3, (i, j))})
    if start is not None: # Handle the last segment
      O = paint(O, recolor(3, frozenset((i, k) for k in range(start, len(row)))))
  return O 
 
18.5, 29.749086, def feeabcefbhcheefdifbfeeeddhccddfa(I):
  """
  Uses objects to connect adjacent '2' pixels with '3'.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  connected_objs = frozenset(
      obj if color(obj) != TWO or len(obj) == 1 else recolor(THREE, obj)
      for obj in objs
  )
  return paint(canvas(ZERO, shape(I)), merge(connected_objs))
 
15.0, 30.194696, def fidbcbacibeeedbjjfgcccadhjeaeeba(I):
  """
  Shifts the grid and compares to identify adjacent '2's.
  """
  shifted = shift(asobject(I), RIGHT)
  return tuple(
      tuple(
          THREE if 0 < j < width(I) and I[i][j] == TWO and (i, j) in toindices(intersection(asobject(I), shifted)) else cell
          for j, cell in enumerate(row)
      ) for i, row in enumerate(I)
  )
 
20.0, 12.346359, def aabhdheehhfcejbcbfhhdeaebdfdafja(grid):
  # First pass: Mark cells right of a '2' with a temporary value ('4')
  marked_grid = tuple(
    tuple(4 if j > 0 and row[j-1] == 2 and val == 0 else val for j, val in enumerate(row))
    for row in grid
  )

  # Second pass: Replace '4's adjacent to a '2' on the left with '3'
  return tuple(
    tuple(3 if (j > 0 and row[j-1] == 2) or (j < len(row)-1 and row[j+1] == 2) and val == 4 else val for j, val in enumerate(row))
    for row in marked_grid
  ) 
 
19.5, 12.453273, def dbihjajgheeceedcaifaadffjcdaghcc(grid):
  return tuple(
    tuple(
        3 if val == 0 and (
            (j > 0 and row[j-1] == 2) or
            (j < len(row) - 1 and row[j+1] == 2 and all(v == 0 for v in row[j+1:min(len(row), j+2)]))
        )
        else val
        for j, val in enumerate(row)
    ) for row in grid
  )
 
28.0, 58.2238, def dddbegaddejeebhabddjacafgddheagh(grid):
  new_grid = canvas(0, shape(grid))
  for obj in objects(grid, univalued=False, diagonal=False, without_bg=False):
    if color(obj) == 2:
      for i, j in toindices(obj):
        new_grid = fill(new_grid, 3, {(i, j-1)})
        new_grid = fill(new_grid, 3, {(i, j+1)})
      new_grid = paint(new_grid, obj) 
  return new_grid
 
129.5, 38.60097, def jbefiibedecceeedaacfjdgbbdjhhajb(I):
  O = I 
  for i in range(len(I)):
    for obj in objects(crop(I, (i,0), (1, len(I[0]))), univalued=True, diagonal=False, without_bg=True):
      leftmost_j = leftmost(obj)
      rightmost_j = rightmost(obj)
      O = fill(O, 3, {(i, j) for j in range(0, leftmost_j)})
      O = fill(O, 3, {(i, j) for j in range(rightmost_j + 1, len(I[0]))})
  return O
 
227.5, 40.04216, def cjbdegccahhaefcfbjabfaecfbbiceaa(I):
  O = canvas(mostcommon(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcommon(I):
        O = fill(O, 3, connect((i, j), (i, 0)))
        O = fill(O, 3, connect((i, j), (i, len(I[0]) - 1)))
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
37.0, 9.76929, def jhdjecbhiabcebadiceafbjebfbabcfc(I):
  O = paint(canvas(mostcommon(I), shape(I)), asobject(I))  # Initialize with input
  shifted_downright = paint(canvas(ZERO, shape(I)), shift(asobject(I), (1,1))) # Shift diagonally down-right
  shifted_right = paint(canvas(ZERO, shape(I)), shift(asobject(I), RIGHT)) # Shift directly right
  O = cellwise(O, shifted_downright, THREE)  # Apply down-right shadow
  O = cellwise(O, shifted_right, THREE) # Apply right shadow
  return O 
 
39.0, 27.484941, def fififfafdebieiccaaghcgbbajgbhefg(grid):
  for i, row in enumerate(grid):
    for j, value in enumerate(row):
      if value == 2:
        if (j > 0 and grid[i][j - 1] == 0 and not (0 < i < height(grid) - 1 and (grid[i - 1][j - 1] != 0 or grid[i + 1][j - 1] != 0))):
          grid = fill(grid, 3, {(i, j - 1)})
        if (j < width(grid) - 1 and grid[i][j + 1] == 0 and not (0 < i < height(grid) - 1 and (grid[i - 1][j + 1] != 0 or grid[i + 1][j + 1] != 0))):
          grid = fill(grid, 3, {(i, j + 1)})
        if (i > 0 and grid[i - 1][j] == 0):
          grid = fill(grid, 3, {(i - 1, j)})
        if (i < height(grid) - 1 and grid[i + 1][j] == 0):
          grid = fill(grid, 3, {(i + 1, j)})
  return grid
 
28.0, 29.963219, def fbacdjdbcgabejcdbaebeiabbjcdgbjf(I):
  O = I
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    for (i, _) in toindices(obj):
      O = fill(O, 3, {(i, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return O
 
23.5, 11.3911705, def ffffchcdfeebeiabaabhdjaajgfifbcc(I):
  shadow_applicator = lambda i, j: {(i + 1, j + 1), (i, j + 1)}
  shadow_indices = mpapply(shadow_applicator, *zip(*merge(apply(toindices, objects(I, False, True, True)))))
  return underfill(paint(canvas(mostcommon(I), shape(I)), asobject(I)), 3, shadow_indices)
 
15.0, 30.146627, def hiecebciigieeajbihecbgfhbdeafcfg(I):
  """
  Connects horizontally adjacent '2's using pairwise comparison with papply.
  """
  return tuple(
      tuple(
          THREE if j < width(I) - 1 and a == TWO and b == TWO else a
          for j, (a, b) in enumerate(papply(astuple, row, row[1:] + (ZERO,)))
      ) for row in I
  )
 
24.5, 10.781635, def fadacadeiaeeebffjdaddcafdhacidab(grid):
  h, w = height(grid), width(grid)
  return tuple(
    tuple(
      3 if (
        grid[i][j] == 0 and 
        (j > 0 and grid[i][j - 1] == 2 or j < w - 1 and grid[i][j + 1] == 2) and 
        (i == 0 or grid[i - 1][j] == 0) and 
        (i == h - 1 or grid[i + 1][j] == 0)
      ) else grid[i][j] 
      for j in range(w)
    ) for i in range(h)
  )
 
25.0, 10.55059, def dafehibhcabdebehicedcabchefeacbe(grid):
  def fill_horizontal_gaps(row):
    new_row = list(row)
    for j in range(1, len(row) - 1):
      if row[j] == 0 and (row[j - 1] == 2 or row[j + 1] == 2):
        new_row[j] = 3
    return tuple(new_row)

  def apply_with_isolation(grid):
    h = height(grid)
    new_grid = [list(row) for row in grid]
    for i in range(h):
      new_grid[i] = list(fill_horizontal_gaps(grid[i]))
      if i > 0:
        for j in range(len(new_grid[i])):
          if new_grid[i][j] == 3 and new_grid[i - 1][j] != 0:
            new_grid[i][j] = 0
    return tuple(tuple(row) for row in new_grid)
  return apply_with_isolation(grid)
 
50.0, 18.989609, def agibdeeedabaehcabjjbddbdghfgfbaa(I):
  lines = objects(I, True, False, False)
  hlines = sfilter(lines, hline)
  new_cells = set()
  for line in hlines:
    upper, left = ulcorner(line)
    width = len(line)
    for j in range(left, left + width):
      if even(j-left):
        new_cells.add(((upper, j)))
    new_cells.add(((upper, left-1)))
    new_cells.add(((upper, left + width)))
  O = fill(I, 2, frozenset(new_cells))
  return O 
 
240.5, 23.564575, def adjdfcbaddheeeadicafdccaeeacacjc(I):
  h = height(I)
  w = width(I)
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(1, w - 1):
      if I[i][j-1] == I[i][j] == I[i][j+1]:
        O = paint(O, {(2, (i, j-1)), (2, (i, j+1)), (2, (i, j))})
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
65.5, 15.234081, def fehecfbbbeceecaijfhcfdidajhffbdf(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, True, False, False):
        if hline(obj):
            O = paint(O, recolor(2, obj))
            O = paint(O, recolor(2, shift(obj, (-1, 0))))
            O = paint(O, recolor(2, shift(obj, (1, 0))))
    return O
 
43.0, 15.532785, def daeibcadcafdefbgiciagbjbacaegddd(I):
    # Get indices of all '3's
    threes = ofcolor(I, 3) 
    # Initialize output grid with same dimensions as input
    O = canvas(0, shape(I)) 
    h, w = len(I), len(I[0])
    # Iterate through each cell 
    for i in range(h):
        for j in range(w):
            # Check if cell is on a diagonal line formed by '3's
            if (i,j) in threes: 
                # Alternate between '2' and '3' based on sum of indices
                O = fill(O, 2 if (i+j)%2==0 else 3, {(i,j)})
            else:
                # Keep other cells unchanged
                O = fill(O, I[i][j], {(i,j)})
    return O
 
73.0, 37.089745, def fjejfdfcffeceeecbjccijhdebijjdfd(I):
    # Get indices of all '3's in the original and diagonally mirrored grids
    threes = ofcolor(I, 3) 
    threes_mirrored = ofcolor(dmirror(I), 3)
    # Initialize output grid with same dimensions as input
    O = canvas(0, shape(I)) 
    h, w = len(I), len(I[0])
    # Iterate through each cell 
    for i in range(h):
        for j in range(w):
            # Check if cell is on a diagonal line 
            if (i,j) in threes or (i,j) in threes_mirrored: 
                # Alternate between '2' and '3'
                O = fill(O, 2 if (i+j)%2==0 else 3, {(i,j)})
            else:
                # Keep other cells unchanged
                O = fill(O, I[i][j], {(i,j)})
    return O
 
40.0, 13.289019, def ebdbdficgeaeeafgjbafccccdicgjaja(I):
    # Identify objects and filter for those with color '3'
    objs = objects(I, True, False, True)
    threes = colorfilter(objs, 3)
    # Initialize output grid
    O = canvas(0, shape(I))
    # Iterate through objects with color '3'
    for obj in threes:
        # Paint the object with alternating '2's and '3's 
        for k, (i, j) in enumerate(obj):
            O = fill(O, 2 if k % 2 == 0 else 3, {(i, j)})
    # Paint other objects from the input to the output
    for obj in objs - threes:
        O = paint(O, obj)
    return O
 
46.5, 9.976306, def dgfaacaibcecececibaedabbcghbdaeb(I):
    # Get indices of top-left and bottom-right corners of the grid
    h, w = len(I), len(I[0])
    tl = (0, 0)
    br = (h - 1, w - 1)
    # Generate diagonal lines 
    diag1 = connect(tl, br)
    diag2 = connect((0, w - 1), (h - 1, 0))
    # Initialize output grid
    O = canvas(0, shape(I))
    # Iterate through each cell
    for i in range(h):
        for j in range(w):
            # Check if cell belongs to either diagonal line
            if (i, j) in diag1 or (i, j) in diag2:
                # Alternate between '2' and '3'
                O = fill(O, 2 if (i + j) % 2 == 0 else 3, {(i, j)})
            else:
                # Keep other cells unchanged
                O = fill(O, I[i][j], {(i, j)})
    return O
 
200.5, 60.108727, def dedajchjaecdedeeacafaadbdabfceac(I):
  threes = ofcolor(I, 3)
  O = canvas(0, shape(I))
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      shifted = {(i + k, j + k) for k in range(-min(h, w), min(h, w))}
      if len(shifted.intersection(threes)) > 0:
        O = fill(O, 2 if (i + j) % 2 == 0 else 3, {(i, j)})
      else:
        O = fill(O, I[i][j], {(i, j)})
  return O
 
55.5, 10.626126, def ggfideeadeabeijejdebhdbebdddabbd(I):
  objs = objects(I, T, T, T)
  shifted_objs = frozenset({(2, (i+1, j+1)) if i < len(I)-1 else (2, (0, j+1))  for obj in objs for v, (i, j) in obj})
  O = paint(canvas(0, shape(I)), shifted_objs)
  return O
 
57.5, 11.351031, def cbdfbbdhceecebddbebhbgfbdhcaaajb(I):
  indices_3 = ofcolor(I, 3)
  shifted_indices = frozenset(((i+1)%len(I), (j+1)%len(I[0])) for i, j in indices_3)
  O = paint(fill(I, 0, indices_3), recolor(2, shifted_indices))
  return O
 
45.5, 10.434148, def badafdccaccdebddijddcaccdadbfbei(I):
  shifted = shift(recolor(2, ofcolor(I, 3)), (1, 1))
  O = paint(canvas(0, shape(I)), shifted)
  return O
 
33.5, 26.4655, def aedbeeeaagcbebafbhhjjbfajafhcacf(I):
  def process_cell(i, j):
    if I[i][j] == 3:
      return (2, ((i + 1) % len(I), (j + 1) % len(I[0])))
    return (0, (i, j))
  
  new_cells = [process_cell(i, j) for i in range(len(I)) for j in range(len(I[0]))]
  O = paint(canvas(0, shape(I)), frozenset(new_cells))
  return O
 
111.0, 44.92894, def aibiaadchbbjejfeiidecefaefbabjab(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    O = underfill(O, 2, outbox(toindices(obj)))
  return O
 
136.5, 19.021128, def chiedcbfbiheebeaiifdgfafabfaffhb(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    for idx in toindices(obj):
      if len(neighbors(idx) - toindices(obj)) > 0:
        O = paint(O, {(2, idx)})
  return O
 
98.5, 22.568586, def cfdgcdcbbcfheedbjjhefcbidggeeegc(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    O = paint(O, recolor(2, box(toindices(obj))))
    O = underpaint(O, obj)
  return O 
 
135.0, 23.308744, def dididfjcfbgeeadejgcdaefddcjhfhec(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    border = toindices(obj)
    for _ in range(2):
      border = mapply(dneighbors, border) - toindices(obj)
    O = fill(O, 2, border)
  return O
 
46.5, 10.080831, def ajbbfacddgebegaficceifhbddfaaccj(I):
    objs = objects(I, False, False, True)
    largest = argmax(objs, size)
    corners_ = difference(corners(outbox(largest)), {urcorner(largest)})
    singles = recolor(2, corners_)
    O = paint(cover(I, merge(objs)), merge(objs) | singles)
    return O
 
54.5, 22.715273, def gfidhddaeadieaegbabfjhaiifcdjcjb(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        O = paint(O, recolor(2, {llcorner(obj), urcorner(obj)}))
        for j in range(leftmost(obj) + 1, rightmost(obj)):
            if (uppermost(obj), j) not in toindices(obj):
                O = paint(O, {(2, (uppermost(obj), j))})
        for j in range(leftmost(obj) + 1, rightmost(obj)):
            if (lowermost(obj), j) not in toindices(obj):
                O = paint(O, {(2, (lowermost(obj), j))})
        for i in range(uppermost(obj) + 1, lowermost(obj)):
            if (i, rightmost(obj)) not in toindices(obj):
                O = paint(O, {(2, (i, rightmost(obj)))})
    return O
 
40.5, 11.375498, def idgfdfcjadffebafjdfebfcffbaeicde(I):
    # Identify single-cell '3' objects
    objs = objects(I, True, False, True)
    single_cell_objs = sizefilter(objs, 1)

    # Shift and recolor each single-cell object
    shifted_objs = frozenset({recolor(2, shift(obj, (1,1))) for obj in single_cell_objs})

    # Paint the shifted objects and replace original '3' with '2'
    O = paint(replace(I, 3, 2), merge(shifted_objs))
    return O
 
50.0, 10.858557, def fffbjeceiffeecfgjjhcfjbghhbjbach(I):
    # Find indices of single-cell '3's
    indices_3 = ofcolor(I, 3)
    single_cell_indices = frozenset(
        loc for loc in indices_3 if len(dneighbors(loc) & indices_3) == 0
    )
    
    # Shift and recolor the indices
    shifted_indices = frozenset(((i+1)%len(I), (j+1)%len(I[0])) for i, j in single_cell_indices)
    
    # Modify the grid
    O = paint(fill(I, 0, single_cell_indices), recolor(2, shifted_indices))
    return O
 
49.5, 10.505332, def bdfdfhbaabiiefbaiddbbafffcgaaheg(I):
    # Find locations of single-cell '3's
    single_cell_locs = frozenset(
        (i, j)
        for i in range(len(I))
        for j in range(len(I[0]))
        if I[i][j] == 3 and sum(I[i + di][j + dj] == 3 for di, dj in [(0, 1), (1, 0), (1, 1), (-1, 0), (0, -1), (-1, -1), (1, -1), (-1, 1)] if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0])) == 0
    )

    # Create a new grid by applying the transformation
    O = tuple(
        tuple(
            2 if (i, j) in {(x + 1, y + 1) for x, y in single_cell_locs} else (0 if (i, j) in single_cell_locs else I[i][j])
            for j in range(len(I[0]))
        )
        for i in range(len(I))
    )
    return O
 
64.5, 31.110678, def bgcdhajchicaedcdbfdbcbfecjdaifhb(I):
  objs = objects(I, T, T, T)  # Extract all objects excluding background
  shifted_objs = apply(lambda obj: shift(recolor(TWO, obj), (ONE, ONE)), objs)  # Shift and recolor each object
  O = paint(I, merge(shifted_objs))  # Paint the shifted objects onto the input grid
  return O
 
64.5, 31.02463, def dahbabdcefaeecihjhebbfcahbadijfa(I):
    O = I
    for obj in objects(I, T, T, T):
        O = underpaint(O, shift(recolor(TWO, obj), (ONE, ONE)))  # Underpaint shifted and recolored object
    return O
 
43.0, 20.57536, def eicdacdebhdheijgaijchcjgcfhbhfaf(I):
    O = canvas(mostcolor(I), shape(I)) # create empty canvas
    for obj in objects(I, T, T, T):
        O = paint(O, shift(recolor(TWO, obj), add(ulcorner(obj), (ONE, ONE)))) # paint shifted object on empty canvas
    return O
 
39.0, 11.616695, def degaaggfajhheaccifffcfjdcecjjhbj(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = set()
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    shift_distance = (i // 3, j // 3)  # Adjust the divisor for different shift patterns
    shifted_obj = shift(obj, shift_distance)
    shifted_objs.add(shifted_obj)
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
38.0, 18.25915, def fdaicdjgbcfdejajaacidaedgidfegcf(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    ref_point = (len(I) // 2, len(I[0]) // 2)  # Define a reference point
    shifted_objs = set()
    for obj in objs:
        i, j = centerofmass(obj)
        rel_i = (i - ref_point[0]) // 5  # Adjust the divisor for different shift patterns
        rel_j = (j - ref_point[1]) // 5
        shifted_obj = shift(obj, (rel_i, rel_j))
        shifted_objs.add(shifted_obj)
    O = paint(canvas(bg, shape(I)), merge(shifted_objs))
    return O
 
39.5, 23.68817, def bbjbaadfcdbbebbcjdfagdbdfiaaadba(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = set()
  for obj in objs:
      neighbors_count = sum(1 for i, j in toindices(obj)
                            for x, y in dneighbors((i, j))
                            if 0 <= x < len(I) and 0 <= y < len(I[0]) and I[x][y] != bg)
      shift_distance = (neighbors_count // 4, neighbors_count // 4) 
      shifted_obj = shift(obj, shift_distance)
      shifted_objs.add(shifted_obj)
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
41.0, 9.714996, def cjccccieajgbeecdaefacdeifdbbffhc(I):
  O = canvas(2, shape(I))
  objs = objects(I, True, False, False)
  for obj in objs:
    O = underpaint(O, obj)
  return O 
 
125.5, 17.951674, def eaheceefhiebebfcjgfibhfaedddejda(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    for ind in toindices(obj):
      if len(dneighbors(ind) - toindices(obj)) > 0: 
          O = fill(O, 2, initset(ind))
  return O
 
42.5, 16.46282, def diaabagaabcaedbaifccdbebhhbfceeg(I):
  shifted_grids = (
      shift(asobject(I), UP), 
      shift(asobject(I), DOWN),
      shift(asobject(I), LEFT),
      shift(asobject(I), RIGHT)
  )
  O = I
  for shifted_grid in shifted_grids:
    O = cellwise(I, paint(cover(canvas(mostcolor(I), shape(I)), shifted_grid), shifted_grid), 2)
  return O
 
55.0, 15.006874, def jbeibhfadaedebdfjbedcjbebgjcbfdi(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        O = paint(O, recolor(2, {llcorner(obj), urcorner(obj)}))
        for i in range(uppermost(obj), lowermost(obj) + 1):
            for j in range(leftmost(obj), rightmost(obj) + 1):
                if i == uppermost(obj) or i == lowermost(obj) or j == leftmost(obj) or j == rightmost(obj):
                    if index(O, (i,j)) != 2:
                        O = paint(O, {(2, (i, j))})
    return O
 
38.0, 9.817221, def hfgahagccfcfejgfacifjeejabdeicfc(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        bbox = box(obj)
        O = paint(O, recolor(2, bbox | {llcorner(obj), urcorner(obj)}))
        O = paint(O, recolor(mostcolor(I), bbox - toindices(obj)))
    return O
 
74.0, 12.026091, def cbcdccidfifcegfebbcjafgddjcfabdg(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        outline = box(obj)
        shifted_outline = shift(outline, (1, 0)) & asindices(I)
        combined_outline = outline | shifted_outline | {llcorner(obj), urcorner(obj)}
        O = paint(O, recolor(2, combined_outline))
    return O
 
64.5, 31.110678, def debihdcdhdeeedcbaebcbeabcbedccea(I):
    target_color = leastcolor(I)
    shifted_objs = mapply(
        lambda loc: shift(recolor(2, {(target_color, loc)}), (1, 1)),
        ofcolor(I, target_color)
    )
    O = paint(canvas(0, shape(I)), asobject(I))
    O = paint(O, shifted_objs)
    return O
 
27.5, 43.117268, def cfcfaffhhhhaefejbaffcahicafcfieh(I):
    target_color = leastcolor(I)
    O = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == target_color:
                new_i, new_j = i + 1, j + 1
                if 0 <= new_i < len(I) and 0 <= new_j < len(row):
                    O = paint(O, {(2, (new_i, new_j))})
            else:
                O = paint(O, {(value, (i, j))})
    return O
 
57.0, 12.006939, def afabhjigajaaegeaifhefacaabcacaae(I):
    target_color = leastcolor(I)
    O = paint(canvas(0, shape(I)), asobject(I)) # Paint original grid
    for i, j in ofcolor(I, target_color):
        new_i, new_j = i + 1, j + 1
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
            O = paint(cover(O, {(target_color, (i, j))}), {(2, (new_i, new_j))}) 
    return O
 
40.0, 16.922129, def bddhfadabfaeejadbfaechdaddbecege(I):
  objs = objects(I, T, F, T) # Identify objects excluding background
  bg = mostcolor(I) # Get background color
  shifted_objs = set() 
  for obj in objs:
    i, j = ulcorner(toindices(obj)) # Get upper-left corner
    shift_distance = (size(obj) // 2, size(obj) // 2) # Calculate shift based on size
    shifted_obj = shift(obj, shift_distance) # Shift the object
    shifted_objs.add(shifted_obj) # Add shifted object to the set
  O = paint(canvas(bg, shape(I)), merge(shifted_objs)) # Paint all shifted objects
  return O
 
35.0, 13.936704, def icadcgdabcaeedchaedaagfjbgfdbaee(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = mapply(
      lambda obj: shift(obj, (uppermost(obj) // 2, leftmost(obj) // 2)), 
      objs
  ) # Use mapply for shift and merge
  O = paint(canvas(bg, shape(I)), shifted_objs) 
  return O
 
40.0, 18.734177, def hdiejaibfcahedfdigjdchedbedhibii(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = {shift(obj, (len(obj) // 3, len(obj) // 3)) for obj in objs}
  # Use set comprehension for shift
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
38.0, 15.481279, def fhhffdahgfcfeagiahifchddaadcfhbb(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = set()
  for obj in objs:
    h, w = shape(obj) # Calculate height and width
    shift_distance = (h // 2 + w // 4, w // 2 + h // 4) # Complex shift calculation
    shifted_obj = shift(obj, shift_distance)
    shifted_objs.add(shifted_obj)
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
42.5, 10.279934, def ihechafbceadeeeaaicgfcbeeddfjefd(I):
  h, w = len(I), len(I[0])
  O = [[I[i][j] for j in range(w)] for i in range(h)]
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if I[i][j] != mostcolor(I) and any(I[ni][nj] == mostcolor(I) for ni, nj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]):
        O[i][j] = 2
  return tuple(tuple(row) for row in O)
 
58.5, 19.297905, def jhhfacfdebdcebffjbaeefefifedceah(I):
  objs = objects(I, False, False, True)
  O = cover(I, merge(objs))
  for obj in objs:
    ul = ulcorner(obj)
    ur = urcorner(obj)
    ll = llcorner(obj)
    top_edge = connect((ul[0], ul[1] + 1), (ur[0], ur[1] - 1))
    bottom_edge = connect((ll[0], ll[1] + 1), (ur[0], ur[1] - 1))
    right_edge = connect((ul[0] + 1, ur[1]), (ll[0] - 1, ll[1]))
    outline = {ul, ur, ll} | top_edge | bottom_edge | right_edge 
    O = paint(O, recolor(2, outline))
  return O
 
112.0, 45.946644, def bbabacifeedfedfcihdbdcbcaiibebbf(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    O = paint(O, recolor(2, outbox(inbox(obj))))
  return O
 
37.5, 9.211693, def dhcgjaijfachebfhjfeedcefahfdadff(I):
  h, w = len(I), len(I[0])
  O = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] != 0: 
        if i == 0 or i == h - 1 or j == 0 or j == w - 1 or \
           I[i-1][j] == 0 or I[i+1][j] == 0 or I[i][j-1] == 0 or I[i][j+1] == 0:
          O[i][j] = 2
        else:
          O[i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
53.5, 22.594622, def jhbbabgfcagdeghbjaidhafgfjacdhae(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    outline = delta(obj) | corners(obj)
    O = paint(O, recolor(2, outline))
  return O
 
46.0, 13.065657, def ibdgbaabcacaecdaieiacdbaiedbhfei(I):
  target_color = leastcolor(I)
  single_cells = {(i, j) for i, r in enumerate(I) for j, v in enumerate(r) if v == target_color and sum(I[i+di][j+dj] == target_color for di, dj in [(0,1), (1,0), (0,-1), (-1,0), (1,1), (-1,1), (1,-1), (-1,-1)] if 0 <= i+di < len(I) and 0 <= j+dj < len(I[0])) == 0}
  O = paint(canvas(0, shape(I)), asobject(I))
  for i, j in single_cells:
    O = paint(O, {(2, (i, j))})
    if i < len(I) - 1 and j < len(I[0]) - 1:
      O = paint(O, {(2, (i + 1, j + 1))})
  return O
 
45.5, 10.434148, def agdcjdeeafjheebibcehcffbchahajci(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    O = underpaint(O, recolor(TWO, toindices(shift(obj, (ONE, ONE)))))
  return O
 
218.0, 26.611967, def hfdfbaiiadfbebfjidfccaecjccceibd(I):
  O = I
  for i, j in asindices(I):
    if index(I, (i-ONE, j-ONE)) is not None:
      O = fill(O, TWO, {(i, j)})
  return O
 
26.5, 45.21575, def cdcdaiaicehiejidiaccdiieffbbfbcc(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = set()
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    shift_amount = (1, 1)  
    max_shifts = size(obj) // 3
    for _ in range(max_shifts):
      obj = shift(obj, shift_amount) 
      i, j = add((i, j), shift_amount) 
    shifted_objs.add(frozenset({(TWO, (i, j))}))
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
29.5, 47.731323, def hhaahcedafejejcdjjgbdegaeebddgff(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  new_objs = set()
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    shift_distance = (max(0, i - 5), max(0, j - 5)) 
    new_obj = shift(recolor(TWO, {(i, j)}), shift_distance) 
    new_objs.add(new_obj)
  O = paint(canvas(bg, shape(I)), merge(new_objs))
  return O
 
26.5, 44.58815, def hcieibcaicagedefjidefddbbfahiabf(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shifted_objs = set()
  for obj in objs:
    s = size(obj) 
    i, j = ulcorner(toindices(obj))
    new_i = i + (s // 2 if s > 4 else 0)
    new_j = j + (s // 3 if s > 3 else 0)
    shifted_objs.add(frozenset({(TWO, (new_i, new_j))}))
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
26.5, 45.231125, def adcfbfafeeejeceabbeacedjcefcfffd(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    shifted_objs = mapply(lambda obj: frozenset({(TWO, (uppermost(obj) + size(obj) // 4, leftmost(obj) + size(obj) // 3))}), objs)
    O = paint(canvas(bg, shape(I)), shifted_objs)
    return O
 
60.0, 19.861319, def bfejafbbiegcediiicfdcjcfaahacech(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    O = paint(O,  recolor(2, delta(toindices(obj))))
    O = paint(O, obj)
  return O
 
89.5, 27.568876, def ddfiegcfbfcaehceacfdbjjgbcdgcfce(I):
  O = I
  for obj in objects(I, True, False, False):
    outline = toindices(obj)
    for cell in toindices(obj):
      if any(n in delta(outline) for n in dneighbors(cell)):
        O = fill(O, 2, {cell})
  return O
 
241.0, 53.86138, def gjcgebfdjfffehaiijdfcddfibjjfbeb(I):
  objs = objects(I, True, False, False)
  O = I
  for obj in objs:
    for i, j in toindices(obj):
      if any(index(I, (i + di, j + dj)) == mostcolor(I) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        O = fill(O, 2, {(i, j)}) 
  return O
 
104.5, 43.477707, def fdabahebebcjedcaijddfgfaedbgaacf(I):
    objs = objects(I, False, False, True)  # Identify objects
    O = I
    for obj in objs:
      ul = ulcorner(obj)
      ur = urcorner(obj)
      ll = llcorner(obj)
      O = paint(O, recolor(2, outbox(obj) - {ur})) # Paint outline using outbox and remove upper right corner
      O = paint(O, recolor(2, {ul, ur, ll})) # Paint corner markers
    return O
 
70.5, 24.282978, def hecbaajegiabehcejfcbfdiccfiiafab(I):
  def paint_line(grid, start, length, direction, color):
    for i in range(length):
      grid = paint(grid, {(color, add(start, multiply(i, direction)))})
    return grid

  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    ul = ulcorner(obj)
    h = height(obj)
    w = width(obj)
    O = paint_line(O, add(ul, (0, 1)), w - 1, RIGHT, 2)  # Top line
    O = paint_line(O, add(ul, (1, 0)), h - 1, DOWN, 2)  # Left line
    O = paint_line(O, add(ul, (h, 1)), w - 1, RIGHT, 2)  # Bottom line
    O = paint_line(O, add(ul, (1, w)), h - 1, DOWN, 2)  # Right line
    O = paint(O, recolor(2, {ul, add(ul, (0, w)), add(ul, (h, 0))})) # Corners
  return O
 
77.0, 22.86918, def ffebahbeieibeeceidgbcfdecbajjbfi(I):
  objs = objects(I, False, False, True)
  O = cover(I, merge(objs)) # Create blank canvas 
  for obj in objs:
    O = underpaint(O, shift(recolor(2, obj), (-1, -1))) # Paint shifted object with outline color
    O = underpaint(O, shift(recolor(2, obj), (-1, 1)))
    O = underpaint(O, shift(recolor(2, obj), (1, -1)))
    O = underpaint(O, shift(recolor(2, obj), (1, 1)))
    ul = ulcorner(obj)
    ur = urcorner(obj)
    ll = llcorner(obj)
    O = paint(O, recolor(2, {ul, ur, ll})) # Paint corner markers
  return O
 
54.5, 12.26554, def cbjcbagadfbdedghbadibebijgijdbeb(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    for d in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Directions for outline
      O = paint(O, recolor(2, shift(intersection(toindices(obj), shift(backdrop(obj), d)), invert(d)))) 
    ul = ulcorner(obj)
    ur = urcorner(obj)
    ll = llcorner(obj)
    O = paint(O, recolor(2, {ul, ur, ll})) # Paint corner markers
  return O
 
111.0, 34.92038, def hbbfdchedhaeeeegafibjfcdbajeagab(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    for cell in toindices(obj):
      for n in neighbors(cell): # Check neighbors of each cell
        if n not in toindices(obj):
          O = paint(O, {(2, n)}) # Paint if neighbor is not part of the object
    ul = ulcorner(obj)
    ur = urcorner(obj)
    ll = llcorner(obj)
    O = paint(O, recolor(2, {ul, ur, ll})) # Paint corner markers
  return O
 
55.5, 17.459171, def agdcahjibcceehbhbaidegjfgicbcede(I):
  t = leastcolor(I)
  O = paint(canvas(0, shape(I)), asobject(I))
  for i, r in enumerate(I):
    for j, c in enumerate(r):
      if c == t:
        O = fill(O, 2, {(i, j), (i + 1, j + 1)})
  return O 
 
61.0, 31.645128, def bfcbfifiegacefccibaehfdaifbbchbe(I):
  target_color = leastcolor(I)
  objs = objects(I, True, False, True)
  other_objs = frozenset(obj for obj in objs if color(obj) != target_color or len(obj) > 1)
  target_cells = {(i,j) for i, row in enumerate(I) for j, c in enumerate(row) if c == target_color}
  shifted_cells = shift(target_cells, (1,1))
  O = paint(canvas(0, shape(I)), merge(other_objs))
  O = underfill(O, 2, target_cells)
  O = underfill(O, 2, shifted_cells)
  return O
 
39.0, 10.132406, def fdfbicjcibcbeiddadfbciaheibfafjj(I):
  O = I
  for obj in objects(I, T, T, T):
    if size(obj) == 1:
      O = paint(O, recolor(TWO, toindices(obj)))
    else:
      O = paint(cover(O, obj), recolor(TWO, toindices(shift(obj, (ONE, ONE)))))
  return O
 
241.5, 58.90934, def ibacjgcjhacieeceicihdfecbheacadi(I):
  O = paint(I, recolor(TWO, mfilter(objects(I, T, F, F), identity)))
  return paint(O, recolor(TWO, toindices(merge(mfilter(objects(O, T, T, T), lambda obj: shift(obj, (ONE, ONE)))))))
 
69.5, 31.00171, def jcgedaeeedacedieibcdeiffajdgcdah(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if index(I, (i, j)) == THREE and size(extract(objects(I, T, T, T), lambda obj: (i, j) in toindices(obj))) == 1:
        O = paint(O, recolor(TWO, {(i, j)}))
      elif index(I, (i, j)) == THREE:
        new_i, new_j = (i + ONE) % height(I), (j + ONE) % width(I)
        O = paint(O, {(TWO, (new_i, new_j))})
  return O
 
31.5, 32.860172, def bbheccbhhdgiejbcahbcgfagdifajafg(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  shrunk_objs = set()
  for obj in objs:
    s = size(obj)
    factor = max(1, 5 - s // 2) # Different shrinking factor calculation
    i, j = ulcorner(obj) 
    new_loc = (i // factor, j // factor) 
    shrunk_objs.add(recolor(TWO, {(new_loc)})) 
  O = paint(canvas(bg, shape(I)), merge(shrunk_objs))
  return O
 
45.0, 11.812317, def dbebdjcdiefgeaaaifheefgadjcihafb(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    for obj in objs:
        size_factor = max(1, 4 - size(obj) // 3)
        new_obj = {(TWO, (i // size_factor, j // size_factor)) for _, (i, j) in obj}
        O = paint(O, new_obj)
    return O
 
37.0, 9.544674, def ibffbiabbajfeidcjjcdibhaibfefbdf(I):
  bg = mostcolor(I)
  return paint(I, frozenset((2, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v != bg and any(index(I, n) == bg for n in dneighbors((i, j)))))
 
241.5, 54.185207, def eiadiiebjjccedafacghfichefebcfba(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    outline = sfilter(toindices(obj), lambda ind: any(index(I, n) == mostcolor(I) for n in dneighbors(ind)))
    O = paint(O, recolor(2, outline))
  return O
 
40.5, 14.90013, def afhefadicggbeccebcbehdcebadfhiaf(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
      if color(obj) == 3:
        # Identify and recolor corner indices to 2
        corners_indices = corners(obj)
        O = paint(O, recolor(2, corners_indices))
        # Shift elements diagonally if possible
        for value, (i, j) in obj:
            if (i, j) not in corners_indices:
                new_i = min(i + 1, len(I)-1)
                new_j = min(j + 1, len(I[0])-1)
                if index(O, (new_i, new_j)) == 0:
                    O = paint(O, {(value, (new_i, new_j))})
                    O = cover(O, {(value, (i, j))}) 
      else:
        O = paint(O, obj)
    return O
 
34.5, 34.047825, def jdddfbfbcgdhecacafaafcbejigiafeb(I):
    O = canvas(0, shape(I)) 
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == 3:
                # Check for corner condition (simplified)
                if (i == 0 or i == len(I)-1) or (j == 0 or j == len(row)-1):
                    O = fill(O, 2, {(i, j)}) 
                else:
                    new_i = i + (1 if i < len(I)-1 else 0)
                    new_j = j + (1 if j < len(row)-1 else 0)
                    O = fill(O, value, {(new_i, new_j)})
            else:
                O = fill(O, value, {(i, j)})
    return O
 
47.0, 10.572696, def dfcjggfiaffbedacadbegfabffbbfada(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        if color(obj) == 3:
            for v, (i, j) in obj:
                # Check for patterns indicative of a shift
                if (i + 1, j + 1) in toindices(obj): 
                    O = paint(O, {(2, (i, j)), (v, (i + 1, j + 1))})
                elif i > 0 and j > 0 and (i - 1, j - 1) in toindices(obj):
                    O = paint(O, {(v, (i, j)), (2, (i - 1, j - 1))})
        else:
            O = paint(O, obj)
    return O
 
49.0, 10.691517, def gefjeecdgefdeeafaeacdbdcijehabcb(I):
    objs = objects(I, False, False, True)
    O = I
    for obj in objs:
        if color(obj) == 3:
            center_i, center_j = centerofmass(obj)
            for v, (i, j) in obj:
                # Shift logic based on relative position to center of mass
                new_i = i + (1 if i < center_i else -1 if i > center_i else 0)
                new_j = j + (1 if j < center_j else -1 if j > center_j else 0)
                O = paint(O, {(v, (new_i, new_j))})
        else:
            O = paint(O, obj)
    return O
 
38.5, 12.271518, def bceeddffedfcecfgjbbaadghfdchehff(I):
    objs = objects(I, False, False, True)
    O = I
    for obj1 in objs:
        if color(obj1) == 3:
            for obj2 in objs:
                if color(obj2) != 3:
                    direction = gravitate(obj1, obj2)
                    O = paint(cover(O, obj1), shift(obj1, direction))
                    break
            # Assuming corner coloring is consistent across inputs
            O = paint(O, recolor(2, corners(obj1)))
        else:
            O = paint(O, obj1)
    return O 
 
58.0, 30.075256, def adcgddcidfadejfeijiedjfeadcffafd(I):
  target_color = 3  
  objs = objects(I, True, False, True)
  target_objs = sfilter(objs, lambda obj: size(obj) > 1 and color(obj) == target_color)
  shifted_objs = apply(lambda obj: shift(recolor(2, obj), (1, 1)), target_objs)
  least_color = leastcolor(I)
  single_cell_objs = sfilter(objs, lambda obj: size(obj) == 1 and color(obj) == least_color)
  recolored_objs = apply(lambda obj: recolor(2, obj), single_cell_objs)
  O = paint(canvas(0, shape(I)), merge(objs))
  O = paint(O, merge(shifted_objs))
  O = paint(O, merge(recolored_objs))
  return O
 
61.5, 29.952059, def ebcbbbgagdjaecbfifdbgefefjcfbdjf(I):
  target_color = 3
  objs = objects(I, True, False, True)
  filtered_objs = sfilter(objs, lambda obj: (size(obj) > 1 and color(obj) == target_color) or (size(obj) == 1 and color(obj) == leastcolor(I)))
  shifted_objs = apply(lambda obj: shift(obj, (1, 1)) if size(obj) > 1 else obj, filtered_objs)
  O = paint(canvas(0, shape(I)), merge(filtered_objs))
  O = underpaint(O, merge(apply(lambda obj: recolor(2, obj), shifted_objs)))
  return O
 
46.5, 9.976306, def ccibefaijhbeeafdjeajeehdadggicbb(I):
  objs = objects(I, True, False, True)
  shifted_objs = mfilter(objs, lambda obj: shift(recolor(2, obj), (1, 1)) if size(obj) > 1 and color(obj) == 3 else (recolor(2, obj) if size(obj) == 1 and color(obj) == leastcolor(I) else None))
  O = paint(canvas(0, shape(I)), merge(objs))
  O = paint(O, shifted_objs)
  return O
 
39.0, 10.132406, def egdfcjbefgifejfbbfafiifegijgejja(I):
  def transform_object(obj):
    if size(obj) > 1 and color(obj) == 3:
      return shift(recolor(2, obj), (1, 1))
    if size(obj) == 1 and color(obj) == leastcolor(I):
      return recolor(2, obj)
    return obj

  objs = objects(I, True, False, True)
  transformed_objs = apply(transform_object, objs)
  O = paint(canvas(0, shape(I)), merge(transformed_objs))
  return O
 
228.0, 12.01729, def cefedfeacfbjedjejedjfcaefheeabde(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    if size(obj) > 1:
      O = underpaint(O, recolor(TWO, toindices(shift(obj, (ONE, ONE)))))
  for obj in objects(I, T, F, F):
    O = underpaint(O, recolor(TWO, toindices(obj)))
  return O
 
26.5, 44.14277, def hecddgefdhffeddcjdaaegfecfjcceba(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    shrunk_objs = set()
    for obj in objs:
      if size(obj) == 1:
        shrunk_objs.add(recolor(TWO, toindices(obj)))
      else:
        i, j = ulcorner(obj)
        new_loc = (i+1, j+1) 
        shrunk_objs.add(frozenset({(TWO, new_loc)}))
    O = paint(canvas(bg, shape(I)), merge(shrunk_objs))
    return O 
 
35.5, 9.689877, def cfigjadhbheaehecbcegiagbbfhjbeej(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == THREE:
        if (i > 0 and j > 0 and I[i-1][j] != THREE and I[i][j-1] != THREE):
          O = fill(O, TWO, {(i, j)}) 
        else:
          O = fill(O, TWO, {(i + 1, j + 1)})
  return O
 
40.5, 15.56249, def cdddafbeeeheebfgaidfgcfcccajaddj(I):
    for obj in objects(I, True, False, False):
        outline = sfilter(toindices(obj), lambda ind: any(index(I, n) == mostcolor(I) for n in dneighbors(ind)))
        for func in [argmin, argmax]:
            for axis in [lambda ind: ind[0], lambda ind: ind[1]]:
                I = fill(I, 2, initset(func(outline, axis)))
    return I
 
40.0, 15.485899, def caghaeffffeaecffidfiddcehjfggiai(I):
  def mark_extreme(obj, axis, extreme_func):
    outline = sfilter(toindices(obj), lambda ind: any(index(I, n) == mostcolor(I) for n in dneighbors(ind)))
    extreme_index = extreme_func(outline, key=axis)
    return fill(I, 2, initset(extreme_index))
  for obj in objects(I, True, False, False):
    for axis in [lambda ind: ind[0], lambda ind: ind[1]]:
      for extreme_func in [min, max]:
        I = mark_extreme(obj, axis, extreme_func)
  return I
 
46.5, 9.510408, def bdgagbibcdebeaddihcegedfcebibdbc(I):
  # Directly create a grid with '2's at mirrored positions
  largest_obj = argmax(objects(I, T, F, T), size)
  center_i, center_j = centerofmass(largest_obj)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 3 and size(extract(objects(I, T, F, T), lambda obj: contained((i, j), toindices(obj)))) == 1:
        # Calculate mirrored position
        new_i = center_i - (i - center_i)
        new_j = center_j - (j - center_j)
        O = fill(O, 2, {(new_i, new_j)})
      else:
        O = fill(O, v, {(i, j)})
  return O
 
43.0, 10.554506, def deeeccfdgbcaefcdjfdefcbadjbfcgib(I):
  # Use a lambda function to determine the new cell value
  largest_obj = argmax(objects(I, T, F, T), size)
  center_i, center_j = centerofmass(largest_obj)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      new_value = lambda x, y: 2 if x == 3 and size(extract(objects(I, T, F, T), lambda obj: contained((y, j), toindices(obj)))) == 1 else v
      O = fill(O, new_value(v, i), {(i, j)})
  return O
 
37.5, 30.443453, def jgiiaheehfcieaaaigdciegjbebedeab(I):
    obj3 = argmax(objects(I, True, False, True), size)  # Identify the largest "3" object
    obj2a = recolor(2, obj3)  # Recolor to "2"
    obj2b = shift(obj2a, add(urcorner(obj3), UNITY)) # Shift one down and one right from the top right corner
    obj2c = shift(obj2a, add(lrcorner(obj3), UP))  # Shift one up from the bottom right corner
    O = paint(canvas(0, shape(I)), combine(combine(obj2a, obj2b), obj2c))  # Combine and paint on canvas
    return O
 
43.0, 19.840202, def gdhachbbhdebedefbccfecjihfbieaea(I):
  obj3 = extract(objects(I, True, False, True), lambda o: color(o) == 3 and size(o) > 1) # Identify "3" object
  corners_obj3 = corners(obj3)
  shifted_obj_1 = shift(recolor(2, obj3), add(first(corners_obj3), UNITY))
  shifted_obj_2 = shift(recolor(2, obj3), add(last(corners_obj3), UP))
  O = paint(canvas(0, shape(I)), combine(combine(recolor(2, obj3), shifted_obj_1), shifted_obj_2))
  return O
 
63.5, 10.221894, def dcebigdeddfaegbfbicdaecebadccbii(I):
  objs = objects(I, True, False, True)
  target_obj = argmax(objs, size)
  shifted_objs = apply(lambda offset: shift(recolor(2, target_obj), offset), [(0, 0), (1, 1), (-1, 1)])
  O = paint(canvas(0, shape(I)), merge(combine(shifted_objs, objs - {target_obj})))
  return O
 
36.5, 33.51223, def dbjfdcecbchaehadijdficcdceahieeg(I):
    main_obj = argmax(objects(I, True, False, True), size)
    transformed_objs = apply(lambda pos: shift(recolor(2, main_obj), (uppermost(main_obj) + height(main_obj) // 2 - pos[0], leftmost(main_obj) + width(main_obj) // 2 - pos[1])), [(1, -1), (height(main_obj) // 2, width(main_obj) // 2 + 1), (height(main_obj) // 2 - 1, width(main_obj) // 2 + 1)])
    O = paint(canvas(0, shape(I)), merge(transformed_objs))
    return O
 
58.0, 30.075256, def jjfejffeaffbecehjfaebiaggebddgde(I):
  shifted_objs = frozenset(shift(obj, (ONE, ONE)) if size(obj) > 1 else obj for obj in objects(I, T, T, T))
  O = paint(I, recolor(TWO, toindices(merge(shifted_objs))))
  return O
 
42.5, 10.215909, def bafdefhhcdhdedgcbghcfddbbefccbja(I):
  O = I
  for obj in objects(I, T, T, T):
    if size(obj) > 1:
      O = paint(cover(O, obj), recolor(TWO, toindices(shift(obj, (ONE, ONE)))))
  return O
 
45.5, 10.434148, def afgchhbjdabbeeaabhihecacfieahgab(I):
    bg = mostcolor(I)
    shrunk_objects = frozenset()
    for i in range(1, height(I)):
        for j in range(1, width(I)):
            if index(I, (i-1, j-1)) != bg:
                shrunk_objects = shrunk_objects | {(2, (i,j))}
    return paint(canvas(bg, shape(I)), shrunk_objects)
 
134.0, 15.815871, def ffgihjbfaebfeefbiccfieffjagfchcj(I):
    bg = mostcolor(I)
    return tuple(
        tuple(
            2 if any(index(I, (i - 1, j - 1)) != bg for (i, j) in neighbors((k, l))) else bg
            for l in range(width(I))
        )
        for k in range(height(I))
    )
 
33.0, 44.57685, def bbcahacdbjedeaedbigcjahajaceaadh(I):
    bg = mostcolor(I)
    new_grid = canvas(bg, shape(I))
    for obj in objects(I, T, F, T):
        new_grid = paint(new_grid, {(2, add(ulcorner(obj), (1, 1)))})
    return new_grid
 
55.5, 22.96205, def ajiaaidfcjbfeeajbdfeadaaiajifacd(I):
  # 1. Identify single-cell objects
  single_cells = frozenset(toindices(obj) for obj in objects(I, T, F, T) if size(obj) == 1) 
  
  # 2. Create a diagonal line
  diagonal = frozenset((i, i) for i in range(len(I)))

  # 3. Combine and apply transformations
  O = I
  O = fill(O, 2, diagonal)
  O = fill(O, 2, merge(single_cells))
  return O 
 
50.5, 18.022137, def egcfddjhdcabebbejjcaddagccefjjia(I):
  O = replace(I, 3, 2) # Replace all '3's with '2's
  return fill(O, 2, frozenset((i, i) for i in range(len(I)))) # Draw diagonal
 
58.5, 14.837472, def gbahbbejjbdbegahigbhadcbffafcbeb(I):
  objs = objects(I, True, False, True)
  shifted_objs = []
  for obj in objs:
    if color(obj) == 3:
      shifted_obj = shift(recolor(2, obj), (1 if uppermost(obj) < len(I) // 2 else -1, 1))
      shifted_objs.append(shifted_obj)
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
79.5, 31.947914, def ebigdacdhaideachaedjjjfebcfaccbj(I):
  O = I
  for obj in objects(I, T, T, T):
    O = underpaint(O, recolor(TWO, toindices(shift(obj, (ONE, ONE)))))
    if size(obj) > 1: # Only shift again if size is greater than 1
      O = underpaint(O, recolor(TWO, toindices(shift(obj, (TWO, TWO)))))
  return O
 
38.0, 9.248153, def fejgfecgdjchegaajcecaaccdgebeibf(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I) and any(I[ni][nj] == mostcolor(I) for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]):
        O = fill(O, 2, {(i, j)})
  return O 
 
38.5, 9.254991, def bfhefgjhbehbebicjbaaebficidcgfia(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    ul = ulcorner(obj)
    lr = lrcorner(obj)
    O = paint(O, {(2, ul), (2, lr)})
    O = paint(O, recolor(2, toindices(obj)))
  return O
 
39.0, 11.296539, def dcgcifeaahbjecbcjeabjjbefebbehaj(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    O = paint(O, recolor(2, {ulcorner(obj), lrcorner(obj)}))
    O = underfill(O, 0, box(obj))
  return O
 
33.0, 44.267895, def geeffjedeecceiceadffehfjebjafegc(I):
  bg = mostcolor(I)  # Identify background color
  objs = objects(I, T, F, T)  # Extract objects without background
  shrunk_objs = mapply(lambda obj: recolor(color(obj), {(add(ulcorner(toindices(obj)), (1, 1)))}) , objs)  # Shrink, recolor, reposition
  return paint(canvas(bg, shape(I)), shrunk_objs)  # Paint on a new canvas
 
241.5, 58.90934, def hfdgdafjbfeaeehaifgeejidcieeacha(I):
    def extreme_indices(obj):
        indices = toindices(obj)
        return frozenset({
            argmin(indices, lambda ind: ind[0]),  # top
            argmax(indices, lambda ind: ind[0]),  # bottom
            argmin(indices, lambda ind: ind[1]),  # left
            argmax(indices, lambda ind: ind[1])   # right
        })

    extremes = mfilter(objects(I, True, False, False), extreme_indices)
    return fill(I, 2, extremes)
 
45.0, 11.335544, def ihfcfjciaajfehjhiadiehbbeafegbae(I):
  objs = objects(I, False, False, True)
  O = canvas(0, shape(I))
  for obj in objs:
    ul = ulcorner(obj)
    lr = lrcorner(obj)
    O = paint(O, {(2, ul), (2, lr)})  
    O = paint(O, recolor(2, shift(toindices(obj), (0,1)))) # Shift right by 1
  return O
 
42.0, 11.697111, def iffeaibjigfdejdbjcfibaahcabfchcf(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != 0:
        if i == 0 or i == len(I) - 1 or j == 0 or j == len(row) - 1 or \
           (i > 0 and I[i-1][j] == 0) or (i < len(I) - 1 and I[i+1][j] == 0) or \
           (j > 0 and I[i][j-1] == 0) or (j < len(row) - 1 and I[i][j+1] == 0):
          O = paint(O, {(2, (i, j)), (2, (i, j+1))})  # Mark corners (shifted right)
          O = paint(O, {(2, (i, j+1)) for i, j in ofcolor(I, val)})  # Recolor and shift
  return O 
 
46.0, 11.060796, def cdjcibhefdfceffbjjgfdcaiaefdiaae(I):
  objs = objects(I, False, False, True)
  O = paint(canvas(0, shape(I)), {(2, ulcorner(obj)) for obj in objs} | 
                               {(2, (lrcorner(obj)[0], lrcorner(obj)[1]+1)) for obj in objs}) # Corners, shifted
  return paint(O, merge({recolor(2, shift(toindices(obj), (0, 1))) for obj in objs}))
 
51.5, 14.29873, def edhdgecdddhfeeiebaeedbjcgiideggf(I):
  O = I
  for val in palette(I) - {0}:  # For each non-background color
    obj_indices = ofcolor(I, val)
    O = paint(O, {(2, ul) for ul in {ulcorner(obj_indices)}})
    O = paint(O, {(2, (lr[0], lr[1] + 1)) for lr in {lrcorner(obj_indices)}})  # Shifted corner
    O = paint(O, {(2, (i, j + 1)) for i, j in obj_indices}) # Shift and recolor
  return O
 
241.5, 58.90934, def chieibebecahedehjgajeeaadcdadecb(I):
  return tuple(tuple(2 if (i == 0 or i == len(I) - 1 or j == 0 or j == len(row) - 1 or \
                            (i > 0 and I[i-1][j] == 0) or (i < len(I) - 1 and I[i+1][j] == 0) or \
                            (j > 0 and I[i][j-1] == 0) or (j < len(row) - 1 and I[i][j+1] == 0) or \
                            I[i][j] != 0) else 0 \
                     for j in range(len(row))) for i, row in enumerate(I))
 
241.5, 58.90934, def haafjdbbjfegefjaabfiacgfahjabbfe(I):
    O = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != mostcommon(I):
                new_i = (i + 1) % len(I)
                new_j = (j + 1) % len(row)
                O = paint(O, {(2, (new_i, new_j))})
    return O
 
69.5, 33.15225, def ffieigbdeaeaedfjibcicjaadhcedded(I):
  new_objects = set()
  for obj in objects(I, T, T, T):
    if color(obj) == THREE:
      new_objects.add(recolor(TWO, toindices(shift(obj, DOWN_LEFT))))
  return paint(I, merge(new_objects))
 
49.5, 10.820973, def bcebabdeacjceeddagbdabbbfbaebggf(I):
  output_grid = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    if color(obj) == THREE:
      output_grid = paint(output_grid, recolor(TWO, toindices(shift(obj, DOWN_LEFT))))
  return output_grid
 
41.5, 10.76205, def gefhahgabbbdeacciaiaghafbaddaeje(I):
  bg = mostcolor(I)
  h, w = len(I), len(I[0])
  shrunk_indices = set()
  for i in range(h - 1):
    for j in range(w - 1):
      if I[i][j] != bg:
        shrunk_indices.add((I[i][j], (i + 1, j + 1)))
  return paint(canvas(bg, (h, w)), frozenset(shrunk_indices))
 
