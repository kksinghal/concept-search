6.333333333333333, 11.751889, def jfjffejadgbdeachibhbeaecachfghci(I):
  O = I
  for value in palette(I) - {mostcolor(I)}:
    objs = objects(I, True, False, True)
    obj = extract(objs, lambda obj: color(obj) == value)
    O = move(O, obj, (0, colorcount(I, value)))
  return O 
 
8.0, 26.878185, def hefcgccechbdegefjeaddedgajjidbfc(I):
    O = I
    for value in palette(I) - {mostcolor(I)}:
        indices = ofcolor(I, value)
        O = paint(
              cover(O, indices), 
              shift(recolor(value, indices), (0, colorcount(I, value)))
            )
    return O
 
8.0, 18.147898, def aaaddigdfcdcedfhaabaabdcadgedcee(I):
    objs = objects(I, True, False, True)
    shifted_objs = set()
    for obj in objs:
        value = color(obj)
        shifted_objs.add(shift(obj, (0, colorcount(I, value))))
    O = paint(canvas(mostcolor(I), shape(I)), frozenset.union(*shifted_objs))
    return O
 
5.666666666666667, 4.8407574, def gfhgbedddhideicabedebechdeegeahh(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != mostcolor(I):
        count = row[:j].count(value)
        O = paint(cover(O, {(value, (i, j))}), {(value, (i, j + count))})
  return O
 
9.666666666666666, 8.146711, def ceigafbeacchedjfadaejjgcejidjdhi(I):
  O = canvas(mostcolor(I), shape(I))
  for value in palette(I) - {mostcolor(I)}:
    indices = [(i, j) for i, row in enumerate(I) for j, v in enumerate(row) if v == value]
    for k, (i, j) in enumerate(indices):
      O = paint(O, {(value, (i, j + k))})
  return O
 
8.0, 29.493029, def hcffejahcdifefbjjcfhbdbbghdhbdih(I):
    objs = fgpartition(I)
    top_row = frozenset((i, 0) for i in range(width(I)))
    right_column = frozenset((height(I) - 1, j) for j in range(width(I)))
    O = I
    for i, obj in enumerate(objs):
      if size(obj) == 2:
        O = paint(cover(O, obj), shift(obj, gravitate(obj, recolor(ZERO, top_row))))
      else:
        O = paint(cover(O, obj), shift(obj, gravitate(obj, recolor(ZERO, right_column))))
    return O
 
3.0, 10.05773, def ebfjachcecjceddgbbejfgcejabfidab(I):
    objs = order(fgpartition(I), size)
    output = I
    for obj in objs:
        if height(obj) > 1:
            target = (0, width(I) - width(obj))
        else:
            target = (height(I) - 1, width(I) - width(obj))
        output = paint(cover(output, obj), shift(obj, target))
    return output
 
3.0, 11.498762, def dhchaddbhfdbeaefjagaeeaejdebafbf(I):
  objs = sorted(objects(I, T, T, T), key=size)
  main_obj = next((obj for obj in objs if color(obj) == 5), None) 
  offset = (0, width(main_obj))
  O = I
  for obj in objs:
    if obj != main_obj:
      O = paint(cover(O, obj), shift(obj, offset))
      offset = add(offset, (0, width(obj)))
  return O
 
10.666666666666666, 7.9798727, def ebciaiibfbfcebfaacdfegficcebecbd(I):
  parts = sorted(partition(I), key=lambda x: (size(x), -uppermost(x)))
  O = canvas(0, shape(I))
  offset = (0, 0)
  for part in parts:
    O = paint(O, shift(part, offset))
    offset = add(offset, (0, width(part)))
  return O
 
6.0, 4.9245906, def fdahhcaheeabegeciccgcbdfjiijaffe(I):
    objs = sorted(objects(I, T, T, T), key=lambda x: (size(x), -uppermost(x)))
    frontiers_set = frontiers(I)
    O = I
    for f in frontiers_set:
      for obj in objs:
          if any(index(I, loc) == color(obj) for loc in toindices(f)):
              O = paint(cover(O, obj), shift(obj, (0, width(f))))
              break
    return O
 
11.333333333333334, 6.409327, def eaabeaiaehcjeheeidafcgbjgedeibgi(I):
    x1 = objects(I, T, T, T)  # Identify all objects
    x2 = order(x1, size)  # Order objects by size (smallest first)
    O = I
    for obj in x2:
      x3 = toindices(obj)
      x4 = order(x3, lambda x: x[1]) if portrait(obj) else order(x3, lambda x: x[0])  # Order cells within object
      for i, (r, c) in enumerate(x4):
        O = paint(cover(O, {(I[r][c], (r, c))}), {(I[r][c], (r, x4[-i-1][1]))} if portrait(obj) else {(I[r][c], (x4[-i-1][0], c))})  # Move each cell to the opposite end of its row/column
    return O
 
10.333333333333334, 7.159829, def jdjachehhbaeehccjfdacbjahhedjaef(I):
    O = I
    x1 = objects(I, T, T, T)
    for obj in x1:
      x2 = toindices(obj)
      for i, (r, c) in enumerate(x2):
        if portrait(obj):
          new_c = width(obj) - c + leftmost(x2) - 1
          O = paint(cover(O, {(I[r][c], (r, c))}), {(I[r][c], (r, new_c))})  # Move within row
        else:
          new_r = height(obj) - r + uppermost(x2) - 1
          O = paint(cover(O, {(I[r][c], (r, c))}), {(I[r][c], (new_r, c))})  # Move within column
    return O
 
6.0, 4.9245906, def gaghaffcfgibefdebbffcibdbcbeegcf(I):
  O = canvas(mostcommon(I), shape(I))
  for c in range(width(I)):
    for r in range(height(I)):
      if I[r][c] != mostcommon(I):
        new_r = next((i for i in range(height(I)) if O[i][c] == mostcommon(I)), height(I))
        O = paint(O, {(I[r][c], (new_r, c))})
  return O
 
10.0, 10.100697, def hacchbficbjcefhfjbabfebaaaafbfce(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w)) # Initialize output with background color
  for j in range(w): # Iterate through columns
    column = [I[i][j] for i in range(h)]
    values = [v for v in column if v != mostcolor(I)] # Get non-background digits
    for i, v in enumerate(values):
      O = paint(O, {(v, (i, j))}) # Paint digits upwards in the output
  return O
 
6.0, 15.847019, def biedabbdjebdedecicadjdbibheegbga(I):
  O = I  
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True): # Iterate through objects
    upper = uppermost(obj)
    for v, (i, j) in sorted(obj, key=lambda x: x[1][0], reverse=True): # Sort by row index
        O = paint(cover(O, {(v, (i,j))}), {(v, (upper, j))}) # Move digit to the top
        upper += 1
  return O 
 
6.0, 4.9245906, def fbfbaeiaeecceeajiebjajcjiadaiifd(I):
  O = I
  for x in range(len(I[0])):
    for y in range(len(I)-1):
      if I[y+1][x] != mostcommon(I) and I[y][x] == mostcommon(I):
        O = paint(cover(O, {(I[y][x], (y,x))}),{(I[y+1][x],(y,x))})
        O = paint(cover(O, {(I[y+1][x], (y+1,x))}),{(I[y][x],(y+1,x))})
  return O
 
6.0, 20.681604, def cjieacjhdgdgedgfiajcijhaeidhigea(I):
  O = canvas(ZERO, shape(I)) # Initialize an empty canvas with the same shape as the input
  for v in palette(I): # Iterate over each unique digit in the input
    indices = toindices(ofcolor(I, v)) # Get the indices of all occurrences of the digit
    for k, (i, j) in enumerate(indices): # Iterate over each occurrence
      new_i = i + j - k # Calculate the new row index
      new_j = j + i - k # Calculate the new column index
      O = fill(O, v, {(new_i, new_j)}) # Fill the new location with the digit
  return O
 
6.0, 19.884867, def dejahhagbjccedggiebcbaddcedffcca(I):
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      v = index(I, (i, j))
      new_i = i + j
      new_j =  j + i
      O = fill(O, v, {(new_i, new_j)})
  return O
 
11.0, 6.712414, def deabgechihhceafaaegbdaiecgdjecgb(I):
  O = canvas(mostcommon(I), shape(I))  # Create empty canvas
  for i, row in enumerate(I):
    fg_indices = [j for j, val in enumerate(row) if val != mostcommon(I)]  # Find indices of non-background digits
    O = paint(O, {(row[j], (i, k)) for j, k in zip(fg_indices, range(len(fg_indices)-1,-1,-1))})  # Place digits from right to left
  return O
 
8.333333333333334, 22.754612, def bbefeeefgfaheebaidacjfdceiifheic(I):
  O = I
  for i in range(height(I)):
    row = list(I[i])
    for j in range(width(I) - 1, -1, -1):
      if row[j] != mostcommon(I):
        O = paint(cover(O, {(row[j], (i, j))}), {(row[j], (i, width(I) - 1))})
        row.pop(j)
  return O
 
5.333333333333333, 4.604031, def aafaahiifefcedehbfibhbhfhdbahegj(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      v = I[i][j]
      if v != mostcolor(I):
        k = min([x for x in range(i) if I[x][j] == v], default=i)
        O = move(O, {(v, (i, j))}, (-i + k, 0))
  return O
 
10.333333333333334, 7.85521, def hbcgdafbefibeeabjfeieihhdfhdeage(I):
    O = I
    for j in range(width(I)):
        col = [I[i][j] for i in range(height(I))]
        sorted_col = sorted(col, key=lambda v: (v == mostcolor(I), v))
        for i in range(height(I)):
            O = paint(cover(O, {(I[i][j], (i, j))}), {(sorted_col[i], (i, j))})
    return O
 
5.0, 4.7893486, def dcfdecfbeccfedbejebfbadfhggacgdg(I):
    # Group objects by color
    objs_by_color = {}
    for obj in objects(I, True, True, False):
        color = first(obj)[0]
        objs_by_color.setdefault(color, []).append(obj)

    # Move objects based on their color and position
    for color, objs in objs_by_color.items():
        if color == 3:
            I = move(I, objs[0], (0, len(I[0]) - width(objs[0])))
        elif color == 6:
            I = move(I, objs[0], (0, len(I[0]) - width(objs[0])))
            if len(objs) > 1:
                I = move(I, objs[1], (1, width(objs_by_color[5][0])))
        elif color == 8:
            I = move(I, objs[0], (0, len(I[0]) - width(objs[0])))
        elif color == 2:
            I = move(I, objs[0], (0, len(I[0]) - width(objs[0]) - 1))
        elif color == 1:
            I = move(I, objs[0], (len(I) - 1, width(objs_by_color[5][0])))
    
    O = I
    return O
 
9.0, 13.920832, def behbfhaebefeebbbifgbcjaeddeaaiji(I):
  O = I  # Copy input to output
  for j in range(width(I)):  # Iterate through columns
    for i in range(height(I)):  # Iterate through rows within each column
      v = I[i][j]
      if v != mostcolor(I):  # Check if digit is not background
        O = paint(cover(O, {(v, (i, j))}), {(v, (len([x for x in range(i) if I[x][j] == v]), j))})  # Move digit to its new row index
  return O
 
7.333333333333333, 7.179591, def dabecfdhheibecbgiieedcacaafhebfe(I):
  O = I  # Copy input to output
  for j in range(width(I)):  # Iterate through columns
    for i in range(height(I) - 1):  # Iterate through rows (except last) within each column
      if I[i][j] != mostcolor(I) and I[i + 1][j] == mostcolor(I):  # Check for non-background digit above background
        O = move(O, {(I[i][j], (i, j))}, (-i, 0))  # Move non-background digit to the top of the column
  return O
 
8.0, 6.1464276, def jfjciedfaiagejddbbfeddjcbdeddiga(I):
    # Split the grid horizontally 
    h_split = hsplit(I, len(I[0]))

    # Define transformations for each column based on observations
    transformations = {
        0: lambda x: x,  # No change
        1: lambda x: x,  # No change
        2: lambda x: vconcat(x[2:], x[:2]),  # Move bottom two rows to top 
        3: lambda x: vconcat(x[1:], x[:1])   # Move bottom row to top
    }

    # Apply transformations to each column
    transformed_split = tuple(transformations.get(i, lambda x: x)(col) 
                                for i, col in enumerate(h_split))

    # Concatenate the columns horizontally to form the output
    O = hconcat(*transformed_split[:2])  # Concatenate only the first two columns
    for col in transformed_split[2:]:
        O = hconcat(O, col) 
    return O
 
10.666666666666666, 7.3480597, def ddcdiddebjgaeffdaabeedecbfijebcb(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      if O[i][j] != mostcolor(I):
        k = min([x for x in range(j) if O[i][x] == mostcolor(I)], default=j)
        O = move(O, {(O[i][j], (i, j))}, (0, -j + k))
  return O 
 
9.666666666666666, 7.1583767, def fgfdedabhjbceehdiegciidbjejcfjbg(I):
  objs = objects(I, False, False, True)
  O = I
  for obj in objs:
    j = min(j for i, j in toindices(obj))
    k = min([x for x in range(j) if O[uppermost(obj)][x] == mostcolor(I)], default=j)
    O = move(O, obj, (0, -j + k))
  return O
 
10.333333333333334, 7.408206, def ffddcdcfaaafedjajifbfecfeiiebaef(I):
  O = I
  for i in range(height(I)):
    row = I[i]
    non_bg_values = remove(mostcolor(I), row)
    j = 0
    for v in non_bg_values:
      loc = (i, next((x for x, y in enumerate(row) if y == v), -1))
      O = move(O, {(v, loc)}, (0, -loc[1] + j))
      j += 1
  return O
 
4.333333333333333, 5.2404494, def cjdfbbcdfgdeeifajaijfccgifebedbj(I):
  O = canvas(mostcolor(I), shape(I))  # Create empty canvas
  for v in sorted(palette(I) - {mostcolor(I)}): # Iterate through colors
    obj = first(colorfilter(objects(I, True, True, False), v))
    h, w = len(I), len(I[0])
    for i in range(h):
      for j in range(w-1, -1, -1): # Iterate through grid from right to left
        if index(O, (i, j)) == mostcolor(I) and size(intersection(toindices(shift(obj, (i, j))), asindices(O))) == size(obj):
          O = paint(O, shift(obj, (i, j)))
          break
      else:
        continue
      break
  return O
 
5.333333333333333, 8.682426, def hfbicibadaideeaabcadjhgccdadfgch(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), shape(I))
  for v in sorted(palette(I) - {mostcolor(I)}):
    obj = first(colorfilter(objects(I, True, True, False), v))
    obj_placed = False
    for i in range(h):
      for j in range(w - width(obj), -1, -1):
        target_area = frozenset((i + k, j + l) for k in range(height(obj)) for l in range(width(obj)))
        if all(index(O, (row, col)) == mostcolor(I) for row, col in target_area):
          O = paint(O, shift(obj, (i, j)))
          obj_placed = True
          break
      if obj_placed:
        break
  return O
 
7.0, 38.56502, def bhecjcccffadefdbibbijibehicjjebe(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), shape(I))
  for color in sorted(palette(I) - {mostcolor(I)}):
    obj = first(colorfilter(objects(I, True, True, False), color))
    placed = False
    for row in range(h):
      for col in range(w - width(obj), -1, -1):
        new_obj = shift(obj, (row, col))
        if all(0 <= i < h and 0 <= j < w and (i, j) not in toindices(asobject(O)) for _, (i, j) in new_obj):
          O = paint(O, new_obj)
          placed = True
          break
      if placed:
        break
  return O
 
8.0, 24.74362, def jbgaegabhfgaegeabhdeabbfedicgjaa(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for color in sorted(palette(I) - {mostcolor(I)}):
    obj = first(colorfilter(objects(I, True, True, False), color))
    for row in range(h):
      for col in range(w - width(obj), -1, -1):
        if all(I[i][j] == mostcolor(I) for i in range(row, row + height(obj)) for j in range(col, col + width(obj)) if 0 <= i < h and 0 <= j < w):
          O = paint(O, shift(obj, (row, col)))
          break
      else:
        continue
      break
  return O
 
4.333333333333333, 5.764971, def ecfiiffjjcaaehadbgfacjccfdjaeaie(I):
  O = canvas(mostcolor(I), shape(I))  
  for v in sorted(palette(I) - {mostcolor(I)}): 
    obj = first(colorfilter(objects(I, True, True, False), v))
    for i in range(len(I)):
      for j in range(len(I[0]) - width(obj), -1, -1):
        new_obj = shift(obj, (i, j))
        if all((v, (row, col)) not in asobject(O) for v, (row, col) in new_obj):
          O = paint(O, new_obj)
          break 
      else:
        continue
      break
  return O
 
3.6666666666666665, 3.7779598, def cahbagbeabacehffibdcfdhbbddadabc(I):
  def move_if_even(obj):
    if even(color(obj)):
      return shift(obj, UP_RIGHT)
    return obj

  moved_objs = apply(move_if_even, objects(I, T, T, T))
  return paint(cover(I, asindices(I)), merge(moved_objs))
 
4.0, 4.1356688, def iefaaihcddbhejafjeiebcjeabbbjebd(I):
  O = cover(I, asindices(I))
  for obj in objects(I, T, T, T):
    if even(color(obj)):
      O = paint(O, shift(obj, UP_RIGHT))
    else:
      O = paint(O, obj)
  return O
 
4.333333333333333, 5.1891623, def fccgcdbbcebeeebaifcfgfccdhjigajd(I):
  def new_location(cell):
    value, (i, j) = cell
    return (value, add((i, j), UP_RIGHT)) if even(value) else cell
  
  return paint(canvas(mostcolor(I), shape(I)), apply(new_location, asobject(I)))
 
5.666666666666667, 8.198194, def cfjgadcddffaecdbbgegeehjdbcdaccc(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if even(value):
        new_i, new_j = i - 1, j + 1
        if 0 <= new_i < len(I) and 0 <= new_j < len(row):
          O = paint(cover(O, {(value, (i, j))}), {(value, (new_i, new_j))})
  return O
 
6.0, 5.0026345, def ccccgeafigijeeddaacdjbaajacjdfba(I):
    objs = objects(I, T, T, T)
    new_grid = I
    for obj in objs:
        # Define rules for object movement based on size, color, etc.
        if size(obj) == 1 and color(obj) == 3:
            new_pos = (uppermost(obj) - 1, leftmost(obj) + 1) 
            new_grid = move(new_grid, obj, new_pos)
        # Add more rules for other objects and their movements
    return new_grid
 
4.666666666666667, 5.4765553, def ghfeeggbfagfeiaeijcdhhebheeebjff(grid):
  def move_object(obj):
    # Determine the number of empty spaces to the right of the object.
    row_index = uppermost(obj)
    rightmost_occupied = rightmost(obj)
    empty_spaces = len(grid[row_index]) - rightmost_occupied - 1
    
    # Shift the object to the right by the number of empty spaces.
    return shift(obj, (0, empty_spaces))

  # Apply the movement to all objects and paint them back onto a blank canvas.
  moved_objects = apply(move_object, objects(grid, T, T, T))
  return paint(canvas(mostcolor(grid), shape(grid)), merge(moved_objects)) 
 
6.333333333333333, 6.0280676, def feaaeghfjeicedaajebdffifieggabjd(grid):
  def move_recursive(grid, col_index=0):
    h, w = shape(grid)
    if col_index == w:
      return grid
    
    new_grid = grid
    for row_index in range(h):
      if grid[row_index][col_index] != mostcolor(grid):
        obj = extract(objects(grid, T, T, T), lambda o: (row_index, col_index) in toindices(o))
        empty_spaces = len([j for j in range(col_index + 1, w) if grid[row_index][j] == mostcolor(grid)])
        new_grid = move(grid, obj, (0, empty_spaces))
    
    return move_recursive(new_grid, col_index + 1)

  return move_recursive(grid)
 
3.3333333333333335, 10.292019, def gddjbbcecbbaedebifiegaahfebagiah(I):
    objs = objects(I, True, False, False)
    new_objs = frozenset()
    for obj in objs:
        v = color(obj)
        if v == FIVE: 
            new_objs = new_objs | frozenset({shift(obj, (0,0))})
        else:
            new_objs = new_objs | frozenset({shift(obj, (0, v))})
    O = paint(canvas(ZERO, shape(I)), merge(new_objs))
    return O
 
8.666666666666666, 15.163571, def gbeaajhehfadedceiigchifbibehbhec(I):
    values = sorted(palette(I))
    new_objs = frozenset()
    for i, v in enumerate(values):
        obj = toobject(ofcolor(I, v), I)
        new_objs = new_objs | frozenset({shift(obj, (0, i))})
    O = paint(canvas(ZERO, shape(I)), merge(new_objs))
    return O
 
4.333333333333333, 4.2326, def gdahbfjhfgafeddaibfahfbdaaheaffc(I):
    O = canvas(ZERO, shape(I))
    for v in palette(I):
        obj = toobject(ofcolor(I, v), I)
        offset = (0, v - FIVE) if v != FIVE else (0, 0)
        O = paint(O, shift(obj, offset))
    return O
 
9.333333333333334, 18.296154, def cjbdicbjgbeeefjgbgabfcigcicacfhb(I):
    objs = objects(I, True, False, False)
    new_objs = frozenset()
    h = height(I)
    w = width(I)
    for obj in objs:
        v = color(obj)
        j = v if v != FIVE else 0
        for cell in obj:
            _, (i, _) = cell
            new_objs = insert((v, (i, j)), new_objs)
    O = paint(canvas(ZERO, shape(I)), new_objs)
    return O
 
5.0, 12.079764, def fiabgcahddcaefhaibeeacdceehfdcfb(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            if v == FIVE:
                O = paint(O, {(v, (i, j))})
            else:
                O = paint(O, {(v, (i, v))})
    return O
 
6.0, 5.370545, def bhfjgaegdgiheehejcbiaaeddabhfabc(grid):
  h, w = shape(grid)
  new_grid = canvas(mostcolor(grid), (h, w))
  for obj in objects(grid, T, T, T):
    row_index = uppermost(obj)
    for col_index in range(w):
      if index(new_grid, (row_index, col_index)) == mostcolor(grid):
        new_grid = paint(cover(new_grid, obj), shift(obj, (0, col_index - leftmost(obj))))
        break
  return new_grid
 
10.0, 10.100697, def cdbgjaidhggbebcbiaijjfacccdighjj(grid):
    h, w = shape(grid)
    
    def sort_column(j):
        column = [grid[i][j] for i in range(h)]
        fg_elements = [v for v in column if v != mostcolor(grid)]
        sorted_column = fg_elements + [mostcolor(grid)] * (h - len(fg_elements))
        return tuple(sorted_column)
    
    return dmirror(tuple(sort_column(j) for j in range(w)))
 
11.0, 5.427232, def fadeeiabffagejcfacgdfggjeagbeeeb(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
        grid[(i - grid[0][j] + 1) % h][j] for j in range(w)
      )
    for i in range(h)
  )
 
10.666666666666666, 7.3480597, def aefgaaacecbaedfiaafdghghcjajdfjj(grid):
  return tuple(
      tuple(v for v in row if v != mostcolor(grid)) + tuple(repeat(mostcolor(grid), len(row) - len([v for v in row if v != mostcolor(grid)]))) 
      for row in grid
  )
 
14.666666666666666, 13.164484, def iifahedbaebeeiebbicdfeedbjbdaeed(grid):
  h, w = shape(grid)
  return tuple(
    tuple(
      extract(row, lambda v: v != mostcolor(grid)) if any(v != mostcolor(grid) for v in row) else mostcolor(grid) 
      for _ in range(w)
    ) 
    for row in grid
  )
 
7.0, 38.56502, def hhbcibeaabeeefbfbbfjidbbficjicfc(grid):
  h, w = len(grid), len(grid[0])
  shifted_grid = canvas(mostcolor(grid), (h,w)) # Create a canvas of background color
  for j in range(w):
    column = tuple(grid[i][j] for i in range(h)) # Extract the j-th column
    shift_amount = column[0]  # Get the shift amount from the first element
    if shift_amount > 0: # Shift only if shift_amount is positive
      shift_amount -= 1
      shifted_column = column[shift_amount:] + tuple(mostcolor(grid) for _ in range(shift_amount)) # Shift the column
      for i, val in enumerate(shifted_column):
        shifted_grid = paint(shifted_grid, {(val, (i, j))}) # Paint the shifted column onto the canvas
  return shifted_grid
 
7.333333333333333, 16.619598, def befbibhgeeaiefbgbcgeaecadijcfidf(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
    tuple(
      grid[(i - grid[i][j] + 1) % h][j] # Calculate new row index based on shift
      if grid[i][j] != 0 # Shift only if the element is not 0 
      else grid[i][j] # Keep 0s in their original position
      for j in range(w)
    )
    for i in range(h)
  )
 
6.666666666666667, 4.60938, def bccbihgbbiadebbejfcdbfadjdeggaag(grid):
  h, w = len(grid), len(grid[0])
  shifted = []
  for j in range(w):
    col = [grid[i][j] for i in range(h)]
    s = col[0] - 1
    if s >  0:
      col = col[s:] + col[:s]
    shifted.append(col)
  return tuple(tuple(shifted[j][i] for j in range(w)) for i in range(h))
 
8.0, 23.247852, def jcijacbadfjeejdbbfbchiigajhcecfd(I):
  O = canvas(mostcolor(I),shape(I))
  for j in range(width(I)):
    C = tuple(I[i][j] for i in range(height(I)))
    S = C[0] - 1
    if S >= 0:
      O = paint(O, {(v,(i,j)) for i,v in enumerate(tuple(C[S:len(C)] + C[0:S]))})
  return O
 
3.3333333333333335, 3.4442773, def cijefhgcfebfecffaeddjeebhbfdabbe(I):
  O = I
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = height(I) - 2 if c == 1 else 1 if c in (2, 8) else 0 
      target_j = width(I) - width(obj)
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj))) 
  return O
 
8.666666666666666, 16.11511, def hcdgcffegbjcejgaihafgbfaajagijca(grid):
  h, w = shape(grid)
  new_grid = canvas(mostcolor(grid), (h, w))
  for i in range(h):
    for j in range(w):
      if grid[i][j] != mostcolor(grid):
        shift_amount = grid[i][j] - 1
        new_j = min(j + shift_amount, w-1)  # Prevent shifting out of bounds
        new_grid = fill(new_grid, grid[i][j], {(i, new_j)})
  return new_grid
 
8.666666666666666, 26.059216, def bcbfficdjehaedcbjieiceadcjhaebcf(grid):
  h, w = shape(grid)
  shifted_objs = mapply(
      lambda obj: shift(obj, (0, color(obj) - 1)), 
      objects(grid, T, T, T)
  )
  return paint(canvas(mostcolor(grid), (h, w)), shifted_objs)
 
7.333333333333333, 36.343468, def bigefdhdedfgefaeaigigjecfiiahgjb(grid):
  h, w = shape(grid)
  return tuple(
    tuple(
      grid[i][j-grid[i][j]+1] if j-grid[i][j]+1 >= 0 and grid[i][j] != mostcolor(grid) else mostcolor(grid)
      for j in range(w)
    )
    for i in range(h)
  )
 
6.333333333333333, 31.131462, def fjdgafffedgaeffabeccfechgccfhceh(I):
  O = I
  for v in palette(I) - {mostcolor(I)}:  # For each non-background color
    for j in range(width(I)):  
      for i in range(height(I)):
        if I[i][j] == v:
          O = move(O, {(v, (i, j))}, (-i, -j)) # Move to top-left (0,0)
  return O
 
7.333333333333333, 14.337678, def hfebecjbffcjegjejeadecjdbcdiiaad(I):
    O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
    for obj in sorted(objects(I, False, False, True), key=lambda x: ulcorner(x)[0] * width(I) + ulcorner(x)[1]):
        O = paint(O, shift(obj, subtract(ulcorner(obj), (0, 0)))) 
    return O
 
8.666666666666666, 17.430449, def echehaaedfcfechajfahhhdcedfabccd(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      v = I[i][j]
      if v != mostcolor(I):
        O = move(O, {(v, (i, j))}, (-i, 0)) # Move to the top row
  return O
 
11.0, 7.627841, def jfacacjfjafbeabcijehbfffcccfaaea(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      if I[i][j] != mostcolor(I):
        target_i = next((row for row in range(height(I)) if O[row][j] == mostcolor(I)), height(I))
        O = move(O, {(I[i][j], (i, j))}, (-i + target_i, 0))
  return O
 
8.0, 6.240407, def cgddbfaejeadeebjifefgidgbgefabfd(I):
    objs = objects(I, False, False, True)
    O = canvas(mostcolor(I), shape(I))
    for i, obj in enumerate(sorted(objs, key=lambda x: -len(x))):
        offset = (0, i)
        O = paint(O, shift(obj, offset))
    return O
 
14.333333333333334, 11.874553, def ghgeigficbajegediacfeacefhgdedbf(grid):
  def shift_row(row):
    bg = mostcommon(row) 
    shifted = []
    i = 0
    while i < len(row):
      j = (i + 1) % len(row)
      while row[j] == bg and j != i:
        j = (j + 1) % len(row)
      shifted.append(row[j])
      i += 1
    return tuple(shifted)
  return tuple(shift_row(row) for row in grid)
 
4.333333333333333, 5.2404494, def ghedgbfccfaaejfbjcghddbfhbagggbh(I):
  O = I
  for c in sorted(palette(I)):
    for obj in objects(I, T, T, T):
      if color(obj) != c: continue
      target_i = uppermost(obj)  # Stay in the same row
      target_j = width(I) - width(obj) # Move to the rightmost column
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
8.0, 30.326115, def fibgdiafaeibefcebjdcdjjcebceddfg(I):
  O = cover(I, asindices(I)) # Clear the grid
  for obj in objects(I, T, T, T):
    target_i = uppermost(obj) 
    target_j = width(I) - width(obj) - color(obj) # Adjust column based on color
    O = paint(O, shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj))))
  return O
 
3.3333333333333335, 10.292019, def ijfjbhjeeiecegceibdbdgjbgcegadbe(I):
  O = canvas(ZERO, shape(I))  
  for v in palette(I):
    obj = toobject(ofcolor(I, v), I)
    offset = (0, v) if v != FIVE else (0, 0) 
    O = paint(O, shift(obj, offset))
  return O
 
3.6666666666666665, 10.09024, def effjebdfdgibeaegajedgfacejeeabgb(I):
  O = cover(I, asindices(I)) 
  for obj in objects(I, T, T, T):
    O = paint(O, shift(obj, (0, color(obj) if color(obj) != FIVE else 0))) 
  return O
 
4.0, 9.778407, def bgbfefcfabbfehfiihedacjcecdiecfa(I):
  O = I 
  for i in range(1, 10):
    if i != FIVE:
      O = paint(cover(O, ofcolor(O, i)), shift(toobject(ofcolor(I, i), I), (0, i))) 
  return O
 
7.666666666666667, 5.9320145, def fcfgadbbhchfeefgbjafgdjehhfibdai(I):
    O = I
    for v in palette(I) - {FIVE}:
        O = paint(O, shift(recolor(v, ofcolor(I, v)), (0, width(I) - 1)))
    return O
 
5.0, 4.4230456, def fecfedafegbaeagbjcabfbefaeejbdch(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  
  for obj in objs:
    c = color(obj)
    if c == THREE:
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif c == SIX and size(I) == FOUR:
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif c == FOUR and size(I) == FOUR:
      O = paint(O, shift(obj, (height(I) - ONE, width(I) - ONE)))
    elif c == EIGHT and size(I) == astuple(FIVE, FIVE):
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif c == TWO and size(I) == astuple(FIVE, FIVE):
      O = paint(O, obj)
      bottom_half = vsplit(I, TWO)[ONE]
      obj2_split = extract(objects(bottom_half), lambda o: color(o) == TWO and leftmost(o) == ZERO)
      O = paint(O, shift(obj2_split, (ZERO, width(I) - width(obj2_split) - ONE)))
    else:
      O = paint(O, obj)
  return O
 
5.0, 4.2834654, def bbdeifbbbiceebbaicafhedfcjdcfcaj(I):
  def get_target_location(obj):
    c = color(obj)
    if c == THREE:
      return (ZERO, width(I) - width(obj))
    elif c == SIX and size(I) == FOUR:
      return (ZERO, width(I) - width(obj))
    elif c == FOUR and size(I) == FOUR:
      return (height(I) - ONE, width(I) - ONE)
    elif c == EIGHT and size(I) == astuple(FIVE, FIVE):
      return (ZERO, width(I) - width(obj))
    else:
      return ulcorner(obj)

  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))

  for obj in objs:
    target_loc = get_target_location(obj)
    if color(obj) == TWO and size(I) == astuple(FIVE, FIVE) and target_loc != ulcorner(obj):
      bottom_half = vsplit(I, TWO)[ONE]
      obj2_split = extract(objects(bottom_half), lambda o: color(o) == TWO and leftmost(o) == ZERO)
      O = paint(O, shift(obj2_split, (target_loc[ZERO], target_loc[ONE] - width(obj2_split) - ONE)))
    O = paint(O, shift(obj, (target_loc[ZERO] - uppermost(obj), target_loc[ONE] - leftmost(obj))))
  return O
 
7.666666666666667, 6.908498, def eafaceccdbcdebfcihidfcebjffffbbe(I):
    x1 = leastcolor(I)  # Finding the least common color (background)
    x2 = ofcolor(I, x1) # Getting indices of background cells
    x3 = palette(I) - {x1} # Finding colors of objects (excluding background)
    
    O = I # Initializing output as input
    for color in x3:
        x4 = ofcolor(I, color) # Finding indices of current object
        x5 = argmax(x4, lambda loc: loc[0] + loc[1]) # Finding bottom-right-most index
        x6 = dneighbors(x5) - x2 # Finding adjacent empty cells
        if x6:
            x7 = argmin(x6, lambda loc: loc[0] * loc[1]) # Selecting top-left-most adjacent empty cell
            O = fill(O, x1, {x5}) # Filling original position with background
            O = fill(O, color, {x7}) # Filling the selected empty cell with the object color
    return O
 
9.0, 22.467108, def ddfeafgddddgefhdjfgadjfbcicfehcg(I):
    x1 = objects(I, True, True, True) # Extract objects (univalued, diagonal, without background)
    
    O = I # Initialize output as input
    for obj in x1:
        x2 = normalize(obj) # Normalize the object
        x3 = ulcorner(x2)  # Get upper-left corner of normalized object
        x4 = add(x3, (1, -1)) # Calculate new upper-left corner (shifted diagonally)
        x5 = shift(x2, subtract(x4, x3)) # Shift object to new location
        O = cover(O, obj) # Remove original object
        O = paint(O, x5) # Paint shifted object
    return O
 
7.333333333333333, 6.1260953, def bdcbhbfdeecjecefjgcajfehgbabjjba(I):
    x1 = palette(I)  # Finding all colors in the grid
    O = I # Initializing output as input
    for color in x1:
        x2 = ofcolor(I, color) # Get indices of the current color
        if len(x2) > 1: # If there are multiple cells with the same color
            x3 = argmax(x2, lambda loc: loc[0] * 3 + loc[1]) # Find the bottom-most, right-most index
            x4 = dneighbors(x3) - x2 # Finding adjacent empty cells
            if x4:
                x5 = argmin(x4, lambda loc: loc[0] * 3 + loc[1]) # Selecting top-most, right-most adjacent empty cell
                O = fill(O, mostcolor(I), {x3}) # Filling original position with background
                O = fill(O, color, {x5}) # Filling the selected empty cell with the object color
    return O
 
7.333333333333333, 6.7854834, def dahifccfbaibecjeaaacibcacjfabdja(I):
    x1 = objects(I, True, False, True) # Extract objects (univalued, no diagonals, without background)
    O = I # Initialize output as input
    for obj in x1:
        x2 = ulcorner(obj) # Get the upper-left corner of the object
        x3 = (x2[0] - 1, x2[1] + 1) # Calculate the new position (diagonal up-right)
        x4 = shift(obj, subtract(x3, x2)) # Shift the object to the new location
        O = cover(O, obj) # Remove the original object
        O = underpaint(O, x4) # Paint the shifted object (only on background cells)
    return O
 
5.0, 8.407539, def adfbhacadcfdecbdjfdjfdabaicehfba(I):
    x1 = palette(I) - {mostcolor(I)} # Identify object colors (excluding background)
    O = I # Initialize output as input
    for color in x1:
        x2 = ofcolor(I, color) # Get indices of the current color
        x3 = min(x2) # Get the top-most, left-most cell of the object
        x4 = (x3[0] - 1, x3[1] + 1) # Calculate new position (diagonal up-right)
        O = fill(O, mostcolor(I), {x3}) # Remove original cell
        O = fill(O, color, {x4}) # Fill the new position
    return O
 
3.6666666666666665, 4.5782933, def jadfjfdiaabfehfdijcfdghedbecfaad(I):
  O = I
  for c in sorted(palette(I)):
    for obj in objects(I, T, T, T):
      if color(obj) != c: 
        continue
      target_i = 0 if c != 5 else uppermost(obj) # Top row for non-5, original row for 5
      target_j = width(I) - width(obj) - sum(width(obj2) for obj2 in objects(O, T, T, T) if color(obj2) == c and leftmost(obj2) > leftmost(obj)) # Rightmost position in the row
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
4.0, 4.90457, def iidgdgdcgafbeaagicgfdcidaddbbeed(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize with background
  for c in sorted(palette(I), reverse=True): # Reverse color order
    for obj in objects(I, T, T, T):
      if color(obj) != c:
        continue
      target_i = 0 if c != 5 else uppermost(obj)
      target_j = width(I) - width(obj)
      O = paint(O, shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj)))) # Directly paint, avoiding multiple moves
  return O
 
8.0, 24.817812, def dbfcjbeaahgjeafdbjibifdiccbaeffb(I):
  O = I
  for obj in objects(I, T, T, T):
    target_i = 0 if color(obj) != 5 else uppermost(obj)
    target_j = max(j for i, j in ofcolor(O, color(obj))) + width(obj) if any(index(O, (target_i, j)) == color(obj) for j in range(width(I))) else width(I) - width(obj) # Find the rightmost position of the same color object in the row, otherwise place it at the right end
    O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
3.6666666666666665, 9.614387, def ecccffbebgfeefcbbfdeibeeaegfddeg(I):
    O = canvas(ZERO, shape(I))
    for v in palette(I):
        obj = toobject(ofcolor(I, v), I)
        h = uppermost(obj)  
        offset = (0, h * (v - FIVE))
        O = paint(O, shift(obj, offset))
    return O
 
3.0, 11.498762, def efbciicbadghebicafajijjcdbgffeii(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    c = color(obj)
    for v, (i, j) in obj:
      O = paint(O, {(v, (i, j + i * (c - FIVE)))})
  return O
 
6.0, 31.043228, def ceidffddcdicedcabgeaefdhedeiebch(I):
    O = I  
    for v in palette(I) - {FIVE}:
        obj = toobject(ofcolor(I, v), I)
        for i in range(height(obj)):
            O = move(O, toobject({(v, (i + uppermost(obj), j)) for j in range(width(obj))}, O), (0, i * (v - FIVE)))
    return O
 
5.666666666666667, 5.9943447, def adjhdhdeejehegjabedbjaegheheigbb(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, T, T):
        h = uppermost(obj)
        w = width(obj)
        v = color(obj)
        for i in range(h, h + height(obj)):
            for j in range(leftmost(obj), leftmost(obj) + w):
                if (i, j) in toindices(obj):
                    O = paint(O, {(v, (i, j + (i - h) * (v - FIVE)))}) 
    return O
 
13.333333333333334, 19.653006, def ffehaabehgceejibjafdedhbcdceefff(I):
  # Create a blank canvas of the same size as the input.
  O = canvas(FIVE, shape(I)) 

  # Iterate through each non-5 color in the input.
  for v in palette(I) - {FIVE}:
      # Get the indices of the current color.
      indices = ofcolor(I, v)
      # Calculate the shift amount for the current color.
      shift_amount = width(I) - 1 - leftmost(indices)
      # Shift and paint the color onto the canvas.
      O = paint(O, shift(recolor(v, indices), (0, shift_amount)))
  return O
 
12.333333333333334, 17.32396, def bccaibdefbaheccbbgcfhhdhacdeccdb(I):
  # Find all non-5 cells and their corresponding destination column indices.
  shifted_cells = ((I[i][j], (i, width(I) - 1)) for i in range(height(I)) for j in range(width(I)) if I[i][j] != FIVE)
  
  # Create a blank canvas filled with 5s.
  O = canvas(FIVE, shape(I))

  # Paint the shifted cells onto the canvas.
  O = paint(O, frozenset(shifted_cells))
  return O
 
10.666666666666666, 9.393549, def idgcbjigjhjieefbbebcdcdcccgeaijb(I):
    # Create a list to store the transformed rows.
    transformed_rows = []

    # Iterate over each row in the input grid.
    for row in I:
        # Extract the non-5 digits from the row.
        non_5_digits = [digit for digit in row if digit != FIVE]
        # Create a new row with 5s and the extracted digits.
        transformed_row = [FIVE] * (len(row) - len(non_5_digits)) + non_5_digits
        # Append the transformed row to the list.
        transformed_rows.append(transformed_row)

    # Convert the list of transformed rows back to a tuple of tuples (grid format).
    O = tuple(tuple(row) for row in transformed_rows)
    return O
 
5.0, 4.2795177, def afeddaeecfceeegcafbjiiibefgaffgj(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) in (THREE, SIX, EIGHT):
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif color(obj) == FOUR and size(I) == FOUR:
      O = paint(O, shift(obj, (height(I) - ONE, width(I) - ONE)))
    elif color(obj) == TWO and size(I) == astuple(FIVE, FIVE):
      h = height(I) // TWO
      obj2_top = extract(objects(crop(I, (ZERO, ZERO), (h, width(I)))), lambda o: color(o) == TWO)
      obj2_bottom = extract(objects(crop(I, (h, ZERO), (h, width(I)))), lambda o: color(o) == TWO)
      O = paint(O, shift(obj2_top, (ZERO, width(I) - width(obj2_top))))
      O = paint(O, shift(obj2_bottom, (TWO, width(I) - width(obj2_bottom))))
    else:
      O = paint(O, obj)
  return O
 
7.0, 38.56502, def ejfbcbiebdabebfejcdaddddcfdgcbhg(grid):
  objs = objects(grid, True, False, False)
  sorted_objs = order(objs, lambda obj: color(obj))
  output_grid = canvas(mostcolor(grid), shape(grid))
  current_position = (0, 0)
  for obj in sorted_objs:
    output_grid = paint(output_grid, shift(obj, subtract(current_position, ulcorner(obj))))
    current_position = add(current_position, (height(obj), 0))
  return output_grid
 
8.666666666666666, 28.545591, def gdjadbfjhddceadajfcfdijefdfdfafi(grid):
  colors = order(palette(grid), identity)
  output_grid = canvas(mostcolor(grid), shape(grid))
  current_position = (0, 0)
  for value in colors:
    obj = extract(objects(grid, True, False, False), lambda o: color(o) == value)
    output_grid = paint(output_grid, shift(obj, subtract(current_position, ulcorner(obj))))
    current_position = add(current_position, (height(obj), 0))
  return output_grid
 
8.666666666666666, 18.63305, def feihgccfcdefeeidbhaeffeeeifdbcdh(grid):
  sorted_objs = order(objects(grid, True, False, False), lambda obj: -color(obj))
  output_grid = canvas(mostcolor(grid), shape(grid))
  current_position = subtract(shape(grid), (1, 1))
  for obj in sorted_objs:
    output_grid = paint(output_grid, shift(obj, subtract(current_position, lrcorner(obj))))
    current_position = subtract(current_position, (height(obj), 0))
  return output_grid
 
7.0, 31.659275, def aceeeifiajecejbfbbeeeeeaibcaedbh(grid):
  objs = objects(grid, True, False, False)
  output_grid = grid
  for obj in objs:
    output_grid = cover(output_grid, obj)
    output_grid = paint(output_grid, shift(obj, subtract((0, 0), ulcorner(obj))))
  return output_grid
 
10.666666666666666, 9.241292, def bdgighhffagieeebjffaegihfbegddee(grid):
  objs = order(objects(grid, True, False, False), lambda obj: color(obj))
  output_grid = canvas(mostcolor(grid), shape(grid))
  current_position = (0, 0)
  for obj in objs:
    if current_position[1] + width(obj) > width(grid):
      current_position = (current_position[0] + height(obj), 0)
    output_grid = paint(output_grid, shift(obj, subtract(current_position, ulcorner(obj))))
    current_position = add(current_position, (0, width(obj)))
  return output_grid
 
4.666666666666667, 7.0536222, def dbhfbeeddgdfebfbacdicccaiiacdbge(I):
  O = I
  for c in sorted(palette(I)):
    objs = sizefilter(objects(I, T, T, T), colorcount(I, c))
    target_j = width(I) 
    for i, obj in enumerate(objs):
      target_j -= width(obj)  # Update the target_j for the next object of the same color
      O = move(O, obj, (uppermost(obj) - uppermost(obj), target_j - leftmost(obj)))
  return O
 
4.666666666666667, 5.296579, def ebceedjieeebecdajceadjidjdachbdd(I):
  O = I
  for c in sorted(palette(I), reverse=True):
    occupied_width = 0 
    for obj in objects(I, T, T, T):
      if color(obj) == c:
        target_j = width(I) - occupied_width - width(obj)
        O = move(O, obj, (0, target_j - leftmost(obj)))
        occupied_width += width(obj) 
  return O
 
3.6666666666666665, 9.244399, def bcfbaggdbhcdefaeiejahecagebafabe(I):
  O = canvas(ZERO, shape(I))
  for v in palette(I):
    obj = toobject(ofcolor(I, v), I)
    offset = (0, (v // 2) * 2) if even(v) else (0, 0)  # Even values shift right
    O = paint(O, shift(obj, offset))
  return O
 
3.6666666666666665, 9.36573, def ecidcebcdhbbefiebbfdhbeaeddgfabg(I):
  objs = objects(I, T, T, F)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    v = color(obj)
    O = paint(O, shift(obj, (0, (v//2)*2) if even(v) else (0, 0)))
  return O
 
7.333333333333333, 33.846703, def dededeiddcibecdbifiacjjjehdibbda(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            O = paint(O, {(v, (i, j + (v//2) * 2))})
    return O
 
8.0, 29.544083, def fdcfdgcdbacaefciifebjbcefhejadhj(I):
  O = cover(I, asindices(I))  # Start with a blank canvas
  for obj in objects(I, T, T, F):
    v = color(obj)
    new_obj = {(v, (i, j + (v // 2) * 2)) for v, (i, j) in obj} # Shift object
    O = paint(O, new_obj)
  return O
 
27.333333333333332, 87.26165, def bcaccaahjcaaecdfbafgcaiehcdffdid(I):
  # Split the input grid into columns.
  x1 = vsplit(I, width(I))
  
  # Isolate the rightmost column.
  x2 = x1[-1]
  
  # Create a canvas filled with the background color, excluding the rightmost column.
  x3 = canvas(mostcolor(I), (height(I), width(I) - 1))
  
  # Concatenate the canvas with the isolated rightmost column.
  O = hconcat(x3, x2)
  return O
 
7.666666666666667, 20.688051, def bbeffcbbdafaebaabceagiebbcejeiaj(I):
  # Determine the background color.
  bg = mostcolor(I)
  
  # Create a new grid with the same dimensions as the input, filled with the background color.
  O = canvas(bg, shape(I))
  
  # Iterate through the input grid, transferring non-background values to the rightmost column of the new grid.
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != bg:
        O = paint(O, {(I[i][j], (i, width(O) - 1))})
  return O
 
7.333333333333333, 8.376657, def dcfcbcejcfffefbfijdjgjifaeeefbhe(I):
    # Create a list to store modified objects
    shifted_objects = []
    
    # Iterate through each color in the grid
    for color in palette(I):
        # Find all occurrences of the current color
        indices = ofcolor(I, color)
        
        # If the color is not the background color
        if color != mostcolor(I):
            # Shift the object to the rightmost column
            shifted_objects.append(shift(recolor(color, indices), (0, width(I) - 1 - rightmost(indices))))

    # Paint all shifted objects onto the original grid
    O = paint(I, merge(shifted_objects))
    return O
 
6.333333333333333, 4.8743963, def fbbbbgefdabgejbaagddcadhfcfigfba(I):
    # Extract objects from the grid, excluding background
    x1 = objects(I, True, True, True) 
    # Sort objects based on their color
    x2 = order(x1, lambda obj: color(obj)) 
    # Shift the second object up and left
    x3 = shift(x2[1], (-1, -1))
    # Paint the shifted object onto the original grid
    O = paint(I, x3) 
    return O
 
5.666666666666667, 5.1862855, def efbhceccfhcfefigihbeiafeebdegedj(I):
  # Get objects, excluding background
  x1 = objects(I, True, True, True)
  # Find the object with the least common color 
  x2 = argmin(x1, lambda obj: colorcount(I, color(obj)))
  # Shift the object diagonally upwards
  x3 = shift(x2, (-1, -1)) 
  # Cover the original object's position
  x4 = cover(I, x2)  
  # Paint the shifted object onto the modified grid
  O = paint(x4, x3)
  return O
 
6.0, 4.9245906, def ccbhjbiaeceheebcjaafdacbfiacecce(I):
  # Get all objects, excluding background
  x1 = objects(I, True, True, True)
  # Find the smallest object 
  x2 = argmin(x1, len) 
  # Find the largest object
  x3 = argmax(x1, len)  
  # Determine the direction to move the smaller object towards the larger one
  x4 = gravitate(x2, x3)
  # Move the smaller object
  x5 = shift(x2, x4) 
  # If the objects are not adjacent after the move, move the smaller object one step closer
  x6 = branch(adjacent(x5, x3), x5, shift(x5, sign(x4)))
  # Cover the original object and paint the moved object
  O = paint(cover(I, x2), x6) 
  return O
 
4.666666666666667, 6.192015, def jagghffebiibegcijdfaddabdciececi(I):
  O = I
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = 0 if c == 5 else 1 if c in (3, 4) else height(I) - size(obj) 
      target_j = width(I) - size(obj) if c != 3 else 1
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj))) 
  return O
 
4.666666666666667, 5.704732, def eeecfjgadccieeajibeeeddfafcdbedf(I):
  objs = objects(I, T, T, T)
  new_objs = set()
  for c in palette(I):
    for s in {size(obj) for obj in objs if color(obj) == c}:
      matching_objs = {obj for obj in objs if color(obj) == c and size(obj) == s}
      target_i = 0 if c == 5 else 1 if c in (3, 4) else height(I) - s
      target_j = width(I) - s if c != 3 else 1
      for i, obj in enumerate(sorted(matching_objs, key=lambda obj: ulcorner(obj))):
        offset = (target_i - uppermost(obj), target_j - leftmost(obj) + i)
        new_objs.add(shift(obj, offset))
  return paint(cover(I, asindices(I)), merge(new_objs))
 
4.0, 8.127746, def accciaaaehhfeefbafbffddffdfhfacc(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    s = size(obj)
    target_i = 0 if c == 5 else 1 if c in (3, 4) else height(I) - s
    target_j = width(I) - s if c != 3 else 1
    O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O 
 
4.666666666666667, 5.964475, def fdeeeebfefieeiahbcdabedgffdhcaab(I):
    return paint(canvas(0, shape(I)), merge({shift(obj, (0 if color(obj) == 5 else 1 if color(obj) in (3, 4) else height(I) - size(obj) - uppermost(obj), width(I) - size(obj) - leftmost(obj) if color(obj) != 3 else 1 - leftmost(obj))) for obj in objects(I, T, T, T)}))
 
24.0, 22.528801, def eddfdafhedfheghdifagibhfadcafihg(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w * 2))  # Create a wider canvas
  for i in range(h):
    for j in range(w):
      v = I[i][j]
      O = paint(O, {(v, (i, j + (v // 2) * 2))})  # Shift while painting
  return O
 
24.333333333333332, 20.447437, def dcgdcehcafhiefgbjhcbfefjiceefcad(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w * 2))
  for i, row in enumerate(I):
    O = paint(O, frozenset({(v, (i, j + (v // 2) * 2)) for j, v in enumerate(row)}))
  return O
 
24.333333333333332, 20.611017, def ibafcbciegefecicjaebhccfbiachcgi(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w * 2))
  for obj in asobject(I):
    v, (i, j) = obj
    O = paint(O, {(v, (i, j + (v // 2) * 2))})
  return O
 
134.66666666666666, 59.75404, def gcbghcjfhaibeaafabifedcbefddhfbd(I):
  return tuple(
      tuple(v if k == j + (v // 2) * 2 else ZERO for k in range(2 * len(I[0])))
      for i, row in enumerate(I)
      for j, v in enumerate(row)
  )
 
9.666666666666666, 8.503605, def ddhbfgfjecffefegibjfhaabagdbhfba(I):
  # Transpose the grid to work with columns as rows.
  transposed_grid = rot90(I)  
  
  # Define a function to shift non-background values in a column (now a row).
  def shift_non_bg(row):
    bg_color = mostcommon(row)  
    non_bg_values = [v for v in row if v != bg_color]
    return [bg_color] * (len(row) - len(non_bg_values)) + non_bg_values 
  
  # Apply the shift to each row (originally a column).
  shifted_rows = apply(shift_non_bg, transposed_grid)
  
  # Transpose back to the original orientation.
  O = rot270(tuple(shifted_rows)) 
  return O
 
8.0, 6.6616554, def ajegaicdbcffehgcjbehacdccfaffcab(I):
  # Create a blank canvas.
  O = canvas(mostcolor(I), shape(I)) 
  
  # Iterate through each object.
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    # Calculate the shift offset for the object.
    offset = (0, width(I) - 1 - rightmost(obj))
    
    # Paint the shifted object onto the canvas.
    O = paint(O, shift(obj, offset))
  return O
 
8.0, 7.030962, def hbhgagifegggeccdadibadcafdgahafb(I):
  # Define a lambda function for shifting an object.
  shift_obj = lambda obj: shift(obj, (0, width(I) - 1 - rightmost(obj)))
  
  # Apply the shifting function to all non-background objects and merge them.
  shifted_objs = merge(apply(shift_obj, objects(I, univalued=False, diagonal=False, without_bg=True)))
  
  # Create the output grid by painting the shifted objects on a blank canvas.
  O = paint(canvas(mostcolor(I), shape(I)), shifted_objs)
  return O
 
4.0, 5.587217, def ahgfdhejidciebjjiffbdajjbciedbda(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    if c == THREE:
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif c == SIX:
      O = paint(O, shift(obj, (ZERO, width(I) - width(obj))))
    elif c == FOUR:
      O = paint(O, shift(obj, (height(I) - ONE, width(I) - width(obj))))
    elif c == EIGHT:
      O = paint(O, shift(obj, (ZERO, width(O) - width(obj))))
    elif c == TWO:
      O = paint(O, shift(obj, (THREE, width(O) - width(obj))))
    elif c == ONE:
      O = paint(O, shift(obj, (THREE, width(O) - ONE)))
    else:
      O = paint(O, obj)
  return O
 
4.0, 8.462875, def baiefadhjjgcejggjcdfbfegfijccbcb(I):
  # 1. Get objects, excluding background
  objs = objects(I, True, True, True)
  # 2. Sort objects based on upper-left corner 
  sorted_objs = order(objs, lambda obj: ulcorner(obj))
  # 3. Clear the grid and repaint in sorted order
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted_objs:
    O = paint(O, shift(obj, subtract(ulcorner(obj), ORIGIN)))
  return O
 
6.0, 31.043228, def dhfiaahdgaefegfbiefbhhbebebfgefa(I):
  bg = mostcolor(I)
  h, w = len(I), len(I[0])
  O = [[bg for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg:
        new_i, new_j = min(i for i in range(h) if I[i][j] == I[i][j]), min(j for j in range(w) if I[i][j] == I[i][j])
        O[new_i][new_j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
4.333333333333333, 7.4158726, def baedecfaafejeedfbafigicacaeafdcj(I):
  bg = mostcolor(I)
  shifted_objs = []
  for c in difference(palette(I), {bg}):
    indices = [(i, j) for i, r in enumerate(I) for j, v in enumerate(r) if v == c]
    min_i, min_j = min(i for i, j in indices), min(j for i, j in indices)
    shifted_obj = [(c, (i - min_i, j - min_j)) for i, j in indices]
    shifted_objs.append(shifted_obj)
  O = canvas(bg, shape(I))
  for obj in shifted_objs:
    O = paint(O, obj)
  return O
 
10.333333333333334, 6.7677655, def cdiicdfcfechecadjdbdcabbacegjddi(I):
  O = canvas(mostcolor(I), shape(I))
  occupied_columns = set() # Keep track of occupied columns
  for c in sorted(palette(I)):
    objs = sizefilter(objects(I, T, T, T), colorcount(I, c))
    target_j = width(I) - 1
    for obj in objs:
      while target_j in occupied_columns: # Find the first unoccupied column from right to left
        target_j -= 1
      O = paint(O, shift(obj, (0, target_j - leftmost(obj))))
      occupied_columns.update(range(target_j, target_j + width(obj))) # Mark used columns
  return O
 
9.666666666666666, 22.899496, def gbddcbdeeffbefcbacacbeajahddffbf(I):
    O = canvas(ZERO, shape(I))
    for v in palette(I) - {mostcolor(I)}:  # Iterate over colors except background
        obj = toobject(ofcolor(I, v), I)
        offset = (0, -colorcount(I, v) + 1)  # Calculate left shift based on color count
        O = paint(O, shift(obj, offset))
    return O
 
10.666666666666666, 7.3480597, def eebcbaifdefbecibachbcfbaecbdedae(I):
    new_grid = []
    for row in I:
        non_zeros = [v for v in row if v != 0]  # Extract non-zero digits
        zeros = [0 for _ in range(len(row) - len(non_zeros))]  # Create padding zeros
        new_grid.append(tuple(non_zeros + zeros))  # Combine and append to new grid
    return tuple(new_grid)
 
34.0, 25.850704, def hjcafbaihiadeibcaidaghcbdbiehfia(I):
    h, w = shape(I)
    O = canvas(ZERO, (h, w))
    for v in palette(I) - {mostcolor(I)}:
        obj = toobject(ofcolor(I, v), I)
        obj_width = width(obj)
        sub_grid = crop(I, (0, 0), (h, obj_width))  # Crop a subgrid with the object's width
        O = hconcat(O, sub_grid)  # Concatenate to the output grid
    return O
 
10.0, 8.747988, def fgaahecdjfieegdgjadadcbheaffjahb(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    row_obj =  frozenset((I[i][j], (i, j)) for j in range(width(I)) if I[i][j] != mostcolor(I))
    O = paint(O, shift(row_obj, (0, width(I) - 1 - rightmost(toindices(row_obj))))) 
  return O
 
7.0, 38.56502, def idgaahfficdbedgbiacihedcdbfhieab(I):
  O = list(list(row) for row in I) # Create a mutable copy of I
  for i in range(height(I)):
    for j in range(width(I)):
      if O[i][j] != mostcolor(I):
        O[i][width(I)-1] = O[i][j]
        O[i][j] = mostcolor(I) 
  return tuple(tuple(row) for row in O)  # Convert back to immutable tuples 
 
9.333333333333334, 8.258773, def idcadecgdejceddeaadcifeiehdfjhdd(I):
  O = []
  for row in I:
    new_row = [v for v in row if v == mostcolor(I)] + [v for v in row if v != mostcolor(I)]
    O.append(tuple(new_row))
  return tuple(O)
 
7.666666666666667, 6.4070663, def hifaddfabccdeeebjfjbjacbagbcedaa(I):
    return tuple(
        tuple(
            v if j != width(I) - 1 else next((x for x in row[::-1] if x != mostcolor(I)), mostcolor(I))
            for j, v in enumerate(row)
        )
        for row in I
    )
 
5.666666666666667, 4.7223887, def deaaijadeacdedbejfebgdbfbeabcdfg(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (0, width(obj))))
    elif len(objs) == 4 and c == 6:
      O = paint(O, shift(obj, (0, 2)))
    elif len(objs) == 4 and c == 4:
      O = paint(O, shift(obj, (1, 2)))
    elif len(objs) == 5 and c == 8:
      O = paint(O, shift(obj, (0, 1)))
    elif len(objs) == 5 and c == 2 and uppermost(obj) == 1:
      O = paint(O, shift(obj, (0, 1)))
    elif len(objs) == 5 and c == 2 and uppermost(obj) == 3:
      O = paint(O, shift(obj, (0, 2)))
    else:
      O = paint(O, obj)
  return O 
 
8.333333333333334, 10.04031, def chbhddbcfcheegjgbhccegeddccafcfb(I):
  objs = order(fgpartition(I), lambda obj: -color(obj))
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  x, y = 0, 0
  for obj in objs:
    O = paint(O, shift(obj, (x, y)))
    y += width(obj)
  return O
 
8.666666666666666, 17.571365, def faiachhjdegcebdbieghcfaafjhdgddh(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    pos = position(obj, asindices(I))
    if pos == (0, -1):
      O = paint(O, shift(obj, (0, width(obj))))
    elif pos == (1, -1):
      O = paint(O, shift(obj, (1, width(obj))))
    elif pos == (-1, -1) and len(objs) == 5:
      O = paint(O, shift(obj, (0, width(obj) + 1)))
    else:
      O = paint(O, shift(obj, (0, width(obj))))
  return O
 
5.333333333333333, 4.395121, def ddjiecbfdfcfeebfacgfddceiajaabdc(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and adjacent(obj1, obj2):
        direction = gravitate(obj1, obj2)
        O = paint(O, shift(obj1, direction))
  return O
 
10.0, 8.862689, def dbdbeebfcfjhebffijafjfigabchfdae(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  offset = 0
  for obj in objs:
    O = paint(O, shift(obj, (0, offset)))
    offset += width(obj)
  return O
 
3.0, 11.498762, def eehbbajdecaiejfdihhdddhbbaecdddh(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))  
  objs = sorted(objects(I, True, True, True), key=lambda obj: (uppermost(obj), leftmost(obj)))
  offset = (0, 0)
  for obj in objs:
    O = paint(O, shift(normalize(obj), offset))
    offset = (offset[0] + height(obj), offset[1])
  return O
 
5.333333333333333, 4.6740265, def aefebedbidabefdhbabdjiechdagbied(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != bg:
        O = paint(O, {(v, (i, j - leftmost(ofcolor(I, v))))}) 
  return O
 
2.6666666666666665, 2.555308, def ecjiahbhagiaedaiaidaacaffedieeid(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    O = paint(O, shift(obj, (-uppermost(obj), -leftmost(obj) + uppermost(obj))))
  return O
 
5.0, 7.7893467, def iecfacaajffdehfebfdhebadicbiaddd(I):
  bg = mostcolor(I)
  h, w = shape(I)
  O = canvas(bg, (h, w))
  used = set()
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != bg and (i, j) not in used:
        obj = toobject(ofcolor(I, v), I)
        O = paint(O, shift(obj, (-i, -j)))
        used |= toindices(obj)
  return O
 
3.6666666666666665, 5.519764, def ahjbdgfecdabejdbbidgbaegehceafea(I):
  O = I
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = height(I) - 2 if c == 3 else 0 if c in (2, 8, 6) else height(I) - size(obj) 
      target_j = width(I) - width(obj) if c != 4 else width(I) - size(obj) 
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj))) 
  return O
 
4.0, 5.4142556, def feadhecbdddbeciebjbgjbafcbigecde(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    target_i = height(I) - 2 if c == 3 else 0 if c in (2, 8, 6) else height(I) - size(obj)
    target_j = width(I) - width(obj) if c != 4 else width(I) - size(obj)
    O = paint(cover(O, obj), shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj))))
  return O
 
10.0, 10.100697, def cacfecfdchhieeegjeibaidabdededff(grid):
    h, w = len(grid), len(grid[0])
    new_grid = canvas(0, (h, w))
    for j in range(w):
        column = tuple(grid[i][j] for i in range(h))
        new_column = tuple(v for v in column if v != 0) + tuple(0 for _ in range(column.count(0)))
        for i in range(h):
            new_grid = fill(new_grid, new_column[i], {(i, j)})
    return new_grid
 
5.0, 6.2748165, def abacbecghbfgeedgbebfceebchcaidga(grid):
    h, w = len(grid), len(grid[0])
    return tuple(
        tuple(
            sorted((grid[i][j] for i in range(h)), key=lambda x: x!=0)
        ) for j in range(w)
    )
 
6.0, 4.9245906, def ccgfcbfcafgfeebbaabbaegaebcfagcb(I):
    O = canvas(0, shape(I))
    for j in range(width(I)):
        column = [I[i][j] for i in range(height(I))]
        non_zeros = [v for v in column if v != 0]
        k = 0
        for i in range(height(I)):
            if column[i] != 0:
                O = fill(O, non_zeros[k], {(i, j)})
                k += 1
    return O
 
12.666666666666666, 40.33577, def bjabdbdidggeeffhicjbdejebdddgbba(grid):
    h, w = shape(grid)
    return tuple(
        tuple(
            next(v for v in (grid[i][j] for i in range(h)) if v != 0) 
            if any(grid[i][j] != 0 for i in range(h)) 
            else 0 
            for j in range(w)
        ) for i in range(h)
    )
 
7.333333333333333, 23.079165, def bfdgiicejjhcecfhbeddaebcfejbhabc(I):
    O = canvas(mostcolor(I), shape(I))
    for i in range(height(I)):
        row_objs = sfilter(objects(crop(I, (i, 0), (1, width(I))), univalued=False, diagonal=False, without_bg=True), lambda obj: len(obj) > 0)
        for obj in row_objs:
            O = paint(O, shift(obj, (0, width(I) - 1 - rightmost(toindices(obj)))))
    return O
 
8.333333333333334, 17.693707, def bdaebcgjaaaieeffbfahajbcdgabdiab(I):
    O = I
    for j in range(width(I)-1, -1, -1):
        for i in range(height(I)):
            if index(I, (i,j)) != mostcolor(I):
                O = move(O, {(index(I, (i,j)), (i,j))}, (0, width(O) - 1 - j))
    return O
 
11.0, 6.712414, def bfghajfedhfdecehafibhbbciffgfbib(I):
    shifted_cells = set()
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != mostcolor(I):
                shifted_cells.add((val, (i, width(I) - 1 - j)))
    return paint(canvas(mostcolor(I), shape(I)), frozenset(shifted_cells))
 
5.0, 4.9895997, def aeiccbeegfdjehcfabihajcgcdbabaib(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(objects(I, univalued=True, diagonal=False, without_bg=True), key=lambda x: uppermost(x)):
    c = color(obj)
    j = leftmost(obj)
    for i in range(uppermost(obj), len(I)):
      if O[i][j] == bg:
        O = paint(O, {(c, (i, j))})
        break
  return O
 
10.0, 10.100697, def fcgffcefeibgegefbffffahhddegbadd(I):
  bg = mostcolor(I)
  h, w = shape(I)
  O = canvas(bg, (h, w))
  for j in range(w):
    top = 0
    for i in range(h):
      c = I[i][j]
      if c != bg and O[top][j] == bg:
        O = paint(O, {(c, (top, j))})
        top += 1
  return O
 
4.666666666666667, 5.3835, def gfccejddafiaeddaiedacedbiadadgff(I):
  O = I
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = uppermost(obj)
      target_j = width(I) - width(obj) if c != 3 else width(I) - size(obj)
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
3.6666666666666665, 10.289518, def caciiheacaadejjaacfdcbdafifgfcbe(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    for obj in objects(I, T, T, T):
      if color(obj) != c: 
        continue
      target_i = uppermost(obj) if c != 3 else height(I) - size(obj)
      target_j = width(I) - width(obj)
      O = paint(O, shift(obj, (target_i, target_j)))
  return O
 
4.0, 5.099488, def efddedbadiicecfcabdicicabiddeeab(I):
  O = I
  for c in palette(I):
    objs = [obj for obj in objects(I, T, T, T) if color(obj) == c]
    objs = sorted(objs, key=lambda obj: -uppermost(obj))
    for obj in objs:
      target_i = uppermost(obj) if c != 3 else height(I) - size(obj) - len(objs) + 1
      target_j = width(I) - width(obj)
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
4.333333333333333, 4.124089, def hchefcbjeeededfbjjhdabgeacadacfj(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    offset = (0, color(obj) - FIVE)
    O = paint(O, shift(obj, offset))
  return O
 
8.333333333333334, 19.86858, def bbigaecbcbifecfejffeehbcgifefiha(I):
    # Create a blank canvas with the same shape as the input grid, filled with the background color.
    O = canvas(mostcolor(I), shape(I))
    # Iterate through each unique color in the input grid, excluding the background color.
    for v in palette(I) - {mostcolor(I)}:
        # Identify the indices of cells containing the current color.
        indices = ofcolor(I, v)
        # Find the uppermost row index for the current color.
        row = uppermost(indices)
        # Shift the color to the rightmost column of the identified row.
        shifted_color = shift(recolor(v, {(row, 0)}), (0, width(I) - 1))
        # Paint the shifted color onto the canvas.
        O = paint(O, shifted_color)
    return O
 
8.0, 20.165361, def fhcabgachdfdefhejhgbdhfabjjcachb(I):
    # Create a blank canvas with the same dimensions as the input, filled with the background color
    O = canvas(mostcolor(I), shape(I))
    # Iterate over each row of the input grid
    for i, row in enumerate(I):
        # Iterate over each unique digit in the row
        for v in set(row):
            # Find all occurrences of the digit in the row
            occurrences = frozenset((i, j) for j, value in enumerate(row) if value == v)
            # Shift the occurrences to the rightmost column
            shifted_occurrences = shift(recolor(v, occurrences), (0, width(I) - 1 - rightmost(occurrences)))
            # Paint the shifted occurrences onto the output grid
            O = paint(O, shifted_occurrences)
    # Return the modified output grid
    return O
 
4.333333333333333, 5.2404494, def gfgigfacaibhedfabebbifcfjijecehc(I):
    # Get a set of all unique colors in the input, excluding the most common color
    colors = palette(I) - {mostcolor(I)}
    # Create a list to store shifted objects
    shifted_objs = []
    # Iterate over each color
    for color in colors:
        # Find the indices of the current color
        indices = ofcolor(I, color)
        # Shift the color to the rightmost position
        shifted_indices = shift(indices, (0, width(I) - 1 - rightmost(indices)))
        # Recolor the shifted indices and add them to the list
        shifted_objs.append(recolor(color, shifted_indices))
    # Paint all shifted objects onto a canvas filled with the most common color
    return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
 
8.333333333333334, 17.661453, def jiceggfbaacfebfcjecgggfdfdhfjdei(I):
  # Create a blank canvas with the same dimensions as the input grid
  O = canvas(mostcolor(I), shape(I))
  # Iterate through each non-background color in the input grid
  for v in palette(I) - {mostcolor(I)}:
    # Find the indices of cells with the current color
    cells = ofcolor(I, v)
    # Group the cells by row index
    rows = {}
    for i, j in cells:
      if i not in rows:
        rows[i] = []
      rows[i].append(j)
    # For each row, create a shifted object containing all occurrences of the color
    for i, js in rows.items():
      shifted_obj = recolor(v, {(i, j) for j in js})
      shifted_obj = shift(shifted_obj, (0, width(I) - 1 - max(js)))
      # Paint the shifted object onto the output grid
      O = paint(O, shifted_obj)
  # Return the modified output grid
  return O
 
4.0, 7.723182, def deceaibheadieccibbfgafiecdfceced(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (0, 1)))  # Move '3' one position right
    elif c == 6:
      O = paint(O, shift(obj, (0, 2)))  # Move '6' two positions right
    elif c == 4:
      O = paint(O, shift(obj, (2, 3)))  # Move '4' to the bottom right
    elif c == 8:
      O = paint(O, shift(obj, (0, 2)))  # Move '8' two positions right
    elif c == 2:
      if uppermost(obj) == 1:
        O = paint(O, shift(obj, (1, 3)))  # Move top '2'
      else:
        O = paint(O, shift(obj, (2, 3)))  # Move bottom '2'
    elif c == 1:
      O = paint(O, shift(obj, (3, 4)))  # Move '1' to the bottom right
    else:
      O = paint(O, obj)
  return O 
 
6.666666666666667, 6.0232816, def eiahcgagiachebjhbiifjefbibiabded(I):
  h, w = shape(I)
  bg = mostcolor(I)
  parts = [list(obj) for obj in fgpartition(I)]
  parts.sort(key=lambda x: color(x))
  # Reconstruct grid with digits in new positions based on analysis
  O = canvas(bg, (h, w))
  if w == 4:
      O = paint(O, frozenset(parts[0] +  [(5, (0, 1))] + parts[1] + parts[2]))
      O = paint(O, frozenset([(5, (1, 1))]))
      O = paint(O, frozenset([(5, (2, 3))]))
      O = paint(O, frozenset([(5, (3, 3))]))
  elif h == 3:
      O = paint(O, frozenset(parts[0] + [(5, (0, 1))] + parts[1]))
      O = paint(O, frozenset([(5, (1, 1))]))
      O = paint(O, frozenset([(5, (2, 2))]))
  elif h == 5:
      O = paint(O, frozenset(parts[0] + [(5, (0, 1))] + parts[1] + [(5, (1, 3))] + parts[2] + parts[3]))
      O = paint(O, frozenset([(5, (2, 2))]))
      O = paint(O, frozenset([(5, (3, 3))]))
      O = paint(O, frozenset([(5, (4, 4))]))
  return O
 
8.333333333333334, 6.608111, def bcdbceefbbfdebbcahebjaghiahhaeah(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    i, j = ulcorner(obj)
    new_j = (c + j) % width(I)  # Calculate new column using modulo
    O = paint(O, shift(obj, (0, new_j - j)))  # Shift to new column
  return O
 
9.0, 8.261154, def afdbbachehcfebjejaagcbecjedagcei(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    if c == 6:
      O = paint(O, shift(obj, (0, width(I)-width(obj))))
    elif c == 2 or c == 4 or c == 1:
      O = paint(O, shift(obj, (0, width(I)-1)))
    else:
      O = paint(O, shift(obj, (0, 1)))
  return O
 
9.666666666666666, 6.0810385, def ceicahjedfdeefedaejaichehffccgbh(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, False, False, True):
    c = color(obj)
    if c == 6:
      O = paint(O, shift(obj, (0, width(I)-width(obj))))
    elif c in {2, 4, 1}:
      O = paint(O, shift(obj, (0, rightmost(obj) - leftmost(obj) + width(I)-rightmost(obj)-1)))
    else:
      O = paint(O, shift(obj, (0, 1)))
  return O
 
9.333333333333334, 7.289864, def ceaejdjaabdeeeeeaeefjdebcbedaede(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    if c == 6:
      O = paint(O, shift(obj, (0, width(I) - rightmost(obj) + leftmost(obj) - 1)))
    elif c in {2, 4, 1}:
      target_column = width(I) - len([1 for x in difference(palette(I), {bg}) if x in {2, 4, 1}]) + list({2, 4, 1}).index(c)
      O = paint(O, shift(obj, (0, target_column - leftmost(obj))))
    else:
      O = paint(O, shift(obj, (0, 1)))
  return O
 
9.666666666666666, 6.9076653, def cedbdibgdhdbebeiaedhgheedfeecifd(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(objects(I, False, False, True), key=lambda x: color(x)):
    c = color(obj)
    if c == 6:
      O = paint(O, shift(obj, (0, width(I)-width(obj))))
    elif c in {2, 4, 1}:
      O = paint(O, shift(obj, (0, width(I)-1)))
    else:
      O = paint(O, shift(obj, (0, 1)))
  return O
 
8.0, 9.300635, def cihgjbdaieaaejdcifddebjjfajbcede(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    c = color(obj)
    direction = {
        5: UP_RIGHT,
        3: RIGHT,
        6: RIGHT,
        8: UP,
        2: UP
    }.get(c, ORIGIN)  # Default to no movement if color not specified
    
    temp_obj = shift(obj, direction)
    while not len(intersection(toindices(temp_obj), toindices(asobject(O)))) and not bordering(temp_obj, O):
      obj = temp_obj
      temp_obj = shift(obj, direction)

    O = paint(O, obj)
  return O
 
6.0, 4.9245906, def hjgabdffhfgcejfcbcbdicadibabddfb(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    direction = {
        5: (-1, 1),
        3: (0, 1),
        6: (0, 1),
        8: (-1, 0),
        2: (-1, 0)
    }.get(c, (0, 0))
    for _ in range(max(shape(I))):
        obj = toobject(ofcolor(O, c), O)
        if bordering(obj, O):
          break
        O = paint(cover(O, obj), shift(obj, direction))
  return O
 
7.666666666666667, 19.683231, def jecaeghbcbbfedfejghdbfafhjgbgefa(I):
  objs = sorted(fgpartition(I), key=lambda obj: (color(obj), uppermost(obj)))
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  target_columns = {3: 1, 6: 2, 4: 3, 8: 2, 2: 4, 1: 4} 
  for obj in objs:
    c = color(obj)
    if c in target_columns:
      target_col = target_columns[c]
      O = paint(O, shift(obj, (0, target_col - leftmost(obj)))) 
  return O
 
8.333333333333334, 8.762203, def efdeadegefdaecaaibfhhbcefbeddhca(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    offset = (0, (c - 1) % width(I) - leftmost(obj)) # Calculate offset based on color
    O = paint(O, shift(obj, offset))
  return O
 
7.666666666666667, 21.410927, def eeadjbjdejddedcaihgaibcdadaagaac(I):
  objs = sorted(fgpartition(I), key=lambda obj: -uppermost(obj))
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  current_columns = {i: 0 for i in range(1, 9)}
  target_columns = {3: 1, 6: 2, 4: 3, 8: 2, 2: 3, 1: 4} 
  for obj in objs:
    c = color(obj)
    if c in target_columns:
      target_col = target_columns[c]
      offset = (0, target_col - current_columns[c])
      O = paint(O, shift(obj, offset))
      current_columns[c] += 1
  return O
 
8.333333333333334, 9.497052, def eahccdhicedeecfbiafdgajgdediidfb(I):
    objs = fgpartition(I)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    for obj in objs:
        c = color(obj)
        target_col = (c // 2 + (c % 2) * 2) % width(I)  # Calculate target column
        O = paint(O, shift(obj, (0, target_col - leftmost(obj))))
    return O
 
7.666666666666667, 25.0938, def cdfeebgehiefeeghbggjdbffcgjgbffi(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    O = paint(O, shift(obj, (-uppermost(obj), -leftmost(obj)))) 
  return O
 
7.666666666666667, 20.682558, def ejibiejbdehheeebjddbfgbhababaaha(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    for i in range(h):
      if I[i][j] != mostcolor(I):
        O = paint(O, {(I[i][j], (0, j))})
        break
  return O
 
8.666666666666666, 13.894304, def bdcbheajfccgeiafbffdaejafjjeabeb(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(objects(I, univalued=True, diagonal=False, without_bg=True), key=lambda x: leftmost(x)):
    O = paint(O, shift(obj, (-uppermost(obj), 0)))
  return O
 
8.0, 18.833662, def gfgegfbaacccebifagafedbeecjfiiaj(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for j in range(len(I[0])):
    target_cell = extract(asobject(I), lambda x: x[1][1] == j and x[0] != bg)
    if target_cell:
      O = paint(O, {(target_cell[0], (0, j))})
  return O
 
7.333333333333333, 17.805815, def aebddcgffaabecdaaccffbggdifjieea(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  occupied_cols = set()
  for obj in sorted(objects(I, univalued=True, diagonal=False, without_bg=True), key=lambda x: (leftmost(x), uppermost(x))):
    c = color(obj)
    j = leftmost(obj)
    while j in occupied_cols:
      j += 1
    O = paint(O, {(c, (0, j))})
    occupied_cols.add(j)
  return O
 
8.666666666666666, 15.163571, def abdehieagdbfeebfaeebeacfdfbddjba(I):
  O = canvas(ZERO, shape(I))  # Create blank canvas
  colors = sorted(palette(I))  # Get sorted list of colors
  for i, v in enumerate(colors):
    obj = toobject(ofcolor(I, v), I)  # Get object of current color
    O = paint(O, shift(obj, (0, i)))  # Shift based on color index
  return O
 
10.333333333333334, 6.3814807, def gcdbbeefagahehhfiiebaafhgfacgjbb(I):
  objects_list = sorted(objects(I, T, T, T), key=lambda x: color(x))  # Sorted objects
  O = canvas(ZERO, shape(I))
  for i, obj in enumerate(objects_list):
    O = paint(O, shift(obj, (0, i)))
  return O
 
6.0, 5.0727944, def jbhhbeabbafcebfbjdchffaegdbdjifj(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    direction = {
        8: UP,
        2: UP,
        3: RIGHT,
        6: RIGHT
    }.get(c, ORIGIN)
    obj = toobject(ofcolor(O, c), O)
    temp_obj = shift(obj, direction)
    while not len(intersection(toindices(temp_obj), toindices(asobject(O)))) and not bordering(temp_obj, O):
      obj = temp_obj
      temp_obj = shift(obj, direction)
    O = paint(cover(O, obj), temp_obj)
  return O
 
6.666666666666667, 6.3501105, def acfgefihbdfgebgeadcggaciafdffdda(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), O)
    direction = {
        8: UP,
        2: UP,
        3: RIGHT,
        6: RIGHT
    }.get(c, ORIGIN)
    while True:
      shifted_obj = shift(obj, direction)
      if any(index(O, loc) != mostcolor(O) for loc in toindices(shifted_obj)):
        break
      obj = shifted_obj
    O = paint(cover(O, obj), obj)
  return O
 
6.0, 4.872484, def ecdcjffgaeddeeeebbbebiicaaegciac(I):
    O = I
    for c in palette(I) - {mostcolor(I)}:
        direction = {
            8: UP,
            2: UP,
            3: RIGHT,
            6: RIGHT
        }.get(c, ORIGIN)
        indices = ofcolor(O, c)
        new_indices = set()
        for i, j in indices:
            ni, nj = i, j
            while 0 <= ni + direction[0] < len(I) and 0 <= nj + direction[1] < len(I[0]) and O[ni + direction[0]][nj + direction[1]] == mostcolor(O):
                ni += direction[0]
                nj += direction[1]
            new_indices.add((ni, nj))
        O = paint(cover(O, recolor(c, indices)), recolor(c, frozenset(new_indices)))
    return O
 
4.333333333333333, 6.1612716, def dbiecjddbgjceecaaiceidbachgcdaea(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 3:
      O = paint(O, shift(obj, (0, 1)))
    elif color(obj) == 6:
      O = paint(O, shift(obj, (0, 2)))
    elif color(obj) == 4:
      O = paint(O, shift(obj, (0, 1)))
    elif color(obj) == 8:
      O = paint(O, shift(obj, (0, 2)))
    elif color(obj) == 2:
      O = paint(O, shift(obj, (0, 3)))
    else:
      O = paint(O, obj)
  return O
 
4.666666666666667, 5.507423, def dedjbdagddegegjajeccididaaedebie(I):
  def shift_amount(c):
    return (c == 6 or c == 8) + (c == 2) * 2 + (c == 3 or c == 4) 
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (0, shift_amount(color(obj)))))
  return O
 
8.333333333333334, 25.165314, def efichaiccgjdehdeafffdijacadcaeif(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    O = paint(O, shift(obj, (0, max(0, color(obj) - 2))))
  return O
 
7.666666666666667, 20.568316, def bideeiejdfjbeaecjjcdfgjaafacjeih(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    ul = ulcorner(obj)
    shift_offset = (-(ul[0] + 1), ul[0] + 1)
    shifted_obj = shift(obj, shift_offset)
    O = paint(O, shifted_obj)
  return O
 
10.333333333333334, 15.10895, def ffdaifcddgdbejcijcgfdhajdfffeggh(I):
  O = I
  for obj in fgpartition(I):
    if size(obj) > 1:
       upper_part = sfilter(obj, lambda cell: cell[1][0] <  centerofmass(obj)[0])
       lower_part = sfilter(obj, lambda cell: cell[1][0] >= centerofmass(obj)[0])
       O = paint(cover(O, upper_part), shift(upper_part, (-1, 1)))
       O = paint(cover(O, lower_part), shift(lower_part, (1, -1)))
  return O
 
8.333333333333334, 10.799939, def afefaaecaecbeddfjacabjeciahjfdcj(I):
  O = I
  for c in difference(palette(I), {mostcolor(I)}):
    obj = toobject(ofcolor(I, c), I)
    if size(obj) > 1:
      O = fill(O, c, shift(toindices(obj), (-1, 1)))
  return O
 
4.666666666666667, 4.860281, def cajajbjhfegdefgabicceeeaafdaccbg(I):
  O = I
  for obj in fgpartition(I):
    ul = ulcorner(obj)
    if ul[0] != 0 and ul[1] != 0:
      O = paint(cover(O, obj), shift(obj, (-1, 1)))
  return O
 
3.0, 11.498762, def dddbaiffheaeebghbbcgfacdceghfiag(I):
  O = I
  five_obj = extract(objects(I, T, T, T), lambda obj: color(obj) == 5)
  for c in sorted(palette(I) - {5}):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = uppermost(five_obj)
      target_j = rightmost(five_obj) + width(obj)
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
4.666666666666667, 3.7904403, def adabifdficejebbdadcdjjdadbdgeeic(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  ref_obj = toobject(ofcolor(I, FIVE), I) # Define reference object with color 5
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE: # Skip the reference object
      rel_pos = position(obj, ref_obj)[1] # Get relative horizontal position
      O = paint(O, shift(obj, (0, rel_pos * (color(obj) - FIVE)))) # Shift and paint
  O = paint(O, ref_obj) # Paint the reference object at the end
  return O 
 
10.0, 10.921168, def ehhdhfbahbdbeiiiiahefjceehabdhag(I):
  lh = lefthalf(I)  # Extract left half
  rh = righthalf(I)  # Extract right half
  return hconcat(lh, rh)  # Concatenate horizontally
 
7.333333333333333, 8.291244, def ghadfdjdeajgegbciacadhddiieafbbc(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(O, c), O)
    while True:
      shifted_obj = shift(obj, (0, 1))
      if any(index(O, loc) not in [c, mostcolor(O)] for loc in toindices(shifted_obj)):
        break
      obj = shifted_obj
      O = paint(cover(O, obj), obj)
  return O
 
8.0, 9.756446, def dcfhgacfbbfceiaabhhcaechehjhdbaf(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(O, c), O)
    distance = rightmost(asindices(O)) - rightmost(obj) 
    O = paint(cover(O, obj), shift(obj, (0, distance)))
  return O
 
10.333333333333334, 14.006951, def dejebeibfegdebicibfiebbafibhagje(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(O, c), O)
    distance = width(obj) - 1
    O = paint(cover(O, obj), shift(obj, (0, distance)))
  return O
 
6.0, 6.2994165, def bbbgdjdhaaijeefajcjjabjiefagaafd(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(O, c), O)
    for j in range(1, width(O)):
      shifted_obj = shift(obj, (0, j))
      if any(index(O, (i, j)) not in [c, mostcolor(O)] for i, j in toindices(shifted_obj)):
        break
      O = paint(cover(O, obj), shifted_obj)
  return O
 
8.666666666666666, 8.891777, def bbbgbdeafiidefbijggbaacidhhhejhf(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(O, c), O)
    wavefront = toindices(obj)
    while wavefront:
      next_wavefront = set()
      for i, j in wavefront:
        if j + 1 < width(O) and index(O, (i, j + 1)) == mostcolor(O):
          next_wavefront.add((i, j + 1))
      if not next_wavefront:
        break
      O = fill(O, c, next_wavefront)
      wavefront = next_wavefront
  return O
 
8.666666666666666, 26.059216, def dfeacabgdajcecbaiefdcbbahjjdigee(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  
  for obj in objs:
    c = color(obj)
    shift_amount = c - 1  # Shift amount determined by color
    O = paint(O, shift(obj, (0, shift_amount)))

  return O 
 
9.333333333333334, 5.3904853, def hcfgiidhiegaebicjdidehdaafdbeecd(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))

  for obj in objs:
    shift_amount = sum([1 for other_obj in objs if color(other_obj) > color(obj) and hmatching(obj, other_obj)])
    O = paint(O, shift(obj, (0, shift_amount))) 

  return O
 
7.333333333333333, 36.343468, def ehbcedhbdecheefgjfbcigabbdddaeda(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = I  # Start with the input grid

  for obj in objs:
    c = color(obj)
    shift_amount = c - 1
    temp_grid = cover(O, obj) # Temporarily remove the object 
    temp_grid = paint(temp_grid, shift(obj, (0, shift_amount)))
    O = cellwise(O, temp_grid, bg) # Combine with original, prioritizing non-background cells 

  return O
 
10.333333333333334, 6.2822094, def afgibfcajgdgejgcbjgbdfdccdfaaeda(I):
  """
  Utilizes the 'objects' function to move digits based on their color.
  """
  O = canvas(mostcolor(I), shape(I))
  for c in palette(I):
    for obj in objects(I, True, False, False):
      if color(obj) == c:
        if c == 8:
          O = paint(O, shift(obj, (1, 1)))
        else:
          O = paint(O, shift(obj, (0, 1)))
  return O
 
8.0, 25.880716, def efddaedddbdceaaajeafagafdbgcefcb(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    if colorcount(obj, c) == 1:
      O = paint(O, shift(obj, (0, width(I) - width(obj) - leftmost(obj))))
    else:
      obj_parts = objects(subgrid(obj, I), univalued=True, diagonal=False, without_bg=False)
      for part in obj_parts:
        O = paint(O, shift(part, (0, width(I) - width(part) - leftmost(part))))
  return O
 
4.333333333333333, 5.901666, def decgdcfehbcfefbajehhhhfihiaafcid(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  objs = fgpartition(I)
  for obj in objs:
    O = paint(O, shift(obj, (0, width(I) - width(obj) - leftmost(obj))))
  return O
 
10.0, 10.697636, def gdbidcjeeadfefddjbaffehcjbbfahac(I):
  O = canvas(ZERO, shape(I))
  for j in range(width(I)):
    column = tuple(I[i][j] for i in range(height(I)))
    non_fives = tuple(v for v in column if v != FIVE)
    k = 0
    for i in range(height(I)):
      if k < len(non_fives):
        O = paint(O, {(non_fives[k], (i, j))})
        k += 1
      else:
        O = paint(O, {(FIVE, (i, j))})
  return O
 
7.666666666666667, 14.340926, def cbcfeaifegifeeffbifedebchcjheeej(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, F):
    if color(obj) != FIVE:
      j = ulcorner(obj)[1]
      O = paint(O, shift(obj, (-uppermost(obj), 0)))
      O = paint(fill(O, FIVE, ((0, j), (uppermost(obj), j))), toobject(shoot((0, j), DOWN), I))
  return O
 
8.0, 21.722513, def bjdhdcebeaeeeeaaagigaadiadaefecf(I):
  O = I
  for j in range(width(I)):
    non_fives = tuple(I[i][j] for i in range(height(I)) if I[i][j] != FIVE)
    O = paint(O, recolor(ZERO, toobject(shoot((0, j), DOWN), I)))
    for i, v in enumerate(non_fives):
      O = paint(O, {(v, (i, j))})
  return O
 
10.333333333333334, 15.043364, def gdeddfaaajbgefdgjgjedbbbabbffjcc(I):
  O = canvas(ZERO, shape(I))
  for j in range(width(I)):
    values = tuple(I[i][j] for i in range(height(I)))
    fives = values.count(FIVE)
    O = paint(O, {(v, (i, j)) for i, v in enumerate(values) if v != FIVE})
    O = paint(O, {(FIVE, (i + height(I) - fives, j)) for i in range(fives)})
  return O
 
10.0, 7.335802, def hcfaabcffiafedfbafafchecaajjcbgf(I):
  O = I  
  for obj in objects(I, True, True, True): 
    row_index = uppermost(obj)  
    for j in range(width(I)): 
      if index(O, (row_index, j)) == mostcolor(I):
        O = paint(cover(O, obj), shift(obj, (0, j - leftmost(obj)))) 
        break  
  return O
 
7.0, 38.56502, def acbeeedfifddebffjbbjffabgddfcggd(I):
  O = canvas(mostcolor(I), shape(I))  
  for j in range(width(I)):  
    column_objects = [obj for obj in objects(I, True, True, True) if j in set(index for _, index in obj)] 
    for i, obj in enumerate(column_objects):
      target_j = next((k for k in range(j) if index(O, (uppermost(obj), k)) == mostcolor(I)), j) 
      O = paint(O, shift(obj, (0, target_j - j)))  
  return O
 
5.333333333333333, 4.7969365, def dbfbbeiedbeiegfbaedabfcefeccddih(I):
    O = canvas(mostcolor(I), shape(I))
    sorted_objs = sorted(objects(I, True, True, True), key=lambda obj: leftmost(obj))
    for obj in sorted_objs:
        row = uppermost(obj)
        target_j = next((j for j in range(width(I)) if index(O, (row, j)) == mostcolor(I)), width(I))
        O = paint(O, shift(obj, (0, target_j - leftmost(obj))))
    return O
 
9.333333333333334, 16.296976, def deicdicbccebeadebgdfdecdedabcfea(I):
  O = I
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i =  c - THREE if c < SIX else c - FOUR
      target_j = width(I) - width(obj)
      O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
10.0, 12.106644, def hfdahbejceefecidibdfcbcedabiefcb(I):
  O = canvas(ZERO, shape(I))
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      target_i = c - THREE if c < SIX else c - FOUR
      O = paint(O, shift(obj, (target_i - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
  return O
 
9.0, 16.221619, def ebagaebchhicecbbjcdbjebgeahfaeca(I):
  O = I
  for i, c in enumerate(sorted(palette(I))):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      O = move(O, obj, (i - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
  return O
 
9.333333333333334, 11.376993, def bfddbgffebheeecfjbjccceigfcddhge(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I) - {mostcolor(I)}:
    indices = sorted(ofcolor(I, v), key=lambda x: (x[1], x[0]))
    for k, (i, j) in enumerate(indices):
      O = move(O, {(v, (0, k))}, (i, j))
  return O
 
7.666666666666667, 29.805277, def dajgfhdfecjiedabjdieddgcehfdcdge(I):
    O = I
    for obj in objects(I, True, False, True):
        v = color(obj)
        target_index = sum(colorcount(I, v) for c in palette(I) if c < v)
        O = move(cover(O, obj), obj, (-uppermost(obj) + target_index, 0))
    return O
 
5.0, 5.975891, def ceggeeeaihceegdeaafaadjfffgahfie(I):
  O = I
  for j in range(width(O)):
    for i in range(1, height(O)):
      if O[i][j] != mostcolor(O) and O[i - 1][j] == mostcolor(O):
        v = O[i][j]
        k = next((x for x in range(i) if O[x][j] != mostcolor(O)), i)
        O = move(O, {(v, (i, j))}, (-i + k, 0))
  return O
 
4.666666666666667, 6.110629, def ifbfaahcjffceadiifcjahidacdhcjbj(I):
  O = I
  for color in sorted(palette(I) - {FIVE}):
    for obj in colorfilter(objects(I, T, T, F), color):
      O = paint(cover(O, obj), shift(obj, (0, width(I) - rightmost(obj) - 1)))
  return O
 
7.0, 36.215984, def ifbfeafeiedaecdhahabgcahfdbhadfe(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    column = frozenset((I[i][j], (i, j)) for i in range(height(I)))
    if any(v != FIVE for v, _ in column):
      obj = next(obj for obj in objects(I, T, T, F) if any((i, j) in toindices(obj) for i in range(height(I))))
      O = paint(O, shift(obj, (0, width(I) - rightmost(obj) - 1)))
  return O
 
3.6666666666666665, 7.517865, def dhgdechjdcejejcabfchdcehifcbjefe(I):
  O = canvas(mostcolor(I), shape(I))
  non_fives = sorted(((color(obj), obj) for obj in objects(I, T, T, F) if color(obj) != FIVE), key=lambda x: x[0])
  for i, (_, obj) in enumerate(non_fives):
    O = paint(O, shift(obj, (0, i)))
  return paint(O, toobject(ofcolor(I, FIVE), I))
 
5.666666666666667, 11.501034, def cihddegjacadefjcbffbghfaaeeajejc(I):
  O = I
  for i in range(height(I)):
    row_objects = sorted(((color(toobject(frozenset({(I[i][j], (i, j))}), I)), toobject(frozenset({(I[i][j], (i, j))}), I)) for j in range(width(I)) if I[i][j] != FIVE), key=lambda x: x[0])
    for j, (_, obj) in enumerate(row_objects):
      O = paint(cover(O, obj), shift(obj, (0, j)))
  return O
 
5.333333333333333, 4.368971, def efcbbdcgdfgdejhdifbcccbbhcjebefa(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in sorted(objects(I, True, True, True), key=lambda obj: (uppermost(obj), leftmost(obj))):
        target_i = next((i for i in range(uppermost(obj) + 1) if all(index(O, (i, j)) == mostcolor(I) for j in range(leftmost(obj), rightmost(obj) + 1))), uppermost(obj))
        target_j = next((j for j in range(width(I)) if index(O, (target_i, j)) == mostcolor(I)), width(I))
        O = paint(O, shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj))))
    return O
 
5.333333333333333, 4.277412, def ghdgdadbecccebhjieaefifhgbhbiaed(I):
  O = I
  for c in sorted(palette(I)):
    objs = sizefilter(objects(I, T, T, T), colorcount(I, c))
    if len(objs) > 1:
      main_obj = extract(objs, lambda obj: size(obj) == max(size(o) for o in objs))
      for obj in difference(objs, {main_obj}):
        if c == 6:
          target_i = uppermost(main_obj) + height(main_obj) - height(obj)
          target_j = width(I) - width(obj)
        elif c == 8:
          target_i = uppermost(main_obj) 
          target_j = leftmost(main_obj) + width(main_obj)
        else:
          target_i = uppermost(main_obj)
          target_j = leftmost(main_obj) + width(main_obj) - width(obj)
        O = move(O, obj, (target_i - uppermost(obj), target_j - leftmost(obj)))
  return O
 
4.666666666666667, 4.469993, def aeecicbcfhdceagbaddadbdchadifddd(I):
  O = I
  for c in sorted(palette(I)):
    objs = order(objects(I, T, T, T), lambda obj: (-size(obj), uppermost(obj), leftmost(obj)))
    for i, obj in enumerate(objs):
      if i == 0:
        continue
      main_obj = objs[0]
      if c == 6:
        O = move(O, obj, (uppermost(main_obj) + height(main_obj) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
      elif c == 8:
        O = move(O, obj, (uppermost(main_obj) - uppermost(obj), leftmost(main_obj) + width(main_obj) - leftmost(obj)))
      else:
        O = move(O, obj, (uppermost(main_obj) - uppermost(obj), leftmost(main_obj) + width(main_obj) - width(obj) - leftmost(obj)))
  return O
 
4.666666666666667, 5.3458967, def cgahchfhcbgdecdjbdfbhcafhdgdgfej(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    if colorcount(I, c) > 1:
      main_obj = argmax(sizefilter(objects(I, T, T, T), colorcount(I, c)), size) 
      if c == 6:
        O = move(O, obj, (uppermost(main_obj) + height(main_obj) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
      elif c == 8:
        O = move(O, obj, (uppermost(main_obj) - uppermost(obj), leftmost(main_obj) + width(main_obj) - leftmost(obj)))
      else:
        O = move(O, obj, (uppermost(main_obj) - uppermost(obj), leftmost(main_obj) + width(main_obj) - width(obj) - leftmost(obj)))
  return O
 
5.333333333333333, 16.70062, def cbgbcccdjaheedjeiccjjfbcaejbfehe(I):
  O = I
  for j in range(width(I)):
    column_objects = objects(crop(O, (0, j), (height(O), 1)), T, T, F)
    sorted_objects = order(column_objects, lambda obj: color(obj))
    current_i = 0
    for obj in sorted_objects:
      O = cover(O, obj)
      O = paint(O, shift(obj, (current_i, j - leftmost(obj))))
      current_i += height(obj)
  return O
 
10.0, 10.231808, def dfafccjhfiafeabcaaigebcgejbcdfaf(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I) - 1, 0, -1):
      if O[i][j] != mostcolor(O) and O[i - 1][j] == mostcolor(O):
        v = O[i][j]
        k = i - 1
        while k >= 0 and O[k][j] == mostcolor(O):
          k -= 1
        O = move(O, {(v, (i, j))}, (-i + k + 1, 0))
  return O
 
9.666666666666666, 9.428309, def egbcibheacbheiecidecdghjfaafhacf(I):
    O = canvas(mostcolor(I), shape(I))
    for j in range(width(I)):
        column = [I[i][j] for i in range(height(I))]
        non_bg_colors = sorted(set(column) - {mostcolor(I)})
        i = 0
        for c in non_bg_colors:
            for k in range(column.count(c)):
                O = paint(O, {(c, (i, j))})
                i += 1
    return O
 
7.0, 4.7867513, def dchhdfffabhaefcijgacdaabegdfjaje(I):
    O = I
    for j in range(width(I)):
        column_objects = objects(crop(O, (0, j), (height(O), 1)), True, True, True)
        top_pos = 0
        for obj in sorted(column_objects, key=lambda obj: color(obj)):
            O = cover(O, obj)
            O = paint(O, shift(obj, (top_pos - uppermost(obj), j - leftmost(obj))))
            top_pos += height(obj)
    return O
 
10.666666666666666, 6.5281625, def aiejabjfbdfdeefjjdjaaiabgadjjicg(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(objects(I, True, False, True), key=lambda x: (-color(x), -width(x))):
    i, j = ulcorner(obj)
    new_j = width(I) - width(obj) - j
    O = paint(O, shift(obj, (0, new_j - j)))
  return O
 
7.666666666666667, 19.350302, def bcdafegaddebebffidefbjbbhafcdfja(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i in range(height(I)):
    row_objects = objects(crop(I,(i,0),(1,width(I))), True, False, True)
    sorted_objects = sorted(row_objects, key=lambda obj: (-color(obj), -width(obj)))
    offset = 0
    for obj in sorted_objects:
      O = paint(O, shift(obj, (0, offset)))
      offset += width(obj)
  return O
 
4.333333333333333, 5.764971, def edgfebaccfggeadejaahffjffeceacfi(I):
  O = I
  for color in sorted(palette(I)):
    obj = toobject(ofcolor(I, color), I)
    O = paint(cover(O, obj), shift(obj, (0, width(I) - rightmost(obj) - 1)))
  return O 
 
6.333333333333333, 5.539873, def cfgecefghfejecjdaecadeciafigcdce(I):
  O = I
  for i in range(height(I)):
    for color in sorted(palette(crop(I, (i,0), (1, width(I))))):
      obj = toobject(ofcolor(crop(I, (i,0), (1, width(I))), color), I)
      O = paint(cover(O, obj), shift(obj, (0, width(I) - rightmost(obj) - 1)))
  return O
 
4.0, 5.5872173, def eaejacdfefaeeiaebddgcdaaeffffeeh(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    row_objs = sfilter(objs, lambda obj: uppermost(obj) == i)
    for j in range(width(I)-1, -1, -1):
      for obj in sfilter(row_objs, lambda obj: rightmost(obj) == j):
        O = underpaint(O, shift(obj, (0, width(I) - rightmost(obj) - 1)))
  return O
 
8.333333333333334, 21.217775, def jahdbhfaifceedcfiaabdebbjdfhfedf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(objects(I, True, True, True), key=lambda obj: (uppermost(obj), leftmost(obj))):
    target_j = width(I) - 1 - sum(width(obj2) for obj2 in objects(I, True, True, True) if uppermost(obj2) <= uppermost(obj) and leftmost(obj2) > leftmost(obj)) 
    O = paint(O, shift(obj, (0, target_j - leftmost(obj))))
  return O
 
8.333333333333334, 24.150913, def bfgadjggdbaheecfjdfabcddcdheiibh(I):
  O = I
  for obj in sorted(objects(I, True, True, True), key=lambda obj: -leftmost(obj)):
    if leftmost(obj) != width(I) - 1:
      O = paint(cover(O, obj), shift(obj, (0, width(I) - 1 - leftmost(obj))))
  return O
 
10.0, 10.81408, def ffbjbfbdfbdfejecaffdgajhbbbbecca(I):
    O = canvas(mostcolor(I), shape(I))
    offset = 0
    for obj in sorted(objects(I, True, True, True), key=lambda obj: (-uppermost(obj), -leftmost(obj))):
        O = paint(O, shift(obj, (0, width(I) - width(obj) - offset)))
        offset += width(obj)
    return O
 
4.333333333333333, 5.764971, def hahfcdabebjjeibbicdjfabaejecdafb(I):
  O = I
  for c in sorted(palette(I)):
    objs = order(objects(I, T, T, T), lambda obj: (-size(obj), uppermost(obj), leftmost(obj)))
    for i, obj in enumerate(objs):
      if i == 0:
        main_obj = obj
        continue
      if c == 6:
        O = move(O, obj, (uppermost(main_obj), width(I) - width(obj) - leftmost(obj) + i))
      elif c == 8:
        if i == 1:
          O = paint(O, {(c, (uppermost(main_obj), leftmost(main_obj) + width(main_obj) + i))})
        else:
          O = paint(O, {(c, (uppermost(main_obj) + 1, leftmost(main_obj) + width(main_obj) + i - 1))})
      elif c == 2:
        O = paint(O, {(c, (uppermost(main_obj) + 2, leftmost(main_obj) + width(main_obj) + i))})
      else:
        O = move(O, obj, (uppermost(main_obj) + i - 1, leftmost(main_obj) + width(main_obj) - width(obj) - leftmost(obj)))
  return O 
 
9.333333333333334, 6.124461, def ecbdjdbijbbgejeejacbafhbcbaifahb(I):
  O = I
  for c in palette(I):
    objs = objects(I, T, T, T)
    if colorcount(I, c) > 1 or c in {8, 2}:
      main_obj = argmax(sizefilter(objects(I, T, T, T), colorcount(I, c)), size)
      for i, obj in enumerate(objs):
        if color(obj) == c:
          if c == 6:
            O = move(O, obj, (uppermost(main_obj), width(I) - width(obj) - leftmost(obj) + i))
          elif c == 8:
            if i == 0:
              continue
            elif i == 1:
              O = paint(O, {(c, (uppermost(main_obj), leftmost(main_obj) + width(main_obj)))})
            else:
              O = paint(O, {(c, (uppermost(main_obj) + 1, leftmost(main_obj) + width(main_obj) + i - 2))})
          elif c == 2:
            O = paint(O, {(c, (uppermost(main_obj) + 2, leftmost(main_obj) + width(main_obj) + i))})
          else:
            O = move(O, obj, (uppermost(main_obj) + i - 1, leftmost(main_obj) + width(main_obj) - width(obj) - leftmost(obj)))
  return O
 
4.0, 4.657997, def dbhccccecfffeaahiehdbeabjeggajgc(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    objs = order(objects(I, T, T, T), lambda obj: (-size(obj), uppermost(obj), leftmost(obj)))
    for i, obj in enumerate(objs):
      if i == 0:
        main_obj = obj
        O = paint(O, obj)
        continue
      if c == 6:
        O = paint(O, shift(obj, (uppermost(main_obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj) + i)))
      elif c == 8:
        if i == 1:
          O = paint(O, {(c, (uppermost(main_obj), leftmost(main_obj) + width(main_obj) + i))})
        else:
          O = paint(O, {(c, (uppermost(main_obj) + 1, leftmost(main_obj) + width(main_obj) + i - 1))})
      elif c == 2:
        O = paint(O, {(c, (uppermost(main_obj) + 2, leftmost(main_obj) + width(main_obj) + i))})
      else:
        O = paint(O, shift(obj, (uppermost(main_obj) - uppermost(obj) + i - 1, leftmost(main_obj) + width(main_obj) - width(obj) - leftmost(obj))))
  return O
 
5.0, 7.560002, def ieiaffgdehafeeccaeabiajgfffcccfh(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I) - 1):
      if O[i][j] != mostcolor(I) and O[i+1][j] != mostcolor(I):
        O = move(O, {(O[i+1][j], (i+1, j))}, (-1, 0))
  return O
 
8.333333333333334, 18.991365, def eejabcdebagjeeidicfhiceagfffheja(I):
    O = I
    for j in range(width(I)):
        for v in palette(crop(I, (0, j), (height(I), 1))):
            if v != mostcolor(I):
                obj = {(v, (i, j)) for i in range(height(I)) if I[i][j] == v}
                O = move(O, obj, (-uppermost(obj), 0))
    return O
 
9.333333333333334, 11.4776125, def afadeebhbdhbecfficafhbeadfdgaeib(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)-1, 0, -1):
      if O[i][j] != mostcolor(I):
        current_obj = {(O[i][j], (i, j))}
        k = i - 1
        while k >= 0 and O[k][j] != mostcolor(I):
          current_obj.add((O[k][j], (k, j)))
          k -= 1
        O = move(O, current_obj, (-uppermost(current_obj), 0))
  return O
 
7.0, 11.396678, def dehdddbbjccaehfgihddbabhhbaddgch(I):
    O = canvas(mostcolor(I), shape(I))
    for j in range(width(I)):
        top_pos = 0
        for v in palette(crop(I, (0, j), (height(I), 1))):
            if v != mostcolor(I):
                obj = {(v, (i, j)) for i in range(height(I)) if I[i][j] == v}
                O = paint(O, shift(obj, (top_pos, 0)))
                top_pos += height(obj)
    return O
 
4.0, 5.1606193, def gbhdbcicjeheefehagihdifeddbjdedg(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in difference(palette(I), {bg}):
    obj = toobject(ofcolor(I, c), I)
    if c == 8 and size(I) == astuple(5, 5):
      obj1 = extract(objects(obj), lambda o: leftmost(o) == leftmost(obj))
      obj2 = difference(obj, obj1)
      O = paint(O, shift(obj1, (-uppermost(obj1), -leftmost(obj1))))
      O = paint(O, shift(obj2, (-uppermost(obj2), width(I) - width(obj2))))
    else:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj))))
  return O
 
4.333333333333333, 5.2001934, def dgcjbgbjebjbeecbaebdaieefcefacha(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in fgpartition(I):
    c = color(obj)
    if c == 8 and size(I) == astuple(5, 5):
      obj1 = extract(objects(obj), lambda o: uppermost(o) == uppermost(obj))
      obj2 = difference(obj, obj1)
      O = paint(O, shift(obj1, (-uppermost(obj1), width(I) - width(obj1) - leftmost(obj1))))
      O = paint(O, shift(obj2, (-uppermost(obj2), width(I) - width(obj2))))
    else:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj) - leftmost(obj))))
  return O
 
11.0, 8.845795, def dfecfabcdbhaeigeaiafccfiedhfjdad(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, c in enumerate(row):
      if c != bg:
        obj = toobject(ofcolor(I, c), I)
        if c == 8 and size(I) == astuple(5, 5) and j > leftmost(obj):
          O = paint(O, shift(obj, (i - uppermost(obj), width(I) - j - 1)))
        else:
          O = paint(O, shift(obj, (i - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
  return O
 
4.333333333333333, 5.167001, def dhfebeecjafbegcjicbbddehecbcbccb(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  processed = set()
  for i in range(height(I)):
    for j in range(width(I)):
      c = I[i][j]
      if c != bg and (i, j) not in processed:
        obj = toobject(ofcolor(I, c), I)
        processed.update(toindices(obj))
        if c == 8 and size(I) == astuple(5, 5):
          obj1 = extract(objects(obj), lambda o: leftmost(o) == leftmost(obj))
          obj2 = difference(obj, obj1)
          O = paint(O, shift(obj1, (-uppermost(obj1), width(I) - width(obj1) - leftmost(obj1))))
          O = paint(O, shift(obj2, (-uppermost(obj2), width(I) - width(obj2))))
        else:
          O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj) - leftmost(obj))))
  return O
 
3.0, 11.498762, def cedjccafbaabedcbbfddcecefbfdbfca(I):
  O = canvas(ZERO, shape(I))
  ref_obj = toobject(ofcolor(I, FIVE), I)
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      rel_pos = position(obj, ref_obj)[1] 
      O = paint(O, shift(obj, (rel_pos, -color(obj) + FIVE)))
  O = paint(O, ref_obj) 
  return O
 
3.6666666666666665, 9.7659645, def chfbdeehiabdehbcbdgccccfdaffecag(I):
  O = I
  ref_obj = toobject(ofcolor(I, FIVE), I)
  for c in palette(I) - {FIVE}:
    for obj in colorfilter(objects(I, T, T, F), c):
      rel_pos = position(obj, ref_obj)[1]
      O = paint(cover(O, obj), shift(obj, (-c + FIVE, rel_pos)))
  return O
 
3.6666666666666665, 9.661053, def bbfihecifbieedidaeahcdbdjbcdhbde(I):
  O = I
  five_pos = position(toobject(asindices(I), I), toobject(ofcolor(I, FIVE), I))
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      obj_pos = position(obj, toobject(asindices(I), I))
      shift_amount = (-(color(obj) - FIVE), obj_pos[1] - five_pos[1])
      O = paint(cover(O, obj), shift(obj, shift_amount))
  return O
 
8.333333333333334, 25.858738, def ceaicgggacebedbhicgejedcgccbeibb(I):
  objs = sorted(objects(I, True, True, True), key=lambda obj: min(v for v, _ in obj))
  O = canvas(mostcolor(I), shape(I))
  for j, obj in enumerate(objs):
    O = paint(O, shift(obj, (0, j * width(obj))))
  return O
 
8.333333333333334, 26.187088, def fjfaeiibfdhiefedbbgaeefgebjgdhdd(I):
  O = I
  for i, obj in enumerate(sorted(objects(I, True, True, True), key=lambda obj: min(v for v, _ in obj))):
    O = paint(cover(O, obj), shift(obj, (0, width(obj) * i - leftmost(obj))))
  return O
 
9.666666666666666, 9.620215, def aegbbfbibaajejedbchfafeeeeffhdge(I):
  objs = sorted(objects(I, True, True, True), key=lambda obj: (min(v for v, _ in obj), -rightmost(obj)))
  O = canvas(mostcolor(I), shape(I))
  j = 0
  for obj in objs:
    O = paint(O, shift(obj, (0, j)))
    j += width(obj)
  return O
 
4.666666666666667, 5.734516, def acgaddcafefcejcfbeiddbaaacbcjfje(I):
  min_obj = min(objects(I, True, True, True), key=lambda obj: min(v for v, _ in obj))
  other_objs = list(objects(I, True, True, True) - {min_obj})
  O = canvas(mostcolor(I), shape(I))
  for j, obj in enumerate(sorted(other_objs, key=lambda obj: min(v for v, _ in obj))):
    O = paint(O, shift(obj, (0, j * width(obj))))
  O = paint(O, shift(min_obj, (0, len(other_objs) * width(min_obj))))
  return O
 
4.0, 5.1606193, def aehbgiebgbdaeiadbghdhibjddaabfca(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    objs = objects(I, T, T, T)
    for obj in sizefilter(objs, colorcount(I, c)):
      if c == 3:
        target_loc = (0, width(I) - width(obj))
      elif c == 6:
        target_loc = (0, width(I) - width(obj))
      elif c == 8:
        target_loc = (0, width(I) - width(obj))
      elif c == 4:
        target_loc = (height(I) - height(obj), width(I) - width(obj))
      elif c == 1:
        target_loc = (height(I) - height(obj), width(I) - width(obj))
      else:
        target_loc = (0, 0)
      O = paint(O, shift(obj, subtract(target_loc, ulcorner(obj))))
  return O
 
4.666666666666667, 6.110629, def gdifabhifafcebfeaeffecabeafhigje(I):
  O = I
  for c in sorted(palette(I)):
    objs = sizefilter(objects(I, T, T, T), colorcount(I, c))
    for i, obj in enumerate(objs):
      if c == 3:
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      elif c == 6 and i == 0:
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      elif c == 6 and i == 1:
        O = move(O, obj, (1, width(I) - width(obj) - leftmost(obj)))
      elif c == 8 and i == 0:
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      elif c == 8 and i == 1:
        O = move(O, obj, (2, width(I) - width(obj) - leftmost(obj)))
      elif c == 4:
        O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
      elif c == 1:
        O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
  return O
 
5.0, 6.027999, def ggeehhebfadbefecaaacdhaccidcicff(I):
  O = I
  for c in sorted(palette(I) - {mostcolor(I)}):
    obj = extract(objects(I, T, T, T), lambda obj: color(obj) == c)
    if c == 3:
      O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
    elif c == 6:
      O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      O = paint(O, shift(recolor(c, obj), (1, width(I) - width(obj) - leftmost(obj))))
    elif c == 8:
      O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      O = paint(O, shift(recolor(c, obj), (2, width(I) - width(obj) - leftmost(obj))))
    elif c == 4:
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
    elif c == 1:
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
  return O
 
5.0, 3.525463, def bacehdiaahbjehfajffdejefbefbaejf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c == 3:
      target_loc = (0, width(I) - width(obj))
    elif c == 6:
      target_loc = (0, width(I) - width(obj))
      O = paint(O, shift(obj, subtract(target_loc, ulcorner(obj))))
      target_loc = (1, width(I) - width(obj))
    elif c == 8:
      target_loc = (0, width(I) - width(obj))
      O = paint(O, shift(obj, subtract(target_loc, ulcorner(obj))))
      target_loc = (2, width(I) - width(obj))
    elif c == 4:
      target_loc = (height(I) - height(obj), width(I) - width(obj))
    elif c == 1:
      target_loc = (height(I) - height(obj), width(I) - width(obj))
    else:
      target_loc = ulcorner(obj)
    O = paint(O, shift(obj, subtract(target_loc, ulcorner(obj))))
  return O
 
5.333333333333333, 3.7130127, def djaahhhicffaeffaifffdeieccbdjaaf(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c != mostcolor(I):
      if c == 3:
        O = move(O, obj, subtract((0, width(I) - width(obj)), ulcorner(obj)))
      elif c == 6:
        O = move(O, obj, subtract((0, width(I) - width(obj)), ulcorner(obj)))
        O = paint(O, shift(recolor(c, obj), subtract((1, width(I) - width(obj)), ulcorner(obj))))
      elif c == 8:
        O = move(O, obj, subtract((0, width(I) - width(obj)), ulcorner(obj)))
        O = paint(O, shift(recolor(c, obj), subtract((2, width(I) - width(obj)), ulcorner(obj))))
      elif c in (4, 1):
        O = move(O, obj, subtract((height(I) - height(obj), width(I) - width(obj)), ulcorner(obj)))
  return O
 
5.333333333333333, 5.4529357, def ccacchecfdacececjhdcaedihhdfiecj(I):
    O = I
    for j in range(width(I)):
        for i in range(height(I) - 1):
            for k in range(i + 1, height(I)):
                if I[k][j] < I[i][j] and I[k][j] != mostcolor(I):
                    O = move(O, {(I[k][j], (k, j))}, (-k + i, 0))
                    break
    return O
 
9.666666666666666, 11.196289, def aidhiefebdecejbeibdhcefddahbdbfe(I):
  O = I
  for j in range(width(I)):
    sorted_column = sorted((I[i][j] for i in range(height(I))), reverse=True)
    for i, v in enumerate(sorted_column):
      if v != mostcolor(I):
        obj = {(v, (k, j)) for k in range(height(I)) if I[k][j] == v}
        O = cover(O, obj)
        O = paint(O, shift(obj, (-uppermost(obj) + i, j - leftmost(obj))))
  return O
 
9.666666666666666, 9.503932, def hcbghifabjafefddbabjjjggdfehjbji(I):
    O = canvas(mostcolor(I), shape(I))  # Initialize output with background color
    for j in range(width(I)):
        col_objs = objects(crop(I, (0, j), (height(I), 1)), True, True, True)
        sorted_objs = sorted(col_objs, key=lambda obj: color(obj))
        current_height = 0
        for obj in sorted_objs:
            O = paint(O, shift(obj, (-uppermost(obj) + current_height, j - leftmost(obj))))
            current_height += height(obj)
    return O 
 
7.0, 8.879193, def dfdaebebhbbbecbdigbecafbffdeghfg(I):
    O = I
    for j in range(width(I)):
        top_pos = 0
        for v in sorted(set(I[i][j] for i in range(height(I))) - {mostcolor(I)}):
            obj_height = sum(1 for i in range(height(I)) if I[i][j] == v)
            O = move(O, {(v, (i, j)) for i in range(height(I)) if I[i][j] == v}, (-top_pos, 0))
            top_pos += obj_height
    return O
 
4.333333333333333, 5.081677, def dabfcfddbgheeffebahaegfhcfahiefe(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in fgpartition(I):
    c = color(obj)
    if c == 6 and size(I) == astuple(4, 4):  # Handle splitting object with color 6
      top_cell = extract(obj, lambda cell: uppermost(cell) == uppermost(obj))
      bottom_cell = other(obj, top_cell)
      O = paint(O, shift(top_cell, (0, width(I) - 1)))
      O = paint(O, shift(bottom_cell, (1, width(I) - 1)))
    elif size(obj) == 1:  # Move single-cell objects to the rightmost
      O = paint(O, shift(obj, (uppermost(obj), width(I) - 1)))
    else: # Retain other objects in their original position
      O = paint(O, obj)
  return O
 
4.666666666666667, 4.9722867, def abcddaebaafcehabafbdghciibedecgj(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(fgpartition(I), key=lambda obj: (-color(obj), uppermost(obj))):
    if size(obj) == 1:
      target_j = width(I) - 1
      O = paint(O, shift(obj, (uppermost(obj), target_j - leftmost(obj))))
    else:
      O = paint(O, obj)
  return O
 
4.666666666666667, 4.9841375, def defacdhfbbibegeajadhcaaddigcbfac(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != bg:
        if colorcount(I, v) == 1:  
          O = paint(O, {(v, (i, width(I) - 1))})
        else:
          O = paint(O, {(v, (i, j))})
  return O
 
3.6666666666666665, 8.603823, def caabhaccecfieggfbfdgdebgbadgjced(I):
  O = paint(canvas(ZERO, shape(I)), toobject(ofcolor(I, FIVE), I))
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      O = paint(O, shift(obj, (0, position(obj, toobject(ofcolor(I, FIVE), I))[1] * color(obj))))
  return O
 
7.666666666666667, 32.840908, def fajdgacaggefedhajcddbbgchbbcbaic(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  five_indices = ofcolor(I, FIVE) # Get indices of color 5
  for v in palette(I) - {ZERO}: # Iterate over colors except 0
    for i, r in enumerate(I):
      for j, c in enumerate(r):
        if c == v: # Find cells with current color
          rel_pos = position(frozenset({(i, j)}), five_indices) # Calculate relative position to color 5
          new_j = j + rel_pos[1] * v # Calculate new column index
          O = paint(O, {(v, (i, new_j))}) # Paint the cell at the new position
  return O
 
3.6666666666666665, 9.543379, def edjcfidegeebebdaiadefbhceaeacajc(I):
  O = I 
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      O = cover(O, obj) # Remove the object
      ref_pos = toindices(toobject(ofcolor(I, FIVE), I)) # Get indices of reference object
      rel_pos = position(obj, ref_pos) # Get relative position
      new_pos = (rel_pos[0], rel_pos[1] * color(obj)) # Calculate new position
      O = paint(O, shift(obj, new_pos)) # Paint the object at the new position
  return O 
 
9.0, 10.117786, def beedaafgjcafejbhiiiagfecceeeeecd(I):
    # Get the background color of the input grid.
    bg = mostcolor(I)
    # Create a canvas filled with the background color and the same shape as the input grid.
    O = canvas(bg, shape(I))
    # Get a list of all unique colors in the input grid, excluding the background color.
    colors = sorted(palette(I) - {bg})
    # Initialize the starting column index for placing the objects.
    j = 0
    # Iterate over the sorted colors.
    for c in colors:
        # For each color, get the indices of all cells with that color.
        indices = ofcolor(I, c)
        # Create an object from the indices and the current color.
        obj = recolor(c, indices)
        # Paint the object onto the canvas at the top row, starting from the calculated column index.
        O = paint(O, shift(obj, (-uppermost(obj), j)))
        # Update the column index for the next object based on the width of the current object.
        j += width(obj)
    # Return the modified output grid.
    return O
 
17.666666666666668, 12.608862, def bgcaajifbchdeeadjhbhdjddfbffiged(I):
    # Extract all objects from the input grid, excluding the background color
    objs = objects(I, True, True, True)
    # Sort these objects based on their color in ascending order
    objs = sorted(objs, key=lambda obj: color(obj))
    # Calculate the total width needed to accommodate all objects in a row
    total_width = sum([width(obj) for obj in objs])
    # Create a blank canvas with the height of the input and the calculated total width
    canvas_grid = canvas(mostcolor(I), (height(I), total_width))
    # Initialize a counter to track the current horizontal position while placing objects
    current_j = 0
    # Iterate over the sorted objects
    for obj in objs:
        # Paint each object onto the canvas at the top row, starting from the current horizontal position
        canvas_grid = paint(canvas_grid, shift(obj, (-uppermost(obj), current_j)))
        # Update the current horizontal position by adding the width of the just-placed object
        current_j += width(obj)
    # Return the canvas with the rearranged objects
    return canvas_grid
 
2.6666666666666665, 5.257943, def bhabefajbfddebaiaheediecdacebfjc(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    objs = objects(I, T, T, T)
    for obj in sizefilter(objs, colorcount(I, c)):
      if c == 3:
        target_loc = (0, 1)
      elif c == 6:
        target_loc = (0, width(I) - width(obj))
      elif c == 8:
        target_loc = (0, 2)
      elif c == 4:
        target_loc = (height(I) - height(obj), width(I) - width(obj))
      elif c == 1:
        target_loc = (height(I) - height(obj), width(I) - 1)
      elif c == 2:
        target_loc = (2, width(obj) + 1)
      else:
        target_loc = (0, 0)
      O = paint(O, shift(obj, subtract(target_loc, ulcorner(obj))))
  return O
 
4.666666666666667, 7.5132804, def fehgdafjahdbeaehaaaeggffececddda(I):
  O = I
  for c in sorted(palette(I) - {mostcolor(I)}):
    objs = objects(I, T, T, T)
    if c == 3:
      obj = extract(objs, lambda o: color(o) == c)
      O = move(O, obj, (0, 1))
    elif c == 6:
      for obj in sizefilter(objs, colorcount(I, c)):
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
    elif c == 8:
      for i, obj in enumerate(sorted(sizefilter(objs, colorcount(I, c)), key=lambda obj: leftmost(obj))):
        O = move(O, obj, (0, 1 + i * width(obj)))
    elif c == 4:
      obj = extract(objs, lambda o: color(o) == c)
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
    elif c == 1:
      obj = extract(objs, lambda o: color(o) == c)
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - 1 - leftmost(obj)))
    elif c == 2:
      obj = extract(objs, lambda o: color(o) == c)
      target = extract(objects(O, T, T, T), lambda o: color(o) == 8)
      O = move(O, obj, add((0, width(target)), subtract(ulcorner(target), ulcorner(obj))))
  return O
 
4.0, 7.076993, def cbecfbibeegdefifbcdehefifcfdhace(I):
  O = I
  for j in range(width(I)):
    column_objs = objects(crop(O, (0, j), (height(O), 1)), True, True, True)
    for obj in order(column_objs, lambda obj: color(obj)):
        O = cover(O, obj)
        O = paint(O, shift(obj, (-ulcorner(obj)[0], 0)))
  return O
 
9.333333333333334, 9.574926, def ddbbdgjbcaafegfgaibgbjadgfhdjbbd(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  for j in range(w):
    column = [I[i][j] for i in range(h)]
    values = sorted(set(column) - {bg})
    for i, v in product(range(h), values):
      if I[i][j] == v:
        O = paint(O, {(v, (values.index(v), j))})
  return O
 
6.666666666666667, 3.8058515, def cbihadddcecdebjfjdhiebeidbbbibed(I):
  O = I
  for j in range(width(I)):
    column_indices = asindices(crop(O, (0, j), (height(O), 1)))
    for v in sorted(palette(crop(O, (0, j), (height(O), 1))) - {mostcolor(I)}):
      obj_indices = ofcolor(crop(O, (0, j), (height(O), 1)), v)
      O = cover(O, obj_indices)
      O = paint(O, recolor(v, {(i, j) for i in range(len(obj_indices))}))
  return O
 
4.666666666666667, 3.6454692, def biaaaeechbeeegajbeffbjcgabebefje(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (0, width(I) - width(obj)))) 
    elif c == 6:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj))))
    elif c == 4 and size(I) == astuple(4, 4):
      O = paint(O, shift(obj, (height(I) - 1, width(I) - 1)))
    elif c == 8 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (0, width(I) - width(obj))))
    elif c == 2 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (3, width(I) - width(obj))))
    elif c == 1 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (4, width(I) - width(obj))))
    else:
      O = paint(O, obj) 
  return O
 
4.333333333333333, 5.3490515, def eeecgiegefadebbeabceicfebbfejdae(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) == 3:
      O = paint(O, shift(obj, (0, width(obj) - leftmost(obj))))
    elif color(obj) == 6:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - leftmost(obj))))
    elif color(obj) == 4 and size(I) == astuple(4, 4):
      O = paint(O, shift(obj, (height(I) - 1 - uppermost(obj), width(I) - 1 - leftmost(obj))))
    elif color(obj) == 8 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (0, 2))) 
    elif color(obj) == 2 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (3, 3))) 
    elif color(obj) == 1 and size(I) == astuple(5, 5):
      O = paint(O, shift(obj, (4, 4))) 
    else:
      O = paint(O, obj) 
  return O
 
5.333333333333333, 4.277412, def bffdicahcgdfeadcbgbcddbefjeafdjc(I):
  O = canvas(ZERO, shape(I))
  five_indices = ofcolor(I, FIVE)
  O = paint(O, toobject(five_indices, I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != FIVE:
        rel_dist = min(abs(j - j_five) for i_five, j_five in five_indices)
        O = paint(O, {(value, (i, j + rel_dist * value))})
  return O 
 
3.3333333333333335, 11.426515, def acbfddidbbbeebedacgeefaadjdceaha(I):
  O = canvas(ZERO, shape(I))
  ref_obj = toobject(ofcolor(I, FIVE), I)
  O = paint(O, ref_obj)
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != FIVE:
        rel_j = j - centerofmass(ref_obj)[1]
        O = paint(O, {(I[i][j], (i, j + rel_j * I[i][j]))})
  return O
 
5.333333333333333, 4.277412, def aaigbecbdcdjefbejeficcddjchfgfff(I):
  objs = objects(I, True, True, True)
  O = canvas(mostcolor(I), shape(I)) 
  for obj in sorted(objs, key=lambda obj: (color(obj), uppermost(obj), leftmost(obj))):
    O = paint(O, obj) 
  return O
 
10.333333333333334, 13.075179, def fccaebdiafifejegafedbjdieicdceic(I):
  objs = objects(I, True, True, True)
  O = canvas(mostcolor(I), shape(I)) 
  for obj in objs:
    downward_shift = (height(I) - lowermost(obj), 0) 
    O = paint(O, shift(obj, downward_shift)) 
  return O
 
9.666666666666666, 10.549512, def eeehfcgaadcbebecaeecbdcebfeefehc(I):
  objs = objects(I, True, True, True)
  O = canvas(mostcolor(I), shape(I))
  current_j = 0
  for obj in sorted(objs, key=lambda obj: (color(obj), uppermost(obj), leftmost(obj))):
    obj_width = width(obj)
    O = paint(O, shift(obj, (0, current_j - leftmost(obj)))) 
    current_j += obj_width  
  return O
 
11.666666666666666, 7.9502106, def bgfghcahdcbbeebebbfjeehedfbgbeec(I):
  objs = objects(I, True, True, True)
  O = canvas(mostcolor(I), shape(I)) 
  sorted_objs = sorted(objs, key=lambda obj: (color(obj), uppermost(obj), leftmost(obj)))
  for obj in sorted_objs:
    downward_shift = (height(I) - lowermost(obj) - uppermost(obj), 0)
    O = paint(O, shift(obj, downward_shift)) 
  return O
 
4.333333333333333, 7.9185534, def bieaacfiibjfefdcaeeejcgbgiccefda(I):
  O = I
  for c in sorted(palette(I) - {mostcolor(I)}):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      if c == 3:
        O = move(O, obj, (0, 1))
      elif c == 6:
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
      elif c == 8:
        target = extract(objects(O, T, T, T), lambda o: color(o) == 5 and uppermost(o) == 0)
        O = move(O, obj, (0, rightmost(target) - leftmost(obj) + 1))
      elif c == 4:
        O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
      elif c == 1:
        O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
      elif c == 2:
        target = extract(objects(O, T, T, T), lambda o: color(o) == 8)
        O = move(O, obj, (0, rightmost(target) - leftmost(obj) + 1))
  return O
 
7.666666666666667, 27.93088, def ifacfefbefjjeeaejdaedecahbbbaahc(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I) - {mostcolor(I)}):
    objs = sorted(sizefilter(objects(I, T, T, T), colorcount(I, c)), key=lambda o: (-uppermost(o), leftmost(o)))
    for i, obj in enumerate(objs):
      if c == 3:
        O = paint(O, shift(obj, (0, 1)))
      elif c == 6:
        O = paint(O, shift(obj, (uppermost(obj), width(I) - width(obj) - leftmost(obj))))
      elif c == 8:
        O = paint(O, shift(obj, (0, width(I) - width(obj) - leftmost(obj) + i * width(obj))))
      elif c == 4:
        O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
      elif c == 1:
        O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
      elif c == 2:
        target = extract(objects(I, T, T, T), lambda o: color(o) == 8)
        O = paint(O, shift(obj, (uppermost(target), rightmost(target) + i * width(obj) + 1)))
  return O
 
4.666666666666667, 7.7790365, def dajbebdfbeabebeibgegiiddajedaijf(I):
  O = I
  for c in sorted(palette(I) - {mostcolor(I)}):
    if c == 3:
      obj = extract(objects(I, T, T, T), lambda o: color(o) == c)
      O = move(O, obj, (0, 1))
    elif c == 6:
      for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
        O = move(O, obj, (0, width(I) - width(obj) - leftmost(obj)))
    elif c == 8:
      for i, obj in enumerate(sorted(sizefilter(objects(I, T, T, T), colorcount(I, c)), key=lambda o: uppermost(o))):
        O = move(O, obj, (0, width(I) - len(objects(I, T, T, T)) + i))
    elif c == 4:
      obj = extract(objects(I, T, T, T), lambda o: color(o) == c)
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
    elif c == 1:
      obj = extract(objects(I, T, T, T), lambda o: color(o) == c)
      O = move(O, obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj)))
    elif c == 2:
      for i, obj in enumerate(sorted(sizefilter(objects(I, T, T, T), colorcount(I, c)), key=lambda o: uppermost(o))):
        O = move(O, obj, (i, width(I) - len(objects(I, T, T, T)) + i))
  return O
 
7.333333333333333, 30.993216, def aajgdiejgbjfefbbieicfabcbhcaejee(I):
  O = canvas(mostcolor(I), shape(I))
  objs = sorted(objects(I, T, T, T), key=lambda o: (color(o), -uppermost(o), leftmost(o)))
  for i, obj in enumerate(objs):
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (0, 1)))
    elif c == 6:
      O = paint(O, shift(obj, (uppermost(obj), width(I) - width(obj) - leftmost(obj))))
    elif c == 8:
      O = paint(O, shift(obj, (0, i * width(obj))))
    elif c == 4:
      O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
    elif c == 1:
      O = paint(O, shift(obj, (height(I) - height(obj) - uppermost(obj), width(I) - width(obj) - leftmost(obj))))
    elif c == 2:
      target = extract(objects(I, T, T, T), lambda o: color(o) == 8)
      O = paint(O, shift(obj, (i - 1, rightmost(target) + 1)))
  return O
 
10.333333333333334, 13.907824, def cfffafhbgfdfefdgbcbedafghgheecbc(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for c in palette(I) - {bg}:
    obj = frozenset((c, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == c)
    target_j = 0
    while any(index(O, (i, target_j)) != bg for i in range(height(I))):
      target_j += 1
    O = paint(O, shift(obj, (0, target_j - rightmost(obj))))
  return O
 
9.333333333333334, 16.090298, def fcffcfiehadbeabeifddajbddgdfdadi(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  processed = initset(bg)
  for j in range(width(I)-1, -1, -1):  # Iterate columns right to left
    for i in range(height(I)):
      c = index(I, (i, j))
      if c not in processed:
        obj = frozenset((c, (k, l)) for k, r in enumerate(I) for l, v in enumerate(r) if v == c)
        target_j = 0
        while any(index(O, (k, target_j)) != bg for k in range(height(I))):
          target_j += 1
        O = paint(O, shift(obj, (0, target_j - rightmost(obj))))
        processed = insert(c, processed)
  return O
 
10.666666666666666, 11.945929, def bcdajecieijdebehbccjabdbfadiejfd(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  available_cols = list(range(width(I)))
  for obj in fgpartition(I):
    c = color(obj)
    target_j = available_cols.pop(0)  # Get and remove the first available column
    O = paint(O, shift(obj, (0, target_j - rightmost(obj))))
  return O
 
8.333333333333334, 29.383368, def fajcbbijejfbeaehjeebbcgcifagiicd(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for j in range(width(I)-1, -1, -1):
    col = frozenset((index(I, (i, j)), (i, j)) for i in range(height(I)))
    for c, (i, _) in col:
      if c != bg and index(O, (i, 0)) == bg:  # Check if color needs moving and target is empty
        obj = frozenset((c, (k, l)) for k, r in enumerate(I) for l, v in enumerate(r) if v == c)
        O = paint(O, shift(obj, (0, -rightmost(obj))))
        break  # Move only one column per original column
  return O
 
5.0, 4.0633583, def deafjfhaagaeedbabgijbfddaggjjfdi(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  ref_obj = toobject(ofcolor(I, FIVE), I) # Define reference object with color 5
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE: # Skip the reference object
      rel_pos = sign(position(obj, ref_obj)[1]) # Get the direction to move towards 5
      O = paint(O, shift(obj, (0, rel_pos * abs(color(obj) - FIVE)))) # Shift and paint
  O = paint(O, ref_obj) # Paint the reference object at the end
  return O
 
3.6666666666666665, 9.527158, def chfbfhfbfacfeababaifjfjfbbeaecbe(I):
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      ref_obj = toobject(ofcolor(I, FIVE), I)
      direction = position(obj, ref_obj)
      O = paint(cover(O, obj), shift(obj, (0, crement(direction[1]) * abs(color(obj) - FIVE))))
  return O 
 
3.3333333333333335, 10.309266, def edeeaegdbedcejgdjchejdfdbbfhaaeb(I):
  O = canvas(ZERO, shape(I))
  ref_obj = toobject(ofcolor(I, FIVE), I)
  for obj in objects(I, T, T, T):
    if color(obj) == FIVE: continue
    ref_center = center(ref_obj)
    obj_center = center(obj)
    h_diff = obj_center[1] - ref_center[1]
    new_obj = shift(obj, (0, sign(h_diff) * abs(color(obj) - FIVE)))
    O = paint(O, new_obj)
  O = paint(O, ref_obj)
  return O
 
5.333333333333333, 5.0872145, def adjhffedafdfedifjfbjbheidbjeeddd(I):
  # Identify objects within the grid
  objs = objects(I, True, True, True)
  # Find the object with the minimum color value
  min_obj = argmin(objs, lambda obj: min(palette(obj)))
  # Remove the object with the minimum color value from the grid
  I = cover(I, min_obj)
  # Paint the object with the minimum color value at the top left corner
  O = paint(I, shift(min_obj, (-uppermost(min_obj), -leftmost(min_obj))))
  return O
 
3.6666666666666665, 6.7328553, def hfcjddcfiaaaeefcjcgbjeefbbjajcia(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    for obj in sizefilter(objects(I, T, T, T), colorcount(I, c)):
      if c == 3:
        O = paint(O, shift(obj, (0, 1)))
      elif c == 6:
        O = paint(O, shift(obj, (0, width(I) - rightmost(obj))))
      elif c == 8:
        if colorcount(O, c) == 1:
          O = paint(O, shift(obj, (0, 1)))
        else:
          O = paint(O, obj)
      elif c == 4:
        O = paint(O, shift(obj, (height(I) - lowermost(obj), width(I) - rightmost(obj))))
      elif c == 1:
        O = paint(O, shift(obj, (height(I) - lowermost(obj), width(I) - rightmost(obj) - 1)))
      elif c == 2 and colorcount(I, c) == 0:
        target_8 = extract(objects(O, T, T, T), lambda o: color(o) == 8)
        O = paint(O, shift({(2, (uppermost(target_8) - 1, rightmost(target_8) + 1)), (2, (uppermost(target_8), rightmost(target_8) + 1))}, (0, 0)))
      else:
        O = paint(O, obj)
  return O
 
4.0, 6.376043, def hedbfdfffbcbefdbicdjdcaebecjdidd(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c == 3:
      O = move(O, obj, (0, 1))
    elif c == 6:
      O = move(O, obj, (0, width(O) - rightmost(obj)))
    elif c == 8 and any(color(o) == 8 and rightmost(o) > rightmost(obj) for o in objects(O, T, T, T)):
      O = move(O, obj, (0, 1))
    elif c == 4:
      O = move(O, obj, (height(O) - lowermost(obj), width(O) - rightmost(obj)))
    elif c == 1:
      O = move(O, obj, (height(O) - lowermost(obj), width(O) - rightmost(obj) - 1))
    elif c == 2 and colorcount(I, c) == 0:
      target = extract(objects(O, T, T, T), lambda o: color(o) == 8)
      O = paint(O, {(2, (uppermost(target) - 1, rightmost(target) + 1)), (2, (uppermost(target), rightmost(target) + 1))})
  return O
 
7.0, 38.56502, def ffcabcabihjhebbajcbjceadfajedbie(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(objects(I, True, True, True), key=lambda o: (leftmost(o), uppermost(o))):
    target_j = leftmost(obj)
    O = paint(O, shift(normalize(obj), (uppermost(ofcolor(O, color(obj)) | {(height(I), target_j)}), target_j)))
  return O
 
3.3333333333333335, 8.332272, def gecaeigaejjeeedjicfdaajcdigfjceb(I):
    O = canvas(mostcolor(I), shape(I))
    for j in range(width(I)):
        column_objects = sorted(
            (obj for obj in objects(I, True, True, True) if leftmost(obj) == j),
            key=lambda o: uppermost(o)
        )
        current_i = 0
        for obj in column_objects:
            O = paint(O, shift(normalize(obj), (current_i, j)))
            current_i += height(obj)
    return O
 
8.666666666666666, 13.520806, def dfhffegcahfdehhhbihfdeaafbeffahi(I):
    O = I
    for j in range(width(I)):
        column_indices = frozenset((i, j) for i in range(height(I)))
        for v in sorted(palette(crop(I, (0, j), (height(I), 1))) - {mostcolor(I)}):
            obj = toobject(intersection(column_indices, toindices(extract(objects(I, True, True, True), lambda o: color(o) == v))), I)
            O = cover(O, obj)
            O = paint(O, shift(normalize(obj), (uppermost(ofcolor(O, v) | {(height(I), j)}), j)))
    return O
 
4.333333333333333, 5.8163996, def aiigdegcbedbedbhafbabbadejebgahf(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (0, width(I) - width(obj))))
    elif c == 6:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj))))
    elif c == 4 and size(I) == astuple(4, 4):
      O = paint(O, shift(obj, (height(I) - 1, width(I) - 1)))
    elif c == 8:
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj))))
    elif c == 2:
      target_row = 1
      O = paint(O, shift(obj, (target_row - uppermost(obj), width(I) - width(obj))))
    elif c == 1:
      O = paint(O, shift(obj, (3, width(I) - width(obj))))
    else:
      O = paint(O, obj)
  return O
 
8.666666666666666, 18.052464, def bedcifbafaefehababgajfiefjbdaifd(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    c = color(obj)
    row, col = divmod(c, 3)  # Determine target row and column offset based on color
    O = paint(O, shift(obj, (row - uppermost(obj), width(I) - width(obj) - col)))
  return O
 
7.666666666666667, 8.871036, def cibjaecffafeeghbbefbjjcffhbdddff(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    target_row = (uppermost(obj) + color(obj)) % height(I)  # Target row based on color and initial position
    O = paint(O, shift(obj, (target_row - uppermost(obj), width(I) - width(obj))))
  return O
 
4.666666666666667, 4.2286673, def fhcadgeegfdjefbiihbhhbdaeddaeacb(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if color(obj) in {3, 6, 8}:  # Move only specific colors
      O = paint(O, shift(obj, (-uppermost(obj), width(I) - width(obj))))
    else:
      O = paint(O, obj) 
  return O
 
4.333333333333333, 7.632884, def fabiibbhaeaceecbajbicggfedibcdcb(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    five_j = row.index(FIVE)
    for j, v in enumerate(row):
      if v != ZERO:
        new_j = five_j + (j - five_j) * abs(v - FIVE)
        if 0 <= new_j < width(I):
          O = fill(O, v, ((i, new_j), (1, 1)))
  return O
 
5.333333333333333, 8.025198, def adabdgcdabbeejaeabcicddhjbbbfbaj(I):
  O = I
  for i in range(height(I)):
    five_j = I[i].index(FIVE)
    for j in range(width(I)):
      if I[i][j] != ZERO and I[i][j] != FIVE:
        diff = abs(I[i][j] - FIVE)
        direction = 1 if j > five_j else -1
        new_j = five_j + direction * diff
        if 0 <= new_j < width(I):
          O = fill(O, I[i][j], ((i, new_j), (1, 1)))
          O = fill(O, ZERO, ((i, j), (1, 1)))
  return O
 
3.3333333333333335, 11.182233, def ggebhbebcbdcebbeaibbjajdabcbaeff(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    try:
      five_j = row.index(FIVE)
    except ValueError:
      five_j = -1  # Handle cases where '5' might be missing in a row.
    for j, v in enumerate(row):
      if v != ZERO:
        new_j = j + (j - five_j) * (v - FIVE)
        if 0 <= new_j < width(I):
          O = fill(O, v, ((i, new_j), (1, 1)))
  return O
 
12.333333333333334, 7.0963306, def cieajicgddajeaiaibdadffjfgfaacjh(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    for i, r in enumerate(O):
        empty_indices = [(i, j) for j, v in enumerate(r) if v == mostcolor(O)]
        object_indices = [(i, j) for j, v in enumerate(r) if v == c]
        for k in range(min(len(empty_indices), len(object_indices))):
          O = paint(cover(O, recolor(c, {object_indices[k]})), recolor(c, {empty_indices[k]}))
  return O
 
8.666666666666666, 20.959345, def ccjhaeefdifdecegaceegaedjahdhcde(I):
    O = I
    objs = objects(I, True, True, True)
    for obj in objs:
      c = color(obj)
      row = uppermost(obj)
      empty_indices = [(row, j) for j, v in enumerate(O[row]) if v == mostcolor(O)]
      if empty_indices:
        target_index = empty_indices[-1]
        shifted_obj = shift(obj, subtract(target_index, ulcorner(obj)))
        O = paint(cover(O, obj), shifted_obj)
    return O
 
9.0, 18.8352, def ijjdacceafbheahgjefijcjhchajdccd(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    objs = colorfilter(objects(O, True, True, True), c)
    for obj in objs:
      empty_indices = [(uppermost(obj), j) for j in range(len(O[0])) if O[uppermost(obj)][j] == mostcolor(O)]
      if empty_indices:
        O = paint(cover(O, obj), shift(obj, subtract(empty_indices[-1], ulcorner(obj))))
  return O
 
11.666666666666666, 5.4899383, def aadfaeffageaeagcjiefbcedjfhjiiha(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = first(colorfilter(objects(I, True, True, True), c)) # Assuming all objects of same color are identical
    occurrences_indices = occurrences(I, obj)
    target_indices = sorted([ulcorner(recolor(c, {(i, j)})) for i, row in enumerate(I) for j, v in enumerate(row) if v == mostcolor(I) and (i, j) not in occurrences(I, obj)])
    for k in range(min(len(occurrences_indices), len(target_indices))):
      O = paint(cover(O, shift(obj, subtract(first(occurrences_indices), ORIGIN))), shift(obj, subtract(target_indices[k], ORIGIN)))
  return O
 
12.333333333333334, 8.361457, def ggbfbecbcacaeafdjecabbjfebiefice(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = first(colorfilter(objects(I, True, True, True), c))
    for i, row in enumerate(O):
      empty_indices = [(i, j) for j, v in enumerate(row) if v == mostcolor(O)]
      if empty_indices:
        target_index = empty_indices[-1]
        O = paint(cover(O, obj), shift(obj, subtract(target_index, ulcorner(obj)))) 
  return O
 
4.0, 8.40968, def fhijcedibgeaeafhabffdadabfbcebbe(I):
  O = I 
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c == 3:
      O = move(O, obj, (0, 1)) 
    elif c == 6:
      O = move(O, obj, (0, width(I) - rightmost(obj))) 
    elif c == 8:
      other_objs = sizefilter(colorfilter(objects(O, T, T, T), 8), size(obj))
      if len(other_objs) > 0:
        other_obj = first(other_objs)
        O = move(O, obj, (0, rightmost(other_obj) - leftmost(obj) + 1))
    elif c == 4:
      O = move(O, obj, (height(I) - lowermost(obj), width(I) - rightmost(obj)))
    elif c == 1:
      O = move(O, obj, (height(I) - lowermost(obj), width(I) - rightmost(obj) - 1))
    elif c == 2 and colorcount(I, c) == 0:
      target = extract(objects(O, T, T, T), lambda o: color(o) == 8)
      O = paint(O, shift({(2, (uppermost(target) - 1, rightmost(target) + 1)), (2, (uppermost(target), rightmost(target) + 1))}, (0, 0)))
  return O
 
5.333333333333333, 4.277412, def ciegeicbfahfehbcbebbedjefjcdccfd(I):
    O = canvas(mostcolor(I), shape(I))
    for j in range(width(I)):
        for i in range(height(I)):
            v = I[i][j]
            if v != mostcolor(I):
                O = paint(O, {(v, (i, j))})
    return O
 
4.666666666666667, 5.3253555, def ddiecjjdhdcdebahbfbhfdaafehdcbaf(I):
    O = I
    for j in range(width(I)):
        column_objects = sorted(objects(crop(I, (0, j), (height(I), 1)), True, True, True), key=lambda obj: uppermost(obj))
        next_i = 0
        for obj in column_objects:
            O = cover(O, obj)
            O = paint(O, shift(obj, (-uppermost(obj) + next_i, 0)))
            next_i += height(obj)
    return O 
 
5.0, 5.085932, def agdfcagjfiddegeejgchagcgdcabddea(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  objs = fgpartition(I)
  for obj in objs:
    if size(obj) == 1:
      same_color_locs = ofcolor(I, color(obj)) - toindices(obj)
      if same_color_locs:
        target_loc = argmin(same_color_locs, lambda loc: manhattan(obj, initset(loc)))
        O = paint(O, {(color(obj), target_loc)})
      else:
        i, j = first(toindices(obj))
        O = paint(O, {(color(obj), (i, width(I) - 1))})
    else:
      O = paint(O, obj)
  return O
 
7.666666666666667, 24.720306, def iafdfgdbebajeajfjihcehggjbabfebg(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i in range(height(I)):
    row_objs = objects(crop(I, (i, 0), (1, width(I))), univalued=False, diagonal=False, without_bg=True)
    for j, obj in enumerate(sorted(row_objs, key=lambda o: leftmost(o))):
      if size(obj) == 1:
        O = paint(O, shift(obj, (0, width(I) - j - 1)))
      else:
        O = paint(O, shift(obj, (0, j * width(obj))))
  return O
 
7.0, 37.096516, def ifcfhahigegcejcbjchhbfdgjibcaaeb(I):
  O = canvas(ZERO, shape(I))
  for obj in fgpartition(I):
    value = color(obj)
    O = paint(O, shift(obj, (0, value)))
  return O
 
7.0, 38.56502, def gcebdbajihbceecfiiijebfcjiafbjej(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != ZERO:
        O = paint(cover(O, {(value, (i, j))}), {(value, (i, j + value))})
  return O
 
8.333333333333334, 5.712991, def gjgbfbebahebeedhijheaiibfhehehdb(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  for i, r in enumerate(I):
    for j, v in enumerate(r):
      if v:
        O = paint(O, {(v, (i, (j + v) % w))})
  return O
 
8.666666666666666, 15.5385475, def cebcjdfddcjcebabihffedaebgjgfaac(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(objects(I, True, True, True), key=lambda obj: color(obj)):
    for (v, (i, j)) in sorted(obj, key=lambda x: (x[1][0], x[1][1])):
      target_i = next((x for x in range(i+1) if index(O, (x, j)) == mostcolor(I)), i)
      target_j = next((y for y in range(j+1) if index(O, (target_i, y)) == mostcolor(I)), j)
      O = paint(O, {(v,(target_i, target_j))})
  return O
 
10.666666666666666, 11.812605, def gcejfjfgbdecebieiccdfffcaeccjecj(I):
  O = canvas(mostcolor(I), shape(I))
  for v in sorted(palette(I)-{mostcolor(I)}):
    for (i, j) in sorted(ofcolor(I, v)):
      target_i = next((x for x in range(i+1) if all(index(O, (x, y)) == mostcolor(I) for y in range(j, j+1))), i)
      target_j = next((y for y in range(width(I)) if index(O, (target_i, y)) == mostcolor(I)), width(I))
      O = paint(O, {(v, (target_i, target_j))})
  return O
 
10.333333333333334, 7.114615, def ceffjafadcefebaaadccjeiheijafajf(I):
  O = canvas(mostcolor(I), shape(I))
  for v in sorted(palette(I)-{mostcolor(I)}):
    obj = recolor(v, ofcolor(I, v))
    target_i = next((i for i in range(height(I)) if all(index(O, (i, j)) == mostcolor(I) for j in range(width(I)))), 0)
    target_j = next((j for j in range(width(I)) if index(O, (target_i, j)) == mostcolor(I)), 0)
    O = paint(O, shift(obj, (target_i-uppermost(obj), target_j-leftmost(obj))))
  return O
 
11.333333333333334, 8.53769, def cjgaebfecefaegbbabicafbgahejhbbi(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(objects(I, True, True, True), key=lambda obj: (color(obj), -height(obj)*width(obj))):
    target_i = next((i for i in range(height(I)) if all(index(O, (i, j)) == mostcolor(I) for j in range(leftmost(obj), rightmost(obj)+1))), 0)
    target_j = next((j for j in range(width(I)) if index(O, (target_i, j)) == mostcolor(I)), 0)
    O = paint(O, shift(obj, (target_i-uppermost(obj), target_j-leftmost(obj))))
  return O
 
4.666666666666667, 5.6489787, def cfdccafdbiaceddcjchbdejeceijeiac(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c == 3:
      O = move(O, obj, (0, -rightmost(obj)))
    elif c == 6:
      O = move(O, obj, (-lowermost(obj), width(I)-rightmost(obj)-1))
    elif c == 8:
      O = move(O, obj, (-lowermost(obj), width(I)-rightmost(obj)))
      O = paint(O, {(2, (uppermost(obj), rightmost(obj) + 1)), (2, (uppermost(obj), rightmost(obj) + 2))})
    elif c == 1:
      O = move(O, obj, (0, 1))
  return O
 
4.0, 6.386826, def ideiahbiibaeejbjjhaccbdaaahbdibi(I):
  O = canvas(mostcolor(I), shape(I))
  for c in sorted(palette(I)):
    for obj in objects(I, T, T, T):
      if color(obj) == c:
        if c == 3:
          O = paint(O, shift(obj, (0, -rightmost(obj))))
        elif c == 6:
          O = paint(O, shift(obj, (-lowermost(obj), width(I)-rightmost(obj)-1)))
        elif c == 8:
          O = paint(O, shift(obj, (-lowermost(obj), width(I)-rightmost(obj))))
          O = paint(O, {(2, (0, width(O)-2)), (2, (0, width(O)-1))})
        elif c == 1:
          O = paint(O, shift(obj, (0, 1)))
        else:
          O = paint(O, obj)
  return O
 
4.333333333333333, 6.339051, def jjibciaejhecejhbahgebebgifajjfaj(I):
  O = I
  for obj in objects(I, T, T, T):
    if color(obj) == 3:
      O = paint(cover(O, obj), shift(obj, (0, -rightmost(obj))))
    elif color(obj) == 6:
      O = paint(cover(O, obj), shift(obj, (-lowermost(obj), width(I)-rightmost(obj)-1)))
    elif color(obj) == 8:
      O = paint(cover(O, obj), shift(obj, (-lowermost(obj), width(I)-rightmost(obj))))
      O = paint(O, {(2, (0, width(O)-2)), (2, (0, width(O)-1))})
    elif color(obj) == 1:
      O = paint(cover(O, obj), shift(obj, (0, 1)))
  return O
 
9.0, 11.619731, def aifcaggbfgcdeibjiafgadfacdejiggd(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    colors = []
    for i in range(height(I)):
      if I[i][j] != mostcolor(I) and I[i][j] not in colors:
        colors.append(I[i][j])
    for k, v in enumerate(colors):
      O = paint(O, {(v, (k, j))})
  return O
 
8.333333333333334, 6.6720653, def fffeaeefefcjehecifaaaabfheffdbde(I):
  O = I
  for j in range(width(I)):
    temp = []
    for i in range(height(I)):
      if I[i][j] != mostcolor(I):
        temp.append(I[i][j])
    for i in range(len(temp)):
      O = paint(cover(O, {(I[i][j], (i, j))}), {(temp[i], (i, j))})
  return O
 
9.333333333333334, 11.414379, def geiffadfiacaegbcidecgaeffeefhchc(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    k = 0
    for i in range(height(I)):
      v = I[i][j]
      if v != mostcolor(I):
        O = paint(O, {(v, (k, j))})
        k += 1
  return O
 
7.0, 4.843273, def ffhdigacceggeggiacbabhcbdcbccbef(I):
  O = I
  for j in range(width(I)):
    col = crop(O, (0, j), (height(O), 1))
    non_bg_colors = list(palette(col) - {mostcolor(I)})
    O = cover(O, asindices(col))
    for i, v in enumerate(non_bg_colors):
      O = paint(O, {(v, (i, j))})
  return O
 
3.6666666666666665, 6.4842424, def acadcbhadgcgebeibddaibbcafbhceec(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  moved_digits = set()
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != bg and (v, (i, j)) not in moved_digits:
        if v == 6 and size(I) == astuple(4, 4):
          if j == 0: # Left '6'
            O = paint(O, {(v, (0, 3))})
            moved_digits.add((v, (i, j)))
          else:  # Right '6'
            O = paint(O, {(v, (i - 1, 3))})
            moved_digits.add((v, (i, j)))
        elif v == 8:
          if i == 2 and j == 1:  # Top '8'
            O = paint(O, {(v, (i, j + 1))})
            moved_digits.add((v, (i, j)))
          elif i == 3 and j == 0:  # Bottom '8'
            O = paint(O, {(v, (i, j + 2))})
            moved_digits.add((v, (i, j)))
            O = paint(O, {(2, (i, j + 3))})  # Add first '2'
            O = paint(O, {(2, (i, j + 4))})  # Add second '2'
        elif v == 3: # Move '3' to the right
          O = paint(O, {(v, (i, j + 1))})
          moved_digits.add((v, (i, j)))
        elif v == 4: # Move '4' 
          O = paint(O, {(v, (i - 1, 3))})
          moved_digits.add((v, (i, j)))
        else:
          O = paint(O, {(v, (i, j))})
  return O
 
4.666666666666667, 6.0169916, def dbhheidbeejgefbbbhafcafdjheiffcf(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in sorted(fgpartition(I), key=lambda x: (color(x), -uppermost(x), -leftmost(x))): # Prioritize by color, top-left position
    c = color(obj)
    if c == 6 and size(I) == astuple(4, 4):
      if uppermost(obj) == 2:
        O = paint(O, shift(obj, (0, width(I) - 1 - leftmost(obj))))
      else:
        O = paint(O, shift(obj, (-1, width(I) - 1 - leftmost(obj))))
    elif c == 8:
      if uppermost(obj) == 2:
        O = paint(O, shift(obj, (0, 1)))
      else:
        O = paint(O, shift(obj, (0, 2)))
        O = paint(O, {(2, (3, 3))})
        O = paint(O, {(2, (3, 4))})
    elif c == 3:
      O = paint(O, shift(obj, (0, 1)))
    elif c == 4:
      O = paint(O, shift(obj, (-1, width(I) - 1)))
    else:
      O = paint(O, obj)
  return O
 
3.6666666666666665, 4.5040545, def acdgdcafhdcaebcibdjaeaejebfffcec(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != bg:
        if v == 6:
          O = paint(O, {(v, (i - (j > 0), 3))}) # Adjust row based on column
        elif v == 8:
          O = paint(O, {(v, (i, j + i - 2))}) # Move right based on row
          if i == 3:
            O = paint(O, {(2, (i, 3))})
            O = paint(O, {(2, (i, 4))})
        elif v == 3:
          O = paint(O, {(v, (i, j + 1))})
        elif v == 4:
          O = paint(O, {(v, (i - 1, 3))})
        else:
          O = paint(O, {(v, (i, j))})
  return O
 
5.333333333333333, 4.292928, def aacgbacfgdggedbcigjcffaecaaheaef(I):
  O = canvas(ZERO, shape(I))  # Empty canvas
  ref_obj = toobject(ofcolor(I, FIVE), I)  # Reference 5-object
  for obj in objects(I, T, T, T):
    if color(obj) != FIVE:
      movement = gravitate(obj, ref_obj)
      O = paint(O, shift(obj, movement))
  return paint(O, ref_obj)
 
7.0, 31.321356, def bceachbfehdjefieagaeafgjfgbeadec(I):
    O = canvas(mostcolor(I), shape(I))
    for c in sorted(palette(I) - {mostcolor(I)}):
        for obj in sizefilter(objects(I, True, True, True), 1):
            if color(obj) == c:
                target_i = next((i for i in range(len(O)) if all(index(O, (i, j)) == mostcolor(I) for j in range(len(O[0])))), 0)
                target_j = next((j for j in range(len(O[0])) if index(O, (target_i, j)) == mostcolor(I)), len(O[0]))
                O = paint(O, shift(obj, (target_i - uppermost(obj), target_j - leftmost(obj))))
    return O
 
8.666666666666666, 11.252024, def gfcfigbfhbbfegfaiehifcahcdgccegb(I):
    O = canvas(mostcolor(I), shape(I))
    offset = (0, 0)
    for c in sorted(palette(I) - {mostcolor(I)}):
        for obj in objects(I, True, True, True):
            if color(obj) == c:
                occurrence = first(occurrences(I, obj))
                O = paint(O, shift(obj, subtract(offset, occurrence)))
                offset = add(offset, (0, width(obj)))
    return O
 
5.666666666666667, 5.221205, def idhfdddhffjaeddgjabbefdbjhchbgfa(I):
  O = I
  for obj in objects(I, T, T, T):
    c = color(obj)
    if c == 3:
      O = move(O, obj, (-rightmost(obj)+width(obj)-1, 0))
    elif c == 6:
      O = move(O, obj, (0, width(I)-rightmost(obj)-1))
    elif c == 8:
      O = move(O, obj, (-lowermost(obj), 0))
      O = paint(O, {(2, (0, width(O)-2)), (2, (0, width(O)-1))})
    elif c == 1:
      O = move(O, obj, (0, 1))
  return O
 
5.333333333333333, 5.0749497, def dfdaedfffegaecbdihhdefiafdaaadea(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    if color(obj) == 3:
      O = paint(O, shift(obj, (-rightmost(obj)+width(obj)-1, 0)))
    elif color(obj) == 6:
      O = paint(O, shift(obj, (0, width(I)-rightmost(obj)-1)))
    elif color(obj) == 8:
      O = paint(O, shift(obj, (-lowermost(obj), 0)))
      O = paint(O, {(2, (0, width(O)-2)), (2, (0, width(O)-1))})
    elif color(obj) == 1:
      O = paint(O, shift(obj, (0, 1)))
    else:
      O = paint(O, obj)
  return O
 
3.6666666666666665, 11.41458, def babhgdfcceffeeibbbdaegiifaiaafdf(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    non_bg_objects = sorted(
      sfilter(objects(I, True, True, True), lambda o: leftmost(o) == j), 
      key=lambda o: uppermost(o)
    )
    next_i = 0
    for obj in non_bg_objects:
      O = paint(O, shift(normalize(obj), (next_i, j - leftmost(obj))))
      next_i += height(obj)
  return O
 
