10.974034def gbagehdcffbbebbbbffcbcbcgajegbdg(I):
  objs = objects(I, False, False, True) # Get all objects excluding background
  bg = mostcolor(I) # Get background color
  O = I
  for obj in objs:
    for direction in [(0,1)]: # Check only rightward extension
      shifted_obj = shift(obj, direction)
      intersection = toindices(shifted_obj) & asindices(I) # Check for intersection with grid
      if intersection: # If the shifted object intersects the grid
        shifted_obj = toobject(intersection, I) # Get actual values from the grid
        if color(shifted_obj) == bg: # If the intersection is with the background
          O = paint(O, recolor(color(obj), intersection)) # Paint the extension
  return O

8.341943def fcahgajbjcffeggciieedjbcedafffib(I):
  O = I
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w - 1): # Iterate till the second last column
      if I[i][j] != mostcolor(I) and I[i][j + 1] == mostcolor(I): 
        O = fill(O, I[i][j], {(i, j + 1)}) # Fill right cell with the current object's color
  return O

32.32506def icbcfiehhdfdefieagfcbaejafjbdbfb(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  O = I
  for obj in objs:
    for (i, j) in toindices(obj):
      for k in range(j + 1, width(I)): # Check for extension from current column to the right edge
        if I[i][k] == bg:
          O = fill(O, color(obj), {(i, k)})
        else:
          break # Stop extending if another object is encountered
  return O

23.283365def ddhiffceaeeieaefbbbhcgaecgaacieb(I):
  O = canvas(mostcolor(I), shape(I)) # Start with a canvas filled with background color
  for obj in objects(I, False, False, True):
    O = paint(O, obj) # Paint each object onto the canvas from left to right
  return O

42.16702def icciadjcaaabefcabebcghibagfdddbf(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    
    def extend_object(obj):
        color = first(obj)[0]
        top_i = uppermost(obj)
        bottom_i = lowermost(obj)
        left_j = leftmost(obj)
        right_j = rightmost(obj)
        
        for i in range(top_i - 1, -1, -1):
            if index(I, (i, left_j)) != bg:
                break
            obj = obj | {(color, (i, left_j))}
        for i in range(bottom_i + 1, len(I)):
            if index(I, (i, left_j)) != bg:
                break
            obj = obj | {(color, (i, left_j))}
        for j in range(left_j - 1, -1, -1):
            if index(I, (top_i, j)) != bg:
                break
            obj = obj | {(color, (top_i, j))}
        for j in range(right_j + 1, len(I[0])):
            if index(I, (top_i, j)) != bg:
                break
            obj = obj | {(color, (top_i, j))}
        return obj

    extended_objs = frozenset({extend_object(obj) for obj in objs})
    O = paint(I, merge(extended_objs))
    return O

33.59042def beccebjjbcafecddadfegbedahdgafaj(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    
    def extend_direction(obj, direction):
        color = first(obj)[0]
        start = centerofmass(obj)
        while True:
            start = add(start, direction)
            if index(I, start) != bg:
                break
            obj = obj | {(color, start)}
        return obj

    extended_objs = frozenset({
        extend_direction(extend_direction(obj, UP), DOWN)
        if portrait(obj)
        else extend_direction(extend_direction(obj, LEFT), RIGHT)
        for obj in objs
    })
    O = paint(I, merge(extended_objs))
    return O

23.283365def cejicbccbdfaebeaabfdafaibdfhfdbc(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    
    def extend_until_obstacle(obj, direction):
        color = first(obj)[0]
        frontier = toindices(obj)
        while True:
            new_frontier = mapply(lambda loc: add(loc, direction), frontier)
            if len(intersection(new_frontier, ofcolor(I, bg))) != len(new_frontier):
                break
            frontier = new_frontier
            obj = obj | recolor(color, frontier)
        return obj
    
    extended_objs = frozenset({
        extend_until_obstacle(extend_until_obstacle(obj, UP), DOWN)
        if portrait(obj)
        else extend_until_obstacle(extend_until_obstacle(obj, LEFT), RIGHT)
        for obj in objs
    })
    O = paint(I, merge(extended_objs))
    return O

22.469046def jaceggcedcfbebbdjifiidbhabbeedia(I):
  objs = objects(I, T, F, F) # Identify all objects in the grid
  out_grid = I 
  for obj in objs:
    color_val = color(obj)
    row_objs = sfilter(objs, lambda o: uppermost(o) == uppermost(obj) and color(o) == color_val) # Objects in the same row with the same color
    if size(row_objs) > 1:
      rightmost_obj = argmax(row_objs, rightmost)
      leftmost_obj = argmin(row_objs, leftmost)
      if obj == rightmost_obj: # Extend object right only if it's the rightmost one
        connection_line = connect(lrcorner(obj), ulcorner(leftmost_obj)) # Line connecting the objects
        out_grid = fill(out_grid, color_val, connection_line) # Fill the connecting line
  O = out_grid
  return O

11.164088def jdddcjbebcadefffjdbbijiigibiacej(I):
  O = I
  for i in range(height(I)):
    row = I[i]
    for j in range(width(I)-1):
      if row[j] != 0 and row[j] == row[j+1]:
        O = fill(O, row[j], frozenset({(i,k) for k in range(j, width(I))}))
  return O

23.492815def dgjeaabcbbbieeaeicgccjafciecdfaa(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, F):
    O = paint(O, obj)
    for x in range(leftmost(obj) + 1, width(I)):
      if index(I, (uppermost(obj), x)) == color(obj):
        O = fill(O, color(obj), frozenset({(uppermost(obj), y) for y in range(leftmost(obj), x + 1)}))
        break
  return O

23.283365def bhcecbeiffcbedfdadcebcaefbfbbejb(I):
    grid = list(list(row) for row in I)
    for i, row in enumerate(grid):
        for j in range(len(row) - 1):
            if row[j] != 0 and row[j] == row[j + 1]:
                for k in range(j + 1, len(row)):
                    if row[k] == row[j]:
                        grid[i][k] = row[j]
    return tuple(tuple(row) for row in grid)

22.08667def jbadhcdfejajecbfjdbcifedbdjbccgg(I):
    objs = objects(I, T, T, T)
    lines = mapply(lambda obj: frozenset((color(obj), (uppermost(obj), j)) for j in range(leftmost(obj), rightmost(obj) + 1)), objs)
    O = paint(I, lines)
    return O

32.32506def aecbjceaeeaheffaajechdgbeajigdcd(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  filled_grid = I
  for obj in objs:
    for _, (i, j) in sorted(obj, key=lambda x: x[1][1]):
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) == bg:
          filled_grid = fill(filled_grid, color(obj), {(i, k)})
        else:
          break
  O = filled_grid
  return O

32.35286def gaajfaafffjcedfeifijedjifciafcea(I):
    objs = objects(I, True, False, True)
    bg = mostcolor(I)
    new_grid = canvas(bg, shape(I))
    for obj in objs:
        leftmost_j = leftmost(obj)
        for _, (i, j) in obj:
            new_grid = fill(new_grid, color(obj), {(i, k) for k in range(leftmost_j, width(I))})
    O = new_grid
    return O

31.704872def bddfciadaefcefdhibfjdfceafcbejfa(I):
    modified_grid = I
    for i in range(height(I)):
        for j in range(width(I) - 1):
            if index(I, (i, j)) != mostcolor(I) and index(I, (i, j + 1)) == mostcolor(I):
                modified_grid = fill(modified_grid, index(I, (i, j)), {(i, k) for k in range(j + 1, width(I))})
    O = modified_grid
    return O

32.302124def cdidaichafjeeciajdfigebbfigcdhea(I):
  O = I 
  objs = objects(I, True, False, True) # Get objects excluding background
  for obj in objs:
    rightmost_j = rightmost(obj) 
    for j in range(rightmost_j + 1, width(I)): # Iterate from rightmost cell to edge
      shifted_obj = shift(obj, (0, j - rightmost_j)) 
      if not any(index(I, (i, j)) != mostcolor(I) for v, (i, j) in shifted_obj): 
        O = paint(O, shifted_obj) # Paint if the path is clear
  return O

60.697186def ffdgebfafhfdeaaibdbdddfbaaiejaji(I):
  O = canvas(mostcolor(I), shape(I)) # Canvas with background color
  objs = sorted(objects(I, True, False, True), key=lambda obj: leftmost(obj))
  for obj in objs:
    for x, (i, j) in obj:
      for k in range(j, width(I)):
        if index(I, (i, k)) == mostcolor(I):
          O = fill(O, x, {(i, k)})
        else:
          break 
  return O

61.038986def agjgfecddhdbebhfbcbbgegdigagfefd(I):
    for color in palette(I) - {mostcolor(I)}:
        for _ in range(max(height(I), width(I))):
            for direction in [RIGHT, LEFT, UP, DOWN]:
                obj = toobject(ofcolor(I, color), I)
                shifted_obj = shift(obj, direction)
                if len(obj & shifted_obj) > 0:
                    I = paint(I, recolor(color, toindices(shifted_obj)))
    O = I
    return O

24.146906def faeahdjfaahaedahaccbcdbjejdcgiab(I):
  objs = objects(I, True, True, False)
  for obj in objs:
    for (v, (i, j)) in obj:
       if index(I, (i + 1, j + 1)) == v:
         O = fill(I, v, connect((i, j), (i + height(I), j + width(I))))
  return O

20.654606def iedfffbchfffedbabjdefjfdhicbdecc(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, True, False):
    shifted_obj = shift(obj, (height(obj), width(obj)))
    merged_obj = obj | shifted_obj
    O = paint(O, merged_obj) 
  return O

22.864756def cccidcacacefebfajdddfeheghafcdea(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if index(O, (i, j)) != 0:
        diag_line = connect((i, j), (i + 9, j + 9))
        O = fill(O, index(O, (i, j)), frozenset((x, y) for x, y in diag_line if 0 <= x < height(I) and 0 <= y < width(I)))
  return O

16.750992def aafaefeeijfhejaaiedidcagdhbeifaf(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    new_objs = set()
    for obj in objs:
        color = first(obj)[0]
        leftmost_j = leftmost(obj)
        for j in range(leftmost_j + 1, width(I)):
            if index(I, (uppermost(obj), j)) == color:
                obj = obj | recolor(color, connect((leftmost(obj), uppermost(obj)), (j, uppermost(obj))))
                break
        new_objs.add(obj)
    O = paint(canvas(bg, shape(I)), merge(new_objs))
    return O

23.283365def addebjjfdjffebceiagefdehhafbfdbd(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    for obj in objs:
        for x in range(1, width(I)):
            shifted_obj = shift(obj, (0,x))
            intersection = toindices(shifted_obj) & toindices(obj)
            if intersection:
                obj = obj | recolor(color(obj), connect(ulcorner(obj),urcorner(shifted_obj)))
                break
    O = paint(canvas(bg, shape(I)), merge(objs))
    return O

32.788734def eabccjbfhcdfefhdidgfghjcbcaeahaa(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    new_grid = canvas(bg, shape(I))
    for obj in objs:
        c = color(obj)
        start_j = leftmost(obj)
        end_j = start_j
        for j in range(start_j + 1, width(I)):
            if index(I, (uppermost(obj), j)) == c:
                end_j = j
        new_grid = fill(new_grid, c, connect((uppermost(obj), start_j), (uppermost(obj), end_j)))
    return new_grid

11.164088def adcbeccfagfdebdfjibccccicdicfbbf(I):
    for row in range(height(I)):
        for col in range(width(I) - 1):
            if index(I, (row, col)) != mostcolor(I) and index(I, (row, col + 1)) == index(I, (row, col)):
                I = fill(I, index(I, (row, col)), connect((row, col), (row, width(I) - 1)))
    return I

21.50529def beiahfgaecbbecbhadefaajfadebeced(I):
    objs = objects(I, F, F, F)
    bg = mostcolor(I)
    for obj in objs:
        val = color(obj)
        if val != bg:
            for (i, j) in toindices(obj):
                for k in range(j+1, width(I)):
                    if index(I, (i, k)) != bg:
                        break
                    I = fill(I, val, {(i, k)})
    O = I
    return O

30.071901def ddfibeheaagfecebbhiagadabfidcaaa(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I)-1):
            if index(O, (i, j)) != mostcolor(I) and index(O, (i, j+1)) == mostcolor(I):
                O = fill(O, index(O, (i, j)), {(i, k) for k in range(j+1, width(I))})
    return O 

35.14136def aadjccdjhbbhedjgiffacifgdcchbffa(I):
    h, w = shape(I)
    grid = list(list(row) for row in I)
    for i in range(h):
        for j in range(w - 1, -1, -1):
            if grid[i][j] != mostcolor(I):
                for k in range(j - 1, -1, -1):
                    if grid[i][k] == mostcolor(I):
                        grid[i][k] = grid[i][j]
                    else:
                        break
    return tuple(tuple(row) for row in grid) 

17.169735def cbcedbebdfageadabicjgaaeaicdgfff(I):
  for obj in objects(I, True, False, True):  # Iterate over foreground objects
    direction = (0, 1) if hline(obj) else (1, 0)  # Determine extension direction based on object shape
    for _ in range(max(height(I), width(I))):
      new_obj = shift(obj, direction)
      if len(intersection(toindices(new_obj), asindices(I))) == 0:  # Check if new_obj is out of bounds
        break
      if any(index(I, (i, j)) != mostcolor(I) for i, j in toindices(new_obj)):  # Check for collision
        break
      obj = new_obj
    I = paint(I, obj)  # Paint the extended object
  return I

15.907109def fcgeccbebaffeidbjcdcjbddbjgcecbc(grid):
  objs = objects(grid, T, F, T)
  target_color = color(first(objs))
  filled_grid = grid
  for obj in objs:
    if color(obj) == target_color:
      start_j = leftmost(obj)
      end_j = rightmost(obj)
      filled_grid = fill(filled_grid, target_color, {(i, j) for i in range(height(grid)) for j in range(start_j, end_j + 1)})
  return filled_grid

34.408413def hcadefhhgecjebfeadfebfbfbecacgfc(grid):
  target_color = index(grid, (0, 0))
  return tuple(tuple(target_color if target_color in row else cell for cell in row) for row in grid)

30.78704def cgdhfiaaebbeecdfbahgacaedcjgjbif(grid):
  objs = objects(grid, True, False, True)
  target_obj = first(objs)
  target_color = color(target_obj)
  filled_indices = set()
  for i in range(height(grid)):
    for obj in objs:
      if color(obj) == target_color and hmatching({(i, 0)}, obj):
        filled_indices |= {(i, j) for j in range(width(grid))}
  return fill(grid, target_color, frozenset(filled_indices)) 

24.674664def egcfjfbcadcbeaiajbaeefbadahadhba(grid):
  target_color = index(grid, (0, 0))
  return tuple(tuple(cell if cell != 0 else target_color for cell in row) for row in grid)

17.15629def cgjiagddeajaedjbjdifihgadhbaeiie(grid):
  objs = objects(grid, T, F, T)
  target_color = color(argmin(objs, size))
  h = height(grid)
  filled_indices = set()
  for j in range(width(grid)):
    for obj in objs:
      if color(obj) == target_color and contained((0, j), toindices(obj)):
        filled_indices |= {(i, j) for i in range(h)}
  return fill(grid, target_color, frozenset(filled_indices))

41.844345def dcdaecfghfgaedacaifbfddjgaafbgcf(I):
  x1 = objects(I, T, T, T) # Identify all objects
  x2 = apply(lambda obj: (leftmost(obj), rightmost(obj), color(obj)), x1)  # Get leftmost, rightmost columns, and color of each object
  x3 = apply(lambda x: frozenset((x[2], (i, j)) for i in range(len(I)) for j in range(x[0], x[1] + 1)), x2)  # Create horizontal lines for each object
  x4 = mapply(identity, x3) # Merge all lines
  O = paint(I, x4) # Paint the lines onto the input grid
  return O

42.125187def hcdcghcgidiceifaiajjaijhefbbjbeb(I):
  x1 = objects(I, T, T, T)  # Identify all objects
  x2 = apply(lambda obj: ((uppermost(obj), leftmost(obj)), color(obj)), x1)  # Get top-left corner and color for each object
  x3 = apply(lambda x: frozenset((x[1], (x[0][0], j)) for j in range(len(I[0]))), x2)  # Create horizontal lines at the top row of each object, spanning the entire grid width
  x4 = mapply(identity, x3)  # Merge the lines
  O = paint(I, x4)  # Paint the lines onto the input grid
  return O

26.941948def efdfecafaaceedheacbcjdgcdjdcbcej(I):
    objs = objects(I, T, F, T) 
    for obj in objs:
        if width(obj) >= height(obj):  # Extend horizontally if wider
            O = fill(I, color(obj), connect(ulcorner(obj), (ulcorner(obj)[0], width(I)-1)))
        else:  # Extend vertically if taller
            O = fill(I, color(obj), connect(ulcorner(obj), (height(I)-1, ulcorner(obj)[1])))
        I = O 
    return O

30.071901def degiicfcgcaheiccbhebjefjfaachchc(I):
    for row in range(height(I)):
        for col in range(width(I)):
            if index(I, (row, col)) != mostcolor(I): # Check if it's not background
                obj = extract(objects(I, T, F, T), lambda x: (row, col) in toindices(x)) # Find the object at this location
                if width(obj) >= height(obj):
                    I = fill(I, color(obj), connect((row, col), (row, width(I)-1)))
                else:
                    I = fill(I, color(obj), connect((row, col), (height(I)-1, col)))
    return I

16.559256def cafbdedbadbcecdebcejgdfhfbfdhdjf(I):
    objs = objects(I, T, F, T)
    for obj in objs:
        direction = (0, 1) if width(obj) >= height(obj) else (1, 0) # Determine direction based on shape
        start = ulcorner(obj)
        while True:
            next_cell = add(start, direction) # Get the next cell in the direction
            if index(I, next_cell) is not None and index(I, next_cell) == mostcolor(I): 
                I = fill(I, color(obj), {next_cell}) # Fill if within bounds and background
                start = next_cell
            else:
                break # Stop extending if hitting another object or grid edge
    return I

7.710466def ibegdefcafjeegfabahdfdfdecgfeadb(I):
    objs = objects(I, T, F, T)
    for obj in objs:
        if width(obj) >= height(obj):
            line = connect(ulcorner(obj), (ulcorner(obj)[0], rightmost(obj) + width(obj)))
            I = fill(I, color(obj), intersection(toindices(line), asindices(I))) # Extend only within grid
        else:
            line = connect(ulcorner(obj), (lowermost(obj) + height(obj), ulcorner(obj)[1]))
            I = fill(I, color(obj), intersection(toindices(line), asindices(I)))
    return I

11.835057def fbgeacafahdgebbdiadcggedfdfgbebd(I):
    def extend_object(obj):
        if width(obj) >= height(obj):
            return fill(I, color(obj), connect(ulcorner(obj), (ulcorner(obj)[0], width(I)-1)))
        return fill(I, color(obj), connect(ulcorner(obj), (height(I)-1, ulcorner(obj)[1])))
    return last(apply(extend_object, objects(I, T, F, T))) # Apply extension and return the last modified grid

10.509236def afecddjbaiebebfajaiajhfeaeificef(I):
    for i in range(height(I)):
        for j in range(width(I)-1):
            if I[i][j] != mostcolor(I) and I[i][j] == I[i][j+1]:
                I = underfill(I, I[i][j], {(i, k) for k in range(j+2, width(I))})
    for j in range(width(I)):
        for i in range(height(I)-1):
            if I[i][j] != mostcolor(I) and I[i][j] == I[i+1][j]:
                I = underfill(I, I[i][j], {(k, j) for k in range(i+2, height(I))})
    O = I
    return O

13.781828def efjhabdddfbgefaijbdgabahadhadacc(I):
    objs = objects(I, T, F, T)
    for obj1 in objs:
        c = color(obj1)
        for obj2 in objs:
            if color(obj2) == c and obj1 != obj2:
                min_i = min(uppermost(obj1), uppermost(obj2))
                max_i = max(lowermost(obj1), lowermost(obj2))
                min_j = min(leftmost(obj1), leftmost(obj2))
                max_j = max(rightmost(obj1), rightmost(obj2))
                if max_i - min_i + 1 == len(obj1) + len(obj2) or max_j - min_j + 1 == len(obj1) + len(obj2):
                    for i in range(min_i, max_i + 1):
                        for j in range(min_j, max_j + 1):
                            if I[i][j] == mostcolor(I):
                                I = underfill(I, c, {(i, j)})
    O = I
    return O

32.32506def gaahjdcjhdbcecabacfcbijbbebgacde(I):
  O = I
  for i in range(height(I)): # Iterate through each row
    current_color = None
    for j in range(width(I)): # Iterate through each column
      if index(O, (i,j)) != 0: # If a non-zero digit is encountered
        current_color = index(O, (i,j)) # Update the current color
      elif current_color is not None: # If current_color is set (meaning an object is being extended)
        O = fill(O, current_color, {(i, j)}) # Fill with the current_color
  return O

24.119871def dbfjadbfcgbjecfebjfadjdacfdbabib(I):
    O = canvas(0, shape(I)) # Create an empty canvas with the same shape as the input
    for obj in objects(I, T, F, F): # Get all objects in the grid
        start_j = leftmost(obj) # Find the leftmost column of the object
        for i in range(uppermost(obj), lowermost(obj) + 1): # Iterate through each row in the object
            for j in range(start_j, width(I)): # Iterate through columns from the start to the right edge
                if j == start_j or index(I, (i, j)) == color(obj): # Fill the cell if it's the starting cell or has the same color as the object
                    O = fill(O, color(obj), {(i, j)})
                else:
                    break # Stop extending if a different color or empty cell is encountered
    return O

20.941689def bcgiebibgbheeejdibjddjfcihbaadjc(I):
  modified_grid = canvas(mostcolor(I), shape(I)) # Create a blank canvas with the background color
  objs = objects(I, T, T, T)
  for obj in objs:
    left_j = leftmost(obj)
    right_j = rightmost(obj)
    for i in range(uppermost(obj), lowermost(obj) + 1):
      modified_grid = paint(modified_grid, {(color(obj), (i, j)) for j in range(left_j, right_j + 1)}) # Paint a horizontal line
  O = modified_grid
  return O

18.756247def idefjcidjdigedjcahfgjidjehfcjbcf(I):
    objs = objects(I, T, F, T) 
    for obj in objs:
        c = color(obj)
        if width(obj) >= height(obj): 
            I = fill(I, c, connect(ulcorner(obj), (ulcorner(obj)[0], rightmost(obj) + width(obj) - 1)))
        else:
            I = fill(I, c, connect(ulcorner(obj), (lowermost(obj) + height(obj) - 1, ulcorner(obj)[1])))
    return I

16.390427def beeachbbjdbaejfcihhfbcdhjbbfdfde(I):
    O = I 
    for obj in objects(I, T, F, T):
        w, h = shape(obj)
        O = paint(O, recolor(color(obj), backdrop(shift(normalize(obj), (0, w - 1) if w >= h else (h - 1, 0)))))
    return O

16.464525def aijaebceddeaeiecicahcacccjebecaf(I):
  O = I
  for obj in objects(I, T, F, T):
    direction = (0, width(obj) - 1) if width(obj) >= height(obj) else (height(obj) - 1, 0)
    O = paint(O, recolor(color(obj), backdrop(shift(obj, direction))))
  return O 

11.471505def efdaccbgidadegfhjafcebdgdecfhahb(I):
  # Identify objects and their colors
  objs = objects(I, F, F, T)
  colors = list(palette(I))
  
  # Find the least common color excluding background
  least_color = min(colors[1:], key=lambda c: colorcount(I, c))

  # Extend objects based on their color
  for obj in objs:
    color = first(obj)[0]
    if color == 1:
      # Extend horizontally to the right
      rightmost_j = rightmost(obj)
      extension = frozenset({(1, (i, j)) for i, j in product(range(uppermost(obj), lowermost(obj) + 1), range(rightmost_j + 1, width(I)))})
      I = paint(I, recolor(least_color, extension))
    elif color == 7:
      # Extend horizontally and vertically
      rightmost_j = rightmost(obj)
      bottommost_i = lowermost(obj)
      h_extension = frozenset({(7, (i, j)) for i, j in product(range(uppermost(obj), bottommost_i + 1), range(rightmost_j + 1, width(I)))})
      v_extension = frozenset({(7, (i, j)) for i, j in product(range(bottommost_i + 1, height(I)), range(leftmost(obj), rightmost(obj) + 1))})
      I = paint(I, recolor(7, h_extension | v_extension))

  O = I
  return O

10.31419def ibbgccajjdfceddaajbdfgddafjddicc(I):
    # Identify objects
    objs = objects(I, F, F, T)

    # Function to extend object to right edge
    def extend_right(obj, color):
      rightmost_j = rightmost(obj)
      extension = frozenset({(color, (i, j)) for i, j in product(range(uppermost(obj), lowermost(obj) + 1), range(rightmost_j + 1, width(I)))})
      return paint(I, recolor(color, extension))

    # Extend objects based on color
    for obj in objs:
      if color(obj) == 1:
        I = extend_right(obj, leastcolor(difference(asindices(I), toindices(obj))))
      elif color(obj) == 7:
        I = extend_right(obj, 7)

    O = I
    return O

36.98381def hedbbfdjbbaaeajbbebfcibiafbjfgec(I):
  objs = objects(I, T, F, T)  # Get all foreground objects
  for obj in objs:
    c = color(obj)
    same_color_objs = colorfilter(objs, c) - {obj}  # Find other objects of the same color
    if same_color_objs:
      closest_obj = argmin(same_color_objs, lambda x: manhattan(x, obj))  # Find the closest object
      direction = gravitate(obj, closest_obj)  # Get direction to move towards the closest object
      extension = shoot(centerofmass(obj), direction)  # Create a line extension in that direction
      I = underfill(I, c, extension)  # Fill the extension with the object's color, only on background
  O = I
  return O

19.948578def hffjfdeeafddeaiaaajbhabiebddccba(I):
    for c in palette(I) - {mostcolor(I)}:  # Iterate through each foreground color
        obj = toobject(ofcolor(I, c), I)  # Get the object of that color
        bg = delta(obj) # Get the background indices around the object
        if bg:
          closest_bg = argmin(bg, lambda x: manhattan({x}, obj))  # Find the closest background point to the object
          direction = gravitate({closest_bg}, obj)  # Get direction from closest background point to object
          extension = shoot(closest_bg, direction)  # Extend a line from the closest background point
          I = underfill(I, c, extension)  # Fill with the object's color, only on background
    O = I
    return O

37.884266def achfcgcjhffcefdcbfehjicddeaabddb(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    c = color(obj1)
    for obj2 in colorfilter(objs, c) - {obj1}:
      if manhattan(obj1, obj2) <= height(I): # Check if objects are close enough
        direction = gravitate(obj1, obj2)
        extension = shoot(centerofmass(obj1), direction)
        I = underfill(I, c, extension)
  O = I
  return O

5.6469817def febhgeefcdhjedabiaebaafbbhbbcchc(I):
    for c in palette(I) - {mostcolor(I)}:
        obj = toobject(ofcolor(I, c), I)
        bg = difference(backdrop(obj), toindices(obj))  # Calculate background within bounding box
        if bg:
          closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
          path = connect(closest_bg, centerofmass(obj))  # Connect closest background to object's center
          I = underfill(I, c, path)
    O = I
    return O

17.813452def dacdbhcdehhjedfijbcecbgjehaajbhd(I):
    objs = objects(I, T, F, T)
    for obj in objs:
        c = color(obj)
        same_color_objs = colorfilter(objs, c) - {obj}
        if same_color_objs:
            closest_obj = argmin(same_color_objs, lambda x: manhattan(x, obj))
            if manhattan(obj, closest_obj) <= max(height(I), width(I)) // 2: # Use maximum dimension for threshold
              direction = gravitate(obj, closest_obj)
              extension = set()
              for loc in toindices(obj):
                  ray = shoot(loc, direction)
                  extension.update(ray)
              I = underfill(I, c, frozenset(extension)) # Extend from all object points
    O = I
    return O

22.31243def igjfdfdefgcfeheijeaacaacdadafgab(I):
  objs = objects(I, T, T, T) # Identify all objects
  O = I
  for obj in objs:
    upper_i = uppermost(obj) # Row of the top-leftmost cell
    for j in range(leftmost(obj), rightmost(obj) + 1): # Iterate over columns within object bounds
      if (upper_i, j) in toindices(obj): # Check if cell is in the object and on the same row as top-left
        line = connect((upper_i, j), (lowermost(obj), j)) # Connect topmost and bottommost points in that column
        O = paint(O, recolor(color(obj), line)) # Paint the line with the object's color
  return O 

35.359386def eiaahfdfiehaecfgabadacdieacgjicc(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if width(obj) >= height(obj):
      I = fill(I, color(obj), 
               {(i,j) for i in range(height(I)) 
               for j in range(leftmost(obj), rightmost(obj) + width(obj))
               if index(I,(i,j)) == mostcolor(I)})
    else:
      I = fill(I, color(obj),
               {(i,j) for j in range(width(I))
               for i in range(uppermost(obj), lowermost(obj) + height(obj))
               if index(I,(i,j)) == mostcolor(I)})
  return I

5.6291313def feefdhiabegdeedabjcacdfjbdgcchcf(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      direction = sign(subtract(closest_bg, centerofmass(obj)))
      path = shoot(centerofmass(obj), direction)
      I = underfill(I, color(obj), path)
  O = I
  return O

20.409096def dcecahacffaaecfeahcgcaadadgbidfj(I):
  for value in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, value), I)
    for bg_cell in difference(backdrop(obj), toindices(obj)):
      if manhattan({bg_cell}, obj) == 1:
        I = underfill(I, value, connect(centerofmass(obj), bg_cell))
  O = I
  return O

32.461723def bdacjdiibicgegfhaiffjgifabbdchcb(I):
  O = I
  for obj in objects(I, T, F, F):
    rightmost_col = rightmost(obj)
    for (i, j) in toindices(obj):
      extension = frozenset({(i, x) for x in range(j + 1, rightmost_col + width(I))})
      O = underpaint(O, recolor(color(obj), extension)) 
  return O

23.225668def ahafgdbfhdaeehcfjghfhidhcecaebca(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    closest_dist = float('inf')
    closest_obj = None
    for obj2 in objs:
      if color(obj1) != color(obj2):
        dist = manhattan(obj1, obj2)
        if dist < closest_dist:
          closest_dist = dist
          closest_obj = obj2
    if closest_obj is not None:
      if hmatching(obj1, closest_obj):
        direction = (0, 1) if leftmost(obj1) < leftmost(closest_obj) else (0, -1)
      else:
        direction = (1, 0) if uppermost(obj1) < uppermost(closest_obj) else (-1, 0)
      extension = shoot(center(obj1), direction)
      I = fill(I, color(obj1), intersection(extension, backdrop(closest_obj)))
  return I

6.970263def ggdeiibcigiaejaaaeadfcbbicbghgca(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and (hmatching(obj1, obj2) or vmatching(obj1, obj2)):
        if hmatching(obj1, obj2):
          start = ulcorner(obj1) if leftmost(obj1) < leftmost(obj2) else urcorner(obj1)
          end = (start[0], other(corners(obj2), start)[1])
        else:
          start = ulcorner(obj1) if uppermost(obj1) < uppermost(obj2) else llcorner(obj1)
          end = (other(corners(obj2), start)[0], start[1])
        I = fill(I, color(obj1), connect(start, end))
  return I

41.242176def cbadfjcgicidejfaiaebfaecgeeabcba(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        grav = gravitate(obj1, obj2)
        if grav != (0, 0):
          I = fill(I, color(obj1), connect(center(obj1), add(center(obj1), grav)))
  return I

20.595892def iaajfhabeiabecgebdfagedjfadgjhda(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    extensions = set()
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) <= 2:
        extensions.add(gravitate(obj1, obj2))
    for ext in extensions:
      if ext != (0, 0):
        I = fill(I, color(obj1), connect(center(obj1), add(center(obj1), ext)))
  return I

22.917767def ddjfdbaggccaegigjffjfehbeeabfihc(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) == min(manhattan(obj1, obj3) for obj3 in objs if color(obj1) != color(obj3)):
        if hmatching(obj1, obj2):
          direction = (0, 1) if leftmost(obj1) < leftmost(obj2) else (0, -1)
        else:
          direction = (1, 0) if uppermost(obj1) < uppermost(obj2) else (-1, 0)
        extension = shoot(center(obj1), direction)
        I = fill(I, color(obj1), intersection(extension, backdrop(obj2)))
  return I

31.813457def gdcfgfdafgebegciibecgjaefffeefcb(I):
  for obj in objects(I, F, F, T):
    obj_color = color(obj)
    fill_color = obj_color
    if obj_color == 1:
      non_zero_colors = difference(palette(I), {0})
      fill_color = leastcommon(totuple(non_zero_colors))  # Convert frozenset to tuple for leastcommon
    I = paint(I, recolor(fill_color, 
                       frozenset({(i, j) 
                                 for i in range(uppermost(obj), lowermost(obj) + 1) 
                                 for j in range(rightmost(obj) + 1, width(I))})))
  return I

19.549448def ciaddaaiegceeficbijceeihbffdcdbb(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      if closest_bg[0] == centerofmass(obj)[0]:  # Same row
        direction = (0, sign(subtract(closest_bg, centerofmass(obj))[1]))
      else:  # Different row, assume same column
        direction = (sign(subtract(closest_bg, centerofmass(obj))[0]), 0)
      path = shoot(closest_bg, direction)
      I = underfill(I, color(obj), path)
  O = I
  return O

14.370998def bjjehaefiafeecdbibdebfaeaeefgjae(I):
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), I)
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      if closest_bg[0] == centerofmass(obj)[0]:
        path = connect(closest_bg, (closest_bg[0], rightmost(obj)))
      else:
        path = connect(closest_bg, (lowermost(obj), closest_bg[1]))
      I = underfill(I, c, path)
  O = I
  return O

19.22458def bfeedjfahajbehjhagbcaffjhbcfagec(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      h_distance = abs(closest_bg[1] - centerofmass(obj)[1])
      v_distance = abs(closest_bg[0] - centerofmass(obj)[0])
      if h_distance < v_distance: # Closer horizontally
        path = connect(closest_bg, (closest_bg[0], centerofmass(obj)[1]))
      else: # Closer vertically
        path = connect(closest_bg, (centerofmass(obj)[0], closest_bg[1]))
      I = underfill(I, color(obj), path)
  O = I
  return O

7.575467def bcdaegecaajiecceiadchifgegadaiie(I):
  for obj in fgpartition(I):
    bg = difference(asindices(I), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      path = connect(closest_bg, centerofmass(obj))
      steps = len(path)
      for i in range(1, steps):
        I = underfill(I, color(obj), {tuple(sorted(path))[i]})
  O = I
  return O

11.036535def echebeedgaejeeafbefbdcfhdedcdfhb(I):
    objs = objects(I, T, F, T)
    extended_objs = frozenset()
    for obj in objs:
        value = color(obj)
        if value == 1 or (value == 6 and lrcorner(obj)[0] == height(I) - 1):
            uppermost_row = uppermost(obj)
            for i, j in toindices(obj):
                extended_objs = extended_objs | frozenset({(value, (uppermost_row, k)) for k in range(j, width(I)) if index(I, (uppermost_row, k)) == 0})
        else:
            extended_objs = extended_objs | obj
    O = paint(canvas(0, shape(I)), extended_objs)
    return O

9.710849def adaicidcbdebeiebjebecadaibjicfdg(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1:
        for k in range(j+1, width(I)):
          if I[i][k] == 0:
            O = fill(O, 1, frozenset({(i,k)}))
          else:
            break
      elif I[i][j] == 6 and i == height(I) - 1:
        for k in range(j+1, width(I)):
          if I[i][k] == 0:
            O = fill(O, 6, frozenset({(i,k)}))
          else:
            break
  return O

37.834373def egbcbbdgigiieacjbcbgifcaeabfbefc(I):
  O = I
  for j in range(width(I)):  # Iterate over columns
    current_color = None
    start_i = None
    for i in range(height(I)):
      if index(I, (i, j)) != mostcommon(I) and current_color is None:  # New object cell encountered
        current_color = index(I, (i, j))
        start_i = i
      elif index(I, (i, j)) == mostcommon(I) and current_color is not None:  # End of continuous object segment
        O = paint(O, recolor(current_color, connect((start_i, j), (i - 1, j))))
        current_color = None
      elif i == height(I) - 1 and current_color is not None:  # Handle object reaching the bottom
        O = paint(O, recolor(current_color, connect((start_i, j), (i, j))))
  return O

27.17817def fddfddbabhghegdbiafbcejdfddfccca(I):
    objs = objects(I, True, False, True)  # Extract objects, not considering diagonals
    for obj in objs:
        right_edge = rightmost(obj) 
        for j in range(right_edge + 1, width(I)):  # Iterate from right edge to grid width
            next_cell = (uppermost(obj), j) 
            if index(I, next_cell) == 0:  # If the next cell is empty
                I = fill(I, color(obj), {next_cell})  # Fill with object color
            else:
                break  # Stop extending if another object is encountered
    return I 

31.84454def eaagaaicjbeaeefcafgefggdbfffacaf(I):
    objs = objects(I, True, False, True)
    for obj in objs:
        for j in range(rightmost(obj) + 1, width(I)):
            extension = {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1)}
            if not any(index(I, cell) != 0 for cell in extension):
                I = fill(I, color(obj), extension)
            else:
                break
    return I 

17.686918def dajfaeebjeajeaaajiifdddfifeehbhd(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      if hmatching(obj, {closest_bg}): # Check for horizontal alignment
        direction = sign(subtract(closest_bg, centerofmass(obj)))
        path = shoot(centerofmass(obj), (direction[0], 0)) # Force horizontal direction
        I = underfill(I, color(obj), path)
  O = I
  return O

16.726757def jecddgjcbcfeecchjfbeaacagcehaabf(I):
    for obj in fgpartition(I):
        for x in range(leftmost(obj), rightmost(obj) + 1): # Scan horizontally within object bounds
            loc = (centerofmass(obj)[0], x)  # Create a horizontal line of potential connection points
            if loc in delta(obj):
                I = underfill(I, color(obj), {loc})  # Fill only if the point is background 
    O = I
    return O

19.346533def fechddjajfaeejadbdacgedcfbdejfei(I):
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), I)
    h_projection = {(i, centerofmass(obj)[1]) for i, j in toindices(obj)} # Project object onto vertical line
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, h_projection))
      path = connect(closest_bg, (closest_bg[0], centerofmass(obj)[1])) # Connect vertically
      I = underfill(I, c, path)
  O = I
  return O

16.559256def bdedjehbdecfeaafjadfhfbdibbcehff(I):
    objs = objects(I, True, False, True)  # Extract univalued objects, excluding background
    filled_grid = I  # Initialize the output grid
    for obj in objs:
        left_j = leftmost(obj)  # Find the leftmost column of the object
        right_border = width(I)  # Get the right border of the grid
        for j in range(left_j + 1, right_border):
            next_loc = (uppermost(obj), j)  # Calculate the next location to the right
            if index(I, next_loc) == mostcolor(I):  # Check if the next location is background
                filled_grid = fill(filled_grid, color(obj), frozenset({next_loc}))  # Fill with object's color
            else:
                break  # Stop extending if another object is encountered
    O = filled_grid  
    return O

10.565047def acgcjgcdicffehbbjbeadgcehicgceef(I):
    objs = objects(I, True, False, True)
    O = I
    for obj in objs:
        for (i, j) in toindices(obj):
            right_frontier = hfrontier((i, j))
            for (fi, fj) in right_frontier:
                if fj >= width(I) or index(I, (fi, fj)) != mostcolor(I):
                    break
                O = fill(O, color(obj), frozenset({(fi, fj)}))
    return O

32.601116def idedihadaeifeiaiiacfbdcgcfgecbdf(I):
    def extend_right(obj):
        return frozenset((color(obj), (i, k)) 
                         for (i, j) in toindices(obj) 
                         for k in range(j, width(I)) 
                         if k == j or index(I, (i, k)) == mostcolor(I))
    
    objs = objects(I, True, False, True)
    extension = mapply(extend_right, objs)
    O = paint(I, extension)
    return O

23.283365def cfeebcacdaccedaejibbbjddcebicfdd(I):
  O = I  # Initialize output grid as input grid
  for i in range(height(I)):
    row = tuple(I[i]) # Get the current row
    for j in range(width(I) - 1):
      if row[j] == row[j + 1] and row[j] != mostcommon(I):
        O = fill(O, row[j], connect((i, j), (i, j + 1)))
  return O

13.474663def cdajedfjhediebddbgcccieiijjddgha(I):
    objs = objects(I, True, False, True)
    for obj in objs:
        direction = (1, 0) if width(obj) >= height(obj) else (0, 1) # Determine extension direction
        start = ulcorner(obj)
        current = start
        while True:
            next_cell = (current[0] + direction[0], current[1] + direction[1])
            if next_cell not in asindices(I) or index(I, next_cell) != mostcolor(I): # Stop at grid border or different color
                break
            current = next_cell
        I = fill(I, color(obj), connect(start, current))
    return I

14.322208def bigbbfcdefejefbgjjieeiicaibgdcfa(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest = argmin(bg, lambda x: manhattan({x}, obj))
      I = paint(I, recolor(color(obj), connect(center(obj), closest)))
  O = I
  return O 

14.43909def gjbdiabibhfbefidihefbbhggdeabbdf(I):
  objs = objects(I, True, False, True) # Extract all objects
  O = I
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and color(obj1) == color(obj2) and (hmatching(obj1, obj2) or vmatching(obj1, obj2)): # Check if two objects are of the same color and on the same row or column
        connection_line = connect(centerofmass(obj1), centerofmass(obj2)) # Connect their centers of mass 
        O = fill(O, color(obj1), connection_line) # Fill the connection line with the object's color
  return O

23.584366def ddebdcihabafejjcadfjdbibdbcebcag(I):
  O = I  # Initialize output as input
  objs = objects(I, T, T, T)  # Extract all objects
  for obj in objs:
    min_row, min_col = ulcorner(obj)
    max_row, max_col = lrcorner(obj)
    if max_col - min_col > 0:  # Horizontal line condition
      for i in range(min_row, max_row + 1):
        O = paint(O, recolor(index(I, (i, min_col)), connect((i, min_col), (i, max_col))))
    if max_row - min_row > 0:  # Vertical line condition
      for j in range(min_col, max_col + 1):
        O = paint(O, recolor(index(I, (min_row, j)), connect((min_row, j), (max_row, j))))
  return O

26.173988def faafccaaccadediabedcaffhgjcdifhb(I):
  return paint(I, merge({recolor(color(obj), connect(ulcorner(obj), (ulcorner(obj)[0], len(I[0])-1)))
                          if width(obj) >= height(obj)
                          else recolor(color(obj), connect(ulcorner(obj), (len(I)-1, ulcorner(obj)[1])))
                          for obj in objects(I, T, F, T)}))

6.983012def dcicafejcajceeffbcdcaacjigfgfbgf(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      direction = sign(subtract(closest_bg, center(obj))) # Determine direction
      path = shoot(center(obj), direction) # Extend in that direction
      I = underfill(I, color(obj), intersection(path, backdrop(obj))) # Fill only within bounding box
  return I

11.484097def ffddddchcjfgeeabjcbjiiaedicccefa(I):
  for obj in fgpartition(I):
    for (i, j) in toindices(obj):
      left_edge = leftmost(obj)
      right_edge = rightmost(obj)
      if i == uppermost(obj): # Only extend from the top row
        if j > 0 and I[i][j-1] == 0:
          I = underfill(I, color(obj), {(i, k) for k in range(left_edge, j)})
        if j < len(I[0]) - 1 and I[i][j+1] == 0:
          I = underfill(I, color(obj), {(i, k) for k in range(j + 1, right_edge + 1)})
  return I

9.552044def aaigcddcbiiheccbjfgeiecebfhgfbcf(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      target = argmin(bg, lambda x: abs(x[1] - center(obj)[1])) # Closest in terms of column
      path = connect(center(obj), target)
      I = underfill(I, color(obj), intersection(path, backdrop(obj)))
  return I

12.436956def cefhdcfcfdgiedajbbeefbfaefjfjdcc(I):
  for obj in fgpartition(I):
    center_cell = center(obj)
    left_path = {(center_cell[0], j) for j in range(center_cell[1], -1, -1)}
    right_path = {(center_cell[0], j) for j in range(center_cell[1], len(I[0]))}
    I = underfill(I, color(obj), intersection(left_path, backdrop(obj)))
    I = underfill(I, color(obj), intersection(right_path, backdrop(obj)))
  return I

18.460814def ffdiffefddaaeeafjcdigbafbgciafce(I):
  for obj in fgpartition(I):
    for row in range(uppermost(obj), lowermost(obj) + 1):
      for col in range(leftmost(obj), rightmost(obj)):
        if I[row][col] == mostcolor(I) and (row, col) in backdrop(obj):
          I = underfill(I, color(obj), {(row, col)})
  return I

25.997978def edhdegjgajaiecidaecfeccaafffiefh(I):
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for obj in objects(I, True, False, True):
    v = color(obj)
    shifted_obj = obj
    for k in range(width(I)):
      shifted_obj = shift(shifted_obj, (0, 1)) # Shift right
      O = paint(O, shifted_obj) # paint onto the canvas
  return O

22.808224def ghgihjeeecjeeifcbcefgibhddjageee(I):
  painted = set()
  for c in palette(I):  # Iterate through colors
    color_indices = ofcolor(I, c)
    topmost = (height(I), 0)
    bottommost = (0, 0)
    for i, j in color_indices:
      if i < topmost[0]: 
        topmost = (i, j)
      if i > bottommost[0]:
        bottommost = (i, j)
    if topmost != bottommost:  # Connect only if there's a vertical line
      painted |= connect(topmost, bottommost)
  return paint(I, recolor(c, painted))

57.063496def dagabbaedacaeidcaaiceebjecabbcdg(I):
  painted = set()
  for c in palette(I):
    color_indices = sorted(ofcolor(I, c)) # Get sorted indices of the color
    for i in range(len(color_indices) - 1):
      if color_indices[i][0] == color_indices[i+1][0]: # Check if on the same row
        painted |= connect(color_indices[i], color_indices[i+1]) # Connect horizontally
      if color_indices[i][1] == color_indices[i+1][1]: # Check if on the same column
        painted |= connect(color_indices[i], color_indices[i+1]) # Connect vertically
  return paint(I, recolor(c, painted)) 

14.515804def abjdfhehdaadebfgaffdddjhaciihcee(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    closest_distance = float("inf")
    closest_obj = None
    for obj2 in objs:
      if color(obj1) == color(obj2) and obj1 != obj2:
        dist = manhattan(obj1, obj2)
        if dist < closest_distance:
          closest_distance = dist
          closest_obj = obj2
    if closest_obj:
      if hmatching(obj1, closest_obj):
        start = ulcorner(obj1) if leftmost(obj1) < leftmost(closest_obj) else urcorner(obj1)
        end = (start[0], other(corners(closest_obj), start)[1])
      else:
        start = ulcorner(obj1) if uppermost(obj1) < uppermost(closest_obj) else llcorner(obj1)
        end = (other(corners(closest_obj), start)[0], start[1])
      I = fill(I, color(obj1), connect(start, end))
  return I

58.73751def cbfdfdjfbacbedfabfeafdjfadffjede(I):
  for x in range(len(I)):
    for y in range(len(I[0])):
      val = I[x][y]
      if val != mostcommon(I):
        for i in range(y + 1, len(I[0])):
          if I[x][i] == val:
            I = fill(I, val, connect((x, y), (x, i)))
            break
        for i in range(x + 1, len(I)):
          if I[i][y] == val:
            I = fill(I, val, connect((x, y), (i, y)))
            break
  return I

14.43909def icjfdfaejaecedhciedbjbjcdaibbcgb(I):
  for obj in objects(I, T, F, T):
    for dir in [RIGHT, DOWN]:
      for i in range(1, max(len(I), len(I[0]))):
        shifted_obj = shift(obj, multiply(dir, i))
        if len(intersection(toindices(shifted_obj), asindices(I))) == 0:
          break
        if len(intersection(shifted_obj, asobject(I))) > 0:
          I = fill(I, color(obj), connect(centerofmass(obj), centerofmass(shifted_obj)))
          break
  return I

20.653349def dcbfcfifajafedbcjidaddaibaieaebc(I):
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), I)
    bg_indices = difference(backdrop(obj), toindices(obj))
    if bg_indices:
      closest_bg = argmin(bg_indices, lambda x: manhattan({x}, toindices(obj)))
      path = connect(closest_bg, argmin(toindices(obj), lambda x: manhattan({x}, {closest_bg})))
      I = underfill(I, c, path)
  O = I
  return O

23.283365def caafgaadbcfgehcbbdhfhefdfcbcbdca(I):
    for obj in fgpartition(I):
        bg = difference(backdrop(obj), toindices(obj))
        if bg:
            closest_bg = min(bg, key=lambda x: sum(abs(a - b) for a, b in zip(x, centerofmass(obj))))
            path = set()
            current = centerofmass(obj)
            while current != closest_bg:
                path.add(current)
                candidates = [
                    (current[0] + 1, current[1]),
                    (current[0] - 1, current[1]),
                    (current[0], current[1] + 1),
                    (current[0], current[1] - 1),
                ]
                current = min(candidates, key=lambda x: sum(abs(a - b) for a, b in zip(x, closest_bg)))
            I = underfill(I, color(obj), frozenset(path))
    O = I
    return O

18.201923def beedacjacfcieccdjefbcbbadaaaceah(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = min(bg, key=lambda x: max(abs(a - b) for a, b in zip(x, centerofmass(obj))))
      I = underfill(I, color(obj), connect(centerofmass(obj), closest_bg))
  O = I
  return O

10.353499def fcbddbefjfdcefbabbfgfbdfeeaaaehc(I):
    for obj in fgpartition(I):
        if delta(obj):  # Check for background cells within bounding box
            closest_bg = min(delta(obj), key=lambda x: manhattan({x}, obj))
            path = connect(closest_bg, centerofmass(obj))
            for i, j in path:
                if I[i][j] == mostcolor(I):
                    I = fill(I, color(obj), {(i, j)})
    O = I
    return O

8.771294def jaaidebffbggeibcjhhbbafbhaaeehed(I):
  objs = objects(I, True, False, True) # Get all objects, excluding background
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) <= 2: # Check if objects have different colors and are close
        direction = gravitate(obj1, obj2) # Find direction to move obj1 towards obj2
        I = underfill(I, color(obj1), shoot(center(obj1), direction)) # Extend obj1 in the found direction within its bounding box
  return I

10.232585def ajfeefiaaafceababfedfejbhgjafbee(I):
  objs = fgpartition(I)
  for obj in objs:
    for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
      path = shoot(centerofmass(obj), direction)
      for other_obj in objs:
        if color(obj) != color(other_obj) and len(intersection(toindices(other_obj), path)) > 0:
          I = underfill(I, color(obj), intersection(path, backdrop(obj)))
          break
  return I

22.521002def fefdafbdjdceedbciihhegjabggaecid(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    closest_obj = None
    min_distance = float('inf')
    for obj2 in objs:
      if color(obj1) != color(obj2):
        dist = manhattan(obj1, obj2)
        if dist < min_distance:
          min_distance = dist
          closest_obj = obj2
    if closest_obj is not None:
      direction = gravitate(obj1, closest_obj)
      I = underfill(I, color(obj1), connect(center(obj1), add(center(obj1), direction)))
  return I

8.424225def bfcfjadcddbdeffcicfdaacafdiifbbi(I):
  for obj1 in fgpartition(I):
    bg = difference(backdrop(obj1), toindices(obj1))
    closest_neighbors = sorted(bg, key=lambda x: manhattan({x}, obj1))
    for closest_neighbor in closest_neighbors:
      for obj2 in fgpartition(I):
        if color(obj1) != color(obj2) and contained(closest_neighbor, toindices(obj2)):
          direction = sign(subtract(closest_neighbor, center(obj1)))
          I = underfill(I, color(obj1), shoot(center(obj1), direction))
          break
      else:
        continue
      break
  return I

9.41095def ebcbjhhbebbcefhejeejcbfiafeeghec(I):
    for value in palette(I) - {mostcolor(I)}: # Iterate through each color
        obj = toobject(ofcolor(I, value), I)
        for d in [LEFT, RIGHT]:
            frontier = toindices(obj)
            while True:
                next_frontier = shift(frontier, d)
                if not intersection(next_frontier, asindices(I)) or any(index(I, loc) != mostcolor(I) for loc in next_frontier):
                    break
                frontier = next_frontier
            I = underfill(I, value, frontier)
    O = I
    return O

45.303894def cffieabababbefchacjbiadbcacejeeb(I):
    O = I
    for x in range(len(I[0])):
        for y in range(len(I)):
            if I[y][x] != mostcolor(I):
                current_color = I[y][x]
                for d in [1, -1]:
                    nx = x + d
                    while 0 <= nx < len(I[0]) and I[y][nx] == mostcolor(I):
                        O = fill(O, current_color, {(y, nx)})
                        nx += d
    return O

23.283365def dafjbedbejibeaedaibebbdiaffbceah(I):
    objs = fgpartition(I) 
    for obj in objs:
        ul = ulcorner(obj)
        lr = lrcorner(obj)
        if ul[0] == lr[0]:  # Check if object is on a single row
            left_extension = {(ul[0], j) for j in range(0, ul[1])}
            right_extension = {(lr[0], j) for j in range(lr[1] + 1, len(I[0]))}
            I = underfill(I, color(obj), left_extension)
            I = underfill(I, color(obj), right_extension)
    O = I
    return O

32.32506def headhhbhbjefeijebjaiciebaefiihac(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0]) - 1):
      if I[i][j] != mostcolor(I):
        k = j + 1
        while k < len(I[0]) and I[i][k] == mostcolor(I):
          O = fill(O, I[i][j], {(i, k)})
          k += 1
  return O

22.469046def ihgebbdhdbgdeeibbeffieajfgjihddf(I):
  objs = objects(I, T, F, T)
  new_objs = set()
  for obj in objs:
    rightmost_col = rightmost(obj)
    for other_obj in objs - {obj}:
      if color(obj) == color(other_obj) and hmatching(obj, other_obj):
        connection_line = connect((uppermost(obj), rightmost_col), (uppermost(obj), leftmost(other_obj)))
        obj = combine(obj, recolor(color(obj), intersection(connection_line, asindices(I))))
    new_objs.add(obj)
  return paint(canvas(mostcolor(I), shape(I)), merge(new_objs))

7.714026def cjieeceejfibecibifaifiedcfbabbac(I):
  O = I
  objs = objects(I, T, F, T)
  for obj in objs:
    for i in range(height(I)):
      row_segment = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
      if len(row_segment) > 0:
        start_j = leftmost(row_segment)
        end_j = rightmost(row_segment)
        for j in range(start_j, end_j):
          if I[i][j] == mostcolor(I):
            O = fill(O, color(obj), {(i, j)})
  return O

31.938875def dbbdhfbeeifjebbcaaaadcjecibdhcdh(I):
  for i in range(len(I)):
    current_color = None
    fill_start = None
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I) and current_color is None:
        current_color = I[i][j]
        fill_start = j
      elif I[i][j] == mostcolor(I) and current_color is not None:
        I = fill(I, current_color, {(i, j)})
      elif I[i][j] != mostcolor(I) and I[i][j] != current_color:
        current_color = None
        fill_start = None
  return I

23.283365def aejdbefcjecbefjfbcaabbdfdhciccbc(I):
  objs = objects(I, True, False, False) # Get all objects
  filled = I
  for obj in objs:
    if hline(obj) or vline(obj): # Check if object is a line
      bbox = backdrop(obj)  # Get bounding box
      fill_value = color(obj) # Get the object's color
      filled = fill(filled, fill_value, bbox) # Fill the bounding box
  O = filled
  return O

4.793095def didddcadhhgdeagdbhfcdagffehcbccb(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      direction = sign(subtract(closest_bg, centerofmass(obj)))
      if abs(direction[0]) == abs(direction[1]):  # Diagonal movement
          I = underfill(I, color(obj), connect(centerofmass(obj), closest_bg))
      else:
          I = underfill(I, color(obj), shoot(centerofmass(obj), direction))
  O = I
  return O

15.247403def efcgjhjebjfaecaebggjaegbjafcidff(I):
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), I)
    queue = [centerofmass(obj)]
    visited = set()
    while queue:
      loc = queue.pop(0)
      if loc in visited or loc not in backdrop(obj):
        continue
      visited.add(loc)
      for n in dneighbors(loc):
        if n not in visited and index(I, n) == 0:
          I = underfill(I, c, {loc})
          queue.append(n)
  O = I
  return O

16.760117def bifgafdfgadaeidabcacicafcicfdfbd(I):
  for obj in fgpartition(I):
    h, w = shape(obj)
    if h > w:
      direction = (1 if uppermost(obj) < len(I) // 2 else -1, 0)
    else:
      direction = (0, 1 if leftmost(obj) < len(I[0]) // 2 else -1)
    I = underfill(I, color(obj), shoot(centerofmass(obj), direction))
  O = I
  return O

32.81556def agfcbfbcbbfaefebbdcjfajciafbhicc(I):
  for obj in fgpartition(I):
    for loc in toindices(obj):
      for direction in [UP, DOWN, LEFT, RIGHT]:
        target = add(loc, direction)
        if index(I, target) == 0:
          I = underfill(I, color(obj), {target})
  O = I
  return O

32.843193def cddbceadbeffebfcbccagbgdfceicdaf(I):
  for c in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, c), I)
    while True:
      expanded = False
      for loc in toindices(obj):
        for n in dneighbors(loc):
          if index(I, n) == 0:
            I = underfill(I, c, {n})
            expanded = True
      if not expanded:
        break
  O = I
  return O

10.290941def aeefeadeeaeiedajiaghfccffcdehgba(I):
  for obj1 in fgpartition(I):
    for obj2 in fgpartition(I):
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) <= width(I): # Check for different color and proximity
        direction = gravitate(obj1, obj2) # Find direction to move obj1 towards obj2
        I = underfill(I, color(obj1), shoot(center(obj1), sign(direction))) # Extend obj1 in that direction
  return I

19.514418def jjbfebdgjgeeecfhifbbfeegdfcbbcdb(I):
  for obj1 in fgpartition(I):
    closest_obj = None
    min_distance = float('inf')
    for obj2 in fgpartition(I):
      if color(obj1) != color(obj2):
        dist = manhattan(obj1, obj2)
        if dist < min_distance:
          min_distance = dist
          closest_obj = obj2
    if closest_obj is not None:
      direction = gravitate(obj1, closest_obj)
      I = underfill(I, color(obj1), connect(center(obj1), center(closest_obj)))
  return I

11.546087def ebfabdefjhdaefbjjfebbddebfcijfja(I):
  objs = fgpartition(I)
  for obj1 in objs:
    neighbors = sorted([obj2 for obj2 in objs if obj2 != obj1 and manhattan(obj1, obj2) <= width(I)], key=lambda x: manhattan(x, obj1))
    for neighbor in neighbors:
      if color(neighbor) != color(obj1):
        overlap = intersection(backdrop(obj1), backdrop(neighbor))
        if overlap:
          direction = sign(subtract(center(neighbor), center(obj1)))
          I = underfill(I, color(obj1), shoot(center(obj1), direction))
          break
  return I

18.641775def gjddfcgjgeajefcgbcbfehfddcgecfba(I):
  for obj1 in fgpartition(I):
    targets = [obj2 for obj2 in fgpartition(I) if color(obj2) != color(obj1) and manhattan(obj1, obj2) <= width(I)]
    if targets:
      closest_target = min(targets, key=lambda x: manhattan(x, obj1))
      path = connect(center(obj1), center(closest_target))
      for i, j in path:
        if contained((i, j), backdrop(obj1)):
          I = fill(I, color(obj1), {(i, j)})
  return I

19.255323def cgcbcjbbeeebefcdibdgcdbfajfggffg(I):
  for obj in fgpartition(I):
    others = [o for o in fgpartition(I) if color(o) != color(obj)]
    closest = min(others, key=lambda o: manhattan(obj, o), default=None)
    if closest:
      path = connect(center(obj), center(closest))
      I = underfill(I, color(obj), intersection(path, backdrop(obj)))
  return I

43.079475def abaiacdhdffeegddbebdfedaadabcfge(I):
  objs = objects(I, F, F, T)
  for obj in objs:
    left_edge = hfrontier((uppermost(obj), leftmost(obj)-1))
    right_edge = hfrontier((uppermost(obj), rightmost(obj)+1))
    left_extension = intersection(left_edge, asindices(I))
    right_extension = intersection(right_edge, asindices(I))
    I = underfill(I, color(obj), left_extension)
    I = underfill(I, color(obj), right_extension)
  O = I
  return O

35.319805def icaafdbhdccbebdeaedfijhfjgcaafde(I):
  for x in range(width(I)):
    I = apply(lambda row: extend_row(row, x), I)
  O = I
  return O

43.856136def bficabcchhbdeceejdfbadbifddbaaaj(I):
  for obj in objects(I, F, F, T):
    for i, j in toindices(obj):
      for d in [LEFT, RIGHT]:
        k = 1
        while (i, j + k * d[1]) in asindices(I) and I[i][j + k * d[1]] == 0:
          I = fill(I, color(obj), {(i, j + k * d[1])})
          k += 1
  O = I
  return O

23.283365def jbbefjeedfbdeebhaeafbaabbdebeigd(I):
  objs = objects(I, T, F, T)  # Extract objects excluding background
  extended_objs = set()
  for obj in objs:
    extended_obj = obj  # Initialize the extended object
    for j in range(leftmost(obj), width(I)):  # Iterate through columns from object's leftmost point
      right_edge = {(v, (i, j)) for v, (i, j) in extended_obj if j == rightmost(extended_obj)}  # Find the rightmost cells
      if any(index(I, (i, j + 1)) != mostcolor(I) for v, (i, j) in right_edge):  # Check if any cell to the right is not background
        break  # Stop extending if an object or border is encountered
      extended_obj = extended_obj | {(index(I, (i, j + 1)), (i, j + 1)) for v, (i, j) in right_edge}  # Extend the object
    extended_objs.add(extended_obj)
  return paint(canvas(mostcolor(I), shape(I)), merge(extended_objs))  # Paint the extended objects on a blank canvas

15.987002def bdcfjedddahfefjdbeibcgieceaddcba(I):
  for target_color, direction in [(1, (0, 1)), (8, (0, 1)), (1, (1, 0))]:  # Define target colors and directions
    objs = objects(I, False, False, True)
    for obj in objs:
      if color(obj) == target_color:
        shifted_obj = obj
        while True:
          next_loc = (lrcorner(shifted_obj) if direction == (1, 0) else urcorner(shifted_obj))  # Get next location in direction
          next_loc = add(next_loc, direction)  # Move one step further
          if index(I, next_loc) is None or index(I, next_loc) != mostcolor(I):  # Stop if at edge or non-background
            break
          shifted_obj = shift(shifted_obj, direction)  # Shift object
        I = underpaint(I, shifted_obj)  # Paint the shifted object
  return I

10.12408def bbeeajcadbddeefcajgejacbagfceacd(I):
  target_colors = [1, 8, 1]
  for idx, target_color in enumerate(target_colors):
    objs = objects(I, False, False, True)
    for obj in objs:
      if color(obj) == target_color:
        expansion_direction = (0, 1) if (idx != 2 and portrait(obj)) or (idx == 2 and not portrait(obj)) else (1, 0)
        expansion_start = lrcorner(obj) if expansion_direction == (1, 0) else urcorner(obj)
        for i in range(1, 10):  # Assuming max grid size of 10
          next_point = add(expansion_start, multiply(i, expansion_direction))
          if index(I, next_point) is None or index(I, next_point) != mostcolor(I):
            break
          I = underfill(I, target_color, {next_point})
  return I

15.157053def cbhhcfcdjdaeeddajhdaeaibfffbagej(I):
  for obj in fgpartition(I):
    color_obj = color(obj)
    for d in (DOWN, RIGHT):
      ob = obj
      while True:
        shifted_obj = shift(ob, d)
        if any((index(I, (i, j)) != mostcolor(I) and (i, j) not in toindices(obj)) for v, (i, j) in shifted_obj):
          break
        ob = shifted_obj
      I = underpaint(I, recolor(color_obj, difference(toindices(ob), toindices(obj))))
  O = I
  return O

40.269558def aaiefihbeaccecaajhacaacdcffjbfja(I):
  for obj in fgpartition(I):
    for direction in [RIGHT, DOWN]:
      frontier = toindices(obj)
      while len(frontier) > 0:
        new_frontier = set()
        for i, j in frontier:
          ni, nj = add((i, j), direction)
          if 0 <= ni < height(I) and 0 <= nj < width(I) and index(I, (ni, nj)) == mostcolor(I):
            new_frontier.add((ni, nj))
        if len(new_frontier) == 0:
          break
        frontier = new_frontier
        I = underfill(I, color(obj), frontier)
  O = I
  return O

41.92543def jadehhhacdeaejbgabfccdfbhbifchfb(I):
  for obj in fgpartition(I):
    h_extension = set()
    v_extension = set()
    for i, j in toindices(obj):
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) != mostcolor(I):
          break
        h_extension.add((i, k))
      for k in range(i + 1, height(I)):
        if index(I, (k, j)) != mostcolor(I):
          break
        v_extension.add((k, j))
    I = underfill(I, color(obj), h_extension)
    I = underfill(I, color(obj), v_extension)
  O = I
  return O

16.920635def edeiahhidcbaehaabaebedcddddihjid(I):
  seen = set()
  for obj in fgpartition(I):
    if any((i,j) in seen for i, j in toindices(obj)):
      continue
    color_obj = color(obj)
    h_line = {(i, j) for i, j in product(range(height(I)), {centerofmass(obj)[1]})}
    v_line = {(i, j) for i, j in product({centerofmass(obj)[0]}, range(width(I)))}
    h_extension = intersection(h_line, difference(backdrop(obj), toindices(obj)))
    v_extension = intersection(v_line, difference(backdrop(obj), toindices(obj)))
    h_extension_final = set()
    v_extension_final = set()
    for i, j in h_extension:
      if index(I, (i, j)) == mostcolor(I):
        h_extension_final.add((i, j))
      else:
        break
    for i, j in v_extension:
      if index(I, (i, j)) == mostcolor(I):
        v_extension_final.add((i, j))
      else:
        break
    I = underfill(I, color_obj, h_extension_final)
    I = underfill(I, color_obj, v_extension_final)
    seen = seen.union(h_extension_final).union(v_extension_final).union(toindices(obj))
  O = I
  return O

7.240992def beidibheeaefeibebacceabfcjacfjfg(I):
  objs = fgpartition(I) # Partition into objects excluding background
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) <= max(height(obj1), width(obj1)): # Check for proximity within bounding box
        direction = gravitate(obj1, obj2) # Determine direction to nearest different object
        path = shoot(center(obj1), direction) # Extend path in that direction
        I = underfill(I, color(obj1), intersection(path, backdrop(obj1))) # Fill within bounding box
  return I

13.869072def cdabccciajaceaeeiidcecehihaachah(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      I = underfill(I, color(obj), connect(center(obj), closest_bg)) # Directly connect to closest background cell
  return I

18.815014def hchjicadffifegfbbbageeefdaccjeei(I):
  objs = fgpartition(I)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and (hmatching(obj1, obj2) or vmatching(obj1, obj2)):
        if hmatching(obj1, obj2):
          dir = (0, 1) if leftmost(obj1) < leftmost(obj2) else (0, -1) # Simplified direction logic
        else:
          dir = (1, 0) if uppermost(obj1) < uppermost(obj2) else (-1, 0)
        I = underfill(I, color(obj1), shoot(center(obj1), dir)) # Fill path from center in determined direction
  return I

15.59932def adiehagcbdgdebcdafgfbcjibahchcga(I):
  for obj in fgpartition(I):
    targets = [(i, j) for i in range(height(I)) for j in range(width(I)) if I[i][j] != color(obj) and I[i][j] != mostcolor(I)] # Find all target cell locations
    if targets:
      closest_target = argmin(targets, lambda x: manhattan({x}, obj)) # Find the closest target cell
      I = underfill(I, color(obj), connect(center(obj), closest_target)) # Connect to the closest target
  return I

27.598753def eabhbiaechhfeafbbecfdccbhdddhaga(I):
  for obj in fgpartition(I):
    h_path = intersection(shoot(center(obj), (0, 1)), backdrop(obj)) | intersection(shoot(center(obj), (0, -1)), backdrop(obj)) # Horizontal path
    v_path = intersection(shoot(center(obj), (1, 0)), backdrop(obj)) | intersection(shoot(center(obj), (-1, 0)), backdrop(obj)) # Vertical path
    I = underfill(underfill(I, color(obj), h_path), color(obj), v_path) # Fill both paths
  return I

7.913887def bajffddefiiaeeebbahbcacfddbjfbbg(I):
  for obj in fgpartition(I):
    for index in toindices(obj):
      bg = difference(asindices(I), toindices(obj))
      closest_bg = argmin(bg, lambda x: manhattan({x}, {index}))
      I = underfill(I, color(obj), {closest_bg})
  O = I
  return O

11.246535def aibdaadichfaejddbiefffaeheeafjcf(I):
  for obj in fgpartition(I):
    bg = difference(asindices(I), toindices(obj))
    closest = sorted(bg, key=lambda x: manhattan({x}, obj))
    path = set()
    for b in closest:
      path = connect(b, centerofmass(obj))
      if len(intersection(path, toindices(obj))) > 0:
        break
    I = underfill(I, color(obj), path)
  O = I
  return O

14.43909def efafajhjcbffegcaabcbhhhachecegef(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and color(obj1) == color(obj2):
        if hmatching(obj1, obj2) and not vmatching(obj1, obj2): 
          I = fill(I, color(obj1), connect(center(obj1), center(obj2)))
        elif vmatching(obj1, obj2) and not hmatching(obj1, obj2):
          I = fill(I, color(obj1), connect(center(obj1), center(obj2)))
  return I

7.792658def haabaeecegadegbdigfjfbaceddhgjjf(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      current_color = I[i][j]
      if current_color != mostcolor(I):
        # Extend horizontally
        for k in range(j + 1, len(I[0])):
          if I[i][k] == current_color:
            I = fill(I, current_color, connect((i, j), (i, k)))
            break
        # Extend vertically
        for k in range(i + 1, len(I)):
          if I[k][j] == current_color:
            I = fill(I, current_color, connect((i, j), (k, j)))
            break
  return I

5.0266275def hcbfbbdagceaeejgacabajefaibbcifg(I):
  objs = fgpartition(I)
  for obj in objs:
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
      direction = sign(subtract(closest_bg, centerofmass(obj)))
      I = underfill(I, color(obj), connect(centerofmass(obj), add(closest_bg, direction)))
  O = I
  return O

42.987362def jfgbbdjbbgadebefaacgdfddicjcadjd(I):
  for _ in range(max(height(I), width(I))):
    changed = False
    for obj in fgpartition(I):
      for i, j in toindices(obj):
        for ni, nj in [(i + 1, j + 1), (i + 1, j - 1), (i - 1, j + 1), (i - 1, j - 1)]:
          if 0 <= ni < height(I) and 0 <= nj < width(I) and index(I, (ni, nj)) == mostcolor(I):
            I = underfill(I, color(obj), {(ni, nj)})
            changed = True
    if not changed:
      break
  O = I
  return O

33.17428def cbifcfhebfhdeajeijcbfhfebhjcadee(I):
  objs = fgpartition(I)
  for obj in objs:
    for _ in range(max(height(I), width(I))):
      expansion = set()
      for i, j in toindices(obj):
        for ni, nj in [(i + 1, j + 1), (i + 1, j - 1), (i - 1, j + 1), (i - 1, j - 1)]:
          if 0 <= ni < height(I) and 0 <= nj < width(I) and index(I, (ni, nj)) == mostcolor(I):
            expansion.add((ni, nj))
      if not expansion:
        break
      I = underfill(I, color(obj), expansion)
      obj = obj | recolor(color(obj), expansion) 
  O = I
  return O

35.029747def ceejeaebcebceegfjcdiegjeccecagcj(I):
  objs = fgpartition(I)
  for obj in objs:
    queue = list(toindices(obj))
    visited = set(queue)
    while queue:
      i, j = queue.pop(0)
      for di, dj in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
        ni, nj = i + di, j + dj
        if (
          0 <= ni < height(I)
          and 0 <= nj < width(I)
          and index(I, (ni, nj)) == mostcolor(I)
          and (ni, nj) not in visited
        ):
          I = underfill(I, color(obj), {(ni, nj)})
          visited.add((ni, nj))
          queue.append((ni, nj))
  O = I
  return O

27.961706def hghfhjjaihgdeggebhigchaedcjfbiac(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and (hmatching(obj1, obj2) or vmatching(obj1, obj2)):
        if hmatching(obj1, obj2):
          direction = (0, 1) if leftmost(obj1) < leftmost(obj2) else (0, -1)
        else:
          direction = (1, 0) if uppermost(obj1) < uppermost(obj2) else (-1, 0)
        I = underfill(I, color(obj1), shoot(center(obj1), direction))
  return I

11.5699def ecacafhbgdjaegefieaacbeadcbhdcid(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    target_objs = sfilter(objs - {obj1}, lambda x: color(x) != color(obj1) and (hmatching(obj1, x) or vmatching(obj1, x)))
    if target_objs:
      closest_obj = argmin(target_objs, lambda x: manhattan(obj1, x))
      if hmatching(obj1, closest_obj):
        I = fill(I, color(obj1), connect(center(obj1), (center(obj1)[0], center(closest_obj)[1])))
      else:
        I = fill(I, color(obj1), connect(center(obj1), (center(closest_obj)[0], center(obj1)[1])))
  return I

13.79124def difgebgaccaeeebdjaieidfabbecgbbf(I):
  objs = fgpartition(I)
  for obj1 in objs:
    h_targets = sfilter(objs - {obj1}, lambda x: color(x) != color(obj1) and hmatching(obj1, x))
    v_targets = sfilter(objs - {obj1}, lambda x: color(x) != color(obj1) and vmatching(obj1, x))
    if h_targets:
      closest_htarget = argmin(h_targets, lambda x: manhattan(obj1, x))
      I = underfill(I, color(obj1), connect(center(obj1), (center(obj1)[0], center(closest_htarget)[1]))) 
    if v_targets:
      closest_vtarget = argmin(v_targets, lambda x: manhattan(obj1, x))
      I = underfill(I, color(obj1), connect(center(obj1), (center(closest_vtarget)[0], center(obj1)[1]))) 
  return I

22.233908def cdbacffahffeeacgiebjfjabjcaiacfa(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        if hmatching(obj1, obj2):
          I = underfill(I, color(obj1), connect(center(obj1), (center(obj1)[0], center(obj2)[1])))
        if vmatching(obj1, obj2):
          I = underfill(I, color(obj1), connect(center(obj1), (center(obj2)[0], center(obj1)[1])))
  return I

17.734724def hdciddfffacaehbcafgbhabjdfjfgadd(I):
  for obj in fgpartition(I):
    obj_center = (centerofmass(obj)[0], center(obj)[1])
    bg = difference(asindices(I), toindices(obj))
    closest_bg = argmin(bg, lambda x: abs(x[1] - obj_center[1])) # Closest based on column difference
    if closest_bg[1] < obj_center[1]:
        I = underfill(I, color(obj), connect(closest_bg, (closest_bg[0], obj_center[1])))
    else:
        I = underfill(I, color(obj), connect((closest_bg[0], obj_center[1]), closest_bg))
  O = I
  return O

11.546087def ighdeafffafaeffiahfgfiaebfebghde(I):
  objs = fgpartition(I)
  for obj1 in objs:
    closest_distance = float('inf')
    closest_obj2 = None
    for obj2 in objs:
      if color(obj1) != color(obj2):
        dist = manhattan(obj1, obj2)
        if dist < closest_distance:
          closest_distance = dist
          closest_obj2 = obj2
    if closest_obj2:
      direction = position(obj1, closest_obj2)
      I = underfill(I, color(obj1), shoot(center(obj1), direction))
  O = I
  return O

8.482531def gidefcfjjhhbebbciiecfefbhfchddcg(I):
  objs = fgpartition(I)
  for obj1 in objs:
    closest_obj2 = min(((manhattan(obj1, obj2), obj2) for obj2 in objs if color(obj1) != color(obj2)), default=(None, None))[1]
    if closest_obj2:
      hdist = abs(center(obj1)[1] - center(closest_obj2)[1])
      vdist = abs(center(obj1)[0] - center(closest_obj2)[0])
      direction = (0, sign(center(closest_obj2)[1] - center(obj1)[1])) if hdist > vdist else (sign(center(closest_obj2)[0] - center(obj1)[0]), 0)
      I = underfill(I, color(obj1), shoot(center(obj1), direction))
  O = I
  return O

7.4084597def aajciebbfdadecjdbadgbadacaacgdfe(I):
  for obj in fgpartition(I):
    bg = difference(backdrop(obj), toindices(obj))
    if bg:
      closest_bg = min(bg, key=lambda x: manhattan({x}, obj))
      h_diff = abs(closest_bg[1] - centerofmass(obj)[1])
      v_diff = abs(closest_bg[0] - centerofmass(obj)[0])
      direction = tojvec(sign(closest_bg[1] - centerofmass(obj)[1])) if h_diff > v_diff else toivec(sign(closest_bg[0] - centerofmass(obj)[0]))
      I = underfill(I, color(obj), shoot(centerofmass(obj), direction))
  O = I
  return O

16.302998def jjffafiffaeieebdaiiecfejdicbbeff(I):
  objs = fgpartition(I) 
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        direction = gravitate(obj1, obj2)
        I = underfill(I, color(obj1), shoot(center(obj1), direction)) 
  return I

10.504161def iabadceghggheffebdaagaebgaeibfha(I):
  objs = fgpartition(I)
  for obj1 in objs:
    closest_distance = float('inf')
    closest_obj = None
    for obj2 in objs:
      if color(obj1) != color(obj2):
        dist = manhattan(obj1, obj2)
        if dist < closest_distance:
          closest_distance = dist
          closest_obj = obj2
    if closest_obj is not None:
      direction = gravitate(obj1, closest_obj)
      I = underfill(I, color(obj1), shoot(center(obj1), direction))
  return I

20.267561def djcbbhejcagdeaafaibafibedbcdiajb(I):
  objs = fgpartition(I)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and hmatching(obj1, obj2):
        I = underfill(I, color(obj1), connect(center(obj1), center(obj2)))
  return I

18.179316def fddbcjheafaaehgcjfcbebbdcbhfaajb(I):
  objs = fgpartition(I)
  for obj1 in objs:
    target_objs = sfilter(objs, lambda obj2: color(obj1) != color(obj2) and manhattan(obj1, obj2) <= max(height(obj1), width(obj1)))
    for obj2 in target_objs:
      I = underfill(I, color(obj1), connect(center(obj1), center(obj2)))
  return I

20.509556def ajahbhjcbfffegfbjigaeehaghidfdha(I):
  O = I
  for c in palette(I):
    if colorcount(I, c) <= 1: # Ignore single-cell colors
      continue
    indices = ofcolor(I, c)
    for (i, j) in indices:
      closest_dist = float('inf')
      closest_point = None
      for (m, n) in indices:
        if (m, n) != (i, j):
          dist = max(abs(i-m), abs(j-n))
          if dist < closest_dist:
            closest_dist = dist
            closest_point = (m, n)
      if closest_point is not None:
        if closest_point[0] > i and closest_point[1] > j:
          direction = (1, 1)
        elif closest_point[0] > i and closest_point[1] < j:
          direction = (1, -1)
        elif closest_point[0] < i and closest_point[1] > j:
          direction = (-1, 1)
        else:
          direction = (-1, -1)
        O = fill(O, c, connect((i, j), add((i, j), multiply(direction, closest_dist))))
  return O

15.410984def abagfaccbbceejhbjijacdifbdjffdeh(I):
  O = I
  for c in palette(I):
    if colorcount(I, c) <= 1:  
      continue
    cells = ofcolor(I, c)
    for (i, j) in cells:
      closest = min(
        ((abs(i-m) + abs(j-n), m, n) for m, n in cells if (m, n) != (i, j)),
        key=lambda x: x[0], default=(None, None, None)
      )
      if closest[0] is not None:
        O = fill(O, c, connect((i, j), closest[1:]))
  return O

57.075134def dgahcfbdfifgebjdbfdediebaiejbhdf(I):
  for c in palette(I):
    if colorcount(I, c) <= 1:  
      continue
    cells = sorted(ofcolor(I, c))
    for i in range(len(cells) - 1):
      I = fill(I, c, connect(cells[i], cells[i+1]))
  return I

32.288986def cacddcagjeeieciejaeeaaddbceacdda(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if I[i][j] != 0 and I[i][j + 1] == 0:
        O = fill(O, I[i][j], connect((i, j), (i, width(I) - 1)))
  return O

19.940979def fejhfjadeaaheiehacdffbbbfccjeehd(I):
  for j in range(width(I) - 1):
    for i in range(height(I)):
      if I[i][j] != 0 and I[i][j + 1] == 0:
        obj = extract(objects(I, True, False, False), lambda obj: (i, j) in toindices(obj))
        O = paint(I, shift(obj, (0, 1)))
  return O

34.96401def iddiceaffigdeeaiicgbcceajfhhabfi(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    min_j = leftmost(obj)
    max_j = next((j for j in range(min_j + 1, width(I)) if any(i in {i for i, k in ofcolor(I, index(I, (i, j)))} for i, k in toindices(obj))), width(I))
    O = paint(O, recolor(color(obj), product(range(uppermost(obj), lowermost(obj) + 1), range(min_j, max_j))))
  return O

32.32506def cdjciebjhhhaecdaacbbcaddfgbadffc(I):
    O = I
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != 0 and j < width(I) - 1 and I[i][j + 1] == 0:
                collision_point = next((k for k in range(j + 2, width(I)) if I[i][k] != 0), width(I))
                O = fill(O, val, frozenset((i, k) for k in range(j + 1, collision_point)))
    return O

5.4538345def adfbdacefgageecfabahaabgbbaaeeeg(I):
  for value in palette(I) - {mostcommon(I)}:  # Iterate over non-background colors
    obj = toobject(ofcolor(I, value), I)  # Get the object with the current color
    bg = difference(backdrop(obj), toindices(obj))  # Get background indices around the object
    if bg:
      closest_bg = min(bg, key=lambda x: manhattan({x}, obj))  # Find closest background cell
      h_diff = abs(closest_bg[1] - center(obj)[1])  # Horizontal distance
      v_diff = abs(closest_bg[0] - center(obj)[0])  # Vertical distance
      if h_diff >= v_diff:
        I = underfill(I, value, connect(center(obj), (center(obj)[0], closest_bg[1]))) # Extend horizontally
      else:
        I = underfill(I, value, connect(center(obj), (closest_bg[0], center(obj)[1]))) # Extend vertically
  O = I
  return O

5.7918878def dehdebihafddecaaiddfehffiiaeabeb(I):
  for obj in fgpartition(I):  # Iterate over foreground objects
    bg = difference(asindices(I), toindices(obj))  # All background cells
    closest_bg = min(bg, key=lambda x: manhattan({x}, obj), default=None)  # Closest background
    if closest_bg:
      h_diff = abs(closest_bg[1] - center(obj)[1])
      v_diff = abs(closest_bg[0] - center(obj)[0])
      target = (closest_bg[0], center(obj)[1]) if v_diff > h_diff else (center(obj)[0], closest_bg[1])
      I = underfill(I, color(obj), connect(center(obj), target))  # Extend towards target
  O = I
  return O

11.819004def agccfgfehfchedeijcadaabfaghchagf(I):
  objs = fgpartition(I)
  for obj1 in objs:
    bg = difference(asindices(I), toindices(obj1)) 
    closest_bg = min(bg, key=lambda x: manhattan({x}, obj1), default=None)
    if closest_bg:
      direction = position(obj1, {closest_bg})
      extension = connect(center(obj1), add(center(obj1), multiply(direction, (width(obj1) // 2, height(obj1) // 2))))
      I = underfill(I, color(obj1), extension) 
  O = I
  return O

20.415918def ibdefeejefhaeeaebigjcbadggbbjgdi(I):
  objs = fgpartition(I)  # Get objects without background
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) == 2:  # Check for different colors and distance
        I = underfill(I, color(obj1), connect(center(obj1), center(obj2)))  # Connect with a line
  return I

23.283365def dbbaaeiffagcefhajgebcfgdbbcbdefd(I):
  objs = fgpartition(I)
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i, j)) == mostcolor(I):  # Check for background cells
        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:  # Check adjacent cells
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and index(I, (ni, nj)) != mostcolor(I):
            for obj in objs:
              if (ni, nj) in toindices(obj):
                opposite = (i + 2 * di, j + 2 * dj) # Calculate potential opposite object location
                if 0 <= opposite[0] < len(I) and 0 <= opposite[1] < len(I[0]) and index(I, opposite) != mostcolor(I) and index(I, opposite) != index(I, (ni, nj)):
                  I = underfill(I, index(I, (ni, nj)), connect((i, j), opposite)) # Connect if opposite cell is a different colored object
  return I

13.646432def cbfcefeiccbgegehjabdfcahhfggaiac(I):
  for obj in fgpartition(I):
    row = uppermost(obj)
    fill_cols = set()
    for j in range(leftmost(obj), rightmost(obj) + 1):
      if (row, j) in toindices(obj):
        fill_cols.add(j)
      elif fill_cols:
        I = underfill(I, color(obj), {(row, j)})
  O = I
  return O

11.484097def dahfbieegchcecfaaabcfaeibcdegfji(I):
  for obj in fgpartition(I):
    obj_row = uppermost(obj)
    left_bound = leftmost(obj)
    right_bound = rightmost(obj)
    for j in range(len(I[0])):
      if left_bound <= j <= right_bound and (obj_row, j) not in toindices(obj):
        I = underfill(I, color(obj), {(obj_row, j)})
  O = I
  return O

7.551676def cfhgafgidjjhegddjjbbjfhfcccacdid(I):
  objs = fgpartition(I)
  for obj in objs:
    for cell in toindices(obj):  # Iterate over each cell of the object
      bg = intersection(dneighbors(cell), difference(asindices(I), toindices(obj)))  # Check for direct neighbor background cells
      if bg:
        closest_bg = argmin(bg, lambda x: manhattan({x}, {cell}))  # Find nearest among direct neighbors
        direction = sign(subtract(closest_bg, cell))
        I = underfill(I, color(obj), connect(cell, add(cell, direction)))  # Extend from current cell, stopping at next cell
  O = I
  return O

10.523309def jcabcgbgaaaaeibdjegdccghadbdghcj(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    target_objs = sfilter(objs - {obj1}, lambda x: color(x) == color(obj1))
    if target_objs:
      closest_obj = argmin(target_objs, lambda x: manhattan(obj1, x))
      if manhattan(obj1, closest_obj) <= max(width(I), height(I)) // 2:
        if hmatching(obj1, closest_obj):
          start = center(obj1)
          end = (start[0], center(closest_obj)[1])
        else:
          start = center(obj1)
          end = (center(closest_obj)[0], start[1])
        I = fill(I, color(obj1), connect(start, end))
  return I

14.43909def baiegcibfcbdeaidajdggeaagecbfbbf(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) == color(obj2) and obj1 != obj2:
        min_i = min(lowermost(obj1), lowermost(obj2))
        max_i = max(uppermost(obj1), uppermost(obj2))
        min_j = min(rightmost(obj1), rightmost(obj2))
        max_j = max(leftmost(obj1), leftmost(obj2))
        if max_i - min_i <= height(I) // 2 or max_j - min_j <= width(I) // 2:
          if hmatching(obj1, obj2):
            I = fill(I, color(obj1), connect(center(obj1), (center(obj1)[0], center(obj2)[1])))
          elif vmatching(obj1, obj2):
            I = fill(I, color(obj1), connect(center(obj1), (center(obj2)[0], center(obj1)[1])))
  return I

22.469046def fddijecaicedehiaifdcfabcbaddddib(I):
  objs = objects(I, True, False, True)
  for obj1 in objs:
    closest_obj = None
    min_distance = float('inf')
    for obj2 in objs:
      if color(obj1) == color(obj2) and obj1 != obj2:
        dist = manhattan(obj1, obj2)
        if dist < min_distance:
          min_distance = dist
          closest_obj = obj2
    if closest_obj and min_distance <= max(width(I), height(I)) // 2:
      if hmatching(obj1, closest_obj):
        I = fill(I, color(obj1), connect(center(obj1), (center(obj1)[0], center(closest_obj)[1])))
      elif vmatching(obj1, closest_obj):
        I = fill(I, color(obj1), connect(center(obj1), (center(closest_obj)[0], center(obj1)[1])))
  return I

32.32506def cebicdeahcfhejcbbbaefacghiefieda(I):
  O = I  
  for obj in fgpartition(I):
    for (v, (i, j)) in obj:
      for k in range(j + 1, width(I)):
        if index(I, (i, k)) == mostcolor(I):
          O = fill(O, v, {(i, k)})
        else:
          break
  return O

12.011565def ebjacdgdcbbaedeebbcebcjfcacbacjb(I):
  objs = fgpartition(I)
  filled = set()
  for obj in objs:
    for v, (i, j) in obj:
      k = j + 1
      while k < width(I) and (i, k) not in filled and index(I, (i, k)) == mostcolor(I):
        filled.add((i, k))
        k += 1
      O = fill(I, v, {(i, l) for l in range(j + 1, k)})
  return O 

32.386654def cabdeajdadbjecdebeffifedfdhadgga(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(fgpartition(I), key=lambda obj: -rightmost(obj)):
    O = paint(O, obj)
    for v, (i, j) in obj:
      for k in range(j + 1, width(I)):
        if index(O, (i, k)) == mostcolor(I):
          O = fill(O, v, {(i, k)})
        else:
          break
  return O

8.341943def chdbhddjfaebebjaabddfigafajbbgfh(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if index(I, (i, j)) != mostcolor(I) and index(I, (i, j + 1)) == mostcolor(I):
        O = fill(O, index(I, (i, j)), {(i, j + 1)})
  return O

16.464525def jjhbabhiehacebdeadgdfjbcbcagbfga(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I) - 1):
      c = I[i][j]
      if c != mostcolor(I) and I[i][j + 1] == mostcolor(I):
        left_connected = any(I[i][k] == c for k in range(j))  # Efficient left connection check
        if left_connected:
          O = fill(O, c, {(i, j + 1)})
  return O

22.98013def gcdedceacefjeeedbhbaaeddchfaadih(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in objects(I, T, F, T):
    c = color(obj)
    rightmost_col = rightmost(obj)
    if rightmost_col < width(I) - 1:  # Check if the object touches the right edge
      O = paint(O, obj)  # If not, paint the object as is
    else:  
      O = paint(O, shift(obj, (0, -1)))  # If yes, shift the object one position left and paint
  return O

12.693241def bfhijehacaadecgjicifdbdbachaafge(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    for i in range(1, max(height(I), width(I))):
      if hline(obj) or (width(obj) > height(obj)):
        offset = (0, i)
      else:
        offset = (i, 0)
      shifted_obj = shift(obj, offset)
      if any(len(intersection(toindices(shifted_obj), toindices(other_obj))) > 0 for other_obj in objs) or bordering(shifted_obj, I):
        break
      O = paint(cover(O, shifted_obj), shifted_obj)
  return O

23.4049def ahdedgbcbjdfebjdbiifjdbeehdichdb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    h, w = shape(obj)
    if h > w:
      start_j = leftmost(obj)
      for j in range(start_j + w, width(I)):
        if index(I, (uppermost(obj), j)) != mostcolor(I):
          break
        O = paint(O, {(color(obj), (i, j)) for i in range(uppermost(obj), lowermost(obj) + 1)})
    else:
      start_i = uppermost(obj)
      for i in range(start_i + h, height(I)):
        if index(I, (i, leftmost(obj))) != mostcolor(I):
          break
        O = paint(O, {(color(obj), (i, j)) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return O

29.777822def fhjjidechcbdecgdbjcdgcfbacfhfcad(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I):
        if any(I[k][j] == I[i][j] for k in range(i)):
          for new_i in range(i + 1, height(I)):
            if I[new_i][j] != mostcolor(I):
              break
            O = paint(O, {(I[i][j], (new_i, j))})
        else:
          for new_j in range(j + 1, width(I)):
            if I[i][new_j] != mostcolor(I):
              break
            O = paint(O, {(I[i][j], (i, new_j))})
  return O

13.413392def icidibcgfgaceagaahbcbicjdfbfghed(I):
  for value in palette(I) - {mostcommon(I)}:
    obj = toobject(ofcolor(I, value), I)
    right_edge = rightmost(obj)
    for j in range(right_edge + 1, width(I)):
      frontier = {(i, j) for i in range(height(I))}
      if len(intersection(toindices(obj), frontier)) > 0 and len(intersection(ofcolor(I, value), frontier)) == 0:
        break
      I = underfill(I, value, {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1)})
  O = I
  return O

22.243834def ibaaaaafeifiegafjcedccigefeddbag(I):
  objs = fgpartition(I) # Get all objects excluding background
  for obj in objs:
    direction = (0, 1) # Define direction as rightwards
    start = rightmost(obj) # Start extending from the rightmost point of the object
    path = shoot((uppermost(obj), start), direction) # Create a path extending rightwards
    I = underfill(I, color(obj), intersection(path, backdrop(obj))) # Fill the path with object's color within its bounding box
  return I

30.071901def fefeaahfiadbebdabfjeccgbagccchha(I):
  for i in range(len(I)):
    for j in range(len(I[0])-1):
      if I[i][j] != mostcolor(I) and I[i][j+1] == mostcolor(I): # Check for object edge
        I = fill(I, I[i][j], {(i, k) for k in range(j+1, len(I[0]))}) # Fill rightwards from edge
  return I

18.694744def dadjhbecbjececgcbeabcaiccfdeeefe(I):
  objs = sorted(fgpartition(I), key=lambda obj: leftmost(obj)) # Sort objects by their leftmost point
  for obj in objs:
    I = underfill(I, color(obj), {(i, j) for i in range(uppermost(obj), lowermost(obj)+1) for j in range(leftmost(obj), len(I[0]))}) # Fill rightwards within object's vertical bounds
  return I

12.10245def deafchegddaeehaiaeeabfaibbaeadca(I):
  for obj in fgpartition(I):
    right_edge = max(j for _, (i, j) in obj) # Find the rightmost column of the object
    for _, (i, j) in obj:
      if j == right_edge: # If a cell is on the right edge
        I = underfill(I, color(obj), {(i, k) for k in range(j+1, len(I[0]))}) # Extend rightwards from that cell
  return I

17.144022def cfaaejhgdfegegefiacjaaiadjgcaehb(I):
    for value in palette(I) - {mostcolor(I)}:
        for obj in objects(I, T, F, T):
            if color(obj) != value:
                continue
            for d in [LEFT, RIGHT, UP, DOWN]:
                shifted_obj = shift(obj, d)
                while not any(index(I, loc) != mostcolor(I) for loc in toindices(shifted_obj)) and \
                      any(manhattan(obj2, shifted_obj) == 1 and color(obj2) == value for obj2 in objects(I, T, F, T) - {obj}):
                    shifted_obj = shift(shifted_obj, d)
                I = underpaint(I, shift(shifted_obj, invert(d)))
    O = I
    return O

20.294706def ddghafbadaibefjibjfebibijcahgebc(I):
    objs = objects(I, T, F, T)
    for obj1 in objs:
        for obj2 in objs - {obj1}:
            if color(obj1) == color(obj2):
                if hmatching(obj1, obj2) and not vmatching(obj1, obj2):
                    direction = gravitate(obj1, obj2)
                    I = underpaint(I, shift(obj1, direction))
                elif vmatching(obj1, obj2) and not hmatching(obj1, obj2):
                    direction = gravitate(obj1, obj2)
                    I = underpaint(I, shift(obj1, direction))
    O = I
    return O

20.941689def ibdbicdgahcfeebabeheegficebjbcji(I):
    for value in palette(I) - {mostcolor(I)}:
        objs = colorfilter(objects(I, T, F, T), value)
        while any(manhattan(obj1, obj2) == 2 for obj1 in objs for obj2 in objs - {obj1}):
            for obj1 in objs:
                for obj2 in objs - {obj1}:
                    if manhattan(obj1, obj2) == 2:
                        for d in [LEFT, RIGHT, UP, DOWN]:
                            if any(manhattan(shift(obj1, d), obj2) == 1 for obj2 in objs - {obj1}):
                                I = underpaint(I, shift(obj1, d))
                        objs = colorfilter(objects(I, T, F, T), value)
    O = I
    return O

19.911566def dfcccbagbcjbeehejjciheeeibcdedaa(I):
  O = I
  objs = objects(I, T, F, T)
  for obj in objs:
    for direction in [(0, 1), (1, 0)]: # Check right and down directions
      shifted_obj = obj
      while True:
        next_shifted_obj = shift(shifted_obj, direction)
        # Stop if shifted object goes out of bounds or overlaps with another object
        if any(i < 0 or i >= len(I) or j < 0 or j >= len(I[0]) or (I[i][j] != mostcolor(I) and (i, j) not in toindices(obj)) for _, (i, j) in next_shifted_obj):
          break
        shifted_obj = next_shifted_obj
      O = paint(O, recolor(color(obj), shifted_obj))  # Paint the extended object
  return O

40.911175def hjicfheedgaaehbiagcedeebadbgejcf(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        # Extend Right
        k = j + 1
        while k < len(I[0]) and I[i][k] == mostcolor(I):
          O = fill(O, I[i][j], {(i, k)})
          k += 1
        # Extend Down
        k = i + 1
        while k < len(I) and I[k][j] == mostcolor(I):
          O = fill(O, I[i][j], {(k, j)})
          k += 1
  return O 

32.75097def ifajccacdfbdedeejddbafdaiiaiggdg(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))  # Start with an empty canvas
  objs = objects(I, T, F, T)
  for obj in objs:
    normalized = normalize(obj)
    for i in range(h - height(normalized) + 1):  # Iterate through possible vertical positions
      for j in range(w - width(normalized) + 1):  # Iterate through possible horizontal positions
        shifted_obj = shift(normalized, (i, j))
        if all(I[row][col] == mostcolor(I) or (row, col) in toindices(obj) for _, (row, col) in shifted_obj):  # Check for overlap
           O = paint(O, recolor(color(obj), shifted_obj)) # Paint if no overlap
  return O

42.13454def fecafeegddfcecacaffjcfgbeaaeeddh(I):
  O = I
  objs = objects(I, T, F, T)
  for obj in objs:
    # Find the bounding box of the object
    min_i, min_j = ulcorner(obj)
    max_i, max_j = lrcorner(obj)
    
    # Extend Right
    for j in range(max_j + 1, len(I[0])):
      if all(I[i][j] == mostcolor(I) for i in range(min_i, max_i + 1)):
        O = fill(O, color(obj), {(i, j) for i in range(min_i, max_i + 1)})
      else:
        break
    # Extend Down
    for i in range(max_i + 1, len(I)):
      if all(I[i][j] == mostcolor(I) for j in range(min_j, max_j + 1)):
        O = fill(O, color(obj), {(i, j) for j in range(min_j, max_j + 1)})
      else:
        break
  return O

42.29924def gaeadhfcffdfedeajecaaabbjeeacicc(I):
  O = I
  objs = objects(I, T, F, T)
  for obj in objs:
    for (i, j) in toindices(obj):
      # Extend Right
      for k in range(j + 1, len(I[0])):
        if I[i][k] == mostcolor(I):
          O = fill(O, I[i][j], {(i, k)})
        else:
          break
      # Extend Down
      for k in range(i + 1, len(I)):
        if I[k][j] == mostcolor(I):
          O = fill(O, I[i][j], {(k, j)})
        else:
          break
  return O

33.60008def dchbjbdjaecbeageaicbfdjghbdaffff(I):
  O = canvas(mostcolor(I), shape(I))  # Initialize output grid with background color
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1: # If cell color is 1
        O = fill(O, 1, connect((i,j), (i, width(I)-1))) # Fill horizontally from current position to the right edge with 1
        break # Move to the next row
  return O

9.710849def haaceahcffaaeeihahceceiifjhfdjdc(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)-1):
      if I[i][j] == 1 and I[i][j+1] == 0: # If we find a '1' followed by a '0'
        O = fill(O, 1, connect((i,j), (i, width(I)-1))) # Fill horizontally from the '1' to the right edge with '1's
        break # Move to the next row
  return O 

10.550992def efdhfjfagfedebeejficjbajadfbiibf(I):
  for j in range(width(I)-1):
    for i in range(height(I)):
      if I[i][j] == 1:
        k = j + 1
        while k < width(I) and I[i][k] == 0:
          I = fill(I, 1, {(i, k)})
          k += 1
        break
  return I

20.595758def eehaejafiehdechgafaeafabbabbacdj(I):
  for obj in fgpartition(I):  # Iterate over foreground objects
    if rightmost(obj) != width(I) - 1:  # If the object doesn't touch the right edge
      extension = connect((uppermost(obj), rightmost(obj) + 1), (lowermost(obj), width(I) - 1))  # Line from object's right edge to the grid's right edge
      I = underfill(I, color(obj), extension)  # Extend the object by filling the line
  O = I
  return O

11.018187def ffbaeibcefebecedjaihaeaibhbiieed(I):
  for value in palette(I) - {mostcommon(I)}:  # Iterate over foreground colors
    obj = toobject(ofcolor(I, value), I)  # Get the object of the current color
    while rightmost(obj) != width(I) - 1:  # Loop until the object reaches the right edge
      I = underfill(I, value, {(lowermost(obj), rightmost(obj) + 1)})  # Extend the object one cell to the right
      obj = toobject(ofcolor(I, value), I)  # Update the object
  O = I
  return O

17.668821def cabdfbaahdccedffbfhbefjicfbehcac(I):
  for obj in fgpartition(I):  # Iterate over foreground objects
    target_column = width(I) - 1  # Target column is the rightmost column
    for j in range(rightmost(obj) + 1, width(I)):
      if index(I, (center(obj)[0], j)) != mostcommon(I):
        target_column = j - 1  # Find the first non-background cell and stop before it
        break
    I = underfill(I, color(obj), connect((center(obj)[0], rightmost(obj) + 1), (center(obj)[0], target_column)))  # Extend object to the target column
  O = I
  return O

8.18154def fcbbhbdbcageegaebcbicfjdiebciiaa(I):
  for obj in fgpartition(I):
    for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Check all four directions
      path = shoot(center(obj), direction)
      collision = False
      for other_obj in fgpartition(I):
        if color(obj) != color(other_obj) and len(intersection(toindices(other_obj), path)) > 0:
          collision = True
          break
      if collision:
        I = underfill(I, color(obj), intersection(path, backdrop(obj)))
  return I

15.432181def ggdfgjedfhdeeccibccecceafgeefibj(I):
  objs = fgpartition(I)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        if hmatching(obj1, obj2):
          direction = (1, 0) if center(obj1)[0] < center(obj2)[0] else (-1, 0)
          I = underfill(I, color(obj1), intersection(shoot(center(obj1), direction), backdrop(obj1)))
        if vmatching(obj1, obj2):
          direction = (0, 1) if center(obj1)[1] < center(obj2)[1] else (0, -1)
          I = underfill(I, color(obj1), intersection(shoot(center(obj1), direction), backdrop(obj1)))
  return I

8.908877def ahfdbiabegffehbbbdebbdjijfcahbgc(I):
  objs = fgpartition(I)
  for obj1 in objs:
    closest_obj = next((obj2 for obj2 in objs if color(obj1) != color(obj2) and manhattan(obj1, obj2) == 2), None)
    if closest_obj:
      direction = gravitate(obj1, closest_obj)
      I = underfill(I, color(obj1), intersection(shoot(center(obj1), direction), backdrop(obj1)))
  return I

32.250607def icggcibecggdeeadjcdagedbjjjicdgi(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    leftmost_j = leftmost(obj)
    for (i, j) in toindices(obj):
      O = paint(O, {(color(obj), (i, j))})
      for k in range(j + 1, len(I[0])):
        if k >= leftmost_j:
          O = fill(O, color(obj), {(i, k)})
        else:
          break
  return O

39.286484def iagbdhbebadfegfejffhhihdgidbbadi(I):
  O = I
  for obj in fgpartition(I):
    for i in range(height(I)):
      row_obj = {(v, (i, j)) for v, (i, j) in obj if i == i}
      if len(row_obj) > 0:
        O = fill(O, color(obj), {(i, k) for k in range(leftmost(row_obj), len(I[0]))})
  return O 

29.79127def jfdehiacbbeiejafiaaafefhecfbadeb(I):
  O = I
  for obj in fgpartition(I):
    indices = toindices(obj)
    min_j, max_j = leftmost(indices), rightmost(indices)
    for i in range(uppermost(indices), lowermost(indices) + 1):
      O = fill(O, color(obj), {(i, j) for j in range(min_j, len(I[0])) if (i, j) not in indices})
  return O

14.168383def gbhidajheefjebehjdfadieicbdcdfbh(I):
  O = I
  for obj in fgpartition(I):
    for i, row in enumerate(I):
      obj_in_row = {(v, (i, j)) for v, (i, j) in obj if i == i}
      if len(obj_in_row) > 0:
        j = 0
        while j < len(row):
          if (row[j], (i, j)) in obj_in_row:
            j += 1
          elif row[j] == mostcolor(I):
            O = fill(O, color(obj), {(i, j)})
            j += 1
          else:
            break 
  return O

32.517353def ahdgdfebfcedecjeiccjfdddjffchfhf(I):
  O = I
  objs = objects(I, True, False, True)
  for obj in objs:
    for j in range(leftmost(obj), width(I)):
      column_segment = {(v, (i, j)) for v, (i, j) in obj if j == j}
      if len(column_segment) > 0:
        for i in range(uppermost(column_segment), lowermost(column_segment) + 1):
          if I[i][j] == mostcolor(I):
            O = fill(O, color(obj), {(i, j)})
          else:
            break
  return O

8.052644def hjagafcbddfbeafiabjijdgcaifcfeaj(I):
  O = canvas(mostcolor(I), shape(I))
  objs = sorted(objects(I, True, False, True), key=lambda obj: leftmost(obj))
  for obj in objs:
    O = paint(O, obj)
    for j in range(leftmost(obj) + 1, width(I)):
      if len(intersection(toindices(obj), {(i, j) for i in range(height(I))})) == 0:
        break
      O = paint(O, recolor(color(obj), {(i, j) for i in range(height(I)) if index(I, (i, j)) == mostcolor(I)}))
  return O

42.158184def fiiibdhbbgceeedjafidefdhhgceccdi(I):
  O = I
  for j in range(width(I) - 1):
    for i in range(height(I)):
      if I[i][j] != mostcolor(I) and I[i][j + 1] == mostcolor(I):
        O = fill(O, I[i][j], hfrontier((i, j + 1)))
  return O

31.84454def ebdedcbebdbeefbiigcbbfagefhbadee(I):
  O = I
  for obj in objects(I, True, False, True):
    rightmost_col = rightmost(obj)
    for j in range(rightmost_col + 1, width(I)):
      collision = False
      for i in range(uppermost(obj), lowermost(obj) + 1):
        if I[i][j] != mostcolor(I):
          collision = True
          break
      if collision:
        break
      else:
        O = fill(O, color(obj), {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1)})
  return O

30.071901def jahedjbbbffjefabjdcdfabeiddcdigg(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if I[i][j] != mostcolor(I) and I[i][j + 1] == mostcolor(I):
        frontier = {(i, k) for k in range(j + 1, width(I))}
        O = fill(O, I[i][j], frontier)
        break
  return O

34.93266def edhdccgffgjeecccidbehefhgdgacege(I):
  last_top_row = last(I[0])
  last_left_col = last(dmirror(I)[0])

  direction = (
    0 if last_top_row == last_left_col else (1 if index(I, (0, width(I)-1)) < index(I,(height(I)-1, 0)) else -1), 
    1 if last_top_row != last_left_col else (1 if index(I, (0, width(I)-1)) > index(I,(height(I)-1, 0)) else -1)
  )

  objs = fgpartition(I)
  O = I
  for obj in objs:
    for _ in range(42):
      obj = shift(obj, direction)
      O = underpaint(O, obj)
  return O

7.679388def aedbbadjefegeigdaaeahffdhbfdabbg(I):
  h_direction = 1 if index(I, (0, width(I)-1)) < index(I,(height(I)-1, 0)) else -1
  v_direction = 1 if index(I, (0, width(I)-1)) > index(I,(height(I)-1, 0)) else -1

  objs = fgpartition(I)
  O = I
  for obj in objs:
    if hmatching(obj,  {(0, width(I)-1)}):
      for _ in range(42):
        obj = shift(obj, (0, h_direction))
        O = underpaint(O, obj)
    elif vmatching(obj,  {(height(I)-1, 0)}):
      for _ in range(42):
        obj = shift(obj, (v_direction, 0))
        O = underpaint(O, obj) 
  return O

11.437601def dfifagiccadaebahjbdcdahbcaaaicbh(I):
  objs = fgpartition(I)
  while True:
    changed = False
    for obj in objs:
      for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        next_cell = add(centerofmass(obj), direction)
        if index(I, next_cell) == mostcolor(I) and next_cell in backdrop(obj):
          I = underfill(I, color(obj), {next_cell})
          changed = True
    if not changed:
      break
  O = I
  return O

11.496208def eecfhedcbchdebgjaecideeieicajddj(I):
  objs = fgpartition(I)
  while len(objs) > 0:
    new_objs = set()
    for obj in objs:
      for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        next_cell = add(centerofmass(obj), direction)
        if index(I, next_cell) == mostcolor(I) and next_cell in backdrop(obj):
          new_obj = frozenset((*obj, (color(obj), next_cell)))
          new_objs.add(new_obj)
          I = underfill(I, color(obj), {next_cell})
          break
    objs = new_objs
  O = I
  return O

14.33517def cgcfdchdeeaaeidfijfhcfbaadhadihg(I):
  objs = fgpartition(I) # Get all objects except background
  for obj in objs:
    direction = (0, 1)  # Set initial direction to right
    for i in range(1, width(I)): # Iterate through columns
      shifted_obj = shift(obj, (0, i)) # Shift the current object to the right
      for other_obj in objs:
        if color(other_obj) != color(obj) and hmatching(shifted_obj, other_obj):
          I = underpaint(I, recolor(color(obj), intersection(backdrop(shifted_obj), backdrop(obj))))
          break  # Stop extending if another object is encountered
      else:
        continue # Continue to the next column if no other object found
      break # Break the outer loop if another object is found
  return I

10.86442def ffebbfecdgdhefebjhdbeijfefbfajhe(I):
  objs = fgpartition(I)
  for obj in objs:
    right_edge = rightmost(obj)
    for j in range(right_edge + 1, width(I)):
      if index(I, (uppermost(obj), j)) != mostcolor(I):
        break
      I = underfill(I, color(obj), {(uppermost(obj), j)}) 
  return I

32.32506def ficahecabfibejdiafifdebacejibdgb(I):
    objs = fgpartition(I)
    for obj in objs:
        for x, y in toindices(obj):
            for j in range(y+1, width(I)):
                if index(I, (x, j)) != mostcolor(I):
                    break
                I = underfill(I, color(obj), {(x, j)})
    return I

28.298048def eedaadffheieecjcajebejabhcefjbji(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  for obj in objs:
    rightmost_cell = argmax(obj, lambda c: c[1][1])
    for j in range(rightmost_cell[1][1] + 1, width(I)):
      if index(I, (rightmost_cell[1][0], j)) == mostcolor(I):
        I = underfill(I, color(obj), {(rightmost_cell[1][0], j)})
      else:
        break
  return I

10.172783def baaejfdaeaedechhiaeaacdjiaadbbce(I):
  for obj in fgpartition(I):
    bg = difference(asindices(I), toindices(obj))
    closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
    if vmatching(obj, {closest_bg}):
      direction = (sign(closest_bg[0] - centerofmass(obj)[0]), 0)
    else:
      direction = (0, sign(closest_bg[1] - centerofmass(obj)[1]))
    path = shoot(centerofmass(obj), direction)
    I = underfill(I, color(obj), intersection(path, bg))
  O = I
  return O

8.8624def eaiafichcgaaehaeahbeifijjidedbei(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    O = paint(O, obj)
    bg = difference(asindices(I), toindices(obj))
    closest_bg = argmin(bg, lambda x: manhattan({x}, obj))
    if vmatching(obj, {closest_bg}):
      O = underfill(O, color(obj), connect(center(obj), (center(obj)[0], closest_bg[1])))
    else:
      O = underfill(O, color(obj), connect(center(obj), (closest_bg[0], center(obj)[1])))
  return O

8.273074def jeeicifaddgfeeefbaecbibaejgccafd(I):
  O = I
  for obj in fgpartition(I):
    bg = difference(asindices(I), toindices(obj))
    closest_bg = argmin(bg, lambda x: manhattan(obj, {x}))
    if hmatching(obj, {closest_bg}):
      path = connect(centerofmass(obj), (closest_bg[0], centerofmass(obj)[1]))
    else:
      path = connect(centerofmass(obj), (centerofmass(obj)[0], closest_bg[1]))
    O = underfill(O, color(obj), path)
  return O

15.948753def edhagafdcagceijabjbbeaddbeehdjdj(I):
  O = I
  for obj in fgpartition(I):
    distances = sorted(product(toindices(obj), difference(asindices(I), toindices(obj))), key=lambda x: manhattan({x[0]}, {x[1]}))
    closest_pair = first(distances)
    path = connect(closest_pair[0], closest_pair[1])
    O = underfill(O, color(obj), path)
  return O

23.06521def cbidcbaejajcechajgceiijdffjdgfab(grid):
  objs = objects(grid, univalued=True, diagonal=False, without_bg=True)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) == color(obj2) and obj1 != obj2 and hmatching(obj1, obj2):
        if leftmost(obj1) < leftmost(obj2):
          direction = (0, 1)
          while not adjacent(obj1, obj2):
            obj1 = shift(obj1, direction)
          grid = paint(cover(grid, obj1), obj1)
  return grid

12.896246def dhaceadffhfeefdcbbfdacdahaagaiha(I):
  O = I
  for j in range(width(I)):
    if I[0][j] != 0:
      O = fill(O, I[0][j], hfrontier((0,j)))
  for i in range(height(I)):
    if I[i][width(I)-1] != 0:
      O = fill(O, I[i][width(I)-1], vfrontier((i, width(I)-1)))
  return O

32.122314def dbeahafbecdaebebbbbdibebdedadghc(I):
  O = I
  target_row = next((i for i, row in enumerate(I) if any(row)), None) 
  target_col = width(I) - 1 if target_row is not None else None
  if target_col is None:
    target_col = next((j for j in range(width(I)) if I[-1][j] != 0), None)
    target_row = height(I) - 1
  
  for obj in fgpartition(I):
    if any(i == target_row for i,j in toindices(obj)) or any(j == target_col for i,j in toindices(obj)):
      O = fill(O, color(obj), backdrop(obj)) 
  return O

38.038868def dddebddagbdhejbdafebhdedegcadbdc(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != 0:
        if i == 0 or j == width(I) - 1:
          O = paint(O, recolor(val, backdrop(ofcolor(I, val))))
  return O

15.423506def abgadjcfbfeeeedbacbidfejdfbdagce(I):
  O = I
  for obj in fgpartition(I):
    if any(index(I, (i, j)) != 0 and (i == 0 or j == width(I) - 1) for i, j in toindices(obj)):
      O = paint(O, recolor(color(obj), connect(ulcorner(obj), lrcorner(obj))))
  return O

34.332893def echbeiibajdeeffcbecadjcdigbefjgd(I):
  O = I
  for obj in objects(I, T, F, T):
    for i in range(height(obj)):
      row = {(v, (r, c)) for v, (r, c) in obj if r == uppermost(obj) + i}
      if len(row) > 0:
        rightmost = urcorner(row)
        O = paint(cover(O, row), {(color(obj), rightmost)}) 
  return O

34.67868def abifddhgbbbcejafbdbhfhjfdhaeefeb(I):
  O = canvas(ZERO, shape(I))
  for c in palette(I):
    obj = frozenset((c, i) for i in ofcolor(I, c))
    for i in range(height(obj)):
      row = {(v, (r, c)) for v, (r, c) in obj if r == uppermost(obj) + i}
      if len(row) > 0:
        O = paint(O, {(c, urcorner(row))})
  return O

38.17197def iaaeffeeecbgehdcjfcdghicdidcjbbc(I):
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    for j in range(width(I) - 1, -1, -1):
      if I[i][j] != ZERO:
        O = paint(O, {(I[i][j], (i, j))})
        break
  return O

25.831966def jddgdhcafjgbedacbefijcacfhbddchd(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    if portrait(obj):  # If the object is taller than it is wide
      I = fill(I, mostcolor(I), obj)  # Clear the original object
      I = paint(I, shift(normalize(obj), (0, leftmost(obj))))  # Align to the left
    else:  # If the object is wider than it is tall or a square
      I = fill(I, mostcolor(I), obj)  # Clear the original object
      I = paint(I, shift(normalize(obj), (uppermost(obj), 0)))  # Align to the top
  return I

40.43453def ajbdedbdfhdjebdeibeeajeedbejbbje(I):
  for v in palette(I) - {mostcolor(I)}:
    obj = toobject(ofcolor(I, v), I)
    if portrait(obj):
      I = fill(I, mostcolor(I), obj)
      I = underfill(I, v, vfrontier((uppermost(obj), 0)))
    else:
      I = fill(I, mostcolor(I), obj)
      I = underfill(I, v, hfrontier((0, leftmost(obj))))
  return I

39.098583def baidbdffefahedjdiidfjdcfbficfgfc(I):
  for obj in fgpartition(I):
    if height(obj) > width(obj):
      I = paint(cover(I, obj), recolor(color(obj), {(i, 0) for i in range(height(obj))}))
    else:
      I = paint(cover(I, obj), recolor(color(obj), {(0, j) for j in range(width(obj))}))
  return I

42.628086def bdfadcfgjdfdecebachdegffbaecfgad(I):
  for v in palette(I) - {mostcolor(I)}:
    indices = ofcolor(I, v)
    if height(indices) > width(indices):
      I = fill(I, mostcolor(I), indices)
      for i in range(height(indices)):
        I = fill(I, v, {(i, 0)})
    else:
      I = fill(I, mostcolor(I), indices)
      for j in range(width(indices)):
        I = fill(I, v, {(0, j)})
  return I

9.814656def cfebbhdbdcebegadieccefcfgdcbfbbe(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    if len(obj) == 1:
      continue
    ci, cj = centerofmass(obj)
    new_obj = set()
    for v, (i, j) in obj:
      new_i = i + crement(ci - i)
      new_j = j + crement(cj - j)
      new_obj.add((v, (new_i, new_j)))
    I = paint(cover(I, obj), frozenset(new_obj))
  return I

52.482372def adfbggbdafececjhaffaffccbbaagbci(I):
  objs = fgpartition(I)  # Get objects without background
  bg = mostcolor(I)
  for obj in objs:
    for v, (i, j) in obj:
      if (i, j) != ulcorner(obj):  # Check if it's not the top-left corner
        I = fill(I, bg, {(i, j)})  # Recolor with background
  return I

49.518005def aaeghibhbdecebjfieddcbdihdfieeag(I):
  O = canvas(mostcolor(I), shape(I))  # Create an empty canvas
  for obj in fgpartition(I):
    O = paint(O, {(color(obj), ulcorner(obj))})  # Paint top-left corner of each object
  return O

56.85753def fcdeaehecaeaeeacadcabedbafdcidhc(grid):
  objs = objects(grid, univalued=True, diagonal=False, without_bg=True)
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    leftmost_col = leftmost(obj)
    shifted_obj = shift(obj, (0, -leftmost_col))
    new_grid = paint(new_grid, shifted_obj)
  return compress(new_grid)

57.10391def affheifbeabbehebaeeedbfbdccffchh(grid):
  return dmirror(compress(dmirror(paint(canvas(mostcolor(grid), shape(grid)), 
                                         merge(apply(lambda obj: shift(obj, (0, -leftmost(obj))), 
                                                     objects(grid, univalued=True, diagonal=False, without_bg=True)))))))

40.455254def gcjfbbaaecfcecijibceehaehacbfgdc(grid):
  h, w = len(grid), len(grid[0])
  new_grid = [list(row) for row in grid]  # Create a mutable copy
  for j in range(w):
    first_val = next((grid[i][j] for i in range(h) if grid[i][j] != mostcolor(grid)), None)
    if first_val is not None:
      for i in range(h):
        if grid[i][j] == first_val:
          new_grid[i][j] = first_val
        else:
          new_grid[i][j] = mostcolor(grid)
  return compress(tuple(tuple(row) for row in new_grid))

33.52962def ejdaegddfdcdehbdbbeeafgcaaeecegc(grid):
  transformed = tuple(
      tuple(
          next((v for v in row[j:] if v != mostcolor(grid)), mostcolor(grid))
          for j in range(len(grid[0]))
      )
      for row in grid
  )
  return compress(transformed)

22.593014def achihjbfbebfeebdbeedbgbacjfdbbfh(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for j in range(width(grid)):
    column = tuple(grid[i][j] for i in range(height(grid)))
    first_non_bg = next((v for v in column if v != mostcolor(grid)), None)
    if first_non_bg is not None:
      new_grid = paint(new_grid, {(first_non_bg, (i, j)) for i in range(height(grid)) if column[i] == first_non_bg})
  return new_grid

39.359615def cbiaajfgbahjeebdiccddcifedaedgic(I):
  objs = objects(I, T, F, T) # Identify all objects in the grid.
  rightmost_cells = frozenset((color(obj), urcorner(obj)) for obj in objs)  # Find the rightmost cell (color, index) for each object.
  O = paint(canvas(ZERO, shape(I)), rightmost_cells)  # Create a blank canvas and paint the rightmost cells onto it.
  return O 

32.901333def hheceaibbdjhehfbbfgadaiahbbhbaed(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        _, (i, j) =  extract(obj, lambda cell: cell[1] == urcorner(obj))
        O = fill(O, 0, frozenset({(i, k) for k in range(j)}) )
    return O

15.009314def ddicaedjdffiedhiidaceehjbceidaef(I):
  for v in palette(I) - {mostcolor(I)}:  
    target_loc = (uppermost(ofcolor(I, v)), leftmost(ofcolor(I, v)))
    for i, j in ofcolor(I, v):
      if i == target_loc[0]:
        I = fill(I, v, {(i, k) for k in range(j, target_loc[1], -1)})
      elif j == target_loc[1]:
        I = fill(I, v, {(k, j) for k in range(i, target_loc[0], -1)})
  return I

15.5141735def bhcicfiiaefdedceiciabeabhbecjfij(I):
  for obj in partition(I):
    if color(obj) != mostcolor(I):
      ti, tj = ulcorner(obj)
      for _, (i, j) in sorted(obj, key=lambda x: (x[1][0], x[1][1])):
        if i == ti:
          I = fill(I, color(obj), connect((i, j), (i, tj)))
        if j == tj:
          I = fill(I, color(obj), connect((i, j), (ti, j)))
  return I

32.395763def eabeabgefejfebjhijfefjfhbbccddia(I):
  for v in palette(I) - {mostcolor(I)}:
    indices = ofcolor(I, v)
    target = ulcorner(indices)
    shifted_indices = {(i, j - (j - target[1])) if i == target[0] else (i - (i - target[0]), j) for i, j in indices}
    I = fill(I, mostcolor(I), indices)
    I = fill(I, v, shifted_indices)
  return I

25.27638def icaaebeeehfeeceijdgedicdejegchgd(I):
  for obj in fgpartition(I):
    target_i, target_j = ulcorner(obj)
    new_obj = set()
    for _, (i, j) in obj:
      new_j = target_j if i == target_i else j
      new_i = target_i if j == target_j else i
      new_obj.add((color(obj), (new_i, new_j)))
    I = paint(cover(I, obj), frozenset(new_obj))
  return I

27.907871def egdeicacegfeefgdjjiifahiicgcebii(I):
  for v in palette(I) - {mostcolor(I)}:
    min_i = min(i for i, j in ofcolor(I, v))
    min_j = min(j for i, j in ofcolor(I, v))
    for i, j in ofcolor(I, v):
      if i == min_i:
        I = fill(I, v, {(i, k) for k in range(j, min_j - 1, -1)})
      else:
        I = fill(I, v, {(k, j) for k in range(i, min_i - 1, -1)})
  return I

39.575237def egefgfbebbfdeaicajcgedahcbfeffcc(I):
  objs = objects(I, True, False, True)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    leftmost_cell = argmin(obj, lambda cell: cell[1][1])  # Find leftmost cell in object
    O = paint(O, initset(leftmost_cell))  # Paint only the leftmost cell
  return O

39.38893def bhbebadffheaecfcjcefbabbcbigeccb(I):
  objs = objects(I, True, False, True)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    topmost_cell = argmin(obj, lambda cell: cell[1][0])  # Find topmost cell
    O = paint(O, initset(topmost_cell))  # Paint only the topmost cell
  return O

35.427986def cjidadfddfajefbfbahdcbgfaeaahaed(I):
    objs = objects(I, True, False, True)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        leftmost_col = leftmost(obj)  # Find the leftmost column index
        column_cells = sfilter(obj, lambda cell: cell[1][1] == leftmost_col) # Get all cells in that column
        O = paint(O, column_cells) 
    return O

31.478489def decdajbgbfafecjejfjdicfbjfgccadb(I):
  objs = objects(I, True, False, True)
  O = I 
  for obj in objs:
    for cell in obj:
      if len(intersection(dneighbors(cell[1]), toindices(obj))) < 2:  # Check if cell has less than 2 direct neighbors
        O = cover(O, initset(cell[1]))  # Remove cells with less than 2 neighbors
  return O

10.8056135def dcgbijibdbbbebcdihdaiefdgcdadcdd(I):
  objs = objects(I, True, False, True)
  O = canvas(mostcolor(I), shape(I)) 
  for obj in objs:
    bbox = box(obj)  # Get the bounding box of the object
    O = underfill(O, color(obj), bbox)  # Fill the bounding box on the output canvas
  return O

38.088333def egcjcaehbeedeabbbbacaiefjeccdcgj(I):
  O = I
  for obj in fgpartition(I):
    start_i, start_j = ulcorner(obj)
    end_i, end_j = argmax(
        toindices(obj),
        lambda loc: max(abs(loc[0] - start_i), abs(loc[1] - start_j)) * (1 if (loc[0] != start_i or loc[1] != start_j) else 0)
    )
    line = connect((start_i, start_j), (end_i, end_j))
    O = paint(cover(O, obj), recolor(color(obj), line))
  return O

18.990778def debeeeieaefjebdjahbebffjfadcdicd(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    if hline(obj) or vline(obj):
      O = paint(O, obj)
      continue
    start = ulcorner(obj)
    if width(obj) > height(obj):
      end = (start[0], rightmost(obj))
    else:
      end = (lowermost(obj), start[1])
    O = paint(O, recolor(color(obj), connect(start, end)))
  return O

19.393734def ecbegacjeaceebdbibeejahdaaacbcfd(I):
  def find_endpoint(obj, start):
    candidates = ((i, j) for i, j in toindices(obj) if i != start[0] or j != start[1])
    return next(
      (
          (i, j)
          for i, j in sorted(candidates, key=lambda loc: (abs(loc[0] - start[0]) + abs(loc[1] - start[1])), reverse=True)
          if i == start[0] or j == start[1]
      ),
      start,
    )
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    start = ulcorner(obj)
    end = find_endpoint(obj, start)
    O = paint(O, recolor(color(obj), connect(start, end)))
  return O

14.290926def fceeejjaadcjeiajiedfbggjafhjfafc(I):
  O = I  # Initialize output grid
  for obj in fgpartition(I):  # Iterate through objects
    min_j = min(j for _, (i, j) in obj)  # Find leftmost column of the object
    O = cover(O, obj)  # Remove object from the grid
    O = paint(O, shift(obj, (0, -min_j)))  # Shift object to the leftmost column and paint it back
  return O

32.07579def fdibdadcgaacecabijaechbiaacjddif(I):
  painted = canvas(mostcolor(I), shape(I))  # Initialize output grid with background color
  for j in range(width(I)):  # Iterate through columns
    for i in range(height(I)):  # Iterate through rows
      c = I[i][j]
      if c != mostcolor(I):  # Check for non-background color
        obj = next(obj for obj in fgpartition(I) if (c, (i, j)) in obj)  # Find the object containing the current cell
        min_j = min(k for _, (_, k) in obj)  # Find the object's leftmost column
        painted = paint(painted, {(c, (i, min_j))})  # Paint the cell at its shifted position in the output grid
  return painted

14.650165def cbadecfdhbdcecfcjjajjhhgdaeeccci(I):
  O = I
  for j in range(width(I)):
    column = frozenset((i, j) for i in range(height(I)))
    for obj in fgpartition(I):
      if intersection(toindices(obj), column):
        min_j = min(k for _, (_, k) in obj)
        O = cover(O, obj)
        O = paint(O, shift(obj, (0, -min_j)))
        break
  return O

14.889594def cigbhacddiffehceaehibebfccdjajai(I):
  O = I
  objects_processed = set()
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I):
        obj = next(obj for obj in fgpartition(I) if (I[i][j], (i, j)) in obj)
        if obj not in objects_processed:
          min_j = min(k for _, (_, k) in obj)
          O = cover(O, obj)
          O = paint(O, shift(obj, (0, -min_j)))
          objects_processed.add(obj)
  return O

34.614857def eeeibdjgejedeafcaibddfdafbijecff(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I):
    locs = ofcolor(I, v)
    for i in range(height(I)):
      row_locs = {(a, b) for a, b in locs if a == i}
      if row_locs:
        j = min(row_locs, key=lambda x: x[1])[1]
        O = paint(O, {(v, (i, j))})
  return O

48.594646def bdcdicffajghehfbjdafdfdcgjddeded(I):
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas filled with the background color
  for obj in fgpartition(I): # Iterate over each object
    rightmost_col = argmax(toindices(obj), lambda x: x[1])[1] # Find the rightmost column index
    rightmost_cells = {(v, (i, j)) for v, (i, j) in obj if j == rightmost_col} # Extract cells in the rightmost column
    O = paint(O, rightmost_cells) # Paint the extracted cells onto the canvas
  return O

7.710466def cgffbefaecgiecagibdgegeigeceaeee(I):
  for obj in fgpartition(I): # Iterate over each object
    rightmost_col = rightmost(obj) # Find the rightmost column index
    I = underfill(I, mostcolor(I), {(i, j) for i, j in asindices(I) if j != rightmost_col and (i, j) in toindices(obj)}) # Fill everything but the rightmost column with the background color
  return I

26.518661def cdeagabedifdeibgbbjheccdhdghccii(I):
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for j in range(width(I)): # Iterate over each column
    column_cells = {(I[i][j], (i, j)) for i in range(height(I)) if I[i][j] != mostcolor(I)} # Extract non-background cells in the column
    if len(column_cells) > 0: # Check if the column has non-background cells
      rightmost_object = argmax(objects(paint(canvas(mostcolor(I), shape(I)), column_cells), True, False, True), lambda x: rightmost(x)) # Find the rightmost object in the column
      O = paint(O, rightmost_object) # Paint the rightmost object onto the canvas
  return O

34.67868def hachecbegbhieacabjehffegccicacaf(I):
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for i, row in enumerate(I): # Iterate over each row
    for j, val in enumerate(row): # Iterate over each cell in the row
      if val != mostcolor(I) and j == argmax(((k, v) for k, v in enumerate(row) if v == val), lambda x: x[0])[0]: # Check if it's the rightmost cell of its value in the row
        O = paint(O, {(val, (i, j))}) # Paint the cell onto the canvas
  return O

15.202934def gcecjbbfbdbdebdfijegcecbbcjiaabe(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    bottom_cell = argmax(obj, lambda cell: cell[1][0])
    line = frozenset((color(obj), (bottom_cell[1][0] - i, bottom_cell[1][1])) for i in range(len(obj)))
    O = paint(O, line)
  return O

13.427582def ceabafiaccagegadifcfdcegajbfebhc(I):
  O = I
  for obj in fgpartition(I):
    bottom_j = argmax(toindices(obj), lambda x: x[0])[1]
    line = {(color(obj), (i, bottom_j)) for i in range(uppermost(obj), lowermost(obj) + 1)}
    O = paint(cover(O, obj), line)
  return O

8.468295def beeedcadejdaedififihaabfagbegjgh(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    column = tuple(I[i][j] for i in range(h))
    for v in set(column):
      if v != mostcolor(I):
        start_i = max([i for i, x in enumerate(column) if x == v])
        line = frozenset(((v, (start_i - c, j)) for c in range(column.count(v))))
        O = paint(O, line)
  return O 

33.73746def afffdcaacfebefciicfdedbigcbaaifg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, True):
    min_i, _ = ulcorner(obj)
    max_i, max_j = lrcorner(obj)
    line = frozenset({(color(obj), (max_i - i, max_j)) for i in range(max_i - min_i + 1)})
    O = paint(O, line)
  return O

32.07579def baccfhcafiafegeeajbdiafabjiffbja(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in fgpartition(I): # Iterate over objects without considering background
    leftmost_j = leftmost(obj) # Find the leftmost column index of the object
    O = paint(O, {(color(obj), (i, leftmost_j)) for _, (i, _) in obj}) # Paint a vertical line with the object's color at the leftmost column
  return O 

43.453182def egegbeaffejiebfdibeadghjcaidbcdg(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)): # Iterate over rows
    for j in range(width(I)): # Iterate over columns
      if index(I, (i, j)) != mostcolor(I): # Check if cell is not background
        O = fill(O, index(I, (i, j)), {(i, 0)}) # Fill the output grid's first column in the same row with the object's color
        break # Move to the next row after encountering an object
  return O

41.45941def fhgaccifiaebeddejcbdhhcdcbacdfbg(I):
  return tuple(tuple(next((index(I, (row_index, col_index)) for col_index in range(width(I)) if index(I, (row_index, col_index)) != mostcolor(I)), mostcolor(I)) for _ in range(width(I))) for row_index in range(height(I)))

34.327515def hfceifedfebaeeebjdfcgfbfdbdafbfi(I):
  O = I  # Start with the input grid
  for i in range(len(I)):
    for j in range(len(I[0])-1, 0, -1): # Iterate through each row from right to left
      if I[i][j] != mostcolor(I) and I[i][j-1] == I[i][j]:  # Check if cell is part of an object and not the rightmost one
        O = fill(O, mostcolor(I), {(i, j)})  # Replace the cell with background color
  return O

60.697186def bfacaeeahbbaegbdbcibgifaaacfdjac(I):
  objs = objects(I, T, F, T)  # Extract connected objects
  rightmost_indices = mapply(urcorner, objs) # Find rightmost indices of all objects
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if (i,j) not in rightmost_indices and I[i][j] != mostcolor(I):
        O = fill(O, mostcolor(I), {(i, j)}) # Fill all cells except the rightmost of each object with background color
  return O

20.69345def bfidcajgjgecefhbacegfhdhjfbdacae(I):
  objs = objects(I, True, False, True)  # Extract objects
  for obj in objs:
    leftmost_j = leftmost(obj) # Find leftmost column index of the object
    for i, j in toindices(obj):
      if j > leftmost_j: # For every column other than the leftmost 
        I = fill(I, mostcolor(I), {(i, j)}) # Remove overlapping cells
    I = paint(I, shift(obj, (-j, -leftmost_j))) # Shift object to the left
  return I

13.63977def cadidfdehacjeccgaacjhibdbabadibe(I):
  for j in range(width(I)-1, 0, -1): # Iterate through columns from right to left
    for i in range(height(I)):
      if I[i][j] != mostcolor(I): # If cell is not background
        k = j
        while k > 0 and I[i][k-1] == mostcolor(I): # Find the farthest left position
          k -= 1
        if k != j:
          I = paint(I, {(I[i][j], (i, k))}) # Move the cell to the leftmost available position
          I = fill(I, mostcolor(I), {(i, j)}) # Remove cell from original position
  return I 

16.39258def dbaedjagchdeeddcadebcafbbeifadbb(I):
  for obj in fgpartition(I): # Iterate through foreground objects
    leftmost_cell = argmin(toindices(obj), lambda x: x[1])  # Find the leftmost cell
    target_column = vfrontier(leftmost_cell) # Create a vertical line at the leftmost cell's column
    I = underfill(I, color(obj), target_column)  # Fill the target column with object's color
    I = cover(I, difference(toindices(obj), target_column))  # Remove other cells of the object
  return I

25.43486def eedjccfbijedecacbjjaajbajdecbaed(I):
  new_grid = canvas(mostcolor(I), shape(I))  # Create a new empty grid filled with background color
  for obj in objects(I, True, False, True):  # Extract objects
    min_j = leftmost(obj) # Get the leftmost column index of the object
    for (v, (i, j)) in obj:
      new_grid = paint(new_grid, {(v, (i, j - min_j))}) # Paint the object onto the new grid, shifted to the left
  return new_grid

34.614857def idhcebgbifebeaeeihbdeaceafejdcfa(I):
  for i in range(height(I)):
    row = I[i]
    new_row = []
    current_color = None  # Keep track of the current object color
    for j in range(width(I)):
      if row[j] != mostcolor(I) and row[j] != current_color: # If new object encountered
        new_row.append(row[j]) 
        current_color = row[j] # Update current color
      else:
        new_row.append(mostcolor(I))  # Fill with background color
    I = paint(I, {(v, (i, j)) for j, v in enumerate(new_row)}) # Update the row in the grid
  return I

23.799505def fafcebedffcfedbajegjcbdiagdehhdc(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I):
    for j in range(width(I)):
      column = frozenset((i, j) for i in range(height(I)))
      if index(I, (0, j)) == v:
          O = paint(O, recolor(v, column))
  return O

23.024218def bbdbbabieddfeeieajfhjababjejeieb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    bottom_row = max(i for i, j in toindices(obj))
    rightmost_cells = frozenset((i, j) for i, j in toindices(obj) if i == bottom_row)
    line = recolor(color(obj), rightmost_cells)
    O = paint(O, line)
  return O

42.94559def fecfddaifejaedhejbdehcifbigdbjcg(I):
  """
  Identifies objects, iterates through them, and preserves only the leftmost column of each object.
  """
  objs = fgpartition(I)  # Identify objects without background
  O = fill(I, mostcolor(I), asindices(I))  # Create a blank canvas with background color
  for obj in objs:
    leftmost_col = min(j for _, (i, j) in obj)  # Find the leftmost column index of the object
    O = paint(O, {(v, (i, j)) for v, (i, j) in obj if j == leftmost_col})  # Paint the leftmost column
  return O

32.25747def cffajgceaceeeaegjefdgjdfdbgffcec(I):
  """
  Constructs the output grid column by column, copying only the leftmost cell of each object in each column. 
  """
  O = canvas(mostcolor(I), shape(I))  # Initialize output grid with background color
  for j in range(width(I)):
    column_cells = {(i, j) for i in range(height(I))}  # Get all indices of the current column
    for obj in fgpartition(I):
      intersection = toindices(obj) & column_cells  # Find object cells in the current column
      if intersection:
        i = min(i for i, _ in intersection)  # Find the topmost row index within the intersection
        O = fill(O, index(I, (i, j)), {(i, j)})  # Fill the corresponding cell in the output
        break # Move to the next column once an object's leftmost cell is copied
  return O

26.438715def hbbbgbedeadgeaedjdbbjjhfgjfgieai(I):
  objs = fgpartition(I)
  I = fill(I, mostcolor(I), asindices(I))  # Clear the grid
  for obj in objs:
    leftmost_col = leftmost(obj)
    I = paint(I, {(color(obj), (i, leftmost_col)) for i in range(uppermost(obj), lowermost(obj) + 1)}) # Paint leftmost column
  return I

32.075104def jfaefbbehgdgecbdjecdhdeecaecgafd(I):
  new_grid = canvas(mostcolor(I), shape(I)) # Create empty grid
  for j in range(width(I)):
    column_obj = {(I[i][j], (i, j)) for i in range(height(I)) if I[i][j] != mostcolor(I)}
    if column_obj: 
      leftmost_col = leftmost(column_obj) 
      new_grid = paint(new_grid, {(color(column_obj), (i, leftmost_col)) for i in range(uppermost(column_obj), lowermost(column_obj) + 1)})
  return new_grid

12.550802def djffgcjcjeibehadbbidbhjdacbeacdc(I):
  return rot270(hmirror(rot90(
    apply(lambda col: tuple(col[0] if any(c != mostcolor(I) for c in col) else mostcolor(I) for _ in col), rot90(I))
  )))

38.89236def ediaegfcddcceceabadhefbeffjhgeac(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in partition(I):
    rightmost_col = rightmost(obj)
    line = frozenset({(color(obj), (i, rightmost_col)) for i in range(uppermost(obj), lowermost(obj) + 1)})
    O = paint(O, line)
  return O

48.594646def fafjdagacafheihebbefifhibibbagdf(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I):
    indices = ofcolor(I, v)
    if indices:
      max_j = max(j for _, j in indices)
      line = frozenset({(v, (i, max_j)) for i in range(height(I)) if (i, max_j) in indices})
      O = paint(O, line)
  return O

13.31551def iagiafdaeeabejebafbaaadfjfdidccj(I):
  O = I
  for obj in fgpartition(I):
    for i in range(uppermost(obj), lowermost(obj) + 1):
      O = fill(O, color(obj), {(i, rightmost(obj))})
  return O

59.56225def efchbgbaigbceedgachcbgaeeidbibce(I):
  """
  Iterates through each cell, preserving only those in the leftmost column of their respective objects. 
  """
  O = canvas(mostcolor(I), shape(I))  # Create an empty canvas
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I) and j == leftmost(toindices(toobject(asindices(crop(I, (i,0), (1, j+1))), I))): 
        # Check if it's the leftmost cell of an object
        O = fill(O, val, {(i, j)})
  return O

38.39016def eceadchcecfbefadidbabghjfaiefied(I):
  """
  Identifies objects and directly paints their leftmost columns onto a blank canvas.
  """
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for obj in objects(I, False, False, True):
    left_column = min(toindices(obj), key=lambda x: x[1])[1] # Find the leftmost column
    leftmost_cells = {(v, (i, left_column)) for v, (i, j) in obj if j == left_column} # Extract leftmost cells
    O = paint(O, leftmost_cells) # Paint the cells on the canvas
  return O

16.866549def jadcddhjffffeeaebbfbfhbeadddaicf(I):
  """
  Utilizes a column-wise approach, preserving only the topmost occurrence of each distinct color.
  """
  O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for j in range(width(I)): # Iterate through columns
    seen_colors = set() # Track seen colors in the column
    for i in range(height(I)): # Iterate through rows within the column
      if I[i][j] != mostcolor(I) and I[i][j] not in seen_colors:
        O = fill(O, I[i][j], {(i,j)}) # Preserve the topmost occurrence
        seen_colors.add(I[i][j]) # Mark the color as seen
  return O

111.999405def bfeicjbbifbbediiifhdaidgafajfcib(I):
  """
  Employs a recursive approach to identify and preserve leftmost columns.
  """
  def helper(grid, col_index):
    if col_index == width(grid):
      return canvas(mostcolor(grid), shape(grid))
    column = tuple(row[col_index] for row in grid)
    if any(c != mostcolor(grid) for c in column):
      return hconcat((tuple(column), ), helper(grid, col_index + 1))
    else:
      return hconcat((tuple(mostcolor(grid) for _ in range(height(grid))), ), helper(grid, col_index + 1))
  return helper(I, 0)

14.651808def fecdbaccjjafeecejcbchdeijhejeahj(I):
  O = I  # Modify the input grid directly
  for obj in fgpartition(I): # Iterate through each object
    leftmost_j = leftmost(obj) # Find the leftmost column index of the object
    shift_amount = (-leftmost_j, 0) # Calculate shift amount to align to the left edge
    O = paint(cover(O, obj), shift(obj, shift_amount)) # Erase the object and paint it back shifted
  return O

32.77691def jbgihgijicfeejcajcaeacdhhdceeeah(I):
  O = I
  for obj in fgpartition(I):
    target_column = min(toindices(obj), key=lambda x: x[1])[1]  # Find the leftmost column index of the object
    for i in range(height(I)):
      if index(I, (i, target_column)) == color(obj):
        O = underfill(O, color(obj), connect((i, target_column), (i, width(I)))) # Fill rightwards from the leftmost occurrence of the color
  return O

11.927976def jajiegabddfbedgabdigaaacfddcadhj(I):
  objs = objects(I, True, False, True)  
  O = I  
  for obj in objs:
    for j in range(rightmost(obj), leftmost(obj), -1): 
      obj_temp = shift(obj, (1, 0))
      O = paint(O, {(color(obj), (i+1, j-1)) for v, (i, k) in obj_temp if k == j})
      obj = {(v, (i, k)) for v, (i, k) in obj if k != j}
  return O

54.107def dcjefhgecjccefifbbaahhacdhhbgjde(I):
  O = canvas(mostcolor(I), shape(I)) 
  for j in range(width(I)):
    column = {(v, (i, j)) for v, (i, k) in asobject(I) if k == j} 
    shifted_column = shift(column, (1, -j)) 
    O = paint(O, shifted_column)  
  return O

12.154239def bcffadcacdafedfcihfeafbejdefjafa(I):
    O = I
    for i in range(height(I) - 1):
        for j in range(width(I)):
            if index(I, (i, j)) != mostcolor(I):
                if index(I, (i + 1, j)) == mostcolor(I):
                    O = paint(O, {(index(I, (i, j)), (i + 1, j))})
                    O = paint(O, {(mostcolor(I), (i, j))}) 
    return O

52.396503def jfafcedabbjfeabajcdfeacdccefabei(I):
    objs = objects(I, True, False, True)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        w = width(obj)
        for i in range(height(obj)):
            row = {(color(obj), (i, j)) for j in range(w)} 
            shifted_row = shift(row, (i + 1, -w + 1)) 
            O = paint(O, shifted_row) 
    return O

10.251121def jcacbacaccadehgebfabbdeddebbdbge(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    for i in range(height(obj)):
      rightmost_cell = {(v, (i, j)) for v, (i, j) in obj if j == rightmost(obj)} 
      O = paint(cover(O, rightmost_cell), shift(rightmost_cell, (1, -width(obj) + 1))) 
  return O

60.697186def cibcdheafdddeeeeieafaacfcdfeacee(I):
  O = []  # Initialize empty output grid
  for j in range(width(I)):  # Iterate over columns
    col = tuple(I[i][j] for i in range(height(I))) # Extract current column
    if any(c != mostcolor(I) for c in col):  # Check if column contains non-background colors
      O.append(tuple(mostcommon(col) for _ in range(height(I)))) # Fill output column with most common color in the input column
    else:
      O.append(tuple(mostcolor(I) for _ in range(height(I)))) # Fill with background color
  return rot270(tuple(O)) # Rotate to correct orientation

16.417183def eeciffgddcdhegabacehcbeeacjfcbic(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    j = leftmost(obj)  # Column index for collapsing
    O = fill(O, color(obj), {(i, j) for i in range(height(I))})
  return O

18.546747def jgddbdcfbgdcedefbeedcbffjjajcead(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    for i in range(height(I)):
      if I[i][j] != mostcolor(I):
        O = fill(O, I[i][j], {(k, j) for k in range(height(I))})
        break # Move to the next column once a non-background color is found
  return O

23.799505def eabecdgedfddegdbijagadcdgabjbced(I):
  O = canvas(mostcommon(I), shape(I))
  for j in range(width(I)): # Iterate through columns
    for i in range(height(I)): # Iterate through rows
      v = index(I, (i, j))
      if v != mostcommon(I): # Found a non-background color
        O = paint(O, recolor(v, {(k, j) for k in range(height(I))}))
        break # Move to next column
  return O

42.275154def bbcdccbedcifecegjbbeaaabehhbffdf(I):
  O = canvas(mostcommon(I), shape(I))
  for j in range(width(I)): # Iterate through columns
    column_colors = {index(I, (i, j)) for i in range(height(I))} - {mostcommon(I)} # Get unique colors in column
    if column_colors: # If there are non-background colors
      v = first(column_colors) # Take the first non-background color encountered
      O = paint(O, recolor(v, {(i, j) for i in range(height(I))}))
  return O

37.00382def edbfdejbfjidecegaabchbahdfhbbbhf(I):
    O = canvas(mostcommon(I), shape(I)) # Create a blank canvas
    for v in palette(I): # Iterate over each color
        for i, row in enumerate(I): # Iterate over rows
            j = width(I) - 1
            while j >= 0:
                if row[j] == v:
                    O = paint(O, {(v, (i, k)) for k in range(j + 1)})  # Paint from the rightmost cell
                    break # Move to the next row
                j -= 1
    return O

10.941557def eebghccjgggaeafibeefdajaebbcficg(I):
  return tuple(tuple(mostcolor(I) if any(v == k and j == rightmost(obj) for obj in fgpartition(I) for k, (_, _) in obj) else v 
                   for j, v in enumerate(row))
               for row in I)

32.995937def acfgbhdfjjdbeficiehhjfhddjcbfefa(I):
  objs = fgpartition(I)
  new_objs = frozenset(frozenset((color(obj), (i, rightmost(obj))) 
                         for i in range(uppermost(obj), lowermost(obj) + 1)) 
                         for obj in objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(new_objs))

23.304148def baeeaadcchecedhdbaedfbfbfibccegd(I):
  return tuple(tuple(next((color(obj) for obj in fgpartition(I) if (i, rightmost(obj)) == (i, j)), mostcolor(I))
                   for j, v in enumerate(row))
               for i, row in enumerate(I)) 

9.064666def dgfdaajdbhddededadbcbacbefaeciaf(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if portrait(obj):
      direction = DOWN
      start = (uppermost(obj), leftmost(obj))
    elif width(obj) > height(obj):
      direction = RIGHT
      start = (uppermost(obj), leftmost(obj))
    else:
      direction = (0, 0)
      start = ulcorner(obj)
    line = connect(start, add(start, multiply(shape(obj), direction)))
    O = paint(O, recolor(color(obj), line))
  return O

14.569735def aaijcbdcheeceafhadacfefdfcijbhjh(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = cover(O, obj)
    if portrait(obj):
      start = (uppermost(obj), leftmost(obj))
      line = frozenset((start[0] + i, start[1]) for i in range(height(obj)))
    elif width(obj) > height(obj):
      start = (uppermost(obj), leftmost(obj))
      line = frozenset((start[0], start[1] + j) for j in range(width(obj)))
    else:
      line = toindices(obj)
    O = paint(O, recolor(color(obj), line))
  return O

32.996113def febicecbddcgegcbaabgggifefeaccaa(I):
  O = canvas(mostcolor(I), shape(I))
  for v in palette(I) - {mostcolor(I)}:
    obj = extract(objects(I, T, F, T), matcher(color, v))
    if portrait(obj):
      line = connect(ulcorner(obj), llcorner(obj))
    elif width(obj) > height(obj):
      line = connect(ulcorner(obj), urcorner(obj))
    else:
      line = toindices(obj)
    O = paint(O, recolor(v, line))
  return O

16.53885def fahfejjecjdceebfbjadfgffgbfdbijc(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output grid with background color
  for c in palette(I) - {mostcolor(I)}: # Iterate over colors in the input, excluding background
    j = min(ofcolor(I, c), key=lambda x: x[1])[1] # Find column index of the leftmost occurrence
    O = fill(O, c, {(i, j) for i in range(height(I))}) # Fill the entire column with the color
  return O 

17.529696def acedfcbbighfeejdbgdiccfbdibjhdcc(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for i, row in enumerate(I): # Iterate through rows
    for j, c in enumerate(row): # Iterate through elements in each row
      if c != mostcolor(I): # If not background color
        O = fill(O, c, {(k, j) for k in range(height(I))}) # Draw vertical line
        break # Move to the next row
  return O

11.25866def gdideahdgjeieaedjceigdacigeafceb(I):
  used_colors = set() # Keep track of colors already processed
  O = canvas(mostcolor(I), shape(I)) # Initialize output grid with background color
  for i, row in enumerate(I): # Iterate through rows
    for j, c in enumerate(row): # Iterate through elements in each row
      if c != mostcolor(I) and c not in used_colors: # If not background color and not processed yet
        O = fill(O, c, {(k, j) for k in range(height(I))}) # Draw vertical line
        used_colors.add(c) # Mark the color as processed
  return O

9.29365def ccadhfhggajeecdcaddfeffgigdagfjc(I):
  O = I  # Start with a copy of the input
  for v in palette(I) - {mostcommon(I)}: # For each color (excluding background)
    target_col = min(j for i, j in ofcolor(I, v)) # Find the target column
    for i, row in enumerate(I):
      for j, val in enumerate(row):
        if val == v: # If the cell has the current color
          O = paint(O, {(v, (i, target_col))}) # Paint it at the target column on same row
  return O 

34.20315def cfdffiffadiiedcabefaiffcgcebbcae(I):
  objs = objects(I, T, F, T) # Extract objects from the input grid, excluding background
  O = canvas(mostcolor(I), shape(I)) # Create a canvas filled with the background color
  for obj in objs:
    start = (uppermost(obj), leftmost(obj)) # Find the starting point (uppermost, leftmost)
    height_obj = height(obj) # Calculate the height of the object
    line = [(start[0] + i, start[1]) for i in range(height_obj)] # Generate indices for the vertical line
    O = paint(O, recolor(color(obj), frozenset(line)))  # Paint the line with the object's color
  return O

49.67247def dciichbaefjeeddbbiddefacdefegcie(grid):
  for color in palette(grid):
    for i, j in ofcolor(grid, color):
      if i > uppermost(ofcolor(grid, color)) or j > leftmost(ofcolor(grid, color)):
        grid = fill(grid, mostcolor(grid), {(i, j)})
  return grid

7.727117def aajgfcbacgfhegcbaifggjceccdfeiad(grid):
  for obj in objects(grid, univalued=False, diagonal=True, without_bg=False):
    topleft_color = next(iter(obj))[0]
    grid = paint(grid, recolor(topleft_color, {(uppermost(obj), leftmost(obj))}))
  return grid

7.786455def eegbdhhhbaajeefcjcaehcfdfibefeda(grid):
  for color in palette(grid):
    for i, j in ofcolor(grid, color):
      if i == uppermost(ofcolor(grid, color)) and j == leftmost(ofcolor(grid, color)):
        grid = paint(grid, asobject(crop(grid, (i,j), (1,1))))
  return grid

7.710466def jaacfhcgfeeeefdjiibbegfgbedbgdgc(I):
  O = I[:]  # Copy input
  for i in range(height(I)):
    for j in range(width(I) - 1):
      if O[i][j] != mostcommon(I) and O[i][j+1] == mostcommon(I):
        O = fill(O, mostcommon(I), {(i, k) for k in range(j + 1)})  # Clear leftward from gaps
  return O

9.54106def gdcfahaabgaeeffdjhffachfdcbjafbb(I):
  new_grid = canvas(mostcolor(I), shape(I)) # Create a canvas filled with background color.
  for obj in fgpartition(I):
    shifted_obj = shift(obj, (0, 1)) # Shift object one column right
    new_grid = paint(new_grid, shifted_obj) # Paint the shifted object onto the new grid.
  return new_grid

15.509565def gcgddbehijbaefiabcaahjggdihgcbbi(I):
  return tuple(tuple(v if j != rightmost(obj)-1  else mostcolor(I)
                 for j, v in enumerate(row))
               for obj in fgpartition(I)
               for i, row in enumerate(I) if any((i, k) in toindices(obj) for k in range(width(I))))

9.310957def ecchfcifhcjceidejjdbfadabhbadbid(I):
  objs = fgpartition(I)
  new_objs = frozenset(frozenset((color(obj), (i, min(j+1, width(I)-1))) for c, (i, j) in obj) for obj in objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(new_objs))

9.019485def defgfcjadbbiehcjjdciaagdcicbagbi(I):
  O = canvas(mostcolor(I), shape(I))  # Initialize output canvas
  for obj in objects(I, T, F, T):  # Iterate over each object
    start = ulcorner(obj)  # Get top-left corner
    if width(obj) > height(obj):
      direction = RIGHT  # Extend right if wider
    else:
      direction = DOWN  # Extend down otherwise
    line = connect(start, add(start, multiply(shape(obj), direction)))  # Create line indices
    O = paint(O, recolor(color(obj), line))  # Paint the line
  return O 

8.826354def cefiaffgeadjecfaiecjbaeaibecbdhc(I):
  O = paint(canvas(mostcolor(I), shape(I)), merge({recolor(color(obj), connect(ulcorner(obj), add(ulcorner(obj), multiply(shape(obj), RIGHT if width(obj) > height(obj) else DOWN)))) for obj in objects(I, T, F, T)}))
  return O

17.004065def geieaiabfabdefababfbgbaededjccfb(I):
  objs = objects(I, T, F, T)
  lines = frozenset({recolor(color(obj), connect(ulcorner(obj), add(ulcorner(obj), (width(obj)-1, 0) if width(obj) > height(obj) else (0, height(obj)-1)))) for obj in objs})
  return paint(canvas(mostcolor(I), shape(I)), merge(lines))

7.710466def haidfbhejegfedbabjdaddbeccgdjeej(I):
  lines = mfilter(objects(I, T, F, T), lambda obj: recolor(color(obj), connect(ulcorner(obj), astuple(ulcorner(obj)[0] + width(obj) - 1 if width(obj) > height(obj) else ulcorner(obj)[0], ulcorner(obj)[1] + height(obj) - 1 if height(obj) >= width(obj) else ulcorner(obj)[1]))))
  return paint(canvas(mostcolor(I), shape(I)), lines)

47.19543def heihejibcccaejaiaegehjebejgdbcaa(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objects(grid, univalued=False, diagonal=True, without_bg=False):
    leftmost_col = leftmost(obj)
    shifted_obj = frozenset((v, (i, leftmost_col)) for v, (i, _) in obj)
    new_grid = paint(new_grid, shifted_obj)
  return new_grid

47.96321def ebddjfibhcfaeebcieideibddafjdbbf(grid):
  transformed_objects = set()
  for obj in objects(grid, univalued=False, diagonal=True, without_bg=False):
    min_j = min(j for _, (i, j) in obj)
    transformed_objects.add(frozenset((val, (i, min_j)) for val, (i, _) in obj))
  return paint(canvas(mostcolor(grid), shape(grid)), merge(transformed_objects))

38.48469def jacbfbchiicdeccbjgfdibedcchhhice(I):
  new_grid = canvas(mostcolor(I), shape(I)) # Create a new grid filled with the background color
  for obj in fgpartition(I):
    rightmost_col = rightmost(obj)
    new_grid = paint(new_grid, {(color(obj), (i, rightmost_col)) for i, j in toindices(obj)})
  return new_grid

15.306437def ecaeddhadcbceeacadijidgehjbidcfe(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    shift_amount = width(obj) - 1
    O = paint(O, shift(obj, (0, shift_amount)))
  return O

9.79385def aefcfibejciieijjjdecbdabfcabgeje(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    period = hperiod(obj)
    shift_amount = period - 1 if period > 1 else 0
    O = paint(O, shift(obj, (0, shift_amount)))
  return O

42.69085def bhaibbjcdfabeacbbbeecagjaaehdaed(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    row_objs = objects(crop(I, (i, 0), (1, w)), T, F, T)
    for obj in row_objs:
      shift_amount = width(obj) - 1
      O = paint(O, shift(obj, (0, shift_amount)))
  return O

34.614857def adecjjdcdigcejhaibgafjbcjhffiaag(I):
  O = I  # Initialize output as input
  bg = mostcolor(I)  # Identify background color
  for c in palette(I) - {bg}:  # Iterate through unique colors (excluding background)
    cells = ofcolor(I, c)  # Get all cell indices of the current color
    diag = set()  # Store indices of the primary diagonal
    for i in range(len(I)):
      for j in range(len(I[0])):
        if (i, j) in cells:
          diag.add((i, j))
          break  # Move to the next row once a cell of the color is found
    O = fill(O, bg, cells - diag) # Fill non-diagonal cells with background color
  return O 

27.039415def dhcdcdeabdggecddaajdjdhbegaacbgc(I):
  O = canvas(mostcolor(I), shape(I)) # Canvas of background color
  for c in palette(I) - {mostcolor(I)}: # Loop through colors
    indices = sorted(ofcolor(I, c)) # Get sorted indices of the color
    if len(indices) > 1:
      d = subtract(indices[-1], indices[0])
      if d[0] == d[1]: # Check if on main diagonal
        O = paint(O, {(c, i) for i in indices}) # Paint the entire diagonal
      else:
        O = paint(O, {(c, indices[0])}) # Paint only the first cell
    else:
      O = paint(O, {(c, indices[0])}) # Paint single cell objects
  return O

42.20137def hafgjdccdaeiehhjjjabaabdeccdabah(I):
  O = I
  bg = mostcolor(I)
  for c in palette(I) - {bg}:
    cells = ofcolor(I, c)
    if len(cells) > 1:
      start = min(cells, key=lambda x: x[0] + x[1]) # Find top-leftmost cell
      O = fill(O, bg, cells - shoot(start, (1, 1))) # Keep only the diagonal from the start
  return O

14.032225def cicdhdhijddcejefaieijghhcacdbccf(I):
  O = canvas(mostcolor(I), shape(I))
  for c in palette(I) - {mostcolor(I)}:
    diag = set()
    for i, j in ofcolor(I, c):
      if not any((i, k) in diag for k in range(j)): # Check for previous diagonal cell in the same row
        diag.add((i, j))
    O = paint(O, recolor(c, diag))
  return O

26.772926def bdadejcdccfhejfijceihdechabdafbc(I):
  O = I
  bg = mostcolor(I)
  for c in palette(I) - {bg}:
    diag = set()
    last_j = -1  # Track the column of the last diagonal cell
    for i, j in sorted(ofcolor(I, c)):
      if j > last_j:  # If the current cell is in a column greater than the last diagonal cell's column
        diag.add((i, j))
        last_j = j
    O = fill(O, bg, ofcolor(I, c) - diag)
  return O

7.710466def fdgaehjefbdaehcgaaeidfeahffcjcjb(I):
  O = canvas(mostcommon(I), shape(I)) # Create a blank canvas
  for i, row in enumerate(I): # Iterate over each row
    j = 0 # Start from the first column
    for v in row: # Iterate over each value in the row
      if v != mostcommon(I): # If it's not the background color
        O = paint(O, {(v, (i, j))}) # Paint the color at the current position
        j += 1 # Move to the next column for the next non-background color
  return O

36.839474def adeifdfjbjeeejeiiahcdgicbjddfaah(I):
    objs = objects(I, T, F, T)  # Identify all objects
    O = I 
    for obj in objs:
        leftmost_j = leftmost(obj)
        for i in range(uppermost(obj), lowermost(obj) + 1):
            O = fill(O, mostcolor(I), {(i, j) for j in range(leftmost_j + 1, width(I))})  # Clear everything to the right of the leftmost cell in each row
            O = fill(O, first(palette(obj)), {(i, leftmost_j)})  # Fill the leftmost cell
    return O

34.20315def efibagjdfegbedbcbbcgbebacagahcif(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    upper, left = ulcorner(obj)
    for i in range(height(obj)):
      O = fill(O, first(palette(obj)), {(upper + i, left)})
  return O

34.327515def ddfdceihedheedbdiceffbcbjccfdgff(I):
  for i in range(height(I)):
    for j in range(width(I)-1, 0, -1): # Iterate columns right to left
      if I[i][j] == I[i][j-1]: # If current cell same as the one to its left
        I = fill(I, mostcolor(I), {(i, j)}) # Replace current cell with background
  return I

34.614857def aecgbdfaccabedjbabifebcafeifbggf(I):
  return tuple(tuple(v if j == min(k for k in range(width(I)) if I[i][k] == v) else mostcolor(I) for j, v in enumerate(row)) for i, row in enumerate(I))

17.330063def dcdcdchfdbaieebaabfcciecdiggbddg(I):
  objs = objects(I, True, False, True)
  moved = set()
  for obj in objs:
    if obj in moved:
      continue
    closest_obj = None
    closest_dist = float('inf')
    for other_obj in objs:
      if color(obj) != color(other_obj):
        dist = manhattan(obj, other_obj)
        if dist < closest_dist:
          closest_dist = dist
          closest_obj = other_obj
    if closest_obj is not None:
      # Determine the direction to gravitate
      delta = gravitate(obj, closest_obj)
      obj = shift(obj, delta)
      moved.add(obj)
      I = paint(cover(I, obj), obj)
  return I

15.505347def djcbjbbcbiebegffbaffbhgaddajabjd(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in fgpartition(I): # Iterate over objects without background
    top_left = ulcorner(obj)
    O = paint(O, {(color(obj), top_left)}) # Paint top-left corner
    if width(obj) > 1:
      O = fill(O, color(obj), {(top_left[0], j) for j in range(top_left[1], top_left[1] + width(obj))}) # Fill horizontally
    if height(obj) > 1 and top_left[1] == leftmost(obj): # Only for topmost part of vertically stacked objects
      O = fill(O, color(obj), {(i, top_left[1]) for i in range(top_left[0], top_left[0] + height(obj))}) # Fill vertically
  return O

15.648468def cceacifdaddheebeafifibcihabjcfie(grid):
  for obj in objects(grid, univalued=False, diagonal=False, without_bg=True):
    rightmost_cell = argmax(obj, lambda cell: cell[1][1])
    leftmost_column = leftmost(obj)
    new_obj = {(v, (i, leftmost_column)) if (v, (i, j)) == rightmost_cell else (v, (i, j)) for v, (i, j) in obj}
    grid = paint(cover(grid, obj), new_obj)
  return grid

20.52512def dfaabbfgdiadefcdaaegcibgeddfbbdd(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objects(grid, univalued=False, diagonal=False, without_bg=True):
    for i in range(height(obj)):
      row_cells = {(v, (a, b)) for v, (a, b) in obj if a == uppermost(obj) + i}
      rightmost_cell = argmax(row_cells, lambda cell: cell[1][1])
      new_obj = {(v, (i + uppermost(obj), leftmost(obj))) if (v, (a, b)) == rightmost_cell else (v, (a, b)) for v, (a, b) in row_cells}
      new_grid = paint(new_grid, new_obj)
  return new_grid

25.825485def gejdccaidicfecibbbaafccbcfhjdibe(grid):
  for j in range(width(grid)-1, 0, -1):
    for i in range(height(grid)):
      if (i, j) in asindices(grid) and index(grid, (i, j)) != mostcolor(grid) and index(grid, (i, j-1)) == mostcolor(grid):
        obj = extract(objects(grid, univalued=False, diagonal=False, without_bg=True), lambda x: (i, j) in toindices(x))
        grid = move(grid, obj, (0, -1))
  return grid

7.164059def efdhiaebdaacebfajagdeffibjajficf(grid):
  processed_grid = canvas(mostcolor(grid), shape(grid))
  for i in range(height(grid)):
    for j in range(width(grid)):
      if index(grid, (i, j)) != mostcolor(grid):
        obj = extract(objects(grid, univalued=False, diagonal=False, without_bg=True), lambda x: (i, j) in toindices(x))
        leftmost_col = leftmost(obj)
        processed_grid = paint(processed_grid, {(v, (i, leftmost_col)) if (a, b) == (i, j) else (v, (a, b)) for v, (a, b) in obj})
  return processed_grid

7.710466def iabeabhccefgebcbiaeabiecafebgcde(grid):
  for obj in objects(grid, univalued=False, diagonal=False, without_bg=True):
    for i in range(height(obj)):
      row = uppermost(obj) + i
      obj_row = {(v, (a, b)) for v, (a, b) in obj if a == row}
      k = width(obj_row)
      for j in range(width(obj_row)):
        c = index(grid, (row, leftmost(obj) + j))
        grid = fill(grid, c, {(row, leftmost(obj) + (j - k) % width(obj_row))})
  return grid

44.699493def dgiebaibfdbdebcjjaecjdjdhcfdeffe(I):
  O = canvas(mostcolor(I), shape(I))
  for i, column in enumerate(hsplit(I, width(I))):
    obj = toobject(asindices(column), column)
    leftmost_col = objects(column, T, F, F)
    if leftmost_col:
      O = paint(O, shift(recolor(color(first(leftmost_col)), toindices(first(leftmost_col))), (0, i)))
  return O

49.51816def agiffebgdabeefbcafccheggeafcafaf(I):
  O = I
  for c in palette(I):
    indices = ofcolor(I, c)
    for i, j in indices:
      if (i, j) != first(order(indices, lambda x: x[1])):
        O = fill(O, mostcolor(I), {(i, j)})
  return O

59.3855def iedjcfdbeaededajjjbebedgagbajiid(I):
  def isolate_leftmost(grid):
    if width(grid) == 1:
      return grid
    left, right = hsplit(grid, 2)
    return hconcat(isolate_leftmost(left), canvas(mostcolor(grid), shape(right)))
  return isolate_leftmost(I)

7.710466def caibdaebbcdbefcebhcggicbbbhbcdeg(I):
  for _ in range(max(height(I), width(I))): # Iterate enough times for potential movements
    for i in range(len(I)):
      for j in range(len(I[0])):
        if index(I, (i, j)) != mostcommon(I):
          # Find closest neighbor of a different color
          closest_neighbor = None
          closest_dist = float('inf')
          for ni, nj in dneighbors((i, j)):
            if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and index(I, (ni, nj)) != index(I, (i, j)):
              dist = abs(ni - i) + abs(nj - j)
              if dist < closest_dist:
                closest_dist = dist
                closest_neighbor = (ni, nj)
          if closest_neighbor is not None:
            # Move towards the neighbor if empty
            di, dj = sign((closest_neighbor[0] - i, closest_neighbor[1] - j))
            if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0]) and index(I, (i + di, j + dj)) == mostcommon(I):
              I = paint(cover(I, {(index(I, (i, j)), (i, j))}), {(index(I, (i, j)), (i + di, j + dj))})
  return I

48.65921def aeaaigifedfeebcbbahgejbeddcidcfb(I):
  O = canvas(mostcolor(I), shape(I))  # Initialize output grid with background color
  objs = fgpartition(I)  # Get objects without background
  for obj in objs:
    line_indices = set()
    for (v, (i, j)) in obj:
      for (m, n) in dneighbors((i, j)):  # Check direct neighbors for same color
        if (v, (m, n)) in obj:
          line_indices.update({(i, j), (m, n)})  # Add connected cells to line_indices
    if line_indices:
      line_center = centerofmass(frozenset(line_indices))
      O = fill(O, v, {line_center})  # Fill center of mass with the line's color
  return O

30.91322def didebhedebdheedcahaafiegbeaficid(I):
  O = canvas(mostcolor(I), shape(I)) 
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I): # For each non-background cell
        line = {(I[i][j], (i, j))}
        k = 1
        while (I[i][j], (i, j + k)) in asobject(I):  # Extend line horizontally
          line.add((I[i][j], (i, j + k)))
          k += 1
        if len(line) > 1:
          O = paint(O, { (I[i][j], centerofmass(line)) }) # Paint the center 
  return O

14.651808def icgcbahjacdcedbeiejbbiedhbfdcdah(grid):
  for obj in fgpartition(grid):
    leftmost_col = leftmost(obj)
    grid = move(grid, obj, (-leftmost_col, 0))
  return grid

41.45941def ecjeahbdbgeaedjabbaibjchahgifcag(grid):
  return tuple(
    tuple(
      next((v for v in row if v != mostcolor(grid)), mostcolor(grid)) 
      for _ in range(len(row))
    ) 
    for row in grid
  )

37.499565def iefibcafacidefafbabgbaabbffdhcbe(grid):
  h, w = shape(grid)
  return tuple(
      tuple(
          grid[i][j] if j == min((k for k in range(w) if grid[i][k] != mostcolor(grid)), default=j) 
          else mostcolor(grid) 
          for j in range(w)
      )
      for i in range(h)
  )

34.891968def dbccjfjcedageffbicaecceehdebchjd(I):
    O = canvas(mostcolor(I), shape(I))  # Initialize output grid with background color
    for obj in objects(I, T, F, F):      # Iterate over each object in the input grid
        left_edge = frozenset((v, (i, leftmost(obj))) for v, (i, j) in obj)  # Extract the leftmost column of the object
        O = paint(O, left_edge)          # Paint the leftmost column onto the output grid
    return O

7.7730484def aifbebdeeedjehefbdaiiciaafcbcdfc(I):
  O = I
  for j in range(1, width(I)):  # Iterate over columns, starting from the second
    column = crop(I, (0, j), (height(I), 1))  # Extract the current column
    if numcolors(column) > 1:  # Check if the column contains more than one color (part of an object)
      O = fill(O, mostcolor(I), asindices(column))  # Fill the column with the background color
  return O

35.427986def efaddajbcgbceabcjcfgfjcgaadcffce(I):
    O = I
    for obj in objects(I, T, F, F):
        if width(obj) > 1:  # Check if object spans multiple columns
            for j in range(leftmost(obj) + 1, rightmost(obj) + 1):
                O = fill(O, mostcolor(I), {(i, j) for i in range(height(I)) if (i, j) in toindices(obj)})
    return O

7.710466def cicahcageagjehefjdfbbeihbcfjbgbd(I):
  O = canvas(mostcolor(I), shape(I))  # Initialize output with background color
  for i in range(height(I)):  # Iterate over rows
    leftmost_color = None  # Keep track of the leftmost color encountered in the row
    for j in range(width(I)):  # Iterate over columns
      color = index(I, (i, j))  # Get the color at the current cell
      if color != mostcolor(I) and leftmost_color is None: # If a non-background color is encountered for the first time in the row
        leftmost_color = color  # Update the leftmost color
      if leftmost_color is not None:  # If a leftmost color has been found
        O = fill(O, leftmost_color, {(i, j)})  # Fill the cell with the leftmost color
        leftmost_color = None  # Reset leftmost color for the next object in the row
  return O

42.94559def fbcigaicchcgehjbbfjejeggfbdcjaci(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    leftmost_j = leftmost(obj)
    color_val = color(obj)
    for i, j in toindices(obj):
      if j == leftmost_j:
        O = fill(O, color_val, {(i, j)})
  return O

23.305897def ceaefgifchjjeebejjhiajdbbbbfdbed(I):
  O = I
  for j in range(width(I)):
    column = {(i, j) for i in range(height(I))}
    for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
      if intersection(toindices(obj), column):
        O = fill(O, mostcolor(I), column)
        O = paint(O, recolor(color(obj), {(i, j) for i, _ in toindices(obj)}))
        break
  return O

58.31692def aeaifbfeaebaeeedaebaaficfiaffbba(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      if j > 0 and I[i][j] != I[i][j - 1] and I[i][j] != mostcolor(I):
        O = fill(O, mostcolor(I), {(i, k) for k in range(j, width(I))})
  return O

22.704163def gedabhebdeaeebffjebieebcfbbaafac(grid):
  objs = objects(grid, univalued=False, diagonal=False, without_bg=True)
  for obj in objs:
    rightmost_col = rightmost(obj)
    shifted_obj = shift(obj, (0, -leftmost(obj) + rightmost_col - width(obj) + 1))
    grid = paint(cover(grid, obj), shifted_obj)
  return compress(grid)

10.593239def cgfbejcfbcjdeeadabjciefadaieecbe(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objects(grid, univalued=False, diagonal=False, without_bg=True):
    width_obj = width(obj)
    for (v, (i, j)) in obj:
        new_grid = paint(new_grid, {(v, (i, rightmost(obj)-width_obj+1))})
        width_obj -= 1
  return new_grid

10.328219def dfjefdbdfejiehdebjaaadffagafbeeb(grid):
  new_grid = canvas(mostcolor(grid), shape(grid))
  for x in palette(grid) - {mostcolor(grid)}:
    indices = ofcolor(grid, x)
    rightmost_col = max([j for i,j in indices])
    new_indices = {(i, rightmost_col - j + leftmost(indices)) for (i,j) in indices}
    new_grid = paint(new_grid, recolor(x, new_indices))
  return new_grid

21.90369def bbafaideddjfeaadiaacecgeefddfdee(grid):
  transformed_grid = []
  for row in grid:
    values = [v for v in row if v != mostcommon(row)]
    transformed_row = [mostcommon(row)] * (len(row) - len(values)) + values
    transformed_grid.append(tuple(transformed_row))
  return tuple(transformed_grid)

34.614857def dfdbefibcdbjecccbfjdcedaaaaaaffb(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    seen_colors = set()
    for j in range(width(I)):
      value = index(I, (i, j))
      if value not in seen_colors:
        O = paint(O, {(value, (i, j))})
        seen_colors.add(value)
  return O

34.327515def ahejdigehfeaefffjbedjdbcabibeccc(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)-1, 0, -1):
      if index(I, (i,j)) == index(I, (i, j-1)):
        O = fill(O, mostcolor(I), {(i, j)})
  return O

49.57604def cehfbecaeaajeaaibahhaaffeajdcaeg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in partition(I):
    leftmost_cell = argmin(obj, lambda cell: cell[1][1])
    O = paint(O, {leftmost_cell})
  return O

32.973217def hbgbhifcebfbefbcifihcfaefjbegfhf(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    row = tuple(index(I, (i, j)) for j in range(width(I)))
    unique_row = dedupe(row)
    for j, v in enumerate(unique_row):
      O = paint(O, {(v, (i, j))})
  return O

26.114824def hdacdjdaejcaejjejehahgdcaieaacbf(I):
  new_I = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for obj in fgpartition(I): # Iterate over each non-background object
    leftmost_j = leftmost(obj) # Find the leftmost column index of the object
    for i in range(height(I)): # Iterate over each row
      if (i, leftmost_j) in toindices(obj): # Check if the leftmost column of this row contains the object
        new_I = paint(new_I, {(color(obj), (i, leftmost_j))}) # Paint the leftmost cell
        for j in range(leftmost_j + 1, width(I)): # Extend horizontally to the right
          new_I = paint(new_I, {(color(obj), (i, j))}) # Paint the current cell
  return new_I

17.555824def gddbdbchgcggedceacfjdefbfidcaefb(I):
  new_I = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for obj in fgpartition(I): # Iterate over each non-background object
    min_j = leftmost(obj) # Find the leftmost column index of the object
    max_i = lowermost(obj) # Find the bottom row index of the object
    for i in range(uppermost(obj), max_i + 1): # Iterate over rows where the object is present
      new_I = paint(new_I, {(color(obj), (i, min_j))}) # Paint the leftmost cell for each row
      if i == max_i: # If it's the bottom row
        for j in range(min_j + 1, width(I)): # Extend horizontally from the leftmost cell
          new_I = paint(new_I, {(color(obj), (i, j))}) # Paint the current cell
  return new_I

20.071909def ajdjcifdchefedahjeiefgcjajhijceb(I):
  new_I = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, True):
    start = (uppermost(obj), leftmost(obj))
    end = (uppermost(obj), width(new_I)-1)
    line = connect(start, end)
    new_I = paint(new_I, recolor(color(obj), line)) 
  return new_I

41.934513def fibfdihaefefeacdigghbfjbdagdeadi(I):
  for color in palette(I) - {mostcommon(I)}:
    for j in range(width(I)):
      connected_cells = set()
      for i in range(height(I)):
        if I[i][j] == color:
          connected_cells.add((i, j))
      if len(connected_cells) > 0:
        target_row = uppermost(connected_cells)
        for i, _ in sorted(connected_cells):
          I = paint(cover(I, {(color, (i, j))}), {(color, (target_row, j))})
          target_row += 1
  return I

31.366634def bdafebeddcdeehgjibabafijecfbccch(I):
  for color in palette(I) - {mostcommon(I)}:
    for i in range(height(I)):
      connected_cells = set()
      for j in range(width(I)):
        if I[i][j] == color:
          connected_cells.add((i, j))
      if len(connected_cells) > 0:
        target_col = leftmost(connected_cells)
        for _, j in sorted(connected_cells):
          I = paint(cover(I, {(color, (i, j))}), {(color, (i, target_col))})
          target_col += 1
  return I

17.76116def fhbjcbidbdfgeedejfabgffbibgdcgij(I):
  for value in palette(I):  # Iterate through each color
    for k in range(2):  # Two passes: one for horizontal, one for vertical
      for i in range(height(I)):  # Iterate through rows
        indices = [(i, j) for j in range(width(I)) if I[i][j] == value]
        if len(indices) == 2:  # Only connect if two occurrences in the row/column
          I = fill(I, value, connect(*indices))
      I = rot90(I)  # Rotate for vertical check
  return I

8.42553def fagiffdbbhdbeehbjffajefdgbcfdeid(I):
  for obj in fgpartition(I):  # Iterate through objects
    for k in range(2):  # Two passes: horizontal and vertical
      if hline(obj) or vline(obj) and size(obj) == 2:  # Connect if two-cell line
        start, end = astuple(*toindices(obj))
        I = fill(I, color(obj), connect(start, end))
      I = rot90(I)
  return I

7.710466def jfcbjjdafecdeaeeiecaddcacfiffjfg(I):
  objs = fgpartition(I)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and color(obj1) == color(obj2):
        if (hline(obj1) and hline(obj2) and hmatching(obj1, obj2)) or \
           (vline(obj1) and vline(obj2) and vmatching(obj1, obj2)):
          I = fill(I, color(obj1), connect(center(obj1), center(obj2)))
  return I

27.17059def ahagaafcjagbecgfigaaffgdefefajee(grid):
  bg = mostcolor(grid)
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=True):
    grid = fill(grid, bg, toindices(obj))
    grid = paint(grid, shift(obj, (0, rightmost(obj) - width(obj) + 1)))
  return grid

33.73746def cdddaabgfbebeidiiedffjbbbdfbagfh(grid):
  bg = mostcolor(grid)
  new_grid = [[bg for _ in range(width(grid))] for _ in range(height(grid))]
  for i in range(height(grid)):
    for j in range(width(grid)):
      if grid[i][j] != bg:
        obj = toobject(extract(objects(grid, univalued=True, diagonal=False, without_bg=True), lambda x: (i, j) in toindices(x)), grid)
        new_grid[i][rightmost(obj)] = grid[i][j]
  return tuple(tuple(row) for row in new_grid)

42.254612def accgdfhebdaaedabijgebbcefjebdcgb(grid):
  bg = mostcolor(grid)
  for x in palette(grid) - {bg}:
    obj = toobject(ofcolor(grid, x), grid)
    right_edge = rightmost(obj)
    for i, row in enumerate(grid):
      for j, val in enumerate(row):
        if val == x:
          grid = fill(grid, bg, {(i, k) for k in range(j, j + width(obj))})
          grid = paint(grid, {(x, (i, j + right_edge - width(obj) + 1))})
  return grid

39.104103def befdafgdebceedifjacbbafbfcidaeii(grid):
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=True):
    w = width(obj)
    for i, j in toindices(obj):
      if grid[i][j] != mostcolor(grid):
        grid = paint(fill(grid, mostcolor(grid), {(i, k) for k in range(j, j + w)}), {(grid[i][j], (i, j + rightmost(obj) - w + 1))})
  return grid

11.600339def bbccdhggcceheeebabefcjedahgeabab(I):
  O = canvas(mostcolor(I), shape(I))
  center_j = width(I) // 2 
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    obj_center_j = centerofmass(obj)[1]
    shift_amount = (center_j - obj_center_j, 0)
    O = paint(O, shift(obj, shift_amount))
  return O

7.52716def gfabeadeejegeegabddcfbcibacfcedd(I):
  O = I
  center_j = width(I) // 2
  for j in range(width(I)):
    if j != center_j:
      column = crop(I, (0, j), (height(I), 1))
      if numcolors(column) > 1:
        direction = (1, 0) if j < center_j else (-1, 0)
        O = paint(cover(O, asindices(column)), shift(asobject(column), direction))
  return O

11.335151def cbeaceeebbbaebbcjfacbjbfjeefeeja(I):
  O = canvas(mostcolor(I), shape(I))
  center_j = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    obj_width = width(obj)
    target_j = center_j - obj_width // 2 if centerofmass(obj)[1] < center_j else center_j + obj_width // 2
    shift_amount = (0, target_j - leftmost(obj))
    O = paint(O, shift(obj, shift_amount))
  return O

21.15684def acghcghebchieffgiedhdgbfbedfjjdf(I):
  objs = objects(I, True, False, True) # Identify objects, excluding background
  for obj in objs:
    direction = (0, 1) if any(leftmost(obj) < leftmost(obj2) and hmatching(obj, obj2) for obj2 in objs - {obj}) else (1, 0) # Determine extension direction: right if another object is to the right and shares a row, otherwise down
    extension = shoot(ulcorner(obj), direction) # Create an extension line
    targets = difference(asindices(I), {c for v, c in obj}) # Identify potential target cells excluding the object itself
    I = fill(I, color(obj), intersection(extension, targets)) # Fill the extension line with the object's color
  return I

30.673458def jebjhccjeedfefaciacifgfaeejdafdi(I):
  for obj in fgpartition(I):
    min_j = leftmost(obj)
    for j in range(width(I)):
      if any(index(I, (i, j)) == color(obj) for i in range(height(I))):
        min_j = j
        break
    for i in range(height(I)):
      if index(I, (i, min_j)) == color(obj):
        for j in range(min_j + 1, width(I)):
          if index(I, (i, j)) != mostcolor(I) and index(I, (i, j)) != color(obj):
            break
          I = fill(I, color(obj), {(i, j)})
        break
    for i in range(height(I)):
      if index(I, (i, min_j)) == color(obj):
        for i in range(i + 1, height(I)):
          if index(I, (i, min_j)) != mostcolor(I) and index(I, (i, min_j)) != color(obj):
            break
          I = fill(I, color(obj), {(i, min_j)})
  return I

20.905533def cjdifgjfbecdebhebecijcdjabibjfeg(I):
  bg = mostcolor(I)
  for obj in objects(I, True, False, True):
    c = color(obj)
    ul = ulcorner(obj)
    for j in range(ul[1] + 1, width(I)):
      if index(I, (ul[0], j)) != bg:
        break
      I = fill(I, c, {(ul[0], j)})
    for i in range(ul[0] + 1, height(I)):
      if index(I, (i, ul[1])) != bg:
        break
      I = fill(I, c, {(i, ul[1])})
  return I

26.855787def bafgchifffbaejcdahgcadifddefccej(I):
  for obj in fgpartition(I):
    for i in range(height(I)):
      for j in range(width(I)):
        if index(I, (i, j)) == color(obj):
          if j > 0 and index(I, (i, j - 1)) == mostcolor(I):
            I = fill(I, color(obj), {(i, k) for k in range(j, width(I)) if index(I, (i, k)) == mostcolor(I)})
          break
      for j in range(width(I)):
        if index(I, (i, j)) == color(obj):
          if i > 0 and index(I, (i - 1, j)) == mostcolor(I):
            I = fill(I, color(obj), {(k, j) for k in range(i, height(I)) if index(I, (k, j)) == mostcolor(I)})
          break
  return I

34.20315def bgjcgdjiefjaehddjdaccffegiebiabj(I):
  for obj in objects(I, True, False, True):
    leftmost_col = leftmost(obj)
    new_obj = {(color(obj), (i, leftmost_col)) for i, j in toindices(obj)} 
    I = paint(cover(I, obj), new_obj)
  return I

34.327515def cjehfachebcjeiebiafdcjbcefifcfhe(I):
  O = I
  for i in range(len(I)):
    for j in range(1, len(I[0])):
      if index(I, (i, j)) == index(I, (i, j - 1)):
        O = fill(O, mostcolor(I), {(i, j)})
  return O

34.614857def giiiahibbbfaebdfjdagijejiaddgbga(I):
  O = I
  for obj in fgpartition(I):
    for (v, (i, j)) in obj:
      if j > leftmost(sfilter(obj, lambda x: x[1][0] == i)):
        O = fill(O, mostcolor(O), {(i, j)})
  return O

37.499565def cdedbeecidgdegbhjfbbidedbbecfbjd(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    leftmost_color = None
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I) and leftmost_color is None:
        leftmost_color = I[i][j]
        O = fill(O, leftmost_color, {(i, j)})
  return O

21.81384def cbaiafbeccajeacdbcbegjefcjaihefa(grid):
  new_grid = [] 
  for row in grid: 
    non_bg_digits = [v for v in row if v != mostcommon(row)] # Extract non-background digits
    padding = [mostcommon(row)] * (len(row) - len(non_bg_digits)) # Calculate padding
    new_row = non_bg_digits + padding # Combine digits and padding
    new_grid.append(tuple(new_row)) 
  return tuple(new_grid)

22.94056def afeifdgcfedfebafiiaegbfcjbdddhdd(I):
  O = canvas(mostcolor(I), shape(I))
  for y, row in enumerate(I):
    x = 0
    for v in row:
      if v != mostcolor(I):
        O = paint(O, {(v, (y, x))})
        x += 1
  return O

66.70596def gfdfcdagaiecebdfjdbdcdecbhebdhee(grid):
  return tuple(
    tuple(v for k,v in sorted((grid[i][j],j) for j in range(width(grid))) if v != mostcolor(grid)) + 
    tuple(mostcolor(grid) for _ in range(width(grid)-len([v for k,v in sorted((grid[i][j],j) for j in range(width(grid))) if v != mostcolor(grid)])))
    for i in range(height(grid))
  )

16.634125def ffcbdbafbfefeecdadeebadccdcgfgee(I):
  O = canvas(mostcolor(I), shape(I))
  center_j = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    for j in range(width(I)):
      for i in range(height(I)):
        if (j < center_j and index(I, (i, j)) == color(obj)) or (j > center_j and index(I, (i, width(I) - j + center_j - 1)) == color(obj)):
          O = fill(O, color(obj), {(i, j)})
  return O

10.942836def edhdjehjejheecjeiadbhfhahcbadeib(I):
  O = I
  center_j = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    left_part = {(v, (i, j)) for v, (i, j) in obj if j < center_j}
    right_part = {(v, (i, j)) for v, (i, j) in obj if j > center_j}
    if left_part and right_part:
      O = paint(cover(O, left_part), shift(left_part, (0, center_j - leftmost(left_part))))
      O = paint(cover(O, right_part), shift(right_part, (0, center_j - rightmost(right_part))))
  return O

26.138733def addgagcdababegjcjeibhedejbffhfda(I):
  O = I
  c = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    for (i, j) in toindices(obj):
      if j < c:
        O = fill(O, index(I, (i, j)), {(i, j + c - leftmost(obj))})
      elif j > c:
        O = fill(O, index(I, (i, j)), {(i, j - (rightmost(obj) - c + 1))})
  return O

37.305054def hdbdeagbigeeefgcafdecfafcdeddafc(I):
  O = canvas(mostcolor(I), shape(I))
  center_j = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    for i in range(height(I)):
      left_j = None
      right_j = None
      for j in range(width(I)):
        if index(I, (i, j)) == color(obj):
          if j < center_j and (left_j is None or j < left_j):
            left_j = j
          if j > center_j and (right_j is None or j > right_j):
            right_j = j
      if left_j is not None:
        O = fill(O, color(obj), {(i, center_j - (center_j - left_j))})
      if right_j is not None:
        O = fill(O, color(obj), {(i, center_j + (right_j - center_j))})
  return O

29.011044def ffdjiajjdhcdehicjeffacaefbhddeai(I):
  O = I
  c = width(I) // 2
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
      for x in range(width(obj) // 2):
        O = paint(cover(O, {(v, (i, j)) for v, (i, j) in obj if j == leftmost(obj) + x}), shift({(v, (i, j)) for v, (i, j) in obj if j == leftmost(obj) + x}, (0, c - leftmost(obj) - x)))
        O = paint(cover(O, {(v, (i, j)) for v, (i, j) in obj if j == rightmost(obj) - x}), shift({(v, (i, j)) for v, (i, j) in obj if j == rightmost(obj) - x}, (0, c - rightmost(obj) + x)))
  return O

14.290926def agcibadcaiabeadaahcfbcgefbfaebdj(I):
  for obj in fgpartition(I):
    target_column = leftmost(obj)  # Determine the target column
    I = fill(I, mostcolor(I), obj)  # Remove the object from its current location
    I = paint(I, shift(obj, (0, -target_column)))  # Shift the object to the target column
  return I

60.697186def acbehceebeacehacjeaecbjccddhcdjb(I):
  for j in range(width(I)):
    column = {(i, j) for i in range(height(I)) if I[i][j] != mostcolor(I)}  # Extract the column
    if column:
      target_row = min(i for i, j in column)  # Find the target row
      I = fill(I, mostcolor(I), column)  # Clear the column
      I = paint(I, shift(toobject(column, I), (-target_row, 0)))  # Shift and paint the column content
  return I

7.710466def bdgddfgacdddebiabbcebbadfddacdac(I):
  for obj in fgpartition(I):
    target_loc = (uppermost(obj), leftmost(obj))  # Determine the target location
    offset = subtract(target_loc, ulcorner(obj))  # Calculate the shift offset
    I = move(I, obj, offset)  # Move the object using the calculated offset
  return I

7.945213def bdfbhhgagdecececafacccffdidfdebe(I):
  for obj in objects(I, True, False, False): # Iterate over all objects
    c = color(obj)
    leftmost_j = leftmost(obj) 
    for j in range(width(I)): # Iterate over columns
      if (0, j) in {(i, j) for i, j in toindices(obj)}: # Check if object present in the column
        I = paint(cover(I, {(c, (i, j)) for i in range(height(I)) if (c, (i, j)) in obj}), {(c, (0, leftmost_j))})
  return I

36.19184def cbdccfdgafdhefffadfhbcafdfefeebf(I):
  for obj in objects(I, True, False, False):
    min_j = leftmost(obj)
    I = paint(cover(I, obj), recolor(color(obj), {(i, min_j) for i in range(uppermost(obj), lowermost(obj) + 1)}))
  return I

51.8841def efjjcagcigjgebicahfgachajgacaaba(grid):
  processed_grid = canvas(mostcolor(grid), shape(grid)) # Create a blank canvas
  for obj in fgpartition(grid): # Iterate over each foreground object
    leftmost_index = argmin(toindices(obj), lambda x: x[1]) # Find the index of the leftmost cell
    processed_grid = paint(processed_grid, { # Paint the leftmost cell onto the canvas
        (color(obj), (leftmost_index[0], 0)) 
    })
  return processed_grid

43.453182def ccjdcgefedhgedgeiiiccbjfjbffffcd(grid):
  output_grid = canvas(mostcolor(grid), shape(grid)) # Blank canvas
  for i, row in enumerate(grid): # Iterate through rows
    for j, value in enumerate(row): # Iterate through columns
      if value != mostcolor(grid): # If not background color
        output_grid = paint(output_grid, {(value, (i, 0))}) # Paint to leftmost column
        break # Move to next row
  return output_grid

7.2681823def jdeabdiggibcecbfjebadeecacchghib(I):
  objs = objects(I, T, F, T)
  thinned_objs = frozenset(recolor(color(obj), {(i, leftmost(obj))}) for obj in objs for i in range(uppermost(obj), lowermost(obj) + 1))
  O = I
  for obj in thinned_objs:
    O = paint(O, obj)
  return O

36.15496def chfehedhbibaehdabcjgdeacfggbbbff(I):
  O = canvas(ZERO, shape(I))
  for i in range(height(I)):
    current_color = ZERO
    for j in range(width(I)):
      if index(I, (i, j)) != ZERO and current_color == ZERO:
        O = fill(O, index(I, (i, j)), {(i, j)})
        current_color = index(I, (i, j))
      else:
        current_color = index(I, (i, j))
  return O 

32.07579def cehchdcdgbahebbfaaecdbfjaaeebcff(I):
  for obj in fgpartition(I):
    for j in range(width(I)): # Iterate over columns
      column_cells = {(v, (i, k)) for v, (i, k) in obj if k == j} # Find cells in the current column
      if column_cells: # If there are cells in this column
        I = paint(cover(I, column_cells), shift(column_cells, (0, -j + leftmost(obj)))) # Shift the entire column to the leftmost position
  return I 

14.137159def ebajdhedcbaeeaebagiebffjhjfacdca(I):
  for obj in fgpartition(I):
    shift_amount = -leftmost(obj) # Calculate the total shift needed
    shifted_obj = shift(obj, (0, shift_amount)) # Shift the entire object at once
    I = underpaint(cover(I, obj), shifted_obj) # Cover the original and paint the shifted object
  return I

13.879222def ijebjgheafcgeeefjeffhjbcbbhjeeai(I):
  O = canvas(mostcolor(I), shape(I))  # Create output grid with background color
  for obj in fgpartition(I):  # Iterate over each foreground object
    leftmost_indices = set()  # Initialize a set to store leftmost indices
    for _, (i, j) in obj: # Iterate through each cell in the object
      if not any((i, k) in leftmost_indices for k in range(j)):  # Check if a leftmost index already exists in the same row
        leftmost_indices.add((i, j))  # If not, add the current index as leftmost
    O = paint(O, toobject(frozenset(leftmost_indices), I))  # Paint the leftmost cells onto the output grid
  return O

21.589317def bibgdibjecbieijejgdicabdfgcdjahh(grid):
  bg = mostcolor(grid)
  h, w = len(grid), len(grid[0])
  for j in range(w - 1, -1, -1):
    for i in range(h):
      if grid[i][j] != bg:
        for k in range(w - 1, j, -1):
          if grid[i][k] == bg:
            grid = fill(grid, grid[i][j], {(i, k)})
            grid = fill(grid, bg, {(i, j)})
            break
  return grid

7.8805456def biagjffhafbeefcdbbbbeihhibbfhbgc(grid):
  bg = mostcolor(grid)
  h, w = len(grid), len(grid[0])
  for obj in fgpartition(grid):
    j = w - 1
    for i in range(h):
      if (grid[i][0], (i, 0)) in obj:
        grid = fill(grid, grid[i][0], {(i, j)})
        grid = fill(grid, bg, {(i, 0)})
        j -= 1
  return grid

12.520563def fadjifagfjieeffiihfffbddbdaadefb(grid):
  bg = mostcolor(grid)
  transformed = tuple(tuple(v if j == len(row) - 1 else bg for j, v in enumerate(row)) for row in grid)
  for obj in fgpartition(grid):
    offset = (0, len(grid[0]) - 1 - rightmost(obj))
    transformed = paint(transformed, shift(obj, offset))
  return transformed

39.359615def geecbdgbacdfeddajfbdiedaahhgabaa(I):
  O = I # Initialize output as input
  for obj in objects(I, T, F, T): # Iterate over connected components
    for cell in obj: # Iterate over cells in each object
      if cell[1] != urcorner(obj): # If cell is not the rightmost cell 
        O = paint(O, {(mostcolor(I), cell[1])}) # Replace the cell with background color
  return O 

29.92445def gaaecddebcebeabijacjbgdedfbhjfdd(I):
  O = canvas(mostcolor(I), shape(I)) # Create blank canvas with background color
  for j in range(width(I)): # Iterate over columns from right to left
    for i in range(height(I)): # Iterate over rows 
      if I[i][j] != mostcolor(I): # If cell is not background color
        O = paint(O, {(I[i][j], (i,j))}) # Paint the cell onto the output grid
        break # Move to the next column
  return O

16.704277def chbfbfeabbcieefjbiedcgajafeibfjg(I):
  objs = fgpartition(I)
  for obj in objs:
    h, w = shape(obj)
    if h > w: 
      direction = (1, 0)
    elif w > h:
      direction = (0, 1)
    else: 
      direction = (1, 1)
    start = ulcorner(obj)
    extension = shoot(start, direction)
    I = underfill(I, color(obj), intersection(extension, backdrop(obj)))
  return I

50.27841def eeiicbfebejaeacajdeedadbbjggbddd(I):
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I):
        obj = {(I[i][j], (k, l)) for k, r in enumerate(I) for l, c in enumerate(r) if c == I[i][j]}
        I = paint(cover(I, obj), {(I[i][j], (i, j))})
  return I

40.992466def accajfadbhiaebacihhhdchcefejjhca(I):
  O = I
  for i in range(height(I)):
    row_obj = asobject(crop(I, (i, 0), (1, width(I))))  # Extract the current row as an object
    non_bg_indices = sfilter(toindices(row_obj), lambda x: index(I, x) != mostcolor(I))  # Get indices of non-background cells
    if non_bg_indices:  # If non-background cells exist
      leftmost_j = leftmost(non_bg_indices)  # Find the leftmost non-background cell
      O = fill(O, mostcolor(I), {(i, j) for j in range(leftmost_j + 1, width(I))}) # Fill everything to the right of it with background
  return O

38.48469def bidhciiijaffeddfiajahafaegdigbfa(grid):
  bg = mostcolor(grid)
  new_grid = canvas(bg, shape(grid))
  for obj in fgpartition(grid):
    rightmost_col = rightmost(obj)
    new_obj = {(v, (i, rightmost_col)) for v, (i, j) in obj}
    new_grid = paint(new_grid, new_obj)
  return new_grid

23.338768def bcjhcfecbcecebefafcabdgdhbdafhfc(grid):
  bg = mostcolor(grid)
  return tuple(
    tuple(v for v in r[::-1] if v != bg) + tuple(bg for _ in range(len(grid[0]) - len(tuple(v for v in r[::-1] if v != bg))))
    for r in grid
  )

39.540024def ccjgchgfjajceddcadcefcafjejcchdj(grid):
  bg = mostcolor(grid)
  return tuple(tuple(
    branch(j >= len(row) - row.count(v), v, bg) 
    for j, v in enumerate(row)
    ) for row in grid)

23.9153def dccibddedahhecebigfafdfgadhdeiba(I):
  O = cover(I, asindices(I))  # Start with a blank canvas
  for j in range(width(I)):  # Iterate over each column
    for i in range(height(I)):  # Iterate over each row in the column
      if I[i][j] != mostcolor(I):  # If cell is not background
        O = paint(O, frozenset({(I[i][j], (k, j)) for k in range(i, height(I))}))  # Draw a vertical line from this cell downwards
        break  # Move to the next column
  return O 

18.538338def caefbebgbdbcecbcbafhcdgefihdaebe(I):
  def rightmost_cell_in_column(j, obj):
    return any((i, j) in toindices(obj) for i in range(height(I)))
  
  objs = objects(I, T, F, T)
  O = cover(I, asindices(I))
  for j in range(width(I)):
    for obj in objs:
      if rightmost_cell_in_column(j, obj):
        color_ = color(obj)
        O = paint(O, frozenset({(color_, (i, j)) for i in range(height(I))}))
        break 
  return O

34.78582def ehachjihacdaefjhafgcggefgafhefdi(I):
  objs = objects(I, True, False, True)  # Extract all objects from the grid
  for obj in objs:
    ul = ulcorner(obj)  # Get upper-left corner of the object
    for i, j in toindices(obj):
      if i - ul[0] != j - ul[1]:  # Check if cell is not on the main diagonal
        I = fill(I, mostcolor(I), {(i, j)})  # Fill off-diagonal cells with background
  return I

51.519093def bgaeehgfdbddeffajaahchfbcheafdih(I):
  for i in range(height(I)):
    for j in range(width(I)):
      if i != j:  # Check if cell is not on the main diagonal
        I = fill(I, mostcolor(I), {(i, j)})  # Fill off-diagonal cells with background
  return I

55.46484def bcigbbehhfeieifdjaggdcceeedcfged(I):
  objs = partition(I)  # Partition the grid based on color
  for obj in objs:
    diag = connect(ulcorner(obj), lrcorner(obj))  # Get indices of the main diagonal
    I = paint(cover(I, obj), toobject(diag, I))  # Cover object and paint only the diagonal
  return I

31.721674def ghajjihhdcaaeafbbdfjbadgbfdjcaed(I):
  O = canvas(mostcolor(I), shape(I))  # Create empty canvas
  for obj in fgpartition(I):  # Loop through each object (no background)
    for i in range(uppermost(obj), lowermost(obj) + 1):  # Loop through rows
      leftmost_cell = min(obj, key=lambda x: x[1][1] if x[1][0] == i else float('inf')) # Find leftmost cell in row
      O = paint(O, {leftmost_cell})  # Paint leftmost cell
  return O 

30.74232def ihhabedebahdehebaiahjjchbiicffcg(I):
  lines = set()
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I):  # Ignore background
        lines.add(frozenset({(I[i][j], (k, j)) for k in range(height(I))}))  # Draw line from current point
  O = paint(cover(I, asindices(I)), merge(lines))
  return O

38.09331def ccddbccdffbbedebjdecabcfjbfdgfif(I):
  def create_line(obj):
    _, (i, j) = next(iter(obj))  # Get any cell's coordinates
    return frozenset({(I[i][j], (k, j)) for k in range(height(I))})
    
  objs = objects(I, T, F, T)  # Get all objects
  lines = apply(create_line, objs)  # Create lines for each object
  O = paint(cover(I, asindices(I)), merge(lines))  # Paint lines on blank canvas
  return O

29.704885def ceaehjeiaifbecfeibhddhdhdefedaad(I):
  def rightmost_cell(obj):
    return argmax(obj, lambda cell: cell[1][1])
  
  objs = objects(I, T, F, T)
  lines = set()
  for obj in objs:
    color, (i, j) = rightmost_cell(obj)
    lines.add(frozenset({(color, (k, j)) for k in range(height(I))}))
  O = paint(cover(I, asindices(I)), merge(lines))
  return O

49.518005def bfabcdagadfhegaaiagadbaideaebgdj(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    O = paint(O, {(color(obj), ulcorner(toindices(obj)))})
  return O 

58.220608def eeedcfbajfahedgcaajcehgiffeejcif(I):
  objs = fgpartition(I)
  return fill(I, mostcolor(I), 
              merge([difference(backdrop(obj), {ulcorner(obj)}) for obj in objs]))

52.482372def bdaddbccdgabedabjfijehdcddddeefc(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if any((i, j) == ulcorner(obj) for obj in fgpartition(I) if (i, j) in toindices(obj)):
        O = paint(O, {(v, (i, j))})
  return O

