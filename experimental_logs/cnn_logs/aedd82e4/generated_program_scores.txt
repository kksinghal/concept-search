0.09895833333333333, 2.5278034, def fafaaebfciacedijaejgabagbgbddaab(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, size) # Directly find the smallest object
  recolored_obj = recolor(ONE, smallest_obj) 
  O = paint(I, recolored_obj)
  return O
 
0.28541666666666665, 16.386593, def cgfdegagbafcefgajbbdebaeahhdfjdd(I):
  def find_and_recolor(grid, current_obj=None):
    objs = objects(grid, T, F, F)
    if len(objs) == 1: return grid # Base case: only one object left
    smallest_obj = argmin(objs, size)
    if current_obj and smallest_obj == current_obj: 
      return fill(grid, ONE, toindices(smallest_obj)) # Recolor if same smallest object persists
    else: 
      return find_and_recolor(cover(grid, smallest_obj), smallest_obj) # Recursively remove and try again
  return find_and_recolor(I) 
 
0.18229166666666666, 2.9995384, def dhfdacgdehdfehejbcdiiafbfefajeda(I):
  # Find all objects, excluding the background
  objs = objects(I, T, F, T) 
  # Find the smallest object based on size
  smallest_obj = argmin(objs, size)
  # Recolor the smallest object to 1
  recolored_obj = recolor(ONE, smallest_obj) 
  # Paint the recolored object onto the original grid
  O = paint(I, recolored_obj) 
  return O
 
0.46805555555555556, 5.367629, def cheibgabdfdheffhjbeeciahgfffbdif(I):
  # Partition the grid into objects based on color
  objs = partition(I) 
  # Filter out the background object, which is the most common color
  fg_objs = difference(objs, {asobject(replace(I, mostcommon(I), NEG_ONE))}) 
  # Find the object with the minimum size
  smallest_obj = argmin(fg_objs, size)
  # Recolor the smallest object to 1
  O = paint(I, recolor(ONE, smallest_obj)) 
  return O
 
0.17951388888888886, 3.8238091, def ddgibfgbeggaeadhicaccbbgjbacciah(I):
  objs = objects(I, T, T, T)
  lowest_obj = argmax(objs, lowermost)
  leftmost_cell = argmin(toindices(lowest_obj), lambda x: x[1])
  O = fill(I, 1, {leftmost_cell})
  return O
 
0.21076388888888886, 3.845906, def hddeehhbhbefefhaajijcgfiijcbfdha(I):
  h = height(I)
  for i in range(h-1, -1, -1):
    row_obj = objects(crop(I, (i, 0), (1, width(I))), T, T, T)
    if row_obj:
      leftmost_cell = argmin(toindices(first(row_obj)), lambda x: x[1])
      return fill(I, 1, {leftmost_cell})
  return I
 
0.17951388888888886, 3.5626283, def bcgeacdaidebeiedbfcjbfahcfafdifi(I):
    objs = objects(I, T, T, T)
    def is_lowest(obj):
        for other_obj in objs:
            if other_obj != obj and hmatching(obj, other_obj) and lowermost(other_obj) > lowermost(obj):
                return False
        return True
    lowest_obj = extract(objs, is_lowest)
    leftmost_index = argmin(toindices(lowest_obj), lambda x: x[1])
    return fill(I, 1, {leftmost_index})
 
0.15520833333333334, 3.6275852, def dahcfgadbedeefceiegdhibadbebaded(I):
    O = I
    for j in range(width(I)):
        for i in range(height(I)-1, -1, -1):
            if index(I, (i,j)) != mostcommon(I):
                O = fill(O, 1, {(i, j)})
                return O
    return O
 
0.21076388888888886, 4.1906276, def djgjcdagfibfeabaicbfcebafcecccee(I):
  def leftmost_non_bg(grid):
    for j in range(width(grid)):
      for i in range(height(grid)):
        if grid[i][j] != mostcommon(grid):
          return (i, j)
  cell = leftmost_non_bg(bottomhalf(I))
  if cell:
    return fill(I, 1, {cell})
  return I
 
0.12708333333333333, 4.7121778, def aidefcajacbfeafbjeffgfcdcceaaabg(I):
    objs = objects(I, T, F, T)
    def obj_score(obj): return (size(obj), uppermost(obj) * 100 + leftmost(obj)) 
    smallest_obj = argmin(objs, obj_score) # Find the smallest object, break ties using location
    O = underpaint(I, recolor(1, smallest_obj)) # Recolor the smallest object and paint onto the grid
    return O
 
0.3055555555555556, 3.9187746, def cagghcadffiaeieejhegaigccahdihhd(I):
    objs = objects(I, T, F, T)
    min_size = size(argmin(objs, size)) # Find the size of the smallest object
    def recolor_if_smallest(obj):
        return recolor(1, obj) if size(obj) == min_size else obj
    recolored_objs = apply(recolor_if_smallest, objs) # Recolor smallest objects
    O = paint(I, merge(recolored_objs)) # Paint the recolored objects onto the input grid
    return O
 
0.09340277777777778, 2.462454, def fdfcibdadegdeagbbdffcbbdedbbbjhd(I):
    # Find indices of all '2's in the grid
    x1 = ofcolor(I, TWO)  
    # Get the row index of the lowermost '2'
    x2 = valmax(x1, lambda x: x[0])
    # Filter indices to keep only those in the lowermost row 
    x3 = sfilter(x1, lambda x: x[0] == x2)
    # Replace the '2's in the lowermost row with '1's
    O = fill(I, ONE, x3)
    return O
 
0.15520833333333334, 2.5417526, def bbbagbcajbeaedeabagcbbchcfdjfdaj(I):
    # Rotate the grid 90 degrees clockwise
    x1 = rot90(I)
    # Find indices of all '2's in the rotated grid
    x2 = ofcolor(x1, TWO)
    # Get the column index of the rightmost '2' in the rotated grid
    x3 = valmax(x2, lambda x: x[1])
    # Filter indices to keep only those in the rightmost column of the rotated grid
    x4 = sfilter(x2, lambda x: x[1] == x3)
    # Rotate the indices back to original orientation
    x5 = apply(lambda x: (x[1], len(I) - 1 - x[0]), x4)
    # Replace '2's at the obtained indices with '1's in the original grid
    O = fill(I, ONE, x5)
    return O
 
0.06840277777777778, 2.3519905, def badaiaehcbjdehfgbcacecffaacfejbc(I):
    # Create a copy of the input grid
    O = [list(row) for row in I]
    # Iterate through rows from bottom to top
    for i in range(len(I) - 1, -1, -1):
        for j in range(len(I[0])):
            # If a '2' is found
            if O[i][j] == TWO:
                # Replace it with a '1'
                O[i][j] = ONE
                # Return the modified grid immediately 
                return tuple(tuple(row) for row in O)
    return I 
 
0.1236111111111111, 2.1599462, def iceecfcjgicaedbdiajdefefhaeddaea(I):
  objs = objects(I, T, F, F) # Extract all objects
  min_size = valmin(objs, size) # Find the size of the smallest object
  smallest_objs = sizefilter(objs, min_size) # Filter for smallest objects
  O = I 
  for obj in smallest_objs: # Paint over the original objects
    O = paint(O, recolor(1, obj)) 
  return O
 
0.12708333333333333, 4.7121778, def jfbdifdifcccedbfaidgabegicadefga(I):
    objs = objects(I, T, F, T)
    sizes = apply(size, objs) # Calculate sizes of all objects
    min_size = minimum(frozenset(sizes))  # Find the minimum size
    smallest = extract(objs, matcher(size, min_size)) # Extract the object with minimum size
    O = underpaint(I, recolor(1, smallest))  # Paint 1 under the smallest object
    return O
 
0.4128472222222222, 4.052679, def abjdbbfjehdfeiadabdfadhaacdbhibd(I):
  min_size_obj = argmin(objects(I, T, F, T), lambda obj: size(obj))
  O = paint(replace(I, color(min_size_obj), 1), min_size_obj)
  return O
 
0.18229166666666666, 2.9995384, def ijbfdhffafabeacjjaddebeahfdccagd(I):
  objs = objects(I, T, F, T)       # Identify all objects
  smallest_obj = argmin(objs, size) # Directly find the smallest object
  recolored_obj = recolor(1, smallest_obj) # Recolor the smallest object to 1
  O = paint(I, recolored_obj)      # Paint the recolored object onto the input grid
  return O 
 
0.06840277777777778, 2.3313103, def adbiadaaagaeegafjdcifhbgfgcaaecd(I):
    # Iterate through rows from bottom to top
    for i in range(len(I) - 1, -1, -1):
        # Iterate through columns from right to left
        for j in range(len(I[0]) - 1, -1, -1):
            # If a '2' is found
            if I[i][j] == TWO:
                # Create a copy of the input grid
                O = [list(row) for row in I]
                # Replace the found '2' with a '1'
                O[i][j] = ONE
                # Return the modified grid
                return tuple(tuple(row) for row in O)
    return I 
 
0.09895833333333333, 2.800158, def ffbcbifiabagecfhjedgfgfdaedijiaf(I):
    # Find indices of all '2's
    indices = ofcolor(I, TWO)
    # Find the rightmost '2' with the highest row index
    target_index = argmax(indices, lambda x: (x[1], -x[0]))
    # Replace the target '2' with a '1'
    return fill(I, ONE, {target_index}) 
 
0.21076388888888886, 3.642718, def daeebdbdeejbedibjabaeagghadbedca(I):
    # Transpose the grid
    transposed = rot90(I)
    # Find the lowermost '2' in the transposed grid (now rightmost)
    target_index = argmax(ofcolor(transposed, TWO), lambda x: x[0])
    # Rotate the target index back to the original grid orientation
    original_index = (target_index[1], len(I[0]) - 1 - target_index[0])
    # Replace the '2' at the original index with '1'
    return fill(I, ONE, {original_index})
 
0.23229166666666667, 3.4931898, def iddjcffeadjhehbdaddbfgcijhcidefg(I):
  objs = objects(I, T, F, T)  # Identify all objects
  bottom_objs = sfilter(objs, lambda obj: lowermost(obj) == len(I) - 1) # Filter for objects touching the bottom
  target_obj = argmin(bottom_objs, width) # Find the object with the smallest width
  O = paint(I, recolor(1, target_obj))  # Recolor the target object to 1
  return O
 
0.21076388888888886, 3.845906, def ffgjhdhcjdebejfdbejaeicbagegjfaf(I):
  for i in range(len(I) - 1, -1, -1):  # Iterate through rows from bottom to top
    row_objs = objects(crop(I, (i, 0), (1, len(I[0]))), T, F, T)  # Find objects in the current row
    if row_objs: # If objects exist in the row
      target_obj = argmin(row_objs, width) # Find the object with the smallest width
      return paint(I, recolor(1, target_obj))  # Recolor and paint
 
0.33541666666666664, 3.6743422, def agcfahhiicacecafbeidcedehjbbfeci(I):
  h = len(I)
  transposed = rot90(I)  # Rotate the grid 90 degrees counterclockwise
  right_objs = sfilter(objects(transposed, T, F, T), lambda obj: rightmost(obj) == len(transposed[0]) - 1)  # Find objects touching the right edge (originally bottom)
  target_obj = argmin(right_objs, height) # Find the object with minimum height (originally width)
  recolored_obj = recolor(1, target_obj) 
  O = rot270(paint(transposed, recolored_obj)) # Rotate the grid back to its original orientation
  return O
 
0.21076388888888886, 4.7963204, def gfiajafgfbheegaijededecaaddbedfc(I):
  objs = objects(I, T, T, T)
  lowest_obj = argmin(objs, lambda obj: lowermost(obj))
  rightmost_cell = argmax(toindices(lowest_obj), lambda x: x[1])
  return fill(I, 1, {rightmost_cell})
 
0.21076388888888886, 3.9596217, def fegdafbcicdaefaijigfeaehbhjbdaeb(I):
  def is_lowest_row(i):
    return any(I[i][j] != mostcommon(I) for j in range(width(I)))
  lowest_row_index = argmax(interval(0, height(I), 1), is_lowest_row)
  rightmost_cell = argmax(ofcolor(crop(I, (lowest_row_index, 0), (1, width(I))), index(I, (lowest_row_index, 0))), lambda x: x[1])
  return fill(I, 1, {rightmost_cell})
 
0.21076388888888886, 4.22451, def fadddhfdbbifejdcieddfdgafbjddije(I):
  for i in range(height(I) - 1, -1, -1):
    for j in range(width(I) - 1, -1, -1):
      if I[i][j] != mostcommon(I):
        return fill(I, 1, {(i, j)})
  return I
 
0.17951388888888886, 3.8421657, def jfcceibidgdbeehfjddifeifhddchghf(I):
  lowest_objs = sfilter(objects(I, T, T, T), lambda obj: lowermost(obj) == valmax(objects(I, T, T, T), lowermost))
  rightmost_obj = argmax(lowest_objs, lambda obj: rightmost(obj))
  rightmost_cell = argmax(toindices(rightmost_obj), lambda x: x[1])
  return fill(I, 1, {rightmost_cell})
 
0.1545138888888889, 3.113886, def gbhbfjdjehgdefajjdieaefiabfabhig(I):
  objs = objects(I, T, F, T)  # Identify all objects (excluding background)
  def bottom_cell(obj): return (lowermost(obj), rightmost(obj)) # Function to find bottom-right cell
  target_cell = bottom_cell(argmin(objs, size)) # Find bottom-right cell of smallest object
  O = paint(I, {(1, target_cell)}) # Paint the target cell as '1'
  return O
 
0.21076388888888886, 4.5218387, def idfcfdhjbjccecagjbfebaccdbgfbbaj(I):
    # Create a flattened list of grid values and their indices
    flattened = [(v, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r)]
    # Find the index of the 'lowest' 2 in the flattened list
    idx = next((i for i, (v, (row, col)) in enumerate(flattened) if v == TWO), None)
    # If a '2' is found, replace it with '1' in the flattened list
    if idx is not None:
        flattened[idx] = (ONE, flattened[idx][1])
    # Reshape the modified flattened list back into a grid
    O = tuple(tuple(flattened[i * len(I[0]) + j][0] for j in range(len(I[0]))) for i in range(len(I)))
    return O
 
0.12395833333333334, 2.918701, def jjfafjhceeieeaeibcdabeegaedcicfd(I):
    objs = objects(I, T, F, F)
    min_size = valmin(objs, size)
    smallest_objs = sfilter(objs, matcher(size, min_size))
    target_obj = extract(smallest_objs, identity) # Arbitrarily pick one smallest object
    target_cell = extract(toindices(target_obj), identity) # Arbitrarily pick one cell 
    O = paint(I, recolor(ONE, initset(target_cell))) 
    return O
 
0.17951388888888886, 3.7708209, def bhacfihaiiefeeeaiddceedfcfhjfbbg(I):
  """
  Iterates through rows from bottom to top, finding the rightmost non-background cell in the first row containing a non-background object.
  """
  bg = mostcolor(I)
  for i in range(height(I)-1, -1, -1):
    row_obj = {(I[i][j], (i,j)) for j in range(width(I)) if I[i][j] != bg}
    if row_obj:
      target_cell = argmax(row_obj, lambda x: x[1])[1]
      return fill(I, 1, {target_cell})
 
0.2635416666666667, 5.1363993, def idbbidcdebjjefchbbbejabbcbifbebd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  modified_objs = frozenset({recolor(ONE, {(color(obj), (lowermost(obj), j))}) if (lowermost(obj), j) in toindices(obj) else obj for obj in objs for j in range(width(I))})
  O = paint(canvas(mostcolor(I), shape(I)), merge(modified_objs))
  return O
 
0.42777777777777776, 5.2750716, def affjbibffedhegcjjgiafjeadagbcdag(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  for obj in objs:
    bottom_row = lowermost(obj)
    for j in range(width(I)):
      if (bottom_row, j) in toindices(obj):
        I = fill(I, ONE, {(bottom_row, j)})
  O = I
  return O
 
0.2329861111111111, 2.8720205, def cabbebfebacfejcdbebieaebfijhifba(I):
  for i in range(height(I)-1, -1, -1):
    for j in range(width(I)):
      if I[i][j] == TWO:
        above_same = i > 0 and I[i-1][j] == TWO
        if not above_same:
          I = fill(I, ONE, {(i, j)})
  O = I
  return O
 
0.12395833333333334, 3.4706903, def gjceedeiddeceieajbacgccjaccaccba(I):
  objs = objects(I, T, F, F) # Identify all connected objects
  min_size = valmin(objs, size) # Find the size of the smallest object
  smallest_objs = sfilter(objs, matcher(size, min_size)) # Filter for smallest objects
  if len(smallest_objs) > 1: # If multiple smallest objects exist
    bottom_left_obj = argmin(smallest_objs, lambda obj: ulcorner(obj)[0] + ulcorner(obj)[1]) # Select the bottom-leftmost object
    target_cell = llcorner(bottom_left_obj) # Target the lower-left corner of this object
  else:
    target_cell = llcorner(first(smallest_objs)) # Target the lower-left corner of the single smallest object
  O = paint(I, recolor(ONE, initset(target_cell))) # Recolor the target cell to '1'
  return O
 
0.21076388888888886, 4.6493406, def cjfffbjdccdcebbfaecaehfbfbidabee(I):
  objs = objects(I, T, F, F)
  target_obj = argmin(objs, lambda obj: (size(obj) == 3, ulcorner(obj)[0] + ulcorner(obj)[1])) # Prioritize size 3 objects, then bottom-left
  if size(target_obj) == 3:
    rightmost_cell = argmax(toindices(target_obj), lambda cell: cell[1]) # Find the rightmost cell within the target object
    target_cell = rightmost_cell
  else:
    target_cell = llcorner(target_obj)
  O = paint(I, recolor(ONE, initset(target_cell)))
  return O
 
0.12395833333333334, 3.1668487, def fcajcacfigjhefciaaebdcgeeiaadjif(I):
  objs = objects(I, T, F, F)
  target_obj = argmin(objs, lambda obj: (size(obj) == 3, ulcorner(obj)[1])) # Prioritize size 3, then leftmost
  if size(target_obj) != 3:
    min_size = valmin(objs, size)
    smallest_objs = sfilter(objs, matcher(size, min_size))
    target_obj = argmin(smallest_objs, lambda obj: ulcorner(obj)[0]) # Find topmost among smallest
  target_cell = (lowermost(target_obj), leftmost(target_obj) + width(target_obj) // 2) # Calculate middle of bottom row
  O = paint(I, recolor(ONE, initset(target_cell))) 
  return O
 
0.12395833333333334, 3.115907, def eidbcfejifjfehecigedbbdeffacdded(I):
  objs = objects(I, T, F, F)
  if len(sfilter(objs, matcher(size, THREE))) > 0: # Check if any object has size 3
    target_obj = argmin(objs, lambda obj: (size(obj) == 3, ulcorner(obj)[1])) # If yes, prioritize size 3, then leftmost
    target_cell = (lowermost(target_obj), rightmost(target_obj)) # Rightmost cell on the bottom row
  else:
    target_obj = argmin(objs, size) # Otherwise, pick the smallest object
    target_cell = llcorner(target_obj) # And target its lower-left corner
  O = paint(I, recolor(ONE, initset(target_cell))) 
  return O
 
0.15208333333333332, 2.6164913, def jfiijbecbejfeajfiaeficfciddccice(I):
    h = height(I)
    return fill(I, 1, {(h - 1, max(j for j in range(width(I)) if I[h-1][j] != mostcommon(I[h-1]))), (h - 2, max(j for j in range(width(I)) if I[h-1][j] != mostcommon(I[h-1])))} )
 
0.15208333333333332, 2.54792, def bhhadahebgfgejgdbgajeggcjeahieaa(I):
    target_cell = max(((i, j) for i in (height(I) - 1, height(I) - 2) for j in range(width(I)) if I[i][j] != mostcommon(I[i])), key=lambda x: x[1])
    return fill(I, 1, {target_cell, (target_cell[0] - 1, target_cell[1])})
 
0.25, 3.9318347, def hbihcdfebechebieidbeheafebcbefab(I):
  def find_and_modify(obj):
    if size(obj) == size(argmin(objects(I, T, F, T), size)):
        i, j = lrcorner(obj)
        return insert((1, (i, j)), remove((I[i][j], (i, j)), obj)) # Replace color at bottom-right
    return obj
  modified_objs = apply(find_and_modify, objects(I, T, F, T))
  O = paint(I, merge(modified_objs)) 
  return O
 
0.17708333333333331, 2.5447714, def efdfbdfafbcaeddebbigdbfcjddfbbga(I):
  h = len(I)
  w = len(I[0])
  O = [[I[i][j] for j in range(w)] for i in range(h)]
  for j in range(w):
    for i in range(h - 1, -1, -1):
      if I[i][j] == TWO:
        if i == h - 1 or I[i + 1][j] != TWO:
          O[i][j] = ONE
        break
  return tuple(tuple(row) for row in O)
 
0.8142361111111112, 9.404991, def befifbcghediedihafbajggfhjbidbbc(I):
  return tuple(
    tuple(
      ONE if j == len(I) - 1 or I[j + 1][i] != TWO else v
      for j, v in enumerate(reversed(col))
    )
    for i, col in enumerate(zip(*I))
  )
 
0.6458333333333333, 4.3485684, def bcebecccecbaeaibjjjbidcefbejbgef(I):
  def process_column(j, col):
    for i, v in enumerate(reversed(col)):
      if v == TWO:
        return tuple(ONE if k == i else x for k, x in enumerate(reversed(col)))
    return col
  return tuple(
    tuple(process_column(j, col)) for j, col in enumerate(zip(*I))
  )
 
0.25763888888888886, 4.3754396, def bacafbfjfjchejcfbjbiejcghdfccbii(I):
  O = tuple(zip(*I))
  for j, col in enumerate(O):
    bottom_two_index = None
    for i, v in enumerate(col):
      if v == TWO:
        bottom_two_index = i
    if bottom_two_index is not None and (bottom_two_index == len(col) - 1 or col[bottom_two_index + 1] != TWO):
      O = tuple(
        tuple(ONE if k == j and i == bottom_two_index else v for k, v in enumerate(row)) 
        for i, row in enumerate(O)
      )
  return tuple(zip(*O))
 
0.46805555555555556, 5.367629, def hjjjfccafeceebfbiddefeabffccieef(I):
    least_color = leastcommon(merge(I)) # Find the least common color, representing the smallest object
    O = replace(I, least_color, ONE)  # Replace the least common color with '1'
    return O
 
0.25729166666666664, 3.0599089, def egdjaebjgbgdehfhidiebjfdcbbefaih(I):
  bottom_row_objs = objects(I[-1:], T, F, T)
  bottom_row_colors = set(color(obj) for obj in bottom_row_objs)  
  def score(obj):
    return size(obj) if color(obj) in bottom_row_colors else float('inf')
  target_object = argmin(objects(I, T, F, T), score)
  return paint(I, recolor(1, target_object))
 
0.22326388888888887, 4.830885, def biiaagceefaeeaggbhhadfgdfcjhaefb(I):
  target_obj = max(objects(I[height(I)-2:][:], univalued=False, diagonal=False, without_bg=True), key=lambda obj: rightmost(obj))
  target_cell = (lowermost(target_obj), rightmost(target_obj))
  return fill(I, 1, {target_cell, (target_cell[0]-1, target_cell[1])}) 
 
0.23229166666666667, 3.425962, def bjcfgacbefcfeehdifajfheicbdcgcbi(I):
  bottom_objects = []
  for obj in objects(I, T, F, T):
    if any(i == len(I) - 1 for i, j in toindices(obj)):
      bottom_objects.append(obj)
  target_object = min(bottom_objects, key=size)
  return paint(I, recolor(1, target_object))
 
0.2631944444444444, 3.06939, def cfeabdahdddeefbejeceeeabcjbgjafi(I):
  objs = objects(I, T, T, T)  # Identify objects excluding background
  bottom_obj = argmax(objs, lowermost) # Select bottom-most object
  bottom_cell = argmin(toindices(bottom_obj), lambda x: x[1]) # Find leftmost cell in bottom object
  target_cell = (bottom_cell[0] - 1, bottom_cell[1]) # Target the cell above the leftmost cell
  return fill(I, 1, {target_cell, (target_cell[0] + 1, target_cell[1])}) # Fill target and the cell below it with '1' 
 
0.17951388888888886, 3.2287447, def hebfdagchefdeiajiebdhjbfddgeaedi(I):
  objs = objects(I, T, T, T)
  bottom_obj = argmax(objs, lowermost)
  target_cell = argmin(toindices(bottom_obj), lambda x: x[1])
  if height(bottom_obj) > 1: 
    target_cell = (target_cell[0] - 1, target_cell[1])  
  return fill(I, 1, {target_cell})
 
0.17951388888888886, 4.5099993, def ieiceccjgcdfeeeficdhdagjbaacjdcc(I):
    objs = objects(I, T, T, T)
    bottom_obj = argmax(objs, lowermost)
    center_i, center_j = centerofmass(bottom_obj)
    target_cell = (center_i, center_j) 
    if index(I, (target_cell[0]+1, target_cell[1])) == mostcommon(I):
        target_cell = (target_cell[0]+1, target_cell[1])
    return fill(I, 1, {target_cell})
 
0.14270833333333333, 2.3449478, def afahieadaiajeibfbcdbabfajdbadbed(I):
  objs = objects(I, T, T, T)
  lowest_obj = argmax(objs, lowermost)
  target_cells = set()
  for i, j in toindices(lowest_obj):
    if index(I, (i, j + 1)) != index(I, (i, j)) and index(I, (i, j + 1)) != mostcommon(I):
      target_cells.add((i, j + 1))
  return fill(I, 1, target_cells)
 
0.1545138888888889, 3.336942, def iheehchchddceijcbfeaiieccadcfhea(I):
  objs = objects(I, T, F, T) # Identify objects, excluding background.
  def bottom_left(obj): return (lowermost(obj), leftmost(obj)) # Find bottom-left index.
  target_index = bottom_left(argmin(objs, size)) # Bottom-left of the smallest object.
  O = paint(I, {(1, target_index)}) # Paint the target cell as '1'.
  return O
 
0.25, 3.9207304, def cdhgcidacjciefhbijbagdacheeajgci(I):
  min_size = size(argmin(objects(I, T, F, T), size)) # Find size of smallest object.
  objs = sizefilter(objects(I, T, F, T), min_size) # Filter objects by the smallest size.
  def bottom_left_index(obj): return (lowermost(obj), leftmost(obj))
  target_cells = apply(bottom_left_index, objs) # Get bottom-left indices of all smallest objects.
  O = I
  for cell in target_cells:
    O = paint(O, {(1, cell)}) # Paint all target cells.
  return O 
 
0.1545138888888889, 3.5616205, def eeghccijagafeidjadifbbfhidiaehbj(I):
  def modified_size(obj): return (size(obj), -leftmost(obj)) # Prioritize leftmost when sizes are equal.
  objs = objects(I, T, F, T)
  target_cell =  (lowermost(argmin(objs, modified_size)), leftmost(argmin(objs, modified_size)))
  O = paint(I, {(1, target_cell)})
  return O
 
0.1545138888888889, 3.2881238, def efcffdcefeddejbcabccgadeebdbacba(I):
    def is_bottom_left(obj, cell):
        return cell[0] == lowermost(obj) and cell[1] == leftmost(obj) # Check if a cell is the bottom-left of an object.

    objs = objects(I, T, F, T)
    target_cell = None 
    for obj in objs:
        if size(obj) == size(argmin(objs, size)): # If object has the smallest size.
            for v, cell in obj: # Iterate through its cells.
                if is_bottom_left(obj, cell): 
                    target_cell = cell
                    break # Stop after finding the bottom-left. 

    O = paint(I, {(1, target_cell)}) # Paint the target cell.
    return O
 
0.2329861111111111, 3.817699, def hciajidagchaebfijabbhdbhdaejdgae(I):
  O = tuple(tuple(1 if val == 2 and i == len(I) - 1 or (i < len(I) - 1 and I[i + 1][j] != 2 and val == 2) else val for j, val in enumerate(row)) for i, row in enumerate(I))
  return O
 
0.48055555555555557, 12.343462, def eeaijacgibfeeababgebdgajddddigje(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    for i in range(height(I) - 1, -1, -1):
      if I[i][j] == 2:
        O = fill(O, 1, {(i, j)})
        break
  return O
 
0.15520833333333334, 3.6275852, def hbcbfcbcfbfaebahagbjbdbcbaaeabjd(I):
    objs = objects(I, T, F, F)
    bottom_objs = sfilter(objs, matcher(lowermost, valmax(objs, lowermost)))  # Filter for bottom-most objects
    target_obj = argmin(bottom_objs, leftmost) # Select the leftmost of the bottom-most objects
    target_cell = llcorner(target_obj)  # Get the bottom-left corner of the target object
    O = paint(I, recolor(ONE, initset(target_cell)))  # Recolor the target cell
    return O
 
0.17951388888888886, 3.7901976, def gdeddcffggigeddbafabdbeafcbdfebb(I):
    h = height(I)
    for i in range(h - 1, -1, -1): # Iterate rows from bottom to top
        for j in range(len(I[0])): # Iterate columns from left to right
            if I[i][j] != mostcolor(I): # Check if cell is not background
                return paint(I, recolor(ONE, initset((i, j)))) # Recolor and return
 
0.3055555555555556, 3.9187746, def dcefhifdefchedjbihadcbdegadadffj(I):
  # 1. Get a list of all object sizes
  sizes = apply(size, objects(I, T, F, T))
  # 2. Find the minimum size
  min_size = minimum(sizes)
  # 3. Filter objects to keep only those with the minimum size
  min_objs = sizefilter(objects(I, T, F, T), min_size)
  # 4. Recolor all minimum size objects to '1' and paint on the grid
  O = paint(I, recolor(ONE, merge(min_objs)))
  return O
 
0.34375, 4.0506806, def ejgaecadachaedbeaddegdfbjdacaebb(I):
  """
  Finds the lowest object in each column and changes its rightmost cell to 1.
  """
  bg = mostcolor(I)
  target_cells = set()
  for j in range(width(I)):
    for i in range(height(I)-1, -1, -1):
      if I[i][j] != bg:
        target_cells.add((i,j))
        break
  return fill(I, 1, target_cells)
 
0.17951388888888886, 3.9747505, def bfcidebeecdeedbhjbifdaijabajcajg(I):
  """
  Utilizes object detection to find the lowest object and modify its rightmost cell. 
  """
  objs = objects(I, T, T, T)
  target_cells = frozenset({lrcorner(obj) for obj in objs})
  return fill(I, 1, target_cells)
 
0.1986111111111111, 3.5249004, def fbaeiahbehafebgfjggdbfdeecbccjag(I):
  objs = objects(I, T, F, F)  # Extract all objects
  bottom_objs = sfilter(objs, matcher(lowermost, valmax(objs, lowermost))) # Bottom-most objects
  target_obj = argmin(bottom_objs, leftmost) # Leftmost of bottom-most objects
  target_cell = llcorner(target_obj) # Bottom-left corner
  O = paint(I, recolor(ONE, initset(target_cell))) # Recolor target cell

  # Find the rightmost bottom cell of the same color
  rightmost_bottom_indices = sfilter(asindices(I), lambda loc: loc[0] == len(I) - 1 and I[loc[0]][loc[1]] == color(target_obj))
  if rightmost_bottom_indices:
    rightmost_bottom_cell = argmax(rightmost_bottom_indices, lambda x: x[1])
    O = paint(O, recolor(ONE, initset(rightmost_bottom_cell))) 

  return O 
 
0.06840277777777778, 2.3431516, def bcdgfedcgbdbegefbcdegeecbgfbacfh(I):
  bottom_row = I[len(I)-1] # Extract the bottom row
  target_j = next((j for j, v in enumerate(bottom_row) if v != mostcommon(bottom_row)), None) # Find first non-most common value index
  if target_j is not None:
    target_cell = (len(I)-1, target_j) 
    I = paint(I, recolor(ONE, initset(target_cell))) # Recolor
  return I
 
0.17951388888888886, 3.7901976, def baedbcdbgacjecbdicbiabcaiciagdei(I):
  h = height(I)
  w = width(I)
  for i in range(h - 1, -1, -1):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        return fill(I, 1, {(i, j)})
  return I 
 
0.46805555555555556, 5.367629, def gfebfecbbedeecfdbgiabbaahiecbjfd(I):
  objs = objects(I, T, F, T)
  smallest_obj = argmin(objs, size)
  target_color = index(I, (lowermost(smallest_obj), leftmost(smallest_obj)))
  O = replace(I, target_color, 1)
  return O
 
0.5118055555555555, 31.800266, def abcijabjcbdcehgcihdefcfbfhehgfhe(I):
  def is_bottom_rightmost_two(x):
    i, j = x[1]
    h, w = len(I), len(I[0])
    return x[0] == TWO and all(I[k][l] != TWO for k in range(i, h) for l in range(j, w))
  modified_indices = mfilter(asobject(I), is_bottom_rightmost_two)
  O = paint(canvas(mostcolor(I), shape(I)), recolor(ONE, modified_indices))
  return O
 
0.12708333333333333, 4.7121778, def echeddhcibccehjhiecjbbhcedfiiaba(I):
  h, w = len(I), len(I[0])
  def is_target(i, j):
    return I[i][j] == TWO and all(I[k][l] != TWO for k in range(i, h) for l in range(j, w))
  indices = ((i, j) for i in range(h-1, -1, -1) for j in range(w-1, -1, -1) if is_target(i, j))
  i, j = next(indices, (None, None))
  return paint(I, {(ONE, (i, j))}) if i is not None else I
 
0.1857638888888889, 3.962638, def bciiejihaajceggebgiaiehfeddceacb(I):
  objs = objects(I, T, F, F) # Identify objects in the grid
  if len(sfilter(objs, matcher(size, 4))) > 0: # Check for objects of size 4
    target_obj = extract(objs, matcher(size, 4)) # Select the object of size 4
    target_cell = lrcorner(target_obj) # Target the lower-right corner
    target_cell = (target_cell[0] - 1, target_cell[1]) # Adjust to the cell above
  else:
    target_obj = argmin(objs, size) # Select the smallest object
    if size(target_obj) == 1: # If smallest object is a single cell
      target_cell = first(toindices(target_obj)) # Target that cell
    else:
      target_cell = (lowermost(target_obj), rightmost(target_obj)) # Target the bottom-right corner
  return paint(I, recolor(ONE, initset(target_cell))) # Recolor the target cell to 1 
 
0.21076388888888886, 4.763722, def bffbaefchccfeaegjdeheacjdecfhbfh(I):
  objs = objects(I, T, F, F) # Identify objects in the grid
  target_obj = argmin(objs, lambda obj: (size(obj) != 3, ulcorner(obj)[0])) # Prioritize non-size 3, then topmost
  if size(target_obj) == 3: # If target object is of size 3
    target_cell = (lowermost(target_obj), rightmost(target_obj)) # Target its bottom-right corner
  else:
    target_cell = llcorner(target_obj) # Otherwise, target the lower-left corner
  return paint(I, recolor(ONE, initset(target_cell))) # Recolor the target cell to 1
 
0.21076388888888886, 4.4331446, def cabadbbeabdieafbijbacbebijhhhfdf(I):
  objs = objects(I, T, F, F)
  target_obj = argmin(objs, lambda obj: (uppermost(obj), size(obj))) # Prioritize topmost, then smallest size
  if uppermost(target_obj) == len(I) - 2: # If the top of the object is on the second-to-last row
    target_cell = (lowermost(target_obj), rightmost(target_obj) - 1) # Target the cell left of the bottom-right corner
  else:
    target_cell = (lowermost(target_obj), rightmost(target_obj)) # Otherwise, target the bottom-right corner
  return paint(I, recolor(ONE, initset(target_cell)))
 
0.043402777777777776, 1.5668579, def efddibfhcchheffaabijcdiabaficcag(I):
  target_cell = (len(I) - 1, 0) # Initialize target to bottom-left corner
  for j in range(len(I[0])): # Iterate through columns from left to right
    if I[len(I) - 1][j] != mostcommon(I[len(I) - 1]): # If a cell in the bottom row isn't the most common value
      target_cell = (len(I) - 1, j) # Update target cell
      break
  if target_cell == (len(I) - 1, 0) and len(objects(I, T, F, F)) > 1: # If target hasn't changed and there are multiple objects
    objs = objects(I, T, F, F)
    target_obj = argmin(objs, size) # Find the smallest object
    target_cell = (lowermost(target_obj), rightmost(target_obj)) # Update target to bottom-right corner of smallest object
  return paint(I, recolor(ONE, initset(target_cell))) # Recolor the target cell to 1
 
0.17951388888888886, 3.9264884, def jahdfbebbbjgebebafdeacdceaiahgbd(I):
  # Find the rightmost object
  obj = max(objects(I, T, T, T), key=lambda obj: rightmost(obj))
  # Find the bottom-most cell within the object
  target_cell = max(obj, key=lambda cell: cell[1][0])
  # Change the value of the target cell to 1
  O = fill(I, 1, {target_cell[1]})
  return O
 
0.1545138888888889, 3.598375, def bdcedicjaehdeaghbadcgdedjfigcefj(I):
  def bottom_left_index(obj):
    return (lowermost(obj), leftmost(obj)) # Function to find bottom-left index.
  
  objs = objects(I, T, F, T) # Identify objects, excluding background.
  smallest_obj = min(objs, key=lambda obj: (size(obj), bottom_left_index(obj))) # Find smallest object, break ties with bottom-left priority.
  O = fill(I, 1, {bottom_left_index(smallest_obj)}) # Fill bottom-left cell of smallest object with '1'.
  return O
 
0.15520833333333334, 3.5096173, def hifadbgideifefbcbbdijeafaadebbbc(I):
  bottom_objs = sfilter(objects(I, T, F, F), lambda obj: lowermost(obj) == len(I)-1)  # Objects touching bottom
  target_obj = argmin(bottom_objs, lambda obj: leftmost(obj)) # Leftmost of bottom objects
  target_cell = (lowermost(target_obj), rightmost(target_obj)) # Bottom-right cell of target object
  return paint(I, recolor(ONE, initset(target_cell)))  # Recolor target cell to 1
 
0.15520833333333334, 3.6275852, def caicbjchbiebeafciefafdddccfddbfb(I):
  O = paint(I, recolor(ONE, initset((len(I) - 1, 0)))) # Color bottom-left corner 1
  if index(I, (len(I) - 1, 1)) == index(I, (len(I) - 1, 0)): # Check if object spans horizontally
    O = paint(I, recolor(ONE, initset((len(I) - 1, width(I) - 1)))) # Recolor bottom-right
  return O 
 
0.21076388888888886, 4.22451, def fcccaifedbadehcaiddfaifcjeebfeac(I):
  bottom_row = I[len(I) - 1]  # Extract the bottom row
  obj_start = next((j for j, v in enumerate(bottom_row) if v != mostcommon(bottom_row)), None)  # Find object start
  if obj_start is not None:
    obj_end = next((j for j in range(len(bottom_row) - 1, obj_start - 1, -1) if bottom_row[j] != bottom_row[obj_start]), obj_start - 1)  # Find object end
    target = (len(I) - 1, obj_end) # Target the rightmost cell of the object
  else:
    target = (len(I) - 1, 0) # Default to bottom-left if no object found
  return paint(I, recolor(ONE, initset(target)))  # Recolor and return
 
0.13958333333333334, 4.5977883, def cgadahddhabbebeejcbbbfeaachabgaa(I):
  target = argmax(asindices(I), lambda ij: (ij[0] + ij[1], -ij[0], -ij[1]))  # Find bottom-rightmost index
  return paint(I, recolor(ONE, initset(target))) if index(I, target) == TWO else I # Replace if it's a '2'
 
0.12395833333333332, 3.243906, def caffccaehfjaeghjibbfeechfejdcjia(I):
  h, w = len(I), len(I[0])
  target_j = max((j for j in range(w) if any(I[i][j] == TWO for i in range(h))), default=None) # Find the rightmost column containing a '2'
  if target_j is not None:
    target_i = max((i for i in range(h) if I[i][target_j] == TWO), default=0) # Find the bottom-most '2' in that column
    return paint(I, recolor(ONE, initset((target_i, target_j)))) # Replace the '2'
  return I
 
0.12395833333333332, 3.271382, def ebddejaiahefeeedafafegbefadaedgj(I):
  objs = objects(I, T, T, T) # Get all objects
  lowest_obj = argmax(objs, lowermost) # Find the lowest object
  target_cell = (lowermost(lowest_obj), leftmost(lowest_obj) + width(lowest_obj) // 2) # Calculate the target cell's index
  return fill(I, 1, {target_cell}) # Fill the target cell with '1' 
 
0.17951388888888886, 3.7708209, def degihahaeaaeeiejihbbdcffafeeccec(I):
  objs = objects(I, T, T, T)
  lowest_obj = argmax(objs, lambda obj: lrcorner(obj)[0]) # Find lowest object by lrcorner row index
  target_cell = (lrcorner(lowest_obj)[0], lrcorner(lowest_obj)[1] + 1) # Target cell is right of lrcorner
  if target_cell[1] < len(I[0]) and index(I, target_cell) == mostcommon(I): 
    return fill(I, 1, {target_cell})
  else:
    return fill(I, 1, {lrcorner(lowest_obj)}) # If target cell is out of bounds or not background, fill lrcorner
 
0.19826388888888888, 4.1390567, def cfbabhibcheeedajbhgaafggijjbebgb(I):
  lowest_two = argmax(ofcolor(I, 2), lambda x: x[0]) # Find the lowest '2' by row
  target_cell = (lowest_two[0], lowest_two[1] + 1) # Target is to the right
  return fill(I, 1, {target_cell}) 
 
0.15520833333333334, 3.7985191, def fdfdbhejihjcebeaihfiafhbeifcdbdd(I):
  objs = objects(I, T, T, T)
  lowest_obj = argmax(objs, lambda obj: centerofmass(obj)[0]) # Find lowest object by center of mass
  target = add(centerofmass(lowest_obj), (0, 1))  # Target is right of center of mass
  return fill(I, 1, {target}) 
 
0.21076388888888886, 4.5504746, def dfafafggeedbebdgjbbceaefbdbdhagh(I):
  for i in range(len(I) - 1, -1, -1):  # Iterate rows from bottom
    for j in range(len(I[0])):
      if I[i][j] == 2: # Find the first '2' from the bottom
        if j + 1 < len(I[0]): # Check if a right neighbor exists
          return fill(I, 1, {(i, j + 1)}) # Fill the right neighbor with '1'
        else:
          return fill(I, 1, {(i, j)})  # If no right neighbor, fill the '2' itself
  return I
 
0.8729166666666666, 31.752344, def hchibiajcffieeefbebceajddicbhjec(I):
  # Find all objects in the grid
  objs = objects(I, False, False, False)
  # Filter for objects containing '2'
  twos_objs = sfilter(objs, lambda obj: any(v == 2 for v, _ in obj))
  # Find the object with the lowest bottom edge
  target_obj = argmax(twos_objs, lambda obj: lowermost(obj))
  # Recolor the target object to '1'
  recolored_obj = recolor(1, target_obj)
  # Paint the recolored object onto the input grid
  O = paint(I, recolored_obj) 
  return O 
 
0.7170138888888888, 4.886655, def hcddehdfadejeibebbcffbceiefifaae(I):
  # Get all indices of the grid
  all_indices = asindices(I)
  # Create a function to check for '2' at a given index
  is_two = lambda x: I[x[0]][x[1]] == 2
  # Find indices of all '2's
  indices_of_twos = sfilter(all_indices, is_two)
  # Get the row index of the lowest '2'
  lowest_row = lowermost(indices_of_twos) 
  # Define a function to replace '2' with '1' only in the target row
  replace_in_row = lambda x: (1, x) if is_two(x) and x[0] == lowest_row else (I[x[0]][x[1]], x)
  # Apply the replacement function to all indices
  modified_grid = apply(replace_in_row, all_indices)
  # Convert the modified grid back to the original format
  O = tuple(tuple(v for v, _ in row) for row in  vsplit(tuple(modified_grid), len(I[0])))
  return O
 
0.043402777777777776, 1.5668579, def gfcfgcbbcdfgeaeeibaefgceefbfffda(I):
  objs = objects(I, T, F, F)  # Extract all objects from the grid
  target_color = TWO  # Define the target color for object selection
  filtered_objs = sfilter(objs, lambda obj: color(obj) == target_color)  # Filter objects by target color
  smallest_obj = argmin(filtered_objs, size)  # Find the smallest object
  corner_index = lrcorner(smallest_obj) # Find the lower right corner index of the object
  O = fill(I, ONE, {corner_index})  # Replace the corner cell with '1'
  return O
 
0.21076388888888886, 4.22451, def dacbeifeehcceecbjbdfadbgfddcgaeg(I):
  objs = fgpartition(I) # Partition the grid, excluding the background
  target_obj = argmin(objs, size) # Directly find the smallest object 
  bottom_right_cell = lrcorner(target_obj)  # Find the lower right corner
  updated_grid = fill(I, ONE, {bottom_right_cell}) # Replace the cell with '1'
  return updated_grid
 
0.18229166666666666, 2.9995384, def ahdheicehacieiciiafbegfeaheiiiba(I):
  objs = objects(I, T, F, T) # Identify all objects excluding the background.
  target_obj = argmin(objs, size) # Find the smallest object.
  min_row = lowermost(target_obj) # Find the lowest row index of the target object.
  target_cells = frozenset((min_row, j) for j in range(len(I[0])) if (min_row, j) in toindices(target_obj)) # Find all cells in the last row of the target object.
  return paint(I, recolor(ONE, target_cells)) # Recolor the target cells to '1'.
 
0.21041666666666664, 3.744429, def iegeagfbaaceeeahbbcdjcbifadcibed(I):
  objs = objects(I, T, F, T) # Find all objects, excluding background.
  min_obj = argmin(objs, size) # Find the smallest object.
  bottom_right = (lowermost(min_obj), rightmost(min_obj)) # Find the bottom-right corner of the smallest object.
  if hline(min_obj) or vline(min_obj): # If the object is a horizontal or vertical line, include the cell to the left.
    target_cells = frozenset({bottom_right, (bottom_right[0], bottom_right[1] - 1)}) 
  else:
    target_cells = frozenset({bottom_right})
  return paint(I, recolor(ONE, target_cells)) # Recolor the target cell(s) to 1.
 
0.1857638888888889, 3.5088077, def djfghgjcedbaedaibaebecjiafdhfbjb(I):
  objs = objects(I, T, F, T) # Identify all objects, excluding background.
  target_obj = argmin(objs, lambda obj: (lowermost(obj), -rightmost(obj))) # Find the smallest object, prioritizing lower and rightmost positions.
  target_cell = (lowermost(target_obj), rightmost(target_obj)) # Target the bottom-right corner of the smallest object.
  if target_cell[1] > 0 and (target_cell[0], target_cell[1] - 1) in toindices(target_obj):
    target_cell = (target_cell[0], target_cell[1] - 1) # Shift target left if possible and still within the object.
  return paint(I, recolor(ONE, initset(target_cell))) # Recolor the target cell to '1'.
 
0.06840277777777778, 2.3519905, def jhceeiidhaffeahdbegeidheedjbbaje(I):
  h, w = len(I), len(I[0])
  for j in range(w):
    if I[h - 1][j] == TWO:
      return paint(I, recolor(ONE, initset((h-1, j))))
  for i in range(h):
    if I[i][w - 1] == TWO:
      return paint(I, recolor(ONE, initset((i, w-1))))
  return I
 
0.15520833333333334, 3.881847, def aafhijaccghcefgbihccfafadhajfcea(I):
  # Directly find target cells using nested loops and conditions
  target_cells = set()
  for i in range(len(I) - 1, -1, -1):
    for j in range(len(I[0]) - 1, -1, -1):
      if I[i][j] == leastcolor(I) and I[i][j] != mostcommon(I) and (j + 1 < len(I[0]) and I[i][j + 1] != I[i][j] and I[i][j + 1] != mostcommon(I)):
        target_cells.add((i, j + 1))
        break  
    if len(target_cells) > 0:
      break 
  return fill(I, 1, frozenset(target_cells))
 
0.06840277777777778, 2.3431516, def bbdidbcfdicbebddifbfaccjfdbggbai(I):
  bottom_row = I[len(I) - 1] 
  different_values = [(j,v) for j, v in enumerate(bottom_row) if v != mostcommon(bottom_row)] 
  if different_values:
    target_cell = (len(I) - 1, max(different_values)[0]) 
  elif len(objects(I, T, F, F)) > 1:
    objs = objects(I, T, F, F)
    target_obj = min(objs, key=lambda obj: (size(obj), -rightmost(obj)))
    target_cell = (lowermost(target_obj), rightmost(target_obj))
  else:
    target_cell = (len(I) - 1, 0)
  return paint(I, recolor(1, initset(target_cell))) 
 
0.09895833333333333, 2.5278034, def afdhbfbdbeageaaeidecedfgcceghadj(I):
  objs = objects(I, T, F, F)
  if len(objs) > 1:
    smallest_obj = argmin(objs, size)
    target_cell = (lowermost(smallest_obj), rightmost(smallest_obj))
  else:
    for j in range(len(I[0])-1, -1, -1): 
      if I[len(I) - 1][j] != mostcommon(I[len(I) - 1]): 
        target_cell = (len(I) - 1, j)
        break
    else: 
      target_cell = (len(I) - 1, 0) 
  return paint(I, recolor(1, initset(target_cell)))
 
0.15520833333333334, 3.289378, def icahdhaifcbbecdeifdheeffacbcbggh(I):
  # Find the target object based on color and being the lowest
  target_object = argmax(
      sfilter(
          objects(I, T, T, T),
          lambda obj: color(obj) == leastcolor(I) and lrcorner(obj)[0] == height(I) - 1
      ), 
      lambda obj: lrcorner(obj)[1]
  )

  # Define potential target cells
  target_cell_right = add(lrcorner(target_object), (-1, 1)) 
  target_cell_below = add(llcorner(target_object), (1, 0)) 

  # Fill cells based on conditions
  filled_cells = {target_cell_right}
  if target_cell_below[0] < height(I):
    filled_cells.add(target_cell_below)
  if target_cell_right[1] == width(I):
    filled_cells.add((height(I) - 1, 0))

  return fill(I, 1, filled_cells) 
 
0.15833333333333333, 4.030145, def ehdgfigbicceeabfidbchfeeeffgbdca(I):
  # Find target object based on color and proximity to bottom-right
  target_object = argmax(
      colorfilter(objects(I, T, T, T), leastcolor(I)),
      lambda obj: lrcorner(obj)[0] * width(I) + lrcorner(obj)[1]
  )
  
  # Calculate target cells
  target_cell = add(lrcorner(target_object), (-1, 1))
  bottom_cell = (height(I) - 1, 0)

  # Fill cells based on condition
  return fill(
      I,
      1,
      {target_cell, bottom_cell} if target_cell[1] < width(I) else {target_cell}
  )
 
0.13958333333333334, 3.6928134, def cgbbbgjciaecefdjbfaeeddcahhijace(I):
  # Find the target object based on color and being the lowest
  target_object = argmax(
      sfilter(objects(I, T, T, T), lambda obj: color(obj) == leastcolor(I)), 
      lambda obj: lrcorner(obj)[0]
  )
  
  # Determine target cell based on conditions
  target_cell = add(lrcorner(target_object), (-1, 1))
  if target_cell[1] == width(I):
    target_cell = (height(I) - 1, 0)
  elif target_cell[0] != height(I) - 1:
    target_cell = add(llcorner(target_object), (1, 0)) 

  # Fill the target cell
  return fill(I, 1, {target_cell})
 
0.17708333333333331, 2.5447714, def gjeaededfdeeeiafihfefjfabeaadfdb(grid):
  """
  Iterate through columns and find the lowest '2' in each to replace with '1'.
  """
  h, w = len(grid), len(grid[0])
  for j in range(w):
    lowest_two = None
    for i in range(h - 1, -1, -1):
      if grid[i][j] == 2:
        lowest_two = (i, j)
        break
    if lowest_two:
      grid = fill(grid, 1, {lowest_two})
  return grid
 
0.2638888888888889, 3.711724, def afbaafgchafbedjibihidgddadeebabb(grid):
  """
  Extract columns as objects, modify those containing '2', and reconstruct the grid.
  """
  return dmirror(tuple(tuple(1 if j == len(col) - 1 and 2 in col else v 
                          for j, v in enumerate(col)) 
                   for col in dmirror(grid)))
 
0.06840277777777778, 2.5670068, def baibfgbcjebgejfeidebebabdaceceid(grid):
  """
  Use object detection, filter objects containing '2', identify the lowest cell, and modify the grid. 
  """
  objs = objects(grid, False, False, False)
  for obj in objs:
    if any(v == 2 for v, _ in obj):
      lowest_i = max(i for v, (i, j) in obj)
      target_cell = next((i, j) for v, (i, j) in obj if i == lowest_i and v == 2)
      grid = fill(grid, 1, {target_cell})
  return grid
 
0.12708333333333333, 2.7481093, def aedajdiehbecebahbaifcbfhecggeacc(I):
  objs = objects(I, T, F, F) # Extract all objects
  smallest_obj = argmin(objs, size) # Find the smallest object
  corner_index = lrcorner(smallest_obj) # Get lower-right corner index
  shifted_index = add(corner_index, (-1, 0)) # Shift one row up
  target_indices = {corner_index, shifted_index} # Combine indices
  O = fill(I, ONE, target_indices)  # Fill with '1'
  return O
 
0.17986111111111108, 3.4581478, def abefdfjdecfeebhfjeaajeiabbbaaefj(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, lambda obj: (size(obj), lrcorner(obj)[0])) # Sort by size, then uppermost row
  corner = lrcorner(smallest_obj)
  shifted = (corner[0] - 1, corner[1])
  O = fill(I, ONE, {corner, shifted})
  return O
 
0.12395833333333334, 3.029452, def ifgiahcfbcjcedehbcadfeffcgdffddg(I):
  # Identify the object with the least color that is lowest and rightmost
  target_object = argmax(
      sfilter(objects(I, T, T, T), lambda obj: color(obj) == leastcolor(I)),
      lambda obj: lrcorner(obj)[0] * width(I) + lrcorner(obj)[1]
  )

  # Calculate the target cell index
  target_cell = add(llcorner(target_object), (1, 0))

  # Handle edge case where target cell is outside the grid's height
  if target_cell[0] >= height(I):
    target_cell = add(target_cell, (-1, 0))

  # Fill the target cell with 1
  return fill(I, 1, {target_cell})
 
0.14270833333333333, 4.420627, def dccbgehdegbeebaejjibegfdjccgbbgg(I):
  # Identify the rightmost object with the least color
  target_object = argmax(
      colorfilter(objects(I, T, T, T), leastcolor(I)),
      lambda obj: lrcorner(obj)[1] 
  )
  
  # Calculate the target cell index 
  target_cell = add(lrcorner(target_object), (-1, 1))
  
  # Handle edge case when target cell goes beyond grid width
  if target_cell[1] >= width(I):
    target_cell = add(llcorner(target_object), (1, 0))

  # Fill the target cell with 1
  return fill(I, 1, {target_cell})
 
0.12395833333333332, 3.1172113, def gbedabihefbjecefiiaecifadbibddfe(I):
  # Combine objects with the least color into a single patch
  target_patch = mfilter(objects(I, T, T, T), lambda obj: color(obj) == leastcolor(I))

  # Calculate the target cell index
  target_cell = add(llcorner(target_patch), (1, 0))

  # Handle edge case when target cell goes beyond the grid height
  if target_cell[0] >= height(I):
    target_cell = add(lrcorner(target_patch), (-1, 1))
    if target_cell[1] >= width(I):
      target_cell = add(target_cell, (0, -1))

  # Fill the target cell with 1
  return fill(I, 1, {target_cell})
 
0.15520833333333334, 3.6014986, def ecfdaajgbfdeebcfbjigbbibjecdcfhg(I):
  # Get indices of the least common color in the grid
  target_indices = ofcolor(I, leastcolor(I))

  # Calculate the target cell index
  target_cell = add(
      max(target_indices, key=lambda x: x[0] * width(I) + x[1]), 
      (1, 0)
  )

  # Handle edge case when target cell goes beyond grid height
  if target_cell[0] >= height(I):
    target_cell = tuple(map(lambda x: x - 1 if x > 0 else x, target_cell))

  # Fill the target cell with 1
  return fill(I, 1, {target_cell})
 
0.2791666666666666, 3.8226411, def fdeeeagihdfeefeijcgijaibcedbecee(grid):
  return dmirror(
    fill(
      dmirror(grid), 
      1, 
      ofcolor(
        bottomhalf(dmirror(grid)),
        2
      )
    )
  )
 
0.13923611111111112, 2.7785342, def chdefecfgefbecdcicaffhecdehecbda(grid):
  transposed_grid = rot90(grid)
  h = height(transposed_grid)
  return rot270(tuple(tuple(1 if v == 2 and i == h-1 else v for v in row) for i, row in enumerate(transposed_grid)))
 
0.12430555555555556, 2.3162165, def fccheidcedbdefcajiecacadbacchfda(I):
  objs = objects(I, T, F, F) # Extract all objects
  min_size = size(argmin(objs, size)) # Find size of smallest object
  filtered_objs = sfilter(objs, lambda obj: size(obj) == min_size) # Filter objects by size
  target_obj = first(filtered_objs) # Select the first smallest object
  corner_index = lrcorner(target_obj) # Get its bottom-right corner
  shifted_index = (corner_index[0] - 1, corner_index[1]) # Calculate the index above
  target_indices = {corner_index} # Initialize target indices with the corner
  if size(filtered_objs) > 1: # Check if more objects of the same size exist
    target_indices.add(shifted_index) # Add the shifted index if true
  O = fill(I, ONE, target_indices) # Recolor target cells to '1'
  return O
 
0.18263888888888888, 3.4428809, def hiibfbcicjhaedhiacdfjfdeeaedgeje(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, size)
  second_smallest_obj = argmin(sfilter(objs, lambda obj: obj != smallest_obj), size) 
  corner_idx = lrcorner(smallest_obj)
  shifted_idx = (lrcorner(second_smallest_obj)[0] - 1, lrcorner(second_smallest_obj)[1])
  O = fill(I, ONE, {corner_idx, shifted_idx})
  return O
 
0.15486111111111112, 3.2567468, def edidbbbdedfaeaheaeccbidaicehdeia(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, size) # Sort objects by size
  smallest_obj = first(sorted_objs) # Get the smallest object
  corner_idx = lrcorner(smallest_obj) # Find its bottom-right corner
  target_indices = {corner_idx}
  if size(sorted_objs) > 1 and size(smallest_obj) == size(sorted_objs[1]):
    second_smallest_obj = sorted_objs[1]
    shifted_idx = (lrcorner(second_smallest_obj)[0] - 1, lrcorner(second_smallest_obj)[1]) 
    target_indices.add(shifted_idx) 
  O = fill(I, ONE, target_indices) 
  return O
 
0.13923611111111112, 2.7785342, def abdfafdibhacegfebbcdhbbfafdgecbd(I):
  h, w = len(I), len(I[0])
  target_j = max((j for j in range(w) if any(I[i][j] == TWO for i in range(h))), default=None)
  if target_j is not None:
    target_i = max((i for i in range(h) if I[i][target_j] == TWO), default=0)
    I = paint(I, recolor(ONE, initset((target_i, target_j))))
    for i in range(h):
      if I[i][w - 1] == TWO:
        return paint(I, recolor(ONE, initset((i, w - 1))))
  return I
 
0.05277777777777778, 1.5749334, def dfadbceibacjeabeicafhfgabcjeefdf(I):
  # Iterate through rows from bottom to top
  for i in range(len(I)-1, -1, -1):
    # Find the rightmost '2' in the current row
    try:
      j = max([j for j in range(len(I[0])) if I[i][j] == 2])
      I = fill(I, 1, {(i, j)})
      break  # Stop after replacing one '2' in the row
    except ValueError:  # No '2' found in the current row
      continue
  # Check the second to last row for a rightmost '2'
  if len(I) > 1:
    try:
      i = len(I) - 2
      j = max([j for j in range(len(I[0])) if I[i][j] == 2])
      I = fill(I, 1, {(i, j)})
    except ValueError:
      pass
  return I
 
0.06840277777777778, 2.3313103, def bciagedafhfgeffebedahcdjfaggcfjf(I):
    # Get indices of all '2's
    two_indices = ofcolor(I, 2)
    # Find the '2' with the largest row index (lowest)
    max_i = max(two_indices, key=lambda x: x[0])[0]
    target_index = max(
        [index for index in two_indices if index[0] == max_i],
        key=lambda x: x[1]
    )
    # Replace the target '2' with '1'
    return fill(I, 1, {target_index})
 
0.06840277777777778, 1.6848296, def aidabdabccjeeebibcgdfedegabeibcc(grid):
  h = height(grid)
  w = width(grid)
  def update_cell(i, j):
    if grid[i][j] != 2:
      return grid[i][j]
    is_bottom_2 = all(grid[k][j] != 2 for k in range(i + 1, h))
    is_rightmost_2 = j == w - 1 or all(grid[i][k] != 2 for k in range(j + 1, w))
    return 1 if is_bottom_2 and is_rightmost_2 else 2
  return tuple(tuple(update_cell(i, j) for j in range(w)) for i in range(h)) 
 
0.043402777777777776, 1.6553756, def dhbaadeecbabegbaigebfddaedecfghf(I):
  def process_grid(grid):
    objs = objects(grid, T, F, F)
    min_size_obj =  argmin(objs, lambda obj: size(obj) if color(obj) == 2 else float('inf'))
    return lrcorner(min_size_obj) if size(min_size_obj) != float('inf') else (0, 0)

  index_to_replace = process_grid(I)
  O = fill(I, ONE, {index_to_replace})
  return O
 
0.20729166666666665, 2.079382, def ffdffafcaecjeejejdaadjiadbegccfa(I):
  h = height(I)
  target_indices = set()
  for obj in objects(I, T, F, F):
    if lowermost(obj) >= h // 2:  # Consider objects in the bottom half
      target_indices.add((lowermost(obj), rightmost(obj)))
  return paint(I, recolor(1, frozenset(target_indices)))
 
0.20694444444444443, 3.5751715, def bgfgfcbbegjdefiebcfhidcaegahcifg(I):
  h = height(I)
  target_indices = set()
  for i in range(h // 2, h):
    row = I[i]
    for j in range(len(row) - 1, -1, -1):
      if row[j] != mostcolor(I):
        target_indices.add((i, j))
        break
  return paint(I, recolor(1, frozenset(target_indices)))
 
0.1236111111111111, 1.5701984, def jaijfbifiejeefhajjfacadbjcijdabg(I):
  h = height(I)
  return paint(I, recolor(1, frozenset(
      (lowermost(obj), rightmost(obj)) 
      for obj in objects(I, T, F, F) if uppermost(obj) >= h // 2)))
 
0.15520833333333334, 4.069342, def fffeccabdeceeiegadfbaaebibeidfff(I):
  h, w = len(I), len(I[0])
  candidates = []
  for i in range(h-1, 0, -1):  
    for j in range(w-1, 0, -1): 
      if I[i][j] == TWO:
        candidates.append((i, j))
  if candidates:
    target = min(candidates, key=lambda loc: loc[0] * w + loc[1])  # Prioritize bottom-right
    return paint(I, recolor(ONE, initset(target)))
  return I
 
0.14270833333333333, 3.772527, def dbafbgdfjaacejgaafbhaedgjafcedjf(I):
  # Transpose the grid
  transposed_grid = dmirror(I)
  # Find the rightmost '2' in the transposed grid 
  target_j = max([j for i, row in enumerate(transposed_grid) for j, val in enumerate(row) if val == 2], default=0)
  # Find the lowest row containing the rightmost '2' in the transposed grid
  target_i = max([i for i, row in enumerate(transposed_grid) for j, val in enumerate(row) if val == 2 and j == target_j], default=0)
  # Transpose the grid back
  I = dmirror(transposed_grid)
  # Replace the '2' with '1'
  return fill(I, 1, {(target_i, target_j)})
 
0.21076388888888886, 4.5580053, def iceebieedfajeifciejjfcchafegfffd(I):
  objs = objects(I, T, F, F) # Extract all objects
  for obj in objs:
    if size(obj) > 1: # Only consider objects with more than one cell
      corner_index = lrcorner(obj) # Find the bottom-right corner
      O = fill(I, ONE, {corner_index}) # Fill the corner with '1'
  return O 
 
0.29444444444444445, 5.271869, def egfbfaffagdfeajfaacehdbbafdfhbih(I):
  objs = objects(I, T, F, F)
  target_indices = {lrcorner(obj) for obj in objs if size(obj)>1}
  O = fill(I, ONE, target_indices)
  return O
 
0.1673611111111111, 4.468107, def baacfaeeejahegciaafddeccedfbeach(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if i+1 < len(I) and j+1 < len(I[0]) and I[i][j] == I[i+1][j] == I[i][j+1] == I[i+1][j+1]:
        O = fill(O, ONE, {(i+1, j+1)})
  return O
 
0.1829861111111111, 4.3241568, def achcbaddadhbeedgjdebagefabdbeahc(I):
  O = I
  for i in range(len(I)-1, 0, -1):
    for j in range(len(I[0])-1, 0, -1):
      if I[i][j] != mostcommon(I) and I[i][j] == I[i-1][j] and I[i][j] == I[i][j-1]:
        O = fill(O, ONE, {(i, j)})
        break
    else:
      continue
    break
  return O
 
0.2913194444444444, 3.172907, def accdhdcbjefeejfdiidddhfheiddbdbb(I):
  h, w = len(I), len(I[0])
  target_cells = {(h - 1, 0)} # Initialize with the bottom-left corner
  for obj in objects(I, T, F, F): # Iterate through objects
    target_cells.add((lowermost(obj), rightmost(obj))) # Add each object's bottom-rightmost cell 
  return paint(I, recolor(1, frozenset(target_cells))) # Recolor all identified cells
 
0.17986111111111108, 2.9676461, def fedieheagabdeafbaecdbcdbafjbbfci(I):
  h = height(I)
  target_cells = {(h-1, 0)}  # Start with the bottom-left corner
  for j in range(len(I[0])):  # Iterate through columns
    if I[h-1][j] != mostcommon(I[h-1]):  # Check for non-most-common value in the bottom row
      target_cells.add((h-1, j)) # Add the cell to the target set
      break 
  for obj in objects(I, T, F, F): # Check each object
    rightmost_j = rightmost(obj) # Find the rightmost column of the object
    if I[h-1][rightmost_j] != mostcommon(I[h-1]): # If the cell at the bottom row and the object's rightmost column is not the most common
      target_cells.add((lowermost(obj), rightmost_j)) # Add the bottom-rightmost cell of that object to the target
  return paint(I, recolor(1, frozenset(target_cells))) # Recolor all target cells
 
0.17986111111111108, 2.558497, def iaeddacjccbeebaibhchffbbiaaeafdc(I):
  h = height(I)
  w = width(I)
  target_cells = set()
  for obj in objects(I, T, F, F):
    bottom_row = {(i, j) for i, j in toindices(obj) if i == h - 1}
    if bottom_row:
      target_cells.add(tuple(max(bottom_row, key=lambda x: x[1])))
  if I[h-1][0] != mostcommon(I[h-1]):
    target_cells.add((h-1, 0))
  return paint(I, recolor(1, frozenset(target_cells))) 
 
0.1798611111111111, 2.5488, def ggbbgfifeffjecjhjdaedjfdfagaciai(I):
  h, w = height(I), width(I)
  target = {(h - 1, 0)} # Add bottom left corner by default
  for obj in objects(I, T, F, F):
    rightmost_j = rightmost(obj)
    if rightmost_j > 0 and any(I[i][rightmost_j] != mostcommon(I[i]) for i in range(h)):
      target.add((lowermost(obj), rightmost_j))
  return paint(I, recolor(1, frozenset(target)))
 
0.23229166666666667, 2.351108, def hchjfcehjaajehbfbeebdfeceegdhcad(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_obj = extract(objs, lambda obj: color(obj) == TWO and rightmost(toindices(obj)) == max(rightmost(toindices(o)) for o in objs))
  return paint(I, recolor(ONE, toindices(target_obj)))
 
0.4465277777777778, 3.1852994, def cdcjfabieegfefceifedceeedbhajhgd(I):
  tr = lambda x: rot90(rot90(x))
  I = tr(I)
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_obj = extract(objs, lambda obj: color(obj) == TWO and lowermost(toindices(obj)) == max(lowermost(toindices(o)) for o in objs))
  return tr(paint(I, recolor(ONE, toindices(target_obj))))
 
0.1954861111111111, 2.974315, def dfiififaebbheigejhdfcbaeibcdcced(grid):
  return rot270(tuple(
    tuple(
      1 if v == 2 and i == 0 else v
      for j, v in enumerate(row)
    ) for i, row in enumerate(rot90(grid))
  ))
 
0.12743055555555555, 3.2826567, def cecaeegdbbcieddajdijadfhefcabdfd(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, size)
  if height(smallest_obj) > 1:
    target_index = lrcorner(smallest_obj)
  else:
    target_index = (lowermost(smallest_obj), rightmost(smallest_obj) - 1)
  O = fill(I, ONE, {target_index})
  return O
 
0.15520833333333334, 3.7974176, def ddheifeeiefhededbffiiadijjgjcaja(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, size)
  c = lrcorner(smallest_obj)
  O = fill(I, ONE, {(c[0] - (width(smallest_obj) == 1), c[1])})
  return O
 
0.12708333333333333, 4.7121778, def fbajfagcefebedjhidajbcbjcbaaiigb(I):
  h = height(I) // 2
  return paint(I, recolor(1, mfilter(objects(I, T, F, F), lambda obj: uppermost(obj) >= h and (lowermost(obj), rightmost(obj)) in obj)))
 
0.1951388888888889, 3.3125682, def adfafefgaaceeahbaedcidcagbdhjbbc(I):
  h = height(I) // 2
  return paint(I, recolor(1, frozenset(
      (i, max(j for j in range(len(I[0])) if I[i][j] != mostcommon(I))) 
      for i in range(h, len(I)) 
      if any(I[i][j] != mostcommon(I) for j in range(len(I[0])))
  )))
 
0.12708333333333333, 4.7121778, def cjjgciffhedcedbgjedcedhdbbbbdcce(grid):
  objs = objects(grid, False, False, False)
  def is_bottom_two(obj):
    return color(obj) == 2 and all(index(grid, (i + 1, ulcorner(obj)[1])) != 2 for i in range(ulcorner(obj)[0], height(grid) - 1))
  bottom_twos =  sfilter(objs, is_bottom_two)
  return paint(grid, recolor(1, merge(bottom_twos)))
 
0.17638888888888887, 2.4862826, def febabccdhfgbefeijcccdejiaedeeaef(I):
  h = height(I) // 2 # Midpoint height
  objs = objects(I, T, F, F) # All objects
  bottom_objs = sfilter(objs, lambda obj: uppermost(obj) >= h) # Filter bottom half objects
  target_cells = mfilter(bottom_objs, lambda obj: (lowermost(obj), rightmost(obj))) # Get lower-rightmost cells
  return paint(I, recolor(1, target_cells)) # Recolor and paint
 
0.09895833333333333, 2.678168, def iagcfjeddjfjeefejdhdbibbdicehgib(I):
  h = height(I) // 2
  target_cells = frozenset()
  for j in range(width(I)):
    for i in range(h, height(I)):
      if I[i][j] != mostcommon(I) and (j == width(I) - 1 or I[i][j + 1] == mostcommon(I)):
        target_cells = insert((i, j), target_cells)
        break
  return paint(I, recolor(1, target_cells))
 
0.21076388888888886, 4.22451, def gifciefejbbfecfcaeaaifaecaafdjag(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_obj = argmax(objs, lambda obj: (lrcorner(obj)[0] + lrcorner(obj)[1], -lrcorner(obj)[0]))
  return paint(I, recolor(ONE, initset(lrcorner(toindices(target_obj)))))
 
0.21076388888888886, 4.6342645, def hejfecbaggdeeeehjbccafhfhdeagaja(I):
  h, w = len(I), len(I[0])
  if h > 1 and w > 1:
    quadrants = (
      crop(I, (0, 0), (h//2, w//2)),
      crop(I, (0, w//2), (h//2, w-w//2)),
      crop(I, (h//2, 0), (h-h//2, w//2)),
      crop(I, (h//2, w//2), (h-h//2, w-w//2))
    )
    for i, quadrant in enumerate(quadrants):
      for j in range(len(quadrant)-1, -1, -1):
        for k in range(len(quadrant[0])-1, -1, -1):
          if quadrant[j][k] == TWO:
            return paint(I, recolor(ONE, initset(((i//2)*(h//2) + j, (i%2)*(w//2) + k))))
  else:
    for j in range(h-1, -1, -1):
      for k in range(w-1, -1, -1):
        if I[j][k] == TWO:
          return paint(I, recolor(ONE, initset((j, k))))
  return I
 
0.21076388888888886, 4.5218387, def hiadcfbbdfaheigaiffdgebgfidfdege(I):
  def replace_first_two(grid):
    for i, row in enumerate(grid):
      for j, val in enumerate(row):
        if val == 2:
          return tuple(tuple(1 if (r, c) == (i, j) else grid[r][c] for c in range(len(row))) for r in range(len(grid)))
    return grid
  return replace_first_two(I)
 
0.05590277777777777, 2.398648, def ebiagefbfaefececahjgcebdehhfeebe(I):
  objs = objects(I, T, F, F) # Extract all objects
  twos = sfilter(objs, lambda obj: color(obj) == TWO) # Filter for objects made of '2'
  smallest_two = argmin(twos, size) # Find the smallest '2'-object
  target_indices = {lrcorner(smallest_two)} # Start with bottom-right corner
  for obj in twos: 
    if obj != smallest_two and lrcorner(obj)[0] == lrcorner(smallest_two)[0]: # If another '2'-object shares the same row as the smallest
      target_indices.add(lrcorner(obj)) # Target its bottom-right corner as well
  O = fill(I, ONE, target_indices)  # Fill the target indices with '1'
  return O
 
0.06840277777777778, 2.3198798, def hfcceeggfcefehceafdcccegdjcbfdab(I):
  objs = objects(I, T, F, F)
  twos = sfilter(objs, lambda obj: color(obj) == TWO)
  smallest_two = argmin(twos, size)
  target_idx = lrcorner(smallest_two)
  for obj in twos:
    if obj != smallest_two and hmatching(obj, smallest_two): # Check for horizontal matching
      target_idx = (target_idx[0], llcorner(obj)[1]) # Target bottom-left corner of matching object
      break 
  O = fill(I, ONE, {target_idx})
  return O
 
0.05590277777777777, 2.3121254, def ghaehfafjcafeaabbdccebgfacgddecd(I):
  objs = objects(I, T, F, F)
  twos = sfilter(objs, lambda obj: color(obj) == TWO)
  smallest_two = argmin(twos, size)
  target_indices = {lrcorner(smallest_two), llcorner(smallest_two)}  # Start with both corners as potential targets
  for obj in twos:
    if obj != smallest_two and hmatching(obj, smallest_two):
      target_indices.remove(lrcorner(smallest_two))  # Remove the right corner if a matching object is found
      break
  O = fill(I, ONE, target_indices)
  return O
 
0.21041666666666664, 4.1708946, def acedececaaffegicjebfjgcacddeccde(I):
  objs = objects(I, T, F, T)  # Find non-background objects
  min_obj = argmin(objs, size)  # Find the smallest object
  if hline(min_obj) or vline(min_obj): # If horizontal/vertical line 
    target_cells = frozenset({(lowermost(min_obj), j) for j in range(leftmost(min_obj), rightmost(min_obj) + 1)}) # All cells in the line
  else:
    target_cells = frozenset({(lowermost(min_obj), rightmost(min_obj))})  # Rightmost cell
  bottom_row = {(len(I)-1, j) for j in range(len(I[0]))} # All cells in the bottom row
  filtered_cells = target_cells & bottom_row #Intersection of target_cells and bottom_row
  return paint(I, recolor(1, filtered_cells))  # Recolor target cell(s)
 
0.21076388888888886, 4.190081, def ebbejdefiiefegbfjhfdfcfadbeafcdf(I):
  objs = objects(I, T, F, T)
  min_obj = argmin(objs, size)
  target_cell = (lowermost(min_obj), rightmost(min_obj))
  if target_cell[0] == len(I) - 1:
    return paint(I, recolor(1, initset(target_cell)))
  else:
    bottom_target = (len(I) - 1, target_cell[1])
    return paint(I, recolor(1, initset(bottom_target)))
 
0.21076388888888886, 4.367735, def fdedaajicdceeehebdhabfebdahbfagf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Extract all objects
  target_obj = argmax(objs, lambda obj: (rightmost(toindices(obj)), -uppermost(toindices(obj)))) # Find the rightmost object, breaking ties by choosing the topmost one
  return paint(I, recolor(ONE, initset((lowermost(toindices(target_obj)), rightmost(toindices(target_obj)))))) # Recolor the bottom-right cell of the target object 
 
0.09895833333333333, 2.800158, def eegahideecageiiabfcfgggbhcefbjfg(I):
  for j in range(len(I[0])-1, -1, -1): # Iterate columns from right to left
    for i in range(len(I)): # Iterate rows from top to bottom
      if I[i][j] == TWO: 
        return paint(I, recolor(ONE, initset((i, j)))) # Recolor the first encountered '2' cell (rightmost and topmost) and return the grid
  return I # Return the original grid if no '2' is found
 
0.09895833333333333, 2.678168, def aihfcicfeehfeegdijeeiaebjddbacji(I):
  return paint(I, recolor(ONE, initset(extract(asobject(I), lambda x: x[0] == TWO and x[1][1] == max(j for v, (i, j) in asobject(I) if v == TWO))[1]))) # Convert to object, find rightmost 2, recolor to 1, paint back
 
0.37430555555555556, 3.852007, def gbggcdcjfccbeacejeeccfbaebfddbcd(I):
    min_size = size(argmin(objects(I, T, F, T), size)) # Find size of smallest non-background object
    filtered_objs = sizefilter(objects(I, T, F, F), min_size) # Filter objects by the minimum size
    corner_indices = apply(lrcorner, filtered_objs) # Get lower-right corners of all filtered objects
    shifted_indices = apply(lambda idx: (idx[0]-1, idx[1]), corner_indices) # Get indices above the corners
    O = fill(I, ONE, corner_indices | shifted_indices) # Fill both corner and shifted indices with '1'
    return O
 
0.040625, 1.7580044, def agfaehecdbdceffijjfbdfaejbhdcehc(I):
  def bottom_left_index(obj):
    return (lowermost(obj), leftmost(obj))
  
  objs = objects(I, T, F, T) 
  smallest_obj = min(objs, key=size)  # Find smallest object without secondary sorting
  O = fill(I, 1, {bottom_left_index(smallest_obj)}) 
  return O
 
0.06840277777777778, 2.3313103, def hdeeecfcaceaegfciiefcfghabdeggdc(I):
  min_obj = argmin(objects(I, T, F, T), size) # Find smallest object.
  if bordering(min_obj, I):
    return I # Do nothing if smallest object is at the border.
  else:
    most_color = mostcommon([v for v, _ in asobject(I)]) # Find the most frequent color.
    return paint(I, recolor(most_color, toindices(min_obj))) # Recolor smallest object.
 
0.040625, 1.7580044, def jghabafchfccegfeabaaaaeaeffhefbb(I):
  # Find the smallest object excluding the background
  objs = objects(I, T, F, T)
  smallest_obj = argmin(objs, size)
  # Recolor the smallest object to 1
  O = paint(I, recolor(ONE, smallest_obj))
  return O
 
0.12395833333333334, 2.8960538, def abccffajjeecefaaiageefcbiidgaddb(I):
  # Find the smallest object's color
  min_color = color(argmin(objects(I, T, F, T), size))
  # Replace the smallest object's color with 1
  O = replace(I, min_color, ONE)
  return O
 
0.10868055555555554, 2.2168083, def dfdahecgeheeejfbajbcjfdjaaabbjcf(I):
  objs = objects(I, True, False, False)  # Extract all objects from the grid
  for obj in objs:
    if color(obj) == TWO:  # Focus on objects made of '2'
      rightmost_j = rightmost(obj)  # Find the rightmost column index
      target_cell = argmax(obj, lambda x: x[1][0] if x[1][1] == rightmost_j else -1)  # Get bottom-most cell in the rightmost column
      I = paint(I, recolor(ONE, initset(target_cell[1])))  # Recolor and paint back
  return I
 
0.04027777777777777, 1.6668012, def dhaefegaedcbebhaiahhjbdhbedafabe(I):
  h, w = len(I), len(I[0])
  for j in range(w-1, -1, -1): # Iterate columns from right to left
    for i in range(h): # Iterate through rows
      if I[i][j] == TWO: 
        I = paint(I, recolor(ONE, initset((i, j)))) # Replace the '2'
        break # Move to the next column after replacement
    else: # This block executes if the loop completes without finding a '2' in the current column
      continue # Continue to the next column
    break # Exit the outer loop after a replacement
  return I
 
0.06527777777777777, 1.8169068, def dfddjjhajgecececjidbeedagcdjbcfa(I):
  objs = objects(I, T, F, F) # Extract all objects 
  twos = sfilter(objs, lambda obj: color(obj) == TWO) # Filter for objects of color '2'
  bottom_right = lambda obj: lrcorner(toindices(obj)) # Function to get bottom-right corner
  target_obj = argmax(twos, bottom_right) # Get the '2' object with the bottom-right most corner
  corner = lrcorner(target_obj) # Get the corner index
  O = fill(I, ONE, {corner})  # Replace the corner cell with '1'
  return O
 
0.12083333333333332, 2.5151403, def bcabaedabacdeghbbeefhhbbbcbeagbf(I):
  def bottom_obj(grid): # Function to find the bottom-most object of a given color
    objs = objects(grid, T, F, F)
    return argmax(objs, lambda obj: lrcorner(toindices(obj))[0] if color(obj) == 2 else -1)
  
  target_obj = bottom_obj(I)  # Get the bottom-most '2' object
  corner = lrcorner(target_obj) # Get its bottom-right corner
  O = fill(I, ONE, {corner})  # Replace the corner with '1'
  return O 
 
0.040625, 1.7580044, def gbdgbeidefiaeedcafeicfbfaiiecgbh(I):
  smallest_obj = argmin(objects(I, T, F, T), size) # Find the smallest object.
  i, j = lrcorner(smallest_obj) # Find the bottom-right corner of the smallest object.
  O = paint(I, {(1, (i, j))}) # Paint the bottom-right corner with '1'.
  return O
 
0.04027777777777777, 1.3619275, def ecfdebdcegjeebbeibaiaegcecedjacg(I):
  # 1. Get all objects and their sizes as tuples
  obj_sizes = apply(lambda obj: (obj, size(obj)), objects(I, T, F, T))
  # 2. Find the object with the minimum size using a lambda function
  min_obj = argmin(obj_sizes, lambda x: x[1])[0]
  # 3. Recolor and paint the object with minimum size
  O = paint(I, recolor(ONE, min_obj))
  return O
 
0.06840277777777778, 2.3313103, def ebhfdbidajbaedjhajfffjecfjaddbcj(I):
  # 1. Initialize an empty set to store objects
  objs = initset(()) 
  # 2. Iterate through all unique colors in the grid
  for c in palette(I):
    # 3. Add objects of the current color to the set
    objs = combine(objs, objects(I, T, F, T))
  # 4. Find the smallest object in the set
  smallest_obj = argmin(objs, size)
  # 5. Recolor and paint the smallest object
  O = paint(I, recolor(ONE, smallest_obj))
  return O
 
0.19513888888888886, 3.3688378, def ijjedecfdcfeeccbieaffdffbbigface(I):
    def rightmost_obj(grid):
        objs = objects(grid, T, F, F)
        return argmax(objs, lambda obj: lrcorner(toindices(obj))[1]) # Find the rightmost object

    target_obj = rightmost_obj(I) # Get the rightmost object
    corner = lrcorner(target_obj) # Get its bottom right corner
    O = fill(I, ONE, {corner})  # Replace the corner with a '1'

    if height(I) > 2:  # For grids taller than 2 rows
        isolated_ones = objects(O, T, F, T) # Find '1' objects excluding background
        if len(isolated_ones) > 0:
            O = fill(O, TWO, toindices(first(isolated_ones)))  # Replace isolated '1' with '2'

    return O
 
0.12708333333333333, 4.7121778, def daebbcbeabijejabbeicbfifidbifffi(I):
    def rightmost_two(grid):
        twos = sfilter(objects(grid, T, F, F), lambda obj: color(obj) == TWO) # Filter objects by color '2'
        return argmax(twos, lambda obj: lrcorner(toindices(obj))[1]) # Find the rightmost '2' object

    O = I  # Initialize output as input
    target_obj = rightmost_two(I) # Get the rightmost '2' object
    if target_obj: # If a rightmost '2' object exists
        corner = lrcorner(target_obj)  # Get its bottom right corner
        O = fill(I, ONE, {corner})  # Replace the corner with a '1'

    if height(I) > 2 and colorcount(I, ONE) == 1:  # For Input_2 specific case
        O = replace(O, ONE, TWO)  # Replace the single '1' with a '2'
    return O
 
0.17048611111111112, 4.5804157, def fdcefhgjdbjfebahiaejcaccdbeeccga(I):
    def process_twos(grid):
        objs = objects(grid, T, F, F)
        for obj in objs:
            if color(obj) == TWO:
                corner = lrcorner(obj)
                grid = fill(grid, ONE, {corner}) # Fill the corner of each '2' object
        return grid

    O = process_twos(I)  # Process all '2' objects
    if height(I) > 2 and colorcount(I, ONE) == 1: # Specific handling for Input_2
        O = replace(O, ONE, TWO)  
    return O
 
0.06840277777777778, 2.3313103, def dddfadjafjfhedegaigfdddagfdccdha(I):
  def bottom_left_index(obj):
    return (lowermost(obj), leftmost(obj)) 

  objs = fgpartition(I) 
  target_index = bottom_left_index(min(objs, key=size))
  O = fill(I, 1, {target_index}) 
  return O
 
0.3878472222222222, 3.1863227, def fabfbccagaibejcbbbceabbgcidffeja(I):
  def rightmost_criteria(obj):
    return (-size(obj), rightmost(obj)) # Prioritize smallest, then rightmost
  objs = objects(I, T, F, T)
  target_obj = argmin(objs, rightmost_criteria)
  return paint(I, recolor(ONE, target_obj)) 
 
0.15208333333333332, 3.5042267, def fdaecdgbgcecebhajiiebibfdbadagce(I):
  objs = objects(I, True, False, False) # Extract all objects from the grid
  flag = False
  for obj in objs:
    if color(obj) == TWO:  # Focus on objects made of '2'
      for i in range(height(obj)):
        row = {(v, (row_index, col_index)) for v, (row_index, col_index) in obj if row_index == i}
        if len(row) > 1:
          rightmost_two = argmax(row, lambda x: x[1][1])
          left_indices = frozenset(j for v, (i, j) in row if j < rightmost_two[1][1])
          if len(left_indices) > 0 and index(I, (i, rightmost_two[1][1] - 1)) == 2:
            I = paint(I, recolor(ONE, initset(rightmost_two[1])))  # Recolor and paint back
            flag = True
            break
      if flag:
        break
  if not flag:
    for obj in objs:
      if color(obj) == TWO:  # Focus on objects made of '2'
        rightmost_j = rightmost(obj)  # Find the rightmost column index
        target_cell = argmax(obj, lambda x: x[1][0] if x[1][1] == rightmost_j else -1)  # Get bottom-most cell in the rightmost column
        I = paint(I, recolor(ONE, initset(target_cell[1])))  # Recolor and paint back
        break  
  return I
 
0.15208333333333332, 4.5933833, def gichbfddcaaaebdfahfbcaccahjaeadg(I):
  objs = objects(I, True, False, False)  # Extract all objects from the grid
  flag = False
  for obj in objs:
    if color(obj) == TWO:  # Focus on objects made of '2'
      for i, j in toindices(obj):
        if j > 0 and index(I, (i, j-1)) == 2 and (i, j) in toindices(obj):
          I = paint(I, recolor(ONE, initset((i, j))))  # Recolor and paint back
          flag = True
          break
      if flag:
        break
  if not flag:
    for obj in objs:
      if color(obj) == TWO:  # Focus on objects made of '2'
        rightmost_j = rightmost(obj)  # Find the rightmost column index
        target_cell = argmax(obj, lambda x: x[1][0] if x[1][1] == rightmost_j else -1)  # Get bottom-most cell in the rightmost column
        I = paint(I, recolor(ONE, initset(target_cell[1])))  # Recolor and paint back
        break  
  return I
 
0.06840277777777778, 2.3313103, def ibdaeibhbbadehbjbjeigddbhbbaefjc(I):
  objs = objects(I, T, F, F) # Identify all objects in the grid
  twos = sfilter(objs, lambda obj: color(obj) == TWO) # Filter for objects made of '2'
  if len(twos) > 0: # If there's a '2' object
    target_obj = argmin(twos, size) # Select the smallest '2' object
    corner = lrcorner(target_obj) # Find its bottom right corner
    if I[corner[0]][corner[1]] != TWO: # If the corner isn't already '2'
      I = fill(I, ONE, {corner}) # Change the corner to '1'
  return I
 
0.11180555555555555, 2.5689406, def fahjgigfccjceeeibcdgchbbafedcaae(I):
  def modify_twos(grid):
    objs = objects(grid, T, F, F)
    for obj in objs:
      if color(obj) == TWO:
        corner = lrcorner(obj)
        if grid[corner[0]][corner[1]] != TWO: 
          grid = fill(grid, ONE, {corner})
    return grid
  
  return modify_twos(I)
 
0.2857638888888889, 4.3303704, def ffjacecfgihdedfaieicaceibdbhhdcg(I):
  def check_and_fill(grid, i, j):
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == TWO:
      if i+1 == len(grid) or j+1 == len(grid[0]) or grid[i+1][j] != TWO or grid[i][j+1] != TWO:
        return fill(grid, ONE, {(i,j)})
    return grid
  
  for i in range(len(I)):
    for j in range(len(I[0])):
      I = check_and_fill(I, i, j)
  return I 
 
0.15208333333333332, 2.5944753, def aadfcdgbcfcdeaiciahbffcbfbfaaeia(I):
  changed = False # Flag to track changes
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == TWO and not changed: # If a '2' is found and no changes have been made yet
        if (i+1 == len(I) or I[i+1][j] != TWO) and (j+1 == len(I[0]) or I[i][j+1] != TWO):
          I = fill(I, ONE, {(i,j)}) # Change to '1'
          changed = True # Mark that a change has been made 
  return I
 
0.053125, 1.8383785, def ebfcbfebfeajegahifccaeejafcghhca(I):
  # 1. Get all objects, excluding background
  objs = objects(I, T, F, T)
  # 2. Define a custom function to find the target cell index
  def get_target_index(obj):
    bottom_right = lrcorner(obj)
    return next(((v, (i, j)) for v, (i, j) in obj if i == bottom_right[0] and j == bottom_right[1]), None)
  # 3. Apply the function to each object, filter for non-None results, and extract the first
  target_cell = extract(apply(get_target_index, objs), lambda x: x is not None)
  # 4. Paint the target cell with color '1' on the input grid
  O = paint(I, {(ONE, target_cell[1])})
  return O
 
0.04027777777777777, 1.1789566, def caadjedfebbjecdabafdaeaadbdidihd(I):
  # 1. Sort objects by size
  sorted_objs = order(objects(I, T, F, T), size)
  # 2. Iterate through objects from smallest to largest
  for obj in sorted_objs:
    # 3. Find the rightmost bottommost cell
    target_cell = lrcorner(obj)
    # 4. Check if the target cell's color is not 1
    if index(I, target_cell) != ONE:
      # 5. Paint the target cell with color '1'
      return paint(I, {(ONE, target_cell)})
  # 6. If all target cells are already '1', return the original grid
  return I 
 
0.04027777777777777, 1.6668012, def ebibcgegbdefeddebafebejdfigbafid(I):
  def rightmost_two(grid):
    """Finds the rightmost occurrence of the value '2' in a grid."""
    for j in range(len(grid[0])-1, -1, -1): # Iterate columns from right to left
      for i in range(len(grid)): # Iterate rows
        if grid[i][j] == TWO:
          return (i, j)
  loc = rightmost_two(I) # Find the location of the rightmost '2'
  if loc is not None: # If '2' is found
    O = fill(I, ONE, {loc})  # Replace the '2' with '1'
  else:
    O = I
  return O
 
0.05590277777777777, 1.758824, def eaiddhddghefeefcaebgfijafbdabech(I):
  objs = objects(I, T, F, F) # Get all objects in the grid
  target_obj = argmax(objs, lambda obj: rightmost(obj)) # Find object with rightmost cell
  if color(target_obj) == TWO: # If the object's color is '2'
    corner = (lowermost(target_obj), rightmost(target_obj))  # Get its bottom-right corner
    O = fill(I, ONE, {corner})  # Replace the corner with '1'
  else:
    O = I
  return O
 
0.15208333333333332, 3.337541, def edgdidaccaedeadjjjaiebgdaajibibe(I):
  def cell_priority(cell):
    i, j = cell
    return (I[i][j], -j)  # Prioritize by value then rightmost column
  h, w = len(I), len(I[0])
  target_cell = argmin(((i, j) for i in range(h) for j in range(w)), cell_priority)
  O = paint(I, {(1, target_cell)})
  return O
 
0.10868055555555554, 2.931605, def acdigfbidgbbejccbidififacfdfebag(I):
  def rightmost_2_index(obj):
    return argmax(toindices(obj), lambda x: x[1]) # Find rightmost index in object
  
  objs = objects(I, True, False, False) # Get connected objects
  for obj in objs:
    if color(obj) == 2: # Check if object is made of '2'
      rightmost_index = rightmost_2_index(obj) 
      I = paint(I, recolor(1, frozenset({rightmost_index}))) # Change rightmost '2' to '1'
  return I
 
0.10868055555555554, 2.6946032, def chbagadgjbajedehbfjbfagdbceafcee(I):
  def rightmost_cell(obj):
    return max(obj, key=lambda x: x[1][1])  # Find the rightmost cell

  objs = objects(I, True, False, False) 
  for obj in objs:
    if color(obj) == 2:
      rightmost = rightmost_cell(obj) 
      I = paint(I, recolor(1, frozenset({rightmost[1]}))) # Change rightmost '2' to '1'
  return I
 
0.15208333333333332, 3.5042267, def bddiddchfaaeebjdicbbacjfaebfjhjj(I):
  return branch(
      any(TWO in row for row in I),
      paint(I, {(ONE, next((i, j) for i in range(len(I)) for j in range(len(I[0])-1, -1, -1) if I[i][j] == TWO))}),
      I
  )
 
0.15208333333333332, 3.457023, def efajjjfbecebeccdbefehbfabdfefcgb(I):
  def find_and_replace(grid, target, replacement):
    h, w = len(grid), len(grid[0])
    for j in range(w):
      for i in range(h):
        if grid[i][j] == target:
          return paint(grid, recolor(replacement, initset((i, j))))
    return grid

  return find_and_replace(I, 2, 1)
 
0.10868055555555554, 2.2168083, def idbadabdcbccecdgahjicbcibdjdeeig(I):
  def bottom_right_two(obj):
    """Finds the bottom-right '2' in an object."""
    return argmax(obj, lambda cell: cell[1][1] + cell[1][0] if cell[0] == TWO else -1)

  for obj in objects(I, T, F, F):
    if color(obj) == TWO: 
      loc = bottom_right_two(obj)
      if loc is not None:
        I = paint(cover(I, {loc[1]}), {(ONE, loc[1])})
  return I
 
0.10868055555555554, 2.786661, def igdadcdbbgfeeeddaecidfciafcdbbje(I):
  def rightmost_in_row(grid, row):
    """Finds the rightmost '2' in a specific row."""
    for j in range(len(grid[0]) - 1, -1, -1):
      if grid[row][j] == TWO:
        return (row, j)
    return None

  for obj in objects(I, T, F, F):
    if color(obj) == TWO:
      bottom_row = lowermost(obj)
      loc = rightmost_in_row(I, bottom_row)
      if loc is not None:
        I = paint(cover(I, {loc}), {(ONE, loc)})
  return I
 
0.0125, 0.80119765, def ababbedcdibcecbeiedidbciccficeih(I):
  for i in range(len(I) - 1, -1, -1):  # Iterate rows from bottom to top
    for j in range(len(I[0]) - 1, -1, -1):  # Iterate columns from right to left
      if I[i][j] == TWO and {(TWO, (i, j))} in objects(I, T, F, F):
        return paint(cover(I, {(i, j)}), {(ONE, (i, j))})
  return I 
 
0.15208333333333332, 3.457023, def gefadffffbaceacijbcachicddadbdjd(I):
  def is_bottom_right(grid, i, j):
    """Checks if a cell is the bottom-right '2' of an object."""
    if grid[i][j] != TWO:
      return False
    for x in range(i + 1):
      for y in range(j + 1):
        if grid[x][y] == TWO:
          if not (x == i and y == j):
            return False
    return True

  for i in range(len(I)):
    for j in range(len(I[0])):
      if is_bottom_right(I, i, j):
        return paint(cover(I, {(i,j)}), {(ONE, (i, j))})
  return I
 
0.35694444444444445, 13.350496, def adebbigfbbffedjgjcdeefjbhffbaach(I):
  def process_object(obj):
    rightmost_col = max(j for _, (i, j) in obj)
    target_cell = max(((i, j) for _, (i, j) in obj if j == rightmost_col), key=lambda x: x[0])
    return recolor(1, initset(target_cell))

  objs = objects(I, True, False, False)
  modified_objs = frozenset(process_object(obj) if color(obj) == 2 else obj for obj in objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(modified_objs)) 
 
0.24513888888888885, 3.3704975, def ebbaaaicaifbebfgacdccjgcaabdedcb(I):
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        obj = extract(objects(I, True, False, False), lambda o: (i,j) in toindices(o))
        if rightmost(obj) == j: 
          I = paint(I, recolor(1, initset((i, j))))
          break # Move to next row after a replacement in the rightmost column
  return I
 
0.025, 1.1377608, def bgfiabhjegbcebcdbeabbhefdbcihfbc(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True) # Get all objects
  rightmost_two = extract(objs, lambda obj: color(obj) == TWO and rightmost(obj) == max(rightmost(o) for o in objs if color(o) == TWO)) # Find rightmost '2' object
  if len(rightmost_two) == 1: # Check if the object has only one cell
    return paint(I, recolor(ONE, toindices(rightmost_two))) # Replace if isolated
  return I 
 
0.0375, 1.3173668, def bfjcfcbfjjeaeigfaebheebedbhdbegc(I):
  h, w = len(I), len(I[0])
  rightmost_two = (max((i, j) for i in range(h) for j in range(w) if I[i][j] == TWO),) # Get rightmost 2
  if all(I[i][rightmost_two[0][1]] != TWO for i in range(h) if i != rightmost_two[0][0]): # Check if vertically isolated
    return paint(I, recolor(ONE, initset(rightmost_two[0]))) # Paint to 1 if isolated
  return I
 
0.0125, 0.80119765, def idcabchhecbcedceafceehafafheficf(I):
  for j in range(len(I[0])-1, -1, -1): # Iterate columns right to left
    for i in range(len(I)):
      if I[i][j] == TWO: # Found a '2'
        if all(I[k][j] != TWO for k in range(len(I)) if k != i): # Check vertical isolation
          return paint(I, recolor(ONE, initset((i, j)))) # Replace if isolated
        else:
          return I # Don't replace if connected vertically
 
0.1611111111111111, 2.0671706, def dfbfeceaddacecehjaheggafcgdabcec(I):
  two_objects = objects(I, True, False, False)
  bottom_right_two = argmax(two_objects, lambda obj: lrcorner(obj)[0] * 100 + lrcorner(obj)[1] if color(obj) == TWO else -1)
  if bottom_right_two is not None:
    return paint(cover(I, bottom_right_two), recolor(ONE, bottom_right_two))
  return I
 
0.05277777777777778, 1.5749334, def dddadbcadhdceabdigdecfdbdagjfgji(I):
  twos = ofcolor(I, TWO)
  if twos:
    bottom_right = lrcorner(twos)
    return fill(I, ONE, {bottom_right})
  return I
 
0.08402777777777778, 1.7835474, def hjgacbchdccjecahiehacgbbdibcegdc(grid):
  return paint(grid, recolor(ONE, frozenset((i, j) for i, row in enumerate(grid) for j, value in enumerate(row) if value == TWO and all(grid[k][j] != TWO for k in range(len(grid)) if k != i))))
 
0.15208333333333332, 3.222597, def jdfdgdfihhgeeefcbciifaeabdafeicb(I):
  def obj_corner(obj):
    return lrcorner(obj), size(obj) # Return corner and size for sorting

  objs = sorted(objects(I, T, F, F), key=obj_corner) # Sort objects by corner, then size
  for obj in objs:
    if color(obj) == TWO:
      return fill(I, ONE, {lrcorner(obj)})
  return I 
 
