0.055, 2.7772217, def cfcbjcjeedfcecafidebbebgehbdcccc(I):
    # Identify distinct objects with color 4
    x1 = objects(I, T, F, T)
    x2 = colorfilter(x1, FOUR)
    
    # Define function to get inner indices of an object
    def inner_indices(obj):
      return difference(backdrop(obj), box(obj))

    # Apply recoloring based on object's position 
    O = I
    for i, obj in enumerate(x2):
        new_color = 1 if uppermost(obj) < len(I) // 2 else 2 
        O = fill(O, new_color, inner_indices(obj))
    return O
 
0.055, 3.359687, def bedhijbjafdfehedbjabjcbaafhcbece(I):
  # Split grid horizontally
  upper_half = tophalf(I)
  lower_half = bottomhalf(I)

  # Define function to recolor inner area
  def recolor_inner(grid, color):
    obj = first(objects(grid, T, F, T))
    return fill(grid, color, difference(backdrop(obj), box(obj)))

  # Apply recoloring to each half
  new_upper = recolor_inner(upper_half, 1)
  new_lower = recolor_inner(lower_half, 2)

  # Recombine halves
  return vconcat(new_upper, new_lower)
 
0.11499999999999999, 5.22877, def aafgccbeddcceahfieadeeaidagighhj(I):
    # Define function to recolor based on position and size
    def recolor_object(obj):
        if uppermost(obj) < len(I) // 2:
            if width(obj) > height(obj):
                return fill(I, 2, difference(backdrop(obj), box(obj)))
            else:
                return fill(I, 1, difference(backdrop(obj), box(obj)))
        else:
            return fill(I, 1, difference(backdrop(obj), box(obj))) 

    # Identify objects and apply recoloring
    x1 = objects(I, T, F, T)
    x2 = colorfilter(x1, FOUR)
    O = I
    for obj in x2:
        O = recolor_object(obj)
    return O
 
0.245, 14.001059, def ahdhgbccgfcceaadjaeeaagddddaejee(I):
    # Define a function to create a smaller inner patch
    def inner_patch(obj):
        return  difference(
                difference(backdrop(obj), {(uppermost(obj), leftmost(obj)), (lowermost(obj), rightmost(obj))}), 
                {(uppermost(obj), rightmost(obj)), (lowermost(obj), leftmost(obj))}
            )
    
    # Identify objects and apply recoloring
    x1 = objects(I, T, F, T)
    x2 = colorfilter(x1, FOUR)
    O = I
    for i, obj in enumerate(x2):
        new_color = 1 if uppermost(obj) < len(I) // 2 else 2
        O = fill(O, new_color, inner_patch(obj)) 
    return O 
 
0.10500000000000001, 5.031145, def bjejajebicffeaabbcfgcedddafdefhf(I):
    O = I
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == 4:
                # Check if inside the inner area of a '4' object
                if (1 < i < len(I) - 2) and (1 < j < len(row) - 2) and (I[i-1][j] == I[i+1][j] == 4):
                    O = fill(O, 1 if i < len(I) // 2 else 2, {(i, j)})
    return O
 
0.135, 13.358515, def ecibjiijfffiedcbicfdbgffheiajfhi(I):
    # Find the objects and their corners
    objs = objects(I, T, F, T)
    obj1 = first(objs)
    obj2 = last(objs)
    ul1 = ulcorner(obj1)
    ul2 = ulcorner(obj2)
    
    # Modify obj1 - replace center with value 2
    O = fill(I, 2, {(ul1[0] + 2, ul1[1] + 1), (ul1[0] + 2, ul1[1] + 2), (ul1[0] + 3, ul1[1] + 1), (ul1[0] + 3, ul1[1] + 2)})

    # Modify obj2 based on its position relative to obj1
    if ul2[1] > ul1[1]:
        O = fill(O, 1, {(ul2[0] + 1, ul2[1] + 1), (ul2[0] + 1, ul2[1] + 2)})  
    else:
        O = fill(O, 1, {(ul2[0] + 3, ul2[1] + 1), (ul2[0] + 3, ul2[1] + 2)})
    return O
 
0.11499999999999999, 25.916822, def baecidcfeiijedhcibahbdfcacbjacaf(I):
  # Partition the grid into objects
  objs = partition(I)
  
  # Modify objects based on their size
  O = I
  for obj in objs:
    if size(obj) == 16:
      ul = ulcorner(obj)
      O = fill(O, 2, {(ul[0] + 2, ul[1] + 1), (ul[0] + 2, ul[1] + 2), (ul[0] + 3, ul[1] + 1), (ul[0] + 3, ul[1] + 2)})
    elif size(obj) == 8:
      ul = ulcorner(obj)
      if ul[0] == 1:
        O = fill(O, 1, {(ul[0] + 1, ul[1] + 1), (ul[0] + 1, ul[1] + 2)})
      else:
        O = fill(O, 1, {(ul[0] + 3, ul[1] + 1), (ul[0] + 3, ul[1] + 2)})
  return O
 
0.22999999999999998, 26.61484, def bbfbhddicfefeeafibbhiejhcegeecfi(I):
    # Find objects based on color and position
    obj1 = first(objects(I, T, F, T))
    obj2 = first(colorfilter(objects(bottomhalf(I), T, F, T), 4))
    
    # Define modifications for each object
    mod1 = {(2, 1), (2, 2), (3, 1), (3, 2)}
    mod2 = {(1, 1), (1, 2)} if uppermost(obj2) == 1 else {(3, 1), (3, 2)}
    
    # Apply modifications
    O = paint(paint(cover(cover(I, obj1), obj2), shift(recolor(2, mod1), ulcorner(obj1))), shift(recolor(1, mod2), ulcorner(obj2)))
    return O
 
0.13, 4.7540364, def dcjfbjagefceeaefahdeccbhdbheieje(I):
    obj = argmax(objects(I, T, F, T), size)

    # Calculate inner fill boundaries
    left_bound = leftmost(obj) + width(obj)//3
    right_bound = leftmost(obj) + 2 * width(obj)//3 
    
    # Apply inner fill
    O = I
    for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost(obj), rightmost(obj) + 1):
            if left_bound <= j <= right_bound:
                O = fill(O, 1, {(i, j)}) 

    # Apply lower fill
    for j in range(left_bound, right_bound + 1):
        O = fill(O, 2, {(lowermost(obj) + 1, j)})

    return O
 
0.13, 22.863024, def eebhjccaafbeejebbhhiaagadddeecfd(I):
    obj = argmax(objects(I, T, F, T), size) 
    h, w = shape(obj)

    # Define inner and lower fill areas as objects
    inner_fill = {(1, (i, j)) for i in range(uppermost(obj) + 1, lowermost(obj)) for j in range(leftmost(obj) + w//3, leftmost(obj) + 2 * w//3 + (1 if w % 3 else 0))}
    lower_fill = {(2, (lowermost(obj) + 1, j)) for j in range(leftmost(obj) + w//3 - 1, leftmost(obj) + 2 * w//3)}

    O = underpaint(I, inner_fill)
    O = underpaint(O, lower_fill)
    return O
 
0.095, 3.3008032, def gaghdfbdaeeaehiebgfbcdcfcbeedgch(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      i_min = uppermost(obj)
      i_max = lowermost(obj)
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      if i_min < len(I) // 2:
        I = fill(I, 1, frozenset({(i, j_center) for i in range(i_min + 1, i_max)}))
        I = fill(I, 1, frozenset({(i, j_center + 1) for i in range(i_min + 1, i_max)}))
      else:
        I = fill(I, 2, frozenset({(i, j_center) for i in range(i_min, i_max)}))
        I = fill(I, 2, frozenset({(i, j_center + 1) for i in range(i_min, i_max)}))
  return I
 
0.11499999999999999, 3.4337635, def aeejeijjdceieejbbbebjbaecjjcicdc(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)
  
  I = fill(I, 1, connect((uppermost(top_obj) + 1, (leftmost(top_obj) + rightmost(top_obj)) // 2),
                      (lowermost(top_obj) - 1, (leftmost(top_obj) + rightmost(top_obj)) // 2)))
  I = fill(I, 1, connect((uppermost(top_obj) + 1, (leftmost(top_obj) + rightmost(top_obj)) // 2 + 1),
                      (lowermost(top_obj) - 1, (leftmost(top_obj) + rightmost(top_obj)) // 2 + 1)))

  I = fill(I, 2, connect((uppermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2),
                      (lowermost(bottom_obj) , (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2)))
  I = fill(I, 2, connect((uppermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1),
                      (lowermost(bottom_obj) , (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1)))
  return I
 
0.075, 4.4671087, def bedcaafefejeeccfidhdabdgfbdbcbgb(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      for j in range(j_center, j_center + 2):
        for i in range(uppermost(obj) + 1, lowermost(obj)):
          if i < len(I) // 2:
            I = fill(I, 1, frozenset({(i, j)})) 
          else:
            I = fill(I, 2, frozenset({(i, j)})) 
  return I
 
0.12, 22.41944, def ecdcfhcgddcaecjdbacdagafddfhedfa(I):
  for obj in objects(I, T, F, T):
    if size(obj) > 3:
      c = centerofmass(obj)
      if c[0] < len(I) // 2:
        I = paint(I, recolor(1, crop(I, (c[0] - 1, c[1] - 1), (3, 2))))
      else:
        I = paint(I, recolor(2, crop(I, (c[0] - 1, c[1] - 1), (3, 2))))
  return I
 
0.115, 4.9428663, def iciagjibbhiaeacaiacedhadedfadcic(I):
    obj1, obj2 = objects(I, T, F, T)  
    h1, w1 = shape(obj1)
    h2, w2 = shape(obj2)
    mid_col1 = leftmost(obj1) + w1 // 2
    mid_col2 = leftmost(obj2) + w2 // 2
    line1 = frozenset({(1, (i, j)) for i in range(uppermost(obj1), uppermost(obj1) + h1 // 2 + 1) 
                                    for j in range(mid_col1 - 1, mid_col1 + 2)})
    line2 = frozenset({(2, (i, j)) for i in range(uppermost(obj2) + h2 // 2, uppermost(obj2) + h2) 
                                    for j in range(mid_col2 - 1, mid_col2 + 2)})
    O = paint(paint(I, line1), line2)
    return O
 
0.1, 3.7921493, def igjhachhafdfedfabiecedhejeadjadg(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    h, w = shape(obj)
    mid_col = leftmost(obj) + w // 2
    start_row = uppermost(obj) + h // 2
    if i == 0:
      O = fill(O, 1, frozenset((row, mid_col) for row in range(start_row, start_row + 2)))
      O = fill(O, 1, frozenset((row, mid_col - 1) for row in range(start_row, start_row + 2)))
    else:
      O = fill(O, 2, frozenset((row, col) for row in range(start_row, start_row + h - h // 2) 
                                        for col in range(mid_col - 1, mid_col + 2)))
  return O
 
0.08499999999999999, 4.4213395, def hdbbicajjfgdeihgjchefjafdafaiaba(I):
    objs = sorted(objects(I, T, F, T), key=size)
    O = I
    for i, obj in enumerate(objs):
        h, w = shape(obj)
        mid_row = uppermost(obj) + h // 2
        mid_col = leftmost(obj) + w // 2
        if i == 0:
            O = fill(O, 1, frozenset(((mid_row, mid_col - 1), (mid_row, mid_col), (mid_row + 1, mid_col - 1), (mid_row + 1, mid_col)))) 
        else:
            O = fill(O, 2, frozenset(((mid_row, mid_col - 1), (mid_row, mid_col), (mid_row, mid_col + 1),
                                (mid_row + 1, mid_col - 1), (mid_row + 1, mid_col), (mid_row + 1, mid_col + 1))))
    return O
 
0.135, 6.1211834, def bbcadafbciheedcfifffgehciagahccf(I):
    obj1, obj2 = sorted(objects(I, T, F, T), key=lambda obj: (uppermost(obj), leftmost(obj)))
    h1, w1 = shape(obj1)
    h2, w2 = shape(obj2)
    O = fill(I, 1, frozenset((uppermost(obj1) + h1 // 2 + i, leftmost(obj1) + w1 // 2 + j) for i in range(2) for j in (-1, 0)))
    O = fill(O, 2, frozenset((uppermost(obj2) + h2 // 2 + i, leftmost(obj2) + w2 // 2 + j) for i in range(h2 - h2 // 2) for j in range(-1, 2)))
    return O 
 
0.08499999999999999, 4.169749, def aedbdjfaffbeebabiabecjchfjebdhjh(I):
  # Count objects with color 4
  obj_count = len(objects(I, T, F, T))
  
  # Define function to recolor inner area
  def recolor_inner(grid, color):
    obj = first(objects(grid, T, F, T))
    return fill(grid, color, difference(backdrop(obj), box(obj)))

  # Apply recoloring based on object count
  if obj_count == 1:
    return recolor_inner(I, 1)
  else:
    upper_half = recolor_inner(tophalf(I), 2)
    lower_half = recolor_inner(bottomhalf(I), 1)
    return vconcat(upper_half, lower_half) 
 
0.06999999999999999, 5.0466843, def efadddheibdheecaicedecgbdfbbabgd(I):
  # Identify distinct objects with color 4
  objs = colorfilter(objects(I, T, F, T), FOUR)

  # Define function to recolor inner area
  def recolor_inner(obj, color):
    return fill(I, color, difference(backdrop(obj), box(obj)))
  
  # Apply recoloring based on uppermost row
  O = I
  for obj in objs:
    if uppermost(obj) < len(I) // 2:
      O = recolor_inner(obj, 2 if len(objs) > 1 else 1)
    else:
      O = recolor_inner(obj, 1)
  return O 
 
0.065, 16.503523, def jbccfhhjchhaedbfjgdaaecbffgegdfb(I):
  # Identify distinct objects with color 4
  objs = colorfilter(objects(I, T, F, T), FOUR)
  
  # Define function to recolor inner area
  def recolor_inner(obj, color):
    return fill(I, color, difference(backdrop(obj), box(obj)))

  # Apply recoloring based on object size comparison
  O = I
  if len(objs) > 1:
    top_obj = first(sfilter(objs, lambda obj: uppermost(obj) < len(I) // 2))
    bottom_obj = first(sfilter(objs, lambda obj: uppermost(obj) >= len(I) // 2))
    if len(top_obj) >= len(bottom_obj):
      O = recolor_inner(top_obj, 2)
      O = recolor_inner(bottom_obj, 1)
    else:
      O = recolor_inner(top_obj, 1)
      O = recolor_inner(bottom_obj, 2)
  else:
    O = recolor_inner(first(objs), 1) 
  return O
 
0.13, 22.758759, def cdbbcgjdhadbeeicaeghabideeedbcfg(I):
  obj = argmax(objects(I, T, F, T), size)
  h, w = shape(obj)
  left_bound = leftmost(obj) + w // 3
  right_bound = leftmost(obj) + 2 * w // 3
  
  inner_fill = frozenset({(i, j) 
                         for i in range(uppermost(obj) + 1, lowermost(obj)) 
                         for j in range(left_bound, right_bound + 1)})
  lower_fill = frozenset({(lowermost(obj) + 1, j) 
                         for j in range(left_bound, right_bound + 1)})

  O = underfill(I, 1, inner_fill)
  O = underfill(O, 2, lower_fill)
  return O
 
0.12, 24.753874, def cccddbcbadbcehfibfbcefjijahfajca(I):
  obj = argmax(objects(I, T, F, T), size)
  h, w = shape(obj)

  inner_start = (uppermost(obj) + 1, leftmost(obj) + w // 3)
  inner_dims = (h - 2, w // 3 + (1 if w % 3 else 0))
  inner_fill = toindices(crop(canvas(1, inner_dims), (0, 0), inner_dims))
  inner_fill = shift(inner_fill, inner_start)

  lower_fill = toindices(shift(crop(canvas(2, (1, w)), (0, 0), (1, w // 3 + (1 if w % 3 else 0))), 
                              (lowermost(obj) + 1, leftmost(obj) + w // 3 - 1)))

  O = underfill(I, 1, inner_fill)
  O = underfill(O, 2, lower_fill)
  return O
 
0.11499999999999999, 25.916822, def ghaeefefgfheeeacidbfdbddfedhhefg(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: (-size(obj), uppermost(obj)))
  obj1, obj2 = objs[0], objs[1]

  # Determine line color based on object order
  color1 = 1 if uppermost(obj1) < uppermost(obj2) else 2
  color2 = 3 - color1

  # Draw Lines (Same as Program Version 1)
  # ... 
  return I
 
0.075, 6.7940617, def hbfefadcfaafebbgaicbaefbfcfdcdac(I):
  objs = objects(I, T, F, T)
  O = I
  first_obj = True
  for obj in objs:
    center_i, center_j = center(obj)
    if first_obj:
      O = fill(O, 1, frozenset(((center_i, center_j), (center_i, center_j + 1))))
      first_obj = False
    else:
      O = fill(O, 2, frozenset(((center_i, center_j), (center_i + 1, center_j), (center_i - 1, center_j), 
                                (center_i, center_j + 1), (center_i, center_j - 1))))
  return O
 
0.10500000000000001, 9.809218, def dcfbifihbecbejcdbgagieehbbjegffe(I):
  objs = objects(I, T, F, T)
  O = I
  first_obj = True
  for obj in objs:
    if first_obj:
      i, j = ulcorner(obj)
      h, w = shape(obj)
      O = fill(O, 1, frozenset(((i + h // 2, j + w // 2), (i + h // 2, j + w // 2 + 1))))
      first_obj = False
    else:
      hp = hperiod(obj)
      vp = vperiod(obj)
      i, j = ulcorner(obj)
      O = fill(O, 2, frozenset(((i + vp, j + hp), (i + 2 * vp, j + hp), (i, j + hp),
                                (i + vp, j), (i + vp, j + 2 * hp)))) 
  return O 
 
0.355, 28.18951, def dhdfffehefiiefafaegeffjhciafadfb(I):
  O = I
  for obj in fgpartition(I):
    middle_row = len(I) // 2
    top_count = sum(1 for _, (i, _) in obj if i < middle_row)
    bottom_count = len(obj) - top_count
    new_color = 1 if top_count > bottom_count else 2
    if len(fgpartition(I)) == 1:
        new_color = 2 if top_count > bottom_count else 1
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.11499999999999999, 25.916822, def jjceehafeicfejhbidcffeibdhjdjhbb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    upper_part = len(set(i for i, j in toindices(obj) if i < len(I) // 2)) > 0
    new_color = 1 if upper_part else 2
    if len(objs) == 1:
        new_color = 2 if upper_part else 1
    O = underfill(O, new_color, obj)
  return O
 
0.0, 0.0, def adhiffdcajcdeeedjebhafdffgdfbagi(I):
  O = I
  for i, obj in enumerate(objects(I, T, F, T)):
    new_color = i + 1
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.125, 23.555431, def cbfcjigegfhdeaifbihfbbafeaafjcfc(I):
    obj = argmax(objects(I, T, F, T), size)
    h, w = shape(obj)
    third_w = w // 3
    
    inner_fill = frozenset((uppermost(obj) + i, leftmost(obj) + j)
                          for i in range(1, h - 1)
                          for j in range(third_w, 2 * third_w + (1 if w % 3 else 0)))
    
    lower_fill = frozenset((lowermost(obj) + 1, leftmost(obj) + j) 
                         for j in range(third_w, 2 * third_w + (1 if w % 3 else 0)))

    O = underfill(I, 1, inner_fill)
    O = underfill(O, 2, lower_fill)
    return O
 
0.12, 24.720118, def bddhdfghhdcfedaajbbcfcbdbfcdageh(I):
  obj = argmax(objects(I, T, F, T), size)
  h, w = shape(obj)
  third_w = w // 3

  inner_rect = crop(canvas(1, (h - 2, third_w + (1 if w % 3 else 0))), (0, 0), (h - 2, third_w + (1 if w % 3 else 0)))
  inner_fill = toindices(shift(inner_rect, (uppermost(obj) + 1, leftmost(obj) + third_w)))
  lower_line = crop(canvas(2, (1, third_w + (1 if w % 3 else 0))), (0, 0), (1, third_w + (1 if w % 3 else 0)))
  lower_fill = toindices(shift(lower_line, (lowermost(obj) + 1, leftmost(obj) + third_w)))

  O = underfill(I, 1, inner_fill)
  O = underfill(O, 2, lower_fill)
  return O
 
0.065, 6.1682324, def abfccdegeiagedefibcffiagdfdcdeja(I):
  objs = objects(I, T, F, T)
  O = I
  first_obj = T
  for obj in objs:
    center_i, center_j = center(toindices(obj))
    if first_obj:
      O = fill(O, 1, connect((center_i, center_j-1), (center_i, center_j+1)))
      first_obj = F
    else:
      O = fill(O, 2, connect((center_i-1, center_j), (center_i+1, center_j)))
      O = fill(O, 2, connect((center_i, center_j-1), (center_i, center_j+1)))
  return O
 
0.065, 5.8503995, def fdeiijddfhbaeefebbfacdadefefbcff(I):
  objs = objects(I, T, F, T)
  O = [[v for v in row] for row in I]
  first_obj = True
  for obj in objs:
    min_i, min_j = ulcorner(obj)
    max_i, max_j = lrcorner(obj)
    center_i = (min_i + max_i) // 2
    center_j = (min_j + max_j) // 2
    if first_obj:
      for dj in range(-1, 2):
        if 0 <= center_j + dj < len(O[0]):
          O[center_i][center_j + dj] = 1
      first_obj = False
    else:
      for di in range(-1, 2):
        if 0 <= center_i + di < len(O):
          O[center_i + di][center_j] = 2
      for dj in range(-1, 2):
        if 0 <= center_j + dj < len(O[0]):
          O[center_i][center_j + dj] = 2
  return tuple(tuple(row) for row in O)
 
0.05, 1.7428297, def dbejcjccebefebcejjbgjdfjaahjaefa(I):
  """
  Identifies objects and recolors them based on their vertical position relative to the grid's center.
  """
  objs = objects(I, T, F, T)  
  O = I
  for i, obj in enumerate(objs):
    middle_row = height(I) // 2 
    new_color = i + 1 if uppermost(obj) < middle_row else i + 2
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O 
 
0.14500000000000002, 9.934126, def feifeafgifjeecafabdccbgecfffbggf(I):
  """
  Splits the grid into top and bottom halves, then recolors objects in each half separately.
  """
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  top_objs = objects(top_half, T, F, T)
  bottom_objs = objects(bottom_half, T, F, T)
  O = I
  for i, obj in enumerate(top_objs):
    O = fill(O, i + 1, difference(backdrop(obj), box(obj)))
  for i, obj in enumerate(bottom_objs):
    O = fill(O, i + len(top_objs) + 1, difference(backdrop(obj), box(obj)))
  return O
 
0.38, 78.11831, def cehfciebdcieedbbbbdidhaahbdhgdjf(I):
  # Identify objects
  obj1 = first(colorfilter(objects(I, T, F, T), 4))
  obj2 = other(colorfilter(objects(I, T, F, T), 4), obj1)
  
  # Define a function to modify an object based on its index
  def modify_object(obj, idx):
    h, w = halve(shape(obj))
    if idx == 0:  # First object
      return toobject(fill(canvas(0, (2, 2)), 1, {(0, 0), (0, 1)}), I)
    else:  # Second object
      return toobject(fill(canvas(0, (2, 2)), 2, {(0, 0), (0, 1)}), I)
  
  # Apply modifications based on index
  O = paint(
    paint(cover(cover(I, obj1), obj2), shift(modify_object(obj1, 0), subtract(center(obj1), (1, 1)))),
    shift(modify_object(obj2, 1), subtract(center(obj2), (1, 1)))
  )
  return O
 
0.19, 7.7397127, def fecjfddafhfcehaebeibdijfejieiafb(I):
  obj = argmax(objects(I, T, F, T), size)
  h = height(obj)
  w = width(obj)
  O = I
  for i in range(uppermost(obj), lowermost(obj) + 1):
    for j in range(leftmost(obj), rightmost(obj) + 1):
      if i in range(uppermost(obj) + h//3, lowermost(obj) - h//3 + 1):
        O = fill(O, 1, {(i, j)})
      if i == lowermost(obj) and j in range(leftmost(obj) + w//3, rightmost(obj) - w//3 + 1):
        O = fill(O, 2, {(i, j)})
  return O
 
0.18, 7.069641, def bbjeegicfeacefadbdgicafbdaaejcfa(I):
  obj = argmax(objects(I, T, F, T), size)
  third_height = height(obj) // 3
  third_width = width(obj) // 3
  upper_bound = uppermost(obj) + third_height
  lower_bound = lowermost(obj) - third_height
  left_bound = leftmost(obj) + third_width
  right_bound = rightmost(obj) - third_width
  O = fill(I, 1, product(interval(upper_bound, lower_bound + 1, 1), interval(leftmost(obj), rightmost(obj) + 1, 1)))
  O = fill(O, 2, product({lowermost(obj) + 1}, interval(left_bound, right_bound + 1, 1)))
  return O 
 
0.22499999999999998, 13.276953, def ecejfaafffecefabachehbaaacfdgheb(I):
  obj = argmax(objects(I, T, F, T), size)
  middle_section = crop(I, (uppermost(obj) + height(obj)//3, leftmost(obj)), (height(obj)//3, width(obj)))
  O = fill(I, 1, asindices(middle_section))
  O = fill(O, 2, shift(asindices(crop(middle_section, (height(middle_section) - 1, 0), (1, width(middle_section)))), (height(obj), 0)))
  return O
 
0.035, 4.258894, def edjeffdbegiiefecjacdfbiffbcfefai(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    h, w = shape(obj)
    mid_col = leftmost(obj) + w // 2
    start_row = uppermost(obj) + (h - (h // 2)) // 2 
    if i == 0:
      O = fill(O, 1, frozenset((row, mid_col) for row in range(start_row, start_row + 2)))
      O = fill(O, 1, frozenset((row, mid_col - 1) for row in range(start_row, start_row + 2)))
    else:
      O = fill(O, 2, frozenset((row, col) for row in range(start_row, start_row + h // 2) 
                                        for col in range(mid_col - 1, mid_col + 2)))
  return O
 
0.12000000000000001, 4.0000668, def fdhhbadbedjdejcbjagffcfjebghcjgh(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    ul = ulcorner(obj)
    h, w = shape(obj)
    if i == 0:
      O = fill(O, 1, frozenset(((ul[0] + h // 2, ul[1] + w // 2), (ul[0] + h // 2, ul[1] + w // 2 + 1),
                               (ul[0] + h // 2 + 1, ul[1] + w // 2), (ul[0] + h // 2 + 1, ul[1] + w // 2 + 1))))
    else:
      O = fill(O, 2, frozenset((ul[0] + k, ul[1] + l) for k in range(h // 2, h) 
                                                     for l in range(max(0, w // 2 - 1), min(w, w // 2 + 2))))
  return O
 
0.11499999999999999, 6.572972, def hcaajdfaaacgejedibcabbicfcaaaadf(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    c = center(obj)
    h, w = shape(obj)
    if i == 0:
      O = fill(O, 1, frozenset({(c[0], c[1] - 1), (c[0], c[1]), (c[0] + 1, c[1] - 1), (c[0] + 1, c[1])}))
    else:
      O = fill(O, 2, frozenset((c[0] + k, c[1] + l) for k in range( -(h // 2), 0)
                                                  for l in range(-1, 2)))
  return O
 
0.27, 24.597622, def gfeidjcbajhaehddifdcdffdcbdfcfbh(I):
    O = I
    color_index = 1
    for obj in objects(I, T, F, T):
        for i, row in enumerate(I):
            for j, value in enumerate(row):
                if (i, j) in backdrop(obj) and (i, j) not in obj:
                    O = fill(O, color_index, {(i, j)}) 
        color_index += 1
    return O 
 
0.07500000000000001, 14.392794, def bbbheegfdcaaeghebccgfebadecehgdc(I):
  # Identify objects and their centers
  objs = colorfilter(objects(I, T, F, T), 4)
  center1 = center(first(objs))
  center2 = center(other(objs, first(objs)))

  # Modify grid directly based on center locations
  O = fill(fill(I, 1 if index(I, center1) == 4 else 2, {center1, (center1[0], center1[1] - 1)}), 
           2 if index(I, center2) == 4 else 1, {center2, (center2[0], center2[1] - 1)})
  return O
 
0.345, 69.686966, def gijbedigfcaaefbcibhcahadccdhieci(I):
  # Identify objects and their bounding boxes
  objs = colorfilter(objects(I, T, F, T), 4)
  obj1, obj2 = first(objs), other(objs, first(objs))
  box1, box2 = inbox(obj1), inbox(obj2)

  # Define a function to get modification area
  def get_mod_area(box):
    h, w = center(box)
    return {(h, w), (h, w - 1)}

  # Apply modifications using box coordinates
  O = paint(paint(cover(cover(I, obj1), obj2), recolor(1, get_mod_area(box1))), recolor(2, get_mod_area(box2)))
  return O
 
0.12, 14.321922, def igdcaecbeabgedabjhbhfbhajadcchcd(I):
  # Directly identify center indices based on color and surrounding pattern
  center1 = first(sfilter(asindices(I), lambda loc: index(I, loc) == 4 and index(I, add(loc, (0, 1))) == 4 and index(I, add(loc, (1, 0))) == 4))
  center2 = first(sfilter(asindices(I), lambda loc: index(I, loc) == 4 and index(I, add(loc, (0, -1))) == 4 and index(I, add(loc, (-1, 0))) == 4))

  # Modify grid directly based on identified centers
  O = fill(fill(I, 1, {center1, (center1[0], center1[1] - 1)}), 2, {center2, (center2[0], center2[1] - 1)})
  return O
 
0.13, 5.236611, def aafabeebgfefegaiifjcigdjhcbafhij(I):
  obj = argmax(objects(I, T, F, T), size)
  third_width = width(obj) // 3
  left_bound = leftmost(obj) + third_width
  right_bound = rightmost(obj) - third_width
  O = fill(I, 1, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(left_bound, right_bound + 1, 1)))
  O = fill(O, 2, product({lowermost(obj) + 1}, interval(left_bound, right_bound + 1, 1)))
  return O
 
0.07500000000000001, 7.8342013, def cifbjaifhgdjeeabiefdebbhceeedeha(I):
  obj = argmax(objects(I, T, F, T), size)
  center_j = leftmost(obj) + width(obj) // 2
  O = I
  for i in range(uppermost(obj) + 1, lowermost(obj)):
    O = fill(O, 2, {(i, center_j - 1), (i, center_j)})
  O = fill(O, 1, {(lowermost(obj) + 1, center_j - 1), (lowermost(obj) + 1, center_j)}) 
  return O
 
0.125, 5.2876487, def baccfgcjcejdefehijfdcbeafcdbbbee(I):
  obj = argmax(objects(I, T, F, T), size)
  third_w = width(obj) // 3
  O = fill(I, 1, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(leftmost(obj) + third_w, rightmost(obj) - third_w + 1, 1)))
  O = fill(O, 2, {(lowermost(obj) + 1, leftmost(obj) + third_w), (lowermost(obj) + 1, rightmost(obj) - third_w)})
  return O
 
0.095, 11.266977, def fcefabbdgbedeahcaijgacdeedehegae(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, compfunc=lambda obj: len(obj))
  obj2 = argmax(objs - {obj1}, compfunc=lambda obj: len(obj))

  top_obj, bottom_obj = (obj1, obj2) if uppermost(obj1) < uppermost(obj2) else (obj2, obj1)

  def draw_lines(I, obj, color):
    j_start = (leftmost(obj) + rightmost(obj)) // 2
    return fill(I, color, 
               frozenset((i, j) for i in range(uppermost(obj) + 1, lowermost(obj) - 1) 
                         for j in range(j_start, j_start + 2)))
  
  I = draw_lines(I, top_obj, 1)
  I = draw_lines(I, bottom_obj, 2)

  return I
 
0.1, 3.4332957, def gebfedeccfibeacejiddebdbbabibffe(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    h, w = shape(obj)
    mid_col = leftmost(obj) + w // 2
    start_row = uppermost(obj) + h // 2
    if i == 0:
      O = fill(O, 1, frozenset((row, mid_col) for row in range(start_row - 1, start_row + 2)))
      O = fill(O, 1, frozenset((row, mid_col - 1) for row in range(start_row - 1, start_row + 2)))
    else:
      O = fill(O, 2, frozenset((row, col) for row in range(start_row, lowermost(obj) + 1)
                                        for col in range(mid_col - 1, mid_col + 2)))
  return O
 
0.15000000000000002, 8.275464, def edbcdfjbbacdeccfacfhdehdjifdedbf(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 0:
      center_cell = center(obj)
      O = fill(O, 1, frozenset({(center_cell[0] + di, center_cell[1] + dj) 
                              for di in range(-1, 2) for dj in range(-1, 2)}))
    else:
      O = fill(O, 2, frozenset((i,j) for i, j in toindices(obj) if i >= center(obj)[0]))
      O = fill(O, 2, frozenset((center(obj)[0] - 1, center(obj)[1] + dj) for dj in (-1, 0, 1)))
  return O
 
0.39, 26.862757, def gcchffbidediehddbdfadcaiefhfdbag(I):
  """
  This version utilizes the 'partition' function to efficiently group cells into objects based on their 
  color. It then determines each object's position relative to the grid's center using the average 
  column index of its cells and recolors the background accordingly.
  """
  O = I
  w = width(I)
  for obj in partition(I):
    if len(obj) > 0 and next(iter(obj))[0] != mostcolor(I):
      avg_j = sum(j for _, (i, j) in obj) // len(obj)
      new_color = 1 if avg_j < w // 2 else 2
      O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.365, 26.077085, def fdecdbccbadfeaifbbedggfbfdfciaed(I):
  """
  This version uses a recursive approach to identify and recolor the background surrounding objects. 
  It starts from the top-left corner and recursively explores connected cells, assigning colors 
  based on their horizontal position relative to the grid's center.
  """
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  visited = set()
  
  def recolor_recursive(i, j, current_color):
    if (i, j) in visited or not (0 <= i < h and 0 <= j < w) or I[i][j] == bg:
      return
    visited.add((i, j))
    O[i][j] = current_color
    for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
      recolor_recursive(i + di, j + dj, current_color)
  
  O = [[bg for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg and (i, j) not in visited:
        new_color = 1 if j < w // 2 else 2
        recolor_recursive(i, j, new_color)
  return tuple(tuple(row) for row in O)
 
0.14, 5.293195, def debedcccadbiecdaageficcdfhedecij(I):
  obj = argmax(objects(I, T, F, T), size)
  third_width = width(obj) // 3
  left_bound = leftmost(obj) + third_width
  right_bound = rightmost(obj) - third_width
  O = fill(I, 1, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(left_bound, right_bound + 1, 1)))
  if lowermost(obj) < len(I) - 1:
    O = fill(O, 2, product({lowermost(obj) + 1}, interval(left_bound, right_bound + 1, 1)))
  else:
    O = fill(O, 1, product({uppermost(obj) - 1}, interval(left_bound, right_bound + 1, 1))) 
  return O
 
0.12, 8.988579, def bcdahfcjadfdeccdigehceehehcabfjd(I):
  obj = argmax(objects(I, T, F, T), size)
  third_width = width(obj) // 3
  center_x = leftmost(obj) + width(obj) // 2
  left_bound = center_x - third_width // 2
  right_bound = center_x + third_width // 2
  fill_value = 2 if lowermost(obj) < len(I) - 1 else 1
  O = fill(I, 1, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(left_bound, right_bound + 1, 1)))
  O = fill(O, fill_value, product({lowermost(obj) + 1}, interval(left_bound, right_bound + 1, 1)))
  return O
 
0.11000000000000001, 5.2958355, def geagdeddecfdeafabdabcfaafefccfch(I):
  def fill_section(grid, obj, fill_val):
    third_width = width(obj) // 3
    left_bound = leftmost(obj) + third_width
    right_bound = rightmost(obj) - third_width
    return fill(grid, fill_val, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(left_bound, right_bound + 1, 1)))

  obj = argmax(objects(I, T, F, T), size)
  O = fill_section(I, obj, 1)
  O = fill_section(O, shift(obj, (1, 0)), 2) if lowermost(obj) < len(I) - 1 else fill_section(O, shift(obj, (-1, 0)), 1)
  return O
 
0.12, 7.329052, def igcejciebiecebdbjaccfjagdhbhfdcd(I):
  obj = argmax(objects(I, T, F, T), size)
  third_width = width(obj) // 3
  offset = (1, 0) if lowermost(obj) < len(I) - 1 else (-1, 0)
  fill_value = 2 if lowermost(obj) < len(I) - 1 else 1
  fill_area = lambda g, v: fill(g, v, product(interval(uppermost(obj) + offset[0], lowermost(obj) + offset[0] + 1, 1), interval(leftmost(obj) + third_width, rightmost(obj) - third_width + 1, 1)))
  O = fill_area(I, 1)
  O = fill_area(O, fill_value)
  return O
 
0.15000000000000002, 6.152454, def ahjhcfjbdebfededabcfgeeehefifaif(I):
  obj = argmax(objects(I, T, F, T), size)
  fill_area = lambda g, v, off: fill(g, v, product(interval(uppermost(obj) + off[0], lowermost(obj) + off[0] + 1, 1), interval(leftmost(obj) + width(obj)//3, rightmost(obj) - width(obj)//3 + 1, 1)))
  O = fill_area(I, 1, (1, 0)) 
  O = fill_area(O, 2, (2, 0)) if lowermost(obj) < len(I) - 1 else fill_area(O, 1, (0, 0))
  return O
 
0.09, 5.793855, def bbfffacgjjffefacjdiafeabddeeedaj(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: -size(obj))[:2] 
  for i, obj in enumerate(objs):
    color = i + 1 if uppermost(obj) >= len(I) // 2 else 2 - i
    for j in range(-1, 1):
      I = fill(I, color, connect((uppermost(obj) + 1, (leftmost(obj) + rightmost(obj)) // 2 + j), 
                                 (lowermost(obj) - 1, (leftmost(obj) + rightmost(obj)) // 2 + j)))
  return I 
 
0.075, 6.216883, def ifdfabgbabbdefcbjggfjcafecgbaaad(I):
  objs = objects(I, T, F, T)
  large_objs = sfilter(objs, lambda obj: size(obj) > 3)
  for obj in large_objs:
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    color = 2 if uppermost(obj) < len(I) // 2 else 1
    for j_offset in range(2):
      I = fill(I, color, frozenset((i, center_j + j_offset) for i in range(uppermost(obj) + 1, lowermost(obj))))
  return I
 
0.1, 6.293082, def ffejadcbajbaeddbicbeeibbdcdcedbf(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    color = 1 if i == 0 else 2
    center_i = (uppermost(obj) + lowermost(obj)) // 2
    line = frozenset({(color, (center_i, j)) for j in range(leftmost(obj), rightmost(obj) + 1)})
    O = paint(O, line)
  return O
 
0.37, 51.13479, def aehaedadabffefdgbhebfbifbdjdfecd(I):
    objs = objects(I, T, F, T)
    O = canvas(mostcolor(I), shape(I))
    for i, obj in enumerate(objs):
        line = frozenset((i + 1, (j, center(obj)[1])) for j in range(leftmost(obj), rightmost(obj) + 1))
        O = paint(O, line)
    return O
 
0.33, 55.352867, def acaacjdbfihhebfhjcjgehhfgagafecc(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(objs):
    start = (center(obj)[0], leftmost(obj))
    end = (center(obj)[0], rightmost(obj))
    line = connect(start, end)
    O = paint(O, recolor(i+1, line))
  return O
 
0.1, 14.225812, def cdfgcjdedgieecbhbdijdehbeffcdbcd(I):
  # Identify objects and their centers
  objs = colorfilter(objects(I, T, F, T), 4)
  obj1 = argmin(objs, uppermost)
  obj2 = other(objs, obj1)
  c1 = center(obj1)
  c2 = center(obj2)

  # Modify object 1
  O = fill(I, 2, {c1, (c1[0], c1[1] - 1)})

  # Modify object 2 based on shape
  if width(obj2) > height(obj2):
    O = fill(O, 1, {(c2[0], c2[1] - 1), c2, (c2[0], c2[1] + 1)})
  else:
    O = fill(O, 1, {c2, (c2[0], c2[1] - 1)})
  return O
 
0.13, 14.464607, def dibhcdhecfefedfibdebhiicicbfecgc(I):
  # Identify 4-color objects and their properties
  objs = colorfilter(objects(I, T, F, T), 4)
  obj1 = argmax(objs, size)
  obj2 = other(objs, obj1)
  h1, w1 = halve(shape(obj1))
  h2, w2 = halve(shape(obj2))

  # Modify object centers based on size and shape
  if size(obj1) > size(obj2):
    I = fill(I, 2, {(h1, w1), (h1, w1 - 1)})
    if width(obj2) > height(obj2):
      I = fill(I, 1, {(h2, w2 - 1), (h2, w2), (h2, w2 + 1)})
    else:
      I = fill(I, 1, {(h2, w2), (h2, w2 - 1)})
  else:
    I = fill(I, 1, {(h2, w2), (h2, w2 - 1)})
    if width(obj1) > height(obj1):
      I = fill(I, 2, {(h1, w1 - 1), (h1, w1), (h1, w1 + 1)})
    else:
      I = fill(I, 2, {(h1, w1), (h1, w1 - 1)}) 
  return I
 
0.06999999999999999, 6.6007032, def fddbceabeahiebaaafhdcggfbaffdedd(I):
  obj = argmax(objects(I, T, F, T), size)
  third_width = width(obj) // 3
  left_bound = leftmost(obj) + third_width
  right_bound = rightmost(obj) - third_width
  fill_value = 2 if lowermost(obj) < len(I) - 1 else 1
  O = fill(I, fill_value, product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(left_bound, right_bound + 1, 1)))
  return O
 
0.07500000000000001, 12.339896, def adabdgadjfaaeadijbggabdgdfadbegc(I):
  obj = argmax(objects(I, T, F, T), size)
  O = I
  for i in range(uppermost(obj) + 1, lowermost(obj)):
    for j in range(leftmost(obj) + width(obj) // 3, rightmost(obj) - width(obj) // 3):
      O = fill(O, 2 if i < len(I) - 1 else 1, {(i, j)})
  return O
 
0.08499999999999999, 12.102217, def aadeecacfecaeedabacbcccehdjhbhdf(I):
  def fill_middle_third(grid, obj, value):
    third_width = width(obj) // 3
    left_bound = leftmost(obj) + third_width
    right_bound = rightmost(obj) - third_width
    return fill(grid, value, product(range(uppermost(obj) + 1, lowermost(obj)), range(left_bound, right_bound)))
  
  obj = argmax(objects(I, T, F, T), size)
  O = fill_middle_third(I, obj, 2) if lowermost(obj) < len(I) - 1 else fill_middle_third(I, obj, 1)
  return O
 
0.14, 5.872383, def ecaababecceeefabjbfejcfbddhcdeaf(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      i_min = uppermost(obj)
      i_max = lowermost(obj)
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      middle_row = (i_min + i_max) // 2
      if middle_row < len(I) // 2:
        I = fill(I, 1, frozenset({(i, j) for i in range(i_min + 1, i_max) for j in range(j_center - 1, j_center + 2)}))
      else:
        I = fill(I, 2, frozenset({(i, j) for i in range(i_min, i_max + 1) for j in range(j_center - 1, j_center + 2)}))
  return I
 
0.115, 9.016477, def faejcbeaeegdedjbjfeafhcbcfiegdaf(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      i_min = uppermost(obj)
      i_max = lowermost(obj)
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      if (i_min + i_max) // 2 < len(I) // 2:
        I = paint(I, recolor(1, frozenset({(i, j_center) for i in range(i_min + 1, i_max) for j in range(j_center - 1, j_center + 2)})))
      else:
        I = paint(I, recolor(2, frozenset({(i, j_center) for i in range(i_min, i_max + 1) for j in range(j_center - 1, j_center + 2)})))
  return I
 
0.21500000000000002, 21.852552, def aiagcgbcgacbecbajebeffeiffdagdcj(I):
  objs = objects(I, T, F, T)
  O = I
  obj1_center = center(next(iter(objs)))
  O = fill(O, 1, frozenset(((obj1_center[0], obj1_center[1] - 1), 
                           obj1_center, 
                           (obj1_center[0], obj1_center[1] + 1))))
  for i, obj in enumerate(objs):
    if i > 0:
      O = paint(cover(O, obj), recolor(i + 1, frozenset((row, col) for row in range(center(obj)[0], lowermost(obj) + 1) 
                                                      for col in range(leftmost(obj), rightmost(obj) + 1))))
  return O
 
0.14, 19.16759, def ddafeeccggdeeefbjeaehfcfbcdhfihd(I):
  objs = objects(I, T, F, T)
  O = I
  obj1 = next(iter(objs))
  O = paint(O, recolor(1, frozenset(((center(obj1)[0], center(obj1)[1] - 1), 
                                     center(obj1), 
                                     (center(obj1)[0], center(obj1)[1] + 1)))))
  for i, obj in enumerate(objs):
    if i > 0:
      O = paint(O, recolor(i + 1, frozenset((i, j) for i, j in obj if i >= center(obj)[0])))
  return O
 
0.08499999999999999, 3.3714418, def eibfhgbheiebededbdheccdafccbceec(I):
  objs = objects(I, T, F, T)
  inner_areas = mapply(compose(lambda x: difference(backdrop(x), box(x)), lambda y: y), objs)
  return fill(I, ONE, inner_areas) 
 
0.12, 18.49789, def caecdabjjdfdecgijhccaebcfhhhajca(I):
  objs = colorfilter(objects(I, T, F, T), 4)
  top_obj = argmax(objs, uppermost)
  bottom_obj = other(objs, top_obj)

  def modify(obj, value):
    h = height(obj) // 2
    w = width(obj) // 2
    if width(obj) > height(obj):
      return fill(I, value, {(h, w - 1), (h, w), (h, w + 1)})
    else:
      return fill(I, value, {(h, w), (h, w - 1)})

  O = modify(top_obj, 2)
  O = modify(bottom_obj, 1)
  return O
 
0.11499999999999999, 16.397963, def jfehedbbfccfecbejfgedfafbeefaefb(I):
  def process_object(obj, value):
    c = centerofmass(obj)
    if width(obj) > height(obj):
      return paint(I, {(value, (c[0], c[1] - 1)), (value, c), (value, (c[0], c[1] + 1))})
    else:
      return paint(I, {(value, c), (value, (c[0], c[1] - 1))})

  objs = colorfilter(objects(I, T, F, T), 4)
  O = process_object(argmax(objs, uppermost), 2)
  O = process_object(argmin(objs, uppermost), 1)
  return O
 
0.25, 49.81902, def aedbjafjadcaefeeacabfaffffcahbdf(I):
  objs = objects(I, True, False, True)

  def transform(obj, v):
    c = centerofmass(obj)
    if width(obj) > height(obj):
      return paint(cover(I, obj), {(v, (c[0], c[1] - 1)), (v, c), (v, (c[0], c[1] + 1))})
    else:
      return paint(cover(I, obj), {(v, c), (v, (c[0], c[1] - 1))})

  O = transform(argmax(objs, lambda o: uppermost(o)), 2)
  O = transform(argmin(objs, lambda o: uppermost(o)), 1)
  return O
 
0.14, 11.85237, def jccchgbfdeagecgeieidhehdghcbfeee(I):
  obj = argmax(objects(I, T, F, T), size)
  h = height(obj)
  w = width(obj)
  O = fill(I, 1, product(interval(lowermost(obj) - 1, lowermost(obj) + 1, 1), interval(leftmost(obj) + w//3, rightmost(obj) - w//3 + 1, 1)))
  O = fill(O, 2, {(lowermost(obj), leftmost(obj) + w//3), (lowermost(obj), rightmost(obj) - w//3)})
  return O
 
0.11499999999999999, 25.916822, def acgigbeajajbegbbjabcfgciaffegddf(I):
  obj = argmax(objects(I, T, F, T), size)
  third_w = width(obj) // 3
  O = underfill(I, 1, product(interval(lowermost(obj) - 1, lowermost(obj) + 1, 1), interval(leftmost(obj) + third_w, rightmost(obj) - third_w + 1, 1)))
  O = underfill(O, 2, {(lowermost(obj), leftmost(obj) + third_w), (lowermost(obj), rightmost(obj) - third_w)})
  return O
 
0.11499999999999999, 23.359953, def hfcbffjaabeiehehigefeccefcchaccj(I):
  obj = argmax(objects(I, T, F, T), size)
  center_x = leftmost(obj) + width(obj) // 2
  O = I
  for i in range(height(obj)):
    for j in range(width(obj)):
      if (i in range(lowermost(obj)-1,lowermost(obj)+1) and abs(j - center_x) <= width(obj)//6):
        O = fill(O, 1, {(i, j)})
      if (i == lowermost(obj) and abs(j - center_x) == width(obj)//3):
        O = fill(O, 2, {(i, j)})
  return O 
 
0.155, 5.5933332, def ccfhfaaafigeebjfjccfccecfbadgahi(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      rows = frozenset({i for i, j in toindices(obj)})
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      middle_row = (min(rows) + max(rows)) // 2
      if middle_row < len(I) // 2:
        I = fill(I, 1, frozenset({(i, j_center) for i in range(min(rows), max(rows) + 1)}))
        I = fill(I, 1, frozenset({(i, j_center + 1) for i in range(min(rows), max(rows) + 1)}))
      else:
        I = fill(I, 2, frozenset({(i, j_center) for i in range(min(rows), max(rows) + 1)}))
        I = fill(I, 2, frozenset({(i, j_center + 1) for i in range(min(rows), max(rows) + 1)}))
  return I
 
0.33999999999999997, 20.329521, def hidabbegaebjeceaabeacdhfjaejbgah(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != 0:
        obj = extract(objects(I, T, F, T), lambda obj: (i, j) in toindices(obj))
        if size(obj) > 3:
          middle_row = (uppermost(obj) + lowermost(obj)) // 2
          j_center = (leftmost(obj) + rightmost(obj)) // 2
          value = 1 if middle_row < len(I) // 2 else 2
          I = fill(I, value, frozenset({(r, j_center) for r in range(uppermost(obj), lowermost(obj) + 1)}))
          I = fill(I, value, frozenset({(r, j_center + 1) for r in range(uppermost(obj), lowermost(obj) + 1)}))
  return I
 
0.14500000000000002, 8.508573, def jeebiebbcagaeiabjccgffabieaadbhc(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: -size(obj))  # Sort by size, largest first
  O = I
  for i, obj in enumerate(objs):
    c = center(obj)
    w = width(obj)
    if i == 0:
      O = fill(O, 1, frozenset({(c[0], c[1] - 1), (c[0], c[1]), (c[0], c[1] + 1)}))
    else:
      O = fill(O, 2, frozenset({(c[0], j) for j in range(c[1] - w//2, c[1] + w//2 + 1)}))
  return O
 
0.10500000000000001, 19.17638, def hiecjddcbdfbeahjbebgjgcadafcebcc(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 0:
      O = paint(O, recolor(1, connect((center(obj)[0], center(obj)[1] - 1), (center(obj)[0], center(obj)[1] + 1))))
    else:
      O = underfill(O, 2, toindices(obj))
  return O
 
0.135, 5.163355, def jeaehfagefjdefdabbfbfbffidbcedcj(I):
    objs = sorted(objects(I, T, F, T), key=lambda obj: size(obj))
    O = I
    for i, obj in enumerate(objs):
        c = center(obj)
        if i == 0:
            O = fill(O, 1, connect((c[0], c[1] - 1), (c[0], c[1] + 1)))
        else:
            O = fill(O, 2, hfrontier(c))
    return O
 
0.09, 5.4482994, def ahecibebaabiefabiaigfebcbieedbga(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 0:
      O = paint(O, recolor(1, frozenset({(center(obj)[0], center(obj)[1] - 1), center(obj), (center(obj)[0], center(obj)[1] + 1)})))
    else:
      O = paint(O, recolor(2,  frozenset({(center(obj)[0], j) for j in range(leftmost(obj), rightmost(obj) + 1)})))
  return O
 
0.10500000000000001, 19.965593, def biahbjecheieedccigbabjdjgdehibdj(I):
  objs = sorted(objects(I, T, F, T), key=size)
  O = I
  for i, obj in enumerate(objs):
    if i == 0:
      O = fill(O, 1, backdrop(connect(center(obj), add(center(obj), (-1, 0)))))
    else:
      O = underfill(O, 2, backdrop(obj))
  return O
 
0.10500000000000001, 7.4704065, def idecfaiajgeaeehgifedicadfidcadfj(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      color = 2 if uppermost(obj) < len(I) // 2 else 1
      start_row = uppermost(obj) + 1 if uppermost(obj) < len(I) // 2 else uppermost(obj)
      end_row = lowermost(obj) - 1 if uppermost(obj) < len(I) // 2 else lowermost(obj)
      for j in range(j_center, j_center + 2):
        I = fill(I, color, frozenset({(i, j) for i in range(start_row, end_row)}))
  return I
 
0.115, 4.7312365, def babaahjjfacfejfjaabcdhifceddeeaa(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if size(obj) > 3:
      j_center = (leftmost(obj) + rightmost(obj)) // 2
      color = 2 if uppermost(obj) < len(I) // 2 else 1
      I = fill(I, color, connect((uppermost(obj) + (uppermost(obj) < len(I) // 2), j_center), 
                                (lowermost(obj) - (uppermost(obj) < len(I) // 2), j_center)))
      I = fill(I, color, connect((uppermost(obj) + (uppermost(obj) < len(I) // 2), j_center + 1), 
                                (lowermost(obj) - (uppermost(obj) < len(I) // 2), j_center + 1)))
  return I
 
0.14500000000000002, 7.0158157, def ebgcidcaadibebhajaffchefhedabbda(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 1:
      h = height(obj)
      shrink_factor = 1 if h % 2 == 0 else 2 
      O = fill(O, 2 if i == 0 else 1, 
               frozenset((row, col) 
                         for row in range(uppermost(obj) + shrink_factor, lowermost(obj) - shrink_factor + 1)
                         for col in range(leftmost(obj), rightmost(obj) + 1)))
  return O
 
0.195, 19.530197, def fddbfchfejefeccejfcbcbdegjjifcdh(I):
  objs = objects(I, T, F, T)
  O = paint(I, first(objs)) 
  second_obj = list(objs)[1]
  h = height(second_obj)
  shrink_factor = 1 if h % 2 == 0 else 2
  top_part = crop(O, ulcorner(second_obj), (shrink_factor, width(second_obj)))
  bottom_part = crop(O, (lowermost(second_obj) - shrink_factor + 1, leftmost(second_obj)), (shrink_factor, width(second_obj)))
  O = paint(O, recolor(2 if h % 2 == 0 else 1, combine(asindices(top_part), asindices(bottom_part))))
  return O
 
0.125, 7.713441, def gfcaidcdaijfeacdijeadegficebbidi(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 1:
      for j in range(width(obj)):
        if height(obj) % 2 == 0:
          O = fill(O, 2, frozenset({(uppermost(obj) + height(obj) // 2, leftmost(obj) + j), 
                                   (uppermost(obj) + height(obj) // 2 - 1, leftmost(obj) + j)}))
        else:
          O = fill(O, 1, frozenset({(uppermost(obj) + height(obj) // 2 + 1, leftmost(obj) + j), 
                                   (uppermost(obj) + height(obj) // 2, leftmost(obj) + j),
                                   (uppermost(obj) + height(obj) // 2 - 1, leftmost(obj) + j)}))
  return O
 
0.11499999999999999, 25.916822, def cibgheeeabdeefacjcjhaehccfbejaac(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    if i == 1:
      h = height(obj)
      mid = h // 2
      shrink_factor = 1 if h % 2 == 0 else 2 
      O = paint(O, recolor(mostcolor(I), 
                        frozenset((a, b) for a, b in obj if a in range(uppermost(obj) + shrink_factor, lowermost(obj) - shrink_factor + 1))))
  return O
 
0.325, 43.54975, def jbdadecbdhdbegbdjgdbbjddafeccdac(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    fill_color = 1 if uppermost(obj) < len(I) // 2 else 2
    O = paint(O, recolor(fill_color, difference(backdrop(obj), box(obj))))
  return O
 
0.095, 17.929922, def acbaheebcghceejhiicbifebaecdacgf(I):
  def process_object(obj, grid):
    fill_color = 1 if uppermost(obj) < len(I) // 2 else 2
    return fill(grid, fill_color, difference(backdrop(obj), box(obj)))
  return last(apply(lambda obj: lambda grid: process_object(obj, grid), objects(I, T, F, T)))(I)
 
0.105, 21.126923, def fgddddcjhhfaedcfbefihfhceaffhcha(I):
  objs = colorfilter(objects(I, T, F, T), 4)  # Identify objects formed by '4'
  top_obj = min(objs, key=lambda obj: ulcorner(obj)[0])  # Top object has smaller upper left corner row index
  bottom_obj = other(objs, top_obj)

  def modify_obj(obj, val):
    ul = ulcorner(obj)
    h, w = shape(obj)
    center_i, center_j = ul[0] + h // 2, ul[1] + w // 2
    fill_indices = {(center_i, center_j)}
    if w > h:
      fill_indices |= {(center_i, center_j - 1), (center_i, center_j + 1)}
    if h > w or w == h:  # Fill two cells to the left and right if taller or square
      fill_indices |= {(center_i, center_j - 2), (center_i, center_j + 2)} 
    return fill(I, val, fill_indices)

  O = modify_obj(top_obj, 1)
  O = modify_obj(bottom_obj, 2)
  return O
 
0.065, 5.5306726, def jahdfdfhadadegjbjfebihdbdidfjaca(I):
  obj = argmax(objects(I, T, F, T), size)
  h, w = shape(obj)
  third_w = w // 3

  # Determine fill values based on object's vertical position
  fill_inner = 1 if uppermost(obj) == 0 else 2
  fill_lower = 2 if fill_inner == 1 else 1
  
  # Inner Fill
  inner_fill_area = product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(leftmost(obj) + third_w, rightmost(obj) - third_w + 1, 1))
  O = fill(I, fill_inner, inner_fill_area)
  
  # Lower Fill
  lower_fill_area = product({lowermost(obj) + 1}, interval(leftmost(obj) + third_w, rightmost(obj) - third_w + 1, 1))
  O = fill(O, fill_lower, lower_fill_area) 

  return O
 
0.065, 6.7593007, def bdbdebfbdcbcehjeabjccagcdhgdajdf(I):
  obj = argmax(objects(I, T, F, T), size)
  h = height(obj)
  third_w = width(obj) // 3

  O = I
  for i in range(1, h - 1):
    for j in range(third_w, 2 * third_w + 1):
      if index(subgrid(obj, I), (i, j)) != 0:
        O = fill(O, 1 if uppermost(obj) == 0 else 2, {(uppermost(obj) + i, leftmost(obj) + j)})
        if lowermost(obj) + 1 < len(I):
          O = fill(O, 2 if uppermost(obj) == 0 else 1, {(lowermost(obj) + 1, leftmost(obj) + j)})
  return O
 
0.11499999999999999, 11.796076, def diaggbddeajbeecbaibcdeajgifcbeac(I):
  obj = argmax(objects(I, T, F, T), size)
  inner_obj = toobject(product(interval(uppermost(obj) + 1, lowermost(obj), 1), interval(leftmost(obj) + width(obj) // 3, rightmost(obj) - width(obj) // 3 + 1, 1)), subgrid(obj, I))
  
  fill_inner = 1 if uppermost(obj) == 0 else 2
  fill_lower = 2 if fill_inner == 1 else 1

  O = fill(I, fill_inner, toindices(inner_obj))
  O = fill(O, fill_lower, toindices(shift(inner_obj, (1, 0))))

  return O
 
0.435, 37.049248, def hbffeacgadacegfaaefaabcaibfefecc(I):
  obj = argmax(objects(I, T, F, T), size)
  fill_value = 1 if uppermost(obj) == 0 else 2
  
  # Create a mask for the inner area
  mask = canvas(0, shape(obj))
  mask = fill(mask, 1, product(interval(1, height(mask) - 1, 1), interval(width(mask) // 3, 2 * width(mask) // 3 + 1, 1)))

  # Apply the mask to the object's subgrid
  filled_obj = cellwise(subgrid(obj, I), mask, 0)
  filled_obj = recolor(fill_value, asobject(filled_obj))

  # Combine with the lower fill
  lower_fill = recolor(2 if fill_value == 1 else 1, shift(toindices(filled_obj), (1, 0)))
  O = paint(paint(cover(I, obj), filled_obj), lower_fill)

  return O
 
0.195, 10.580112, def ecfjefhbeecfeagijebfcbbbafbfehgb(I):
  """
  This version uses conditional branching to process objects differently
  based on their position relative to the grid's midpoint.
  """
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)
  
  I = branch(size(top_obj) > 0, 
             fill(I, 1, connect((uppermost(top_obj), (leftmost(top_obj) + rightmost(top_obj)) // 2), 
                                (len(I) // 2, (leftmost(top_obj) + rightmost(top_obj)) // 2))),
             I)
  I = branch(size(top_obj) > 0,
             fill(I, 1, connect((uppermost(top_obj), (leftmost(top_obj) + rightmost(top_obj)) // 2 + 1), 
                                (len(I) // 2, (leftmost(top_obj) + rightmost(top_obj)) // 2 + 1))),
             I)
  
  I = branch(size(bottom_obj) > 0, 
             fill(I, 2, connect((len(I) // 2, (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2), 
                                (lowermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2))),
             I)
  I = branch(size(bottom_obj) > 0, 
             fill(I, 2, connect((len(I) // 2, (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1), 
                                (lowermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1))),
             I)
  return I
 
0.12, 25.893013, def cbjbdacfacieeccibeeebbbdbdjiheec(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if even(height(obj)):
      O = paint(cover(O, shift(obj, (1, 0))), obj)
      O = underfill(O, 1, obj)
    else:
      O = paint(cover(O, shift(obj, (2, 0))), obj)
      O = underfill(O, 2, obj)
  return O
 
0.18, 16.95567, def acjbfdggecdaedbbihabdfdfgfjcadae(I):
  objs = objects(I, T, F, T)
  O = I 
  for obj in objs:
    mid_row = uppermost(obj) + height(obj) // 2
    mid_col = leftmost(obj) + width(obj) // 2
    line_color = 1 if even(height(obj)) else 2
    O = fill(O, line_color, frozenset(((mid_row, mid_col), (mid_row + 1, mid_col))))
    for v, (i, j) in obj:
      if i >= mid_row + 1:
        O = fill(O, v, frozenset({(i + (2 if line_color == 2 else 1), j)})) 
  return O
 
0.055, 2.7772217, def fchcecebbifceafbiacbeebfabffdeai(I):
  O = I
  for obj in objects(I, T, F, T):
    middle_row = height(I) // 2
    new_color = 1 if uppermost(obj) < middle_row else 2
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.325, 21.325186, def fcbfaggehiffefchjhajcaccdhedecff(I):
  O = canvas(mostcolor(I), shape(I)) 
  for obj in objects(I, T, F, T):
    middle = height(I) // 2
    upper_part = frozenset((v, (i, j)) for v, (i, j) in obj if i < middle)
    lower_part = frozenset((v, (i, j)) for v, (i, j) in obj if i >= middle)
    O = paint(O, recolor(1, upper_part))
    O = paint(O, recolor(2, lower_part))
  return O
 
0.325, 21.325186, def deeeidhicdhbebjfjhfbfhhgcehabdfd(I):
  # Directly recolor based on cell indices and conditional
  O = canvas(ZERO, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == FOUR:
        new_color = 1 if i < len(I) // 2 else 2
        O = fill(O, new_color, {(i,j)})
      else:
        O = fill(O, I[i][j], {(i,j)})
  return O
 
0.055, 2.7772217, def ececfhjcbbfceaabbggacdfebfdbddeg(I):
  objs = objects(I, T, F, T)
  middle_row = len(I) // 2
  switch_value = 1 if middle_row * 2 == len(I) else 2  # Alternate value for odd height
  for obj in objs:
    fill_value = 1 if uppermost(obj) < middle_row else 2
    fill_value = switch_value if fill_value == 1 else 3 - switch_value  # Swap 1 and 2
    I = fill(I, fill_value, difference(backdrop(obj), box(obj)))
  return I
 
0.06, 1.704354, def efdcigjiaidbeffejcdjiadedfbdgjaf(I):
  objs = objects(I, T, F, T)
  obj_indices = apply(toindices, objs)
  inner_areas = apply(compose(lambda x: difference(backdrop(x), box(x)), identity), obj_indices)
  O = I
  for i, area in enumerate(inner_areas):
    O = fill(O, i + 1, area)
  return O
 
0.005, 4.9204, def hegjdcfaigdbechjahbbaffdaabdaebd(I):
  objs = objects(I, T, F, T)
  O = I
  for i, obj in enumerate(objs):
    inbox_area = inbox(toindices(obj))
    O = fill(O, i + 1, inbox_area)
  return O
 
0.0, 0.0, def bcebcfffifadedhejdaaidgfafjacgae(I):
  def inner_fill(obj, grid, count):
    return fill(grid, count, difference(backdrop(toindices(obj)), box(toindices(obj))))
  
  objs = objects(I, T, F, T)
  O = I
  count = 1
  for obj in objs:
    O = inner_fill(obj, O, count)
    count += 1
  return O
 
0.155, 5.137668, def bfbeebbcfffhegeibjdeegbbbaacffbe(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)
  
  mid_col_top = (leftmost(top_obj) + rightmost(top_obj)) // 2
  start_row_top = uppermost(top_obj) + height(top_obj) // 2 
  I = fill(I, 1, connect((start_row_top, mid_col_top), (start_row_top + 1, mid_col_top)))
  I = fill(I, 1, connect((start_row_top, mid_col_top + 1), (start_row_top + 1, mid_col_top + 1)))

  I = fill(I, 2, frozenset((row, col) for row in range(uppermost(bottom_obj), uppermost(bottom_obj) + height(bottom_obj) // 2) 
                                       for col in range(leftmost(bottom_obj), rightmost(bottom_obj) + 1)))
  return I 
 
0.11499999999999999, 25.916822, def aeffehiedbjdeggcabbdjcbdaebacbfa(I):
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for obj in objects(I, T, F, T):
    color = next(iter(obj))[0]
    if uppermost(obj) < h // 2:
      mid_col = (leftmost(obj) + rightmost(obj)) // 2
      start_row = uppermost(obj) + height(obj) // 2
      O = fill(O, 1, connect((start_row, mid_col), (start_row + 1, mid_col)))
      O = fill(O, 1, connect((start_row, mid_col + 1), (start_row + 1, mid_col + 1)))
    else:
      O = paint(O, recolor(2, frozenset((i, j) for i in range(uppermost(obj), uppermost(obj) + height(obj) // 2) 
                                          for j in range(leftmost(obj), rightmost(obj) + 1))))
    O = paint(O, obj)
  return O
 
0.165, 5.1618843, def abgieafcciagegacbeafifadbeeafigg(I):
  objs = objects(I, T, F, T)
  top = extract(objs, lambda obj: uppermost(obj) < len(I) // 2)
  bottom = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2)

  top_center = centerofmass(top)
  I = fill(I, 1, frozenset({(top_center[0], top_center[1] - 1),
                          (top_center[0], top_center[1]),
                          (top_center[0] + 1, top_center[1] - 1),
                          (top_center[0] + 1, top_center[1])}))
  I = fill(I, 2, frozenset((i, j) for i in range(uppermost(bottom), centerofmass(bottom)[0] + 1)
                                    for j in range(leftmost(bottom), rightmost(bottom) + 1)))
  return I
 
0.325, 24.736103, def ccedabgagfdbebgcijaffhadcdcaific(I):
  h = height(I)
  middle = h // 2
  return paint(paint(I, recolor(1, mfilter(objects(I, T, F, T), lambda obj: uppermost(obj) < middle))),
               recolor(2, mfilter(objects(I, T, F, T), lambda obj: uppermost(obj) >= middle)))
 
0.11499999999999999, 25.916822, def ihdbiibfffadeijdidjdjcddabijaebj(I):
  h = height(I)
  middle = h // 2
  O = I
  for obj in objects(I, T, F, T):
    O = underfill(O, 1, sfilter(toindices(obj), lambda ind: ind[0] < middle))
    O = underfill(O, 2, sfilter(toindices(obj), lambda ind: ind[0] >= middle))
  return O
 
0.05, 1.4355837, def jijfabaidjiheagbjbfcgecebgacfaeb(I):
    # Identify distinct objects with color 4
    x1 = objects(I, T, F, T)
    x2 = colorfilter(x1, FOUR)

    # Define function to get inner indices of an object
    def inner_indices(obj):
      return difference(backdrop(obj), box(obj))

    # Apply recoloring based on object's position and input grid
    O = I
    for i, obj in enumerate(x2):
        new_color = 1 if (uppermost(obj) < len(I) // 2) == (i % 2 == 0) else 2
        O = fill(O, new_color, inner_indices(obj))
    return O
 
0.325, 43.54975, def dbhbgiaiahgeeifeadefdcedefiaacdf(I):
    # Identify all objects 
    objs = objects(I, T, F, T)

    # Function to recolor based on position and existing color
    def recolor_object(obj):
        new_color = 1 if uppermost(obj) < len(I) // 2 else 2
        return recolor(new_color, difference(backdrop(obj), box(obj)))

    # Recolor only objects with color '4'
    recolored_objs = frozenset(recolor_object(obj) if color(obj) == 4 else obj for obj in objs)

    # Paint the recolored objects onto a blank canvas
    return paint(canvas(0, shape(I)), merge(recolored_objs))
 
0.325, 24.736103, def cebfadfabeccecafiijaahbfffadcdgg(I):
    def recolor_cell(i, j):
        if I[i][j] != 4:
            return I[i][j]
        obj = next(obj for obj in objects(I, T, F, T) if (i, j) in toindices(obj))
        return 1 if uppermost(obj) < len(I) // 2 else 2
  
    h, w = shape(I)
    return tuple(tuple(recolor_cell(i, j) for j in range(w)) for i in range(h))
 
0.16, 13.315442, def feeaechdbijbeaaebfidddgfhgbjecca(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2)
  
  I = fill(I, 1, box(shift(crop(I, (uppermost(top_obj) + height(top_obj) // 2 - 1, 
                                       leftmost(top_obj) + width(top_obj) // 2 - 1), 
                                       (2, 2)),
                             (uppermost(top_obj) + height(top_obj) // 2 - 1, 
                              leftmost(top_obj) + width(top_obj) // 2 - 1))))
  
  I = fill(I, 2, frozenset((i, j) 
                           for i in range(uppermost(bottom_obj), 
                                          uppermost(bottom_obj) + height(bottom_obj) // 2) 
                           for j in range(leftmost(bottom_obj), rightmost(bottom_obj) + 1)))
  return I
 
0.135, 4.7252507, def ijbhgjhbeaefeefcjifegbbhdeadidfe(I):
  h, w = len(I), len(I[0])
  O = I
  for obj in objects(I, T, F, T):
    center_row = uppermost(obj) + height(obj) // 2
    center_col = leftmost(obj) + width(obj) // 2
    if center_row < h // 2:
      O = fill(O, 1, frozenset([(center_row, center_col), 
                               (center_row - 1, center_col), 
                               (center_row, center_col - 1), 
                               (center_row - 1, center_col - 1)]))
    else:
      O = fill(O, 2, frozenset((i, j) 
                              for i in range(uppermost(obj), center_row) 
                              for j in range(leftmost(obj), rightmost(obj) + 1)))
  return O
 
0.125, 23.464048, def jbbbdhebdfddedabaccibgegibdajide(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if uppermost(obj) < len(I) // 2:
      I = fill(I, 1, 
                  box(shift(
                      crop(I, (uppermost(obj) + height(obj) // 2 - 1, 
                                leftmost(obj) + width(obj) // 2 - 1), (2, 2)), 
                      (uppermost(obj) + height(obj) // 2 - 1, 
                       leftmost(obj) + width(obj) // 2 - 1))))
    else:
      upper_half = frozenset((i, j) for i in range(uppermost(obj), uppermost(obj) + height(obj) // 2) 
                                       for j in range(leftmost(obj), rightmost(obj) + 1))
      I = underfill(I, 2, upper_half)
  return I
 
0.175, 5.0677757, def jdfaieddhbgeefbdifehahacabdabefh(I):
  h, w = len(I), len(I[0])
  O = I
  for obj in objects(I, T, F, T):
    ci, cj = centerofmass(obj)
    if ci < h // 2:
      O = fill(O, 1, 
               frozenset([(ci, cj), (ci - 1, cj), (ci, cj - 1), (ci - 1, cj - 1)]))
    else:
      O = fill(O, 2, 
               frozenset((i, j) for i in range(uppermost(obj), ci)
                                for j in range(leftmost(obj), rightmost(obj) + 1)))
  return O
 
0.305, 14.528859, def aagadababhebegheidagdccehabciedc(I):
  h = height(I) // 2 
  O = I
  for i in range(h):
    for j in range(width(I)):
      if index(I, (i, j)) == 0 and any(index(I, (n, j)) != 0 for n in range(h)):
        O = fill(O, 1, {(i, j)})
  for i in range(h, height(I)):
    for j in range(width(I)):
      if index(I, (i, j)) == 0 and any(index(I, (n, j)) != 0 for n in range(h, height(I))):
        O = fill(O, 2, {(i, j)})
  return O
 
0.045, 3.1098297, def dajbjchdhffcejjiiigdbaijeiddeecc(I):
    # Split the grid horizontally
    top_half, bottom_half = vsplit(I, 2)
    
    # Function to recolor inner parts of objects
    def recolor_half(grid, color_a, color_b):
        objs = objects(grid, T, F, T)
        toggle = T
        O = grid
        for obj in objs:
            new_color = color_a if toggle else color_b
            inner = difference(backdrop(obj), box(obj))
            O = fill(O, new_color, inner)
            toggle = flip(toggle)
        return O

    # Recolor each half with alternating colors
    recolored_top = recolor_half(top_half, 1, 2)
    recolored_bottom = recolor_half(bottom_half, 2, 1)

    # Concatenate the recolored halves
    return vconcat(recolored_top, recolored_bottom)
 
0.32, 44.367073, def eaabcccfdedjefbejhggfaaiecaahccb(I):
    def recolor_object(obj, toggle):
        inner = difference(backdrop(obj), box(obj))
        new_color = 1 if (uppermost(inner) < len(I) // 2) == toggle else 2
        return recolor(new_color, inner)

    objs = objects(I, T, F, T)
    recolored_objs = tuple(recolor_object(obj, i % 2 == 0) for i, obj in enumerate(objs))
    return paint(canvas(0, shape(I)), merge(recolored_objs))
 
0.055, 3.0782387, def didaeeeeffffehffidfeedbdiffbdccf(I):
  def process_half(grid, color):
    largest_obj = argmax(objects(grid, T, F, T), size)
    fill_area = difference(backdrop(largest_obj), box(largest_obj))
    return fill(grid, color, fill_area)

  top = process_half(tophalf(I), 1)
  bottom = process_half(bottomhalf(I), 2)
  return vconcat(top, bottom)
 
0.30000000000000004, 39.139988, def ihebddbiahedeabiiaaffdjdebefbgdf(I):
  def fill_largest(grid, color):
    return paint(
      cover(grid, argmax(objects(grid, T, F, T), size)), 
      recolor(color, difference(
        backdrop(argmax(objects(grid, T, F, T), size)),
        box(argmax(objects(grid, T, F, T), size))
      ))
    )
  return vconcat(fill_largest(tophalf(I), 1), fill_largest(bottomhalf(I), 2))
 
0.26, 21.141207, def ccdfibijfegieddejdddcfbfabbfecgf(I):
  output = I
  for half, color in [(tophalf(I), 1), (bottomhalf(I), 2)]:
    largest_obj = argmax(objects(half, T, F, T), size)
    output = paint(
      cover(output, largest_obj),
      recolor(color, difference(backdrop(largest_obj), box(largest_obj)))
    )
  return output
 
0.14500000000000002, 9.827869, def dejeeafcfbbcecceafahedgdeaeicaag(I):
  def process_object(obj, grid, color):
    if size(obj) > 1:
      fill_area = difference(backdrop(obj), box(obj))
      grid = fill(grid, color, fill_area)
    return grid

  output = I
  for i, half in enumerate([tophalf(I), bottomhalf(I)]):
    for obj in objects(half, T, F, T):
      output = process_object(obj, output, i + 1)
  return output
 
0.155, 5.2961593, def gaccbjfbfbjhefaiiaihfifeeciddbhh(I):
  objs = objects(I, T, F, T)
  top_obj = argmax(objs, lambda obj: uppermost(obj) if uppermost(obj) < len(I) // 2 else -1)
  bottom_obj = argmin(objs, lambda obj: uppermost(obj) if uppermost(obj) >= len(I) // 2 else len(I))

  top_center_i, top_center_j = centerofmass(top_obj)
  top_patch = frozenset({(top_center_i, top_center_j - 1),
                         (top_center_i, top_center_j),
                         (top_center_i + 1, top_center_j - 1),
                         (top_center_i + 1, top_center_j)})

  bottom_patch = frozenset((i, j) 
                                for i in range(uppermost(bottom_obj), 
                                               uppermost(bottom_obj) + height(bottom_obj) // 2) 
                                for j in range(leftmost(bottom_obj), rightmost(bottom_obj) + 1))

  I = paint(I, recolor(1, top_patch))
  I = paint(I, recolor(2, bottom_patch))
  return I 
 
0.195, 7.854777, def bcibhegefccfedabjbcffdcceeedghed(I):
  objs = objects(I, T, F, T)
  top_obj = argmax(objs, lambda obj: uppermost(obj) if uppermost(obj) < len(I) // 2 else -1)
  bottom_obj = argmin(objs, lambda obj: uppermost(obj) if uppermost(obj) >= len(I) // 2 else len(I))

  top_center_i, top_center_j = centerofmass(top_obj)
  top_patch = frozenset({(top_center_i, top_center_j - 1),
                         (top_center_i, top_center_j),
                         (top_center_i + 1, top_center_j - 1),
                         (top_center_i + 1, top_center_j)})
  
  bottom_patch = crop(I, (uppermost(bottom_obj), leftmost(bottom_obj)), 
                        (height(bottom_obj) // 2, width(bottom_obj)))
  bottom_patch = asindices(bottom_patch) 
  
  I = paint(I, recolor(1, top_patch))
  I = paint(I, recolor(2, bottom_patch))
  return I
 
0.165, 5.632756, def bcibjeccbjdbehfhjeffecieffdcjbib(I):
  objs = objects(I, T, F, T)

  for i, obj in enumerate(objs):
    if i == 0:
      center_i, center_j = centerofmass(obj)
      patch = frozenset({(center_i, center_j - 1),
                           (center_i, center_j),
                           (center_i + 1, center_j - 1),
                           (center_i + 1, center_j)})
      I = paint(I, recolor(1, patch))
    else:
      bottom_patch = frozenset((i, j) 
                                    for i in range(uppermost(obj), 
                                                   uppermost(obj) + height(obj) // 2) 
                                    for j in range(leftmost(obj), rightmost(obj) + 1))
      I = paint(I, recolor(2, bottom_patch))
  return I
 
0.055, 13.864814, def abjacffbcjgfegcajbbjcbdigiegjajj(I):
  """
  Iterates through objects, determines their position relative to the grid's
  center, and recolors inner cells accordingly.
  """
  O = I
  center_row = height(I) // 2
  for obj in objects(I, T, F, T):
    if uppermost(obj) >= center_row:
      O = fill(O, 2, difference(backdrop(obj), box(obj)))
    elif lowermost(obj) < center_row:
      O = fill(O, 1, difference(backdrop(obj), box(obj)))
  return O
 
0.245, 24.196066, def bdigdefdffeeejdfabeecjcaebdffabg(I):
  """
  Leverages the 'apply' function to apply a recoloring function to each 
  object in the input grid.
  """
  center_row = height(I) // 2
  def recolor_object(obj):
    return recolor(
        1 if lowermost(obj) < center_row else 2 if uppermost(obj) >= center_row else color(obj), 
        obj
    )
  return paint(
      canvas(mostcolor(I), shape(I)), 
      merge(apply(recolor_object, objects(I, T, F, T)))
  )
 
0.055, 3.0782387, def dbefhabheifgeidaafejbecabbahbaff(I):
  """
  Divides the grid into top and bottom halves, processes each half separately,
  and then combines them.
  """
  top = Program_to_be_generated_half(tophalf(I), 1)
  bottom = Program_to_be_generated_half(bottomhalf(I), 2)
  return vconcat(top, bottom)
 
0.08499999999999999, 3.3714418, def ebaeeebdjbjeeafabggegddecbjbdifc(grid):
  objs = colorfilter(objects(grid, T, F, T), FOUR)
  top_objs = sfilter(objs, lambda obj: uppermost(obj) < len(grid) // 2)
  bottom_objs = sfilter(objs, lambda obj: uppermost(obj) >= len(grid) // 2)
  out = grid
  for i, obj in enumerate(merge((top_objs, bottom_objs))):
    new_color = 1 + ((i + (obj in bottom_objs)) % 2)
    out = fill(out, new_color, difference(backdrop(obj), box(obj)))
  return out
 
0.22, 9.766211, def gacdefaadfbfeiddbijbbbeibjjacecc(grid):
  out = grid
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val == FOUR and index(grid, add((i, j), (1, 1))) == ZERO:
        new_color = 1 + ((i // (len(grid) // 2)) ^ (j // (len(row) // 2)))
        out = fill(out, new_color, {(i, j)})
  return out
 
0.325, 21.325186, def cfdfecdcfcgaeiejifaiecgdhbchaacb(I):
  h = len(I)
  return tuple(
    tuple(
      1 if (i < h // 2) and (I[i][j] != 0) else (2 if (i >= h // 2) and (I[i][j] != 0) else I[i][j]) 
      for j in range(len(I[0]))
    )
    for i in range(h)
  )
 
0.03, 5.200621, def bbbaagbfaceeejecajafdfefjeeccaae(I):
  def process_object(obj, count):
    def get_inner_area(obj):
      return difference(backdrop(toindices(obj)), box(toindices(obj)))
    return fill(I, count, get_inner_area(obj))
  return list(map(lambda x: process_object(x[1], x[0] + 1), enumerate(objects(I, T, F, T))))[-1]
 
0.155, 3.99413, def fhdbbbdafdecefcgbgiabfcibcdbehef(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if uppermost(obj) < len(I) // 2:
      I = fill(I, 1, connect((uppermost(obj) + 1, (leftmost(obj) + rightmost(obj)) // 2 - 1),
                      (lowermost(obj) - 1, (leftmost(obj) + rightmost(obj)) // 2 - 1)))
      I = fill(I, 1, connect((uppermost(obj) + 1, (leftmost(obj) + rightmost(obj)) // 2),
                      (lowermost(obj) - 1, (leftmost(obj) + rightmost(obj)) // 2)))
    else:
      I = fill(I, 2, 
               frozenset((i, j) for i in range(uppermost(obj), uppermost(obj) + height(obj) // 2)
                                for j in range(leftmost(obj), rightmost(obj) + 1)))
  return I
 
0.16, 13.496697, def ifaffdbfbedcehffjgeecfcacbceaabe(I):
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      if I[i][j] != 0:
        if i < h // 2:
          if j in range((w // 2) - 1, (w // 2) + 1):
            I = fill(I, 1, frozenset({(i,j)}))
        else:
          if i < (uppermost(frozenset({(i,j)})) + height(frozenset({(i,j)})) // 2):
            I = fill(I, 2, frozenset({(i,j)}))
  return I
 
0.365, 12.655178, def dadgdcabfafjeebfabjddbbcihbfdcdd(I):
  top = tophalf(I)
  bottom = bottomhalf(I)
  top = fill(top, 1, connect((1, len(top[0]) // 2 - 1), (len(top) - 2, len(top[0]) // 2 - 1)))
  top = fill(top, 1, connect((1, len(top[0]) // 2), (len(top) - 2, len(top[0]) // 2)))
  bottom = fill(bottom, 2, frozenset((i, j) for i in range(height(bottom) // 2) for j in range(len(bottom[0]))))
  return vconcat(top, bottom)
 
0.06, 1.704354, def gbaccabgahaeecafiaabbbfcfhcaifac(I):
  """
  Iterates through objects and recolors inner cells based on their position relative to the grid's center.
  """
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    if uppermost(obj) < center_row:
      O = fill(O, 2, difference(backdrop(obj), box(obj)))
    else:
      O = fill(O, 1, difference(backdrop(obj), box(obj)))
  return O
 
0.105, 18.182415, def jfceafbdiidceijdjccddggdefjhaadc(I):
  """
  Employs a functional approach with 'apply' and a custom recoloring function.
  """
  center_row = height(I) // 2
  def recolor_object(obj):
    if uppermost(obj) < center_row:
      return fill(I, 2, difference(backdrop(obj), box(obj)))
    else:
      return fill(I, 1, difference(backdrop(obj), box(obj)))
  return last(apply(recolor_object, objects(I, T, F, T)))
 
0.075, 17.066202, def ccbcjaabdjjdegjejggghabhejbbfbeh(I):
  # Find all objects with color 4
  objs = colorfilter(objects(I, T, F, T), FOUR)
  # Initialize output grid and color toggles
  O = I
  top_toggle = T 
  bottom_toggle = F
  # Iterate through objects, recoloring based on position
  for obj in objs:
    if uppermost(obj) < len(I) // 2:  # Object in top half
      new_color = FOUR if top_toggle else TWO
      top_toggle = flip(top_toggle)
    else:  # Object in bottom half
      new_color = ONE if bottom_toggle else TWO
      bottom_toggle = flip(bottom_toggle)
    O = fill(O, new_color, difference(backdrop(obj), box(obj))) 
  return O
 
0.02, 4.438896, def bbfcifgbafjeeceibiciejecaaddebig(I):
  O = I
  for i, obj in enumerate(colorfilter(objects(I, T, F, T), FOUR)):
    new_color = branch(uppermost(obj) < len(I) // 2,
                      branch(even(i), FOUR, TWO),
                      branch(even(i), ONE, TWO))
    inner = difference(backdrop(obj), box(obj))
    O = fill(O, new_color, inner)
  return O 
 
0.01, 1.5289354, def hadacdcfacafedffjcaffbeadhibdbic(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    midpoint = len(I) // 2
    position = 1 if uppermost(obj) < midpoint else 0
    new_color = [FOUR, ONE][position] if even(i) else TWO
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.11499999999999999, 25.916822, def ffcecjddfbjaecbhidcbfcfddaacbfcd(I):
  def process_half(grid, color):
    largest_obj = argmax(objects(grid, T, F, T), size)
    fill_area = difference(backdrop(largest_obj), toindices(largest_obj)) # Directly use toindices
    return fill(grid, color, fill_area)

  top_color = 1 if even(len(I)) else 2 # Determine top color based on height parity
  bottom_color = 3 - top_color # Bottom color is the complement

  top = process_half(tophalf(I), top_color)
  bottom = process_half(bottomhalf(I), bottom_color)
  return vconcat(top, bottom)
 
0.045, 4.14955, def fjfbbefhiffeehbajfagcdaiggffedgg(I):
  def process_half(grid, parity):
    largest_obj = argmax(objects(grid, T, F, T), size)
    fill_color = 1 + parity ^ (uppermost(largest_obj) >= len(I) // 2) # Bitwise XOR for color logic
    return fill(grid, fill_color, difference(backdrop(largest_obj), box(largest_obj)))

  return vconcat(process_half(tophalf(I), even(len(I))), process_half(bottomhalf(I), even(len(I))))
 
0.135, 3.517519, def aiaffejiicfbedibiaabcffhaajaiebd(I):
  objs = objects(I, T, F, T)
  top_obj = argmax(objs, lambda obj: uppermost(obj) * -1)  # Find the highest object
  bottom_obj = argmax(objs, lambda obj: uppermost(obj))  # Find the lowest object
  
  I = fill(I, 1 if uppermost(top_obj) < len(I) // 2 else 2, connect((uppermost(top_obj) + 1, (leftmost(top_obj) + rightmost(top_obj)) // 2), (lowermost(top_obj) - 1, (leftmost(top_obj) + rightmost(top_obj)) // 2)))
  I = fill(I, 1 if uppermost(top_obj) < len(I) // 2 else 2, connect((uppermost(top_obj) + 1, (leftmost(top_obj) + rightmost(top_obj)) // 2 - 1), (lowermost(top_obj) - 1, (leftmost(top_obj) + rightmost(top_obj)) // 2 - 1)))
  I = fill(I, 2 if uppermost(top_obj) < len(I) // 2 else 1, connect((uppermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2), (lowermost(bottom_obj) , (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2)))
  I = fill(I, 2 if uppermost(top_obj) < len(I) // 2 else 1, connect((uppermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1), (lowermost(bottom_obj), (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2 + 1)))
  return I
 
0.08, 3.4514098, def ddaebgbcfjigebiiadecdafadebebdcc(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj)) # sort by uppermost row
  top_obj, bottom_obj = objs[0], objs[1]

  def fill_center(obj, color):
    start = (uppermost(obj) + 1, (leftmost(obj) + rightmost(obj)) // 2 - 1)
    end = (lowermost(obj) - 1, (leftmost(obj) + rightmost(obj)) // 2 + 1)
    return fill(I, color, product(interval(start[0], end[0] + 1, 1), interval(start[1], end[1] + 1, 1)))
  
  color_top = 1 if uppermost(top_obj) < len(I) // 2 else 2
  color_bottom = 2 if color_top == 1 else 1
  I = fill_center(top_obj, color_top)
  I = fill_center(bottom_obj, color_bottom)
  return I
 
0.1, 5.177524, def fbcegfbhabdfedjabefejcciaebfbihc(I):
  objs = objects(I, T, F, T)
  top_obj = argmin(objs, lambda obj: (uppermost(obj), leftmost(obj)))
  bottom_obj = argmax(objs, lambda obj: (uppermost(obj), leftmost(obj)))

  def paint_column(I, obj, color):
    return fill(I, color, 
                 frozenset((i, (leftmost(obj) + rightmost(obj)) // 2 + j)
                          for i in range(uppermost(obj) + 1, lowermost(obj))
                          for j in (-1, 0)))

  top_color = 1 if uppermost(top_obj) < len(I) // 2 else 2
  I = paint_column(I, top_obj, top_color)
  I = paint_column(I, bottom_obj, 3 - top_color)
  return I
 
0.435, 16.94399, def bedgfacbidjhegfaieegfeeididhheab(I):
  """
  Splits the grid horizontally and applies distinct recoloring to each half before merging.
  """
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  top_recolored = fill(top_half, 1, difference(asindices(top_half), box(asindices(top_half))))
  bottom_recolored = fill(bottom_half, 2, difference(asindices(bottom_half), box(asindices(bottom_half))))
  return vconcat(top_recolored, bottom_recolored)
 
0.62, 30.22194, def ichjebghabffegfaagjbhehifagifddd(I):
  """
  Uses a lambda function to apply recoloring based on cell indices and center row comparison.
  """
  center_row = height(I) // 2
  recolor_func = lambda i, j: 2 if i >= center_row else 1 if I[i][j] != mostcolor(I) else mostcolor(I)
  return tuple(tuple(recolor_func(i, j) for j in range(width(I))) for i in range(height(I))) 
 
0.11499999999999999, 25.916822, def djiefegdhgdheffeacaabebedcdejahb(I):
    O = I
    for i in range(len(I) // 2):
        for j, obj in enumerate(colorfilter(objects(crop(I, (i, 0), (1, len(I[0]))), T, F, T), FOUR)):
            O = fill(O, 1 if j % 2 == 0 else 2, difference(backdrop(obj), box(obj)))
    for i in range(len(I) // 2, len(I)):
        for j, obj in enumerate(colorfilter(objects(crop(I, (i, 0), (1, len(I[0]))), T, F, T), FOUR)):
            O = fill(O, 2 if j % 2 == 0 else 1, difference(backdrop(obj), box(obj)))
    return O
 
0.20750000000000002, 20.09674, def ghcfcaafeahbeahhafdchfidbefedfbd(I):
  return totuple(
    totuple(
      i + 1 if (i, j) in difference(backdrop(toindices(obj)), box(toindices(obj))) else v 
      for j, v in enumerate(row)
    ) for i, row in enumerate(I) for obj in objects(I, T, F, T)
  )
 
0.27, 44.542393, def jdeaficdacafeaccjcddjihgjbfagahf(I):
  def paint_area(grid, obj, value):
    return paint(cover(grid, obj), recolor(value, difference(backdrop(toindices(obj)), box(toindices(obj)))))

  O = I
  count = 1
  for obj in objects(I, T, F, T):
    O = paint_area(O, obj, count)
    count += 1
  return O
 
0.12, 12.13778, def hicdbaeefidaedhijgfdifdhbdejbjed(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line(obj, color, width=2):
    mid_col = (leftmost(obj) + rightmost(obj)) // 2
    start_row = uppermost(obj) + height(obj) // 2 
    line = frozenset((row, col) 
                    for row in range(start_row, start_row + (height(obj) // 2 if width == 3 else 1)) 
                    for col in range(mid_col - (width // 2), mid_col + (width // 2) + (width % 2)))  
    return fill(I, color, line)

  I = draw_line(top_obj, 1)  # 2-pixel wide vertical line
  I = draw_line(bottom_obj, 2, width=3)  # 3-pixel wide horizontal line
  return I 
 
0.11000000000000001, 7.289267, def eiedjeddajjcedbcafhiabcbfdjabebc(I):
  objs = objects(I, T, F, T)
  top_obj = min(objs, key=lambda obj: uppermost(obj) + height(obj) // 2)
  bottom_obj = max(objs, key=lambda obj: uppermost(obj) + height(obj) // 2)

  def draw_line(obj, color, direction):
    start = (uppermost(obj) + height(obj) // 2, (leftmost(obj) + rightmost(obj)) // 2)
    return fill(I, color, frozenset(
        {(start[0] + i * direction[0], start[1] + i * direction[1]) for i in range(1, 3)} | {start, (start[0] - direction[0], start[1] - direction[1])}
    ))
  
  I = draw_line(top_obj, 1, (1, 0)) # Vertical line
  I = draw_line(bottom_obj, 2, (0, 1)) # Horizontal line
  return I
 
0.185, 7.702963, def dccdahdbffhfeebdjaejbeccfbgbcehb(I):
  objs = objects(I, T, F, T)
  top_obj = next(obj for obj in objs if uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = next(obj for obj in objs if uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line(obj, color, is_horizontal=False):
    start_row, start_col = uppermost(obj) + height(obj) // 2, (leftmost(obj) + rightmost(obj)) // 2
    if is_horizontal:
      return fill(I, color, frozenset((row, col) for row in range(start_row - 1, start_row + 2) 
                                                  for col in range(leftmost(obj), rightmost(obj) + 1)))
    else:
      return fill(I, color, frozenset({(start_row, start_col), (start_row, start_col - 1),
                                        (start_row + 1, start_col), (start_row + 1, start_col - 1)}))
  
  I = draw_line(top_obj, 1)
  I = draw_line(bottom_obj, 2, is_horizontal=True)
  return I
 
0.195, 8.327131, def accfcidhaaagegeaaebjeaefadciijdd(I):
  objs = objects(I, T, F, T)
  top_obj = argmax(objs, lambda obj: (uppermost(obj) < len(I) // 2) * size(obj))
  bottom_obj = argmax(objs, lambda obj: (uppermost(obj) >= len(I) // 2) * size(obj))

  def line_indices(obj, is_horizontal):
    center_row, center_col = uppermost(obj) + height(obj) // 2, (leftmost(obj) + rightmost(obj)) // 2
    if is_horizontal:
      return ((center_row + i, center_col + j) for i in range(-1, 2) for j in range(-1, width(obj) // 2 + 1))
    else:
      return ((center_row + i, center_col + j) for i in range(-1, height(obj) // 2 + 1) for j in range(-1, 2))

  I = fill(I, 1, frozenset(line_indices(top_obj, False)))
  I = fill(I, 2, frozenset(line_indices(bottom_obj, True)))
  return I
 
0.135, 5.9389, def djbdifhdjbiceehaiaedcbdeifhfcdcd(I):
  """
  Uses a conditional fill based on row index and object presence.
  """
  h = height(I)
  new_grid = I
  for i in range(h):
    for obj in objects(I, T, F, T):
      if i in range(uppermost(obj) + 1, lowermost(obj)):
        new_grid = fill(new_grid, 1 if i < h // 2 else 2, intersection(backdrop(obj), {(i, j) for j in range(width(I))}))
  return new_grid
 
0.057499999999999996, 22.09097, def ecbgbfijdchcegedaabcjebdadieabba(I):
  objs = objects(I, T, F, T)
  mid = len(I) // 2
  top_obj = argmax(sfilter(objs, lambda obj: uppermost(obj) < mid), size)
  bottom_obj = argmax(sfilter(objs, lambda obj: lowermost(obj) >= mid), size)
  return vconcat(
    fill(I, 1 + (len(I) + 1) % 2, difference(backdrop(top_obj), toindices(top_obj))),
    fill(I, 2 - (len(I) + 1) % 2, difference(backdrop(bottom_obj), toindices(bottom_obj)))
  )
 
0.115, 11.319056, def aaddeehbdhcbejadieffgiafcdchaffj(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line(obj, color, vertical=True):
    if vertical:
      start = (uppermost(obj) + height(obj) // 2, (leftmost(obj) + rightmost(obj)) // 2)
      end = (start[0] + 1, start[1])
    else:
      start = (uppermost(obj) + height(obj) // 2, leftmost(obj))
      end = (start[0], rightmost(obj))
    line = connect(start, end)
    return fill(I, color, line)
  
  I = draw_line(top_obj, 1, vertical=True)
  I = draw_line(bottom_obj, 2, vertical=False)
  return I
 
0.115, 9.917255, def fbfjihceddeeeccdiaajjjjiecadbceh(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line_segment(obj, color, direction):
    start = center(obj)
    line = frozenset(add(start, multiply(i, direction)) for i in range(-1, 2))
    return fill(I, color, line)

  I = draw_line_segment(top_obj, 1, (0, 1)) 
  I = draw_line_segment(bottom_obj, 2, (1, 0))
  return I
 
0.20750000000000002, 20.09674, def iidgahdabhcaecbgabfjgahefbgaiadg(I):
  """
  Utilizes list comprehension to efficiently fill the areas
  within bounding boxes of detected objects.
  """
  objs = objects(I, T, F, T)
  return tuple(
    tuple(
      i + 1 if (i, j) in difference(backdrop(obj), box(obj)) else v
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
    for obj in objs
  )
 
0.11499999999999999, 25.916822, def dieddjjadeaeefecijdiafecbabccece(I):
  def inner_fill(obj, grid, count):
    return fill(grid, count, difference(backdrop(toindices(obj)), toindices(obj)))
  
  objs = objects(I, T, F, T)
  O = I
  count = 1
  for obj in objs:
    O = inner_fill(obj, O, count)
    count += 1
  return O
 
0.385, 86.21019, def abbegjfagcbcecifagebedhdaabehhfj(I):
  objs = objects(I, T, F, T)
  O = I
  count = 1
  for obj in objs:
    O = paint(cover(O, obj), recolor(count, difference(backdrop(toindices(obj)), toindices(obj))))
    count += 1
  return O
 
0.18, 7.4763327, def dddchcaeiabgedefjfebgfhbjddebeab(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line(obj, color, is_horizontal):
    start_row = uppermost(obj) + height(obj) // 2 - 1 if is_horizontal else uppermost(obj) + height(obj) // 2
    start_col = (leftmost(obj) + rightmost(obj)) // 2 
    return fill(I, color, 
                 frozenset({(start_row + i, start_col + j) 
                           for i in range(3 if is_horizontal else 2) 
                           for j in range(2 if not is_horizontal else width(obj))}))

  I = draw_line(top_obj, 1, is_horizontal=False)
  I = draw_line(bottom_obj, 2, is_horizontal=True)
  return I
 
0.175, 12.576743, def ddagedifieifececaddfhbeiciiccabb(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  vline_indices = connect((uppermost(top_obj) + height(top_obj) // 2, (leftmost(top_obj) + rightmost(top_obj)) // 2), 
                         (uppermost(top_obj) + height(top_obj) // 2 + 1, (leftmost(top_obj) + rightmost(top_obj)) // 2))
  hline_indices = frozenset({(uppermost(bottom_obj) + height(bottom_obj) // 2 - 1 + i, j) 
                                 for i in range(3) 
                                 for j in range(leftmost(bottom_obj), rightmost(bottom_obj) + 1)})

  I = fill(I, 1, vline_indices)
  I = fill(I, 2, hline_indices)
  return I 
 
0.315, 12.824255, def afefiejjhfebefbgaafedhehedegaddb(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  def draw_line(obj, color, offset, is_horizontal):
    mid = (leftmost(obj) + rightmost(obj)) // 2 if is_horizontal else uppermost(obj) + height(obj) // 2
    return fill(I, color, 
                frozenset({(mid + offset + i, j) if is_horizontal else (i, mid + offset + j)
                          for i in range(height(obj) if is_horizontal else 3)
                          for j in range(2 if not is_horizontal else width(obj))}))
  
  I = draw_line(top_obj, 1, offset=height(top_obj) // 2, is_horizontal=False)
  I = draw_line(bottom_obj, 2, offset=height(bottom_obj) // 2 - 1, is_horizontal=True)
  return I
 
0.145, 6.325295, def jjbcedbdebeeegfaibabafjbfacbcbha(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 3)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 3)

  top_mid = (uppermost(top_obj) + height(top_obj) // 2, (leftmost(top_obj) + rightmost(top_obj)) // 2)
  bottom_mid = (uppermost(bottom_obj) + height(bottom_obj) // 2, (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2)

  I = paint(I, recolor(1, connect(top_mid, (top_mid[0] + 1, top_mid[1]))))
  I = paint(I, recolor(1, connect((top_mid[0], top_mid[1] - 1), (top_mid[0] + 1, top_mid[1] - 1))))
  I = paint(I, recolor(2, connect((bottom_mid[0] - 1, bottom_mid[1]), (bottom_mid[0] + 1, bottom_mid[1]))))
  I = paint(I, recolor(2, connect((bottom_mid[0] - 1, bottom_mid[1] - 1), (bottom_mid[0] + 1, bottom_mid[1] - 1))))
  I = paint(I, recolor(2, connect((bottom_mid[0] - 1, bottom_mid[1] + 1), (bottom_mid[0] + 1, bottom_mid[1] + 1))))
  return I
 
0.11499999999999999, 22.066088, def ejfahccbcgfeefcajgdgdfbiheefffee(I):
  """
  Uses a list comprehension to generate a list of filled areas and then
  applies them sequentially to the input grid.
  """
  objs = objects(I, T, F, T)
  filled_areas = [fill(I, i + 1, difference(backdrop(obj), box(obj))) 
                  for i, obj in enumerate(objs)]
  O = I
  for filled_area in filled_areas:
    O = cellwise(filled_area, O, mostcolor(O))
  return O
 
0.11499999999999999, 18.815607, def aiafiaiefgdbegjcaafiffbefdeefdfc(I):
  """
  Utilizes `apply` with a lambda function for a functional approach.
  """
  def fill_object(obj, grid, color_index):
    return fill(grid, color_index, difference(backdrop(obj), box(obj)))

  objs = objects(I, T, F, T)
  return last(
      apply(
          lambda x, o=objs, g=I: fill_object(first(o), g, x + 1),
          interval(0, len(objs), 1),
      )
  )
 
0.065, 2.1356874, def jdebehccijgjehdaicebbddadfgdacgd(I):
  objs = colorfilter(objects(I, T, F, T), 4)
  O = I
  for idx, obj in enumerate(objs):
    new_color = 2 if (uppermost(obj) < len(I) // 2) == (idx % 2 == 0) else 1  
    O = fill(O, new_color, difference(backdrop(obj), box(obj)))
  return O
 
0.30000000000000004, 20.226809, def efgaefeeafdjedhbbfeagbceeebjeaff(I):
    h = height(I)
    return vconcat(
        paint(
            cover(tophalf(I), argmax(objects(tophalf(I), T, F, T), size)), 
            recolor(2 - (h + 1) % 2, argmax(objects(tophalf(I), T, F, T), size))
        ),
        paint(
            cover(bottomhalf(I), argmax(objects(bottomhalf(I), T, F, T), size)),
            recolor(1 + (h + 1) % 2, argmax(objects(bottomhalf(I), T, F, T), size))
        )
    )
 
0.325, 25.508327, def cfddeibjedddehejbfebdcdfiacijabb(I):
  h = height(I)
  top = tophalf(I)
  bottom = bottomhalf(I)
  return vconcat(
    paint(
      fill(top, 0, difference(asindices(canvas(0, shape(top))), toindices(argmax(objects(top, T, F, T), size)))),
      recolor(
        2 - (h + 1) % 2,
        argmax(objects(top, T, F, T), size)
      )
    ),
    paint(
      fill(bottom, 0, difference(asindices(canvas(0, shape(bottom))), toindices(argmax(objects(bottom, T, F, T), size)))),
      recolor(
        1 + (h + 1) % 2,
        argmax(objects(bottom, T, F, T), size)
      )
    )
  )
 
0.14, 5.256319, def ccdfabfdabifefjdiecbccbaddaccjdd(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center_i, center_j = center(toindices(obj))
    fill_value = 1 if center_i < len(I) // 2 else 2
    for i in range(center_i - 1, center_i + 2):
      for j in range(center_j - 1, center_j + 2):
        if (i, j) in toindices(obj):
          O = fill(O, fill_value, {(i, j)})
  return O
 
0.11, 20.001108, def djdfeidfjbfcejeeijbfcbejfdjacfge(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center_loc = centerofmass(obj)
    fill_value = 1 if center_loc[0] < len(I) / 2 else 2
    O = fill(O, fill_value, intersection(toindices(obj), backdrop(shift(initset(center_loc), (1, 1)))) )
  return O
 
0.14, 6.1888785, def baiggbbcacfeehagbgacgaeafbacdbef(I):
  O = I
  for obj in objects(I, T, F, T):
    ci, cj = centerofmass(obj)
    fill_val = 1 if ci < len(I) // 2 else 2
    O = fill(O, fill_val, frozenset((ci + i, cj + j) for i in range(-1, 2) for j in range(-1, 2)) & toindices(obj))
  return O
 
0.755, 16.06815, def idbcgaccjfjbedceaehhajfecfjbfdbd(I):
  def modify_half(half, color):
    largest_obj = argmax(objects(half, T, F, T), lambda obj: len(obj))
    return fill(half, color, difference(
               frozenset((i, j) for i in range(height(half)) for j in range(width(half))), 
               toindices(largest_obj)))
  return vconcat(modify_half(tophalf(I), 1), 
                 modify_half(bottomhalf(I), 2))
 
0.155, 5.5933332, def jbhedaiehdcbeefdbcfihedabfbfagea(I):
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < len(I) // 2 and size(obj) > 1)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= len(I) // 2 and size(obj) > 1)
  center_col_top = (leftmost(top_obj) + rightmost(top_obj)) // 2
  center_col_bottom = (leftmost(bottom_obj) + rightmost(bottom_obj)) // 2
  
  I = fill(I, 1, connect((uppermost(top_obj), center_col_top), (lowermost(top_obj), center_col_top)))
  I = fill(I, 1, connect((uppermost(top_obj), center_col_top + 1), (lowermost(top_obj), center_col_top + 1)))

  I = fill(I, 2, connect((uppermost(bottom_obj), center_col_bottom), (lowermost(bottom_obj), center_col_bottom)))
  I = fill(I, 2, connect((uppermost(bottom_obj), center_col_bottom + 1), (lowermost(bottom_obj), center_col_bottom + 1)))
  return I
 
0.355, 38.526268, def cjieaiaadfhceachjjedbdgcahbbadjb(I):
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for obj in objects(I, T, F, T):
    center_row = uppermost(obj) + height(obj) // 2
    center_col = leftmost(obj) + width(obj) // 2
    color = 1 if center_row < h // 2 else 2
    O = fill(O, color, connect((uppermost(obj), center_col), (lowermost(obj), center_col)))
    O = fill(O, color, connect((uppermost(obj), center_col + 1), (lowermost(obj), center_col + 1)))
  return O
 
0.155, 5.9080944, def dbccibdcfaciefedbdacfcegeeghcjab(I):
  for obj in objects(I, T, F, T):
    c = (leftmost(obj) + rightmost(obj)) // 2
    for i in range(uppermost(obj), lowermost(obj) + 1):
      I = fill(I, 1 if i < len(I) // 2 else 2, frozenset(((i, c), (i, c + 1))))
  return I
 
0.11499999999999999, 4.2683053, def ejbdicfcebadedeabgaadjjebiifcija(I):
  objs = objects(I, T, F, T) 
  O = I
  for obj in objs:
    fill_value = 2 if uppermost(obj) > len(I) // 2 else 1
    outer_shell = box(obj)
    inner_area = difference(toindices(obj), outer_shell)
    O = fill(O, fill_value, inner_area)
  return O
 
0.11499999999999999, 4.1386156, def feggfdihabceedgcjhebbddhiahdffbd(I):
  upper_half = tophalf(I)
  lower_half = bottomhalf(I)
  upper_objs = objects(upper_half, T, F, T)
  lower_objs = objects(lower_half, T, F, T)
  O = I
  for obj in upper_objs:
    O = fill(O, 1, difference(toindices(obj), box(obj)))
  for obj in lower_objs:
    O = fill(O, 2, difference(toindices(obj), box(obj)))
  return O
 
0.135, 14.347179, def ggabhahcfhehefbjidbebfiedbhbeedf(I):
  """
  Iterates through objects, recolors based on position and internal/external cell distinction.
  """
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    if uppermost(obj) < center_row:
      O = fill(O, color(obj), difference(backdrop(obj), box(obj)))
    else:
      O = fill(O, mostcolor(obj), difference(backdrop(obj), box(obj)))
      O = fill(O, leastcolor(obj),  obj)
  return O
 
0.11499999999999999, 3.4337633, def idfeeaeabjcgeebiaffaebgcddacibcf(I):
  """
  Applies a two-step process: recolor all objects, then restore original colors for top objects.
  """
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    periphery_cells = box(obj)
    inner_cells = difference(obj, periphery_cells)
    O = fill(O, leastcolor(obj), inner_cells)
    O = fill(O, mostcolor(obj), periphery_cells)
  for obj in objects(I, T, F, T):
    if uppermost(obj) < center_row:
      O = paint(O, obj)
  return O
 
0.11499999999999999, 4.2683053, def bcjceiejjgfbeacbacadbceceddcfgci(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    inner_area = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      O = fill(O, ONE, inner_area)
    else:
      fill_color = TWO if i % 2 == 0 else FOUR
      O = fill(O, fill_color, inner_area)
  return O
 
0.26, 14.614099, def igfdhfefbgaiehbfbhacgcijcadgfccf(I):
  O = I
  midpoint = len(I) // 2
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == FOUR:
        if i < midpoint:
          O = fill(O, ONE, {(i, j)})
        else:
          O = fill(O, FOUR if (i - midpoint) % 2 == 0 else TWO, {(i, j)})
  return O
 
0.345, 41.91896, def dfdcdidcfbceeeaaifdbeeaeedbaghhi(I):
    objs = objects(I, T, F, T)
    O = canvas(mostcolor(I), shape(I))
    for i, obj in enumerate(objs):
        if color(obj) == FOUR:
            inner = difference(backdrop(obj), box(obj))
            if uppermost(obj) < len(I) // 2:
                O = paint(O, recolor(ONE, inner))
            else:
                fill_color = FOUR if i % 2 == 0 else TWO
                O = paint(O, recolor(fill_color, inner))
        else:
            O = paint(O, obj)
    return O
 
0.425, 23.378973, def abdeeffdcdidedcebhdfhacddhieebhg(I):
    midpoint = len(I) // 2
    top = tophalf(I)
    bottom = bottomhalf(I)
    top = replace(top, FOUR, ONE)
    bottom = tuple(
        tuple(TWO if (i + j) % 2 == 0 else FOUR if v == FOUR else v for j, v in enumerate(row))
        for i, row in enumerate(bottom)
    )
    return vconcat(top, bottom)
 
0.135, 10.842233, def hhdiedejihdfeihgicaajbaggcjaibbc(I):
  # Directly replace the second most common color with the most common color
  O = replace(I, leastcolor(I), mostcolor(I))
  return O
 
0.14500000000000002, 3.8189044, def bdhhebadeaedefddaciiaejhbhdfdfdf(I):
  # Get the indices of the bottom row
  h = height(I)
  bottom_row = {(h-1, j) for j in range(width(I))}
  
  # Get the color at the first cell of the bottom row 
  target_color = index(I, (h-1, 0))
  
  # Fill the bottom row with the target color
  O = fill(I, target_color, bottom_row)
  return O
 
0.09, 5.201946, def bdedecichfcdedfbijdidafdhcfjefcj(I):
  """
  Finds the largest object and fills its inner third with 1 if it's 
  in the top half or 2 if it spans both halves. Smaller objects are 
  handled accordingly.
  """
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  fill_value = 2 if lowermost(largest_obj) >= len(I) // 2 else 1
  third_width = width(largest_obj) // 3
  left_bound = leftmost(largest_obj) + third_width
  right_bound = rightmost(largest_obj) - third_width
  O = fill(I, fill_value, product(interval(uppermost(largest_obj) + 1, lowermost(largest_obj), 1), 
                                     interval(left_bound, right_bound + 1, 1)))
  for obj in objs:
    if obj != largest_obj:
      fill_value = 1 if lowermost(obj) < len(I) // 2 else 2
      third_width = width(obj) // 3
      left_bound = leftmost(obj) + third_width
      right_bound = rightmost(obj) - third_width
      O = fill(O, fill_value, product(interval(uppermost(obj) + 1, lowermost(obj), 1), 
                                       interval(left_bound, right_bound + 1, 1)))
  return O
 
0.11499999999999999, 3.8804011, def bahgabbbceicefccbjcdfdbafghdbhff(I):
  """
  Divides the grid into halves, finds the largest object in each, 
  and fills their inner thirds with distinct values.
  """
  upper_half = tophalf(I)
  lower_half = bottomhalf(I)
  upper_obj = argmax(objects(upper_half, T, F, T), size)
  lower_obj = argmax(objects(lower_half, T, F, T), size)
  O = I
  if size(upper_obj) > 0:
    third_width = width(upper_obj) // 3
    left_bound = leftmost(upper_obj) + third_width
    right_bound = rightmost(upper_obj) - third_width
    O = fill(O, 1, product(interval(uppermost(upper_obj) + 1, lowermost(upper_obj), 1), 
                            interval(left_bound, right_bound + 1, 1)))
  if size(lower_obj) > 0:
    third_width = width(lower_obj) // 3
    left_bound = leftmost(lower_obj) + third_width
    right_bound = rightmost(lower_obj) - third_width
    O = fill(O, 2, product(interval(uppermost(lower_obj) + 1 + len(upper_half), lowermost(lower_obj) + len(upper_half), 1), 
                            interval(left_bound, right_bound + 1, 1)))
  return O
 
0.155, 7.241164, def ffjiceficjadefadijecbacehbbeeccf(I):
  """
  Iterates through objects, dynamically determining the fill value based on the 
  object's size and position relative to other objects.
  """
  O = I
  objs = objects(I, T, F, T)
  for obj in objs:
    third_width = width(obj) // 3
    left_bound = leftmost(obj) + third_width
    right_bound = rightmost(obj) - third_width
    fill_value = 1 
    for other_obj in objs:
      if obj != other_obj and size(other_obj) >= size(obj) and lowermost(other_obj) > lowermost(obj):
        fill_value = 2
    O = fill(O, fill_value, product(interval(uppermost(obj) + 1, lowermost(obj), 1), 
                                    interval(left_bound, right_bound + 1, 1)))
  return O
 
0.125, 5.1974535, def fbegbfgefadaeajjjbfcaaabccaeeeac(I):
  """
  Uses the center of mass of each object to decide the fill value.
  """
  O = I
  for obj in objects(I, T, F, T):
    center_i, _ = centerofmass(obj)
    fill_value = 2 if center_i >= len(I) // 2 else 1
    third_width = width(obj) // 3
    left_bound = leftmost(obj) + third_width
    right_bound = rightmost(obj) - third_width
    O = fill(O, fill_value, product(interval(uppermost(obj) + 1, lowermost(obj), 1), 
                                    interval(left_bound, right_bound + 1, 1)))
  return O
 
0.11499999999999999, 3.4337633, def ecafiaaabhjeeibdacbdffdfbddjfcdf(I):
  """
  Analyzes the grid row by row, changing the fill value based on 
  the previously encountered largest object.
  """
  O = I
  largest_obj_bottom = 0
  for i in range(len(I)):
    row_objs = objects(crop(I, (i, 0), (1, len(I[0]))), T, F, T)
    for obj in row_objs:
      if lowermost(obj) > largest_obj_bottom:
        largest_obj_bottom = lowermost(obj)
      third_width = width(obj) // 3
      left_bound = leftmost(obj) + third_width
      right_bound = rightmost(obj) - third_width
      fill_value = 2 if i > len(I) // 2 and largest_obj_bottom >= len(I) // 2 else 1
      O = fill(O, fill_value, product(interval(uppermost(obj) + 1, lowermost(obj), 1), 
                                      interval(left_bound, right_bound + 1, 1)))
  return O
 
0.09, 4.8471117, def bcceicajfihaehieacfaficacegeicbd(I):
  O = I
  for i, obj in enumerate(colorfilter(objects(I, T, F, T), FOUR)):
    inner_indices = difference(backdrop(obj), box(obj))
    color_pattern = (ONE, ONE) if (uppermost(obj) < len(I) // 2) == (i % 2 == 0) else (TWO, FOUR)
    for j, index in enumerate(inner_indices):
        O = fill(O, color_pattern[j % 2], {index})
  return O
 
0.32, 53.792202, def fdfabebcfcieebedajgciccgefibddgh(I):
  def color_logic(i, j, obj_idx, is_top):
    return ONE if is_top and obj_idx % 2 == 0 else (
        TWO if is_top else (
            (FOUR, ONE, ONE, FOUR)[j % 4] if obj_idx % 2 == 0 else 
            (FOUR, TWO, TWO, FOUR)[j % 4]
        )
    )

  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = canvas(ZERO, shape(I))
  for obj_idx, obj in enumerate(objs):
    for i, row in enumerate(I):
      for j, val in enumerate(row):
        is_top = i < len(I) // 2
        if (i, j) in difference(backdrop(obj), box(obj)):
          O = fill(O, color_logic(i, j, obj_idx, is_top), {(i, j)})
        elif (i, j) in obj:
          O = fill(O, FOUR, {(i, j)})
  return O
 
0.095, 8.443389, def ffaahefchdeeebiibjacibiagfihfghb(I):
  # Create a mask of non-background cells
  mask = difference(asindices(I), ofcolor(I, mostcolor(I)))

  # Define a recursive function to find connected cells
  def flood_fill(loc, visited=None):
    if visited is None:
      visited = set()
    if loc in visited or loc not in mask:
      return visited
    visited.add(loc)
    for n in dneighbors(loc):
      flood_fill(n, visited)
    return visited

  # Start flood fill from the bottom-center cell
  bottom_cell = (height(I) - 1, width(I) // 2)
  target_indices = flood_fill(bottom_cell)

  # Get the color of the topmost cell in the connected component
  top_color = index(I, (uppermost(target_indices), leftmost(target_indices)))

  # Recolor the connected component and paint it on the grid
  O = paint(I, recolor(top_color, target_indices))
  return O
 
0.2, 7.114915, def hafabjaabjfieaaebebcjecfachgccgg(I):
  O = I
  for obj in objects(I, T, F, T):
    top, left = ulcorner(obj)
    height, width = shape(obj)
    third_height = height // 3
    fill_value_middle = 2 if top + height // 2 > len(I) // 2 else 1
    fill_value_bottom = index(I, (top + 2 * third_height, left)) if top + height // 2 > len(I) // 2 else 2
    for i in range(third_height, 2 * third_height):
      for j in range(width):
        O = fill(O, fill_value_middle, {(top + i, left + j)})
    for i in range(2 * third_height, height):
      for j in range(width):
        O = fill(O, fill_value_bottom, {(top + i, left + j)})
  return O 
 
0.11499999999999999, 3.4337633, def hefddgbhfahbeahdjjgcfejdidiiieja(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    if uppermost(obj) > len(I) // 2:  # Target the lower object
      inner_indices = difference(backdrop(obj), box(obj))
      for j, index in enumerate(inner_indices):
        O = fill(O, FOUR if j % 2 == 0 else TWO, {index}) # Alternate 4 and 2
  return O
 
0.11499999999999999, 4.1203847, def jfhbhddbbhciedffijjebeeegaefahfi(I):
  O = I
  for obj in colorfilter(objects(I, T, F, T), FOUR):
    if lrcorner(obj)[0] > len(I) // 2: # Target lower object based on corner
      O = fill(O, FOUR, difference(backdrop(obj), box(obj))) # Fill with 4s
      for j in range(uppermost(obj) + 2, lowermost(obj)): # Fill middle row with 2s
        O = fill(O, TWO, {(j, leftmost(obj) + 1)}) 
  return O
 
0.16, 6.8105683, def ejbacbdeigigejbfaeheaeidcddgcdeh(I):
  O = I
  lower_obj = extract(colorfilter(objects(I, T, F, T), FOUR), lambda obj: lrcorner(obj)[0] > len(I) // 2)
  if lower_obj:
    inner_grid = crop(I, (uppermost(lower_obj) + 1, leftmost(lower_obj) + 1), (height(lower_obj) - 2, width(lower_obj) - 2))
    filled_grid = tuple(tuple(FOUR if i % 2 == 0 else TWO for j in range(len(inner_grid[0]))) for i in range(len(inner_grid)))
    O = paint(O, toobject(backdrop(lower_obj), fill(canvas(ZERO, shape(I)), ONE, difference(backdrop(lower_obj), box(lower_obj)))))
    O = paint(O, toobject(shift(backdrop(lower_obj), (1, 1)), filled_grid))
  return O
 
0.08499999999999999, 6.750624, def fbaafahcjjefebhcidbeacbaeefcecef(I):
  target_color = FOUR
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if color(obj) == target_color and lowermost(obj) >= len(I) // 2:
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          if (i - uppermost(obj)) % 2 == 0:
            O = fill(O, target_color, {(i, j)})
          else:
            O = fill(O, TWO, {(i, j)})
  return O 
 
0.1, 4.9537396, def iehcaajahidjedbeieiifdbhffedbibj(I):
  O = I
  for obj in colorfilter(objects(I, T, F, T), FOUR):
    top = uppermost(obj) 
    bottom = lowermost(obj)
    left = leftmost(obj)
    right = rightmost(obj)
    if bottom >= len(I) // 2:
      for i in range(top + 1, bottom):
        for j in range(left + 1, right):
          O = fill(O, FOUR if (i - top) % 2 == 1 else TWO, {(i, j)})
  return O
 
0.11499999999999999, 21.270538, def gfcdgjfffcfeegbgiahbbiaaheddagef(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    outer_layer = box(toindices(obj))
    inner_layer = toindices(obj) - outer_layer
    col = color(obj)
    if col == TWO:
      I = paint(I, recolor(FOUR, toindices(obj)))
    else:
      I = paint(I, recolor(FOUR, outer_layer))
      I = paint(I, recolor(col - ONE, inner_layer)) 
  return I
 
0.095, 7.1532435, def eagdcbgichdbeafhjhcbaicadcfifeia(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    c = color(obj)
    if c == ONE: 
      continue
    I = paint(I, recolor(FOUR if c == TWO else c, box(toindices(obj))))
    if c != ONE:
      I = paint(I, recolor(c-1, toindices(obj)-box(toindices(obj))))
  return I
 
0.22999999999999998, 11.416679, def bjfddffbifcbebcfjdccehbhacbfifif(I):
  O = I
  for obj in objects(I, T, F, T):
    upper, lower = uppermost(obj), lowermost(obj)
    h = lower - upper + 1
    third_height = h // 3
    O = fill(O, 4, product(interval(upper + third_height, lower - third_height + 1, 1), interval(leftmost(obj), rightmost(obj) + 1, 1)))
    O = fill(O, 2, product(interval(lower - third_height + 1, lower + 1, 1), interval(leftmost(obj), rightmost(obj) + 1, 1)))
  return O
 
0.22, 6.556705, def baebjgfgbccheahcidicjbcggdcfbcae(I):
  O = I
  for obj in objects(I, T, F, T):
    h = height(obj)
    third_height = h // 3
    O = fill(O, 4, product(interval(uppermost(obj) + third_height, uppermost(obj) + 2 * third_height, 1), interval(leftmost(obj), rightmost(obj) + 1, 1)))
    O = fill(O, 2, product(interval(uppermost(obj) + 2 * third_height, lowermost(obj) + 1, 1), interval(leftmost(obj), rightmost(obj) + 1, 1)))
  return O
 
0.19, 8.025794, def bbchiecehdahedecbchhjdaccdjafgdg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    h = height(obj)
    third_height = h // 3
    for i in range(third_height):
      O = underfill(O, 4, shift(obj, (third_height, 0)))
    for i in range(third_height):
      O = underfill(O, 2, shift(obj, (2 * third_height, 0)))
  return O
 
0.315, 30.319447, def dcdbfajhedbeedfdacgccjddfaadahie(I):
  """
  Identifies objects, merges those below the center row, 
  and recolors based on relative positions.
  """
  center_row = height(I) // 2
  objs = objects(I, T, F, T)
  O = I
  for i, obj1 in enumerate(objs):
    for j, obj2 in enumerate(objs):
      if i != j and lowermost(obj1) <= center_row and uppermost(obj2) > center_row:
        O = fill(O, color(obj1), difference(backdrop(combine(obj1, obj2)), box(combine(obj1, obj2))))
        O = fill(O, mostcolor(obj2), difference(obj2, box(obj2)))
  return O 
 
0.28, 30.951384, def gijifcbcjaadegdaijeghjfjjcfafeda(I):
  """
  Uses functional programming to map recoloring logic based on object positions.
  """
  center_row = height(I) // 2
  def recolor(obj1, obj2):
    if lowermost(obj1) <= center_row and uppermost(obj2) > center_row:
      return fill(fill(I, color(obj1), difference(backdrop(combine(obj1, obj2)), box(combine(obj1, obj2)))),
                  mostcolor(obj2), difference(obj2, box(obj2)))
    else:
      return I
  return last(prapply(recolor, objects(I, T, F, T), objects(I, T, F, T)))
 
0.245, 7.1243467, def ccibidefdbijeajfajhebcadddidjeif(I):
  """
  Partitions the grid based on color, then merges and recolors based on position.
  """
  center_row = height(I) // 2
  parts = fgpartition(I)
  O = I
  for i, part1 in enumerate(parts):
    for j, part2 in enumerate(parts):
      if i != j and lowermost(part1) <= center_row and uppermost(part2) > center_row:
        O = fill(O, color(part1), difference(backdrop(combine(part1, part2)), box(combine(part1, part2))))
        O = fill(O, mostcolor(part2), difference(part2, box(part2)))
  return O
 
0.09, 2.760035, def ihafhdeejiacedfhjdbfeaiadadgccig(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    inner_area = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      O = fill(O, ONE if i == 0 else TWO, inner_area) 
    else:
      fill_pattern = [(FOUR, ONE), (FOUR, TWO)][i % 2]
      O = fill(O, fill_pattern[0], inner_area)
      for j in range(1, height(inner_area), 2):
        O = fill(O, fill_pattern[1], shift(inner_area, (j, 0)))
  return O
 
0.235, 8.719277, def fgaedhabaihjecjjbdbdcfcaceedbdfb(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    if uppermost(obj) < len(I) // 2:
      O = fill(O, ONE if i == 0 else TWO, difference(backdrop(obj), box(obj)))
    else:
      inner_grid = crop(I, ulcorner(obj), shape(obj))
      new_inner_grid = tuple(
        tuple(TWO if j % 2 == 1 else v for j, v in enumerate(row)) if i % 2 == 0 else 
        tuple(ONE if j % 2 == 1 else v for j, v in enumerate(row)) 
        for i, row in enumerate(inner_grid)
      )
      O = paint(cover(O, obj), asobject(new_inner_grid))
  return O
 
0.11499999999999999, 25.916822, def dacdbeadegccedfjjecfbihccjeeedah(I):
  for obj in objects(I, T, F, T):
    I = paint(I, recolor(FOUR, box(toindices(obj))))
    if color(obj) == TWO:
      I = underfill(I, TWO, toindices(obj))
  return I
 
0.095, 18.642153, def bghhbfdefecfedahijjeaadfcfhecaaf(I):
  for obj in objects(I, T, F, T):
    indices = toindices(obj)
    I = fill(I, FOUR, backdrop(indices))
    if color(obj) == TWO:
      I = paint(I, recolor(TWO, indices - corners(indices)))
  return I
 
0.125, 4.567202, def gciahbecedfiebhiijgdafecfgihcifa(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) == 1:
      target_pos = add(centerofmass(obj), (1, 0))
      O = move(I, obj, subtract(target_pos, centerofmass(obj)))
    elif color(obj) == 2:
      O = fill(I, 2, backdrop(obj))
  return O 
 
0.125, 3.8134801, def bfhbccbgcaaiefcjieecaecicifacfdh(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) == 1:
      O = paint(I, shift(obj, (1, 0))) 
    elif color(obj) == 2:
      indices = toindices(obj)
      left, right = leftmost(indices), rightmost(indices)
      top = uppermost(indices)
      new_indices = {(top, j) for j in range(left, right + 1)}
      O = fill(I, 2, new_indices)
  return O
 
0.20500000000000002, 9.928416, def daeceggbdbffefdiaggaagajijdjjdah(I):
  one_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == 1)
  two_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == 2)
  O = cover(I, one_obj)
  O = cover(O, two_obj)
  O = paint(O, shift(one_obj, (1, centerofmass(two_obj)[1] - centerofmass(one_obj)[1])))
  O = paint(O, {(2, (uppermost(two_obj), j)) for j in range(leftmost(two_obj), rightmost(two_obj) + 1)})
  return O
 
0.135, 10.835135, def jaecbgafighfebfbbabfbfhgdjgcdfaa(I):
  """
  Splits the grid, identifies objects in each half, recolors inner cells based on color frequencies, 
  and recombines the halves.
  """
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  top_objs = objects(top_half, T, F, T)
  bottom_objs = objects(bottom_half, T, F, T)
  top_color = mostcolor(merge(top_objs))
  bottom_color = leastcolor(merge(bottom_objs))
  modified_top = top_half
  for obj in top_objs:
    modified_top = fill(modified_top, top_color, difference(backdrop(obj), box(obj)))
  modified_bottom = bottom_half
  for obj in bottom_objs:
    modified_bottom = fill(modified_bottom, bottom_color, difference(backdrop(obj), box(obj)))
  return vconcat(modified_top, modified_bottom)
 
0.34, 54.14369, def ffdggbbjdfjeejedabggffaafcddbihj(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(objs):
    inner = difference(backdrop(obj), box(obj))
    fill_value = ONE if i == 0 else TWO
    if uppermost(obj) >= len(I) // 2:
      for j in range(height(inner)):
        for k in range(width(inner)):
          if (j + k) % 2 == (i // 2) % 2:
            O = fill(O, FOUR, {(uppermost(inner) + j, leftmost(inner) + k)})
          else:
            O = fill(O, fill_value, {(uppermost(inner) + j, leftmost(inner) + k)})
    else:
      O = paint(O, recolor(fill_value, inner))
  return O
 
0.145, 8.139032, def ejahhaehhdejeaebicdijbaaaabcabde(I):
    bg = mostcolor(I)
    top = tophalf(I)
    bottom = bottomhalf(I)
    objs = objects(bottom, False, False, True)
    obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
    obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
    if width(obj2) < width(obj4):
        obj2 = recolor(2, backdrop(hconcat(obj2, shift(obj4, (0, width(obj2))))))
    else:
        obj4 = recolor(4, backdrop(hconcat(shift(obj2, (0, width(obj4))), obj4)))
    bottom = paint(fill(bottom, bg, asindices(bottom)), obj2 | obj4)
    O = vconcat(top, bottom)
    return O
 
0.25, 26.400387, def dcbebaafacbfejcdbccddafjcfdabafb(I):
    bg = mostcolor(I)
    top = tophalf(I)
    bottom = bottomhalf(I)
    objs = objects(bottom, False, False, True)
    obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
    obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
    target_indices = backdrop(hconcat(obj2, obj4))
    bottom = paint(fill(bottom, bg, asindices(bottom)), recolor(4, target_indices) | recolor(2, target_indices))
    O = vconcat(top, bottom)
    return O
 
0.155, 8.217111, def ffbaifeceaaaecaiajaccdagebcaefeg(I):
  # Identify objects and their colors
  obj1 = first(objects(I, T, F, T))
  obj2 = last(objects(I, T, F, T))
  col1 = color(obj1)
  col2 = color(obj2)
  
  # Expand the second object horizontally
  O = fill(I, col2, backdrop(toindices(obj2)))
  
  # Shift the first object down and align with the second
  O = fill(O, col1, shift(toindices(obj1), (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])))
  
  return O
 
0.16499999999999998, 12.946834, def fgdejgjicdciejghicdbabafddecdbec(I):
    # Identify the objects based on their colors
    obj1 = next(obj for obj in objects(I, T, F, T) if color(obj) == 1)
    obj2 = next(obj for obj in objects(I, T, F, T) if color(obj) == 2)
    
    # Calculate the horizontal expansion range for obj2
    min_j = leftmost(obj2)
    max_j = rightmost(obj2)
    
    # Expand obj2 horizontally
    O = fill(I, 2, {(i, j) for i, j in asindices(I) if min_j <= j <= max_j and (i, j) in toindices(obj2)})
    
    # Move obj1 downwards and align with obj2
    O = fill(O, 1, shift(toindices(obj1), (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])))
    
    return O
 
0.11499999999999999, 4.2683053, def fbfdbadaaaeheadfaddhibchbihfhdfe(I):
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    inner_cells = difference(backdrop(obj), box(obj))
    if uppermost(obj) < center_row:
      O = fill(O, 1, inner_cells)
    else:
      target_color = mostcommon(list(toobject(obj, I))) if colorcount(I, 2) >= 2 else leastcommon(list(toobject(obj, I)))
      O = fill(O, target_color, inner_cells)
  return O
 
0.11499999999999999, 4.1386156, def eecfaebaigahehfejaecieafdfejgebi(I):
  center_row = height(I) // 2
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  top_recolored = fill(
      top_half, 
      1, 
      merge([difference(backdrop(obj), box(obj)) for obj in objects(top_half, T, F, T)])
  )
  bottom_recolored = fill(
      bottom_half,
      mostcommon(list(asobject(bottom_half))) if colorcount(I, 2) >= 2 else leastcommon(list(asobject(bottom_half))),
      merge([difference(backdrop(obj), box(obj)) for obj in objects(bottom_half, T, F, T)])
  )
  return vconcat(top_recolored, bottom_recolored)
 
0.18, 8.310204, def fbeccffbfijcebdeiechbegdcdaefege(I):
  bg = mostcolor(I)
  top = tophalf(I)
  bottom = bottomhalf(I)
  objs = objects(bottom, False, False, True)
  obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
  obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
  if width(obj2) < width(obj4):
      obj2 = recolor(2, backdrop(obj4))
  else:
      obj4 = recolor(4, backdrop(obj2))
  bottom = paint(fill(bottom, bg, asindices(bottom)), obj2 | obj4)
  O = vconcat(top, bottom)
  return O
 
0.28500000000000003, 18.996565, def jibcddhbiibjeehcjfbagfcbagfceead(I):
  bg = mostcolor(I)
  top = tophalf(I)
  bottom = bottomhalf(I)
  objs = objects(bottom, False, False, True)
  obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
  obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
  max_width = max(width(obj2), width(obj4))
  obj2 = recolor(2, {(2, (i, j)) for i in range(height(obj2)) for j in range(max_width)})
  obj4 = recolor(4, {(4, (i, j)) for i in range(height(obj4)) for j in range(max_width)})
  bottom = paint(fill(bottom, bg, asindices(bottom)), obj2 | obj4)
  O = vconcat(top, bottom)
  return O
 
0.335, 8.285455, def ebfeefdfhadbechbadheeheefaecbhgc(I):
  # Identify objects
  obj1 = next(iter(objects(I, T, F, T)))  # First object
  obj2 = next((obj for obj in objects(I, T, F, T) if obj != obj1), None)  # Second object
  
  # Get object colors
  col1 = color(obj1) 
  col2 = color(obj2)
  
  # Expand the second object horizontally
  O = fill(I, col2, {(i, j) for i, j in asindices(I) if uppermost(obj2) <= i <= lowermost(obj2)})
  
  # Calculate shift amount for alignment
  shift_amount = (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])
  
  # Shift and paint the first object
  O = paint(O, shift(obj1, shift_amount))
  
  return O
 
0.86, 67.089645, def cafiaefabeifefaabfjjiejdjdadaccd(I):
  # Find the two unique objects, excluding the background (0)
  objs = list(objects(I, T, F, T))
  obj1 = objs[0] if color(objs[0]) != 0 else objs[1]
  obj2 = objs[1] if color(objs[1]) != 0 else objs[0]

  # Get object colors
  col1 = color(obj1)
  col2 = color(obj2)

  # Expand the second object horizontally
  O = canvas(col2, (height(I), width(I)))
  
  # Shift and paint the first object
  O = paint(O, shift(obj1, (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])))
  
  return O
 
0.165, 4.76083, def ffjabfbbcbacecbcijcbieigbicchcfi(I):
  # Extract objects directly based on color
  obj1 = next((obj for obj in objects(I, T, F, T) if color(obj) != 0), None)
  obj2 = next((obj for obj in objects(I, T, F, T) if obj != obj1 and color(obj) != 0), None)

  # Expand the second object horizontally
  O = fill(I, color(obj2), backdrop(toindices(obj2)))
  
  # Move the first object to align with the second object
  O = move(O, obj1, (1, centerofmass(obj2)[1] - centerofmass(obj1)[1]))
  
  return O
 
0.45, 19.182072, def cfdcaieadbaeeadhibicdafdgbeciffi(I):
  # Identify objects using a different approach
  obj1 = next((obj for obj in partition(I) if color(obj) != 0), None)
  obj2 = next((obj for obj in partition(I) if obj != obj1 and color(obj) != 0), None)

  # Calculate target indices for the expanded second object
  target_indices = {(i, j) for i in range(height(I)) for j in range(leftmost(obj2), rightmost(obj2) + 1)}

  # Create the output grid
  O = fill(I, color(obj2), target_indices)
  O = paint(O, shift(obj1, (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])))

  return O
 
0.37, 46.79109, def ibececdacijbedehaacbfdaddfddhgdg(I):
  # Identify objects
  objs = list(objects(I, T, F, T))
  obj1 = objs[0] if color(objs[0]) != 0 else objs[1]
  obj2 = objs[1] if color(objs[1]) != 0 else objs[0]

  # Create a blank canvas
  O = canvas(0, (height(I), width(I)))

  # Paint the expanded second object
  O = paint(O, recolor(color(obj2), backdrop(toindices(obj2))))
  
  # Paint the shifted first object
  O = paint(O, shift(obj1, (1, centerofmass(obj2)[1] - centerofmass(obj1)[1])))
  
  return O
 
0.265, 20.481127, def dbcgbbfidijhecgeaacegicfeafcjfda(I):
  """
  This version utilizes 'centerofmass' to determine inner cell recoloring. 
  """
  O = I
  center_row = height(I) // 2
  for obj in objects(I, T, F, T):
    if centerofmass(obj)[0] < center_row:
      O = fill(O, 1, difference(obj, box(obj)))
    else:
      if width(obj) % 2 == 0:
        O = fill(O, 4, difference(obj, box(obj)))
      else:
        O = fill(O, 4, difference(obj, box(obj)) - connect(ulcorner(obj), lrcorner(obj)))
        O = fill(O, 1, connect(ulcorner(obj), lrcorner(obj)))
  return O 
 
0.155, 6.4576354, def bihahcaajcgfefeiahichccaeafgdcce(I):
  """
  This version uses nested loops and conditional recoloring based on row and column indices.
  """
  O = I
  h, w = len(I), len(I[0])
  center_row = h // 2
  for i in range(h):
    for j in range(w):
      if I[i][j] != 0:
        if i < center_row:
          if (i > uppermost(ofcolor(I, I[i][j]))) and (i < lowermost(ofcolor(I, I[i][j]))) and (j > leftmost(ofcolor(I, I[i][j]))) and (j < rightmost(ofcolor(I, I[i][j]))):
            O = fill(O, 1, {(i, j)})
        else:
          if (i > uppermost(ofcolor(I, I[i][j]))) and (i < lowermost(ofcolor(I, I[i][j]))) and (j > leftmost(ofcolor(I, I[i][j]))) and (j < rightmost(ofcolor(I, I[i][j]))):
            if w % 2 == 0:
              O = fill(O, 4, {(i, j)})
            else:
              if j == w // 2:
                O = fill(O, 1, {(i, j)})
              else:
                O = fill(O, 4, {(i, j)})
  return O
 
0.385, 9.154522, def fcafhafcdbjheaagbefdgeddbcjfabcf(I):
  """
  This version employs 'hsplit' to divide the grid and apply recoloring rules separately.
  """
  O = I
  top, bottom = hsplit(I, 2)
  for obj in objects(top, T, F, T):
    O = fill(O, 1, difference(obj, box(obj)))
  for obj in objects(bottom, T, F, T):
    if width(obj) % 2 == 0:
      O = fill(O, 4, difference(obj, box(obj)))
    else:
      O = fill(O, 4, difference(obj, box(obj)) - connect(ulcorner(obj), lrcorner(obj)))
      O = fill(O, 1, connect(ulcorner(obj), lrcorner(obj)))
  return O
 
0.21000000000000002, 12.302621, def bbcbdefgfbffedbejebdefdafjbfadff(I):
    bg = mostcolor(I)
    top = tophalf(I)
    bottom = bottomhalf(I)
    objs = objects(bottom, False, False, True)
    obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
    obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
    if len(obj2) < len(obj4):
        target = obj4
        replace_color = 2
    else:
        target = obj2
        replace_color = 4
    bottom = underpaint(fill(bottom, bg, asindices(bottom)), recolor(replace_color, backdrop(target)))
    O = vconcat(top, bottom)
    return O
 
0.13, 3.6725936, def fdebcacfejbgecfiafbgadcbfgaddcfc(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for obj in objs:
    if centerofmass(obj)[0] >= len(I) // 2:
      for i, row in enumerate(subgrid(obj, I)):
        if i < len(subgrid(obj, I)) // 2:
          O = fill(O, FOUR, asindices(crop(subgrid(obj, I), (i, 0), (1, len(row)))))
        else:
          O = fill(O, ONE, asindices(crop(subgrid(obj, I), (i, 0), (1, len(row)))))
  return O
 
0.145, 13.566966, def heghedibcfiaebffifhfgdcjadfaadce(I):
    bg = mostcolor(I)
    top = tophalf(I)
    bottom = bottomhalf(I)
    objs = objects(bottom, False, False, True)
    obj2 = next((obj for obj in objs if color(obj) == 2), frozenset())
    obj4 = next((obj for obj in objs if color(obj) == 4), frozenset())
    target_width = max(width(obj2), width(obj4))
    obj2_indices = toindices(obj2)
    obj4_indices = toindices(obj4)
    new_obj2_indices = {(i, j) for i, _ in obj2_indices for j in range(leftmost(obj2), leftmost(obj2) + target_width)}
    new_obj4_indices = {(i, j) for i, _ in obj4_indices for j in range(leftmost(obj4), leftmost(obj4) + target_width)}
    bottom = paint(fill(bottom, bg, asindices(bottom)), 
                   recolor(2, new_obj2_indices) |
                   recolor(4, new_obj4_indices))
    O = vconcat(top, bottom)
    return O
 
0.11499999999999999, 11.501832, def fefjgibdgajfeadbieejccbddcdfehcg(I):
  for i in range(len(I) // 2, len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        obj = extract(objects(I, T, F, T), lambda obj: contained((i, j), toindices(obj)))
        hole = difference(backdrop(toindices(obj)), toindices(obj))
        I = fill(I, I[i][j], hole)
        for pi, pj in hole:
          if I[pi][pj] != I[i][j]:
            inner_obj = extract(objects(I, T, F, T), lambda obj: contained((pi, pj), toindices(obj)))
            new_color = 2 if pi == lowermost(inner_obj) else 1
            I = paint(I, recolor(new_color, toindices(inner_obj)))
  return I
 
0.11499999999999999, 3.4337633, def chcjfghgedbcefafididchffddedbahd(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if uppermost(obj) > len(I) // 2:
      inner_objs = sfilter(objs, lambda o: contained(ulcorner(o), difference(backdrop(toindices(obj)), toindices(obj))))
      I = fill(I, color(obj), difference(backdrop(toindices(obj)), toindices(obj)))
      for inner_obj in inner_objs:
        new_color = 2 if uppermost(inner_obj) == uppermost(obj) + 1 else 1
        I = paint(I, recolor(new_color, toindices(inner_obj)))
  return I
 
0.215, 5.128223, def bifjaabedjbfegadaiieaaeahbccegbe(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  for obj in objs:
    if uppermost(obj) > len(I) // 2:
      for i, j in toindices(obj):
        if I[i][j] == bg:
          I = fill(I, color(obj), {(i, j)})
        else:
          inner_obj = extract(objs, lambda o: contained((i, j), toindices(o)))
          new_color = 2 if i == lowermost(inner_obj) else 1
          I = paint(I, recolor(new_color, {(i, j)}))
  return I
 
0.23, 4.6519938, def gddcadbdeaefebcdjbbejedfdahdhbda(I):
  for i in range(len(I) // 2, len(I)):
    obj = None
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        if obj is None:
          obj = extract(objects(I, T, F, T), lambda o: contained((i, j), toindices(o)))
        if (i, j) in difference(backdrop(toindices(obj)), toindices(obj)):
          I = fill(I, color(obj), {(i, j)})
        else:
          new_color = 2 if i == lowermost(obj) - 1 else 1
          I = paint(I, recolor(new_color, {(i, j)})) 
  return I
 
0.11499999999999999, 11.501832, def iecaeaeggaegeeedaabifcjfgicdabbi(I):
  """
  Uses 'apply' and a lambda function for recoloring based on object's center. 
  """
  return last(apply(
      lambda obj: fill(
          I, 
          mostcolor(obj) if (uppermost(obj) + lowermost(obj)) // 2 < (height(obj) // 2) else leastcolor(obj), 
          difference(backdrop(obj), box(obj))
      ), 
      objects(I, T, F, T)
  ))
 
0.11499999999999999, 4.2683053, def ciffdbjbhcaiegbgjigaidbfegfbefbb(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    inner_area = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      O = fill(O, ONE, inner_area)
    else:
      fill_value = FOUR if even(i // 2) else TWO
      O = fill(O, fill_value, shift(inner_area, (0, 0)))
      for j in range(1, height(inner_area) // 2 + (height(inner_area) % 2), 2):
          O = fill(O, TWO if fill_value == FOUR else FOUR, shift(inner_area, (j * 2, 0)))
  return O
 
0.11499999999999999, 3.4337633, def ibdfebffjfbdeabbbjdeggfebghjcaef(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == FOUR and contained((i, j), difference(backdrop(extract(colorfilter(objects(I, T, F, T), FOUR), lambda x: True)), box(extract(colorfilter(objects(I, T, F, T), FOUR), lambda x: True)))):
        if i < len(I) // 2:
          O = fill(O, ONE, {(i, j)} )
        else:
          fill_value = FOUR if even(i // 2) else TWO
          O = fill(O, fill_value, {(i, j)})
          if not even(i - len(I) // 2):
            O = fill(O, TWO if fill_value == FOUR else FOUR, {(i + 1, j)})
  return O
 
0.255, 23.47292, def bdejdicebbcdebiejcafjfdeajchfiah(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  O = I
  for i, obj in enumerate(objs):
    if uppermost(obj) < len(I) // 2:
      O = paint(cover(O, obj), recolor(ONE, difference(backdrop(obj), box(obj))))
    else:
      inner_area = difference(backdrop(obj), box(obj))
      for j in range(height(inner_area)):
        fill_value = FOUR if even(i // 2 + j) else TWO
        O = fill(O, fill_value, shift(inner_area, (j, 0)))
  return O
 
0.095, 8.443389, def ebjdcfffjgchefadjbfbdeaeihiedcah(I):
    # Identify objects and filter by color
    objs = objects(I, T, F, T)
    obj_4s = colorfilter(objs, FOUR)
    obj_2s = colorfilter(objs, TWO)
    
    # Apply transformations based on object position
    O = I
    for i, obj in enumerate(obj_4s):
        if uppermost(obj) > len(I) // 2:
            O = fill(O, TWO, inner_indices(obj)) 
    for i, obj in enumerate(obj_2s):
        if uppermost(obj) > len(I) // 2:
            O = replace(O, TWO, FOUR) 
    return O
 
0.06999999999999999, 13.371678, def cbicfgcjbccfefgeiebfcbcibbbfidci(I):
    # Identify all objects in the grid
    objs = objects(I, T, F, T)

    # Apply transformations based on object color and position
    O = I
    for obj in objs:
        if color(obj) == TWO and uppermost(obj) > len(I) // 2:
            O = replace(O, TWO, FOUR)
        elif color(obj) == FOUR:
            new_color = ONE if colorcount(I, ONE) > 0 and uppermost(obj) > len(I) // 2 else TWO
            O = fill(O, new_color, inner_indices(obj))
    return O
 
0.31, 6.107687, def jibbjceebeeaedbfbfeifdfbeahafeca(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == TWO and i > len(I) // 2:
                O = fill(O, FOUR, {(i, j)})
            elif I[i][j] == FOUR:
                new_color = ONE if any(ONE in row for row in I) and i > len(I) // 2 else TWO
                O = fill(O, new_color, {(i, j)})
    return O
 
0.095, 8.443389, def eafcbddadeacefbbagffbceccbbheabb(I):
  obj1 = first(colorfilter(objects(I,T,F,F), FOUR)) 
  obj2 = first(colorfilter(objects(I,T,F,F), TWO))
  O = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return O
 
0.31000000000000005, 12.6021805, def daababhfccafedfhbigibfbffebccade(I):
  objs = fgpartition(I)
  top_obj = argmax(objs, uppermost)
  bottom_obj = argmin(objs, uppermost)
  O = paint(cover(I, bottom_obj), recolor(color(top_obj), bottom_obj))
  return O
 
0.73, 52.39466, def ihacedbfhfceeagbjciadcaiffadccaa(I):
  objs = objects(I,T,F,F)
  bottom_obj = argmin(objs, lambda o: uppermost(o) + leftmost(o)) 
  top_color = index(I, (uppermost(bottom_obj) - 1, leftmost(bottom_obj))) 
  O = paint(cover(I, bottom_obj), recolor(top_color, bottom_obj))
  return O
 
0.295, 18.492445, def cedfieejiedeeadfadeghfebfadbhdde(I):
  for i in range(len(I) // 2, len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I): # Find an object pixel in the bottom half
        obj_color = I[i][j]
        hole = set()
        stack = [(i, j)]
        visited = set()
        while stack: # Flood fill to find the hole
          ci, cj = stack.pop()
          if (ci, cj) in visited or ci < len(I) // 2 or ci >= len(I) or cj < 0 or cj >= len(I[0]) or I[ci][cj] != obj_color:
            continue
          visited.add((ci, cj))
          hole.add((ci, cj))
          stack.extend([(ci+1, cj), (ci-1, cj), (ci, cj+1), (ci, cj-1)])
        I = fill(I, obj_color, hole) # Fill the hole
        inner_obj = extract(objects(I, T, F, T), lambda o: size(intersection(toindices(o), hole)) > 0)  # Find the inner object
        new_color = 2 if lowermost(inner_obj) == i - 1 else 1  # Determine the new color
        I = paint(I, recolor(new_color, toindices(inner_obj)))  # Recolor the inner object
  return I
 
0.1522875816993464, 13.832757, def eafjijjeabacehfgadifffcafibddfhd(I):
  """
  Recolors inner cells using nested list comprehensions and a helper function
  to determine the fill color based on object position.
  """
  center_row = height(I) // 2
  def get_fill_color(i, j, obj):
    return mostcolor(I) if (uppermost(obj) + lowermost(obj)) // 2 < center_row else (leastcolor(obj) if leastcolor(obj) != mostcolor(I) else mostcolor(I))
  return tuple(
      tuple(
          get_fill_color(i, j, obj) if (i, j) in difference(backdrop(obj), box(obj)) else I[i][j]
          for j in range(width(I))
      )
      for i in range(height(I))
      for obj in objects(I, T, F, T) if any((i, j) in toindices(obj) for j in range(width(I)))
  )
 
0.11499999999999999, 9.093813, def fgdbddedfdfeefidadgcaiafadcjbbed(I):
  """
  Uses 'apply' and a separate helper function to apply recoloring to 
  objects based on their center position.
  """
  center_row = height(I) // 2
  def recolor_obj(obj, grid):
    fill_color = mostcolor(grid) if (uppermost(obj) + lowermost(obj)) // 2 < center_row else (leastcolor(obj) if leastcolor(obj) != mostcolor(grid) else mostcolor(grid))
    return fill(grid, fill_color, difference(backdrop(obj), box(obj)))
  return last(totuple(apply(lambda obj: recolor_obj(obj, I), objects(I, T, F, T)))) 
 
0.11499999999999999, 4.2683053, def jdebbgccfcchebdhadedafchdebjfegh(I):
  # Identify '4' objects
  objs = objects(I, T, F, T)
  fours = colorfilter(objs, FOUR)
  # Recolor inner cells based on position and '1' presence
  O = I
  for obj in fours:
    inner = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      new_color = ONE if colorcount(I, ONE) > 0 else TWO
    else:
      new_color = FOUR if colorcount(I, ONE) > 0 else TWO
    O = fill(O, new_color, inner)
  return O 
 
0.21500000000000002, 5.230194, def agdjbijjfhadefcabbigbgchjfaabfef(I):
  # Define function to recolor a single cell
  def recolor_cell(i, j):
    if I[i][j] == FOUR:
      if (i < len(I) // 2 and colorcount(I, ONE) > 0) or (i >= len(I) // 2 and colorcount(I, ONE) == 0):
        return TWO
      elif i < len(I) // 2:
        return ONE
      else:
        return FOUR
    else:
      return I[i][j]

  # Apply recoloring to each cell in the grid
  return tuple(tuple(recolor_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
0.16499999999999998, 7.1117454, def adccgdfbifjcedciibeeacdeeejfedce(I):
    # Split the grid into top and bottom halves
    top = tophalf(I)
    bottom = bottomhalf(I)
    # Apply transformations based on '1' presence
    if colorcount(I, ONE) > 0:
        top = fill(top, ONE, inner_indices(ofcolor(top, FOUR)))
        bottom = fill(bottom, TWO, inner_indices(ofcolor(bottom, FOUR)))
    else:
        top = fill(top, TWO, inner_indices(ofcolor(top, FOUR)))
        bottom = fill(bottom, FOUR, inner_indices(ofcolor(bottom, FOUR)))
    # Concatenate the halves back together
    return vconcat(top, bottom)
 
0.245, 45.794067, def feigijdefbhaebacbeaaagbdahhigcch(I):
  bottom_obj = argmax(fgpartition(I), lambda obj: lowermost(obj) if size(obj)==4 else -1)
  top_color = index(I, (uppermost(bottom_obj) - 1, centerofmass(bottom_obj)[1]))
  O = paint(I, recolor(top_color, backdrop(bottom_obj)))
  return O
 
0.14500000000000002, 5.2345366, def ebccihfaadcdecbbbbfdccgcagbeebje(I):
  objs = objects(I, T, F, T)  
  for obj in objs:
    if uppermost(obj) > len(I) // 2:
      I = fill(I, color(obj), difference(backdrop(toindices(obj)), toindices(obj)))  
      for i, row in enumerate(I):
        if i > uppermost(obj) and i < lowermost(obj):
          for j, val in enumerate(row):
            if val != mostcolor(I) and val != color(obj):
              new_color = 2 if i == lowermost(obj) - 1 else 1
              I = paint(I, recolor(new_color, {(val, (i, j))}))
  return I
 
0.195, 11.482062, def jbcbbffdedededbgjbehdgbedaaebfcb(I):
  for i in range(len(I) // 2, len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        obj_color = I[i][j]
        obj = {(obj_color,(i,j))}
        for di in range(-1,2):
          for dj in range(-1,2):
            ni,nj = i+di, j+dj
            if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == obj_color:
                  obj.add((obj_color,(ni,nj)))
        hole = difference(backdrop(toindices(obj)), toindices(obj))
        I = fill(I, obj_color, hole)
        inner_objs = sfilter(objects(I,T,F,T), lambda o: size(intersection(toindices(o), hole)) > 0 and o != obj)
        for inner_obj in inner_objs:
          new_color = 2 if lowermost(inner_obj) == lowermost(obj) - 1 else 1
          I = paint(I, recolor(new_color, toindices(inner_obj)))
  return I
 
0.135, 14.347179, def chgdheffaabfehffiahbbfedcecadgeb(I):
  """
  This version iterates through each object, determines its position relative 
  to the center row, and recolors its inner cells based on the logic 
  described in the Transformation Analysis.
  """
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    if (uppermost(obj) + lowermost(obj)) // 2 < center_row:
      O = fill(O, mostcolor(obj), difference(backdrop(obj), box(obj)))
    else:
      fill_color = leastcolor(obj) if leastcolor(obj) != mostcolor(I) else mostcolor(I)
      O = fill(O, fill_color, difference(backdrop(obj), box(obj)))
  return O
 
0.11499999999999999, 3.4337633, def fifadajebbbaeeadabefffecabafiagd(I):
  """
  This version utilizes list comprehension and conditional logic for 
  a more concise implementation of the recoloring process.
  """
  center_row = height(I) // 2
  return last([fill(I, mostcolor(obj) if (uppermost(obj) + lowermost(obj)) // 2 < center_row else (leastcolor(obj) if leastcolor(obj) != mostcolor(I) else mostcolor(I)), difference(backdrop(obj), box(obj))) for obj in objects(I, T, F, T)])
 
0.095, 3.3958552, def beahagcdfjbaeiddbhgefgdajfgdfbaf(I):
  # Determine new color for inner regions based on '1' presence
  new_color_top = ONE if colorcount(I, ONE) > 0 else TWO
  new_color_bottom = TWO if colorcount(I, ONE) > 0 else ONE
  # Apply transformations to specific regions
  O = fill(I, new_color_top, difference(backdrop(extract(objects(I, T, F, T), lambda obj: uppermost(obj) < len(I) // 2)),
                             box(extract(objects(I, T, F, T), lambda obj: uppermost(obj) < len(I) // 2))))
  O = fill(O, FOUR, box(extract(objects(O, T, F, T), lambda obj: uppermost(obj) >= len(I) // 2)))
  O = fill(O, new_color_bottom, difference(backdrop(extract(objects(O, T, F, T), lambda obj: uppermost(obj) >= len(I) // 2)),
                             box(extract(objects(O, T, F, T), lambda obj: uppermost(obj) >= len(I) // 2))))  
  return O
 
0.135, 14.347179, def ddgebjbcaefcebfdbcddcejbfedibgaa(I):
  target_obj = argmin(
      sfilter(fgpartition(I), lambda obj: color(obj) == leastcolor(I)),
      lambda obj: uppermost(obj)
  )
  top_color = color(
      argmin(
          sfilter(fgpartition(I), lambda obj: color(obj) != leastcolor(I)),
          lambda obj: uppermost(obj)
      )
  )
  box_indices = backdrop(target_obj)
  O = paint(I, recolor(top_color, box_indices))
  return O
 
0.185, 14.387487, def eeffhjfhedejedafabcabjbacbefhbbc(I):
  for i in range(len(I) // 2, len(I)):
    row = I[i]
    if any(v != mostcolor(I) for v in row):
      obj = argmax(objects(crop(I, (i, 0), (len(I) - i, len(I[0]))), T, F, T), size)
      obj_color = color(obj)
      I = fill(I, obj_color, difference(backdrop(toindices(obj)), toindices(obj)))
      inner = argmax(objects(crop(I, (i, 0), (len(I) - i, len(I[0]))), T, F, T), lambda o: size(intersection(toindices(o), toindices(obj))))
      if inner:
        new_color = 2 if lowermost(inner) == lowermost(obj) - 1 else 1
        I = paint(I, recolor(new_color, toindices(inner)))
      return I
  return I
 
0.135, 4.802792, def gbagaabachggeahbjddfdffgaedefacb(I):
  # Create a canvas with the same dimensions as the input
  O = canvas(ZERO, shape(I))
  for obj in colorfilter(objects(I, T, F, T), FOUR):
    # Determine fill color based on object position and '1' presence
    fill_color = ONE if (uppermost(obj) < len(I) // 2) == (colorcount(I, ONE) > 0) else TWO
    # Paint the object outline onto the canvas
    O = paint(O, recolor(FOUR, box(obj)))
    # Fill the inner region with the determined color
    O = paint(O, recolor(fill_color, difference(backdrop(obj), box(obj))))
  return O
 
0.03833333333333334, 17.062595, def egajcjdbbbigebffbhhhdjhfaacccefd(I):
  return merge([fill(I, ONE if (uppermost(obj) < len(I) // 2) == (colorcount(I, ONE) > 0) else TWO, 
                    difference(backdrop(obj), box(obj)))
               for obj in colorfilter(objects(I, T, F, T), FOUR)]) 
 
0.16499999999999998, 5.077391, def dcafecjbbgaeeibhaabcagiaciahddci(I):
  # Find the bottom-right object
  obj = list(objects(I, univalued=False, diagonal=False, without_bg=True))[-1]
  
  # Determine the most common color in the bottom-right object
  target_color = mostcolor(obj)
  
  # Replace all other colors within the object with the target color
  O = paint(cover(I, obj), recolor(target_color, obj))
  return O 
 
0.22499999999999998, 21.946676, def fdbhaadbcahfegbebjebbgjabfbeedbe(I):
  # Directly access the bottom-right corner cell to determine its color
  target_color = I[-1][-1]
  
  # Replace all non-background colors in the bottom four rows with the target color
  O = tuple(tuple(target_color if v != 0 else 0 for v in row) if i >= len(I) - 4 else row for i, row in enumerate(I))
  return O
 
0.385, 86.21019, def aciefdjfhgeeeaccjebagadeahdidajg(I):
  # Partition the grid into objects based on color
  objs = partition(I)
  
  # Identify the object containing the bottom-right corner cell
  target_obj = next(obj for obj in objs if (len(I) - 1, len(I[0]) - 1) in toindices(obj))
  
  # Determine the color of the target object
  target_color = color(target_obj)
  
  # Recolor the target object and paint it back onto a cleared canvas
  O = paint(canvas(0, shape(I)), recolor(target_color, toindices(target_obj)))
  return O
 
0.145, 7.837698, def edageageiadgecdeieacjfgcdaabiiee(I):
  # Identify objects excluding the background
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  
  # Find the object with the largest column index (rightmost)
  target_obj = argmax(objs, rightmost)
  
  # Determine the most common color within the target object
  target_color = mostcolor(target_obj)
  
  # Repaint the target object with a uniform color on the original grid
  O = paint(I, recolor(target_color, toindices(target_obj)))
  return O
 
0.11, 5.341366, def ehaabgbgefaeecbgjhddbaadecfafdcg(I):
  O = canvas(ZERO, shape(I)) # Initialize empty canvas
  for i, obj in enumerate(colorfilter(objects(I, T, F, T), FOUR)):
    O = paint(O, obj) # Paint the object on the canvas
    inner_area = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      O = fill(O, ONE if i == 0 else TWO, inner_area)
    else:
      for j in range(height(inner_area)):
        fill_color = FOUR if even(i + j) else ONE  # Alternating color based on object and row index
        O = paint(O, recolor(fill_color, shift(inner_area, (j, 0))))
  return O
 
0.16999999999999998, 5.8193374, def fddjbbeecbhgejgajfgadefecedgedfa(I):
  O = canvas(ZERO, shape(I))
  for i, obj in enumerate(colorfilter(objects(I, T, F, T), FOUR)):
    O = paint(O, obj)
    inner_area = difference(backdrop(obj), box(obj))
    upper_half_fill = ONE if i == 0 else TWO
    lower_half_fill = FOUR if even(i) else ONE
    for j in range(height(inner_area)):
      fill_color = upper_half_fill if j == 0 and uppermost(obj) < len(I) // 2 else lower_half_fill
      if uppermost(obj) >= len(I) // 2 and not even(i) and even(j): # Stripe condition
        fill_color = FOUR
      O = paint(O, recolor(fill_color, shift(inner_area, (j, 0))))
  return O
 
0.14, 32.570477, def hdcbgaajffacedbfidchfieeddahfhfe(I):
  top_half = I[:len(I) // 2]
  bottom_half = I[len(I) // 2:]
  top_processed = merge(apply(lambda obj: fill(top_half, ONE if colorcount(I, ONE) > 0 else TWO, difference(backdrop(obj), box(obj))), colorfilter(objects(top_half, T, F, T), FOUR)))
  bottom_processed = merge(apply(lambda obj: fill(bottom_half, TWO, difference(backdrop(obj), box(obj))), colorfilter(objects(bottom_half, T, F, T), FOUR)))
  return vconcat(tuple(top_processed), tuple(bottom_processed))
 
0.28, 6.190785, def djahfcfjfdejeejabahdfebccjbdaadc(I):
  twos = ofcolor(I, 2)
  rightmost_two =  max(twos, key=lambda x: x[1])
  expansion_area = backdrop(shift({rightmost_two}, (0, width(twos) - 1)))
  filled_grid = fill(I, 2, expansion_area)
  O = switch(filled_grid, 2, 4)
  return O
 
0.29000000000000004, 5.970909, def dbjdfijdbjfeeahbaddhfdhhcfbajjeg(I):
  O = I
  for j in range(width(I)):
    if index(I, (len(I)-1, j)) == 2:
      for i in range(height(I)):
        if index(I, (i, j)) == 4:
          O = paint(O, recolor(2, {(i, j)}))
  O = switch(O, 2, 4)
  return O
 
0.255, 8.629943, def afebbjeadbceedgcbbcaabhbfidbffef(I):
    target_color = 2
    replace_color = 4
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == target_color:
                for k in range(j + 1, len(I[0])):
                    if I[i][k] == replace_color:
                        I = paint(I, recolor(target_color, {(i, k)}))
    return switch(I, target_color, replace_color)
 
0.34, 54.14369, def facbefcbdecaehicaeccdfbebfeajfib(I):
  O = canvas(ZERO, shape(I))
  for i, obj in enumerate(colorfilter(objects(I, T, F, T), FOUR)):
    inner = difference(backdrop(obj), box(obj))
    if uppermost(obj) < len(I) // 2:
      O = paint(O, recolor(ONE if i == 0 else TWO, inner))
    else:
      O = paint(O, recolor(FOUR, inner))
      if i == 1 and size(colorfilter(objects(I, T, F, T), FOUR)) > 1:  # Specific condition for inner object
        inner_obj = shift(recolor(ONE, difference(backdrop(shift(inner, (1, 1))), box(shift(inner, (1, 1))))), (-1, 0)) # Shifted inner object
        O = paint(O, inner_obj) 
  return O
 
0.22499999999999998, 5.400798, def bbacgffedbdbefdjibbjdjiedfeffcac(I):
  objs = colorfilter(objects(I, T, F, T), FOUR)
  dominant_color = ONE if colorcount(I, ONE) >= colorcount(I, TWO) else TWO
  O = I
  for obj in objs:
    inner = difference(backdrop(obj), box(obj))
    fill_color = dominant_color if uppermost(obj) < len(I) // 2 else (TWO if dominant_color == ONE else ONE)
    O = fill(O, fill_color, inner)
    if uppermost(obj) >= len(I) // 2:
      O = fill(O, fill_color, box(obj))
  return O
 
0.385, 31.4967, def ccedfieahbdfehahbdgcadffbcibffce(I):
  O = canvas(ZERO, shape(I))
  for obj in colorfilter(objects(I, T, F, T), FOUR):
    fill_color = (ONE if colorcount(I, ONE) >= colorcount(I, TWO) else TWO) \
                 if uppermost(obj) < len(I) // 2 \
                 else (TWO if colorcount(I, ONE) >= colorcount(I, TWO) else ONE)
    O = underfill(O, fill_color, difference(backdrop(obj), box(obj)))
    if uppermost(obj) >= len(I) // 2:
      O = paint(O, recolor(fill_color, box(obj)))
  return O
 
0.235, 6.8102856, def gjadjcaaacciegjjjahacdfgdeijheaj(I):
  # Extract the non-background object
  obj = extract(objects(I, False, False, True), lambda o: color(o) != mostcolor(I))
  
  # Determine expansion direction based on object shape
  expansion = (height(obj) - 1, 0) if portrait(obj) else (0, width(obj) - 1)

  # Fill the bounding box of the shifted object with the object's color
  filled = fill(I, color(obj), backdrop(shift(obj, expansion)))

  # Recolor based on expansion direction
  return switch(filled, color(obj), 1 if expansion[0] else 4) 
 
0.385, 17.041151, def aceajjifdebcebfdigbbhfafacgbfjcb(I):
  # Find the non-background object
  obj = extract(objects(I, False, False, True), lambda o: color(o) != mostcolor(I))
  
  # Calculate the bounding box of the object
  bbox = backdrop(obj)

  # Expand the object to fill its bounding box
  expanded_obj = recolor(color(obj), bbox)

  # Paint the expanded object onto the grid
  painted = paint(I, expanded_obj)

  # Determine the recoloring value based on the object's shape
  recolor_value = 4 if portrait(obj) else 1 

  # Switch the original object color with the recolor value within the bounding box
  return switch(painted, color(obj), recolor_value)
 
0.33499999999999996, 47.570644, def jjcfejbecdebehecadcebbfbiejaicjj(I):
  # Find the non-background object
  obj = extract(objects(I, False, False, True), lambda o: color(o) != mostcolor(I))

  # Get the upper-left and lower-right corners of the object's bounding box
  ul = ulcorner(obj)
  lr = lrcorner(obj)

  # Create the grid for the expanded object
  O = canvas(mostcolor(I), shape(I))

  # Iterate through the rows of the bounding box
  for i in range(ul[0], lr[0] + 1):
    # Determine the fill color based on row and object orientation
    fill_color = 4 if (portrait(obj) and (i == ul[0] or i == lr[0])) else \
                  1 if (not portrait(obj) and (i == ul[0] or i == lr[0])) else \
                  color(obj)
    
    # Fill the row within the bounding box
    for j in range(ul[1], lr[1] + 1):
      O = fill(O, fill_color, {(i, j)})

  # Overlay the original grid onto the expanded object
  return cellwise(I, O, fallback=O[0][0])
 
0.275, 14.994242, def dcidbaaeffjhegfcajibdfjcecdejeac(I):
  # Get the bounding box of the non-background object
  bbox = backdrop(extract(objects(I, False, False, True), lambda o: color(o) != mostcolor(I)))

  # Determine the fill color for the border based on bounding box orientation
  border_color = 4 if height(bbox) > width(bbox) else 1

  # Fill the bounding box with the border color
  filled_bbox = fill(I, border_color, bbox)

  # Fill the inside of the bounding box with the original object's color
  filled_inside = underfill(filled_bbox, color(toobject(bbox, I)), bbox)
  
  return filled_inside 
 
0.15, 12.245547, def eaegijcfehebecaabaaddcabhiebjaic(I):
  for i in range(len(I) // 2, len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        obj = extract(objects(I, T, F, T), lambda o: contained((i, j), toindices(o)))
        hole = difference(backdrop(toindices(obj)), toindices(obj))
        if size(hole) > 0:
          I = fill(I, color(obj), hole)
          inner_obj = extract(objects(I, T, F, T), lambda o: size(intersection(toindices(o), hole)) > 0 and o != obj)
          if inner_obj:
            new_color = 2 if lowermost(inner_obj) == lowermost(obj) else 1
            I = paint(I, recolor(new_color, toindices(inner_obj)))
  return I
 
0.075, 4.4671087, def efgfefjieffaehbfaajaidhcjcfedage(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  for obj in objs:
    if color(obj) == 2:
      top = uppermost(obj)
      bottom = lowermost(obj)
      I = fill(I, 4, {(top, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
      I = fill(I, 4, {(bottom, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
      I = fill(I, 2, {(top + 1, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
      I = fill(I, 2, {(bottom - 1, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  return I
 
0.125, 4.4315624, def ebbebaejedigeacfjddddecjaecbibfg(I):
  obj2 = list(objects(I, univalued=True, diagonal=False, without_bg=True))[1]  
  I = paint(I, recolor(4, shift(obj2, (1, 0))))
  I = paint(I, recolor(2, shift(obj2, (-1, 0)))) 
  return I
 
0.14500000000000002, 4.0153003, def cedcjfcccegeebebbiibffagjdfacacb(I):
  def transform_object(obj):
    fill_color = TWO if colorcount(I, ONE) < colorcount(I, TWO) else FOUR
    if uppermost(obj) < len(I) // 2:
      return obj
    else:
      return combine(
          recolor(FOUR, difference(backdrop(obj), box(obj))),
          recolor(fill_color, difference(box(obj), backdrop(shift(obj, (-1, -1)))))
      )
  return paint(I, merge(apply(transform_object, colorfilter(objects(I, T, F, T), FOUR))))
 
0.155, 3.9880369, def aiabbddffdfdecbjjiaagedeeffhcfja(I):
  def transform_cell(i, j):
    for obj in colorfilter(objects(I, T, F, T), FOUR):
      if (i, j) in toindices(obj):
        if uppermost(obj) < len(I) // 2:
          return I[i][j]
        else:
          return FOUR if (i, j) in inbox(obj) else (TWO if colorcount(I, ONE) < colorcount(I, TWO) else FOUR)
    return I[i][j]
  return tuple(tuple(transform_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
0.135, 14.347179, def jaijfceadbcaejecjefeibbecaaagjid(I):
  obj = argmax(objects(I, T, F, T), size)
  fill_value = 4
  outer_area = backdrop(toindices(obj))
  inner_area = difference(outer_area, box(toindices(obj)))
  inner_fill = 2 if lowermost(obj) > len(I) // 2 else 1
  O = fill(I, inner_fill, inner_area)
  O = fill(O, fill_value, outer_area)
  return O
 
0.135, 10.50257, def bbaeaccacjjeefefjdeebjcfdbeahbdc(I):
  obj = argmax(objects(I, T, F, T), size)
  O = I
  for i in range(uppermost(obj), lowermost(obj) + 1):
    for j in range(leftmost(obj), rightmost(obj) + 1):
      if (i, j) in toindices(obj):
        if (i == uppermost(obj) or i == lowermost(obj) or 
            j == leftmost(obj) or j == rightmost(obj)):
          O = fill(O, 4, {(i, j)})
        else:
          O = fill(O, 2 if i > len(I) // 2 else 1, {(i, j)})
      else:
        O = fill(O, 4, {(i, j)})
  return O
 
0.12, 10.646036, def dcadbcecfebeeieebbgeeiggbdcedchg(I):
  obj = argmax(objects(I, T, F, T), size)
  O = fill(I, 4, backdrop(toindices(obj)))
  inner_color = 1 if lowermost(obj) > len(I) // 2 else 2
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if (i, j) in toindices(obj) and (i, j) not in box(toindices(obj)):
        O = fill(O, inner_color, {(i, j)})
  return O
 
0.73, 81.36942, def ajaaijcdebggeedjjjdhihcddabdijfh(I):
  largest_obj = argmax(objects(I, T, F, T), size)
  O = paint(canvas(4, shape(I)), recolor(4, largest_obj))
  inner_fill = lambda loc: 2 if loc[0] > len(I) // 2 else 1
  O = paint(O, recolor(inner_fill, difference(toindices(largest_obj), box(toindices(largest_obj)))))
  return O
 
0.135, 11.942177, def abfjebajfafiecediefjgffihcbaddgg(I):
  """
  Uses a single `fill` operation with a nested conditional for color selection.
  """
  center_row = height(I) // 2
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, lambda x: 2 if centerofmass(obj)[0] < center_row else (4 if x[0] < center_row else 1), 
               difference(backdrop(obj), box(obj)))
  return O
 
0.095, 19.032814, def cibheffeecddeedaicbdihhdcahfdeca(I):
  """
  Finds objects in the lower half of the grid and either recolors them 
  to a solid color or swaps colors and shifts them upwards.
  """
  O = I
  for obj in objects(I, F, F, T):
    if lowermost(obj) >= len(I) // 2:
      if color(obj) == FOUR:
        O = paint(O, recolor(FOUR, obj))  # Solid recolor
      else:
        O = paint(cover(O, obj), shift(recolor(ONE, obj), (-1, 0))) # Color swap & shift
  return O
 
0.21000000000000002, 4.9961557, def jaejcjbbfbeieajfbgebdgejdgbjahde(I):
  """
  Processes the grid row by row, transforming cells based on their 
  color and position relative to the middle row.
  """
  O = tuple(
      tuple(
          (ONE if v == FOUR else FOUR) if (i >= len(I) // 2 and v != ZERO) else v 
          for v in r
      ) for i, r in enumerate(I)
  )
  return O
 
