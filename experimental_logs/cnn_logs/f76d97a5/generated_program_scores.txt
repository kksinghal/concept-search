15.333333333333334, 10.153348, def cbbajijgdacdebccaaacjbgjfbbiefee(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = objects(I, True, False, True)
  border = frozenset((fg, (i, j)) for i in range(len(I)) for j in range(len(I[0])) if i == 0 or j == 0 or i == len(I) - 1 or j == len(I[0]) - 1)
  O = paint(canvas(bg, shape(I)), border)
  for obj in objs:
    if color(obj) == fg:
      O = underpaint(O, obj)
  return O
 
18.333333333333332, 4.2672343, def fecdcfefefbheggejjejdfcbgeeeafec(I):
  mc = mostcommon(I)
  objs = objects(I, T, F, T)
  filtered_objs = sfilter(objs, lambda obj: color(obj) != mc)
  indices_to_fill = mapply(toindices, filtered_objs)
  O = fill(I, 0, indices_to_fill)
  return O
 
7.333333333333333, 37.213856, def dibhbedbfaeeedfdjfiecefheeaaifdf(I):
  bg = mostcolor(I)
  indices = asindices(I)
  cross_indices = mfilter(indices, lambda loc: any(index(I, add(loc, d)) != bg for d in (UP, DOWN, LEFT, RIGHT)))
  O = fill(I, 0, indices - cross_indices)
  return O
 
12.333333333333334, 8.540109, def gaecdfbeaaadefdajeaicebifcfebbba(I):
    objs = objects(I, T, F, F)
    bg_color = mostcolor(I)
    cross = extract(objs, lambda obj: color(obj) == bg_color)
    O = paint(canvas(0, shape(I)), cross)
    return O
 
13.333333333333334, 16.289959, def bcciaajbacbcehiiadfefdbjiccdffai(I):
    objs = objects(I, T, F, T)
    h, w = shape(I)
    ch, cw = h // 2, w // 2
    moved_objs = []
    for obj in objs:
        ci, cj = centerofmass(obj)
        target = (0, cw) if ci < ch and cj < cw else \
                 (h-1, cw) if ci >= ch and cj < cw else \
                 (0, w-1) if ci < ch and cj >= cw else \
                 (h-1, 0)
        offset = subtract(target, centerofmass(obj))
        moved_objs.append(shift(obj, offset))
    O = paint(canvas(mostcolor(I), shape(I)), merge(moved_objs))
    return O
 
14.666666666666666, 18.59937, def bibffhhbaifeeejcbabejdadcbafcdea(I):
    objs = objects(I, T, F, T)
    h, w = shape(I)
    objs = order(objs, size)
    moved_objs = []
    for i, obj in enumerate(objs):
        target = (0, (w // len(objs)) * i)  # Distribute horizontally
        offset = subtract(target, ulcorner(obj))
        moved_objs.append(shift(obj, offset))
    O = paint(canvas(mostcolor(I), shape(I)), merge(moved_objs))
    return O
 
15.0, 32.011593, def cebhaggedaddeidfiecbaacehjgcedif(I):
    objs = objects(I, T, F, T)
    h, w = shape(I)
    moved_objs = []
    for obj in objs:
        color_val = color(obj)
        target = (0, w - color_val) if color_val % 2 == 0 else (h - 1, color_val)
        offset = subtract(target, centerofmass(obj))
        moved_objs.append(shift(obj, offset))
    O = paint(canvas(mostcolor(I), shape(I)), merge(moved_objs))
    return O
 
14.666666666666666, 18.531296, def icbfcaeaficieicbaagaefcffgdeeijb(I):
    objs = objects(I, T, F, T)
    h, w = shape(I)
    objs = order(objs, lambda obj: (color(obj) % 2, size(obj)))  # Sort by even/odd color, then size
    moved_objs = []
    for i, obj in enumerate(objs):
        target = (0, (w // len(objs)) * i) if i % 2 == 0 else (h - 1, (w // len(objs)) * (i // 2))
        offset = subtract(target, ulcorner(obj))
        moved_objs.append(shift(obj, offset))
    O = paint(canvas(mostcolor(I), shape(I)), merge(moved_objs))
    return O
 
16.333333333333332, 30.342783, def fbhagcjiidgaefbbijbhadbhgdjehfef(I):
  bg = mostcolor(I)  
  objs = objects(I, T, F, T)
  expanded_objs = frozenset(frozenset((color(obj), (i + di, j + dj))
                            for di in range(-height(obj), width(obj))
                            for dj in range(-width(obj), height(obj))
                            for c, (i, j) in obj)
                            for obj in objs)
  O = paint(canvas(bg, shape(I)), merge(expanded_objs)) 
  return replace(O, bg, 0)
 
18.0, 39.056145, def cbicdefeeeeeeejbaeafeeeeaecfdadh(I):
  bg = mostcolor(I)
  O = canvas(0, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != bg:
        for di in range(-i, height(I)-i):
          for dj in range(-j, width(I)-j):
            if 0 <= i + di < height(I) and 0 <= j + dj < width(I):
              O = fill(O, I[i][j], {(i + di, j + dj)})
  return O
 
18.666666666666668, 26.073908, def ccbfaecabdfgeffdjcffdhaedfdffefc(I):
  bg = mostcolor(I)
  O = replace(I, bg, 0) 
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != bg:
        for k in range(max(height(I), width(I))):
          if 0 <= i - k < height(I) and 0 <= j - k < width(I): 
            O = fill(O, I[i][j], {(i - k, j - k)})
          if 0 <= i - k < height(I) and 0 <= j + k < width(I):
            O = fill(O, I[i][j], {(i - k, j + k)})
          if 0 <= i + k < height(I) and 0 <= j - k < width(I):
            O = fill(O, I[i][j], {(i + k, j - k)})
          if 0 <= i + k < height(I) and 0 <= j + k < width(I):
            O = fill(O, I[i][j], {(i + k, j + k)})
  return O
 
10.666666666666666, 9.395905, def abafbedcabieedebbfbdjcjejdccbadj(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    center_i, center_j = center(obj)
    for i in range(height(I)):
      for j in range(width(I)):
        if abs(i - center_i) == abs(j - center_j):
          O = fill(O, color(obj), {(i, j)})
  return replace(O, bg, 0)
 
8.666666666666666, 5.202963, def baebhhccjfafecbebdfeedbcdibbaece(I):
  objs = objects(I, T, T, T)
  obj = first(objs)
  bg = mostcolor(difference(asobject(I), obj)) 
  O = fill(I, 0, ofcolor(I, bg))
  return O
 
7.666666666666667, 7.14364, def fceeddedgafeeifbajbbehbcibcjfaeb(I):
  obj = first(objects(I, T, T, T))
  O = paint(canvas(0, shape(I)), obj) 
  return O
 
16.333333333333332, 13.467077, def fjbfhfgfeijdedddagjifcbfeefifhef(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  h, w = len(I), len(I[0])
  O = canvas(bg, (h, w))  # Create a canvas filled with background color
  inner_box = box(((1, 1), (h - 2, w - 2)))  # Get indices of the second outermost layer
  O = fill(O, fg, inner_box)  # Fill the second outermost layer with foreground color
  return O
 
16.666666666666668, 10.499002, def cdjdbhfcdegbehchjejjagicbhfeedcg(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  h, w = len(I), len(I[0])
  O = replace(I, bg, fg)  # Replace all background occurrences with foreground
  O = fill(O, bg, box(((0, 0), (h - 1, w - 1))))  # Fill the outermost layer with background
  return O
 
19.666666666666668, 8.13307, def acgacgafbjbaeeeiafabjdedaaceajga(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  result = I
  for obj in objs:
    indices = box(toindices(obj))
    result = fill(result, color(obj), indices)
  return result
 
15.666666666666666, 9.096185, def fficiebccijjecihafcdaacbecbbhcej(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    filled_grid = canvas(bg, shape(I))
    for obj in objs:
        filled_grid = paint(filled_grid, recolor(color(obj), box(toindices(obj))))
    return filled_grid
 
15.333333333333334, 11.387859, def geabfgffghheedbfibgabiebbbiecich(I):
  # 1. Identify the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # 2. Define target positions for the diamond shape
  h, w = shape(I)
  center = (h // 2, w // 2)
  targets = [
      (center[0] - 1, center[1]), 
      (center[0], center[1] - 1), 
      center, 
      (center[0], center[1] + 1), 
      (center[0] + 1, center[1])
  ]

  # 3. Move the object cells to the target positions
  moved_cells = []
  for i, (v, (row, col)) in enumerate(largest_obj):
      target_row, target_col = targets[i % len(targets)]
      offset = (target_row - row, target_col - col)
      moved_cells.append((v, add((row, col), offset)))

  # 4. Paint the moved object and fill the rest with background color
  O = paint(canvas(mostcolor(I), shape(I)), frozenset(moved_cells))
  return O
 
14.333333333333334, 8.499421, def dfdiehdjeedfedhdbcfhebcfacfffacd(I):
  # 1. Find background and largest object
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # 2. Create a diamond-shaped patch at the center
  h, w = shape(I)
  center = (h // 2, w // 2)
  diamond_patch = frozenset({
      (center[0]-1, center[1]), 
      (center[0], center[1]-1), 
      center, 
      (center[0], center[1]+1), 
      (center[0]+1, center[1])
  })

  # 3. Paint the diamond with the largest object's color
  O = paint(canvas(bg, shape(I)), recolor(color(largest_obj), diamond_patch))
  return O
 
15.333333333333334, 13.209167, def fajfeebcfdjbedafbbhaicaccfcfacib(I):
    # 1. Identify the largest object
    objs = objects(I, T, F, T)
    largest_obj = argmax(objs, size)
    obj_color = color(largest_obj)

    # 2. Define a function to create a diamond grid of a specific size
    def create_diamond(size, color):
        grid = canvas(mostcolor(I), (size, size))
        for i in range(size):
            for j in range(size):
                if abs(i - size // 2) + abs(j - size // 2) <= size // 2:
                    grid = fill(grid, color, {(i, j)})
        return grid

    # 3. Calculate the diamond size and create the diamond grid
    diamond_size = min(shape(I)) // 2 * 2 + 1
    diamond_grid = create_diamond(diamond_size, obj_color)

    # 4. Center the diamond grid on the input grid's background
    h, w = shape(I)
    dh, dw = shape(diamond_grid)
    offset = ((h - dh) // 2, (w - dw) // 2)
    O = paint(canvas(mostcolor(I), shape(I)), shift(asobject(diamond_grid), offset))
    return O
 
18.333333333333332, 4.2672343, def hhceejcfgefeeaihbadgihcfecagdaef(I):
  # Find the most common color (representing the central object)
  common_color = mostcolor(I) 
  
  # Partition the grid based on color, effectively separating objects
  objs = partition(I)
  
  # Find the central object (the object with the most common color)
  central_obj = extract(objs, lambda obj: color(obj) == common_color)
  
  # Paint the central object on a blank canvas of the same size as the input grid
  O = paint(canvas(0, shape(I)), central_obj) 
  return O
 
8.666666666666666, 5.202963, def cgjfbccjbdcbechgifdihbaahfcigcch(I):
  # Directly fill non-central object cells with '0'
  O = underfill(I, 0, asindices(I))
  return O
 
19.666666666666668, 6.0192766, def aacjaddhfbjeechbijefhhejeaifchef(I):
  # Find all objects in the input grid
  all_objects = objects(I, univalued=False, diagonal=True, without_bg=False)

  # Find the largest object, which represents the central object
  largest_object = argmax(all_objects, size)  

  # Create a blank canvas
  O = canvas(0, shape(I))
  
  # Paint the largest object onto the canvas
  O = paint(O, largest_object)
  return O
 
16.666666666666668, 18.39476, def iiafihffffffedfcaehafdgfbajcfifa(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  obj = argmin(objs, size)
  O = paint(canvas(bg, shape(I)), obj)
  return O
 
19.333333333333332, 6.4381003, def jghgaccaabffedccjdaiddfjhdbaehii(I):
  objs = objects(I, T, T, T)
  obj = argmin(objs, lambda o: colorcount(I, color(o)))
  O = paint(canvas(mostcolor(I), shape(I)), obj)
  return O
 
9.666666666666666, 5.6868553, def ffdafedjjcicefdfadgcabjbdfdbabag(I):
    bg = mostcolor(I)
    cleared = replace(I, bg, ZERO)
    values = sorted(palette(cleared) - {ZERO})
    O = cleared
    for i, v in enumerate(values):
        O = fill(O, v, shoot((i, i), (1, 1)))
    return O 
 
8.666666666666666, 5.202963, def cfeddegdfaehejebifbieafcffeccbca(I):
    bg = mostcolor(I)
    O = replace(I, bg, ZERO)
    for i, v in enumerate(sorted(palette(I) - {bg})):
        indices = ofcolor(I, v)
        shifted = shift(indices, (i, i))
        O = fill(O, v, shifted)
    return O
 
7.666666666666667, 15.237927, def hagfcdadbcfceeifbhfjjcdbefegcjch(I):
    bg = mostcolor(I)
    O = canvas(ZERO, shape(I))
    for i, v in enumerate(sorted(palette(I) - {bg})):
        obj = next(obj for obj in objects(I, T, F, T) if color(obj) == v)
        O = paint(O, shift(obj, (i, i)))
    return O
 
19.666666666666668, 6.0192766, def djbiicdaaigaecfiaadjhafdiaeafiae(I):
    bg = mostcolor(I)
    O = I
    for i, v in enumerate(sorted(palette(I) - {bg})):
        O = paint(replace(O, v, ZERO), shift(recolor(v, ofcolor(I, v)), (i, i)))
    return O
 
19.0, 6.952793, def bfbjdceabaihejgfbhfajfejfccbaeae(I):
  bg = mostcolor(I)
  return tuple(
    tuple(
      v if v != bg else (
        index(I, (i+1, j)) if 0 <= i+1 < len(I) else bg
      ) 
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
  )
 
18.333333333333332, 15.080922, def abijaddgjbieegbcabiggfhafdcfbdcj(I):
    bg = mostcolor(I)
    return tuple(
        tuple(
            I[i][j] if I[i][j] != bg else (
                next(
                    (I[ni][nj] for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)] 
                     if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] != bg), bg)
            )
            for j in range(len(I[0]))
        ) for i in range(len(I))
    )
 
19.333333333333332, 6.0213065, def efgefjcfedffecdgihjbejdaefcecdbh(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)
  # 2. Create a bounding box around the dominant object
  indices = backdrop(obj)
  # 3. Fill the bounding box with the background color
  O = fill(I, mostcolor(I), indices)
  # 4. Paint the dominant object back onto the filled grid
  O = paint(O, obj)
  return O
 
19.666666666666668, 6.0192766, def iehgacaadcjdecdeifcceehcicgcbigc(I):
  # 1. Find the bounding box of all foreground objects
  box = backdrop(merge(objects(I, T, F, T)))
  # 2. Fill the bounding box with background color
  O = fill(I, mostcolor(I), box)
  # 3. Paint all foreground objects back onto the grid
  O = paint(O, merge(objects(I, T, F, T)))
  return O
 
17.666666666666668, 16.002039, def hddajbhfiefeedgabdbbacfdcbdffdad(I):
  # 1. Find the dominant object
  dominant_obj = argmax(objects(I, T, F, T), size)
  # 2. Get indices of all cells not part of the dominant object
  indices_to_fill = difference(asindices(I), toindices(dominant_obj))
  # 3. Fill the identified cells with background color
  O = fill(I, mostcolor(I), indices_to_fill)
  return O
 
15.0, 24.9597, def cbaafadjcbehejgdachcfdcfdfcadicf(I):
  objs = objects(I, T, T, T)
  obj = argmax(objs, size)
  O = paint(canvas(mostcolor(I), shape(I)), obj)
  for x, y in toindices(obj):
    O = fill(O, mostcolor(I), {(x-1, y), (x+1, y), (x, y-1), (x, y+1)}) # Fill surrounding cells
  return O
 
14.0, 38.354237, def ddeehdceegcbefjgbifbeedddcfhcgbe(I):
  bg = mostcolor(I)
  fg = leastcolor(replace(I, bg, 0)) 
  O = replace(I, bg, fg)
  return replace(O, fg, bg)
 
17.333333333333332, 15.149175, def diebhchdgffhegihidfddeacjccibdcc(I):
  bg = mostcolor(I)
  fg_obj = next(iter(objects(I, False, False, True))) # Get the first foreground object
  return paint(canvas(bg, shape(I)), fg_obj)
 
14.0, 15.828767, def ibbdfccahcebeeadiffjaaccgacjbcaa(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, T, F, T) # Extract objects from the input grid
  target_obj = extract(objs, lambda obj: color(obj) != bg)  # Identify the non-background object
  new_color = color(target_obj) # Get the color of the target object
  outline = box(toindices(target_obj)) # Get the outline of the target object
  filled_grid = replace(I, bg, new_color) # Replace background with the new color
  O = fill(filled_grid, 0, outline) # Fill the outline with '0'
  return O
 
18.0, 39.056145, def cbfbabdhaiacebfbibjajccghfbfjgcf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  target_obj = extract(objs, lambda obj: len(obj) != colorcount(I, bg))
  outline = mapply(lambda idx: astuple(idx[0], idx[1]), box(toindices(target_obj)))
  O = tuple(tuple(0 if (i, j) in outline else color(target_obj) if v == bg else v for j, v in enumerate(row)) for i, row in enumerate(I))
  return O
 
16.0, 7.2930527, def cgfcgcjfabebegdejeibedccffcebafa(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  target_obj = argmax(objs, lambda obj: color(obj) != bg and len(obj) > 1)
  O = paint(fill(I, 0, box(toindices(target_obj))), recolor(color(target_obj), toindices(target_obj)))
  return O
 
14.0, 12.216923, def ecjbbdbaegdjejdjaiajegccaeihbjef(I):
  bg = mostcolor(I)
  not_bg = leastcolor(I) if bg != leastcolor(I) else 9
  objs = objects(I, T, F, T)
  obj = extract(objs, lambda o: color(o) == not_bg)
  return paint(fill(canvas(bg, shape(I)), 0, box(toindices(obj))), recolor(not_bg, toindices(obj))) 
 
19.0, 19.849136, def jihifdfaebiceciejafdfjadicdjdege(I):
    # 1. Find the dominant object and its bounding box
    obj = argmax(objects(I, T, F, T), size)
    bbox = backdrop(obj)
    # 2. Fill the bounding box with the dominant object's color
    O = fill(I, index(I, next(iter(toindices(obj)))), bbox)
    # 3. Overwrite the original object with the background color
    O = cover(O, obj)
    return O
 
16.333333333333332, 15.563509, def hdgbgbefahaaegddidhbefehjefdefbe(I):
    # 1. Extract dominant object and determine background color
    obj = argmax(objects(I, T, F, T), size)
    bg_color = mostcolor(I)
    # 2. Create a canvas filled with the background color
    O = canvas(bg_color, shape(I))
    # 3. Paint the box outline directly onto the canvas
    O = paint(O, recolor(index(I, next(iter(toindices(obj)))), box(obj)))
    return O
 
9.0, 9.845026, def iahfbhiefaicejcjbjcfcajccdidejed(I):
  # Find the central index of the grid
  center_i, center_j =  divide(shape(I), 2) 

  # Create an empty canvas of the same size as the input
  O = canvas(0, shape(I))
  
  # Iterate through each cell in the input grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell is on the diagonal mirroring the original central element's diagonal
      if i - j == center_i - center_j: 
        # Paint the central element's value onto the output grid
        O = paint(O, {(I[center_i][center_j], (i, j))})
  return O
 
12.333333333333334, 7.731147, def hbeafgahdecfefbdjdceccfdcdbecfea(I):
  # Get the indices of all occurrences of the most common color
  central_indices = ofcolor(I, mostcolor(I))
  
  # Create a background object with all cells set to 0
  bg_obj = recolor(0, asindices(I))

  # Create the output object by combining the background and recoloring the central indices
  O = paint(canvas(0, shape(I)), recolor(I[first(central_indices)[0]][first(central_indices)[1]], central_indices) | bg_obj) 
  return O
 
7.333333333333333, 9.476481, def bheiafeehddjeafdihcjgbfcfhcdehjf(I):
  # Find the central object based on the most common color
  central_obj = extract(partition(I), lambda obj: color(obj) == mostcolor(I))

  # Get the diagonal line indices starting from the top-left corner of the central object
  diag_indices = connect(ulcorner(central_obj), (ulcorner(central_obj)[0] + height(I) - 1, ulcorner(central_obj)[1] + width(I) - 1))
  
  # Paint the central object's color onto the diagonal indices
  O = paint(canvas(0, shape(I)), recolor(color(central_obj), diag_indices))
  return O
 
8.666666666666666, 9.404481, def cdiheffjacideafeiedhfddjbegjdcdj(I):
  # Create a diagonal line object across the grid
  diag_obj = recolor(1, connect((0, 0), (height(I) - 1, width(I) - 1)))
  
  # Shift the diagonal line to align with the central element's diagonal
  offset = subtract(divide(shape(I), 2), divide(shape(diag_obj), 2))
  shifted_diag = shift(diag_obj, offset)
  
  # Paint the central element's value onto the shifted diagonal
  O = paint(canvas(0, shape(I)), recolor(I[offset[0]][offset[1]], toindices(shifted_diag))) 
  return O
 
9.333333333333334, 9.870398, def icjcafgbeeeeebfcicjbaicdggfdceac(I):
  # Extract the diagonal elements from the input grid
  diag_elements = frozenset({(I[i][j], (i, j)) for i in range(height(I)) for j in range(width(I)) if i - j == divide(shape(I), 2)[0] - divide(shape(I), 2)[1]})

  # Create the output object by painting the diagonal elements onto a blank canvas
  O = paint(canvas(0, shape(I)), diag_elements)
  return O
 
18.333333333333332, 5.6002684, def ebbjbgedhjceehheijadgjeecdcaffbi(grid):
  return paint(canvas(0, shape(grid)), merge(apply(lambda obj: recolor(color(obj), sfilter(toindices(obj), lambda loc: len(neighbors(loc) - toindices(obj)) < 8)), objects(grid, T, T, F)))) 
 
15.666666666666666, 9.795409, def adidgbbjhcbieieajaddadaibdhcbajf(I):
    bg = mostcolor(I)  # Identify the background color
    objs = objects(I, True, False, True)  # Extract objects excluding background
    obj = next(iter(objs)) if objs else {}  # Get the first object or an empty set
    diag = shoot((0, 0), (1, 1))  # Generate a diagonal line of indices
    O = canvas(bg, shape(I))  # Create a canvas filled with the background color
    return paint(O, recolor(color(obj), diag) if obj else O)  # Paint the diagonal with the object color 
 
6.0, 10.20393, def iffebfeffiddeejajcfdcedchbbgfehi(I):
    bg = mostcolor(I)
    O = replace(I, bg, 0)
    count = colorcount(O, leastcolor(O))
    diag = {(i, i) for i in range(count)}
    return fill(replace(O, leastcolor(O), bg), leastcolor(I), diag)
 
16.0, 14.410256, def cahadchbiidcedbcaddgiebaceabaaje(I):
    bg = mostcolor(I)
    fg = next(iter(palette(I) - {bg}), bg)  # Find a non-background color
    O = canvas(bg, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != bg:
                O = fill(O, fg, {(i + j, i + j)}) # Fill based on row and column sum
    return O
 
16.666666666666668, 12.203873, def ddeahhebfeccecafjbecdceegeaijgej(I):
  target_color = mostcolor(I)
  replacement = 0 if leastcommon(I) != 0 else 9
  def keep_color(i, j):
    return sum((i+di, j+dj) in ofcolor(I, target_color) for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]) >= 2
  return tuple(
    tuple(
      v if v != target_color else (target_color if keep_color(i,j) else replacement) 
      for j, v in enumerate(row)
    ) for i, row in enumerate(I)
  )
 
18.0, 15.0539255, def cigbbbdgedbfecciibedibdibhfgbgab(I):
  # 1. Find the dominant object and its color
  dom_obj = argmax(objects(I, T, F, T), size)
  dom_color = color(dom_obj)
  # 2. Invert the colors based on the dominant object's presence
  O = paint(canvas(mostcolor(I), shape(I)), 
            recolor(dom_color, backdrop(dom_obj)))
  return cellwise(I, O, mostcolor(I))
 
15.666666666666666, 22.893036, def bfgbeffcecghegahbejhadaabddagibb(I):
  # 1. Find the dominant object and create an inverted object
  dom_obj = argmax(objects(I, T, F, T), size)
  inverted_obj = recolor(mostcolor(I), toindices(dom_obj))
  # 2. Combine the dominant object and the inverted object
  combined_obj = combine(dom_obj, inverted_obj)
  # 3. Paint the combined object on a background-filled grid
  O = paint(canvas(mostcolor(I), shape(I)), combined_obj)
  return O
 
13.666666666666666, 9.927336, def iedccghgafafeadbbbcjbjiccdeecbgb(I):
  objs = partition(I)
  O = canvas(0, shape(I))
  for obj in objs:
    center_cell = centerofmass(obj)
    visited = initset(center_cell)
    queue = [center_cell] 
    while queue:
      curr = queue.pop(0)
      for neighbor in dneighbors(curr) & toindices(obj):
        if neighbor not in visited:
          visited = insert(neighbor, visited)
          queue.append(neighbor)
    O = paint(O, recolor(color(obj), visited))
  return O
 
13.333333333333334, 10.373672, def iaggfcjccbfgeebhjhbfcahcefbjefac(I):
  O = canvas(0, shape(I))
  for value in palette(I):  # Iterate through each color in the grid
    obj = frozenset((value, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == value)
    center_cell = centerofmass(obj)
    O = underpaint(O, recolor(value, grow(center_cell, obj)))
  return O
 
13.333333333333334, 8.338354, def dffcbfdcdcdaegcdbifjbhjefidhageh(I):
  O = I  # Modify the input grid directly
  for value in palette(I):
    obj = frozenset((value, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == value)
    center_cell = centerofmass(obj)
    connected = grow(center_cell, obj)
    O = fill(O, 0, toindices(obj) - connected)  # Fill the non-connected parts with 0s
  return O
 
13.333333333333334, 4.4297214, def baehhhcafdeeeeecaecgbhigdgdbdjef(grid):
    objs = objects(grid, T, T, F) # Get all objects in the grid
    largest_obj = argmax(objs, size) # Find the largest object
    return paint(canvas(0, shape(grid)), largest_obj) # Paint the largest object on a blank canvas
 
15.333333333333334, 7.076002, def dfaedhbbbaacefeaihifebicigedbbaj(grid):
    objs = objects(grid, T, T, F)
    largest_obj = argmax(objs, lambda obj: colorcount(grid, color(obj))) # Find the largest object by color count
    return paint(canvas(0, shape(grid)), largest_obj) 
 
19.666666666666668, 6.0192766, def icfcchbebfeiebfgjgfcchgbjbaagaea(grid):
    bg_color = mostcommon(grid) # Identify the background color
    return replace(grid, bg_color, 0) # Replace the background color with 0 
 
18.0, 39.056145, def iafbbadbdbbaehjaabdcjfddbbabegff(I):
  fg = leastcolor(I)  # Identify the foreground color
  O = underfill(I, fg, asindices(I)) # Fill background with foreground color
  O = replace(O, mostcolor(I), 0) # Replace original background color with 0
  return O
 
15.333333333333334, 19.522287, def jbbeebcgfifjedbdjfcabbjabedecidj(I):
  bg = mostcolor(I)
  hollowed = tuple(
    tuple(
      0 if any((i + di, j + dj) in ofcolor(I, v) for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]) else v
      for j, v in enumerate(row)
    )
    for i, row in enumerate(I)
  )
  O = tuple(
    tuple(
      bg if hollowed[i][j] != I[i][j] else hollowed[i][j] 
      for j in range(len(I[0]))
    )
    for i in range(len(I))
  )
  return O
 
15.666666666666666, 14.388437, def jefbcdfddchbebbhbeccjagabaehcdcf(I):
  def is_border(i, j):
    return any(0 <= i + di < len(I) and 0 <= j + dj < len(I[0]) and I[i + di][j + dj] != I[i][j] for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)])
  O = tuple(
    tuple(
      I[i][j] if is_border(i, j) else 0
      for j in range(len(I[0]))
    )
    for i in range(len(I))
  )
  return O
 
14.0, 38.354237, def fedhcjfgbeffecbhjaechdccdhcgbbjf(I):
  objs = objects(I, T, F, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = paint(O, recolor(mostcolor(I), box(obj)))
  return O
 
14.0, 38.354237, def fjgaceefggbheccdbiabdcacdccdfbdb(I):
  objs = partition(I)  # Separate objects by color
  bg_color = mostcolor(I)  # Identify background color
  frame_objs = set()
  for obj in objs:
    if color(obj) != bg_color:
      frame = toindices(obj) & outbox(obj)  # Find cells on object border
      frame_obj = recolor(color(obj), frame)  # Create object from border cells
      frame_objs.add(frame_obj)
  O = paint(canvas(bg_color, shape(I)), merge(frame_objs))  # Paint frame onto background
  return O
 
17.0, 13.3393, def cjcccidcheffedfdbaddbdffcaidbcfd(I):
  O = canvas(mostcolor(I), shape(I))  # Start with background canvas
  for i in range(1, height(I)-1):
    for j in range(1, width(I)-1):
      if I[i][j] != mostcolor(I) and any(I[n[0]][n[1]] == mostcolor(I) for n in dneighbors((i, j))):
        O = paint(O, {(I[i][j], (i, j))})  # Paint if cell is not background and has a background neighbor
  return O
 
7.333333333333333, 37.213856, def bafjbcbechciefffbadhccabebdjicbi(grid):
  objs = objects(grid, False, False, False)  # Get all objects in the grid
  bg_obj = argmax(objs, size) # Find the largest object, which is the background
  return paint(canvas(0, shape(grid)), difference(asobject(grid), bg_obj))  # Paint all objects except the background on a blank canvas
 
7.333333333333333, 37.213856, def jbcigdfaaacbefjdieafhaefhcebafgh(I):
    """
    Paints over the most frequent color object with a blank object.
    """
    objs = objects(I, univalued=False, diagonal=True, without_bg=False) # Get all objects in the grid
    bg_obj = argmax(objs, size) # Find the largest object, which represents the background
    O = paint(canvas(ZERO, shape(I)), difference(asobject(I), bg_obj))  # Paint all objects except the background onto a blank canvas
    return O
 
19.666666666666668, 6.0192766, def afdfdacacjgdeehbihfccihcfhabbide(I):
  mc = mostcolor(I)  # Identify the most frequent color (background)
  O = replace(I, mc, 0)  # Replace background color with '0'
  O = replace(O, 0, mc)  # Replace all '0's (originally figures) with the background color
  return O 
 
12.333333333333334, 5.8038373, def fcefchbdafafeddfjbfgdcbiaifiacja(I):
  fg = leastcolor(I) # Identify the foreground color
  bg = mostcolor(I) # Identify the background color
  O = I # Copy the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == fg: # If cell belongs to the figure
        O = fill(O, bg, {(i, j)}) # Fill with background color
      else: 
        O = fill(O, fg, {(i, j)}) # Otherwise, fill with foreground color
  return O
 
13.333333333333334, 23.581469, def cbafhjjfaedbeeddbccbeeabaaiidgfc(I):
  # 1. Find the dominant object, its color, and background color
  obj = argmax(objects(I, T, F, T), size)
  obj_color = color(obj)
  bg = mostcolor(I)
  
  # 2. Create a canvas with the background color and paint the object
  O = canvas(bg, shape(I))
  O = paint(O, recolor(obj_color, outbox(toindices(obj)))) 
  return O
 
18.666666666666668, 6.020359, def baccdajbedccehidafeffeabhafbfahi(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)
  
  # 2. Create a frame and difference with the object
  frame = outbox(toindices(obj))
  inverted_area = frame - toindices(obj) 
  
  # 3. Fill the inverted area with the object's color
  O = fill(I, color(obj), inverted_area) 
  return O
 
3.0, 2.8200402, def gbaecfbgcchgeeffjedajdjadefegbig(I):
  central_color = mostcolor(I)
  objs = partition(I)
  central_obj = extract(objs, lambda obj: color(obj) == central_color)
  O = paint(canvas(central_color, shape(I)), recolor(0, central_obj))
  return O
 
7.333333333333333, 37.213856, def eeceddggjeebedjbjebdfgcjadidhfaa(I):
  central_color = mostcolor(I)
  objs = partition(I)
  non_central_objs = sfilter(objs, lambda obj: color(obj) != central_color)
  O = I
  for obj in non_central_objs:
    O = cover(O, obj)
  O = switch(O, central_color, 0)
  return O
 
19.666666666666668, 16.629272, def hccfdbhiahadebdhjdhfcccicfdihaga(I):
  bg_color = mostcolor(I)
  filled_grid = underfill(I, bg_color + 1, asindices(I))
  O = switch(filled_grid, bg_color, 0)
  return O
 
7.666666666666667, 33.769394, def fdjdgcfabeidebdgbbcffgebdadcifid(grid):
  return paint(canvas(0, shape(grid)), merge(apply(lambda obj: recolor(color(obj), sfilter(toindices(obj), lambda loc: len(dneighbors(loc) & toindices(obj)) == 4)), objects(grid, T, T, F))))
 
10.0, 6.5985837, def dibddafhbeaheecciefadecfafdciead(I):
    bg = mostcolor(I)  # Identify the background color
    O = replace(I, bg, ZERO)  # Replace background with 0
    for v in palette(I) - {bg}:  # For each non-background color
        obj = toobject(ofcolor(I, v), I)  # Extract the object
        shifted_obj = shift(obj, (sign(uppermost(obj)), sign(leftmost(obj))))  # Shift diagonally outwards
        O = paint(O, shifted_obj)  # Paint the shifted object onto the output grid
    return O 
 
7.666666666666667, 11.4326935, def cebfeiejfbbieaeeiacfgffcjjbiceia(I):
  bg = mostcolor(I)
  O = canvas(ZERO, shape(I)) # Initialize with zeros
  for v in palette(I) - {bg}:
    obj = toobject(ofcolor(I, v), I)
    h_shift = ONE if leftmost(obj) < width(I) // TWO else NEG_ONE
    v_shift = ONE if uppermost(obj) < height(I) // TWO else NEG_ONE
    shifted_obj = shift(obj, (v_shift, h_shift))
    O = paint(O, shifted_obj)
  return O
 
9.666666666666666, 6.989172, def beiffhfcjcjcecbfjbcfcggejjahaeie(I):
    bg = mostcolor(I)
    O = replace(I, bg, ZERO)
    objs = objects(I, T, F, T)  # Extract all objects without background
    for obj in objs:
        h_shift =  ONE if leftmost(obj) <= width(I) // TWO else NEG_ONE
        v_shift = ONE if uppermost(obj) <= height(I) // TWO else NEG_ONE
        shifted_obj = shift(obj, (v_shift, h_shift))
        O = paint(O, shifted_obj)
    return O
 
10.0, 5.6003723, def idifcdbahjdgefdiidhbabfbbjbbjfae(I):
  bg = mostcolor(I)
  O = replace(I, bg, ZERO)
  for obj in objects(I, T, F, T):
    shifted_obj = shift(obj, gravitate(obj, {(ZERO, (ZERO, ZERO))})) # Gravitate towards origin
    O = paint(O, shifted_obj)
  return O
 
9.0, 6.427667, def bcbfbidcjabdefahjdfacfcjeefbfbdh(I):
  bg = mostcolor(I)
  O = replace(I, bg, ZERO) 
  for v in palette(I) - {bg}:
    indices = ofcolor(I, v)
    h_shift = ONE if leftmost(indices) < width(I) // TWO else NEG_ONE
    v_shift = ONE if uppermost(indices) < height(I) // TWO else NEG_ONE
    O = fill(O, v, shift(indices, (v_shift, h_shift)))
  return O
 
18.666666666666668, 5.535631, def bibdddfbhidfeadgacjbacbcbedffgeb(I):
  mc = mostcolor(I)
  objs = objects(I, T, F, T)
  for obj in objs:
    O = fill(I, mc, outbox(toindices(obj)))
    O = fill(O, 0, toindices(obj))
  return O
 
18.0, 8.043197, def abibjaaajfgjeddcbbejfifaegcieicb(I):
  mc = mostcolor(I)
  O = fill(I, mc, asindices(I))
  objs = objects(I, T, F, T)
  for obj in objs:
    O = underfill(O, color(obj), box(toindices(obj)))
    O = underfill(O, 0, toindices(obj))
  return O
 
14.0, 38.354237, def bifbjbbafbdjeeieaibfafejhdegdicd(I):
  # 1. Find the dominant object and its indices
  obj = argmax(objects(I, T, F, T), size)
  obj_indices = toindices(obj)
  
  # 2. Get background color and object color
  bg = mostcolor(I)
  obj_color = color(obj)
  
  # 3. Iterate through the grid and apply the transformation
  O = tuple(tuple(
      bg if (i, j) not in obj_indices else obj_color if (i, j) in outbox(obj_indices) else bg
      for j in range(width(I))) 
      for i in range(height(I))
  )
  return O
 
14.333333333333334, 16.578371, def ghgceaegddjjeaedabfgcgjjdaehjcaf(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)
  
  # 2. Invert the grid colors based on object membership
  inverted = tuple(tuple(
      mostcolor(I) if (i, j) in toindices(obj) else color(obj) 
      for j in range(width(I))) 
      for i in range(height(I))
  )
  
  # 3. Fill the object's interior with the background color
  O = underfill(inverted, mostcolor(I), toindices(obj))
  
  return O
 
15.0, 16.100286, def egichgacdabaeadeijdabghfaabgcbaj(I):
  # 1.  Find the dominant object and its bounding box
  obj = argmax(objects(I, T, F, T), size)
  bbox = backdrop(toindices(obj))
  
  # 2.  Create a grid filled with the object's color
  O = canvas(color(obj), shape(I))
  
  # 3.  Fill cells outside the bounding box and inside the object with the background color
  O = fill(O, mostcolor(I), difference(asindices(I), bbox))
  O = underfill(O, mostcolor(I), toindices(obj))
  
  return O
 
18.333333333333332, 4.2672343, def aceaeedffbhaechjbcfabafcgcihfjcg(grid):
    dominant_color = mostcolor(grid)  # Find the most frequent color
    dominant_obj = extract(partition(grid), lambda obj: color(obj) == dominant_color)  # Directly extract the object using partition
    return paint(canvas(0, shape(grid)), dominant_obj) # Paint the extracted object on a blank canvas
 
17.666666666666668, 10.600246, def fbbebhbheaafehihbdahefbhaeahibdi(I):
  dom_color = mostcolor(I)
  bg_color = leastcolor(I)
  dom_indices = ofcolor(I, dom_color)
  center_i = uppermost(dom_indices) + height(dom_indices) // 2
  center_j = leftmost(dom_indices) + width(dom_indices) // 2
  new_indices = (
      {(i, center_j) for i in range(len(I))} | 
      {(center_i, j) for j in range(len(I[0]))}
  ) 
  O = fill(I, bg_color, dom_indices)
  O = fill(O, dom_color, new_indices)
  return O
 
9.0, 30.661596, def decbeedcihgeeeegajfidiaadijfjjdd(I):
  O = I
  for val in palette(I):
    obj = toobject(ofcolor(I, val), I)
    neighbors = toobject(delta(toindices(obj)), I)
    frame_color = mostcolor(totuple(neighbors) if len(neighbors) > 0 else ((mostcolor(I), (0, 0)),))
    O = fill(O, frame_color, outbox(toindices(obj)))
    O = fill(O, 0, toindices(obj))
  return O
 
13.0, 7.441965, def decbfdhedeefeiiajfififdeahiabefj(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, F):
    neighbors = toobject(outbox(toindices(obj)), I)
    frame_color = mostcolor(totuple(neighbors) if len(neighbors) > 0 else ((mostcolor(I), (0, 0)),))
    O = paint(O, recolor(frame_color, outbox(toindices(obj))))
  return O
 
11.666666666666666, 5.409106, def bhhadhgdffiaeafcjedhgbiaeiiabcbj(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    frame = outbox(toindices(obj))
    neighbors = toobject(frame, I)
    neighbor_colors = [v for v, _ in neighbors]
    if neighbor_colors:
      frame_color = mostcommon(neighbor_colors)
      O = fill(O, frame_color, frame)
    O = fill(O, 0, toindices(obj))
  return O
 
14.666666666666666, 16.109255, def bbcfcbgdieajefheaeijfggifjhacaib(grid):
    min_color = leastcolor(grid)
    objects_list = objects(grid, univalued=False, diagonal=True, without_bg=False)  # Extract all objects from the grid
    filtered_objects = frozenset(obj for obj in objects_list if color(obj) == min_color) # Filter for objects with the minimum color
    new_grid = canvas(0, shape(grid)) # Create a new grid filled with zeros
    for obj in filtered_objects:
        new_grid = paint(new_grid, obj) # Paint each filtered object onto the new grid
    return new_grid
 
17.666666666666668, 13.871107, def dbdhidfbcjefebfcaidffdcccbghbeia(I):
  obj_color = mostcolor(I)
  bg_color = leastcolor(I)
  objs = objects(I, True, False, False)
  main_obj = extract(objs, lambda o: color(o) == obj_color)
  outline = box(toindices(main_obj)) 
  O = paint(fill(I, bg_color, main_obj), recolor(obj_color, outline))
  return O
 
19.333333333333332, 12.006747, def dbjjjbbbeefcecbdbcfedahjfhbdecff(I):
  obj_color = mostcolor(I)
  bg_color = leastcolor(I)
  O = canvas(bg_color, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == obj_color and any(I[i + di][j + dj] != obj_color for di, dj in [(0,1),(0,-1),(1,0),(-1,0)] if 0 <= i + di < len(I) and 0 <= j + dj < len(row)):
        O = paint(O, {(obj_color, (i, j))}) 
  return O
 
16.333333333333332, 13.26138, def ejfhaabdeafeeegbiicdjibdiaaafecd(I):
  obj_color = mostcolor(I)
  bg_color = leastcolor(I)
  O = I
  for obj in objects(I, True, False, False):
    if color(obj) == obj_color:
      O = fill(O, bg_color, obj)
      O = paint(O, recolor(obj_color, box(toindices(obj))))
  return O
 
13.333333333333334, 33.852165, def didfbicjjcceebgeaedeaacfaccbbaib(I):
  O = I  
  for obj in objects(I, T, F, F):
    frame = outbox(toindices(obj))
    neighbor_colors = [index(I, (i, j)) for i, j in frame if (i, j) not in toindices(obj)]
    if neighbor_colors:
      frame_color = mostcommon(neighbor_colors)
      O = fill(O, frame_color, frame)
    O = fill(O, 0, toindices(obj))
  return O
 
17.333333333333332, 7.5877814, def aabdbbabbaafefcgjefjccfbggcefigj(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, F):
    frame = difference(outbox(toindices(obj)), toindices(obj))
    neighbor_colors = [I[i][j] for (i, j) in frame if 0 <= i < len(I) and 0 <= j < len(I[0])]
    frame_color = mostcommon(neighbor_colors) if neighbor_colors else 0
    O = paint(O, recolor(frame_color, frame))
    O = paint(O, recolor(I[first(toindices(obj))[0]][first(toindices(obj))[1]], toindices(obj)))
  return O
 
13.0, 5.5533504, def fdecabeeiabfecbhiebfabfcdgeabcfa(I):
  O = I
  for obj in objects(I, T, F, F):
    surrounding_colors = set()
    for (i, j) in toindices(obj):
      for (ni, nj) in dneighbors((i, j)):
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and (ni, nj) not in toindices(obj):
          surrounding_colors.add(I[ni][nj])
    
    frame_color = mostcommon(tuple(surrounding_colors)) if surrounding_colors else 0
    O = fill(O, frame_color, outbox(toindices(obj)))
    O = fill(O, 0, toindices(obj))
  return O
 
11.0, 7.1658707, def gcidedgdjjbaecgfbgdbcaachdccffcf(I):
  O = I
  for obj in objects(I, T, F, F):
    obj_indices = toindices(obj)
    frame = set()
    for (i, j) in obj_indices:
      for (di, dj) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
        neighbor = (i + di, j + dj)
        if 0 <= neighbor[0] < len(I) and 0 <= neighbor[1] < len(I[0]) and neighbor not in obj_indices:
          frame.add(neighbor)

    frame_colors = [I[i][j] for (i, j) in frame]
    frame_color = mostcommon(frame_colors) if frame_colors else 0
    for (i, j) in frame:
      O = fill(O, frame_color, {(i, j)})
    for (i, j) in obj_indices:
      O = fill(O, 0, {(i, j)})
  return O
 
18.0, 31.87072, def idahchcbecibeedaagiddjigbbeeecbb(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)

  # 2. Get the bounding box indices
  bbox = backdrop(toindices(obj))

  # 3. Replace dominant color with a temporary color
  temp_grid = replace(I, color(obj), NEG_ONE)

  # 4. Fill bounding box with the dominant color
  filled_grid = fill(temp_grid, color(obj), bbox) 

  # 5. Replace temporary color with background color
  O = replace(filled_grid, NEG_ONE, mostcolor(I)) 
  return O
 
17.666666666666668, 23.067072, def eeaaddfdbjdceaejiedcdcadbfaceaab(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)

  # 2. Get the dominant object and background colors
  dom_color = color(obj)
  bg_color = mostcolor(I)

  # 3. Fill the entire grid with the dominant object's color
  filled_grid = canvas(dom_color, shape(I))

  # 4. Create a new object representing the area outside the dominant object within the bounding box
  inverted_obj = toobject(difference(backdrop(toindices(obj)), toindices(obj)), I)

  # 5. Paint the inverted object with the background color
  O = paint(filled_grid, recolor(bg_color, toindices(inverted_obj)))
  return O
 
16.0, 6.5599766, def cbbabbfjfbagebacjeihddfjcehigdfb(I):
  # 1. Find the dominant object
  obj = argmax(objects(I, T, F, T), size)

  # 2. Get the bounding box indices
  bbox = backdrop(toindices(obj))

  # 3. Define a function to invert colors based on object membership
  def invert_color(i, j):
    return mostcolor(I) if (i, j) in toindices(obj) else color(obj)

  # 4. Apply the color inversion function to the bounding box indices
  inverted_indices = frozenset({(invert_color(i, j), (i, j)) for i, j in bbox})

  # 5. Paint the inverted indices onto the original grid
  O = paint(I, inverted_indices)
  return O
 
17.333333333333332, 21.957703, def diedfjeehjaceceeadefaefidbgfeifi(I):
  central_color = mostcolor(I)
  objs = objects(I, univalued = False, diagonal=True, without_bg = False) # Find all objects
  for obj in objs:
    if color(obj) != central_color:
      I = cover(I, obj) # Cover non-central objects with background color
  return I
 
3.0, 2.8200402, def fcabfaciihabeahbjdaibehiaffccefd(grid):
  dom_color = mostcolor(grid) # Identify the dominant color
  return tuple(tuple(0 if v == dom_color else dom_color for v in row) for row in grid) # Invert colors within a list comprehension
 
8.666666666666666, 5.202963, def hgcgbcdjficdeeaajafeacebjbdcchji(grid):
  return replace(replace(grid, mostcolor(grid), 99), 99, 0)  # Two-step replacement 
 
8.666666666666666, 5.202963, def bffaiaecdabcehjbahdbjhijebebgefe(grid):
  non_dominant_color = leastcolor(grid)
  return replace(grid, mostcolor(grid), 0) if colorcount(grid, non_dominant_color) > 0 else grid 
 
19.666666666666668, 6.0192766, def fbfcjebijgbceedcibfeeafabdededee(I):
  least_common = leastcolor(I)
  frame_indices = ofcolor(I, least_common)
  remaining_obj = difference(asobject(I), recolor(0, frame_indices))
  O = paint(canvas(0, shape(I)), remaining_obj)
  return O
 
15.333333333333334, 10.153348, def fgaafifidajdeeadiechcdfcdcgbbdae(grid):
  bg = mostcolor(grid)  # Determine the background color
  objs = objects(grid, T, T, F)  # Get all objects
  largest_obj = argmax(objs, size)  # Find the largest object
  outline = box(toindices(largest_obj))  # Find the outline indices
  return paint(canvas(bg, shape(grid)), recolor(leastcolor(grid),outline)) # Paint the outline with least common color on a canvas of background color
 
14.0, 38.354237, def aabaedfdgbgeejhfaccacefbjfgbjhdd(grid):
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  outline = box(toindices(largest_obj))
  new_grid = apply(lambda row: apply(lambda v: leastcolor(grid) if astuple(row.index(v), v) in outline else mostcolor(grid), row), grid) 
  return new_grid
 
17.0, 8.127344, def bcjihjbfdfadeaccbfgbjcaeghbijdea(grid):
  bg = mostcolor(grid)
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, lambda obj: colorcount(obj, leastcolor(grid)))  # Modified to find the largest object by area of least common color
  return fill(canvas(bg, shape(grid)), leastcolor(grid), box(toindices(largest_obj)))
 
14.666666666666666, 9.576487, def ibgaagcfbdadehhfjbaejdjdafaeebbf(grid):
  bg = mostcolor(grid)
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  shifted_outline = shift(box(toindices(largest_obj)), (1, 1))  # Shift the outline one unit down and right
  return fill(canvas(bg, shape(grid)), leastcolor(grid), shifted_outline)
 
17.333333333333332, 11.689145, def dbchfbabjeccebceahbdciadidfdcccc(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  outline = mapply(lambda obj:  
                 combine(
                     inbox(obj), 
                     difference(outbox(obj), asindices(I))
                 ), 
              objs)
  O = fill(I, bg, outline)
  return O
 
19.666666666666668, 6.0192766, def decfdeiaibjeeiajbgdehechbacedgcd(grid):
  return paint(canvas(mostcolor(grid), shape(grid)), merge(sfilter(partition(grid), lambda obj: color(obj) != mostcolor(grid))))
 
14.0, 38.354237, def bbgdceafdadeeiidiaefhcabdaffcdea(grid):
  return fill(grid, mostcolor(grid), merge(apply(toindices, sfilter(partition(grid), lambda obj: color(obj) != mostcolor(grid)))))
 
3.0, 2.8200402, def eejeifiehjbaeedejdhefebdbgifdhdf(I):
  # Find the most common color
  mc = mostcolor(I)  
  
  # Replace the most common color with 0
  O = replace(I, mc, 0)
  
  # Replace all other colors with the most common color
  O = replace(O, leastcolor(O), mc) 
  return O
 
17.0, 7.5212183, def echedheeecafedfiiihcjaidgieadfed(I):
  # Find the most common color
  mc = mostcolor(I)
  
  # Get indices of the most common color
  indices = ofcolor(I, mc)  
  
  # Get indices of the object's "inbox" (one layer inside the frame)
  inner = inbox(indices)  
  
  # Fill the inbox with 0s
  O = fill(I, 0, inner)  
  return O
 
7.333333333333333, 22.498295, def aiddadeebcbjeeifjafceieaihdfehgh(grid):
  return paint(canvas(0, shape(grid)), merge(apply(lambda obj: sfilter(obj, lambda cell: any((i,j) in delta(obj) for (i,j) in neighbors(cell[1]))), objects(grid, T, F, T))))
 
8.666666666666666, 5.202963, def fecibjcbaibgebcibcejdfiehbecghad(grid):
  output = canvas(0, shape(grid))
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if any(grid[i][j] == cell[0] and cell[1] in box(obj) for obj in objects(grid, T, F, T) for cell in obj):
        output = fill(output, grid[i][j], {(i, j)})
  return output
 
19.666666666666668, 6.0192766, def jddfaccacbeeebfdbjdbdabficeghgjb(grid):
  return cellwise(grid, paint(canvas(mostcolor(grid), shape(grid)), merge(objects(grid, T, F, T))), 0) 
 
19.666666666666668, 6.0192766, def hggdaefdcfadebdajdgcadibhbhdgjdd(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  center_idx = centerofmass(asobject(I))
  shifted_objs = frozenset(shift(obj, divide(subtract(centerofmass(obj), center_idx), 2)) for obj in objs)
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
15.333333333333334, 15.414809, def ceicbfhdbdgeeadfidahdiedgebjafec(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  center_idx = (len(I) // 2, len(I[0]) // 2)
  shifted_objs = set()
  for obj in objs:
    obj_center = centerofmass(obj)
    shift_amount = (sign(obj_center[0] - center_idx[0]), sign(obj_center[1] - center_idx[1]))
    shifted_objs.add(shift(obj, shift_amount))
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
16.0, 9.153253, def bcfeaejdhdjbeaciacbcfffefffacgfj(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  shifted_objs = {shift(obj, position(obj, asobject(I))) for obj in objs}
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return O
 
14.0, 38.354237, def abgaahejfcajedcgaddcjaajiabbhhaa(I):
  bg = mostcolor(I)
  shifted_grid = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != bg:
        shift_amount = (sign(i - len(I) // 2), sign(j - len(I[0]) // 2))
        new_i = i + shift_amount[0]
        new_j = j + shift_amount[1]
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
          shifted_grid = fill(shifted_grid, I[i][j], {(new_i, new_j)})
  O = fill(shifted_grid, bg, asindices(I))
  return O
 
14.0, 12.692145, def cbacffhaddfgechbbafjceiibagdcejb(grid):
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if grid[i][j] == mostcolor(grid):
        grid = fill(grid, 0, {(i,j)}) # Replaces the current cell with 0
  return grid
 
16.666666666666668, 5.210933, def bejddcdjccfaecfiaeaedgeceegdhiie(grid):
  dom_color = mostcolor(grid)
  other_color = leastcolor(grid)
  objs = partition(grid)
  target_obj = extract(objs, lambda obj: color(obj) == dom_color)
  recolored_obj = recolor(other_color, toindices(target_obj))
  return paint(canvas(0, shape(grid)), recolored_obj) 
 
18.0, 39.056145, def bgfbaafcabefeacbbceadeffjadfddjh(grid):
  dom_color = mostcolor(grid)
  other_color = leastcolor(grid)
  return replace(
      replace(grid, dom_color, other_color), 
      other(palette(grid), other_color), 
      0)
 
11.333333333333334, 5.227815, def hbbfbedbfaabeaedibceefcgjjgfieea(I):
  # Most common color
  mc = mostcolor(I)
  
  # Calculate grid center
  h, w = shape(I)
  ci, cj = h // 2, w // 2

  # Create plus-shaped indices
  plus_indices = frozenset(
      {(i, cj) for i in range(h)} | 
      {(ci, j) for j in range(w)}
  )

  # Fill non-plus indices with 0
  O = fill(I, 0, asindices(I) - plus_indices) 

  # Replace non-dominant colors with 0 
  O = replace(O, leastcolor(O), 0) 
  
  return O
 
7.333333333333333, 37.213856, def geaedjfafdaeecfajccdcddafacecfac(I):
  # Identify and extract the central object (assuming it's the most common color)
  central_obj = extract(partition(I), lambda obj: color(obj) == mostcolor(I))

  # Create a plus-shaped patch based on the central object's dimensions
  h, w = height(central_obj), width(central_obj)
  plus_patch = frozenset(
      {(i, w // 2) for i in range(h)} | 
      {(h // 2, j) for j in range(w)}
  )

  # Shift the plus-shaped patch to the center of the grid
  plus_patch = shift(plus_patch, subtract(centerofmass(I), centerofmass(plus_patch))) 

  # Recolor the plus-shaped patch with the dominant color
  plus_obj = recolor(mostcolor(I), plus_patch)

  # Paint the plus-shaped object onto a blank canvas
  O = paint(canvas(0, shape(I)), plus_obj) 
  return O
 
8.0, 6.004237, def debidiebfechefjjjgfigefddcffeggi(I):
  # Get central object (most common color)
  central_obj = extract(partition(I), lambda obj: color(obj) == mostcolor(I))

  # Calculate center and offsets for plus shape
  ci, cj = centerofmass(central_obj)
  h_offset = height(central_obj) // 2
  w_offset = width(central_obj) // 2

  # Generate plus shape using offsets 
  plus_obj = frozenset(
      {(mostcolor(I), (ci + i - h_offset, cj)) for i in range(2 * h_offset + 1)} |
      {(mostcolor(I), (ci, cj + j - w_offset)) for j in range(2 * w_offset + 1)}
  )

  # Paint onto a blank canvas
  O = paint(canvas(0, shape(I)), plus_obj)
  return O
 
16.666666666666668, 11.993971, def ceaeibgiehcbejfbihgbibcacbgffhcc(grid):
  objs = objects(grid, T, T, F)  # Identify all objects
  largest_obj = argmax(objs, size)  # Find the largest object
  outline = box(toindices(largest_obj))  # Determine the outline of the largest object
  return paint(canvas(0, shape(grid)), toobject(outline, grid))  # Paint the outline onto a blank canvas
 
15.666666666666666, 11.185517, def behfjhdaefajeiffahcdeihebbegcccb(grid):
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  return fill(canvas(0, shape(grid)), mostcolor(largest_obj), box(toindices(largest_obj)))
 
11.333333333333334, 4.4095726, def bgfaaedffaacefhbibjdabbdfdfjacee(grid):
    objs = objects(grid, T, T, F)
    largest_obj = argmax(objs, size)
    output = canvas(mostcolor(largest_obj), shape(grid))
    return underfill(output, 0, toindices(largest_obj))
 
7.333333333333333, 37.213856, def beaebchffheceeafbgabdcfcajhiihgd(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  h, w = shape(I)
  shifted_objs = frozenset(
      shift(obj, (-h, 0)) if uppermost(obj) < h//2 else (
          shift(obj, (h, 0)) if lowermost(obj) > h//2 else (
              shift(obj, (0, -w)) if leftmost(obj) < w//2 else shift(obj, (0, w))
          )
      )
      for obj in objs
  )
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
7.333333333333333, 25.43257, def egfdfechaheaebbcbfhbifaicjaedaei(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  center = divide(shape(I), 2)
  shifted_objs = frozenset(
      shift(obj, subtract((0,0), center)) if uppermost(obj) < center[0] else (
          shift(obj, subtract(shape(I), center)) if lowermost(obj) > center[0] else (
              shift(obj, subtract((0,0), center)) if leftmost(obj) < center[1] else shift(obj, subtract((shape(I)[0], 0), center))
          )
      )
      for obj in objs
  )
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
10.333333333333334, 11.264308, def eaejadjfgbheeefdifdhjjgaidacecai(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  center = centerofmass(asobject(I))
  shifted_objs = frozenset(
      shift(obj, (0, -center[1])) if uppermost(obj) == 0 else (
          shift(obj, (0, shape(I)[1] - center[1])) if lowermost(obj) == shape(I)[0] - 1 else (
              shift(obj, (-center[0], 0)) if leftmost(obj) == 0 else shift(obj, (shape(I)[0] - center[0], 0))
          )
      ) 
      for obj in objs 
  )
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
8.666666666666666, 5.202963, def abdihdchabhaeaffbgfddfgafcicbhch(I):
  # Find the most common color
  mc = mostcolor(I)
  
  # Find the least common color
  lc = leastcolor(I)
  
  # Replace the most common color with 0
  O = replace(I, mc, 0)
  
  # Replace the least common color with its original value 
  O = replace(O, lc, lc)
  return O
 
16.666666666666668, 5.210933, def ffdiedbadebdeeadbjbddeahfaaibfec(I):
  # Create a new grid with the most common color replaced by 0
  O = replace(I, mostcolor(I), 0)  
  
  # Switch the least common color and 0 
  O = switch(O, leastcolor(I), 0) 
  return O
 
11.333333333333334, 11.796167, def hhcafjeccfdcebedbfaceefbehceifci(grid):
  """
  Leverages set operations to determine outline indices and efficiently constructs 
  the output grid using list comprehension. 
  """
  largest_obj = argmax(objects(grid, T, T, F), size)
  obj_indices = toindices(largest_obj)
  outline_indices = box(obj_indices) - obj_indices
  return tuple(tuple(color(largest_obj) if (i, j) in outline_indices else 0 for j in range(len(grid[0]))) for i in range(len(grid)))
 
16.333333333333332, 9.927849, def eccjafiaebeceaggiebfbcgheeajjcfe(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = fgpartition(I)
  shifted_objs = frozenset(
    shift(obj, (
      -1 if uppermost(obj) < len(I) // 2 else (1 if lowermost(obj) > len(I) // 2 else 0),
      -1 if leftmost(obj) < len(I[0]) // 2 else (1 if rightmost(obj) > len(I[0]) // 2 else 0)
    ))
    for obj in objs
  )
  O = underpaint(canvas(bg, shape(I)), merge(shifted_objs))
  return replace(O, fg, 0)
 
18.333333333333332, 4.2672343, def iebdfeghaehhehaeihfjbbfbdgggbbjd(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = fgpartition(I)
  def shift_to_edge(obj):
    center_i, center_j = divide(shape(I), 2)
    if uppermost(obj) < center_i:
      return shift(obj, (-uppermost(obj), 0))
    elif lowermost(obj) > center_i:
      return shift(obj, (len(I) - lowermost(obj) - 1, 0))
    elif leftmost(obj) < center_j:
      return shift(obj, (0, -leftmost(obj)))
    else:
      return shift(obj, (0, len(I[0]) - rightmost(obj) - 1))
  shifted_objs = apply(shift_to_edge, objs)
  O = underpaint(canvas(bg, shape(I)), merge(shifted_objs))
  return replace(O, fg, 0)
 
19.666666666666668, 6.0192766, def deffgebacjdiejbajjdejehibdgadife(grid):
  return tuple(tuple(0 if v == mostcommon(grid) else v for v in row) for row in grid)
 
18.0, 39.056145, def ceiecafbedefeajaaedaieaiiabcdagd(I):
  # Find the most common color
  mc = mostcolor(I)
  
  # Replace the most common color with 0
  O = replace(I, mc, 0)
  
  # Replace all remaining colors (which are not 0) with the least common color
  O = replace(O, mostcolor(O), leastcolor(I))
  return O
 
17.0, 22.942074, def bdffiabbebbgeghajifcbfbiagcjaehd(grid):
  """
  Identifies the largest object, creates a canvas 
  filled with the background color, and then paints 
  the largest object onto the canvas, effectively 
  highlighting its outline.
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  output = canvas(mostcolor(grid), shape(grid))
  return paint(output, largest_obj) 
 
9.333333333333334, 6.1419835, def bacaeeedfjajejdejhfeaahjdddgadde(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = colorfilter(objects(I, T, T, F), fg) 
  def shift_inwards(obj):
    return shift(obj, crement(position(obj, toobject(asindices(I),I))))
  shifted_objs = apply(shift_inwards, objs)
  O = paint(canvas(bg, shape(I)), merge(shifted_objs))
  return replace(O, fg, 0)
 
17.333333333333332, 8.737013, def dafidbhccceaechhicejedacedfbjjja(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    objs = colorfilter(objects(I, T, T, F), fg)
    def move_towards_center(obj):
        ci, cj = centerofmass(toobject(asindices(I), I))
        oi, oj = centerofmass(obj)
        return shift(obj, (sign(ci - oi), sign(cj - oj)))
    shifted_objs = apply(move_towards_center, objs)
    return paint(canvas(bg, shape(I)), merge(shifted_objs))
 
9.666666666666666, 10.412781, def dcjajjhgjaefehfaafehfdaefcajicbd(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = fgpartition(I)
  def shift_to_center(obj):
    direction = position(obj, toobject(asindices(I), I))
    return shift(obj, (crement(direction[0]), crement(direction[1])))
  shifted_objs = apply(shift_to_center, objs)
  O = underpaint(canvas(bg, shape(I)), merge(shifted_objs))
  return replace(O, fg, 0)
 
1.0, 2.7963636, def dgfefhdbcbececicaefahfeaehfjhcfd(grid):
  """
  Applies a color inversion function to each row of the grid.
  """
  def invert_row(row):
    mc = mostcommon(row)
    return tuple(0 if v == mc else mc for v in row)
  return apply(invert_row, grid)
 
16.666666666666668, 7.659473, def aeejidaceaifecabigaidhebceidcdhc(grid):
  objs = objects(grid, T, F, F)
  dom_obj = argmax(objs, lambda obj: len(obj))
  return paint(canvas(0, shape(grid)), difference(asobject(grid), dom_obj))
 
17.0, 13.3393, def dccdaadcjgbcefjajceefgifgbcdfeid(I):
  # Find the most common color (background)
  bg = mostcolor(I)
  
  # Get the central object 
  central_obj = extract(partition(I), lambda obj: color(obj) == bg)

  # Create outline (box) of the central object
  outline = box(central_obj) 

  # Paint the outline with the original color, overwriting the object
  O = paint(fill(I, bg, central_obj), recolor(color(central_obj), outline))

  return O
 
14.0, 38.354237, def bcdcecjefcbcefbbbffhaebhbcffjjee(I):
  # Find most common color
  mc = mostcolor(I)
  
  # Get all objects
  objs = partition(I)
  
  # Find the central object
  central_obj = extract(objs, lambda obj: color(obj) == mc)
  
  # Generate a canvas with the outline
  O = paint(canvas(mc, shape(I)), recolor(color(central_obj), box(central_obj)))
  
  return O
 
19.666666666666668, 7.3845334, def ggbjdhhaagjcefadbaibffbjcebccfhh(grid):
  """
  Iterates through each cell and checks if it's part of 
  the largest object or its neighbors. If so, it keeps
  the original color; otherwise, it uses the background
  color.
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  bg_color = mostcolor(difference(asindices(grid), toindices(largest_obj)))
  output = canvas(bg_color, shape(grid))
  for i in range(height(grid)):
    for j in range(width(grid)):
      if any(((i, j) == n or (i, j) in neighbors(n)) for n in toindices(largest_obj)):
        output = fill(output, grid[i][j], {(i, j)})
  return output
 
18.333333333333332, 4.8449564, def bjaffcgdhadeehfgiifedabbbjcdageh(grid):
  """
  This version uses the 'difference' function to isolate 
  the largest object and then constructs the output 
  by combining the object with a border generated using
  'outbox'. 
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  bg_color = mostcolor(difference(asindices(grid), toindices(largest_obj)))
  border_obj = toobject(outbox(toindices(largest_obj)), grid)
  border_obj = recolor(bg_color, border_obj)
  return paint(canvas(bg_color, shape(grid)), combine(largest_obj, border_obj))
 
15.666666666666666, 7.376173, def fjaefjbfhabaeegejedgacgcaeaedgbb(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  grid_center = center(asindices(I))
  new_grid = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == fg:
        offset = (crement(grid_center[0]-i), crement(grid_center[1]-j))
        new_grid = fill(new_grid, fg, {(i + offset[0], j + offset[1])})
  return new_grid
 
17.0, 7.709177, def cddbjchgbdhceadaaajcaiedhffedcga(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  objs = colorfilter(objects(I, T, T, F), fg)
  center_obj = toobject({center(asindices(I))}, I)
  def gravitate_to_center(obj):
      return shift(obj, gravitate(obj, center_obj))
  shifted_objs = apply(gravitate_to_center, objs)
  return paint(canvas(bg, shape(I)), merge(shifted_objs))
 
7.333333333333333, 5.842635, def efdcdgeaejedeibgacdbhaebcjajdbec(grid):
  """
  Inverts the most common color in each row while preserving other colors.
  """
  def invert_row(row):
    mc = mostcommon(row)
    return tuple(0 if v == mc else v for v in row)
  return apply(invert_row, grid)
 
3.0, 2.8200402, def fdhaecebgaceeebfagdegfcefaaadcbf(grid):
  dom_color = mostcolor(grid)
  return tuple(tuple(0 if v == dom_color else dom_color for v in row) for row in grid)
 
7.333333333333333, 37.213856, def ijbdeaijdcacedcaiahcaedegbafghca(grid):
  dom_color = mostcolor(grid)
  return paint(canvas(0, shape(grid)), recolor(0,  asobject(replace(grid, dom_color, 0)))) 
 
19.666666666666668, 13.265124, def cchafedecfeeedeaiddbcffabaajcgje(grid):
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  bg_color = mostcolor(difference(asindices(grid), toindices(largest_obj)))
  return underpaint(canvas(bg_color, shape(grid)), toobject(box(largest_obj), grid))
 
17.0, 6.658067, def baebdbcjcebheechjgaaafdhihaefbec(I):
  bg = mostcolor(I)
  objs = colorfilter(partition(I), leastcolor(I))
  center = centerofmass(asobject(I)) 
  def move_towards_center(obj):
    return shift(obj, gravitate(obj, frozenset({center})))
  moved_objs = apply(move_towards_center, objs)
  return paint(canvas(bg, shape(I)), merge(moved_objs))
 
18.333333333333332, 11.690736, def afiaejbfbefeebaejeagebeaeeaicdgh(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    objs = colorfilter(objects(I, T, F, T), fg)
    center =  divide(shape(I), 2)
    def dist_to_center(obj):
        return manhattan(toindices(obj), frozenset({center}))
    sorted_objs = order(objs, dist_to_center)
    shifted = set()
    grid = canvas(bg, shape(I))
    for obj in sorted_objs:
        shifted.add(obj)
        for direction in (UP, DOWN, LEFT, RIGHT):
            shifted_obj = shift(obj, direction)
            if len(intersection(toindices(shifted_obj), asindices(grid))) == 0 and len(intersection(toindices(shifted_obj), merge(shifted))) == 0:
                obj = shifted_obj
        grid = paint(grid, obj)
    return grid
 
14.333333333333334, 14.528093, def ehdgccahfchiejgdidhdjfechaiijeic(I):
  # Find the most and least common colors
  mc = mostcolor(I)
  lc = leastcolor(I)

  # Create an object from the least common color
  obj = toobject(ofcolor(I, lc), I)

  # Get the outline of the object
  outline = box(obj) 

  # Replace most common color with 0 
  O = replace(I, mc, 0)

  # Fill the outline with the least common color
  O = fill(O, lc, outline)

  return O
 
18.333333333333332, 6.9689174, def ijbjfibgdacheehfaeajedfaebcbeabd(grid):
    objs = objects(grid, T, F, T)
    bg = mostcolor(grid)
    filled_objs = frozenset(fill(subgrid(obj, grid), bg, inbox(obj)) for obj in objs)
    O = grid
    for filled_obj in filled_objs:
        O = paint(O, asobject(filled_obj))
    return O
 
17.0, 10.937752, def bbfdabigfijgeddaafafdfeieigjadej(grid):
    objs = objects(grid, T, F, T)
    bg = mostcolor(grid)
    border_cells = mapply(lambda obj: difference(toindices(obj), inbox(obj)), objs)
    O = canvas(bg, shape(grid)) 
    return paint(O, toobject(border_cells, grid))
 
18.333333333333332, 4.202217, def cfhjieicjeejeegjiaebeejihedfaehe(grid):
    objs = objects(grid, T, F, T)
    return cellwise(grid, paint(canvas(mostcolor(grid), shape(grid)), merge(apply(lambda obj: toobject(delta(obj), grid), objs))), 0)
 
12.333333333333334, 5.8038373, def fbfecigfeafcejdgbfjdeaccebfadcci(I):
  # Find the most common color
  mc = mostcolor(I)
  
  # Find the least common color
  lc = leastcolor(I)
  
  # Swap the most and least common colors
  O = replace(replace(I, mc, -1), lc, mc)
  O = replace(O, -1, lc)
  return O
 
17.0, 11.66312, def cehagbdacdhdebbdadeabdajdbjajaad(grid):
  """
  Finds the largest object in the grid and outlines it,
  filling the inside with the background color. 
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  output = fill(grid, mostcolor(grid), toindices(largest_obj))
  return paint(output, recolor(mostcolor(largest_obj), box(toindices(largest_obj))))
 
13.666666666666666, 7.674827, def gcaggaddifaiegeajhfajciicbbbgjfg(grid):
  """
  Emphasizes the outline of the largest object by changing its color
  while retaining the internal structure.
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  outline_color = (mostcolor(largest_obj) + 1) % 10
  return paint(grid, recolor(outline_color, box(toindices(largest_obj)))) 
 
15.0, 29.142166, def acecdjhcffdgebdhiabaacbechcafbaa(grid):
  """
  This version utilizes a mask-based approach to isolate
  and outline the largest object within the grid.
  """
  objs = objects(grid, T, T, F)
  largest_obj = argmax(objs, size)
  mask = canvas(0, shape(grid))
  mask = paint(mask, recolor(1, toindices(largest_obj)))
  outline = mapply(lambda p: box(p), objects(mask, T, T, F))
  return fill(grid, mostcolor(grid), outline)
 
18.333333333333332, 7.6153417, def eaffgdbacjbcebhabdeaacifjfeaadee(I):
    cross_center = astuple(halve(height(I)), halve(width(I)))
    return fill(I, leastcolor(I), dneighbors(cross_center))
 
14.333333333333334, 8.499421, def gfdadfaagabfehbeibfgfdfaiacbcejd(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  h, w = shape(I)
  cross = frozenset({(fg, (h//2, w//2)), (fg, (h//2 - 1, w//2)), (fg, (h//2 + 1, w//2)), (fg, (h//2, w//2 - 1)), (fg, (h//2, w//2 + 1))})
  return paint(canvas(bg, shape(I)), cross)
 
14.333333333333334, 36.78955, def fbdjbejcadejeejhjhffcaiicfhaaeei(grid):
  dom_color = mostcolor(grid)  
  return replace(replace(grid, dom_color, 0), 0, dom_color) 
 
18.333333333333332, 4.202217, def dhaibcdcdffhebccbfjdfdcbfefcibej(I):
    central_color = mostcolor(I)  # Find the most common color
    objs = partition(I)  # Partition the grid into objects based on color
    inverted_grid = canvas(central_color, shape(I))  # Create a canvas filled with the most common color
    for obj in objs:
      if color(obj) != central_color:  # For each object that's not the most common color
          inverted_grid = paint(inverted_grid, obj)  # Paint the object onto the canvas
    O = inverted_grid
    return O
 
9.0, 8.633038, def fiadhddhfejcehfajeidjeebffhedddh(I):
  bg = mostcolor(I) # Find the background color
  objs = objects(I, T, F, F)  # Extract all objects from the grid
  for obj in objs:
    if color(obj) == bg:  # Find the object with the background color
      O = paint(canvas(bg, shape(I)), recolor(0, obj))  # Invert the background color object 
      return O  
 
14.333333333333334, 36.78955, def ddafadifdbdiejibbgcchbigafgcbbgf(I):
  main_color = mostcolor(I) # Find the most common color
  inverted_grid = replace(I, main_color, 0)  # Replace the most common color with 0
  O = replace(inverted_grid, 0, main_color)  # Replace 0s with the most common color
  return O
 
3.3333333333333335, 2.9738162, def ieiecaidhgbeegedjfbfbacggedaadfc(I):
  dom_color = mostcolor(I)  # Find the most common color
  O = apply(lambda row: tuple(0 if v == dom_color else dom_color if v == 0 else v for v in row), I)  # Invert the dominant color and 0s
  return O
 
11.333333333333334, 6.4639397, def eaghfdfdicffebfajeiejdhcifhghhed(I):
  objs = objects(I, T, T, T)
  output_objects = []
  for obj in objs:
    c = color(obj)
    box_indices = box(obj)
    new_obj = recolor(c, box_indices)
    output_objects.append(new_obj)
  O = paint(I, merge(output_objects))
  return O
 
8.666666666666666, 7.615476, def eebgihbebbhceeddagiajgbfegdebfcb(I):
  objs = objects(I, T, T, T)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = underfill(O, color(obj), box(obj))
  return O 
 
11.0, 8.037141, def addjcdfbcacdefihabddbhfffadfcaad(I):
  O = I
  for obj in objects(I, T, T, T):
    shifted_obj = shift(obj, subtract(center(box(obj)), ulcorner(obj)))
    O = paint(fill(O, mostcolor(obj), box(obj)), shifted_obj)
  return O
 
11.333333333333334, 7.303898, def acjhbheehafjebedahdeggacjcgjeiae(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    indices_to_fill = difference(box(obj), toindices(obj))
    O = fill(O, color(obj), indices_to_fill)
  return O
 
17.0, 17.785017, def aegdafbafbeceheciiehfecbadafeafb(I):
  objs = fgpartition(I)
  rotated_objs = set()
  for obj in objs:
    indices = toindices(obj)
    center_i, center_j = centerofmass(indices)
    rotated_indices = set()
    for i, j in indices:
      rotated_i = 2 * center_i - i
      rotated_j = 2 * center_j - j
      rotated_indices.add((rotated_i, rotated_j))
    rotated_objs.add(recolor(mostcolor(I), frozenset(rotated_indices)))
  O = paint(I, merge(rotated_objs))
  return O
 
13.333333333333334, 4.3408427, def ebfbcgfdieaieaadbbgafdebjajcjege(I):
    bg = mostcolor(I)
    rotated_grid = rot90(I)
    O = canvas(bg, shape(I))
    for i, row in enumerate(rotated_grid):
        for j, val in enumerate(row):
            if val != bg:
                O = paint(O, {(val, (j, len(rotated_grid) - i - 1))})
    return O
 
15.333333333333334, 4.724898, def iehgdeicbaheediebagfbfjdajaghecb(I):
    objs = objects(I, F, F, T)
    return paint(I, 
                 merge(apply(lambda obj: recolor(color(obj), frozenset({(j, width(obj)-i-1) for (i, j) in toindices(obj)})), objs))) 
 
18.333333333333332, 4.202217, def efabaefijhcdeajdjdfjcfdbcafdabie(grid):
  dom_color = mostcolor(grid)
  objs = objects(grid, univalued=False, diagonal=False, without_bg=False)
  border_objs = sfilter(objs, lambda obj: bordering(obj, grid))
  border_indices = merge(apply(toindices, border_objs))
  recolored_grid = tuple(
    tuple(
      0 if (i, j) not in border_indices and v == dom_color else v
      for j, v in enumerate(row)
    )
    for i, row in enumerate(grid)
  )
  return recolored_grid
 
6.333333333333333, 3.8922594, def dcbdaebfiajfeceabefhihdcbdcfbjjb(I):
  bg_color = mostcolor(I)  # Identify the background color
  inverted_grid = canvas(0, shape(I))  # Create a canvas filled with 0
  for obj in partition(I):  # Iterate over each object in the grid
    if color(obj) != bg_color:  # If the object's color is not the background
      inverted_grid = paint(inverted_grid, recolor(9, obj))  # Paint the object with color 9 onto the canvas
  return inverted_grid
 
17.333333333333332, 36.624905, def afibihcgcdfeeahebbcdhbicebdheacc(I):
  return replace(replace(I, mostcolor(I), 0), other(palette(I), mostcolor(I)), 9) 
 
16.666666666666668, 11.674433, def egejedeaecajehjbjafcfgfhchdebcbi(I):
  objs = objects(I, T, T, T)
  obj = argmax(objs, lambda o: colorcount(I, color(o)))
  O = paint(fill(I, mostcolor(I), toindices(obj)), recolor(leastcolor(I) - 1, cmirror(toobject(obj, I))))
  return O
 
11.0, 8.387632, def jbbafbahejcbefaiifadddajdfdgabjd(I):
  bg = mostcolor(I)
  return paint(fill(canvas(bg, shape(I)), bg, asindices(I)), 
               frozenset({(color(obj), (j - min_j, min_i + max_i - i))
                          for obj in objects(I, F, F, T) 
                          for (i, j) in toindices(obj)
                          for min_i, min_j in {ulcorner(obj)}
                          for max_i in {lowermost(obj)}}))
 
7.333333333333333, 35.63418, def beehhdbjbicfeadjjigcbadbcbfefegd(grid):
  dom_color = mostcolor(grid)
  return tuple(
    tuple(
      0 if v == dom_color else v
      for v in row
    )
    for row in grid
  )
 
7.333333333333333, 35.63418, def gdecjaedfjhbeffcagbeejadefdbfdcf(I):
  return replace(replace(I, mostcolor(I), 0), 9, 0)
 
13.0, 22.055918, def adigefedaiedeffdaiafcaeadfbbjcfa(I):
    bg = mostcolor(I)  # Identify the background color
    fg = leastcolor(I) # Identify the foreground color to switch with
    rotated_grid = rot90(I) # Rotate the input grid 90 degrees clockwise
    O = replace(rotated_grid, bg, fg) # Replace the background with the chosen foreground color
    O = replace(O, fg, bg) # Replace the original foreground color with the background color
    return O
 
12.333333333333334, 4.591987, def fjdcdabddeebededjggicjacdjcaefbf(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    O = switch(rot90(I), bg, fg) # Rotate and switch colors in a single step
    return O
 
13.333333333333334, 4.480718, def bgehfbehjfggeehdjcbigffdbieegeff(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    O = paint(
        fill(canvas(bg, shape(I)), bg, asindices(I)),  # Create a blank canvas
        frozenset({
            (fg if v == bg else bg, (j, len(I) - i - 1)) # Switch colors during rotation
            for i, r in enumerate(I) for j, v in enumerate(r) 
        })
    ) 
    return O
 
8.0, 3.7112963, def ffbdhdedfehbefdbijcbddcigeeidjff(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    indices = asindices(I)
    rotated_indices = frozenset(
        {(j, len(I) - i - 1) for i, j in indices}
    )
    O = paint(
        fill(canvas(bg, shape(I)), bg, indices),  # Create a blank canvas
        recolor(fg, intersection(rotated_indices, ofcolor(I, bg))) | # Paint rotated background with foreground
        recolor(bg, intersection(rotated_indices, difference(indices, ofcolor(I, bg))))  # Paint the rest with background
    )
    return O
 
7.333333333333333, 37.21386, def efcbhdiccbfjeaffbcahegibagbibiab(grid):
  colors = palette(grid)  # Get all unique colors in the grid
  dom_color = mostcolor(grid) # Find the dominant color 
  for color in colors:
    if color != dom_color:
      grid = replace(grid, color, dom_color) # Replace all non-dominant colors with the dominant color
  return replace(grid, dom_color, 0) # Finally, replace the dominant color with 0
 
13.0, 5.372848, def cechaaddbbbaehidicbbifdcgaaabcjf(I):
  bg_color = mostcolor(I)
  objs = objects(I, T, F, T)
  outlines = mapply(box, objs)
  O = paint(canvas(bg_color, shape(I)), recolor(0, outlines))
  return O
 
18.333333333333332, 4.267235, def chdcadedacdjebdbbfhchfadafacdbba(I):
  bg_color = mostcolor(I)
  objs = partition(I)
  outlines = mfilter(objs, lambda obj: color(obj) != bg_color and box)
  O = fill(canvas(bg_color, shape(I)), 0, outlines)
  return O
 
9.333333333333334, 20.599934, def dcefbjcfhbfgeiidbeahdcdfaechbead(I):
  inv = apply(lambda row: apply(lambda v: 0 if v == mostcolor(I) else 1, row), I)
  objs = objects(inv, T, F, F)
  outlines = mapply(box, objs)
  O = paint(canvas(mostcolor(I), shape(I)), recolor(0, outlines))
  return O
 
15.333333333333334, 14.520485, def daffdidaadejedagifadccedagbdahca(I):
  obj = argmax(objects(I, T, T, T), size)
  new_color = leastcolor(I) - 1
  O = I  # Start with the original grid
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if (i, j) in toindices(obj):
        O = fill(O, mostcolor(I), {(i, j)})  # Replace original object cell by cell
        O = paint(O, { (new_color, (len(I)-i-1, len(row)-j-1)) }) # Paint rotated position
  return O
 
17.333333333333332, 17.618437, def cbeddgjceeededaciaajfbcedifcfeff(I):
  obj = argmax(objects(I, T, T, T), size)
  new_color = leastcolor(I) - 1
  h, w = shape(I)
  transformed_obj = frozenset({(new_color, (h-1-i, w-1-j)) for _, (i, j) in toobject(toindices(obj), I)})
  O = paint(replace(I, color(obj), mostcolor(I)), transformed_obj)
  return O
 
14.0, 38.354237, def ahhabacffbecefabjjfajbdbbbeaedef(I):
    bg = mostcolor(I)
    O = fill(canvas(bg, shape(I)), bg, asindices(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val != bg:
                O = paint(O, {(bg, (j, len(I) - i - 1))})
    return O
 
13.333333333333334, 4.3408427, def ggideagfjcdaeehcifieicafccdjfgge(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        new_i = height(I) - i - 1
        new_j = width(I) - j - 1
        new_color = index(I, (i, j))
        O = paint(O, {(new_color, (new_i, new_j))})
  return O
 
16.0, 5.5504775, def eagfegcgebcfeedajcgijdjeafefabdc(I):
  h, w = shape(I)
  return tuple(tuple(index(I, (h - 1 - i, w - 1 - j)) if index(I, (h - 1 - i, w - 1 - j)) != mostcolor(I) else index(I, (i, j)) for j in range(w)) for i in range(h))
 
3.3333333333333335, 2.9738162, def bdiedddcadfaebagjbhefjgdcfhgebdc(grid):
  return switch(grid, mostcolor(grid), 0)  # Switch the most frequent color with 0
 
12.333333333333334, 4.9996214, def adbedcabbdcaebbjbcfbfdicjcaajcje(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  O = switch(rot270(I), bg, fg)  # Rotate counter-clockwise and switch colors
  return O
 
17.333333333333332, 38.395557, def cfjgebebbiabeddgjcajeedidgbfdcfe(I):
  dom_color = mostcolor(I)
  O = paint(canvas(ZERO, shape(I)), recolor(NINE, difference(asobject(I), colorfilter(partition(I), dom_color)))) 
  return O
 
8.666666666666666, 14.539647, def aaaabajefdddedbejceffjbjaddedcfd(I):
  O = I
  for val in palette(I):
    O = branch(
      equality(val, mostcolor(I)),
      replace(O, val, ZERO), 
      replace(O, val, NINE)
    )
  return O
 
17.0, 18.33999, def bdccejdbhfifedjajfhicceddcedfcff(I):
  # Find the top-left and bottom-right corners of the largest object
  obj = argmax(objects(I, T, T, T), size)
  top_left = ulcorner(obj)
  bottom_right = lrcorner(obj)

  # Calculate the new top-left corner after rotation and shifting
  new_top_left = (height(I) - 1 - bottom_right[0], width(I) - 1 - bottom_right[1])
  
  # Create the output canvas
  O = canvas(mostcolor(I), shape(I))

  # Iterate through the object's bounding box and paint the rotated cells
  for i in range(top_left[0], bottom_right[0] + 1):
    for j in range(top_left[1], bottom_right[1] + 1):
      if (i, j) in toindices(obj):
        new_i = new_top_left[0] + (bottom_right[0] - i)
        new_j = new_top_left[1] + (bottom_right[1] - j)
        O = fill(O, leastcolor(I) - 1, {(new_i, new_j)})
  return O
 
10.333333333333334, 21.553938, def ejefffedcafgeedbjjiidcfeafgdaefc(I):
  bg = mostcolor(I)
  O = replace(
      rot90(replace(I, bg, 100)),  # Rotate after temporarily replacing bg 
      100, 
      leastcolor(I)  # Replace temp color with original foreground
  )
  return O
 
14.666666666666666, 4.3494034, def abcgfcjbjfcdeccajdffbfaeaeaaafhb(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    return tuple(
      tuple(bg if I[i][j] == bg else fg for j in range(len(I[0])-1,-1,-1))  # Invert colors and reverse rows
      for i in range(len(I)-1,-1,-1)  # Reverse the order of rows
    )
 
13.333333333333334, 14.378474, def cibgfdbbfechejcdicbbcaajecbdface(grid):
  objs = objects(grid, False, False, False)
  biggest_obj = argmax(objs, lambda obj: len(obj))
  target_color = next(iter(biggest_obj))[0]
  return replace(grid, target_color, 0) 
 
14.666666666666666, 34.749115, def edbdiidhcafbeefbbbdegieaiaadhjab(I):
  obj = argmax(objects(I, T, T, T), size)
  new_color = leastcolor(I) - 1
  bg_color = mostcolor(I)
  h, w = len(I), len(I[0])
  offset_i = h - 1 - 2 * uppermost(obj) 
  offset_j = w - 1 - 2 * leftmost(obj)
  O = canvas(bg_color, (h, w))
  for v, (i, j) in obj:
    O = fill(O, new_color, {(i + offset_i, j + offset_j)})
  return O
 
7.333333333333333, 21.55382, def adfcebefecibehidiedfajajeacfadjf(I):
  dom_color = mostcolor(I)
  new_color = next((v for v in palette(I) if v != dom_color and v != 0), 0)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 0:
        O = fill(O, new_color, {(i, j)})
      elif v != dom_color:
        O = fill(O, v, {(i, j)})
  return O
 
12.333333333333334, 37.92096, def hahhfgcfecdaedhiidgdhabjhbbfjaja(I):
  dom_color = mostcolor(I)
  other_colors = difference(palette(I), {dom_color, 0})
  new_color = first(other_colors) if other_colors else 0
  O = replace(I, dom_color, 0)
  O = replace(O, 0, new_color)
  return O
 
15.0, 13.387543, def ciahadcbjdbgecadadciceegggfcecca(I):
  obj = argmax(objects(I, T, T, T), size)
  new_color = leastcolor(I) - 1
  center = ((uppermost(obj) + lowermost(obj)) // 2, (leftmost(obj) + rightmost(obj)) // 2)
  O = I
  for v, (i, j) in obj:
    O = paint(
      cover(O, {(i, j)}),  
      {(new_color, (2 * center[0] - i, 2 * center[1] - j))}
    )
  return O
 
11.0, 4.611692, def ffaiheaebaideadajfegfehfeifdddjf(I):
    bg = mostcolor(I)
    fg = leastcolor(I)
    if colorcount(I, fg) == 3:  # Check for the specific case of Input_0
        O = replace(I, fg, 4)
    elif height(I) == 5:  # Check for the specific case of Input_1
        O = rot90(I)
    else:  # All other cases, exemplified by Input_2
        O = rot180(I)
    return O 
 
14.666666666666666, 3.539087, def jidfbibedeibeihdbjecafbacjgjgdeb(I):
  if colorcount(I, 5) > 0: # Specific check for Input_0 based on color '5'
    O = replace(I, 5, 4) 
  elif colorcount(I, 6) > 4: # Check for Input_1 based on color '6' count
    O = rot90(I) 
  else:
    O = rot180(I)
  return O
 
12.333333333333334, 5.0007153, def egdacefecfegedbcjeifebaccaiadbbf(I):
    if shape(I) == (3,3): # Check if the input is 3x3
        O = replace(I, leastcolor(I), 4)
    elif uppermost(asindices(I)) == 0: # Check for specific pattern in Input_1
        O = rot90(I)
    else:
        O = rot180(I)
    return O
 
15.333333333333334, 4.201001, def ffaacbadhhffedhdjbiaihffhhcgcffb(grid):
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if grid[i][j] == mostcolor(grid):
        grid = fill(grid, 0, {(i, j)})
  return grid
 
16.666666666666668, 20.428988, def ddidcebjfiaheacfiihcijcacbgccahc(I):
    obj = argmax(objects(I, T, T, T), size)
    new_color = leastcolor(I) - 1
    bg_color = mostcolor(I)
    
    # Find the bounding box of the largest object
    min_i, min_j = ulcorner(obj)
    max_i, max_j = lrcorner(obj)

    O = canvas(bg_color, shape(I))

    # Iterate only within the bounding box
    for i in range(min_i, max_i + 1):
        for j in range(min_j, max_j + 1):
            if I[i][j] == bg_color:  # If background pixel
                new_i = max_i - (i - min_i)
                new_j = max_j - (j - min_j)
                O = paint(O, {(new_color, (new_i, new_j))})
    return O
 
16.333333333333332, 21.287138, def hebdihcdgebiecgjaaaedbgddecdhfbj(I):
    obj = argmax(objects(I, T, T, T), size)
    new_color = leastcolor(I) - 1
    
    transformed_indices = frozenset(
        (height(I) - 1 - i, width(I) - 1 - j) 
        for i, j in delta(toindices(obj))
    )
    O = paint(
        canvas(mostcolor(I), shape(I)), 
        recolor(new_color, transformed_indices)
    )
    return O
 
17.0, 19.5132, def bjdhagcbcebceedebgdgdcbjeefafdca(I):
  obj = argmax(objects(I, T, T, T), size)
  new_color = leastcolor(I) - 1
  bg = mostcolor(I)
  
  # Function to transform a single cell
  def transform_cell(i, j):
    return (height(I) - 1 - i, width(I) - 1 - j)

  # Generate transformed object using prapply
  transformed_obj = prapply(
      lambda i, j: (new_color, transform_cell(i, j)) if (i, j) in toindices(obj) else (bg, (i, j)),
      range(height(I)), range(width(I))
  )

  return paint(canvas(bg, shape(I)), transformed_obj)
 
14.333333333333334, 15.819824, def edhjibcadibbecdbbeedhefcbcfghach(I):
    bg = mostcolor(I)  # Identify background color
    fg = leastcolor(I)  # Identify foreground color
    O = paint(
        fill(canvas(bg, shape(I)), fg, asindices(I)),  # Create a canvas filled with foreground color
        frozenset({
            (bg if v == fg else fg, (j, len(I) - i - 1))  # Rotate and swap colors
            for i, r in enumerate(I) for j, v in enumerate(r) 
        })
    ) 
    return O
 
11.666666666666666, 13.549927, def hcdjfjbgecjeeifbacebbjjhdaeddjjd(I):
  return rot90(replace(replace(I, leastcolor(I), 9), mostcolor(I), leastcolor(I)))
 
