0.06222222222222223, 20.475897, def fhejdhfjdbfaecafidfhbacgjjhgbcei(I):
  O = canvas(0, shape(I))  # Initialize output grid with background
  for j in range(width(I)):
    column = [(i, j) for i in range(height(I))]
    for i, loc in enumerate(column):
      if index(I, loc) != 0:  # Found a non-background cell
        new_i = next((k for k in range(i + 1, height(I)) if index(I, (k, j)) != 0), height(I) - 1) # Find the lowest empty cell below
        O = paint(O, {(index(I, loc), (new_i, j))}) # Paint the cell at the new location
  return O
 
0.06222222222222223, 16.572397, def cfffgcfchcidedgajddfbeeiafhgdich(I):
  h, w = shape(I)
  O = I
  for j in range(w):
    for i in range(h - 1, -1, -1): # Iterate from bottom to top
      if index(I, (i, j)) != 0: # Non-background cell
        k = next((l for l in range(i + 1, h) if index(I, (l, j)) != 0), h) # Find next non-background cell below
        O = paint(cover(O, {(index(I, (i, j)), (i, j))}), {(index(I, (i, j)), (k - 1, j))}) # Move the cell down
  return O
 
0.07111111111111111, 14.920588, def cbeadhahbagjegdjaciaecacbigbaebf(I):
    h, w = len(I), len(I[0])
    O = [[0 for _ in range(w)] for _ in range(h)] # Initialize empty output grid
    for j in range(w):
        next_i = h - 1
        for i in range(h - 1, -1, -1):
            if I[i][j] != 0:
                O[next_i][j] = I[i][j]
                next_i -= 1
    return tuple(tuple(row) for row in O)
 
0.05777777777777778, 16.01153, def jhcdbjhajicaeedbjhccifhhffbajaef(I):
  objs = objects(I, T, F, T)
  grid_height = height(I)
  grid_width = width(I)
  center_row = grid_height // 2
  center_col = grid_width // 2
  O = I
  for obj in objs:
    obj_ul_row, obj_ul_col = ulcorner(obj)
    target_row = center_row if obj_ul_row < center_row else obj_ul_row 
    target_col = center_col if obj_ul_col < center_col else obj_ul_col
    O = move(O, obj, (target_row - obj_ul_row, target_col - obj_ul_col))
  return O 
 
0.05777777777777778, 15.738148, def aichdccieggjehbajdffiabbdajgfdcd(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != 0:
        target_row = len(I) // 2 if i < len(I) // 2 else i
        target_col = len(row) // 2 if j < len(row) // 2 else j
        obj = toobject(initset((i,j)), I)
        O = move(O, obj, (target_row - i, target_col - j))
  return O
 
0.04148148148148148, 30.177063, def gaebhcafeiiaejfhjjcbbfiffffedbbf(I):
  objs = objects(I, T, F, T)
  O = canvas(0, shape(I))
  for obj in objs:
    obj_ul_row, obj_ul_col = ulcorner(obj)
    target_row = (height(I) // 2) - (height(obj) // 2)
    target_col = (width(I) // 2) - (width(obj) // 2)
    O = paint(O, shift(obj, (target_row - obj_ul_row, target_col - obj_ul_col)))
  return O
 
0.06814814814814815, 15.842084, def eacheefjfcdfedabaedfdfijcacdbgbd(I):
    shifted_grid = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value != 0:
                target_row =  i - ((i - len(I) // 2) // 2)
                target_col = j - ((j - len(row) // 2) // 2) 
                shifted_grid = fill(shifted_grid, value, {(target_row, target_col)})
    return shifted_grid
 
0.06814814814814815, 20.269363, def dheadfbbjefiecafjffbgecaefdbbcaa(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    row_shift = (height(I) // 2) - (uppermost(obj) + height(obj) // 2)
    col_shift = (width(I) // 2) - (leftmost(obj) + width(obj) // 2)
    O = paint(O, shift(obj, (row_shift, col_shift)))
  return O
 
0.04, 9.010117, def fhdebfdifdcbeebbiafjhfeabhfjache(I):
  objs = objects(I, T, T, T)
  threes = colorfilter(objs, 3)
  sevens = colorfilter(objs, 7)
  other_obj = first(difference(objs, threes | sevens))
  target = centerofmass(other_obj)
  moved_threes = mapply(lambda obj: shift(obj, gravitate(obj, {(3, target)})), threes)
  moved_sevens = mapply(lambda obj: shift(obj, gravitate(obj, {(7, target)})), sevens)
  O = paint(paint(I, moved_threes), moved_sevens)
  return O
 
0.0651851851851852, 11.474966, def gfeafdaccbgcehfbjjccbdbcebfejacf(I):
  objs = objects(I, T, T, T)
  target_obj = argmax(objs, lambda obj: colorcount(obj, 3) + colorcount(obj, 7))
  target_center = centerofmass(target_obj)
  moved_objs = mapply(lambda obj: shift(obj, gravitate(obj, {(color(obj), target_center)})), objs)
  O = paint(I, moved_objs)
  return O
 
0.07555555555555556, 11.625855, def diehbcachdgfedbfbgcdfdacdfidfedb(I):
  objs = fgpartition(I)
  target_color = leastcommon([v for row in I for v in row])
  target_obj = extract(objs, lambda obj: color(obj) == target_color)
  target_location = centerofmass(target_obj)
  moved_objs = set()
  for obj in objs:
    if obj == target_obj:
      moved_objs.add(obj)
      continue
    obj_location = centerofmass(obj)
    diff = subtract(target_location, obj_location)
    moved_objs.add(shift(obj, diff))
  O = paint(I, merge(moved_objs))
  return O
 
0.04148148148148148, 32.480675, def jffbeacajefgecjcjffahcjgjeedeafa(I):
    objs = objects(I, F, T, T)  # Extract all objects (non-background)
    shifted_objs = frozenset(shift(obj, (-uppermost(obj), -leftmost(obj))) for obj in objs) # Move each object to the top left corner
    O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs)) # Paint the shifted objects onto a blank canvas
    return O
 
0.04148148148148148, 32.59751, def hgfcdfedciefeabbjefibgaddcdbeddd(I):
    O = canvas(mostcolor(I), shape(I))  # Create a blank canvas
    non_bg_indices = difference(asindices(I), ofcolor(I, mostcolor(I))) # Find indices of non-background cells
    for i, j in non_bg_indices:
        O = paint(O, {(I[i][j], (i - i, j - j))})  # Move each non-background cell to the top-left
    return O
 
0.07407407407407407, 17.707657, def adeecadfeeieeaedjfebdddeeacjddec(I):
    objs = sorted(objects(I, F, T, T), key=lambda obj: (uppermost(obj), leftmost(obj))) # Get and sort objects by top-left position
    O = canvas(mostcolor(I), shape(I))  # Create blank canvas
    for i, obj in enumerate(objs):
        O = paint(O, shift(obj, (-uppermost(obj), -leftmost(obj) + i)))  # Move each object, shifting right for each subsequent object
    return O
 
0.05037037037037037, 25.563395, def fcjbdcdfbadceehgjeegffbbfadeebfb(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  
  # Find the largest object and the object containing '2'
  largest_obj = argmax(objs, size)
  obj_2 = extract(objs, lambda obj: TWO in palette(obj))
  other_objs = objs - {largest_obj, obj_2}
  
  # Define target areas
  top_area = crop(I, (ZERO, ZERO), (THREE, width(I)))
  bottom_area = crop(I, (height(I) - TWO, ZERO), (TWO, width(I)))
  
  # Clear the grid and paint objects to their target areas
  I = canvas(ZERO, shape(I))
  I = paint(I, shift(largest_obj, subtract((ONE, (width(I) - width(largest_obj)) // TWO), ulcorner(largest_obj))))
  I = paint(I, shift(obj_2, subtract((ONE, rightmost(largest_obj) + TWO), ulcorner(obj_2))))

  for obj in other_objs:
    I = paint(I, shift(obj, subtract(ulcorner(bottom_area), ulcorner(obj))))

  return I
 
0.05037037037037037, 25.554003, def bcecddgdeiggeaaabdicegfdgaadagfj(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  
  # Define functions to find target locations
  find_top_center = lambda obj: (ONE, (width(I) - width(obj)) // TWO)
  find_below_top = lambda obj: (THREE, (width(I) - width(obj)) // TWO)
  find_bottom_center = lambda obj: (height(I) - TWO, (width(I) - width(obj)) // TWO)
  
  # Sort objects based on size 
  sorted_objs = order(objs, size)
  
  # Clear the grid and paint objects based on their size order
  I = canvas(ZERO, shape(I))
  for i, obj in enumerate(sorted_objs):
    if i == 0: 
      I = paint(I, shift(obj, subtract(find_bottom_center(obj), ulcorner(obj))))
    elif i == 1:
      I = paint(I, shift(obj, subtract(find_below_top(obj), ulcorner(obj))))
    else:
      I = paint(I, shift(obj, subtract(find_top_center(obj), ulcorner(obj))))

  return I
 
0.045925925925925926, 25.903036, def eehijcjffghjeadibiedfbhfiggfgaia(I):
  bg = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  
  # Identify the two largest objects
  largest_obj = argmax(objs, size)
  second_largest_obj = argmax(objs - {largest_obj}, size)

  # Calculate new positions based on object sizes and grid dimensions
  new_pos_largest = (ONE, (width(I) - width(largest_obj)) // TWO)
  new_pos_second_largest = (THREE, (width(I) - width(second_largest_obj)) // TWO)
  
  # Clear the grid, move the two largest objects, and fill the rest with the background color
  I = canvas(bg, shape(I))
  I = paint(I, shift(largest_obj, subtract(new_pos_largest, ulcorner(largest_obj))))
  I = paint(I, shift(second_largest_obj, subtract(new_pos_second_largest, ulcorner(second_largest_obj))))

  return I
 
0.04148148148148148, 31.807785, def fjfbgdfbdgdbedccijbddgddgajdbbaa(I):
  objs = objects(I, True, False, True)  # Extract non-background objects
  grid_height = height(I) 
  for obj in objs:
    obj_height = height(obj)
    I = move(I, obj, (-grid_height + obj_height, 0)) # Move each object to the top
  return I
 
0.05925925925925926, 25.596094, def dbchdhafjedaechbjccagfjddaeheeba(I):
  objs = objects(I, True, False, True)
  O = canvas(0, shape(I)) # Create an empty canvas
  for obj in objs:
    O = paint(O, shift(obj, (-uppermost(obj), 0))) # Paint each object onto the canvas at the top
  return O
 
0.05925925925925926, 25.766441, def afhbhhagehdfeagdjbfdbbhehddajaha(I):
  objs = objects(I, True, False, True)
  new_objs = set()
  for obj in objs:
    new_objs.add(shift(obj, (-uppermost(obj), 0))) # Calculate the shifted position of each object
  O = I
  for obj in objs:
    O = cover(O, obj) # Remove original objects from the grid
  for obj in new_objs:
    O = paint(O, obj) # Paint the shifted objects onto the grid
  return O 
 
0.05925925925925926, 26.55379, def caajjfaihiefehddaffbaeebaebcagcg(I):
  transposed = rot90(I)  # Rotate the grid 90 degrees clockwise
  objs = objects(transposed, True, False, True)
  for obj in objs:
    transposed = move(transposed, obj, (0, -leftmost(obj))) # Move objects to the left edge
  return rot270(transposed)  # Rotate back to original orientation
 
0.0637037037037037, 18.166128, def bfehcafhjeeheigdbifgejcieabhfdib(I):
  obj2 = first(colorfilter(objects(I, T, F, T), TWO))
  obj3 = first(colorfilter(objects(I, T, F, T), THREE))
  rel_pos = position(obj3, obj2) 
  direction = (NEG_ONE if rel_pos[1] == ONE else ONE, ZERO)
  offset = gravitate(obj2, obj3)
  moved_obj2 = shift(recolor(TWO, obj2), offset)
  moved_obj3 = shift(recolor(THREE, obj3), add(offset, direction))
  O = paint(paint(cover(cover(I, obj2), obj3), moved_obj2), moved_obj3)
  return O
 
0.06222222222222223, 17.728249, def baebdabadfcaejhcijbafcaeicbheifh(I):
  obj2 = first(colorfilter(objects(I, T, F, T), TWO))
  obj3 = first(colorfilter(objects(I, T, F, T), THREE))
  corner2 = ulcorner(obj2)
  corner3 = ulcorner(obj3)
  h_diff = corner3[0] - corner2[0]
  offset = (h_diff - 1, corner3[1] - corner2[1] + (1 if corner3[1] < corner2[1] else -1))
  moved_obj2 = shift(recolor(TWO, obj2), offset)
  moved_obj3 = shift(recolor(THREE, obj3), (offset[0], offset[1] + (1 if corner3[1] < corner2[1] else -1)))
  O = paint(paint(cover(cover(I, obj2), obj3), moved_obj2), moved_obj3)
  return O
 
0.06222222222222223, 17.732883, def fhfeahhbedhdefceicbhifefeedgdfeb(I):
  obj2 = first(colorfilter(objects(I, T, F, T), TWO))
  obj3 = first(colorfilter(objects(I, T, F, T), THREE))
  com2 = centerofmass(obj2)
  com3 = centerofmass(obj3)
  h_diff = com3[0] - com2[0] 
  rel_pos = position(obj3, obj2)
  offset = (h_diff - 1, com3[1] - com2[1] + (1 if rel_pos[1] == ONE else -1)) 
  moved_obj2 = shift(recolor(TWO, obj2), offset)
  moved_obj3 = shift(recolor(THREE, obj3), add(offset, (ZERO, rel_pos[1])))
  O = paint(paint(cover(cover(I, obj2), obj3), moved_obj2), moved_obj3)
  return O
 
0.06074074074074074, 18.320047, def bahebcibcbgjeejejbaeebjgeieadece(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) == TWO:
      obj2 = obj
    if color(obj) == THREE:
      obj3 = obj
  rel_pos = position(obj3, obj2)
  direction = (NEG_ONE if rel_pos[1] == ONE else ONE, ZERO)
  offset = gravitate(obj2, obj3)
  moved_obj2 = shift(recolor(TWO, obj2), offset)
  moved_obj3 = shift(recolor(THREE, obj3), add(offset, direction))
  O = paint(paint(cover(cover(I, obj2), obj3), moved_obj2), moved_obj3)
  return O
 
0.09333333333333332, 11.526798, def hhafhjececcaeaeeadbbffcaefhheebi(I):
  c = centerofmass(asindices(I))
  return paint(I, mapply(lambda o: shift(o, (sign(c[0] - centerofmass(o)[0]), sign(c[1] - centerofmass(o)[1]))), objects(I, T, T, T)))
 
0.056296296296296296, 17.21155, def bdhbehfhaeehefjabgdjfjhbciidgcfd(I):
  objs = objects(I, T, F, T)  # Identify objects
  moved_objs = set()
  for obj in objs:
    upper = uppermost(obj)
    while upper > 0 and len(intersection(toindices(shift(obj, (-1, 0))), asindices(I))) == 0:
      upper -= 1
      obj = shift(obj, (-1, 0))
    moved_objs.add(obj)
  O = paint(canvas(0, shape(I)), merge(moved_objs))
  return O
 
0.054814814814814816, 15.358785, def daiahffdciececffbcecbjffhgffhdef(I):
  O = canvas(0, shape(I))
  for j in range(width(I)):
    column = { (I[i][j], (i,j)) for i in range(height(I)) if I[i][j] != 0 }
    shifted_column = set()
    for v, (i, _) in sorted(column, key=lambda x: x[1][0]):
      new_i = i
      while new_i > 0 and (I[new_i-1][j] == 0) and ((v, (new_i-1, j)) not in shifted_column):
        new_i -= 1
      shifted_column.add((v, (new_i, j)))
    O = paint(O, frozenset(shifted_column))
  return O
 
0.044444444444444446, 27.572851, def abbjcfadddbiefafjeadedbecaaieadd(I):
    objs = fgpartition(I)
    
    # Define target areas
    target_area_3 = crop(I, (ONE, ZERO), (TWO, width(I)))
    target_area_2 = crop(I, (height(I) - THREE, ZERO), (TWO, width(I)))
    target_area_1 = crop(I, (SIX, ZERO), (TWO, width(I))) 
    
    # Move objects based on their color
    I = canvas(ZERO, shape(I))
    for obj in objs:
        if color(obj) == THREE and size(obj) == 3:
            I = paint(I, shift(obj, subtract((ONE, (width(I) - width(obj)) // TWO), ulcorner(obj))))
        elif color(obj) == TWO and size(obj) == 2:
            I = paint(I, shift(obj, subtract((height(I) - THREE, (width(I) - width(obj)) // TWO), ulcorner(obj)))) 
        elif color(obj) == ONE and size(obj) == 1:
            I = paint(I, shift(obj, subtract((SIX, (width(I) - width(obj)) // TWO), ulcorner(obj))))
    return I
 
0.04148148148148148, 30.007378, def bfgfejbjahgjejediecafchiedbdehdf(I):
  bg = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)

  # Define target locations based on object properties
  target_locations = {
      (3, 3): (1, (width(I) - 3) // 2),
      (2, 2): (height(I) - 3, (width(I) - 2) // 2),
      (1, 1): (6, (width(I) - 1) // 2)
  }

  # Move objects to their target locations
  I = canvas(bg, shape(I))  # Create a blank canvas
  for obj in objs:
      obj_color = color(obj)
      obj_size = size(obj)
      target_location = target_locations.get((obj_color, obj_size))
      if target_location:
          I = paint(I, shift(obj, subtract(target_location, ulcorner(obj))))
  return I
 
0.06962962962962964, 17.227962, def fcebbgdehjajechdjaefjbdddjchcccd(I):
  objs = fgpartition(I)
  width_I = width(I)

  # Define function to calculate target position
  def calculate_target(obj):
      if color(obj) == THREE:
          return (ONE, (width_I - width(obj)) // TWO)
      elif color(obj) == TWO:
          return (height(I) - THREE, (width_I - width(obj)) // TWO)
      elif color(obj) == ONE:
          return (SIX, (width_I - width(obj)) // TWO)
      return ulcorner(obj) # Keep other objects in place

  # Create new grid by moving objects to their target positions
  new_grid = canvas(ZERO, shape(I))
  for obj in objs:
      new_grid = paint(new_grid, shift(obj, subtract(calculate_target(obj), ulcorner(obj))))
  return new_grid
 
0.0651851851851852, 18.173391, def cdgbfefbebfeefbabjbabifeaadihheh(I):
  bg = mostcolor(I)
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)

  # Move objects based on size and color
  for obj in objs:
      if color(obj) == THREE and size(obj) == 3:
          I = move(I, obj, subtract((ONE, (width(I) - width(obj)) // TWO), ulcorner(obj)))
      elif color(obj) == TWO and size(obj) == 2:
          I = move(I, obj, subtract((height(I) - THREE, (width(I) - width(obj)) // TWO), ulcorner(obj)))
      elif color(obj) == ONE and size(obj) == 1:
          I = move(I, obj, subtract((SIX, (width(I) - width(obj)) // TWO), ulcorner(obj)))
  return I
 
0.04148148148148148, 33.423405, def dfabcabadddfedcaifchacbfbgidaaif(I):
    objs = objects(I, T, T, T)
    sorted_objs = order(objs, lambda obj: (-lowermost(obj), -leftmost(obj), -size(obj)))
    painted = I
    for i, obj in enumerate(sorted_objs):
      painted = paint(cover(painted, obj), shift(obj, (14-lowermost(obj), -leftmost(obj)))) 
    O = painted
    return O 
 
0.04148148148148148, 33.504818, def ceejdbfdgfebeddeajjcccdfeccdfdha(I):
    objs = objects(I, T, T, T)
    O = I
    for obj in objs:
      O = underpaint(cover(O, obj), shift(obj, (height(I)-1-lowermost(obj), -leftmost(obj))))
    return O
 
0.07407407407407407, 17.62218, def ffeffcaecddbefhcbiceehdgbeiafdgj(I):
    painted = canvas(0, shape(I))
    objs = order(objects(I, T, T, T), lambda obj: (-lowermost(obj), -leftmost(obj), -size(obj)))
    current_position = (height(I)-1, 0)
    for obj in objs:
        obj_height, obj_width = shape(obj)
        new_position = (current_position[0] - obj_height + 1, current_position[1])
        painted = paint(painted, shift(obj, subtract(new_position, ulcorner(obj))))
        current_position = (new_position[0], current_position[1] + obj_width) 
    O = painted
    return O
 
0.06962962962962964, 16.682823, def jccebegbcdfbejbcbbfaddabbcchfjfa(I):
    O = I
    for i in range(height(I)):
        for j in range(width(I)):
            if I[i][j] != 0:
                O = paint(cover(O, {(I[i][j], (i, j))}), {(I[i][j], (height(I)-1-i, j))})
    return O
 
0.0651851851851852, 16.510626, def dbacbfdfihfaeahcjggjfjcfcbdffecg(I):
  obj2 = first(colorfilter(objects(I, T, F, T), TWO))
  obj3 = first(colorfilter(objects(I, T, F, T), THREE))
  offset = gravitate(obj2, obj3)
  I = move(I, obj2, offset)
  if position(obj3, obj2) == (0, 1):
    I = hmirror(I)
  I = move(I, obj3, add(offset, (1, 0)))
  if position(obj3, obj2) == (0, 1):
    I = hmirror(I)
  O = I
  return O
 
0.07407407407407407, 18.258734, def aichcbgcebbgefhgijiccbdccacdiaff(I):
  grid_center = centerofmass(asindices(I))
  new_grid = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for obj in objects(I, T, T, T):
    obj_center = centerofmass(obj)
    h_direction = sign(grid_center[1] - obj_center[1]) * minimum({1, abs(grid_center[1] - obj_center[1])})
    v_direction = sign(grid_center[0] - obj_center[0]) * minimum({1, abs(grid_center[0] - obj_center[0])})
    moved_obj = shift(obj, (v_direction, h_direction))
    new_grid = paint(new_grid, moved_obj) # Paint each moved object onto the canvas
  return new_grid 
 
0.07111111111111111, 14.509224, def dhbeefeadhefeecfbjjgfebfaijiabha(I):
    O = I
    for i in range(1, len(I)):
      for j in range(len(I[0])):
        if O[i][j] != 0:
          temp = O[i][j]
          k = i
          while k > 0 and O[k-1][j] == 0:
            k -= 1
          O = paint(cover(O, {(temp, (i, j))}), {(temp, (k, j))})
    return O
 
0.07407407407407407, 14.801808, def gibeebeefhdcehfcibgdhifgccdfhfeh(I):
    objs = objects(I, F, T, T)
    new_objs = frozenset(shift(obj, (-uppermost(obj), 0)) for obj in objs)
    O = I
    for obj in new_objs:
        O = underpaint(O, obj)
    return O
 
0.08740740740740742, 23.21645, def ghdfffcdafebeediaaaaefejhaaaddhf(I):
    # Find the anchor '1' and other digits
    ones = ofcolor(I, 1)
    twos = ofcolor(I, 2)
    threes = ofcolor(I, 3)
    sevens = ofcolor(I, 7)

    # Determine the center for repositioning
    center = first(ones) 

    # Create the lines of '3's and '7's
    three_line = connect((center[0], leftmost(threes)), (center[0], rightmost(threes)))
    seven_line = connect((uppermost(sevens), center[1]), (lowermost(sevens), center[1]))

    # Construct the output grid
    O = canvas(0, shape(I))  
    O = fill(O, 3, three_line)
    O = fill(O, 7, seven_line)
    O = fill(O, 1, ones)
    O = fill(O, 2, shift(twos, (1, 0))) 
    return O
 
0.07555555555555556, 13.78977, def ibeigidjhadceieibbcfcfecaefefgef(I):
    ones = ofcolor(I, 1)
    center = first(ones)
    O = canvas(0, shape(I))
    O = fill(O, 1, ones)
    O = fill(O, 2, shift(ofcolor(I, 2), (1, 0)))

    three_obj = toobject(ofcolor(I, 3), I)
    mirrored_three = hmirror(three_obj)
    full_three = combine(three_obj, mirrored_three)
    O = paint(O, full_three)

    seven_obj = toobject(ofcolor(I, 7), I)
    mirrored_seven = vmirror(seven_obj)
    full_seven = combine(seven_obj, mirrored_seven)
    O = paint(O, full_seven)

    return O
 
0.05185185185185185, 18.278828, def ddffdbfbadefeffijdbedfjcacccfbie(I):
    one_obj = toobject(ofcolor(I, 1), I)
    two_obj = toobject(ofcolor(I, 2), I)
    three_obj = toobject(ofcolor(I, 3), I)
    seven_obj = toobject(ofcolor(I, 7), I)

    center = centerofmass(one_obj)
    O = canvas(0, shape(I))
    O = paint(O, one_obj) 
    O = paint(O, shift(two_obj, (1, 0)))

    target_three = (center[0], centerofmass(three_obj)[1])
    three_shift = subtract(target_three, centerofmass(three_obj))
    O = paint(O, shift(three_obj, three_shift)) 

    target_seven = (centerofmass(seven_obj)[0], center[1])
    seven_shift = subtract(target_seven, centerofmass(seven_obj))
    O = paint(O, shift(seven_obj, seven_shift))

    return O
 
0.035555555555555556, 17.645422, def egedgdeifabjechijhcgfabgaeffbfcc(I):
    one_obj = toobject(ofcolor(I, 1), I)
    two_obj = toobject(ofcolor(I, 2), I)
    three_obj = toobject(ofcolor(I, 3), I)
    seven_obj = toobject(ofcolor(I, 7), I)

    center = centerofmass(one_obj)
    O = canvas(0, shape(I))
    O = paint(O, one_obj)
    O = paint(O, shift(two_obj, (1, 0)))

    three_shift = gravitate(three_obj, one_obj)
    O = paint(O, shift(three_obj, three_shift))

    seven_shift = gravitate(seven_obj, one_obj)
    O = paint(O, shift(seven_obj, seven_shift))

    return O
 
0.05333333333333334, 18.169239, def ccffefifchageheajffhcbghbfaceegd(I):
  """
  This version iterates through each row and column, 
  identifies '7' digits, and moves them to a separate object. 
  Then, it constructs the output grid by placing the '7' object 
  on the rightmost column and filling the rest with the remaining digits.
  """
  sevens = set()
  other_digits = set()
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 7:
        sevens.add((value, (i, len(row) - 1)))
      else:
        other_digits.add((value, (i, j)))
  O = canvas(0, shape(I))
  O = paint(O, frozenset(other_digits))
  O = paint(O, frozenset(sevens))
  return O
 
0.05333333333333334, 18.390913, def eggjcigfbdfaejedaeefbcdbecdfacfc(I):
  """
  This version utilizes the 'objects' function to extract all objects, 
  filters for the object containing '7', and moves it to the rightmost 
  position. The remaining grid is then compressed to remove the gap.
  """
  seven_obj = first(colorfilter(objects(I, T, F, T), 7))
  O = cover(I, seven_obj)
  O = paint(O, shift(seven_obj, (0, width(I) - 1)))
  return O
 
0.056296296296296296, 17.6357, def gbacfafbcibbececbabdaajcdbejacdf(I):
  """
  This version iterates through columns, identifies columns containing '7', 
  and swaps them with the rightmost column. 
  """
  O = list(list(row) for row in I)
  seven_col = None
  for j in range(len(O[0])):
    if 7 in [O[i][j] for i in range(len(O))]:
      seven_col = j
      break
  if seven_col is not None:
    for i in range(len(O)):
      O[i][seven_col], O[i][-1] = O[i][-1], O[i][seven_col]
  return tuple(tuple(row) for row in O)
 
0.04296296296296296, 20.596209, def bdeijgdfciheegdabfhccdfjabhciaea(I):
  """
  This version creates a mask identifying the '7' digits 
  and uses it to shift the '7' digits to the right while keeping 
  other digits in their original positions.
  """
  mask = tuple(tuple(1 if v == 7 else 0 for v in row) for row in I)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if mask[i][j] == 1:
        O = paint(O, {(value, (i, len(row) - 1))})
      else:
        O = paint(O, {(value, (i, j))})
  return O
 
0.035555555555555556, 29.135248, def gffceichbadaedadiiaaicihfbfajbfb(I):
  min_color = leastcolor(trim(I))  # Find the least frequent color
  target_pos = centerofmass(ofcolor(I, min_color))  # Find the center of the target color cells
  return paint(canvas(0, shape(I)), merge(apply(lambda obj: shift(obj, subtract(target_pos, centerofmass(obj))), objects(I, T, T, T)))) # Move all objects towards the target position
 
0.05925925925925926, 25.59287, def daaiejedfjdcedcajjdfiegdcgdedgbb(I):
  objs = objects(I, False, True, True)  # Extract all non-background objects
  shifted_objs = frozenset(shift(obj, (-uppermost(obj), 0)) for obj in objs)  # Shift each object upwards
  O = paint(canvas(0, shape(I)), merge(shifted_objs))  # Paint the shifted objects onto a blank canvas
  return O
 
0.04296296296296296, 31.374502, def fddfbcjgafbeejecifhjeggceifcjbbc(I):
  O = canvas(0, shape(I)) # Create an empty canvas
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcommon(I):  # Check if the cell is not background
        O = paint(O, {(val, (0, j))}) # Paint the cell at the top of its column
  return O
 
0.05925925925925926, 25.596094, def ehaaejecffaeejijiihcadddbcbccfee(I):
  objs = objects(I, False, True, True)
  O = I 
  for obj in objs:
    O = cover(O, obj) # Clear the object from its original position
    O = paint(O, shift(obj, (-uppermost(obj), 0))) # Paint the object at the top
  return O
 
0.056296296296296296, 9.710077, def eibchbcdccaiefjjaaehbhgijfacagec(I):
  one_loc = first(ofcolor(I, ONE)) # Find location of '1'
  three_count = colorcount(I, THREE)
  seven_count = colorcount(I, SEVEN)
  h_offset =  (-three_count // 2, 0) # Calculate offset for horizontal line
  v_offset = (0, -seven_count // 2) # Calculate offset for vertical line
  h_line = shift({(THREE, (0, i)) for i in range(three_count)}, add(one_loc, h_offset)) # Create horizontal line
  v_line = shift({(SEVEN, (i, 0)) for i in range(seven_count)}, add(one_loc, v_offset)) # Create vertical line
  O = paint(paint(canvas(ZERO, shape(I)), h_line), v_line) # Create canvas, paint lines
  return paint(fill(O, TWO, shift({(ZERO, ORIGIN)}, add(one_loc, DOWN))), {(ONE, one_loc)}) # Place '2' and '1'
 
0.037037037037037035, 5.5879807, def bcfebibhadfgehaeabcebdabagjaeeea(I):
  one_idx = first(ofcolor(I, ONE))
  three_line = {(THREE, (one_idx[0], j)) for j in range(one_idx[1] - colorcount(I, THREE) // 2, one_idx[1] + colorcount(I, THREE) - colorcount(I, THREE) // 2)}
  seven_line = {(SEVEN, (i, one_idx[1])) for i in range(one_idx[0] - colorcount(I, SEVEN) // 2, one_idx[0] + colorcount(I, SEVEN) - colorcount(I, SEVEN) // 2)}
  O = canvas(ZERO, shape(I))
  O = paint(O, three_line)
  O = paint(O, seven_line)
  O = fill(O, TWO, {add(one_idx, DOWN)})
  O = paint(O, {(ONE, one_idx)})
  return O
 
0.03407407407407407, 5.4679136, def ichhgdahgcceecggaehggdjcdbbbbbec(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  one_loc = first(ofcolor(I, ONE))
  O = fill(O, TWO, shift({(ZERO, (1,0))}, one_loc)) 
  for i in range(colorcount(I, THREE)):
    O = fill(O, THREE, {(one_loc[0], one_loc[1] - colorcount(I, THREE)//2 + i)})
  for i in range(colorcount(I, SEVEN)):
    O = fill(O, SEVEN, {(one_loc[0] - colorcount(I, SEVEN)//2 + i, one_loc[1])})
  O = paint(O, {(ONE, one_loc)})
  return O
 
0.038518518518518514, 6.2251964, def djhfbcbbaieieifbaefhhaajcfhbheih(I):
  one_loc = first(ofcolor(I, ONE))
  threes = colorcount(I, THREE)
  sevens = colorcount(I, SEVEN)
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  O = paint(O, recolor(TWO, shift({(0, 0)}, add(one_loc, DOWN))))
  O = paint(O, recolor(THREE, {(one_loc[0], j) for j in range(one_loc[1] - threes // 2, one_loc[1] + threes - threes//2)}))
  O = paint(O, recolor(SEVEN, {(i, one_loc[1]) for i in range(one_loc[0] - sevens // 2, one_loc[0] + sevens - sevens//2)})) 
  return O 
 
0.06074074074074074, 16.630646, def fdeebgehjafheggcafjehgajhaeddgbe(I):
  """
  This version iterates over rows, reconstructing each with '7's at the end.
  """
  O = ()
  for row in I:
    sevens = tuple(SEVEN for _ in range(row.count(SEVEN)))
    others = tuple(v for v in row if v != SEVEN)
    O = O + (others + sevens,) 
  return O
 
0.04148148148148148, 31.853899, def cjdadeccfcbbecfciaaadebcfejbiedc(I):
  """
  This version uses transpose and object manipulation for '7' shifting.
  """
  x1 = dmirror(I)  # Transpose
  x2 = objects(x1, T, F, F)
  x3 = colorfilter(x2, SEVEN)
  x4 = merge(x3)
  x5 = toindices(x4)
  x6 = shift(x5, (0, width(I) - len(x5)))
  x7 = recolor(SEVEN, x6)
  x8 = paint(canvas(ZERO, shape(I)), x7)
  O = dmirror(x8)  # Transpose back
  return O
 
0.06666666666666667, 16.04227, def bbbbjbfcefdeebahjbedbeaadjcaeaha(I):
  """
  This version flattens the grid, sorts, and then reshapes it.
  """
  x1 = tuple(v for row in I for v in row)
  x2 = tuple(sorted(x1, key=lambda v: 0 if v == SEVEN else 1))
  O = tuple(x2[i * width(I):(i + 1) * width(I)] for i in range(height(I)))
  return O
 
0.05925925925925926, 17.195627, def bfcbacfdbgddedbhbbjhaddgeaeidcdb(I):
  target_color = leastcolor(trim(I))
  objs = fgpartition(I)
  target_obj = extract(objs, lambda obj: color(obj) == target_color)
  target_center = centerofmass(target_obj)
  moved_objs = set()
  for obj in objs:
    if color(obj) != target_color:
      move_vector = gravitate(obj, {(color(obj), target_center)})
      moved_obj = frozenset((v, add((i, j), (sign(move_vector[0]), sign(move_vector[1])))) for v, (i, j) in obj)
      moved_objs.add(moved_obj)
    else:
      moved_objs.add(obj)
  return paint(canvas(0, shape(I)), merge(moved_objs))
 
0.3333333333333333, 101.61186, def cbiaaagddbfbejbhbcedfeaagdcajcea(I):
    objs = objects(I, False, True, True)
    shifted_objs = frozenset(shift(obj, (0, -leftmost(obj))) for obj in objs)
    rightmost_column = max(rightmost(obj) for obj in shifted_objs)
    O = canvas(0, (height(I), rightmost_column + 1))
    for obj in shifted_objs:
        O = paint(O, shift(obj, (0, leftmost(obj))))
    return O
 
0.038518518518518514, 5.9444995, def cjiacdcbbcecejbajagbbcadfbbhbeib(I):
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, THREE)
  v_len = colorcount(I, SEVEN)
  O = canvas(ZERO, shape(I))
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  O = fill(O, TWO, {add(one_loc, DOWN)})
  O = fill(O, ONE, {one_loc})
  return O
 
0.047407407407407405, 13.839725, def gajfhefhbaecedfbicchdedefaecfebi(I):
  """
  Finds the '2' and '3' objects, then moves the '3' object 
  adjacent to the '2' object.
  """
  two_obj = first(colorfilter(objects(I, T, F, T), TWO)) # find the '2' object
  three_obj = first(colorfilter(objects(I, T, F, T), THREE)) # find the '3' object
  move_dir = gravitate(three_obj, two_obj)  # calculate the direction to move
  moved_obj = shift(three_obj, move_dir) # move the '3' object
  O = paint(fill(I, ZERO, three_obj), moved_obj) # clear original position and paint moved object
  return O
 
0.05925925925925926, 19.049393, def fejeeffgaeafeebbjdcjdieedcdbchfc(I):
  tc = leastcolor(trim(I))  # Target color
  objs = fgpartition(I)  # Foreground objects
  t_center = centerofmass(extract(objs, lambda o: color(o) == tc))  # Target center

  def move_obj(obj):
    if color(obj) == tc: 
      return obj  # Don't move target object
    obj_center = centerofmass(obj)
    h_dir = 1 if obj_center[1] < t_center[1] else -1 if obj_center[1] > t_center[1] else 0
    v_dir = 1 if obj_center[0] < t_center[0] else -1 if obj_center[0] > t_center[0] else 0
    return shift(obj, (v_dir, h_dir))  # Move one step towards target

  return paint(canvas(0, shape(I)), merge(apply(move_obj, objs)))  # Paint moved objects
 
0.06074074074074074, 18.475496, def dcdbafdgebageafhabiidbcacadacbbf(I):
  t_color = leastcolor(trim(I)) 
  objects = fgpartition(I) 
  target_object = extract(objects, lambda o: color(o) == t_color) 
  target_center = centerofmass(target_object)

  def move_object(obj):
    if color(obj) == t_color:
      return obj
    rel_pos = subtract(target_center, centerofmass(obj))
    return shift(obj, (sign(rel_pos[0]), 0) if color(obj) == 7 else sign(rel_pos))

  return paint(canvas(0, shape(I)), merge(apply(move_object, objects))) 
 
0.06962962962962964, 16.609486, def ibjjejidfcadecchjadifhceabbaibaa(I):
  def find_object(color, size=None, shape_check=None):
    objs = objects(I, False, False, True)
    if color is not None:
      objs = colorfilter(objs, color)
    if size is not None:
      objs = sizefilter(objs, size)
    if shape_check is not None:
      objs = frozenset(obj for obj in objs if shape_check(obj))
    return first(objs) if objs else None

  obj_3 = find_object(leastcolor(I), shape_check=square)
  obj_2 = find_object(TWO, TWO, hline)
  obj_1 = find_object(ONE)

  grid_center = (height(I) // 2, width(I) // 2)
  target_3 = subtract(grid_center, divide(shape(obj_3), 2))
  target_2 = add(lrcorner(obj_3), (0, 1))
  target_1 = (height(I) - 2, (width(I) - 1) // 2)

  I = move(I, obj_3, subtract(target_3, ulcorner(obj_3))) if obj_3 else I
  I = move(I, obj_2, subtract(target_2, ulcorner(obj_2))) if obj_2 else I
  I = move(I, obj_1, subtract(target_1, ulcorner(obj_1))) if obj_1 else I
  return I
 
0.056296296296296296, 17.21155, def egbfcicihabaejdfiacebchebffgeaff(I):
  def find_by_pattern(pattern):
    h, w = len(I), len(I[0])
    for i in range(h - len(pattern) + 1):
      for j in range(w - len(pattern[0]) + 1):
        match = True
        for pi in range(len(pattern)):
          for pj in range(len(pattern[0])):
            if pattern[pi][pj] != -1 and I[i+pi][j+pj] != pattern[pi][pj]:
              match = False
              break
          if not match: break
        if match:
          return (i, j)
    return None

  obj_3_pos = find_by_pattern([[-1, -1, leastcolor(I)], [-1, leastcolor(I), -1], [leastcolor(I), -1, -1]]) 
  obj_2_pos = find_by_pattern([[2, 2]])
  obj_1_pos = find_by_pattern([[1]])

  I = move(I, toobject(asindices(crop(I, obj_3_pos, (3, 3))), I), ((height(I) - 3) // 2, (width(I) - 3) // 2)) if obj_3_pos else I
  I = move(I, toobject(asindices(crop(I, obj_2_pos, (1, 2))), I), (height(I) - 3, width(I) // 2)) if obj_2_pos else I
  I = move(I, toobject(asindices(crop(I, obj_1_pos, (1, 1))), I), (height(I) - 2, (width(I) - 1) // 2)) if obj_1_pos else I

  return I
 
0.038518518518518514, 7.841684, def caadgeidfcfaeabeihgcafcjdafhebaf(I):
  one_loc = first(ofcolor(I, ONE))
  h_line = {(THREE, (one_loc[0], j)) for j in range(one_loc[1] - colorcount(I, THREE) // 2, one_loc[1] + (colorcount(I, THREE) + 1) // 2)}
  v_line = {(SEVEN, (i, one_loc[1])) for i in range(one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[0] + (colorcount(I, SEVEN) + 1) // 2)}
  return paint(canvas(ZERO, shape(I)), h_line | v_line)
 
0.04, 6.893454, def fchgbehficdeeegfidagibheafhegafj(I):
    one_loc = first(ofcolor(I, ONE))
    grid = canvas(ZERO, shape(I))
    for di in range(-colorcount(I, THREE) // 2, (colorcount(I, THREE) + 1) // 2):
        grid = paint(grid, {(THREE, add(one_loc, (0, di)))})
    for di in range(-colorcount(I, SEVEN) // 2, (colorcount(I, SEVEN) + 1) // 2):
        grid = paint(grid, {(SEVEN, add(one_loc, (di, 0)))})
    return grid
 
0.044444444444444446, 20.942604, def dfbedhacjeddeagdiacdefajaagajbac(I):
  one_loc = first(ofcolor(I, ONE))
  h_offset = (-colorcount(I, THREE) // 2, 0)
  v_offset = (0, -colorcount(I, SEVEN) // 2)
  h_line = recolor(THREE, {(one_loc[0], j) for j in range(colorcount(I, THREE))})
  v_line = recolor(SEVEN, {(i, one_loc[1]) for i in range(colorcount(I, SEVEN))})
  return paint(paint(canvas(ZERO, shape(I)), shift(h_line, add(one_loc, h_offset))), shift(v_line, add(one_loc, v_offset))) 
 
0.05925925925925926, 26.472218, def gajbccdebfcfeehfijdhejjiajjchbfj(I):
  objs = objects(I, False, True, True)  # Extract all objects from the grid
  h = height(I)
  w = width(I)
  O = canvas(0, (h, w)) # Create an empty canvas
  for obj in objs:
    shifted_obj = obj
    while uppermost(shifted_obj) < h - 1 and not any(
      uppermost(o) == uppermost(shifted_obj) + 1 and hmatching(o, shifted_obj)
      for o in objs if o != obj
    ):
      shifted_obj = shift(shifted_obj, DOWN) # Move the object down
    O = paint(O, shifted_obj) # Paint the shifted object onto the canvas
  return O
 
0.05925925925925926, 26.467434, def jfbchbccfccgehdhbejfdbaageehhfif(I):
  objs = objects(I, False, True, True)
  new_objs = set()
  for i, obj in enumerate(objs):
    bottom = lowermost(obj)
    collision = False
    for j, other in enumerate(objs):
      if i != j and hmatching(obj, other) and bottom < uppermost(other):
        bottom = max(bottom, lowermost(other))
        collision = True
    if collision:
      new_objs.add(shift(obj, (bottom - lowermost(obj), 0)))
    else:
      new_objs.add(shift(obj, (height(I) - lowermost(obj) - 1, 0)))
  return paint(canvas(0, shape(I)), merge(new_objs))
 
0.05925925925925926, 26.513178, def gejghfjfhecheebebjhdhdjafbcagiaa(I):
  h = height(I)
  O = canvas(0, shape(I))
  for j in range(width(I)):
    column = [(I[i][j], (i, j)) for i in range(height(I)) if I[i][j] != 0]
    new_column = []
    for v, (i, _) in reversed(sorted(column, key=lambda x: x[1][0])):
      new_i = h - 1
      while new_i > 0 and O[new_i][j] != 0:
        new_i -= 1
      new_column.append((v, (new_i, j)))
    for v, (i, j) in new_column:
      O = paint(O, {(v, (i, j))})
  return O
 
0.038518518518518514, 7.1018724, def dbbfcbedejcdebeibddbjgbabdjeeijd(I):
  """
  Finds the location of the digit 1, counts the number of 3s and 7s, 
  and then paints them centered on the 1 on a blank canvas.
  """
  one_loc = first(ofcolor(I, ONE))
  three_count = colorcount(I, THREE)
  seven_count = colorcount(I, SEVEN)
  O = canvas(ZERO, shape(I)) 
  O = paint(O, {(THREE, (one_loc[0], one_loc[1] + j - three_count // 2)) for j in range(three_count)})
  O = paint(O, {(SEVEN, (one_loc[0] + i - seven_count // 2, one_loc[1])) for i in range(seven_count)})
  return O
 
0.056296296296296296, 16.715017, def deifhbacceececdaaecdbdibfcjdjfda(I):
  """
  This version creates a distance map to efficiently find the
  direction for each '3' to move towards the closest '2'.
  """
  def get_distance_map(grid, value):
    h, w = len(grid), len(grid[0])
    queue = [(i, j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == value]
    visited = set(queue)
    distances = {(i, j): 0 for (i, j) in queue}
    while queue:
      i, j = queue.pop(0)
      for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]:
        ni, nj = i + di, j + dj
        if 0 <= ni < h and 0 <= nj < w and (ni, nj) not in visited:
          distances[(ni, nj)] = distances[(i, j)] + 1
          visited.add((ni, nj))
          queue.append((ni, nj))
    return distances

  O = I
  two_distances = get_distance_map(I, TWO)
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == THREE:
        neighbors = [(i+di, j+dj) for di in [-1, 0, 1] for dj in [-1, 0, 1] if 0 <= i+di < len(I) and 0 <= j+dj < len(row)]
        closest = min(neighbors, key=lambda loc: two_distances.get(loc, float('inf')))
        direction = (sign(closest[0] - i), sign(closest[1] - j))
        O = move(O, {(THREE, (i, j))}, direction)
  return O
 
0.06222222222222223, 20.59605, def dbifabafbdfgeffdjeccjdacjiedgbbi(I):
  def drop(obj, objs):
    bottom = height(I) - 1 # Bottom of the grid
    for other in objs:
      if other != obj and hmatching(obj, other) and bottom > uppermost(other): 
        bottom = min(bottom, uppermost(other) - height(obj))
    return shift(obj, (bottom - uppermost(obj), 0))
  return paint(canvas(0, shape(I)), merge(apply(lambda obj: drop(obj, objects(I, False, True, True)), objects(I, False, True, True))))
 
0.06222222222222223, 16.572397, def iiefheefgbheeaejbabcfbfeecbdbfbc(I):
  def reachable_bottom(obj, grid):
    bottom = lowermost(obj)
    while bottom < height(grid) - 1 and index(grid, (bottom + 1, leftmost(obj))) == 0:
      bottom += 1
    return bottom
  return paint(canvas(0, shape(I)), merge({shift(obj, (reachable_bottom(obj, I) - lowermost(obj), 0)) for obj in objects(I, False, True, True)}))
 
0.06518518518518518, 21.617413, def aheccedebibeegabjbeggcdddcaifdhb(I):
  def drop_object(obj, grid):
    landing = height(grid) - 1
    for i, j in toindices(obj):
      landing = min(landing, max([row for row in range(i, height(grid)) if index(grid, (row, j)) == 0] + [i]))
    return shift(obj, (landing - uppermost(obj), 0))
  return paint(canvas(0, shape(I)), merge(apply(lambda obj: drop_object(obj, I), objects(I, False, True, True))))
 
0.0651851851851852, 15.7474575, def eafhebdfaebeecajacaecdageafibbda(I):
  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  I = move(I, obj_center, subtract((height(I) // 2 - 1, width(I) // 2 - 1), ulcorner(obj_center)))

  # Form a square if necessary
  if not square(obj_center):
    target_corner = (ulcorner(obj_center)[0] + 1, ulcorner(obj_center)[1] + 1)
    I = fill(I, lc, {target_corner})

  objs = objects(I, False, False, True)
  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))

  for obj in objs:
    if color(obj) == 2 and hline(obj) and size(obj) == 2:
      I = move(I, obj, (centerofmass(obj_center)[0], rightmost(obj_center) + 1))
    elif color(obj) == 1:
      I = move(I, obj, (lowermost(obj_center) + 1, centerofmass(obj_center)[1]))
  return I
 
0.03259259259259259, 7.30257, def bbfbebfbgiedegddajcabhdicfidhcdd(I):
  """
  Identifies the central location and iteratively paints the lines.
  """
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, THREE) // 2
  v_len = colorcount(I, SEVEN) // 2
  O = canvas(ZERO, shape(I))
  for di in range(-h_len, h_len + (h_len * 2) % 2):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + di))})
  for di in range(-v_len, v_len + (v_len * 2) % 2):
    O = paint(O, {(SEVEN, (one_loc[0] + di, one_loc[1]))})
  return paint(O, {(ONE, one_loc)})
 
0.037037037037037035, 6.504461, def ccjbffgchjdeejdgbbjbigdjjdefdfgf(I):
  """
  Constructs and merges horizontal and vertical lines separately.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = {(THREE, (one_loc[0], j)) for j in range(one_loc[1] - colorcount(I, THREE) // 2, one_loc[1] + colorcount(I, THREE) - colorcount(I, THREE) // 2)}
  v_line = {(SEVEN, (i, one_loc[1])) for i in range(one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[0] + colorcount(I, SEVEN) - colorcount(I, SEVEN) // 2)}
  return paint(paint(canvas(ZERO, shape(I)), h_line), v_line | {(ONE, one_loc)})
 
0.037037037037037035, 7.32689, def cbaeicfddaafecbbaacafcejdafbicfc(I):
  """
  Constructs lines using shift and repeat functions.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = shift(frozenset({(THREE, (0, j)) for j in range(colorcount(I, THREE))}), (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2))
  v_line = shift(frozenset({(SEVEN, (i, 0)) for i in range(colorcount(I, SEVEN))}), (one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[1]))
  return paint(canvas(ZERO, shape(I)), h_line | v_line | {(ONE, one_loc)}) 
 
0.02962962962962963, 5.665993, def egdcbaffeddeeiegjdagfjdchhadgacc(I):
  """
  Uses a recursive function to move each '3' towards the nearest '2'.
  """
  def move_three(grid, three_loc):
    if any(adjacent({three_loc}, {two_loc}) for two_loc in ofcolor(grid, TWO)):
      return grid
    direction = gravitate({three_loc}, ofcolor(grid, TWO))
    return move_three(move(grid, recolor(THREE, {three_loc}), direction), add(three_loc, direction))
  
  O = I
  for three_loc in ofcolor(I, THREE):
    O = move_three(O, three_loc)
  return O
 
0.056296296296296296, 16.030966, def ecdagbaeedcjegbfadaegffcedfcbaah(I):
  """
  Pre-computes directions to the nearest '2' for each cell 
  and then moves the '3's accordingly.
  """
  h, w = len(I), len(I[0])
  two_locs = ofcolor(I, TWO)
  directions = {}
  for i in range(h):
    for j in range(w):
      closest_two = argmin(two_locs, lambda loc: manhattan({(i, j)}, {loc}))
      directions[(i, j)] = (sign(closest_two[0] - i), sign(closest_two[1] - j))
  
  O = I
  for three_loc in ofcolor(I, THREE):
    O = move(O, recolor(THREE, {three_loc}), directions[three_loc])
  return O
 
0.07111111111111111, 14.920588, def baeacbcibjccefdjibhfddjjegeebeaf(I):
  h, w = shape(I)
  O = canvas(0, (h, w))
  for j in range(w):
    column = tuple(I[i][j] for i in range(h))
    non_zero_indices = tuple(i for i, v in enumerate(column) if v != 0)
    if non_zero_indices:
      k = h - len(non_zero_indices)
      O = paint(O, {(column[i], (k + idx, j)) for idx, i in enumerate(non_zero_indices)})
  return O
 
0.037037037037037035, 35.725292, def cfcdgddbdcbeejgeaeadefcajghejfig(I):
  objs = objects(I, False, True, True)
  grid = canvas(0, shape(I))
  for obj in objs:
    i, j = lrcorner(obj)
    while i < height(grid) and index(grid, (i, j)) == 0:
      obj = shift(obj, (1, 0))
      i += 1
    grid = paint(grid, obj)
  return grid
 
0.0637037037037037, 19.141922, def bgcgaacedjgbedfijdefhijicefajdgg(I):
  O = I
  for obj in objects(I, False, True, True):
    temp = toobject(obj, I)
    i, j = lrcorner(obj)
    while i < height(O) and index(O, (i, j)) == 0:
      i += 1
    O = paint(cover(O, obj), shift(temp, (i - 1 - lrcorner(obj)[0], 0)))
  return O
 
0.06962962962962964, 17.162437, def ihbeedccgcfbefhcicjeacdeeiaafceb(I):
  def center_obj(obj):
    return move(I, obj, subtract((height(I) // 2 - 1, width(I) // 2 - 1), ulcorner(obj)))

  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  I = center_obj(obj_center)

  # Form a square if necessary
  if not square(obj_center):
    missing_cells = delta(box(obj_center))
    I = fill(I, lc, missing_cells)

  objs = objects(I, False, False, True)  # Re-find objects 
  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))

  obj_right = first(sfilter(objs, lambda obj: color(obj) == 2 and hline(obj))) 
  I = move(I, obj_right, (centerofmass(obj_center)[0], rightmost(obj_center) + 1))

  obj_bottom = first(sfilter(objs, lambda obj: color(obj) == 1))
  I = move(I, obj_bottom,  (lowermost(obj_center) + 1, centerofmass(obj_center)[1]))
  return I
 
0.037037037037037035, 29.158543, def abbadgfeaccgejafadddeiedfaccaeed(I):
  """
  Centers objects made of 3s and 7s around the object made of 1.
  """
  one_loc = first(ofcolor(I, ONE))
  three_obj = first(colorfilter(objects(I, True, False, False), THREE))
  seven_obj = first(colorfilter(objects(I, True, False, False), SEVEN))
  three_offset = subtract(one_loc, centerofmass(three_obj))
  seven_offset = subtract(one_loc, centerofmass(seven_obj))
  return paint(paint(canvas(ZERO, shape(I)), shift(three_obj, three_offset)), shift(seven_obj, seven_offset))
 
0.04888888888888889, 19.797714, def ddgacgjbccceedihiabegejeiacbfdcf(I):
  """
  Calculates the target location for each '3' based on '2' and '7' positions,
  then directly moves the '3' to that target.
  """
  O = I
  for three_loc in ofcolor(I, THREE):
    two_loc = argmin(ofcolor(I, TWO), lambda x: manhattan({three_loc}, {x}))
    seven_loc = argmin(ofcolor(I, SEVEN), lambda x: manhattan({three_loc}, {x}))
    target_i = three_loc[0] if hmatching({three_loc}, {seven_loc}) else two_loc[0]
    target_j = three_loc[1] if vmatching({three_loc}, {seven_loc}) else two_loc[1]
    target_loc = (target_i, target_j)
    O = move(O, recolor(THREE, {three_loc}), subtract(target_loc, three_loc))
  return O
 
0.05333333333333334, 17.926018, def jfhbhbdhcddeejffjbfdciddiiaeefda(I):
  """
  Creates a path for each '3' to follow by connecting its initial position
  to a point adjacent to the '2' and aligned with the '7'.
  """
  O = I
  for three_loc in ofcolor(I, THREE):
    two_loc = argmin(ofcolor(I, TWO), lambda x: manhattan({three_loc}, {x}))
    seven_loc = argmin(ofcolor(I, SEVEN), lambda x: manhattan({three_loc}, {x}))
    target_i = two_loc[0] + (1 if three_loc[0] < two_loc[0] else -1) if hmatching({two_loc}, {seven_loc}) else seven_loc[0]
    target_j = two_loc[1] + (1 if three_loc[1] < two_loc[1] else -1) if vmatching({two_loc}, {seven_loc}) else seven_loc[1]
    target_loc = (target_i, target_j)
    path = connect(three_loc, target_loc)
    for step in path:
      if step != three_loc:
        O = move(O, recolor(THREE, {three_loc}), subtract(step, three_loc))
        three_loc = step
  return O
 
0.07111111111111111, 16.583254, def feaebcejcjigegbbbdcdfceghbaaecjb(I):
    shifted = [(v, (height(I) - i - 1, j)) for i, row in enumerate(I) for j, v in enumerate(row) if v != 0]
    return tuple(tuple(next((v for (v, (si, sj)) in shifted if si == i and sj == j), 0) for j in range(len(I[0]))) for i in range(len(I)))
 
0.06074074074074074, 18.166382, def cbedcgbehedeefahbfdefaehbicajdbc(I):
  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  obj_right = first(sfilter(objs, lambda obj: color(obj) == TWO and hline(obj)))
  obj_bottom = first(sfilter(objs, lambda obj: color(obj) == ONE))

  I = move(I, obj_right, gravitate(obj_right, obj_center))
  I = move(I, obj_bottom, gravitate(obj_bottom, shift(obj_center, DOWN))) 

  return fill(I, ZERO, delta(box(combine(obj_center, combine(obj_right, obj_bottom)))))
 
0.07777777777777778, 25.05816, def cfdefcdbdafjecfebdceecdjjbfabgia(I):
  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  obj_right = first(sfilter(objs, lambda obj: color(obj) == TWO and hline(obj)))
  obj_bottom = first(sfilter(objs, lambda obj: color(obj) == ONE))

  I = cover(I, obj_center)
  I = cover(I, obj_right)
  I = cover(I, obj_bottom)

  center_pos = (height(I) // 2 - 1, width(I) // 2 - 1) 
  I = paint(I, shift(obj_center, subtract(center_pos, ulcorner(obj_center))))
  I = hconcat(crop(I, (0, 0), (height(I), center_pos[1] + 1)), 
               vconcat(crop(hconcat(I, paint(canvas(ZERO, (height(I), 1)), obj_right)), (0, center_pos[1] + 1), (height(I) - height(obj_bottom), 1)), 
                       crop(hconcat(I, paint(canvas(ZERO, (height(I), 1)), obj_right)), (height(I) - height(obj_bottom), center_pos[1] + 1), (height(obj_bottom), 1))))

  return I
 
0.054814814814814816, 17.168205, def efbeieeicceeeceiiebdjjeaeddefdef(I):
  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  obj_right = first(sfilter(objs, lambda obj: color(obj) == TWO and hline(obj)))
  obj_bottom = first(sfilter(objs, lambda obj: color(obj) == ONE))

  I = fill(I, ZERO, delta(box(combine(combine(obj_center, shift(obj_right, (0, width(obj_center)))), shift(obj_bottom, (height(obj_center), 0))))))
  
  return I 
 
0.07653061224489797, 19.702406, def fcajjbfibbaiedhijdjcfbcbaabbfceh(I):
  lc = leastcolor(I)
  objs = objects(I, False, False, True)

  obj_center = first(sfilter(objs, lambda obj: color(obj) == lc))
  obj_right = first(sfilter(objs, lambda obj: color(obj) == TWO and hline(obj)))
  obj_bottom = first(sfilter(objs, lambda obj: color(obj) == ONE))

  I = cover(I, obj_center)
  I = cover(I, obj_right)
  I = cover(I, obj_bottom)

  center_pos = (height(I) // 2 - 1, width(I) // 2 - 1)
  I = paint(I, shift(obj_center, subtract(center_pos, ulcorner(obj_center))))
  right_half = hmirror(vconcat(crop(I, (0, 0), (height(I) // 2, width(I) // 2)), 
                               crop(hconcat(paint(canvas(ZERO, (height(I) // 2, width(I) // 2)), obj_right), 
                                             canvas(ZERO, (height(I) // 2, width(I) // 2))), 
                                    (0, 0), (height(I) // 2, width(I) // 2))))
  bottom_half = vmirror(hconcat(crop(I, (0, 0), (height(I) // 2, width(I) // 2)), 
                                 crop(vconcat(paint(canvas(ZERO, (height(I) // 2, width(I) // 2)), obj_bottom), 
                                               canvas(ZERO, (height(I) // 2, width(I) // 2))), 
                                      (0, 0), (height(I) // 2, width(I) // 2))))

  I = vconcat(hconcat(crop(I, (0, 0), (height(I) // 2, width(I) // 2)), right_half), bottom_half)
  return I
 
0.04, 6.2520633, def ehdhjhegdhicegicifdcaabifjeadfbe(I):
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), 
           {(THREE, (one_loc[0], one_loc[1] + i - colorcount(I, THREE) // 2)) for i in range(colorcount(I, THREE))}
           | {(SEVEN, (one_loc[0] + i - colorcount(I, SEVEN) // 2, one_loc[1])) for i in range(colorcount(I, SEVEN))}
           | {(TWO, add(one_loc, DOWN))}
           | {(ONE, one_loc)})
  return O
 
0.04148148148148148, 7.5519114, def fcdgbjbgcefeedhbjfeahifjeibhigef(I):
  one_loc = first(ofcolor(I, ONE))
  h, w = shape(I)
  return tuple(tuple(SEVEN if j == one_loc[1] and abs(i - one_loc[0]) <= colorcount(I, SEVEN) // 2 else
                   THREE if i == one_loc[0] and abs(j - one_loc[1]) <= colorcount(I, THREE) // 2 else
                   TWO if (i, j) == add(one_loc, DOWN) else
                   ONE if (i, j) == one_loc else
                   ZERO 
                   for j in range(w)) for i in range(h))
 
0.04888888888888889, 7.373167, def aggjafcdeieiebdjijbciafjcegdihbd(I):
  """
  This version uses nested loops to simulate the movement of '3's 
  in a more visual way.
  """
  two_loc = first(ofcolor(I, TWO))
  O = I
  for three_loc in ofcolor(I, THREE):
    # Vertical Alignment
    while three_loc[0] != two_loc[0]:
        direction = (1 if three_loc[0] < two_loc[0] else -1, 0)
        O = move(O, recolor(THREE, {three_loc}), direction)
        three_loc = add(three_loc, direction)
    # Horizontal Alignment
    while three_loc[1] != two_loc[1]:
        direction = (0, 1 if three_loc[1] < two_loc[1] else -1)
        O = move(O, recolor(THREE, {three_loc}), direction)
        three_loc = add(three_loc, direction)

  one_loc = first(ofcolor(O, ONE))
  h_len = colorcount(O, THREE)
  v_len = colorcount(O, SEVEN)
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  return O
 
0.035555555555555556, 9.049767, def aiaechfafafeeaajijedecdddfadfbfd(I):
  """
  This version utilizes the 'gravitate' function to handle both 
  vertical and horizontal movements efficiently.
  """
  O = I
  for three_loc in ofcolor(I, THREE):
    direction = gravitate({three_loc}, ofcolor(I, TWO))
    O = move(O, recolor(THREE, {three_loc}), direction)
  
  one_loc = first(ofcolor(O, ONE))
  h_len = colorcount(O, THREE)
  v_len = colorcount(O, SEVEN)
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  return O
 
0.044444444444444446, 7.3951273, def ghdbafbbfbdhefddiebaffhceachacch(I):
  """
  Constructs the cross directly using ranges derived from digit counts.
  """
  one_loc = first(ofcolor(I, ONE))
  h_offset = colorcount(I, SEVEN) // 2
  v_offset = colorcount(I, THREE) // 2
  O = paint(canvas(ZERO, shape(I)), 
           {(ONE, one_loc),
            (TWO, add(one_loc, DOWN))} | 
           {(THREE, (one_loc[0], j)) for j in range(one_loc[1]-h_offset, one_loc[1]+h_offset+1)} | 
           {(SEVEN, (i, one_loc[1])) for i in range(one_loc[0]-v_offset, one_loc[0]+v_offset+1)})
  return O
 
0.038518518518518514, 7.690783, def hdedacdggdedegcejfdfgidehhbdbcgi(I):
    """
    Uses shift and recolor operations on single-element objects to achieve the transformation. 
    """
    one_loc = first(ofcolor(I, ONE))
    threes = recolor(THREE, shift(initset(one_loc), (0, - colorcount(I, THREE) // 2)))
    sevens = recolor(SEVEN, shift(initset(one_loc), (- colorcount(I, SEVEN) // 2, 0)))
    for i in range(1, colorcount(I, THREE)):
      threes = combine(threes, shift(threes, (0, 1)))
    for i in range(1, colorcount(I, SEVEN)):
      sevens = combine(sevens, shift(sevens, (1, 0)))
    return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.03407407407407407, 6.206501, def idjafcehccjeebfejddjgiecfjjaccdc(I):
  """
  Iteratively paints each digit of the lines on a blank canvas.
  """
  one_loc = first(ofcolor(I, ONE))
  O = canvas(ZERO, shape(I))
  for j in range(colorcount(I, THREE)):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2 + j))})
  for i in range(colorcount(I, SEVEN)):
    O = paint(O, {(SEVEN, (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1]))})
  return paint(O, {(ONE, one_loc)})
 
0.04148148148148148, 7.19055, def bcfjdaacacacegdcbecjdcdbdbjhbbjb(I):
  one_loc = first(ofcolor(I, ONE))
  three_count = colorcount(I, THREE)
  seven_count = colorcount(I, SEVEN)
  O = fill(canvas(ZERO, shape(I)), THREE, 
            {(one_loc[0] + i - three_count // 2, one_loc[1]) 
             if three_count % 2 == 1 
             else (one_loc[0] + i - three_count // 2 + 1, one_loc[1] + 1)
             for i in range(three_count)})
  O = paint(O, {(SEVEN, (one_loc[0] + i - seven_count // 2, one_loc[1])) 
                 for i in range(seven_count)})
  O = paint(O, {(TWO, add(one_loc, (1, three_count // 2 if three_count % 2 == 1 else three_count // 2 + 1)))})
  O = paint(O, {(ONE, one_loc)})
  return O
 
0.04888888888888889, 7.3416576, def cdfcbhdeadgdebceaeabcjgdecafdcbj(I):
  one_loc = first(ofcolor(I, ONE))
  three_count = colorcount(I, THREE)
  seven_count = colorcount(I, SEVEN)
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  O = paint(O, {(TWO, add(one_loc, (1, (three_count + 1) // 2)))}) 
  O = paint(O, {(SEVEN, (one_loc[0] - seven_count // 2 + i, one_loc[1])) for i in range(seven_count)})
  for i in range(three_count):
    O = paint(O, {(THREE, (one_loc[0] + i - three_count // 2 + (i + 1) % 2, one_loc[1] + i % 2))})
  return O
 
0.04148148148148148, 10.035673, def jddjgabedeebeiaiabecdihifccbbfah(I):
  one_loc = first(ofcolor(I, ONE))
  three_idx = order(ofcolor(I, THREE), lambda x: x[0] * 15 + x[1])
  seven_count = colorcount(I, SEVEN)
  O = paint(canvas(ZERO, shape(I)), 
             {(THREE, add(one_loc, (i + 1 if i % 2 == 0 else i, i if i % 2 == 0 else i + 1))) for i in range(len(three_idx))})
  O = paint(O, {(SEVEN, (one_loc[0] - seven_count // 2 + i, one_loc[1])) for i in range(seven_count)})
  O = paint(O, {(TWO, add(one_loc, DOWN))})
  O = paint(O, {(ONE, one_loc)})
  return O
 
0.04148148148148148, 6.0832763, def ffgfgcaeebbhecefaahgfhbifecbaedc(I):
  one_loc = first(ofcolor(I, ONE))
  threes = ofcolor(I, THREE)
  sevens = ofcolor(I, SEVEN)
  O = canvas(ZERO, shape(I))
  for i, three_loc in enumerate(threes):
      O = paint(O, {(THREE, (one_loc[0] + i - len(threes) // 2 + (i + 1) % 2, one_loc[1] + i % 2))})
  for i, seven_loc in enumerate(sevens):
      O = paint(O, {(SEVEN, (one_loc[0] - len(sevens) // 2 + i, one_loc[1]))})
  O = paint(O, {(TWO, (one_loc[0] + 1, one_loc[1] + (len(threes) + 1) // 2))})
  return paint(O, {(ONE, one_loc)})
 
0.044444444444444446, 6.8106294, def bfaciedjdiibebbbjhcfdbajdaajecib(I):
  one_loc = first(ofcolor(I, ONE))
  three_count = colorcount(I, THREE)
  seven_count = colorcount(I, SEVEN)
  O = fill(canvas(ZERO, shape(I)), SEVEN, 
            {(one_loc[0] - seven_count // 2 + i, one_loc[1]) for i in range(seven_count)})
  O = paint(O, {(THREE, (one_loc[0] + i - three_count // 2 + (1 - i % 2), one_loc[1] + i % 2))
                 for i in range(three_count)})
  O = paint(O, {(TWO, add(one_loc, (1, three_count // 2 + (1 - three_count % 2))))})
  O = paint(O, {(ONE, one_loc)})
  return O
 
0.04148148148148148, 8.7951355, def ebdbcaefcfgfefgdjccgicejbjcfaccf(I):
  """
  This version iterates through each '3', moves it to the nearest 
  available spot around the '2', and then forms the cross.
  """
  two_loc = first(ofcolor(I, TWO))
  O = I
  for three_loc in ofcolor(I, THREE):
    # Find nearest available spot around '2'
    for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
      new_loc = add(two_loc, direction)
      if index(O, new_loc) == ZERO:
        O = move(O, recolor(THREE, {three_loc}), subtract(new_loc, three_loc))
        break

  one_loc = first(ofcolor(O, ONE))
  h_len = colorcount(O, THREE)
  v_len = colorcount(O, SEVEN)
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  return O
 
0.05333333333333334, 9.006111, def fcecabfddcefefgcjdhdaeafdedbbffb(I):
  """
  This version utilizes 'objects' and 'shift' functions to first 
  group and then move the '3' object, finally building the cross.
  """
  threes = first(colorfilter(objects(I, True, False, False), THREE))
  two_loc = first(ofcolor(I, TWO))
  O = move(I, threes, gravitate(toindices(threes), {two_loc}))

  one_loc = first(ofcolor(O, ONE))
  h_len = colorcount(O, THREE)
  v_len = colorcount(O, SEVEN)
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  return O
 
0.05333333333333334, 8.836488, def edbeehabcefceddhafcbfdfchjahcieb(I):
  """
  This version uses a while loop and manhattan distance to move the '3's 
  and then constructs the cross based on digit counts.
  """
  O = I
  threes = ofcolor(I, THREE)
  two_loc = first(ofcolor(I, TWO))
  
  while manhattan(threes, {two_loc}) > 1:
    for three_loc in threes:
      direction = gravitate({three_loc}, {two_loc})
      O = move(O, recolor(THREE, {three_loc}), direction)
      threes = ofcolor(O, THREE)  # Update 'threes' after each move
      if manhattan(threes, {two_loc}) == 1:  
        break  

  one_loc = first(ofcolor(O, ONE))
  h_len = colorcount(O, THREE)
  v_len = colorcount(O, SEVEN)
  O = paint(O, {(THREE, add(one_loc, (0, di))) for di in range(-h_len // 2, h_len - h_len // 2)})
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-v_len // 2, v_len - v_len // 2)}) 
  return O
 
0.037037037037037035, 5.9552855, def aiicbhbchfidefddjgdabdceebfcbddj(I):
  """
  Directly constructs the cross based on digit counts and anchor location.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, SEVEN)
  cross_height = colorcount(I, THREE)
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)}) # Place the '1'
  O = paint(O, recolor(TWO,  {(one_loc[0] + 1, one_loc[1])})) # Place the '2' 
  O = paint(O, recolor(THREE, {(one_loc[0], one_loc[1] + j - cross_width // 2) for j in range(cross_width)})) # Horizontal
  O = paint(O, recolor(SEVEN, {(one_loc[0] + i - cross_height // 2, one_loc[1]) for i in range(cross_height)})) # Vertical
  return O
 
0.037037037037037035, 6.700233, def dfbfeajbbebeeheeahbdbeiaajheecic(I):
  """
  Constructs horizontal and vertical lines separately, then combines them.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, SEVEN)
  cross_height = colorcount(I, THREE)
  h_line = {(THREE, (one_loc[0], j)) for j in range(one_loc[1] - cross_width // 2, one_loc[1] + cross_width - cross_width // 2)}
  v_line = {(SEVEN, (i, one_loc[1])) for i in range(one_loc[0] - cross_height // 2, one_loc[0] + cross_height - cross_height // 2)}
  return paint(paint(canvas(ZERO, shape(I)), {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))}), h_line | v_line)
 
0.06666666666666667, 13.161213, def ehdfbjheifdfeegcidgafiddihbbbdjf(I):
  """
  Creates a base cross and scales/shifts it based on digit counts. 
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, SEVEN)
  cross_height = colorcount(I, THREE)
  base_cross = {(THREE, (0, 0)), (SEVEN, (1, 0)), (SEVEN, (-1, 0))} 
  scaled_cross = upscale(base_cross, max(1, cross_width // 2, cross_height // 2)) 
  shifted_cross = shift(scaled_cross, (one_loc[0] - cross_height // 2, one_loc[1] - cross_width // 2))
  return paint(paint(canvas(ZERO, shape(I)), {(ONE, one_loc)}), shifted_cross)
 
0.047407407407407405, 11.650642, def cjjidebaadecefagbjeahbgdjdcabghe(I):
  """
  Constructs one quadrant of the cross and mirrors it.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, SEVEN)
  cross_height = colorcount(I, THREE)
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
  for j in range(1, cross_width // 2 + 1):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + j))})
  for i in range(1, cross_height // 2 + 1):
    O = paint(O, {(SEVEN, (one_loc[0] + i, one_loc[1]))})
  O = paint(O, hmirror(asobject(O))) # Mirror horizontally
  O = paint(O, vmirror(asobject(O))) # Mirror vertically
  return O
 
0.038518518518518514, 7.841684, def ahbffdacbbbdecbdijffhibfbabdedde(I):
  """
  Leverages list comprehensions for concise object construction.
  """
  one_i, one_j = first(ofcolor(I, ONE))
  threes = [(THREE, (one_i, one_j + j - colorcount(I, THREE) // 2)) for j in range(colorcount(I, THREE))]
  sevens = [(SEVEN, (one_i + i - colorcount(I, SEVEN) // 2, one_j)) for i in range(colorcount(I, SEVEN))]
  return paint(canvas(ZERO, shape(I)), frozenset(threes + sevens))
 
0.034074074074074076, 27.43014, def jcfehaheghbdeejcbaccbehadebaafdg(I):
  """
  Leverages connect function for line drawing.
  """
  one_loc = first(ofcolor(I, ONE))
  h_start = (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2)
  h_end = (one_loc[0], one_loc[1] + colorcount(I, THREE) // 2 + colorcount(I, THREE) % 2 - 1)
  v_start = (one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[1])
  v_end = (one_loc[0] + colorcount(I, SEVEN) // 2 + colorcount(I, SEVEN) % 2 - 1, one_loc[1])
  h_line = recolor(THREE, connect(h_start, h_end))
  v_line = recolor(SEVEN, connect(v_start, v_end))
  return paint(canvas(ZERO, shape(I)), toobject(h_line, I) | toobject(v_line, I) | {(ONE, one_loc)})
 
0.031111111111111107, 14.810163, def abjcbaeebfadeaifahjbbffcecffbchi(I):
  """
  Constructs lines by repeatedly shifting a single-cell object.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = initset((THREE, one_loc))
  v_line = initset((SEVEN, one_loc))
  for j in range(1, colorcount(I, THREE) // 2 + colorcount(I, THREE) % 2):
    h_line = h_line | shift(h_line, (0, 1))
  for j in range(1, colorcount(I, THREE) // 2):
    h_line = h_line | shift(h_line, (0, -1))
  for i in range(1, colorcount(I, SEVEN) // 2 + colorcount(I, SEVEN) % 2):
    v_line = v_line | shift(v_line, (1, 0))
  for i in range(1, colorcount(I, SEVEN) // 2):
    v_line = v_line | shift(v_line, (-1, 0))
  return paint(canvas(ZERO, shape(I)), h_line | v_line | {(ONE, one_loc)})
 
0.38222222222222224, 45.753536, def hddjbceaadcaefcbifjbeebdbcidbgfg(I):
  """
  Creates lines using range and conditional recoloring.
  """
  one_loc = first(ofcolor(I, ONE))
  h_range = range(one_loc[1] - colorcount(I, THREE) // 2, one_loc[1] + colorcount(I, THREE) // 2 + colorcount(I, THREE) % 2)
  v_range = range(one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[0] + colorcount(I, SEVEN) // 2 + colorcount(I, SEVEN) % 2)
  O = canvas(ZERO, shape(I))
  O = paint(O, {(ONE, one_loc)})
  for i in range(len(I)):
    for j in range(len(I[0])):
      if j in h_range:
        O = paint(O, {(THREE, (i, j))})
      if i in v_range:
        O = paint(O, {(SEVEN, (i, j))})
  return O
 
0.06074074074074074, 18.166382, def acdfeaddfdbhegjcjcbhedbbebbeehci(I):
  one_loc = first(ofcolor(I, ONE))
  threes = ofcolor(I, THREE)
  sevens = ofcolor(I, SEVEN)
  O = canvas(ZERO, shape(I))
  O = paint(O, {(ONE, one_loc)})
  for three_loc in threes:
    O = paint(O, {(THREE, (one_loc[0] + three_loc[0] - one_loc[0], one_loc[1] + three_loc[1] - one_loc[1]))})
  for seven_loc in sevens:
    O = paint(O, {(SEVEN, (one_loc[0] + seven_loc[0] - one_loc[0], one_loc[1] + seven_loc[1] - one_loc[1]))})
  return O
 
0.017777777777777778, 4.6344643, def gjbceijbaaiaeddejbfdcfejbieifged(I):
  """
  Moves '3's towards '2's and aligns '7's vertically with '1'. 
  """
  one_loc = first(ofcolor(I, ONE))
  O = I
  for three_loc in ofcolor(I, THREE):
    direction = gravitate({three_loc}, ofcolor(O, TWO))
    O = move(O, recolor(THREE, {three_loc}), direction)
  sevens = colorcount(I, SEVEN)
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-sevens // 2, sevens - sevens // 2)}) 
  return O 
 
0.03407407407407407, 19.101807, def ebadaifhfegeeadbbicjedafecafddce(I):
  """
  Constructs horizontal and vertical lines using color counts.
  """
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, TWO)
  v_len = colorcount(I, THREE)
  h_start = (one_loc[0], one_loc[1] - h_len // 2)
  v_start = (one_loc[0] - v_len // 2, one_loc[1])
  h_line = {(THREE, (h_start[0], h_start[1] + i)) for i in range(h_len)}
  v_line = {(SEVEN, (v_start[0] + i, v_start[1])) for i in range(v_len)}
  return paint(canvas(ZERO, shape(I)), h_line | v_line | {(ONE, one_loc)})
 
0.03407407407407407, 19.845053, def fjjdadbfbafjehefiaadggfhedaacdii(I):
  """
  Uses recursive functions to draw lines.
  """
  def draw_h_line(O, length, start):
    if length == 0:
      return O
    return draw_h_line(paint(O, {(THREE, start)}), length - 1, (start[0], start[1] + 1))
  def draw_v_line(O, length, start):
    if length == 0:
      return O
    return draw_v_line(paint(O, {(SEVEN, start)}), length - 1, (start[0] + 1, start[1]))
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, TWO)
  v_len = colorcount(I, THREE)
  h_start = (one_loc[0], one_loc[1] - h_len // 2)
  v_start = (one_loc[0] - v_len // 2, one_loc[1])
  return draw_v_line(draw_h_line(canvas(ZERO, shape(I)), h_len, h_start), v_len, v_start)
 
0.037037037037037035, 13.067984, def afhaidfhdafheaddbjacabecdbebffdh(I):
  """
  Uses `interval` and set comprehension for line generation.
  """
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, TWO)
  v_len = colorcount(I, THREE)
  h_range = interval(-h_len // 2 + one_loc[1], h_len // 2 + one_loc[1], 1) 
  v_range = interval(-v_len // 2 + one_loc[0], v_len // 2 + one_loc[0], 1) 
  return paint(canvas(ZERO, shape(I)), {(THREE, (one_loc[0], j)) for j in h_range} | {(SEVEN, (i, one_loc[1])) for i in v_range} | {(ONE, one_loc)})
 
0.04148148148148148, 7.5519114, def ccfhefdgcceeeiacbhfbaidfaabfadad(I):
  """
  Utilizes the `shift` function for moving a base object to create the lines.
  """
  one_loc = first(ofcolor(I, ONE))
  threes = recolor(THREE, initset(one_loc))
  sevens = recolor(SEVEN, initset(one_loc))
  for i in range(colorcount(I, THREE) // 2):
    threes = combine(threes, shift(threes, (0, 1)))
    threes = combine(threes, shift(threes, (0, -1)))
  for i in range(colorcount(I, SEVEN) // 2):
    sevens = combine(sevens, shift(sevens, (1, 0)))
    sevens = combine(sevens, shift(sevens, (-1, 0)))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.038518518518518514, 7.836103, def hbgeebfffjfeeidfabbaehefgaaafjfj(I):
  """
  Leverages 'repeat' function for line generation.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = {(THREE, add(one_loc, (0, j - colorcount(I, THREE) // 2 + (colorcount(I, THREE) % 2)))) for j in range(colorcount(I, THREE))}
  v_line = {(SEVEN, add(one_loc, (i - colorcount(I, SEVEN) // 2, 0))) for i in range(colorcount(I, SEVEN))}
  return paint(canvas(ZERO, shape(I)), h_line | v_line | {(ONE, one_loc)})
 
0.035555555555555556, 6.791456, def cggfefccjchhedbjicaiagbfbfffbdfd(I):
  """
  Employs a single loop and conditional logic for line generation.
  """
  one_loc = first(ofcolor(I, ONE))
  h_count = colorcount(I, THREE)
  v_count = colorcount(I, SEVEN)
  output = canvas(ZERO, shape(I))
  for i in range(max(h_count, v_count)):
    if i < h_count:
      j = i - h_count // 2 + (h_count % 2)
      output = paint(output, {(THREE, add(one_loc, (0, j)))})
    if i < v_count:
      output = paint(output, {(SEVEN, add(one_loc, (i - v_count // 2, 0)))})
  return paint(output, {(ONE, one_loc)})
 
0.03407407407407407, 6.206501, def eifjfaedcdfdebchafjfafcffjdfdabd(I):
  one_loc = first(ofcolor(I, ONE))
  threes = ofcolor(I, THREE)
  sevens = ofcolor(I, SEVEN)
  O = canvas(ZERO, shape(I))
  for i, three_loc in enumerate(threes):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] - len(threes) // 2 + i))})
  for i, seven_loc in enumerate(sevens):
    O = paint(O, {(SEVEN, (one_loc[0] - len(sevens) // 2 + i, one_loc[1]))})
  return paint(O, {(ONE, one_loc)})
 
0.054814814814814816, 20.358788, def fieeggbbfhdhefjibjccaidfjafagcfe(I):
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  for loc in ofcolor(I, THREE):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + loc[1] - one_loc[1]))})
  for loc in ofcolor(I, SEVEN):
    O = paint(O, {(SEVEN, (one_loc[0] + loc[0] - one_loc[0], one_loc[1]))})
  return O
 
0.04, 22.101578, def bbfaafbefcaieaadbadgabggfabcejbc(I):
  one_loc = first(ofcolor(I, ONE))
  O = canvas(ZERO, shape(I))
  O = paint(O, {(ONE, one_loc)})
  O = paint(O, {(THREE, (one_loc[0], one_loc[1] + len(ofcolor(I, THREE)) // 2 - 1))})
  O = paint(O, {(SEVEN, (one_loc[0] - len(ofcolor(I, SEVEN)) // 2, one_loc[1]))})
  return O
 
0.038518518518518514, 7.1018724, def iibibdfdibfceeaebifcjgiacfdjfecf(I):
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  threes = sorted(totuple(ofcolor(I, THREE)), key=lambda x: x[1])
  sevens = sorted(totuple(ofcolor(I, SEVEN)), key=lambda x: x[0])
  for i, loc in enumerate(threes):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] - len(threes) // 2 + i))})
  for i, loc in enumerate(sevens):
    O = paint(O, {(SEVEN, (one_loc[0] - len(sevens) // 2 + i, one_loc[1]))})
  return O
 
0.04148148148148148, 14.088621, def hjhceadgcbbhehbcibiafbfjgfafegbh(I):
  """
  Moves '3's to the nearest '2' and vertically aligns '7's with '1'.
  """
  one_loc = first(ofcolor(I, ONE))
  twos_loc = ofcolor(I, TWO)
  O = I
  for three_loc in ofcolor(I, THREE):
    direction = argmin(
      [(abs(three_loc[0] - two_loc[0]) + abs(three_loc[1] - two_loc[1]), (i, j))  for i, j in [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)] for two_loc in twos_loc],
      lambda x: x[0]
    )[1]
    O = move(O, recolor(THREE, {three_loc}), direction)
  sevens = colorcount(I, SEVEN)
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  O = paint(O, {(SEVEN, add(one_loc, (di, 0))) for di in range(-sevens // 2, sevens - sevens // 2)})
  return O 
 
0.031111111111111114, 4.0473347, def habdiacgdejeecdhaefadcaaefiddicd(I):
  """
  Moves '3's towards '2's using gravitate and aligns '7's with '1'.
  """
  one_loc = first(ofcolor(I, ONE))
  O = I
  for three_loc in ofcolor(I, THREE):
    direction = gravitate({three_loc}, ofcolor(I, TWO))
    O = move(O, recolor(THREE, {three_loc}), direction)
  sevens = colorcount(I, SEVEN)
  O = paint(O, {(SEVEN, (one_loc[0] + i, one_loc[1])) for i in range(-(sevens//2), (sevens//2) + (sevens % 2))})
  return O
 
0.05777777777777778, 11.029295, def iabhgebbcdedefjhaafdbdebaajecega(I):
  """
  Leverages 'centerofmass' for '3' movement and concise '7' alignment.
  """
  one_loc = first(ofcolor(I, ONE))
  O = I
  for three_loc in ofcolor(I, THREE):
    two_center = centerofmass(ofcolor(I, TWO))
    direction = (sign(two_center[0] - three_loc[0]), sign(two_center[1] - three_loc[1]))
    O = move(O, recolor(THREE, {three_loc}), direction)
  sevens = colorcount(I, SEVEN)
  O = paint(O, {(SEVEN, (one_loc[0] - sevens//2 + i, one_loc[1])) for i in range(sevens)})
  return O
 
0.04148148148148148, 7.7756314, def gdejbefgddaheehhaaachcbaiciadfga(I):
  """
  Constructs the cross using line drawing based on digit counts.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, THREE)
  cross_height = colorcount(I, SEVEN)
  O = canvas(ZERO, shape(I))
  O = paint(O, recolor(THREE, connect((one_loc[0], one_loc[1] - cross_width // 2), (one_loc[0], one_loc[1] + cross_width // 2)))) # Horizontal
  O = paint(O, recolor(SEVEN, connect((one_loc[0] - cross_height // 2, one_loc[1]), (one_loc[0] + cross_height // 2, one_loc[1])))) # Vertical
  return paint(paint(O, {(ONE, one_loc)}), {(TWO, (one_loc[0] + 1, one_loc[1]))}) 
 
0.037037037037037035, 7.0436854, def fcdacdbaiebfecgeagebcfdiabhfebbi(I):
  """
  Iteratively builds the cross arms around the anchor point.
  """
  one_loc = first(ofcolor(I, ONE))
  O = canvas(ZERO, shape(I))
  O = paint(O, {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
  for i in range(1, colorcount(I, SEVEN) // 2 + 1):
    O = paint(O, {(SEVEN, (one_loc[0] + i, one_loc[1])), (SEVEN, (one_loc[0] - i, one_loc[1]))})
  for j in range(1, colorcount(I, THREE) // 2 + 1):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + j)), (THREE, (one_loc[0], one_loc[1] - j))})
  return O
 
0.05185185185185185, 10.150039, def afjjdgidfhafebjgaabicahbcifdfcia(I):
  """
  Leverages shifting and normalized object creation for the cross.
  """
  one_loc = first(ofcolor(I, ONE))
  h_arm = normalize(recolor(THREE, {(0, j) for j in range(-colorcount(I, THREE) // 2, colorcount(I, THREE) // 2 + 1)}))
  v_arm = normalize(recolor(SEVEN, {(i, 0) for i in range(-colorcount(I, SEVEN) // 2, colorcount(I, SEVEN) // 2 + 1)}))
  O = canvas(ZERO, shape(I))
  O = paint(O, shift(h_arm, one_loc))
  O = paint(O, shift(v_arm, one_loc))
  return paint(O, {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.044444444444444446, 7.581289, def cdijjijcedaeefiaiccebjdihfcgcjfa(I):
  """
  Combines product and filtering to identify cross arm locations.
  """
  one_loc = first(ofcolor(I, ONE))
  h_range = range(one_loc[1] - colorcount(I, THREE) // 2, one_loc[1] + colorcount(I, THREE) // 2 + 1)
  v_range = range(one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[0] + colorcount(I, SEVEN) // 2 + 1)
  h_arm = {(THREE, (one_loc[0], j)) for j in h_range}
  v_arm = {(SEVEN, (i, one_loc[1])) for i in v_range}
  O = canvas(ZERO, shape(I))
  return paint(paint(O, h_arm), v_arm | {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.035555555555555556, 7.346261, def cbaeggjhbifbeghbiddadbacbaeaceac(I):
  """
  Leverages the `apply` function for a more functional approach to object generation.
  """
  one_loc = first(ofcolor(I, ONE))
  create_line = lambda digit, count, direction: frozenset((digit, add(one_loc, multiply(direction, i - count // 2))) for i in range(count))
  threes = create_line(THREE, colorcount(I, THREE), (1, 0))
  sevens = create_line(SEVEN, colorcount(I, SEVEN), (0, 1))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.03259259259259259, 13.982235, def abfdgidjjfbheggdjadadecfffaedcja(I):
  """
  Builds the lines iteratively using `shift` and `combine`.
  """
  one_loc = first(ofcolor(I, ONE))
  threes = recolor(THREE, initset(one_loc))
  sevens = recolor(SEVEN, initset(one_loc))
  for i in range(1, colorcount(I, THREE) // 2 + (colorcount(I, THREE) % 2)):
    threes = combine(threes, shift(threes, (1, 0)))
    threes = combine(threes, shift(threes, (-1, 0)))
  for i in range(1, colorcount(I, SEVEN) // 2 + (colorcount(I, SEVEN) % 2)):
    sevens = combine(sevens, shift(sevens, (0, 1)))
    sevens = combine(sevens, shift(sevens, (0, -1)))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.037037037037037035, 6.504461, def efbjjfebdeggehifibcehbhefddabcjb(I):
  """
  Finds the '1', calculates line lengths, and constructs the output grid.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = {(THREE, (one_loc[0], j)) for j in range(one_loc[1] - colorcount(I, THREE) // 2, one_loc[1] + colorcount(I, THREE) // 2 + (colorcount(I, THREE) % 2))}
  v_line = {(SEVEN, (i, one_loc[1])) for i in range(one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[0] + colorcount(I, SEVEN) // 2 + (colorcount(I, SEVEN) % 2))}
  return paint(paint(canvas(ZERO, shape(I)), h_line), v_line | {(ONE, one_loc)})
 
0.05777777777777778, 9.20009, def cbjfgeaeibijeccijiffbcadgachddbh(I):
  """
  Employs 'repeat' for line generation and 'shift' for positioning.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = shift(recolor(THREE, {(i, 0) for i in range(colorcount(I, THREE))}), (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2))
  v_line = shift(recolor(SEVEN, {(0, j) for j in range(colorcount(I, SEVEN))}), (one_loc[0] - colorcount(I, SEVEN) // 2, one_loc[1]))
  return paint(paint(canvas(ZERO, shape(I)), h_line), v_line | {(ONE, one_loc)})
 
0.02962962962962963, 25.565521, def iacbdfhifbgaefcdbffdeefeibchabei(I):
  O = canvas(ZERO, shape(I))
  one_loc = first(ofcolor(I, ONE))
  
  # Align '3' digits
  O = paint(O, {(THREE, (i, one_loc[1] - 1)) for i in range(one_loc[0] - colorcount(I, THREE) // 2, one_loc[0] + colorcount(I, THREE) // 2 + (colorcount(I, THREE) % 2))})
  
  # Align '7' digits
  O = paint(O, {(SEVEN, (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1])) for i in range(colorcount(I, SEVEN))})
  
  # Copy other digits
  for v, (i, j) in asobject(I):
    if v not in {ONE, THREE, SEVEN}:
      O = fill(O, v, {(i, j)})
  
  return fill(O, ONE, {one_loc})
 
0.04296296296296296, 6.574522, def ddcbafheichbebieaejbdafcjadffbjc(I):
  """
  Constructs the cross using shifting from center.
  """
  one_loc = first(ofcolor(I, ONE))
  h_arm = recolor(THREE, shift({(0, j) for j in range(-colorcount(I, THREE) // 2, colorcount(I, THREE) - colorcount(I, THREE) // 2)}, one_loc))
  v_arm = recolor(SEVEN, shift({(i, 0) for i in range(-colorcount(I, SEVEN) // 2, colorcount(I, SEVEN) - colorcount(I, SEVEN) // 2)}, one_loc))
  return paint(paint(canvas(ZERO, shape(I)), {(ONE, one_loc)}), h_arm | v_arm | {(TWO, (one_loc[0] + 1, one_loc[1]))}) 
 
0.04, 5.7418084, def gacdgbcdihdeeahgijfehdbaaahiaeaj(I):
  """
  Leverages object detection to construct the cross.
  """
  one = first(colorfilter(objects(I, True, False, False), ONE))
  center_loc = centerofmass(one)
  h_width = colorcount(I, THREE)
  v_height = colorcount(I, SEVEN)
  h_arm = recolor(THREE, {(center_loc[0], center_loc[1] + j - h_width // 2) for j in range(h_width)})
  v_arm = recolor(SEVEN, {(center_loc[0] + i - v_height // 2, center_loc[1]) for i in range(v_height)})
  return paint(paint(canvas(ZERO, shape(I)), h_arm), v_arm | {(ONE, center_loc), (TWO, (center_loc[0] + 1, center_loc[1]))})
 
0.04148148148148148, 11.195875, def chcbccggcfdfeaaeaifdcgdfcjeaajga(I):
  """
  Uses connect function for arm construction.
  """
  one_loc = first(ofcolor(I, ONE))
  h_arm_end = (one_loc[0], one_loc[1] + colorcount(I, THREE) // 2)
  v_arm_end = (one_loc[0] + colorcount(I, SEVEN) // 2, one_loc[1])
  h_arm = recolor(THREE, connect(one_loc, h_arm_end))
  v_arm = recolor(SEVEN, connect(one_loc, v_arm_end))
  return paint(paint(canvas(ZERO, shape(I)), h_arm), v_arm | {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.04148148148148148, 6.141813, def idbfcbfdfafbegcbiaifhegidadjffed(I):
  """
  Iterative approach to construct the cross.
  """
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  for j in range(colorcount(I, THREE)):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2 + j))})
  for i in range(colorcount(I, SEVEN)):
    O = paint(O, {(SEVEN, (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1]))})
  return paint(O, {(TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.06074074074074074, 20.480118, def cbafeefcegeeedjcjjfibhhffciabhad(I):
  """
  Finds the '1', centers '3's vertically, and '7's horizontally around it.
  """
  one_loc = first(ofcolor(I, ONE))
  threes = recolor(THREE, shift(normalize(ofcolor(I, THREE)), (0, one_loc[1] - (colorcount(I, THREE) // 2))))
  sevens = recolor(SEVEN, shift(normalize(ofcolor(I, SEVEN)), (one_loc[0] - (colorcount(I, SEVEN) // 2), 0)))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.035555555555555556, 7.692367, def bgdbffbgfibcebiebbcahebbbdfacgfd(I):
  """
  Combines '3' and '7' placement into a single paint operation.
  """
  one_loc = first(ofcolor(I, ONE))
  digits = combine(
      {(THREE, (one_loc[0] + i - (colorcount(I, THREE) // 2), one_loc[1])) for i in range(colorcount(I, THREE))},
      {(SEVEN, (one_loc[0], one_loc[1] + j - (colorcount(I, SEVEN) // 2))) for j in range(colorcount(I, SEVEN))}
  )
  return paint(canvas(ZERO, shape(I)), digits)
 
0.035555555555555556, 5.2965674, def aiddgebdfafeebjebhbcgafddbbbhbae(I):
  """
  This version employs 'product' for generating indices 
  and a list comprehension for concise object creation.
  """
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  one_loc = first(ofcolor(I, ONE))
  
  # Align '3' horizontally
  three_indices = {(one_loc[0] - len(ofcolor(I, THREE)) // 2 + i, one_loc[1] - 1) for i in range(len(ofcolor(I, THREE)))}
  O = paint(O, {(THREE, idx) for idx in three_indices})

  # Align '7' vertically
  seven_indices = {(one_loc[0] - len(ofcolor(I, SEVEN)) // 2 + i, one_loc[1]) for i in range(len(ofcolor(I, SEVEN)))}
  O = paint(O, {(SEVEN, idx) for idx in seven_indices})
  
  # Place other digits
  other_digits = {(v, (i, j)) for i, j in product(range(h), range(w)) if (v := I[i][j]) not in {ZERO, ONE, THREE, SEVEN}}
  O = paint(O, other_digits)
  
  return fill(O, ONE, {one_loc})
 
0.03703703703703704, 22.07417, def fdcabddabahaedfaiehaejejdejaceff(I):
  """
  This version uses nested loops to iterate through the grid 
  and selectively places digits based on their values.
  """
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  one_loc = first(ofcolor(I, ONE))
  
  for i in range(h):
    for j in range(w):
      val = I[i][j]
      if val == THREE:
        O = fill(O, THREE, {(one_loc[0] - len(ofcolor(I, THREE)) // 2 + j, one_loc[1] - 1)})
      elif val == SEVEN:
        O = fill(O, SEVEN, {(one_loc[0] - len(ofcolor(I, SEVEN)) // 2 + i, one_loc[1])})
      elif val != ONE:
        O = fill(O, val, {(i, j)})
  
  return fill(O, ONE, {one_loc})
 
0.014814814814814815, 3.2397592, def jcffdefdfedgeebbbgcbbdhabeachhcb(I):
  """
  Moves '3's towards '2's recursively and aligns '7's with '1' using modulo operator.
  """
  def move_three_recursive(grid, three_loc):
    if any(adjacent({three_loc}, {two_loc}) for two_loc in ofcolor(grid, TWO)):
      return grid
    direction = gravitate({three_loc}, ofcolor(grid, TWO))
    return move_three_recursive(move(grid, recolor(THREE, {three_loc}), direction), add(three_loc, direction))

  O = I
  for three_loc in ofcolor(I, THREE):
    O = move_three_recursive(O, three_loc)
  one_loc = first(ofcolor(O, ONE))
  sevens_count = colorcount(I, SEVEN)
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  O = paint(O, {(SEVEN, (one_loc[0] + i - sevens_count // 2 + (i >= sevens_count // 2), one_loc[1])) for i in range(sevens_count)})
  return O
 
0.037037037037037035, 5.5879807, def cbhbfdfibfdbedacbbbdhacbegabaebg(I):
  """
  Constructs the cross by iterating over ranges.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_width = colorcount(I, THREE)
  cross_height = colorcount(I, SEVEN)
  O = canvas(ZERO, shape(I))
  for j in range(cross_width):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + j - cross_width // 2))})
  for i in range(cross_height):
    O = paint(O, {(SEVEN, (one_loc[0] + i - cross_height // 2, one_loc[1]))})
  O = paint(O, {(ONE, one_loc)})
  O = paint(O, {(TWO, (one_loc[0] + 1, one_loc[1]))})
  return O
 
0.056296296296296296, 17.21155, def bacabjfachcieedcieajfhhafaiggdif(I):
  """
  This version leverages the 'map' function to efficiently apply transformations
  to individual digits and then constructs the output grid.
  """
  one_loc = first(ofcolor(I, ONE))
  h, w = shape(I)
  
  def transform_digit(digit, i, j):
    if digit == THREE:
      return (THREE, (one_loc[0] - colorcount(I, THREE) // 2 + j, one_loc[1] - 1))
    elif digit == SEVEN:
      return (SEVEN, (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1]))
    elif digit == ONE:
      return (ONE, one_loc)
    else:
      return (digit, (i, j))

  transformed_grid = tuple(
      tuple(transform_digit(I[i][j], i, j)[0] for j in range(w)) 
      for i in range(h)
  )
  
  return transformed_grid
 
0.017777777777777778, 4.671011, def fbefhfcdcedieffcabidehegbajgdgbc(I):
  """
  Moves '3's towards '2's iteratively and aligns '7's with '1' using shifts.
  """
  O = I
  for three_loc in ofcolor(I, THREE):
    while manhattan({three_loc}, ofcolor(O, TWO)) > 1:
      O = move(O, recolor(THREE, {three_loc}), gravitate({three_loc}, ofcolor(O, TWO)))
      three_loc = first(ofcolor(O, THREE))
  one_loc = first(ofcolor(O, ONE))
  sevens = colorcount(I, SEVEN)
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  O = paint(O, {(SEVEN, (one_loc[0], one_loc[1] + i - sevens // 2 - (sevens % 2) + 1)) for i in range(sevens)})
  return O
 
0.014814814814814815, 4.0517063, def idahhebfhbcaebcdibbfdcdeeddebaea(I):
  """
  Moves '3's towards '2's recursively and aligns '7's with '1' using relative positions.
  """
  def move_three(grid, three_loc):
    if manhattan({three_loc}, ofcolor(grid, TWO)) <= 1:
      return grid
    return move_three(move(grid, recolor(THREE, {three_loc}), gravitate({three_loc}, ofcolor(grid, TWO))), add(three_loc, gravitate({three_loc}, ofcolor(grid, TWO))))
  O = I
  for three_loc in ofcolor(I, THREE):
    O = move_three(O, three_loc)
  one_loc = first(ofcolor(O, ONE))
  sevens = sorted(toindices(ofcolor(I, SEVEN)), key = lambda x: x[1])
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  for i, seven_loc in enumerate(sevens):
    O = paint(O, {(SEVEN, (one_loc[0], one_loc[1] - len(sevens) // 2 + i + (len(sevens) % 2)))})
  return O
 
0.02666666666666667, 4.4331512, def bcefjhcadddbebdfbedaabgebbideaii(I):
  """
  Moves '3's towards '2's using extracted objects and aligns '7's with '1' based on bounding box.
  """
  threes = colorfilter(objects(I, T, F, F), THREE)
  twos = colorfilter(objects(I, T, F, F), TWO)
  O = I
  for three in threes:
    direction = gravitate(toindices(three), toindices(first(twos)))
    O = move(O, three, direction)
  one_loc = first(ofcolor(O, ONE))
  sevens = ofcolor(O, SEVEN)
  leftmost_seven = leftmost(sevens)
  O = fill(O, ZERO, sevens)
  O = paint(O, {(SEVEN, (one_loc[0], j)) for j in range(leftmost_seven, leftmost_seven + len(sevens))})
  return O
 
0.04148148148148148, 12.579679, def dbiadhfcdbjjefegajajffiajjbihhjg(I):
  """
  Moves '3's towards '2's by directly calculating target positions and aligns '7's based on their original order.
  """
  O = I
  for three_loc in ofcolor(I, THREE):
    target_loc = ulcorner(ofcolor(I, TWO))
    O = move(O, recolor(THREE, {three_loc}), (sign(target_loc[0] - three_loc[0]), sign(target_loc[1] - three_loc[1])))
  one_loc = first(ofcolor(O, ONE))
  sevens = sorted(toindices(ofcolor(I, SEVEN)), key=lambda x: x[1])
  O = fill(O, ZERO, ofcolor(O, SEVEN))
  for i, seven_loc in enumerate(sevens):
    O = paint(O, {(SEVEN, (one_loc[0], one_loc[1] + i - len(sevens) // 2))})
  return O
 
0.03259259259259259, 6.715681, def eahhjeiddgfeejcbjefdadfffabgcibg(I):
  one_loc = first(ofcolor(I, ONE))
  seven_obj = recolor(SEVEN, shift({(0, 0), (1, 0), (-1, 0)}, one_loc))
  three_obj = recolor(THREE, shift({(0, 0), (0, 1), (0, -1)}, one_loc))
  two_obj = {(TWO, add(one_loc, RIGHT))}
  return paint(paint(paint(canvas(ZERO, shape(I)), seven_obj), three_obj), two_obj)
 
0.03259259259259259, 6.1200733, def agfjbbcjafafegfcjaaedacbcjhcefeb(I):
  """
  Iterative approach to paint the cross.
  """
  O = canvas(ZERO, shape(I))
  one_loc = first(ofcolor(I, ONE))
  O = paint(O, {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
  for d in [-1, 0, 1]:
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + d))})
    O = paint(O, {(SEVEN, (one_loc[0] + d, one_loc[1]))})
  return O
 
0.035555555555555556, 6.69915, def bfeedeebbcbfebfaihaadafcefabeaac(I):
  """
  Constructs the cross using the connect function.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = recolor(THREE, connect(add(one_loc, (-1, 0)), add(one_loc, (1, 0))))
  v_line = recolor(SEVEN, connect(add(one_loc, (0, -1)), add(one_loc, (0, 1))))
  return paint(paint(canvas(ZERO, shape(I)), h_line), v_line | {(TWO, add(one_loc, RIGHT))})
 
0.04296296296296296, 7.366206, def jihdiciijbibeaeijbccihfacbdecibd(I):
  """
  Constructs one arm of the cross and then uses mirroring for efficiency.
  """
  one_loc = first(ofcolor(I, ONE))
  arm = recolor(THREE, {(one_loc[0], one_loc[1] + i) for i in range(-1, 2)})
  cross = arm | hmirror(arm)
  return paint(paint(canvas(ZERO, shape(I)), cross), recolor(SEVEN, shift(cross, (1, 0))) | {(TWO, add(one_loc, RIGHT))})
 
0.05777777777777778, 11.496704, def fgebidaahabdeaacbabccdbjfbjddjdf(I):
  """
  Defines helper functions to streamline the line generation and placement logic.
  """
  def place_line(digit, count, offset):
      return {(digit, add(one_loc, (offset[0] * i - count // 2, offset[1] * i - count // 2))) for i in range(count)}
  one_loc = first(ofcolor(I, ONE))
  threes = place_line(THREE, colorcount(I, THREE), (0, 1))
  sevens = place_line(SEVEN, colorcount(I, SEVEN), (1, 0))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.031111111111111107, 13.993034, def cedjhcccdhejeigdibdcadagaefcebif(I):
  """
  Constructs lines by repeatedly shifting a single-element object.
  """
  one_loc = first(ofcolor(I, ONE))
  h_line = {(THREE, one_loc)}
  v_line = {(SEVEN, one_loc)}
  for i in range(1, colorcount(I, THREE) // 2 + (colorcount(I, THREE) % 2)):
    h_line = h_line | shift(h_line, (0, 1)) | shift(h_line, (0, -1))
  for i in range(1, colorcount(I, SEVEN) // 2 + (colorcount(I, SEVEN) % 2)):
    v_line = v_line | shift(v_line, (1, 0)) | shift(v_line, (-1, 0))
  return paint(canvas(ZERO, shape(I)), h_line | v_line | {(ONE, one_loc)})
 
0.04296296296296296, 17.809656, def dhbhdagbjbeeeaahbfbgdcbccficcbah(I):
  """
  This version uses nested loops and conditional statements 
  to explicitly handle each digit's placement.
  """
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  one_loc = first(ofcolor(I, ONE))
  
  for i in range(h):
    for j in range(w):
      v = I[i][j]
      if v == THREE:
        O = fill(O, v, {(one_loc[0] - colorcount(I, THREE) // 2 + i - one_loc[0], one_loc[1] - 1)})
      elif v == SEVEN:
        O = fill(O, v, {(one_loc[0] - colorcount(I, SEVEN) // 2 + j - one_loc[1], one_loc[1])})
      elif v != ONE:
        O = fill(O, v, {(i, j)})
  
  return fill(O, ONE, {one_loc})
 
0.04, 20.692154, def ifgdhjbfiadbejcdageeicficefcfbbc(I):
  """
  This version utilizes a dictionary for more readable 
  and maintainable digit placement logic.
  """
  O = canvas(ZERO, shape(I))
  one_loc = first(ofcolor(I, ONE))

  placement_logic = {
      THREE: lambda i: (one_loc[0] - colorcount(I, THREE) // 2 + i, one_loc[1] - 1),
      SEVEN: lambda i: (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1]),
  }

  for v, (i, j) in asobject(I):
      if v in placement_logic:
          O = fill(O, v, {(placement_logic[v](i - one_loc[0]))}) 
      elif v != ONE:
          O = fill(O, v, {(i, j)})

  return fill(O, ONE, {one_loc})
 
0.037037037037037035, 6.294113, def jdcdcacejcaceabdifcgajhjfehbbdjf(I):
  """
  Constructs the cross using shifting and set operations.
  """
  one_loc = first(ofcolor(I, ONE))
  h_length = colorcount(I, THREE)
  v_length = colorcount(I, SEVEN)
  h_arm = recolor(THREE, {(one_loc[0], one_loc[1] + j - h_length // 2) for j in range(h_length)})
  v_arm = recolor(SEVEN, {(one_loc[0] + i - v_length // 2, one_loc[1]) for i in range(v_length)})
  return paint(canvas(ZERO, shape(I)), h_arm | v_arm | {(ONE, one_loc), (TWO, add(one_loc, RIGHT))})
 
0.038518518518518514, 6.3177295, def hhfieaeghachedgajfbaabdeddegdaaf(I):
  """
  Constructs the cross iteratively using paint.
  """
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc), (TWO, add(one_loc, RIGHT))}) 
  for j in range(colorcount(I, THREE)):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] - colorcount(I, THREE) // 2 + j))})
  for i in range(colorcount(I, SEVEN)):
    O = paint(O, {(SEVEN, (one_loc[0] - colorcount(I, SEVEN) // 2 + i, one_loc[1]))})
  return O
 
0.038518518518518514, 6.7778783, def aebgecdebdcieiajaeadjfibcebdgcdd(I):
  """
  Uses functional approach with compose and lambda functions.
  """
  one_loc = first(ofcolor(I, ONE))
  h_arm = lambda O: paint(O, recolor(THREE, {(one_loc[0], one_loc[1] + j - colorcount(I, THREE) // 2) for j in range(colorcount(I, THREE))}))
  v_arm = lambda O: paint(O, recolor(SEVEN, {(one_loc[0] + i - colorcount(I, SEVEN) // 2, one_loc[1]) for i in range(colorcount(I, SEVEN))}))
  base = paint(canvas(ZERO, shape(I)), {(ONE, one_loc), (TWO, add(one_loc, RIGHT))})
  return compose(h_arm, v_arm)(base)
 
0.04888888888888889, 13.388315, def aehbafbihafbejeeahfjhhaedfdeiajb(I):
  """
  Iteratively builds lines from the center outwards.
  """
  one_loc = first(ofcolor(I, ONE))
  threes = recolor(THREE, initset(one_loc))
  sevens = recolor(SEVEN, initset(one_loc))
  for i in range(1, colorcount(I, THREE) // 2 + 1):
    threes = combine(threes, shift(threes, (0, i)))
    threes = combine(threes, shift(threes, (0, -i)))
  for i in range(1, colorcount(I, SEVEN) // 2 + 1):
    sevens = combine(sevens, shift(sevens, (i, 0)))
    sevens = combine(sevens, shift(sevens, (-i, 0)))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.04148148148148148, 7.1461267, def dibicfbfhabceegebegbeifbdchachhi(I):
  """
  Leverages `interval` function to generate line indices directly.
  """
  one_loc = first(ofcolor(I, ONE))
  three_offset =  (0, -colorcount(I, THREE) // 2)
  seven_offset = (-colorcount(I, SEVEN) // 2, 0)
  threes = recolor(THREE, frozenset((one_loc[0], j) for j in 
                    interval(one_loc[1] + three_offset[1], 
                              one_loc[1] - three_offset[1] + colorcount(I, THREE) % 2, 1)))
  sevens = recolor(SEVEN, frozenset((i, one_loc[1]) for i in 
                    interval(one_loc[0] + seven_offset[0], 
                              one_loc[0] - seven_offset[0] + colorcount(I, SEVEN) % 2, 1)))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.047407407407407405, 24.058834, def hdfadbffjjddefjfjhegdaiefcibhhba(I):
  """
  Constructs lines using `product` and offsetting.
  """
  one_loc = first(ofcolor(I, ONE))
  three_offset = (0, -colorcount(I, THREE) // 2)
  seven_offset = (-colorcount(I, SEVEN) // 2, 0)
  threes = recolor(THREE, shift(product(initset(one_loc[0]), range(colorcount(I, THREE))), three_offset))
  sevens = recolor(SEVEN, shift(product(range(colorcount(I, SEVEN)), initset(one_loc[1])), seven_offset))
  return paint(paint(canvas(ZERO, shape(I)), threes), sevens)
 
0.028148148148148148, 27.03826, def bdjgjdgjeegdecbebabbeefebeedbdga(I):
  O = canvas(ZERO, shape(I))
  one_loc = first(ofcolor(I, ONE))
  threes = []
  sevens = []
  for v, (i, j) in asobject(I):
    if v == THREE:
      threes.append((i, j))
    elif v == SEVEN:
      sevens.append((i, j))
  
  for i, (r, c) in enumerate(threes):
    O = fill(O, THREE, {(one_loc[0] - len(threes) // 2 + i, one_loc[1])})
  
  for i, (r, c) in enumerate(sevens):
    O = fill(O, SEVEN, {(one_loc[0], one_loc[1] - len(sevens) // 2 + i)})
  
  for v, (i, j) in asobject(I):
    if v not in {ONE, THREE, SEVEN}:
      O = fill(O, v, {(i, j)})

  return fill(O, ONE, {one_loc})
 
0.05037037037037037, 14.0056925, def ajibaaajgjaaeaebaaeecieeeadcjeef(I):
  """
  Uses object detection and set operations to draw the cross.
  """
  one_loc = first(ofcolor(I, ONE))
  three_indices = ofcolor(I, THREE)
  seven_indices = ofcolor(I, SEVEN)
  h_arm = frozenset({(one_loc[0], j) for i, j in three_indices})
  v_arm = frozenset({(i, one_loc[1]) for i, j in seven_indices})
  return paint(paint(paint(canvas(ZERO, shape(I)), recolor(THREE, h_arm)), 
                       recolor(SEVEN, v_arm)), 
               {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.04, 5.4265056, def adagichehhddefcfafajajddgfejbihg(I):
  """
  Uses shifting and line drawing functions for constructing the cross.
  """
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, THREE) // 2
  v_len = colorcount(I, SEVEN) // 2
  h_line = shift(connect((0, -h_len), (0, h_len - (1 - h_len % 2))), one_loc)
  v_line = shift(connect((-v_len, 0), (v_len - (1 - v_len % 2), 0)), one_loc)
  return paint(paint(canvas(ZERO, shape(I)), recolor(THREE, h_line)), 
               recolor(SEVEN, v_line) | {(ONE, one_loc), (TWO, (one_loc[0] + 1, one_loc[1]))})
 
0.05185185185185185, 14.114946, def hjadaafdabefeeahbigfbjedfjfcfgfe(I):
  """
  This program uses a combination of mapping, filtering, and set operations.
  """
  one_loc = first(ofcolor(I, ONE))
  threes = {(one_loc[0], j) for i, j in ofcolor(I, THREE)} 
  sevens = {(i, one_loc[1]) for i, j in ofcolor(I, SEVEN)} 
  return paint(paint(canvas(ZERO, shape(I)), recolor(THREE, threes)), 
                recolor(SEVEN, sevens) | {(ONE, one_loc), (TWO, add(one_loc, DOWN))})
 
0.02962962962962963, 26.04517, def gcfffdcfdbabeeccicacjbacacjceidg(I):
  one_loc = first(ofcolor(I, ONE))
  O = canvas(ZERO, shape(I))
  
  # Place digit '3' vertically above '1'
  for i in range(colorcount(I, THREE)):
    O = fill(O, THREE, {(one_loc[0] - colorcount(I, THREE) // 2 + i, one_loc[1])})

  # Place digit '7' horizontally to the right of '1'
  for i in range(colorcount(I, SEVEN)):
    O = fill(O, SEVEN, {(one_loc[0], one_loc[1] + 1 + i)})

  # Paint other digits in their original positions
  for v, (i, j) in asobject(I):
    if v not in {ONE, THREE, SEVEN}:
      O = fill(O, v, {(i, j)})

  # Fill '1' at its original position
  return fill(O, ONE, {one_loc})
 
0.06074074074074074, 17.27147, def jcdjdjgjdgdjeibbadgdcfadddacadae(I):
  one_loc = first(ofcolor(I, ONE))
  O = paint(canvas(ZERO, shape(I)), {(ONE, one_loc)})
  for d, direction in ((THREE, UP), (SEVEN, RIGHT)):
    for i in range(colorcount(I, d)):
      offset = multiply((i - colorcount(I, d) // 2, i - colorcount(I, d) // 2), direction)
      O = fill(O, d, {add(one_loc, offset)})
  return paint(O, {(v, (i, j)) for v, (i, j) in asobject(I) if v != ONE})
 
0.031111111111111114, 21.720737, def hefdajdbebgeecbeadafhdaecccfecdh(I):
  one_loc = first(ofcolor(I, ONE))
  O = canvas(ZERO, shape(I))
  for v, (i, j) in asobject(I):
    if v == THREE:
      O = fill(O, v, {(one_loc[0] - colorcount(I, v) // 2 + j - one_loc[1], one_loc[1])})
    elif v == SEVEN:
      O = fill(O, v, {(one_loc[0], one_loc[1] + 1 + i - one_loc[0])})
    else:
      O = fill(O, v, {(i, j)})
  return fill(O, ONE, {one_loc})
 
0.038518518518518514, 6.6598883, def ieceejggdcejeadbicbbhecicdafidac(I):
  """
  Finds the location of '1' and constructs the cross using canvas and paint.
  """
  one_loc = first(ofcolor(I, ONE))
  cross_height = colorcount(I, SEVEN)
  cross_width = colorcount(I, THREE)
  O = canvas(ZERO, shape(I))
  O = paint(O, {(ONE, one_loc)}) # Place the '1'
  O = paint(O, recolor(TWO, {(one_loc[0] + 1, one_loc[1])})) # Place the '2' below '1'
  O = paint(O, recolor(SEVEN, {(one_loc[0] + i - cross_height // 2, one_loc[1]) for i in range(cross_height)})) # Vertical line
  O = paint(O, recolor(THREE, {(one_loc[0], one_loc[1] + j - cross_width // 2) for j in range(cross_width)})) # Horizontal line
  return O
 
0.035555555555555556, 5.9872117, def ijejccbbdeddeadgbdeddebhagibdcdc(I):
  """
  Uses nested loops to iterate and paint the lines directly on the canvas.
  """
  one_loc = first(ofcolor(I, ONE))
  h_len = colorcount(I, THREE)
  v_len = colorcount(I, SEVEN)
  O = canvas(ZERO, shape(I))
  for j in range(-h_len // 2, h_len // 2 + (h_len % 2)):
    O = paint(O, {(THREE, (one_loc[0], one_loc[1] + j))})
  for i in range(-v_len // 2, v_len // 2 + (v_len % 2)):
    O = paint(O, {(SEVEN, (one_loc[0] + i, one_loc[1]))})
  return paint(O, {(ONE, one_loc)})
 
0.04296296296296296, 28.133823, def fcffhbfcjdeaeeegajcgaafadciadgjc(I):
  obj = first(objects(I, F, F, F))  # Extract the object (doesn't need to be univalued)
  if color(obj) == TWO:  # Input type 0 or 2
    if color(first(objects(I, F, F, T)))==SEVEN: #Input type 0
      new_obj = shift(recolor(TWO,{(TWO,center(obj))}), (NEG_ONE, ZERO)) | recolor(THREE, shift({(THREE, (i,j)) for i, j in toindices(obj) if THREE == index(I, (i, j))}, (ZERO, NEG_ONE))) | recolor(THREE, shift({(THREE, (i,j)) for i, j in toindices(obj) if THREE == index(I, (i, j))}, (ZERO, ONE)))
    else:
      new_obj = rot270(obj)
  else: #Input type 1
    new_obj = {(v, (i+ONE,center(obj)[ONE])) for v, (i, j) in obj}
  O = paint(cover(I, obj), new_obj)
  return O
 
0.04296296296296296, 7.9429126, def ddgabehejcceebceadbdaggidhbabfcg(I):
  obj2_loc = ulcorner(ofcolor(I, TWO))
  obj3_loc = ulcorner(ofcolor(I, THREE))
  move_vector = add(subtract(obj3_loc, obj2_loc), (-3, 0))
  O = paint(fill(I, ZERO, ofcolor(I, TWO)), shift(recolor(THREE, toobject(ofcolor(I, TWO), I)), move_vector))
  return O
 
0.05185185185185185, 6.283445, def efcadafiiceeeiajjediaifccbgfgfbd(I):
    obj = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
    target_row = 3 if uppermost(ofcolor(I, 7)) < 8 else 11
    offset = (target_row - uppermost(obj), 0)
    O = paint(cover(I, obj), shift(obj, offset))
    return O
 
0.04888888888888889, 10.074662, def bghecabfadegeeddbhhfcegdeafdhafi(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) == SEVEN) # Find the object with the color '7'
    center_i, center_j = centerofmass(obj) # Get the center of mass of the object
    if height(obj) > width(obj): # If the object is taller than it is wide (vertical)
        new_obj = recolor(THREE, shift( {(center_i - 1, center_j), (center_i, center_j), (center_i + 1, center_j)}, (0, 1))) # Create a vertical line of '3's, shifted one unit right 
    else: # If the object is wider than it is tall (horizontal)
        new_obj = recolor(THREE, shift( {(center_i, center_j - 1), (center_i, center_j), (center_i, center_j + 1)}, (1, 0))) # Create a horizontal line of '3's, shifted one unit down
    O = paint(I, new_obj) # Paint the new object onto the grid
    O = paint(O, {(TWO, center(new_obj))}) # Paint the digit '2' at the center of the new object
    return O
 
0.05037037037037037, 11.179014, def jhecbfcffgfdegggbahcjbahcjccfadb(I):
    obj_7 = argmax(objects(I, T, T, T), size) # Find the largest object (assuming the object with '7's is the largest)
    upper = uppermost(obj_7)
    lower = lowermost(obj_7)
    left = leftmost(obj_7)
    right = rightmost(obj_7)
    if lower - upper > right - left:  # Check if object is taller than it is wide
        O = fill(I, THREE, {(upper - 1, right + 1), (upper, right + 1), (upper + 1, right + 1)}) # Vertical line of '3's
        O = paint(O, {(TWO, (upper, right + 1))}) # '2' in the center 
    else:
        O = fill(I, THREE, {(lower + 1, left + 1), (lower + 1, left), (lower + 1, left - 1)}) # Horizontal line of '3's
        O = paint(O, {(TWO, (lower + 1, left))}) # '2' in the center
    return O 
 
0.04888888888888889, 8.86379, def ddbcfffacehjebcdjdjfefieadhiddeb(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) == SEVEN)
    direction = (0, 1) if portrait(obj) else (1, 0)  # Direction of line placement
    start_point = add(branch(portrait(obj), urcorner(obj), lrcorner(obj)), direction)
    new_line = recolor(THREE, {add(start_point, (i * direction[0], i * direction[1])) for i in range(-1, 2)}) 
    O = paint(I, new_line)
    O = paint(O, {(TWO, start_point)}) 
    return O
 
0.04888888888888889, 9.534439, def adhhdhcafjfbehbabbccaibabcbeeaad(I):
    obj_7 = extract(objects(I, T, T, T), lambda o: color(o) == SEVEN)
    center_point = center(obj_7)
    if portrait(obj_7):
        new_obj = recolor(THREE, connect((center_point[0] - 1, center_point[1] + 1), (center_point[0] + 1, center_point[1] + 1)))
    else:
        new_obj = recolor(THREE, connect((center_point[0] + 1, center_point[1] - 1), (center_point[0] + 1, center_point[1] + 1)))
    O = paint(I, new_obj)
    O = paint(O, {(TWO, add(center_point, branch(portrait(obj_7), (0, 1), (1, 0))))})
    return O
 
0.045925925925925926, 6.458119, def hibebfcahcaiebhabgcecajbceffjbac(I):
  target_colors = {TWO, THREE, SEVEN}
  obj = first(sfilter(objects(I, F, F, F), lambda o: any(c in palette(o) for c in target_colors)))
  center_loc = center(obj)
  if color(obj) == TWO and index(I, add(center_loc, UP)) == SEVEN:
    new_obj = recolor(TWO, {center_loc}) |\
              recolor(ONE, {add(center_loc, UP)}) |\
              recolor(THREE, {add(center_loc, DOWN), add(center_loc, (TWO, ZERO))})
  elif color(obj) != TWO:
    new_obj = shift(obj, (ONE, ZERO))
  else:
    new_obj = rot90(obj)
  O = paint(cover(I, obj), new_obj)
  return O
 
0.037037037037037035, 35.725292, def hcaffcfjbbcbeeaaiaeaebcdaeeceahj(I):
  obj = first(sfilter(objects(I, F, F, F), lambda o: 2 in palette(o) or 7 in palette(o)))
  if color(obj) == TWO:
    if index(I, add(center(obj), UP)) == SEVEN:
      new_obj  =  recolor(TWO, {(TWO, center(obj))}) |\
                  recolor(ONE, {(ONE,  add(center(obj), UP))}) |\
                  recolor(THREE, {(THREE, add(center(obj), (TWO, ZERO))), (THREE, add(center(obj), DOWN))})
    else:
      new_obj = rot270(obj)
  else:
    center_j = centerofmass(obj)[ONE]
    new_obj = {(v, (uppermost(obj) + i + height(obj), center_j)) for i, (v, loc) in enumerate(obj)}
  O = paint(cover(I, obj), new_obj)
  return O
 
0.04296296296296296, 5.719421, def beedadgiccahedfbbhccaahaiddcefhi(I):
  target_object = argmin(objects(I, True, True, True), lambda obj: len(obj))
  new_grid = paint(cover(I, target_object), recolor(1, target_object))
  direction = (1, 0) if height(target_object) >= width(target_object) else (0, 1)
  new_obj = set()
  for i in range(-1, max(height(target_object), width(target_object))):
    new_obj.add((2, add(ulcorner(target_object), multiply(direction, i))))
  O = paint(new_grid, frozenset(new_obj))
  return O
 
0.047407407407407405, 7.75288, def afbhbghjaidfeajhbbgcdceiebabbfdc(I):
  target_object = min(objects(I, True, True, True), key=lambda obj: len(obj))
  O = paint(cover(I, target_object), recolor(1, target_object))
  if height(target_object) > width(target_object):
    O = paint(O, recolor(2, connect(subtract(ulcorner(target_object), (1, 0)), add(lrcorner(target_object), (1, 0)))))
  else:
    O = paint(O, recolor(2, connect(subtract(ulcorner(target_object), (0, 1)), add(lrcorner(target_object), (0, 1)))))
  return O
 
0.04148148148148148, 10.495698, def aeedigbdhaciegfdjefafbbbdebedabj(I):
    obj2_indices = ofcolor(I, TWO)
    obj3_indices = ofcolor(I, THREE)
    target = subtract(center(obj3_indices), center(obj2_indices))  # Calculate direction vector
    steps = valmax(target, abs)  # Determine number of steps
    direction = tuple(sign(v) for v in target) # Normalize direction
    move_vector = multiply(direction, steps) # Scale to correct distance
    moved_obj2 = shift(recolor(THREE, toobject(obj2_indices, I)), move_vector)
    O = paint(fill(I, ZERO, obj2_indices), moved_obj2)
    return O
 
0.044444444444444446, 5.947109, def ceehaibcchjeecieacceeddffjcaadhg(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I) 
  obj7 = toobject(ofcolor(I, 7), I)
  center_obj23 = centerofmass(obj23)
  center_obj7 = centerofmass(obj7)

  # Align horizontally if objects share a row, otherwise align vertically
  if hmatching(obj23, obj7):
    target_center = (center_obj7[0], center_obj23[1]) 
  else:
    target_center = (center_obj23[0], center_obj7[1])

  offset = subtract(target_center, center_obj23)
  O = paint(cover(I, obj23), shift(obj23, offset))
  return O
 
0.04888888888888889, 8.469642, def ddicgfcjafgiefiiidbjefbajehdbbde(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I) 
  obj7 = toobject(ofcolor(I, 7), I)

  # Align top of obj23 with bottom of obj7 if obj7 is above obj23, 
  # otherwise align bottom of obj23 with top of obj7 
  if uppermost(obj7) < uppermost(obj23): 
    offset = (lowermost(obj7) + 1 - uppermost(obj23), leftmost(obj7) - leftmost(obj23))
  else:
    offset = (uppermost(obj7) - lowermost(obj23) - 1, leftmost(obj7) - leftmost(obj23))

  O = paint(cover(I, obj23), shift(obj23, offset))
  return O
 
0.047407407407407405, 10.762127, def cdfbeafaeaadefddaheejddahbfghdih(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  # Calculate offset based on relative position of object centers
  direction = position(obj23, obj7)
  offset = multiply(crement(direction), shape(obj23))

  O = paint(cover(I, obj23), shift(obj23, offset))
  return O
 
0.044444444444444446, 6.724114, def cebcebffafbcegedbcadaibfbfjfchde(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  # Use gravitate function to determine offset for adjacency 
  offset = gravitate(obj23, obj7)

  O = paint(cover(I, obj23), shift(obj23, offset))
  return O
 
0.05037037037037037, 8.592596, def gbhbhcafjffceegcihebeabccdeiecee(I):
    obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
    obj7 = toobject(ofcolor(I, 7), I)

    # Determine alignment based on horizontal matching
    if hmatching(obj23, obj7):
        target_loc = (uppermost(obj7) - height(obj23), leftmost(obj7))
    else:
        target_loc = (uppermost(obj23), leftmost(obj7) - width(obj23))
    
    offset = subtract(target_loc, ulcorner(obj23))
    O = paint(cover(I, obj23), shift(obj23, offset))
    return O
 
0.04296296296296296, 5.6864457, def gfbbefjjbbhdehfibddjedibfedaddfh(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find non-background object
  box_indices = box(obj) # Get the bounding box indices
  O = fill(I, THREE, box_indices) # Draw the box with '3's
  center_top = (uppermost(obj)-1, leftmost(obj) + width(obj) // 2) # Find the center-top index
  O = paint(O, {(TWO, center_top)}) # Replace with '2'
  return O
 
0.06518518518518518, 17.314041, def jiigihbbdaaaeebcjcbbbabffecagdda(I):
  objs = objects(I, T, T, T) # Find all objects
  obj = extract(objs, lambda o: color(o) != ZERO) # Select the non-background object
  O = fill(I, THREE, outbox(obj)) # Draw the box with '3's using outbox
  center_index = center(obj) # Calculate the center index
  O = paint(O, {(TWO, add(center_index, (-1, 0)))}) # Place '2' above the center
  return O
 
0.06518518518518518, 18.297472, def bcfhbffffffjeaeaiaageeaedcfdciec(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find non-background object
  O = I
  for i in range(height(obj) + 2): # Iterate over rows of the box
    for j in range(width(obj) + 2): # Iterate over columns of the box
      current_index = add(ulcorner(obj), (i-1, j-1))
      if i == 0 and j == width(obj) // 2: # Condition for placing '2'
        O = paint(O, {(TWO, current_index)})
      elif contained(current_index, backdrop(obj)): # Don't overwrite object cells
        continue
      else:
        O = paint(O, {(THREE, current_index)}) # Draw the box with '3's
  return O
 
0.04148148148148148, 5.8959126, def dciichjaejedebbfaaaaaidaidbacbab(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find non-background object
  O = paint(I, recolor(THREE, delta(obj))) # Fill around object with '3's
  top_edge = {(uppermost(obj), j) for j in range(leftmost(obj), rightmost(obj) + 1)}
  center_top = extract(top_edge, lambda loc: index(I, loc) == color(obj)) # Find center on top edge
  O = paint(O, {(TWO, add(center_top, (-1, 0)))}) # Place '2' above the center
  return O
 
0.06666666666666667, 17.78878, def hifdeajaacchedcficfjhdfbbcdgacfc(I):
  for obj in objects(I, T, T, T):
    if color(obj) != ZERO:
      break
  corner = ulcorner(obj)
  O = paint(I, recolor(THREE,  {(corner[0] + i - 1, corner[1] + j - 1) 
                                  for i in range(height(obj) + 2) 
                                  for j in range(width(obj) + 2)}))
  O = paint(O, {(TWO, (corner[0] - 1, corner[1] + width(obj) // 2))})
  return O
 
0.04, 5.4265056, def bccchaebbcegeefajffhafcegccdbbac(I):
  obj = next((o for o in objects(I, F, F, F) if color(o) in {TWO, THREE, SEVEN}), None)
  if obj is None:
    return I 
  if color(obj) == TWO:
    if any(index(I, add(loc, UP)) == SEVEN for loc in toindices(ofcolor(I, TWO))):
      two_loc = first(toindices(ofcolor(I, TWO)))
      new_obj = recolor(THREE, {two_loc, add(two_loc, DOWN), add(two_loc, (TWO, ZERO))}) | \
                recolor(ONE, {add(two_loc, UP)})
    else:
      new_obj = hmirror(obj)
  else:
    new_obj = {(v, (i + height(obj), j)) for (v, (i, j)) in obj}
  O = paint(cover(I, obj), new_obj)
  return O
 
0.047407407407407405, 8.286161, def bdbcefaficeiehcdibafhhiedeajedfb(I):
  objs = sorted(objects(I, True, True, True), key=size)
  smallest_obj = objs[0]
  O = paint(cover(I, smallest_obj), recolor(1, smallest_obj))
  for i, obj in enumerate(objs):
    if obj == smallest_obj:
      center_j = leftmost(obj) + width(obj) // 2
      for k in range(uppermost(obj) - 1, lowermost(obj) + 2):
        O = paint(O, recolor(3 if k != uppermost(obj) + height(obj) // 2 + 1 else 2, frozenset({(k, center_j)})))
  return O
 
0.047407407407407405, 7.353359, def hebeifjahabaeiaabbjfjgbecjbeeaeb(I):
  smallest_obj = extract(objects(I, True, True, True), lambda obj: size(obj) == min(len(o) for o in objects(I, True, True, True)))
  O = paint(cover(I, smallest_obj), recolor(1, smallest_obj))
  if height(smallest_obj) > width(smallest_obj):
    O = paint(O, recolor(3, connect(subtract(ulcorner(smallest_obj), (1, 0)), add(lrcorner(smallest_obj), (1, 0)))))
    O = paint(O, recolor(2, frozenset({(uppermost(smallest_obj) + height(smallest_obj) // 2 + 1, leftmost(smallest_obj))})))
  else:
    O = paint(O, recolor(3, connect(subtract(ulcorner(smallest_obj), (0, 1)), add(lrcorner(smallest_obj), (0, 1)))))
    O = paint(O, recolor(2, frozenset({(uppermost(smallest_obj), leftmost(smallest_obj) + width(smallest_obj) // 2 + 1)})))
  return O
 
0.044444444444444446, 5.4135556, def jddgfijfedjaeebfaeadbegejfegjdjc(I):
  smallest_obj = min(objects(I, True, True, True), key=len)
  O = paint(cover(I, smallest_obj), recolor(1, smallest_obj))
  line = box(smallest_obj)
  if height(smallest_obj) <= width(smallest_obj):
    line = box(hmirror(smallest_obj))
  O = paint(O, recolor(3, line))
  O = paint(O, recolor(2, frozenset({tuple(map(lambda x: x // 2, (sum(i for i, j in line), sum(j for i, j in line))))})))
  return O
 
0.04296296296296296, 5.552541, def dfjhfajdbbeaefacaceicfbghaafddaa(I):
  smallest_obj = min(objects(I, True, True, True), key=size)
  O = paint(cover(I, smallest_obj), recolor(1, smallest_obj))
  center_smallest = centerofmass(smallest_obj)
  line_start = add(center_smallest, (1 if height(smallest_obj) > width(smallest_obj) else 0, -1 if height(smallest_obj) > width(smallest_obj) else 0))
  line_end = add(center_smallest, (-1 if height(smallest_obj) > width(smallest_obj) else 0, 1 if height(smallest_obj) > width(smallest_obj) else 0))
  O = paint(O, recolor(3, connect(line_start, line_end)))
  replace_pos = add(center_smallest, (1, 0)) if height(smallest_obj) > width(smallest_obj) else add(center_smallest, (0, 1))
  O = paint(O, recolor(2, frozenset({replace_pos})))
  return O
 
0.04, 8.718747, def gdedeeadheeeefgfiabfbbhddadbaceh(I):
  # Identify objects
  obj2 = toobject(ofcolor(I, TWO), I)
  obj37 = toobject(ofcolor(I, THREE) | ofcolor(I, SEVEN), I)

  # Calculate offset - align top-left of '2' with bottom-right of '3'/'7'
  offset = subtract(lrcorner(obj37), lrcorner(obj2))
  
  # Move and recolor '2' object
  moved_obj2 = shift(recolor(mostcolor(obj37), obj2), offset)
  
  # Paint the moved object
  O = paint(cover(I, obj2), moved_obj2)
  return O
 
0.05629629629629629, 14.066663, def cfecccabcbcgeecdacdabeabbfjjebea(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)
  c23 = centerofmass(obj23)
  c7 = centerofmass(obj7)

  if hmatching(obj23, obj7):
    obj23 = recolor(3, shift(obj23, (1,0))) | recolor(3, shift(obj23, (-1,0))) | recolor(2, obj23)
    offset = subtract((c7[0], c23[1]), c23) 
  else:
    offset = subtract((c23[0], c7[1]), c23)

  O = paint(cover(I, obj23), shift(obj23, offset))
  return O
 
0.062222222222222213, 12.846303, def cfiadjecfibcedfiaeccabdebddcihcc(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  if hmatching(obj23, obj7):
    obj23 = {(3, (i+1, j)) for v, (i, j) in obj23} | {(3, (i-1, j)) for v, (i, j) in obj23} | {(2, (i, j)) for v, (i, j) in obj23}
    O = paint(cover(I, obj23), shift(obj23, (0, centerofmass(obj7)[1] - centerofmass(obj23)[1])))
  else:
    O = paint(cover(I, obj23), shift(obj23, (centerofmass(obj7)[0] - centerofmass(obj23)[0], 0)))
  return O
 
0.045925925925925926, 7.833514, def afhaeabhcgfceicbijeeiffhbdjafebb(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  if hmatching(obj23, obj7):
    obj23 = toobject({(3, add((1, 0), idx)) for v, idx in obj23} | {(3, add((-1, 0), idx)) for v, idx in obj23} | {(2, idx) for v, idx in obj23}, I)
    O = paint(cover(I, obj23), shift(obj23, (0, centerofmass(obj7)[1] - centerofmass(obj23)[1])))
  else:
    O = paint(cover(I, obj23), shift(obj23,  subtract(centerofmass(obj7), centerofmass(obj23))))
  return O
 
0.04, 10.467141, def cbeaaicaacfheebbiafgajehejfgcecf(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    center_i = (uppermost(obj) + lowermost(obj)) // 2
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    center_val = index(I, (center_i, center_j))
    O = cover(O, obj)
    O = paint(O, {(center_val, (center_i, center_j))})
  return O
 
0.038518518518518514, 9.566325, def bbjiaciacdigedbbafbfafffihbejfec(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    indices = toindices(obj)
    center_index = argmin(indices, lambda x: abs(x[0] - len(I) // 2) + abs(x[1] - len(I[0]) // 2))
    center_val = index(I, center_index)
    O = cover(O, obj)
    O = paint(O, {(center_val, center_index)})
  return O
 
0.047407407407407405, 14.928795, def jbdaejffficfefacjfdaefjbjbbeejcc(I):
  s = min(objects(I, True, True, True), key=size)  # Find smallest object
  O = paint(canvas(0, shape(I)), recolor(1, s))  # Create blank canvas, paint object
  c = centerofmass(s) # Find object center
  v_line = frozenset((c[0] + i, c[1]) for i in range(-height(s) // 2 - 1, height(s) // 2 + 2))  # Generate vertical line indices
  O = paint(O, recolor(3, v_line))  # Draw the vertical line
  two_pos = (c[0] + height(s) // 2 + 1, c[1]) # Calculate '2' position
  O = paint(O, recolor(2, frozenset({two_pos})))  # Place the '2' 
  return O
 
0.04, 6.04469, def gdcgcfddaejiefggicgficaffdedhbie(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)
  center_obj23 = centerofmass(obj23)
  center_obj7 = centerofmass(obj7)

  # Determine vertical alignment
  if center_obj23[0] < center_obj7[0]:
    target_center = (center_obj7[0], center_obj23[1])
  else:
    target_center = (center_obj23[0], center_obj7[1])

  offset = subtract(target_center, center_obj23)
  obj23_shifted = shift(obj23, offset)

  # Replace 3s in (2,3) object
  new_obj23 = set()
  for v, (i, j) in obj23_shifted:
    if v == 3:
      new_obj23.add((index(I, (i, j)), (i, j)))
    else:
      new_obj23.add((v, (i, j)))

  O = paint(cover(I, obj23), frozenset(new_obj23))
  return O
 
0.037037037037037035, 6.051821, def ajcjfagbccedediejhiadfcdfbedbijd(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  # Determine vertical alignment and replacement value
  if uppermost(obj23) < uppermost(obj7):
    target_row = uppermost(obj7)
    replacement = 7
  else:
    target_row = uppermost(obj23)
    replacement = index(I, (centerofmass(obj23)[0], centerofmass(obj23)[1])) 

  # Shift (2,3) object
  offset = (target_row - uppermost(obj23), 0)
  obj23_shifted = shift(obj23, offset)

  # Replace values in (2,3) object
  new_obj23 = recolor(replacement, toindices(obj23_shifted))

  O = paint(cover(I, obj23), new_obj23)
  return O
 
0.047407407407407405, 10.846846, def jfdhfjbhgecaejeajdijdjbgibicfddb(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)
  center_obj23 = centerofmass(obj23)
  center_obj7 = centerofmass(obj7)

  # Calculate offset based on center of mass difference
  offset = subtract((center_obj7[0], center_obj23[1]), center_obj23)
  obj23_shifted = shift(obj23, offset)

  # Replace values in (2,3) object
  new_obj23 = frozenset(((index(I, (i,j)) if index(I, (i,j)) != 0 else 7), (i,j)) for _, (i, j) in obj23_shifted) 

  O = paint(cover(I, obj23), new_obj23)
  return O
 
0.037037037037037035, 20.537144, def adghihfhbhadeeacbabfbedffabccchi(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)
  h_diff = centerofmass(obj7)[0] - centerofmass(obj23)[0]

  # Shift (2,3) object
  obj23_shifted = shift(obj23, (h_diff, 0))

  # Replace values in (2,3) object
  new_obj23 = frozenset(
      ((7 if v == 3 and h_diff > 0 else index(I, (i, j))), (i, j))
      for v, (i, j) in obj23_shifted
  )

  O = paint(cover(I, obj23), new_obj23)
  return O
 
0.05037037037037037, 10.602431, def dddbeijjadheeaebjbididdhijfacagi(I):
  obj23 = toobject(ofcolor(I, 2) | ofcolor(I, 3), I)
  obj7 = toobject(ofcolor(I, 7), I)

  # Align upper edges and determine replacement value
  offset = (uppermost(obj7) - uppermost(obj23), 0)
  replacement = 7 if offset[0] > 0 else index(I, centerofmass(obj23)) 

  # Shift and modify (2,3) object
  obj23_shifted = shift(obj23, offset)
  new_obj23 = recolor(replacement, toindices(obj23_shifted))

  O = paint(cover(I, obj23), new_obj23)
  return O
 
0.06962962962962964, 20.782625, def daidhgacbaefehddadhhhajbdidibheg(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO and size(o) > 1)  # Extract the target object
  if obj:
    center_j = leftmost(obj) + width(obj) // 2  # Find the object's center column
    O = paint(I, {(ONE, (uppermost(obj) + height(obj) // 2, center_j))})  # Replace center of object with '1'
    O = fill(O, SEVEN, {(i, center_j) for i in range(uppermost(obj), lowermost(obj) + 1)}) # Draw vertical '7' line
  else:
    obj = extract(objects(I, T, T, T), lambda o: color(o) == SEVEN) # Find the '7' line
    center_j = leftmost(obj) + width(obj) // 2  # Find the line's center column
    O = I
  box_indices = frozenset((i, j) for i in range(uppermost(obj) - 2, uppermost(obj) + 1) 
                                for j in range(center_j - 1, center_j + 2)) # Calculate box indices
  O = fill(O, THREE, box_indices)  # Draw the box with '3's
  center_top = (uppermost(box_indices) - 1, center_j)  # Find the center-top index
  O = paint(O, {(TWO, center_top)})  # Replace with '2'
  return O
 
0.04296296296296296, 7.266515, def bdcfdbdecdhgefedjihbfcebaehhehib(I):
  obj = extract(objects(I, F, T, T), lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  center_j = leftmost(obj) + width(obj) // 2
  O = fill(I, THREE, box(shift({(0, 0)}, (uppermost(obj) - 1, center_j - 1))))
  O = paint(O, {(TWO, (uppermost(obj) - 2, center_j))})
  O = paint(O, {(ONE, (uppermost(obj) + height(obj) // 2, center_j))})
  O = fill(O, SEVEN, {(i, center_j) for i in range(uppermost(obj), lowermost(obj) + 1)})
  return O
 
0.047407407407407405, 8.679559, def dcdbhaededbeecdabfbfbegbegdbahfc(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO and size(o) > 1)
    if not obj:
      obj = extract(objects(I, T, T, T), lambda o: color(o) == SEVEN)
    c = centerofmass(obj)
    O = fill(I, THREE, box(shift({(0,0)}, (c[0] - 2, c[1] - 1))))
    O = paint(O, {(TWO, (c[0] - 3, c[1]))})
    O = paint(O, {(ONE, (c[0], c[1]))})
    O = fill(O, SEVEN, {(c[0] - 1, c[1]), (c[0], c[1]), (c[0] + 1, c[1])})
    return O
 
0.047407407407407405, 10.744689, def icdacbdfdbdhebbjajbacdecedgbdhja(I):
  objs = objects(I, F, T, T)
  obj = extract(objs, lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  if height(obj) == 1:
    O = paint(I, {(ONE, centerofmass(obj))})
  else:
    O = paint(I, {(ONE, (uppermost(obj) + height(obj) // 2, leftmost(obj) + width(obj) // 2))})
  O = fill(O, SEVEN, connect(centerofmass(obj), add(centerofmass(obj), (2, 0))))
  O = fill(O, THREE, box(shift({(0, 0)}, subtract(centerofmass(obj), (1, 1)))))
  O = paint(O, {(TWO, subtract(centerofmass(obj), (2, 0)))})
  return O
 
0.044444444444444446, 18.003857, def beddfdadbaedecaeaebbejcjcagcaeij(I):
  objs = objects(I, True, True, True)
  smallest = min(objs, key=size)
  O = paint(canvas(0, shape(I)), recolor(1, smallest))  # Blank canvas, recolor object
  center_col = leftmost(smallest) + width(smallest) // 2
  O = paint(O, recolor(3, connect((uppermost(smallest)-1, center_col), 
                                 (lowermost(smallest)+1, center_col))))  # Line using 'connect'
  O = paint(O, recolor(2, frozenset({(uppermost(smallest) + height(smallest) // 2 + 1, center_col)}))) # '2' placement
  return O
 
0.038518518518518514, 12.944976, def ejfdacebbfjfeajcjhjaedfgdcchdcjg(I):
  obj = extract(objects(I, T, F, T), lambda obj: color(obj) == SEVEN)
  O = paint(cover(I, obj), shift(recolor(ONE, {(TWO, center(ofcolor(I, TWO)))}), gravitate(ofcolor(I, TWO), obj)))
  return O
 
0.04, 6.986966, def daibbihiceibeedbbbecefjeibcebffc(I):
  target_loc = center(ofcolor(I, SEVEN))
  two_loc = center(ofcolor(I, TWO))
  direction = sign(subtract(target_loc, two_loc))
  new_two_loc = add(two_loc, gravitate({(0, two_loc)}, {(0, target_loc)}))
  O = paint(fill(I, ONE, {new_two_loc}), shift(recolor(SEVEN, ofcolor(I, SEVEN)), gravitate(ofcolor(I, SEVEN), {new_two_loc})))
  return O
 
0.04148148148148148, 5.657429, def ehcjaaiddhbeecdjbadhbbdafdbbadjd(I):
  target = extract(objects(I, True, False, True), lambda o: color(o) == SEVEN)
  two_center = center(ofcolor(I, TWO))
  moved_target = shift(target, gravitate(toindices(target), {two_center}))
  new_two_loc = extract(toindices(moved_target), lambda cell: manhattan({cell}, {two_center}) == 1)
  O = paint(fill(I, ONE, {new_two_loc}), moved_target)
  return O
 
0.04888888888888889, 8.533975, def agfcfahbecbgefjfabjfhbchjacaacfa(I):
  obj = extract(objects(I, F, T, T), lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  center_j = leftmost(obj) + width(obj) // 2
  top_most = uppermost(obj)
  if height(obj) == 1: 
    O = fill(I, THREE, box(shift({(0, 0)}, (top_most, center_j - 2))))
    O = paint(O, {(TWO, (top_most, center_j - 1))})
    O = paint(O, {(ONE, (top_most, center_j))})
    O = fill(O, SEVEN, {(top_most, j) for j in range(center_j - 1, center_j + 2)})
    O = paint(O, {(THREE, (top_most, center_j + 1))}) 
  else:
    O = fill(I, THREE, box(shift({(0, 0)}, (top_most - 2, center_j))))
    O = paint(O, {(TWO, (top_most - 1, center_j))})
    O = paint(O, {(ONE, (top_most, center_j))})
    O = fill(O, SEVEN, {(i, center_j) for i in range(top_most, top_most + 3)})
    O = paint(O, {(THREE, (top_most + 1, center_j))})
  return O
 
0.045925925925925926, 8.387705, def figbbefgefaeebdejfeeaajbdcdfeiaf(I):
  obj = extract(objects(I, F, T, T), lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  center_j = leftmost(obj) + width(obj) // 2
  top_most = uppermost(obj)
  O = I
  if height(obj) == 1: 
    for dj in range(-2, 2):
        O = fill(O, branch(dj == 0, ONE, branch(abs(dj) == 1, SEVEN, THREE)), {(top_most, center_j + dj)})
  else:
    for di in range(-2, 2):
        O = fill(O, branch(di == 0, ONE, branch(abs(di) == 1, SEVEN, THREE)), {(top_most + di, center_j)})
  return O
 
0.047407407407407405, 8.12536, def aaaedcgjcahjedffjjeegjcjfdgbcbce(I):
  obj = extract(objects(I, F, T, T), lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  center_j = leftmost(obj) + width(obj) // 2
  top_most = uppermost(obj)
  O = I
  if height(obj) == 1:
      O = paint(O, {(ONE, (top_most, center_j))})
      O = paint(O, {(SEVEN, (top_most, center_j - 1))})
      O = paint(O, {(SEVEN, (top_most, center_j + 1))})
      O = paint(O, {(THREE, (top_most, center_j - 2))})
      O = paint(O, {(THREE, (top_most, center_j + 2))})
  else:
      O = paint(O, {(ONE, (top_most, center_j))})
      O = paint(O, {(SEVEN, (top_most - 1, center_j))})
      O = paint(O, {(SEVEN, (top_most + 1, center_j))})
      O = paint(O, {(THREE, (top_most - 2, center_j))})
      O = paint(O, {(THREE, (top_most + 2, center_j))})
  return O
 
0.038518518518518514, 6.9624143, def hhhgeabhfdegehcfiaefgddgbhjgbebb(I):
  obj = extract(objects(I, F, T, T), lambda o: colorcount(o, SEVEN) > 1 or (size(o) > 1 and color(o) != ZERO))
  c = center(obj)
  O = I
  if height(obj) == 1:
    O = fill(O, THREE, {(c[0], c[1] - 2), (c[0], c[1] + 2)})
    O = fill(O, SEVEN, {(c[0], c[1] - 1), (c[0], c[1] + 1)})
  else:
    O = fill(O, THREE, {(c[0] - 2, c[1]), (c[0] + 2, c[1])})
    O = fill(O, SEVEN, {(c[0] - 1, c[1]), (c[0] + 1, c[1])})
  O = paint(O, {(ONE, c)})
  return O
 
0.056296296296296296, 13.952717, def abdcjddfeafaedebicejcicfceafaccj(I):
  seven = extract(objects(I, T, F, T), lambda obj: color(obj) == SEVEN)
  two_pos = center(ofcolor(I, TWO))
  direction = gravitate(toindices(seven), {two_pos})
  new_seven = shift(seven, direction)
  adjacent_cell = extract(toindices(new_seven), lambda cell: manhattan({cell}, {two_pos}) == 1)
  two_three_obj = toobject(ofcolor(I, TWO) | ofcolor(I, THREE), I)
  new_two_three_obj = shift(two_three_obj, (direction[0] + 1, direction[1]))
  O = paint(paint(fill(I, ONE, {adjacent_cell}), new_seven), new_two_three_obj) 
  return O
 
0.04148148148148148, 8.499155, def cbfdidjacfceebeabeijfifahhibahcb(I):
  seven_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == 7)
  two_center = center(ofcolor(I, 2))
  v_distance = two_center[0] - center(seven_obj)[0]
  new_seven = shift(seven_obj, (v_distance + (1 if v_distance >= 0 else -1), 0))
  overlap = intersection(toindices(new_seven), neighbors(two_center))
  O = paint(fill(I, 1, overlap), new_seven)
  return O
 
0.045925925925925926, 7.2303805, def hcgegibfcbbcegcfiefbhbccchfdhahe(I):
    sevens = toindices(extract(objects(I, T, F, T), lambda o: color(o) == 7))
    two_pos = center(ofcolor(I, 2))
    move_dir = gravitate(sevens, {two_pos})
    new_sevens = shift(sevens, move_dir)
    new_two_pos = extract(neighbors(two_pos), lambda p: p in new_sevens)
    combined = ofcolor(I, 2) | ofcolor(I, 3)
    new_combined = shift(combined, add(move_dir, (sign(move_dir[0]), 0)))
    O = paint(paint(fill(I, 1, {new_two_pos}), recolor(7, new_sevens)), recolor(3, new_combined))
    return O
 
0.11555555555555556, 27.631968, def fcbdecdbfdaaeebebficgagefcacgcdf(I):
  objs = objects(I, T, T, T)  # Identify all non-background objects
  O = I
  for obj in objs:
    O = paint(O, recolor(ONE, obj))  # Recolor the object to 1
    center_x = leftmost(obj) + width(obj) // 2  # Find the x-coordinate of the center
    top_y = uppermost(obj) - 1  # Find the y-coordinate above the object
    line = connect((top_y, center_x), (0, center_x))  # Draw a line upwards
    O = fill(O, THREE, line)  # Fill the line with 3s
    O = paint(O, {(TWO, (top_y, center_x))})  # Replace the top cell with 2
  return O
 
0.11555555555555556, 24.713356, def afajgcdefdjgebgdjghfeagfeaefbahd(I):
  O = I
  for obj in objects(I, T, T, T):
    O = fill(O, ONE, toindices(obj))  # Recolor the object to 1
    top_center = (uppermost(obj) - 1, leftmost(obj) + width(obj) // 2)
    O = paint(O, {(TWO, top_center)})  # Draw the '2' at the top center
    for i in range(top_center[0], -1, -1):  # Draw the vertical line of '3's
      O = paint(O, {(THREE, (i, top_center[1]))}) 
  return O
 
0.11703703703703705, 29.365633, def efchccfabccheiegaadfcgbahfjfeceb(I):
  O = paint(I, recolor(ONE, merge(objects(I, T, T, T))))
  for obj in objects(I, T, T, T):
    x = leftmost(obj) + width(obj) // 2
    for y in range(uppermost(obj) - 1, -1, -1):
      O = paint(O, {(THREE if y != 0 else TWO, (y, x))})
  return O
 
0.10666666666666667, 25.81392, def hdejgaggjecaebdcadibhdfafefcfccj(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    O = paint(O, recolor(ONE, obj))
    start = (uppermost(obj) - 1, leftmost(obj) + width(obj) // 2)
    O = paint(O, {(TWO, start)})
    current = decrement(start)
    while current[0] >= 0:
      O = paint(O, {(THREE, current)})
      current = decrement(current)
  return O
 
0.04148148148148148, 22.410648, def dadgihdefdbheciebdceecdeiheadcja(I):
  objs = objects(I, True, True, True)
  smallest_obj = min(objs, key=lambda obj: len(obj)) # Find smallest object
  O = paint(canvas(0, shape(I)), recolor(1, toindices(smallest_obj))) # Create a blank canvas and paint the smallest object with '1's
  center_i, center_j = centerofmass(smallest_obj) # Get center of mass coordinates
  vline_indices = connect((center_i - height(smallest_obj) // 2, center_j),
                           (center_i + height(smallest_obj) // 2, center_j))  # Create vertical line indices using connect
  O = paint(O, recolor(3, frozenset({(uppermost(vline_indices), center_j),
                                   (lowermost(vline_indices), center_j)}))) # Paint endpoints with 3s 
  O = paint(O, recolor(2, frozenset({(center_i + 1, center_j)})))  # Place the 2 marker
  return O
 
0.044444444444444446, 7.257169, def dbaabeadiacfeeadbhdcfiideefjdegb(I):
  smallest_obj = min(objects(I, True, True, True), key=size) # Find smallest object
  O = paint(cover(I, smallest_obj), recolor(1, smallest_obj)) # Replace with 1s
  c = centerofmass(smallest_obj) # Get center of mass
  v_line = frozenset((i, c[1]) for i in range(c[0] - height(smallest_obj) // 2,
                                              c[0] + height(smallest_obj) // 2 + 1)) # Create vertical line indices
  O = paint(O, recolor(3, {tuple(ulcorner(v_line)), tuple(lrcorner(v_line))})) # Paint endpoints with 3s 
  O = paint(O, recolor(2, frozenset({(c[0] + 1, c[1])}))) # Place the 2 marker
  return O
 
0.04296296296296296, 8.4354725, def efddacdgbbfbeefbiccbgafgdjaebcba(I):
  # Find target and moving object indices
  target_indices = ofcolor(I, THREE) | ofcolor(I, SEVEN)
  moving_indices = ofcolor(I, TWO)

  # Calculate the move vector to align centers of both objects
  move_vector = subtract(center(target_indices), center(moving_indices))

  # Move the moving object
  moved_indices = shift(moving_indices, move_vector)

  # Recolor and paint the moved object
  O = paint(fill(I, ZERO, moving_indices), recolor(mostcolor(toobject(target_indices, I)), moved_indices))
  return O
 
0.056296296296296296, 13.821488, def dfigbfacehdeeegcaiiaeabbgddigbef(I):
    obj7 = toobject(ofcolor(I, SEVEN), I)
    obj23 = toobject(ofcolor(I, TWO) | ofcolor(I, THREE), I)
    center2 = center(ofcolor(I, TWO))
    v = gravitate(toindices(obj7), {center2})
    obj7_new = shift(obj7, v)
    obj23_new = shift(recolor(THREE, obj23), add(v, position(toindices(obj7_new), {center2})))
    adj_index = extract(toindices(obj7_new), lambda x: manhattan({x}, {center2}) == 1)
    O = paint(paint(fill(I, ONE, {adj_index}), obj7_new), obj23_new)
    return O
 
0.04148148148148148, 5.8114386, def ccjjjbaacbeaebifaceiaabecfafebfc(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO)  # Identify non-background object
  O = paint(fill(I, THREE, delta(obj)), obj)  # Create a '3' frame around the object
  top_row = {(uppermost(obj), j) for j in range(leftmost(obj), rightmost(obj) + 1)}
  center_top = extract(top_row, lambda loc: index(I, loc) == color(obj)) # Find center of top row
  O = paint(O, {(TWO, add(center_top, (-1, 0)))})  # Place '2' above center
  O = paint(O, recolor(SEVEN, obj))  # Change object color to '7'
  O = paint(O, {(ONE, center_top)})  # Change center top to '1'
  return O
 
0.04, 5.784216, def iedefadaabdhedddahffedagdgaddhbf(I):
  obj = next(o for o in objects(I, T, T, T) if color(o) != ZERO)  # Find non-background object
  O = paint(I, recolor(THREE,  backdrop(obj) - toindices(obj)))  # Paint '3's around object
  center_j = (leftmost(obj) + rightmost(obj)) // 2
  for i in range(uppermost(obj) - 1, lowermost(obj) + 1):  # Iterate over object's bounding box
    if index(I, (i, center_j)) == color(obj):
      O = paint(O, {(TWO, (i - 1, center_j))})  # Place '2' if it's above object center
      O = paint(O, {(ONE, (i, center_j))})  # Change object center to '1'
    if (i, center_j) in toindices(obj):
      O = paint(O, {(SEVEN, (i, center_j))})  # Change other object cells to '7'
  return O
 
0.04, 5.699829, def bbdfbdddcjdcecfcifdfgacjdejiabbh(I):
  non_bg_objs = (o for o in objects(I, T, T, T) if color(o) != ZERO)
  obj = next(non_bg_objs)
  O = paint(I, recolor(THREE, mapply(delta, objects(I, T, T, T))))  # Frame all objects with '3's
  top_center_j = (leftmost(obj) + rightmost(obj)) // 2
  for i in range(uppermost(obj), lowermost(obj) + 1):
    if index(O, (i, top_center_j)) == color(obj):
      O = paint(O, {(TWO, (i - 1, top_center_j))})  # Place '2'
      O = paint(O, {(ONE, (i, top_center_j))})      # Replace with '1'
  O = paint(O, recolor(SEVEN, obj))                   # Recolor the object to '7'
  return O
 
0.06814814814814814, 6.479482, def edjefgacdgchefabaagbiehaecfadacf(I):
  obj = extract(objects(I, F, F, F), lambda o: any(c in {TWO, THREE, SEVEN} for c in palette(o)))
  mirrored_obj = hmirror(obj) if color(obj) in {TWO, SEVEN} else vmirror(obj)
  offset = (ZERO, width(I) - width(obj) - leftmost(obj)) if color(obj) in {TWO, SEVEN} else (height(I) - height(obj) - uppermost(obj), ZERO)
  O = paint(I, shift(mirrored_obj, offset))
  final_obj = first(objects(O, F, F, F))
  return fill(O, ONE, (centerofmass(final_obj),))
 
0.04296296296296296, 6.1774697, def hbicecdcaahbehhfaebcbheieibhgedh(I):
  # Find indices of the moving object (value 2)
  mover_indices = ofcolor(I, TWO)  

  # Find indices of the target object (combination of 3 and 7)
  target_indices = ofcolor(I, THREE) | ofcolor(I, SEVEN)

  # Calculate the move vector to align bottom-right corner of mover with top-left corner of target
  move_vector = subtract(ulcorner(target_indices), lrcorner(mover_indices))
  move_vector = add(move_vector, (-1, 1)) # Adjust for adjacency 

  # Move and recolor the object
  moved_object = recolor(mostcolor(target_indices), shift(mover_indices, move_vector))

  # Paint onto the input grid 
  O = paint(I, moved_object)  
  return O
 
0.04148148148148148, 5.7077837, def eebbdbjahjfbegdgbfdjcegdjbdiddgj(I):
  # Find indices of objects
  mover_indices = ofcolor(I, TWO)
  target_indices = ofcolor(I, THREE) | ofcolor(I, SEVEN)

  # Calculate center of mass for both objects
  mover_center = centerofmass(mover_indices)
  target_center = centerofmass(target_indices)

  # Calculate move vector based on center of mass differences
  move_vector = (sign(target_center[0] - mover_center[0]), sign(target_center[1] - mover_center[1]))

  # Move the object iteratively until adjacent
  moved_indices = mover_indices
  while not adjacent(moved_indices, target_indices):
    moved_indices = shift(moved_indices, move_vector)

  # Recolor and paint the moved object
  recolored_obj = recolor(mostcolor(target_indices), moved_indices)
  O = paint(I, recolored_obj)
  return O 
 
0.04148148148148148, 5.2349815, def ijjaefcfcigdeebgidbciefecefgfdih(I):
  sevens = extract(objects(I, True, False, True), lambda o: color(o) == SEVEN)
  two_center = center(ofcolor(I, TWO))
  moved_sevens = shift(sevens, gravitate(toindices(sevens), {two_center}))
  adjacent_cell = extract(toindices(moved_sevens), lambda cell: manhattan({cell}, {two_center}) == 1)
  two_three_obj = toobject(ofcolor(I, TWO) | ofcolor(I, THREE), I)
  new_two_three_obj = shift(recolor(THREE, two_three_obj), gravitate(toindices(two_three_obj), {adjacent_cell}))
  O = paint(paint(fill(I, ONE, {adjacent_cell}), moved_sevens), new_two_three_obj)
  return O
 
0.045925925925925926, 7.407119, def eedjfcaicfheefbfadejheeceajeghaa(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find the non-background object
  line_start = (4 - uppermost(obj), leftmost(obj) + width(obj) // 2) # Calculate the starting point of the line
  line_indices = connect(line_start, (line_start[0] + 2, line_start[1])) # Calculate the indices for the line
  O = fill(I, THREE, line_indices) # Draw the line with 3s
  O = paint(O, {(TWO, (line_start[0] + 1, line_start[1]))}) # Replace the bottom element of the line with 2
  O = paint(O, recolor(SEVEN, obj)) # Recolor the object to 7
  return O
 
0.044444444444444446, 6.0239787, def dcgabcahdeebehfhjgbffhcefabddedj(I):
  obj = argmax(objects(I, T, T, T), len) # Find the largest object (assuming it's the non-background one)
  line_length = max(0, 4 - uppermost(obj)) # Calculate line length based on object's position
  line_start = (3, leftmost(obj) + width(obj) // 2) # Calculate the starting point of the line
  O = I
  for i in range(line_length): # Draw the line iteratively
    O = paint(O, {(THREE, (line_start[0] - i, line_start[1]))})
  O = paint(O, {(TWO, (line_start[0] - line_length + 1, line_start[1]))}) # Add 2 at the bottom
  O = paint(O, recolor(SEVEN, obj)) # Recolor the object to 7
  return O
 
0.04296296296296296, 5.769767, def fhhffieehafaehbdjjifcacfggieaaaa(I):
  obj_indices = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find the non-background object indices
  O = paint(I, recolor(SEVEN, obj_indices)) # Recolor the object to 7
  top_index = (uppermost(obj_indices), leftmost(obj_indices) + width(obj_indices) // 2)
  for i in range(1, 4 - top_index[0]):
    O = paint(O, {(THREE, (top_index[0] + i, top_index[1]))}) # Draw the line with 3s downwards
  O = paint(O, {(TWO, (top_index[0] + max(0, 3 - top_index[0]), top_index[1]))}) # Place 2 at the end of the line
  return O
 
0.04148148148148148, 5.289754, def hjifdabgidbbebfaigfdjdfacacaijah(I):
  obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO) # Find the non-background object
  O = paint(I, recolor(SEVEN, obj)) # Recolor the object to 7
  line_y = 4 - uppermost(obj) 
  line_x = leftmost(obj) + width(obj) // 2
  O = paint(O, {(THREE, (line_y - 1, line_x))}) if line_y > 0 else O # Conditionally draw 3s based on line length
  O = paint(O, {(THREE, (line_y - 2, line_x))}) if line_y > 1 else O
  O = paint(O, {(TWO, (line_y - 3, line_x))}) if line_y > 2 else O # Place 2 if the line is long enough
  return O
 
0.04296296296296296, 5.8324337, def gcejfjbdbeddeahfbcffjggbchddfdjd(I):
  # Find the target object (not the background)
  target_object = argmin(sfilter(objects(I, True, True, True), lambda obj: len(obj) > 1), lambda obj: len(obj))
  # Get the upper-left corner of the target object
  corner = ulcorner(target_object)
  # Calculate the line length (maximum of height and width)
  line_length = max(height(target_object), width(target_object))
  # Create the vertical line indices
  line_indices = frozenset((corner[0] + i, corner[1]) for i in range(line_length))
  # Apply the transformation
  O = paint(paint(I, recolor(ONE, target_object)), recolor(TWO, line_indices))
  return O
 
0.04148148148148148, 5.3627853, def dcagbjddcbfaeehijacdafdcfjddgffb(I):
  # Find the object with the least common color (assuming it's unique and not background)
  target_object = argmin(objects(I, True, True, True), lambda obj: colorcount(I, color(obj)))
  # Calculate the line's ending point
  end_point = (uppermost(target_object) + max(height(target_object), width(target_object)) - 1, leftmost(target_object))
  # Create the line indices
  line_indices = connect(ulcorner(target_object), end_point)
  # Apply the transformation
  O = paint(paint(I, recolor(ONE, target_object)), recolor(TWO, line_indices))
  return O
 
0.04, 5.3447676, def beaaccfbajbdehcebffbdjdcedfcgbch(I):
  # Find the target object based on minimum color count (assuming uniqueness)
  target_object = argmin(objects(I, True, True, True), len)
  # Get upper-left corner and calculate offset for the line
  start_point = ulcorner(target_object)
  offset = max(height(target_object), width(target_object)) - 1
  # Generate line indices using shift operation
  line_indices = shift(frozenset({(0, 0)}), (start_point[0], start_point[1])) | shift(frozenset({(0, 0)}), (start_point[0] + offset, start_point[1]))
  # Apply the transformation
  O = paint(paint(I, recolor(ONE, target_object)), recolor(TWO, line_indices))
  return O
 
0.04296296296296296, 5.581303, def jbjfbcdffegeeeajbghcibdbbiafabgj(I):
  # Directly find the object with a specific color (assuming it's unique)
  target_object = extract(objects(I, True, True, True), lambda obj: color(obj) == SEVEN)
  # Calculate the line indices based on object's top-left corner and dimensions
  line_indices = frozenset(((i, leftmost(target_object)) for i in range(uppermost(target_object), uppermost(target_object) + max(height(target_object), width(target_object)))))
  # Apply the transformation
  O = paint(paint(I, recolor(ONE, target_object)), recolor(TWO, line_indices)) 
  return O
 
0.04148148148148148, 5.622286, def agdcccadgdaaedahjcahacbiachhebee(I):
  # Find the object with a unique color (different from background)
  target_object = extract(objects(I, True, True, True), lambda obj: colorcount(I, color(obj)) == len(obj))
  # Create a vertical line object based on the target object's dimensions
  line_object = frozenset(((TWO, (uppermost(target_object) + i, leftmost(target_object))) for i in range(max(height(target_object), width(target_object)))))
  # Apply the transformation
  O = paint(paint(I, recolor(ONE, target_object)), line_object)
  return O
 
0.037037037037037035, 5.3959866, def dcffihdfbcfgedbdbjgfffdchhheaidf(I):
  two_three_indices = toindices(toobject(ofcolor(I, 2) | ofcolor(I, 3), I))
  seven_indices = toindices(toobject(ofcolor(I, 7), I))
  move_vector = gravitate(seven_indices, two_three_indices)
  new_seven = shift(seven_indices, move_vector)
  adjacent_index = first(intersection(neighbors(center(two_three_indices)), new_seven))
  O = paint(paint(I, recolor(SEVEN, new_seven)), recolor(ONE, {adjacent_index}))
  return O
 
0.038518518518518514, 5.6913233, def egebhgacebhaedabiagaiahaeaddfaib(I):
  obj = argmax(objects(I, T, T, T), size) # Find the largest object
  original_pos = ulcorner(obj) 
  
  normalized = normalize(obj)
  h = height(normalized)

  top_row = recolor(THREE, sizefilter(normalized, 1))
  second_row = recolor(TWO, sizefilter(shift(normalized, (1, 0)), 1))
  rest = recolor(SEVEN, difference(normalized, top_row | second_row)) 

  recolored = top_row | second_row | rest
  positioned = shift(recolored, add(original_pos, (1, 0))) if (original_pos[0] < 13 and h < 14 - original_pos[0]) else shift(recolored, original_pos)
  O = paint(I, positioned)
  return O 
 
0.05037037037037037, 6.477571, def beeddbabbgijefejiibeeghdagcagaea(I):
    obj = argmax(objects(I, T, T, T), size)
    h = height(obj)
    new_obj = frozenset()
    for v, (i, j) in obj:
        new_i = i - uppermost(obj)
        new_v = 3 if new_i == 0 else (2 if new_i == 1 else 7)
        new_obj = insert((new_v, (i - uppermost(obj) + (1 if h < 14 - uppermost(obj) else 0), j)), new_obj)
    O = paint(I, new_obj)
    return O
 
0.044444444444444446, 5.207563, def jdedchacfbaeecifjaabafijiiehhcih(I):
    obj = argmax(objects(I, T, T, T), size)
    offset = (1, 0) if uppermost(obj) < 13 - height(obj) else (0, 0)
    O = paint(I, recolor(SEVEN, shift(normalize(obj), add(ulcorner(obj), offset))))
    O = paint(O, recolor(THREE, shift(sizefilter(normalize(obj), 1), add(ulcorner(obj), offset))))
    O = paint(O, recolor(TWO, shift(sizefilter(normalize(obj), 2), add(ulcorner(obj), offset))))
    return O
 
0.05037037037037037, 7.2588034, def cbbiahfdadaeebffabaggeedcjbdfjad(I):
    obj = argmax(objects(I, T, T, T), size)
    h = height(obj)
    new_obj = {(v if i > 1 else (3 if i == 0 else 2), (i + uppermost(obj) + (1 if h < 14 - uppermost(obj) else 0), j)) for v, (i, j) in normalize(obj)}
    O = paint(I, new_obj)
    return O
 
0.044444444444444446, 6.081858, def bgcjifgjcdfgedfcieejecedbdcfahic(I):
  obj = first(sfilter(objects(I, F, F, F), lambda o: any(c in {TWO, THREE, SEVEN} for c in palette(o))))
  direction = DOWN if THREE in palette(obj) else RIGHT
  mirrored_obj = branch(equality(direction, DOWN), vmirror(obj), hmirror(obj))
  combined_obj = toobject(combine(toindices(obj), toindices(shift(mirrored_obj, multiply(direction, shape(obj))))), I)
  return fill(paint(I, combined_obj), ONE, (centerofmass(combined_obj),))
 
0.044444444444444446, 6.564727, def gjgijiddfbdcebibaebdedfffbbabffe(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO)
    center_x = leftmost(obj) + width(obj) // 2
    top_y = uppermost(obj)
    O = I
    for i in range(1, 3):
        O = paint(O, {(THREE, (top_y - i, center_x))})
    O = paint(O, {(TWO, (top_y - 2, center_x))})
    return O
 
0.05185185185185185, 9.037779, def efhgebaeaiaceijabdifgijjegjcjfeh(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO)
    center_x = leftmost(obj) + width(obj) // 2
    top_y = uppermost(obj)
    bottom_y = lowermost(obj)
    O = paint(I, {(TWO, (bottom_y + 2, center_x)), (THREE, (bottom_y + 1, center_x)), (THREE, (bottom_y, center_x))})  
    if colorcount(obj, SEVEN) > 0:
        top_y = uppermost(sfilter(obj, lambda c: c[0] == SEVEN))
        O = paint(O, {(ONE, (top_y - 1, center_x)), (SEVEN, (top_y - 2, center_x))})
    else:
        O = paint(O, {(TWO, (top_y - 1, center_x)), (THREE, (top_y - 2, center_x))}) 
    return O
 
0.05185185185185185, 7.091013, def fcchhcdgihcfebegiafbgebfjfabecge(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO)
    O = I
    if colorcount(obj, SEVEN) > 0:
        obj_7 = sfilter(obj, lambda c: c[0] == SEVEN)
        O = paint(O, recolor(ONE, {(centerofmass(obj_7)[0], uppermost(obj_7) - 1)})) 
        O = paint(O, recolor(SEVEN, {(centerofmass(obj_7)[0], uppermost(obj_7) - 2)}))
    else:
        O = paint(O, {(TWO, (uppermost(obj) - 1, leftmost(obj) + width(obj) // 2))})
        O = paint(O, {(THREE, (uppermost(obj) - 2, leftmost(obj) + width(obj) // 2))})
    O = paint(O, {(TWO, (lowermost(obj) + 2, leftmost(obj) + width(obj) // 2))})
    O = paint(O, {(THREE, (lowermost(obj) + 1, leftmost(obj) + width(obj) // 2))})
    O = paint(O, {(THREE, (lowermost(obj), leftmost(obj) + width(obj) // 2))})
    return O
 
0.044444444444444446, 6.850445, def gacabghcfgfdebfabfababcheggegecf(I):
    obj = extract(objects(I, T, T, T), lambda o: color(o) != ZERO)
    color_obj = color(obj)
    line_color = SEVEN if color_obj == SEVEN else THREE
    center_x = leftmost(obj) + width(obj) // 2
    top_y = uppermost(obj) if color_obj != SEVEN else uppermost(sfilter(obj, lambda c: c[0] == SEVEN))
    O = I
    for i in range(1, 3):
        O = paint(O, {(THREE, (top_y - i, center_x))})
    O = paint(O, {(TWO, (top_y - 2, center_x)), (line_color, (top_y - 1, center_x))})
    return O
 
