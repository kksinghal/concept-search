3.0, 3.7708418, def ffdagdhidbbceacejgddfeebeahgddae(I):
    # Find the bottom-most non-zero row
    row_index = max([i for i, row in enumerate(I) if any(v != 0 for v in row)])
    
    # Identify non-zero columns in that row
    non_zero_cols = [j for j, v in enumerate(I[row_index]) if v != 0]

    # Modify the grid
    new_grid = list(list(row) for row in I) 
    for col in non_zero_cols:
        if row_index + 2 < len(I):
            new_grid[row_index + 2][col] = 4
    
    return tuple(tuple(row) for row in new_grid)
 
4.666666666666667, 8.791772, def dgbbebdjbabbeafdaaeahbcbccdjahfj(I):
  target_row = max(range(len(I)), key=lambda i: any(I[i]))
  target_cols = {j for j, v in enumerate(I[target_row]) if v}
  return tuple(
      tuple(
          4 if i == target_row + 2 and j in target_cols else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
4.0, 5.711288, def fdafbfbfeebbeecgjffbedcgceicihbb(I):
  return tuple(
      tuple(
          4 if any(I[i - 2]) and v and i > 1 else v 
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
2.6666666666666665, 4.8988247, def bibhhbbedbdfehdeaacffeagjdbbdbai(I):
    h = height(I)
    w = width(I)
    border = frozenset((h-1, j) for j in range(0, w, 2))
    O = fill(I, FOUR, border)
    return O
 
3.3333333333333335, 2.6694515, def dfjhjbgabfhhededjfhgacaacbdicbda(I):
    line = hfrontier((height(I)-1, 0))
    pattern = (ZERO, FOUR)
    painted_line = papply(lambda ij, v: (v, ij), line, pattern * (width(I) // 2 + 1))
    O = paint(I, painted_line)
    return O
 
5.666666666666667, 14.840881, def gcdjcfjdgiegeadhaajbdddcdbbcijaf(I):
    # Find all indices of non-background colors
    non_bg_indices = merge([ofcolor(I, c) for c in palette(I) - {mostcolor(I)}])
    # Find the bounding box
    bounding_box = backdrop(non_bg_indices)
    # Identify the line below the bounding box
    line_below = frozenset((i + 1, j) for i, j in bounding_box if i == lowermost(bounding_box))
    # Fill the line with 4
    O = fill(I, 4, line_below)
    return O
 
5.333333333333333, 13.642966, def cdjcdedddicdeefaijbiadbfeddcbegd(I):
    # Calculate bounding box
    objs = fgpartition(I)
    box_indices = merge(apply(backdrop, objs))
    # Find the lower boundary
    lower_boundary = maximum(apply(lowermost, objs))
    # Create horizontal line patch
    line = frozenset({(lower_boundary + 1, j) for i, j in box_indices if i == lower_boundary})
    # Fill the line with value '4'
    O = fill(I, 4, line)
    return O
 
3.6666666666666665, 4.886914, def ffbhiccafggaeiceaedfbbcafhecfccf(I):
  # Find the bottom-most non-zero row
  non_zero_rows = [i for i, row in enumerate(I) if any(row)]
  target_row_index = max(non_zero_rows) if non_zero_rows else 0
  
  # Calculate the positions for the '4's
  center = len(I[0]) // 2
  offset = len(non_zero_rows) - 1  
  left_pos = center - 1 - offset
  right_pos = center + offset 

  # Modify the target row
  modified_row = list(I[target_row_index])
  modified_row[left_pos] = 4
  modified_row[right_pos] = 4
  I = tuple(tuple(modified_row) if i == target_row_index else row for i, row in enumerate(I))
  
  return I
 
10.0, 10.710814, def daadfgcfbdejedbgbbjfbbfggjajffjc(I):
  # Find the bottom-most non-zero row index
  target_row_index = max((i for i, r in enumerate(I) if any(x != 0 for x in r)), default=0)

  # Create a new row with '4's at specific positions
  new_row = tuple(4 if j in (len(I[0])//2 - 1 - target_row_index, len(I[0])//2 + target_row_index) else 0 for j in range(len(I[0])))

  # Concatenate the grid with the new row
  O = I[:target_row_index + 1] + (new_row,) + I[target_row_index + 1:]
  return O
 
3.3333333333333335, 4.6929836, def edbdddcebefdebhbbieeffabefhejidb(I):
    target_row_index = next((len(I) - i - 1 for i, row in enumerate(reversed(I)) if any(row)), 0)
    modified_row = list(I[target_row_index])
    center = len(modified_row) // 2
    offset = target_row_index
    modified_row[center - offset - 1] = 4
    modified_row[center + offset] = 4
    return I[:target_row_index] + (tuple(modified_row),) + I[target_row_index + 1:] 
 
2.6666666666666665, 4.0407953, def dbfcedcecgjiejeeigibjadibgfadhfj(I):
    # Find the smallest object (excluding background)
  obj = argmin(objects(I, T, F, T), size)
  
  # Get object color and bottom row index
  color = first(obj)[0]
  bottom_row = lowermost(obj) + 2 
  
  # Calculate left and right flanking positions
  left_pos = (bottom_row, leftmost(obj) - 1)
  right_pos = (bottom_row, rightmost(obj) + 1)
  
  # Fill positions with the new color (4)
  O = fill(I, 4, {left_pos})
  O = fill(O, 4, {right_pos})
  return O
 
3.0, 3.7708418, def baeacecddfideihbjdhicadffagcfhdd(I):
  # Find the rightmost object
  obj = argmax(objects(I, T, F, T), rightmost)
  
  # Get the bottom-center position below the object
  center_j = centerofmass(obj)[1]
  bottom_i = lowermost(obj) + 2
  
  # Calculate positions flanking the center horizontally
  left_pos = (bottom_i, center_j - 1)
  right_pos = (bottom_i, center_j + 1)
  
  # Fill positions with the new color (4)
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
3.3333333333333335, 2.5164773, def hbdhibegaadbecididfefgdcdjfiaafj(I):
  # Find the object with the least common color
  target_color = leastcolor(I)
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  
  # Calculate flanking positions relative to the object's width
  left_pos = (len(I) - 1, leftmost(obj) - 1)
  right_pos = (len(I) - 1, leftmost(obj) + width(obj))
  
  # Fill positions with the new color (4)
  O = fill(I, 4, {left_pos, right_pos})
  return O 
 
3.0, 2.473915, def dhcbcedbafdjeacejjbgabdhdjcbcbca(I):
  # Find the object farthest from the top-left corner
  corner = (0, 0)
  obj = argmax(objects(I, T, F, T), lambda obj: manhattan(obj, {corner}))
  
  # Calculate horizontal positions flanking the object
  left_pos = (len(I) - 1, leftmost(obj) - 1)
  right_pos = (len(I) - 1, rightmost(obj) + 1)
  
  # Fill positions with the new color (4)
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
5.333333333333333, 10.267762, def egeiabjeeebiechiibaagdahcbdbcfif(I):
  obj = argmax(objects(I, T, F, T), lowermost) # Find the bottom-most object
  offset = (2, 0) # Define the offset to move down
  shifted_obj = shift(toindices(obj), offset) # Shift the object's indices down
  O = underfill(I, 4, shifted_obj) # Fill with '4' at the shifted indices
  return O
 
2.3333333333333335, 4.87796, def aihffbfdeebfedgiabddeeaeedhcgfci(I):
    for i in range(len(I) - 1, 1, -1):  
        if any(v != 0 for v in I[i]):  
            target_row = i
            break
    else:
        target_row = -1 
    new_grid = list(list(row) for row in I)
    if 0 <= target_row + 2 < len(I):
        for j, val in enumerate(I[target_row]):
            if val != 0:
                new_grid[target_row + 2][j] = 4
    return tuple(tuple(row) for row in new_grid)
 
3.3333333333333335, 6.2402263, def dadccdiechbcefefjgaiaffjdfhfddhd(I):
  h = height(I)
  w = width(I)
  target_indices = frozenset()
  for j in range(w):
    if any(I[i][j] != 0 for i in range(h - 1)):
      target_indices = insert((h - 1, j), target_indices)
  O = fill(I, 4, target_indices)
  return O 
 
1.6666666666666667, 6.321297, def agaebedhjcaaeaibidejgfiagfdbifea(I):
  # Get indices of all non-zero values
  non_zero_indices = toindices(asobject(I))
  # Get bounding box coordinates
  lower = lowermost(non_zero_indices)
  left = leftmost(non_zero_indices)
  right = rightmost(non_zero_indices)
  # Create and fill horizontal line
  O = fill(I, 4, frozenset({(lower + 1, j) for j in range(left, right + 1)}))
  return O
 
1.6666666666666667, 6.321297, def hcbcbcehjacdebjgbbjbaeabbhabhidf(I):
  w = width(I)
  line_width = w if even(w) else w - 1
  offset = 0 if even(w) else 1
  bottom_line = {(FOUR, (height(I), j)) for j in range(offset, line_width + offset)}
  return paint(I, toobject(bottom_line, canvas(ZERO, (height(I) + 1, width(I)))))
 
16.666666666666668, 34.462337, def fbibecfaddaiefbeijdeajejdiejbacb(I):
  return fill(canvas(ZERO, (height(I) + 1, width(I))), FOUR,  
              {(height(I), j) for j in range(width(I) - (width(I) % 2))})
 
8.333333333333334, 10.700292, def becjbffcdccieibiaeeadeifccdhecfd(I):
  w = width(I)
  line = ((FOUR,) * (w - (w % 2)) + (ZERO,) * (w % 2))
  return vconcat(I, (line,)) 
 
1.6666666666666667, 6.321297, def ghebhddjajbjebaeiciidjeifcjbfhia(I):
  # Find all objects excluding the background
  objs = objects(I, T, F, T)
  
  # Initialize an empty set for positions to fill
  fill_positions = set()
  
  # Iterate over each object
  for obj in objs:
    # Find the leftmost and rightmost column indices of the object
    leftmost_j = leftmost(obj)
    rightmost_j = rightmost(obj)
    
    # Calculate the positions to fill
    fill_positions.add((len(I), leftmost_j - 1))
    fill_positions.add((len(I), rightmost_j + 1))
  
  # Fill the calculated positions with the new color (4)
  O = fill(I, 4, frozenset(fill_positions))
  return O
 
10.0, 46.669983, def dabefbgijacgebeaacgdeafadehdaife(I):
  # Directly create the output grid with background color
  O = canvas(mostcolor(I), shape(I))
  
  # Iterate over each row of the input grid
  for i, row in enumerate(I):
    # Find unique colors in the row excluding the background
    unique_colors = set(row) - {mostcolor(I)}
    
    # Iterate over each unique color in the row
    for color in unique_colors:
      # Find the leftmost and rightmost occurrence of the color in the row
      first_j = row.index(color)
      last_j = len(row) - 1 - row[::-1].index(color)
      
      # Fill the positions in the output grid
      O = fill(O, 4, {(len(I), first_j - 1), (len(I), last_j + 1)})
  return O
 
1.6666666666666667, 6.321297, def aidafagfjghbeiabjjdhiaaefbjaaaaj(I):
  h = height(I) - 1
  target_indices = frozenset((h, j) for j in range(width(I)) if all(I[i][j] != 0 for i in range(h)))
  O = fill(I, 4, target_indices)
  return O
 
7.0, 18.2099, def deifiefbjcddeiffbfcacjhgeaijeeid(I):
  # Iterate through rows to find the lowermost row containing a non-zero element
  for row_index, row in enumerate(I):
    if any(v != 0 for v in row):
      lower_row = row_index
  # Use the previously found information to create the line
  line = frozenset({(lower_row + 1, j) for j in range(len(I[0]))})
  # Fill the input grid with '4's at the indices specified by 'line'
  O = fill(I, 4, line)
  return O
 
8.333333333333334, 10.050698, def fibhjchggiacehacbfhiddbcbbjecccb(I):
  w = width(I)
  center = w // 2
  offset = 1 - (w % 2)  # offset is 0 for even width, 1 for odd
  bottom_row = [(ZERO if abs(j - center) <= offset else FOUR) for j in range(w)]
  return vconcat(I, (tuple(bottom_row),))
 
8.333333333333334, 10.322237, def ffbhceaaibjbehcbibejhececaiebcdd(I):
  w = width(I)
  line = canvas(ZERO, (1, w)) 
  mid = w // 2
  line = paint(line, {(FOUR, (0, mid - 1 - (w % 2))), (FOUR, (0, mid + (w % 2)))})
  return vconcat(I, line)
 
16.666666666666668, 41.963047, def ecdfaieddadaefdajddcaccfccacdeei(I):
  h = height(I)
  w = width(I)
  return fill(canvas(ZERO, (h + 1, w)), FOUR, {(h, w // 2 - 1 - (w % 2)), (h, w // 2 + (w % 2))})
 
3.6666666666666665, 3.0913467, def bchecgfaegffededaffjfifchaacbgce(I):
  target_color = leastcolor(I)
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  left_pos = (len(I) - 1, leftmost(obj)) 
  right_pos = (len(I) - 1, rightmost(obj))
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
0.6666666666666666, 2.1920764, def eecegcahabgaedbaadebebbeebbaebgi(I):
  target_color = leastcolor(I)
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  flanking_distance = width(obj) // 2 
  left_pos = (len(I) - 1, leftmost(obj) + flanking_distance)
  right_pos = (len(I) - 1, rightmost(obj) - flanking_distance)
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
4.0, 3.0439246, def eebgbbiadfgdefgcjhiceeabaccafhdc(I):
  target_color = leastcolor(I)
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  left_edge = leftmost(obj)
  right_edge = rightmost(obj)
  fill_indices = {(len(I) - 1, j) for j in range(len(I[0])) if j < left_edge or j > right_edge}
  O = fill(I, 4, fill_indices)
  return O
 
3.0, 2.4866, def acccjefggihdeeedjdjjbfdgjjiediec(I):
  return fill(I, 
              4, 
              frozenset({(height(I)-1, width(I)//2 - 1), (height(I)-1, width(I)//2 + (width(I)%2))}))
 
6.333333333333333, 8.93301, def eaigaejaieeceejdibhbagdfadeeaibe(I):
  # Extract all objects from the input grid
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  
  # Find the topmost object by comparing their uppermost row indices
  top_object = argmin(objs, compfunc=uppermost) 
  
  # Mirror the top object about the horizontal axis
  mirrored_indices =  hmirror(toindices(top_object))
  
  # Calculate the required vertical shift for the mirrored object
  v_shift = height(I) - 1 - lowermost(mirrored_indices)
  
  # Shift the mirrored indices and recolor them to 4
  new_obj = recolor(FOUR, shift(mirrored_indices, (v_shift, 0)))
  
  # Paint the new object onto the input grid
  O = paint(I, new_obj) 
  return O
 
18.0, 8.43595, def bbddhbdfecdbeaccjbcdjgghdcbaegja(I):
  # Get a set of all colors present in the input grid
  colors = palette(I) 
  
  # Find the color of the topmost object (assuming it's the least frequent color)
  top_color = leastcommon(list(I[0])) 

  # Find all cells of the topmost object
  top_cells = ofcolor(I, top_color)
  
  # Get the height of the input grid
  grid_height = height(I) 
  
  # Mirror the top cells horizontally
  mirrored_cells = {(i,j) for (i,j) in top_cells}
  
  # Create a new set of cells for the bottom object
  bottom_cells = set()
  for i, j in mirrored_cells:
    bottom_cells.add((grid_height - i - 1, j))
  
  # Paint the bottom cells with color '4' onto the input grid
  O = fill(I, FOUR, bottom_cells)
  return O
 
8.333333333333334, 10.834932, def dfidhebgfhcgecgejbcedcifbhhcbaca(I):
  w = width(I)
  newline = canvas(ZERO, (1, w))
  offset = halve(w) if even(w) else decrement(halve(w)) 
  newline = fill(newline, FOUR, {(ZERO, offset), (ZERO, offset + (w - 1) % 2)})
  return vconcat(I, newline)
 
8.333333333333334, 10.809132, def cjcdadbfhafbehdfacifbgadefichcfb(I):
    w = width(I)
    newline = [(FOUR if j == w // 2 - (1 - w % 2) // 2 or j == w // 2 + (1 - w % 2) // 2 else ZERO) for j in range(w)]
    return vconcat(I, (tuple(newline),))
 
8.333333333333334, 9.878952, def ajcjdcbbcigbechebaaeeeeciaciiddd(I):
  w = width(I)
  line = canvas(ZERO, (1, w))
  mid = halve(w)
  if even(w):
    indices = {(ZERO, mid - ONE), (ZERO, mid)}
  else:
    indices = {(ZERO, mid), (ZERO, mid + ONE)}
  line = fill(line, FOUR, indices)
  return vconcat(I, line)
 
8.333333333333334, 9.991308, def gfadabbdfcdeeebfjaajdcfcadagbbeb(I):
    w = width(I)
    if even(w):
        newRow = tuple(FOUR if i == w // 2 or i == w // 2 - 1 else ZERO for i in range(w))
    else:
        newRow = tuple(FOUR if i == w // 2 - 1 or i == w // 2 + 1 else ZERO for i in range(w))
    return tuple(list(I) + [newRow]) 
 
3.6666666666666665, 2.752535, def cbfadadibeieebbcjdbaeafaiccfejdc(I):
  target_color = leastcolor(I)
  bottom_row = I[-1]
  left_pos = (len(I) - 1, next((j for j, v in enumerate(bottom_row) if v == target_color), 0))
  right_pos = (len(I) - 1, len(bottom_row) - next((j for j, v in enumerate(bottom_row[::-1]) if v == target_color), 0) - 1)
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
7.0, 11.675909, def bfhafibcffbgeedfbebfhhcheiafcdcf(I):
  bottom_row_objs = objects(I, False, False, True)
  target_obj = argmax(bottom_row_objs, lowermost)
  target_indices = toindices(target_obj)
  shifted_indices = shift(target_indices, (2, 0))
  O = underfill(I, 4, shifted_indices)
  return O
 
2.3333333333333335, 1.8079519, def eadaaifiegeaecihbgfgjcacbbdbgcja(I):
  """
  Paints two cells with value 4 on the bottom-most row, 
  symmetrically around the horizontal center.
  """
  bottom_row_indices = toindices(hfrontier((height(I) - 1, 0)))
  center_index = width(I) // 2  
  left_cell = (height(I) - 1, center_index - 1 + (width(I) % 2)) 
  right_cell = (height(I) - 1, center_index)
  cells_to_paint = frozenset({left_cell, right_cell}) & bottom_row_indices
  return fill(I, 4, cells_to_paint) 
 
9.0, 9.215912, def jgbfedeebjhgefjbificifjigiidbcba(I):
  bottom_row = max((i for i, row in enumerate(I) if any(x != 0 for x in row)), default=0)
  new_row = tuple(4 if j in (len(I[0]) // 2 - 1, len(I[0]) // 2 + 2) else 0 for j in range(len(I[0])))
  return I[:bottom_row + 1] + (new_row,) + I[bottom_row + 1:]
 
8.666666666666666, 9.593711, def djgjdejjhdgeefchiddbbgbabaaihbfi(I):
  for i in range(len(I) - 1, -1, -1):
    if any(I[i]):
      return I[:i+1] + (tuple(4 if j in (2,5) else 0 for j in range(len(I[0]))),) + I[i+1:]
  return I + (tuple(4 if j in (2,5) else 0 for j in range(len(I[0]))),)
 
8.333333333333334, 10.554239, def dafaffffcaceegiajfccfabfcebbeffe(I):
  return vconcat(I, (tuple(4 if j == len(I[0]) // 2 - 1 or j == len(I[0]) // 2 + 2 else 0 for j in range(len(I[0]))),))
 
3.6666666666666665, 2.8687963, def ibfhjgajeaddecagaebejhccffaecdbe(I):
  obj = argmax(
      objects(I, True, False, True),
      lambda obj: colorcount(obj, leastcolor(I)) * (lowermost(obj) == len(I) - 1)
  )
  left_pos = (len(I) - 1, leftmost(obj))
  right_pos = (len(I) - 1, rightmost(obj))
  return fill(I, 4, {left_pos, right_pos})
 
3.0, 3.3404562, def addadbjdjdjaecgejjcbchafjejajbib(I):
  """
  Calculates the center offset for placing '4' values on the bottom row.
  """
  center_offset = width(I) // 2 - (1 - width(I) % 2) 
  left_cell = (height(I) - 1, center_offset)
  right_cell = (height(I) - 1, center_offset + 1)
  return paint(I, frozenset({(4, left_cell), (4, right_cell)}))
 
2.3333333333333335, 3.116736, def haaceagfbcceeecjaegbhfbecceiiebf(I):
  """
  Iterates through the bottom row to find and paint the correct cells.
  """
  grid = I
  w = width(grid)
  for j in range(w // 2):
      if grid[height(grid)-1][w//2 -1 - j] != 4:
        grid = paint(grid, {(4, (height(grid) - 1, w // 2 - 1 - j))})
        grid = paint(grid, {(4, (height(grid) - 1, w // 2 + j))})
        break
  return grid
 
3.6666666666666665, 2.652855, def aajidghddcaceccibhaeieafhddbiede(I):
  target_color = leastcolor(I)
  target_obj = extract(objects(I, True, False, False), matcher(color, target_color))
  left_border = leftmost(target_obj) - 1
  right_border = rightmost(target_obj) + 1
  left_pos = (len(I) - 1, max(0, left_border))
  right_pos = (len(I) - 1, min(len(I[0]) - 1, right_border))
  return fill(I, 4, {left_pos, right_pos}) 
 
3.3333333333333335, 2.809351, def idejjdbhbeaeefidijhfbfafhagiaefb(I):
  min_count, min_color = 1000, 0  
  for color in palette(I):
    count = colorcount(I, color)
    if count < min_count:
      min_count = count
      min_color = color
  target_indices = ofcolor(I, min_color)
  left_pos = (len(I) - 1, leftmost(target_indices) - 1)
  right_pos = (len(I) - 1, rightmost(target_indices) + 1)
  return fill(I, 4, {left_pos, right_pos})
 
3.0, 3.1737313, def ccgdidbifgaeecedbbfcaeiiacdddfff(I):
  """
  Calculates the left and right positions for '4' 
  based on the width of the input grid.
  """
  w = width(I)
  left_pos = (height(I) - 1, w // 2 - 1 - (w // 2) % 2)
  right_pos = (height(I) - 1, w // 2 + (w // 2) % 2)
  return paint(I, {(4, left_pos), (4, right_pos)})
 
3.3333333333333335, 3.142375, def cgdhdahbaafceceaadfdfjhfefafadjb(I):
  """
  Iterates through the bottom row and places '4's 
  if the cell is empty.
  """
  output = [list(row) for row in I]
  w = width(I)
  center = w // 2
  placed = 0
  for j in range(w):
    if output[-1][j] == 0 and placed < 2 - (w % 2):
      output[-1][j] = 4
      placed += 1
      if placed == 1 and w % 2 == 0:
        output[-1][center] = 4
  return tuple(tuple(row) for row in output)
 
4.333333333333333, 4.804806, def bdgcgjdegagheajgafaabfbbcfdehgib(I):
  """
  Uses recursion to place '4's symmetrically on the bottom row.
  """
  def place_four(grid, pos, count):
    if count == 0 or pos < 0:
      return grid
    if grid[-1][pos] == 0:
      grid[-1][pos] = 4
      grid[-1][-pos - 1] = 4
      return place_four(grid, pos - 1, count - 2) 
    else:
      return place_four(grid, pos - 1, count)

  output = [list(row) for row in I]
  w = width(I)
  start_pos = w // 2 - 1
  return tuple(tuple(row) for row in place_four(output, start_pos, 2 - w % 2))
 
3.0, 2.2588062, def cdbibcdefdibedhgbcijabacihbbfcie(I):
    # Find non-zero indices in the bottom row
    bottom_indices = sfilter(asindices(I[-1:]), lambda ij: index(I, ij) != 0)
    if bottom_indices:
      # Find the bounding box of non-zero indices
      patch = backdrop(bottom_indices)
      # Get leftmost and rightmost column indices
      left_j = leftmost(patch)
      right_j = rightmost(patch)
      # Create mirrored points
      mirrored_obj = frozenset({(FOUR, (height(I) - 1, left_j)), (FOUR, (height(I) - 1, right_j))})
      # Paint mirrored points onto the grid
      O = paint(I, mirrored_obj)
    else:
      O = I  # Return the input if the bottom row is all zeros
    return O
 
8.333333333333334, 11.003496, def dabgcecbfbdaebdjahheedeeaafiifae(I):
  # Find the bottom-most non-zero row index
  bottom_row = max([i for i, row in enumerate(I) if any(v != 0 for v in row)], default=0)

  # Calculate the offset for '4' placement
  offset = bottom_row 

  # Create a new bottom row with '4's at calculated positions
  new_row = tuple(4 if j == len(I[0]) // 2 - 1 - offset or j == len(I[0]) // 2 + offset else 0 for j in range(len(I[0])))
  
  # Append the new row to the original grid
  O = I + (new_row,)  
  return O
 
1.6666666666666667, 6.321297, def bcbhcaghicghejgbjeeiddjcfcdjiffg(I):
  def add_fours_below(bottom_row):
    non_zero_cols = [j for j, v in enumerate(I[bottom_row]) if v != 0]
    new_grid = [list(row) for row in I] 
    for col in non_zero_cols:
      if bottom_row + 2 < len(I):
        new_grid[bottom_row + 2][col] = 4
    return tuple(tuple(row) for row in new_grid)
  bottom_row = lowermost(asobject(I))
  return add_fours_below(bottom_row)
 
2.0, 3.0998163, def efbideibieeeehdaiaghfeeaecafihda(I):
  """
  Leverages hfrontier and symmetrical indexing for '4' placement.
  """
  bottom_row = hfrontier((height(I) - 1, 0))
  midpoint = width(I) // 2
  offset = 1 - width(I) % 2 
  return fill(I, 4, {(height(I) - 1, midpoint - 1 + offset), (height(I) - 1, midpoint)})
 
8.333333333333334, 9.706381, def fbagdhgjajebehefjcfbhhfhbifieajh(I):
  # Determine the center column of the grid
  center_j = width(I) // 2

  # Create a new row filled with zeros
  new_row = canvas(ZERO, (ONE, width(I))) 

  # Place the '4's symmetrically around the center column
  new_row = fill(new_row, FOUR, {(ZERO, center_j - ONE), (ZERO, center_j)})

  # Concatenate the new row to the bottom of the input grid
  O = vconcat(I, new_row)
  return O
 
8.333333333333334, 10.023783, def afcfbabddcaeeaehacgaceiebcbbdfci(I):
    # Calculate the middle column index
    mid = width(I) // 2

    # Create a new row of zeros
    new_row = tuple(ZERO for _ in range(width(I)))

    # Place the '4's symmetrically on the new row
    new_row = new_row[:mid-1] + (FOUR,) + new_row[mid:mid+1] + (FOUR,) + new_row[mid+2:]

    # Vertically concatenate the input grid with the new row
    O = vconcat(I, (new_row,))
    return O
 
2.0, 6.016012, def eaecdbjhffdiebefahacfjgadcajecbf(I):
  """
  Uses papply to paint a pattern on the bottom row based on grid width.
  """
  w = width(I)
  padding = (w - 2 + (w % 2)) // 2
  bottom_row_indices = hfrontier((height(I) - 1, 0))
  if even(w):
    pattern = tuple([0] * padding + [4, 4] + [0] * padding)
  else:
    pattern = tuple([0] * padding + [4, 0, 4] + [0] * padding)
  painted_row = papply(lambda ij, v: (v, ij), bottom_row_indices, pattern)
  return paint(I, painted_row)
 
2.6666666666666665, 3.127629, def cbaeddaacibceghiadaicjbcicadgbfg(I):
  """
  Uses modulo operation to select cells for painting on the bottom row.
  """
  h, w = shape(I)
  output = I
  for j in range(w):
    if (j - (w // 2 - 1)) % (w - 1) in {0, (w - 2) % (w - 1)}:
      output = paint(output, {(4, (h - 1, j))})
  return output
 
8.333333333333334, 13.443549, def ceeedbdaebdcecfgjcbacfjjdfdbdfec(I):
  h = height(I)
  w = width(I)
  new_row = [0] * w
  for j in range(w):
    if I[h-1][j] != 0:
      new_row[j] = 4
  O = vconcat(I, (tuple(new_row),))
  return O
 
6.0, 6.479824, def bfhfgfcicfhdeafjabaadbhebfejjgac(I):
    # Identify non-zero indices in the bottom row
    bottom_non_zero = sfilter(asindices(I[-1:]), lambda ij: index(I, ij) != 0)

    # If the bottom row has non-zero elements
    if bottom_non_zero:
        # Find the leftmost and rightmost column indices
        left_j = argmin(bottom_non_zero, lambda ij: ij[1])[1]
        right_j = argmax(bottom_non_zero, lambda ij: ij[1])[1]
        
        # Create a new grid with an extra row filled with zeros
        O = vconcat(I, (tuple([0] * width(I)),))
        
        # Paint the '4's at the mirrored positions
        O = paint(O, frozenset({(4, (height(I), left_j)), (4, (height(I), right_j))}))
    else:
        # If the bottom row is all zeros, return the input grid
        O = I
    return O
 
4.333333333333333, 6.4799647, def debdfhhaeijgegbaacjcfbbffjihagdd(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    bottom_row = lowermost(obj)
    left_col = leftmost(obj)
    right_col = rightmost(obj)
    if bottom_row + 2 < height(I):
      O = fill(O, 4, {(bottom_row + 2, left_col), (bottom_row + 2, right_col)})
  return O
 
12.666666666666666, 31.426172, def ffbbbicbhidjeddeiegeagaaeceifice(I):
  return paint(canvas(0, shape(I)), 
               merge(apply(lambda obj: recolor(4, shift(
                 {(lowermost(obj) + 2, leftmost(obj)), 
                  (lowermost(obj) + 2, rightmost(obj))},
                 (0,0))), objects(I, T, F, T))))
 
2.3333333333333335, 2.079031, def dajccaiicefbeajciajdjcfeaabfbbdd(I):
  """
  Identifies corner indices and fills '4's symmetrically.
  """
  h, w = height(I), width(I)
  left_corner = (h - 1, (w - 2 + (w % 2)) // 2)
  right_corner = (h - 1, left_corner[1] + 1 + (w % 2))
  return fill(fill(I, 4, {left_corner}), 4, {right_corner})
 
5.0, 7.076817, def jfbccfbbeaafeaedjibafcbjegadcdfc(I):
  """
  Uses hfrontier, center index, and conditional filling.
  """
  bottom_row = hfrontier((height(I) - 1, 0))
  center = width(I) // 2
  return fill(I, 4, sfilter(bottom_row, lambda x: x[1] != center or even(width(I))))
 
8.333333333333334, 10.317626, def fhjdcdbgabdgefaaiececegcdecbhgbb(I):
  non_zero_cols =  {j for j in range(width(I)) if any(row[j] != 0 for row in I)}
  left_center = min(non_zero_cols)
  right_center = max(non_zero_cols)
  new_row = [ZERO] * width(I)
  new_row[left_center] = FOUR
  new_row[right_center] = FOUR
  return I + (tuple(new_row),)
 
5.0, 8.472659, def fbgcjhjbjeciedeejcehaadfedaidaai(I):
  h = len(I)
  w = len(I[0])
  output = [list(row) for row in I] 
  for j in range(w):
    if I[-1][j] != mostcommon(I):
      if j > 0:
        output[-1][j - 1] = 4
      if j < w - 1:
        output[-1][j + 1] = 4
  return tuple(tuple(row) for row in output)
 
2.3333333333333335, 1.5873265, def hfdedeacbefeeigdbgdjcgbedefaacac(I):
  """
  Calculates the indices for the two '4's and fills them.
  """
  w = width(I)
  center = w // 2
  offset = 1 - (w % 2)  # Adjust offset for even/odd widths
  return fill(fill(I, 4, {(height(I) - 1, center - offset)}), 4, {(height(I) - 1, center + offset)})
 
2.3333333333333335, 3.116736, def bidbdiehhfajeeibjafdbidddcagidbc(I):
  """
  Overwrites the bottom row with '0's and then places '4's.
  """
  w = width(I)
  bottom_row = repeat(0, w)
  new_grid = vconcat(I[:-1], (bottom_row,))  # Replace bottom row
  return fill(fill(new_grid, 4, {(height(I) - 1, w // 2 - 1)}), 4, {(height(I) - 1, w // 2)})
 
3.3333333333333335, 2.5164773, def bfcbgicgaaecefgbbgificabechhcdda(I):
  # Find the most common non-zero color
  target_color = mostcommon(sfilter(totuple(palette(I)), lambda c: c != 0))
  # Extract the object with the target color
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  # Calculate flanking distance
  flanking_distance = width(obj) // 2 
  # Calculate marker positions
  left_pos = (height(I) - 1, leftmost(obj) - flanking_distance)
  right_pos = (height(I) - 1, rightmost(obj) + flanking_distance)
  # Place markers on the grid
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
3.6666666666666665, 2.8687963, def ebcjaajgfhfaeaaabfgcccdfdcgbjiba(I):
  # Extract all non-background objects
  objs = objects(I, T, F, T)
  # Find the largest object
  obj = argmax(objs, size) 
  # Calculate flanking distance
  flanking_distance = width(obj) // 2 - 1
  # Calculate marker positions
  left_pos = (height(I) - 1, leftmost(obj) + flanking_distance)
  right_pos = (height(I) - 1, rightmost(obj) - flanking_distance)
  # Place markers on the grid
  O = fill(I, 4, {left_pos, right_pos})
  return O
 
0.6666666666666666, 2.514951, def dgfjehgfiggeebeaibfiaabgcgaifaeb(I):
    # Extract all non-background objects and their widths
    objs_with_widths = [(obj, width(obj)) for obj in objects(I, T, F, T)]
    # Find the object with maximum width
    obj, max_width = argmax(objs_with_widths, lambda x: x[1])
    # Calculate flanking distance
    flanking_distance = max_width // 2
    # Calculate marker positions
    left_pos = (height(I) - 1, leftmost(obj) + flanking_distance)
    right_pos = (height(I) - 1, rightmost(obj) - flanking_distance)
    # Place markers on the grid
    O = fill(I, 4, {left_pos, right_pos})
    return O
 
3.6666666666666665, 2.4038312, def ddcgifbigfdjedeajhabcdcffgeaeeaj(I):
  w = width(I)
  return fill(I, 4, {(height(I)-1, w // 2 - 1 - (w % 2)), (height(I)-1, w // 2 + (w % 2))})
 
3.0, 2.3889112, def ebajggaeecbfeicejjecdfjffjcbbgad(I):
  offset = 1 if any(v != 0 for row in I for v in row[:-1]) else 0
  w = width(I)
  return fill(I, 4, {(height(I)-1, w // 2 - 1 - offset), (height(I)-1, w // 2 + offset)})
 
3.0, 2.138102, def dhfdecfadfajejcciaedcbhcbihieehb(I):
  obj = argmax(objects(I, T, F, T), lambda obj: len(obj)) if any(v != 0 for row in I for v in row) else {(0, 0)}
  com = centerofmass(obj)
  w = width(I)
  return fill(I, 4, {(height(I) - 1, com[1] - 1 - (w % 2)), (height(I) - 1, com[1] + (w % 2))})
 
3.6666666666666665, 3.0913467, def daefcggffefeehjciajedbgajgaedjbe(I):
  # Identify the least common color (excluding background)
  target_color = leastcolor(I)
  
  # Find the object with the target color
  obj = extract(objects(I, T, F, T), matcher(color, target_color))
  
  # Determine flanking positions on the bottom row
  left_flank = (len(I) - 1, leftmost(obj))
  right_flank = (len(I) - 1, rightmost(obj))
  
  # Fill flanking positions with the new color (4)
  return fill(I, 4, {left_flank, right_flank})
 
3.6666666666666665, 2.978991, def ddbgbaacecgdeagcagefcgdejfbbeefa(I):
  # Directly find indices of the least common color
  target_indices = ofcolor(I, leastcolor(I))
  
  # Calculate flanking positions based on indices
  left_flank = (len(I) - 1, leftmost(target_indices))
  right_flank = (len(I) - 1, rightmost(target_indices))
  
  # Fill flanking positions with the new color (4)
  return fill(I, 4, {left_flank, right_flank})
 
2.3333333333333335, 1.8079519, def bdfaffefceagecifbgbaajaaidgaaibf(I):
  w = width(I)
  offset =  ONE - (w % TWO)
  p =  (height(I) - ONE, w // TWO - offset)
  O = fill(I, FOUR, {p, (p[ZERO], w - p[ONE] - ONE)})
  return O
 
3.0, 1.7410241, def eeaifajjgjceehhgacabihcfacegidfi(I):
  w = width(I)
  mid = w // TWO
  O = I
  for j in range(mid):
    if j != mid - ONE - (w % TWO):
      O = fill(O, ZERO, {(height(I) - ONE, j), (height(I) - ONE, w - j - ONE)})
    else:
      O = fill(O, FOUR, {(height(I) - ONE, j), (height(I) - ONE, w - j - ONE)})
  return O
 
3.3333333333333335, 2.77935, def behgcagcdjjcebdjifbdajjbaeaacdbg(I):
  w = width(I)
  gap = w // TWO - (ONE - (w % TWO))
  indices = {(height(I) - ONE, i) for i in range(w) if abs(i - w // TWO) > gap // TWO}
  O = fill(I, FOUR, indices)
  return O
 
4.0, 3.0821354, def eehdebgbjajaefhdafffbiaieheicahc(I):
  objs = objects(I, T, F, T) 
  for obj in objs:
    flanking_distance = width(obj) // 2
    left_pos = (height(I) - 1, leftmost(obj) - flanking_distance)
    right_pos = (height(I) - 1, rightmost(obj) + flanking_distance)
    I = fill(I, 4, {left_pos, right_pos})
  return I
 
5.0, 4.583652, def gdedhbdgffdbebjebeeffjcgadicceha(I):
  marker_indices = set()
  for obj in objects(I, T, F, T):
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    flanking_distance = width(obj) // 2
    marker_indices.add((height(I) - 1, center_j - flanking_distance))
    marker_indices.add((height(I) - 1, center_j + flanking_distance))
  return fill(I, 4, marker_indices)
 
2.3333333333333335, 3.116736, def fehdececjebbeccajjbgcebacceficch(I):
  w = width(I)
  return fill(I, 4, {(height(I)-1, w // 2 - 1), (height(I)-1, w // 2)})
 
3.0, 2.5546708, def eacdgaccbjgdebadjajcgcdcfhjebbgb(I):
  positions = {(height(I)-1, width(I) // 2)}
  positions = {(height(I)-1, j - 1) for i, j in positions} | {(height(I)-1, j + 1) for i, j in positions}
  return fill(I, 4, positions)
 
3.6666666666666665, 2.8687963, def bcegebehbegdegacibddbecadajcfbfj(I):
  # Extract objects (excluding background)
  objs = objects(I, T, F, T)
  
  # Sort objects by their color count, ascending
  sorted_objs = order(objs, lambda obj: colorcount(I, color(obj)))
  
  # Extract the first object (least common color)
  target_obj = first(sorted_objs)
  
  # Calculate flanking positions on the bottom row
  left_flank = (len(I) - 1, leftmost(target_obj) + width(target_obj) // 2 - 1)
  right_flank = left_flank[0], left_flank[1] + 2

  # Fill flanking positions with the new color (4)
  return fill(I, 4, {left_flank, right_flank})
 
3.0, 2.5546708, def aecghafdgecieeiaaeehigfdfeebagbd(I):
  # Get all object indices, excluding the background
  obj_indices = merge(apply(toindices, objects(I, T, F, T)))
  
  # Calculate the minimum and maximum column indices
  min_col = leftmost(obj_indices)
  max_col = rightmost(obj_indices)
  
  # Calculate flanking positions on the bottom row
  left_flank = (len(I) - 1, min_col + (max_col - min_col) // 2 - 1)
  right_flank = (left_flank[0], left_flank[1] + 2)

  # Fill flanking positions with the new color (4)
  return fill(I, 4, {left_flank, right_flank})
 
3.0, 3.3404562, def aieiidgfijcjecdjigfcecbbaeafbfbd(I):
  w = width(I)
  offset = 1 if even(w) else 0
  left = (height(I) - 1, w // 2 - offset)
  right = (height(I) - 1, w // 2 + (1 - offset))
  O = fill(I, 4, {left, right})
  return O
 
2.0, 3.0998163, def dfdhabcbeafaeecabbicaedfcdebhiij(I):
  O = I
  w = width(I)
  for j in range(w):
    if j == w // 2 - (w % 2) or j == w // 2:
      O = fill(O, 4, {(height(I) - 1, j)})
  return O
 
1.6666666666666667, 6.321297, def abeaihhbjjjcefecahdhfdjdbbejgcbb(I):
  w = width(I)
  offset = 1 if even(w) else 0
  center_indices = {tojvec(w // 2 - offset), tojvec(w // 2 + (1 - offset))}
  bottom_row = hfrontier((height(I) - 1, 0))
  target_cells = intersection(center_indices, toindices(bottom_row))
  return fill(I, 4, target_cells)
 
2.0, 2.718376, def hahaaefadfifefbeaefaaiaedbjfabej(I):
  """
  Constructs the bottom row with '4's and concatenates it to the rest of the grid.
  """
  w = width(I)
  mid = w // 2
  bottom_row = [0] * (mid - 1) + [4] + [0] * (w - mid) 
  return vconcat(I[:-1], (tuple(bottom_row),))
 
3.3333333333333335, 2.390839, def adbcejchfjccefdgacacabadfcefgcbd(I):
  def place_markers(grid, obj):
    """Places markers for a single object."""
    flanking_distance = width(obj) // 2
    left_j = leftmost(obj) - flanking_distance
    right_j = rightmost(obj) + flanking_distance
    grid = fill(grid, 4, {(height(grid) - 1, left_j)})
    grid = fill(grid, 4, {(height(grid) - 1, right_j)})
    return grid

  # Apply marker placement for each object
  return last(apply(lambda obj: place_markers(I, obj), objects(I, T, F, T)))
 
1.6666666666666667, 2.8135889, def bbfagfehbdccefchbaeffefcdhcdajca(I):
  objs = objects(I, T, F, T)
  obj = argmax(objs, size) if objs else {(0, 0)}
  com = centerofmass(obj)
  w = width(I)
  offset = 1 if even(width(obj)) else 0
  return fill(I, 4, {(height(I)-1, com[1]-1-offset), (height(I)-1, com[1]+offset)})
 
3.6666666666666665, 2.5767488, def egcedbfdhaciehacjdgfhhjadifbcaaf(I):
  obj = argmax(objects(I, T, F, T), lambda obj: len(obj)) if any(v != 0 for r in I for v in r) else {(0, 0)}
  j = centerofmass(obj)[1]
  return fill(fill(I, 4, {(height(I) - 1, j - 1 - (width(obj) % 2))}), 4, {(height(I) - 1, j + (width(obj) % 2))})
 
2.3333333333333335, 2.8489237, def eifiddjcbeddehdebdcfjicahhjcfgfc(I):
  objs = [obj for obj in objects(I, T, F, T)]
  if objs:
    obj = max(objs, key=lambda x: len(x))
    j = center(toindices(obj))[1]
  else:
    j = 0
  offset = 1 if even(width(I)) else 0
  return fill(fill(I, 4, {(height(I)-1, j-1-offset)}), 4, {(height(I)-1, j+offset)})
 
3.6666666666666665, 2.889538, def aicecagjddededccbeijhcadajfhhfae(I):
  w = width(I)
  line = {(height(I) - 1, j) for j in range(w)}
  return paint(I, {(4, first(line)), (4, last(line))})
 
3.0, 3.24652, def abiddffdebbcebhibibiifddacfidfie(I):
  """
  Places two '4's symmetrically on the bottom row, 
  only on background cells, handling odd/even widths.
  """
  w = width(I)
  center_index = w // 2 
  offset = 1 - (w % 2) # Adjust offset for odd/even width
  left_cell = (height(I) - 1, center_index - offset)
  right_cell = (height(I) - 1, center_index + 1)
  return underfill(I, 4, {left_cell, right_cell})
 
1.6666666666666667, 3.0220895, def eahhfjaihaffebjbjfedfedaeaadggch(I):
  objs = objects(I, T, F, T)
  obj = argmax(objs, lambda obj: (len(obj), -leftmost(obj))) if objs else {(0, 0)} 
  j = centerofmass(obj)[1]
  return fill(I, 4, {(height(I) - 1, j - 1 + (width(obj) % 2)), (height(I) - 1, j + (width(obj) % 2))})
 
1.6666666666666667, 2.563648, def baefiefgacfgehebaabfdfbibbacbajb(I):
  if all(v == 0 for r in I for v in r):
    return fill(I, 4, {(height(I) - 1, width(I) // 2 - 1), (height(I) - 1, width(I) // 2)})
  else:
    obj = argmax(objects(I, T, F, T), lambda obj: len(obj))
    j = centerofmass(obj)[1]
    return fill(I, 4, {(height(I) - 1, j - 1 + (width(obj) % 2)), (height(I) - 1, j + (width(obj) % 2))})
 
11.333333333333334, 36.96192, def aiacaaefhbbceiefijihgbabejfbcjhb(I):
  # Define flanking positions based on grid width
  left_flank = (height(I) - 1, width(I) // 2 - 1)
  right_flank = (left_flank[0], left_flank[1] + 2)

  # Create a new grid with '4's at flanking positions
  return paint(canvas(0, shape(I)), recolor(4, {left_flank, right_flank}))
 
2.3333333333333335, 1.5873265, def gjebheacdgbhehbgaebefeehcjhjbjgd(I):
  w = width(I)
  mid = w // 2
  offset = 1 - (w % 2) 
  O = fill(I, 4, {(height(I) - 1, mid - offset), (height(I) - 1, mid + offset)})
  return O
 
2.0, 3.0998163, def aaahhhefdhdbeacajcbbcbfifhehgidb(I):
  """
  Identifies the bottom row and places '4's symmetrically around the center.
  """
  bottom_row = hfrontier((height(I) - 1, 0))
  center_index = width(I) // 2
  offset = 1 - (width(I) % 2) 
  left_index = center_index - 1 + offset
  right_index = center_index 
  left_cell = (height(I) - 1, left_index)
  right_cell = (height(I) - 1, right_index)
  return fill(fill(I, 4, {left_cell}), 4, {right_cell}) 
 
10.333333333333334, 37.224518, def fbeccdaeecedefefjdfjffdghdbjbecc(I):
  """
  Creates a new grid with '4's in the desired positions.
  """
  h, w = height(I), width(I)
  new_grid = canvas(0, (h, w))
  center_j = w // 2
  offset = 1 - (w % 2)
  left_corner = (h - 1, center_j - 1 + offset)
  right_corner = (h - 1, center_j)
  return fill(fill(new_grid, 4, {left_corner}), 4, {right_corner})
 
3.6666666666666665, 2.8687963, def cbbiedibaffeeccciaadbcebceajaeba(I):
  obj = argmax(objects(I, T, F, T), lambda obj: len(obj)) if any(v != mostcommon(I) for r in I for v in r) else {(0, 0)}
  center_j = centerofmass(obj)[1]
  offset = width(obj) // 2
  left_marker = (height(I) - 1, center_j - offset)
  right_marker = (height(I) - 1, center_j + offset)
  return fill(fill(I, 4, {left_marker}), 4, {right_marker})
 
4.333333333333333, 5.102101, def ebeaceaeddafeffcjabjhdfdacaiaege(I):
  least_color = leastcolor(I)
  return tuple(
      tuple(4 if j in {len(row) // 2 - 1, len(row) // 2} and v == least_color else v for j, v in enumerate(row))
      for row in I
  )
 
2.6666666666666665, 1.8289416, def afjbjdifcefdehiaiiacagdfebgbccie(I):
  indices = {(height(I) - 1, j) for j in range(width(I)) if abs(j - width(I) // 2) <= 1 - width(I) % 2}
  return fill(I, 4, indices)
 
1.6666666666666667, 1.4547651, def jdigcifgeidhebbhabhdciieacahedhh(I):
  """
  Leverages symmetry to fill '4's based on a single calculated position.
  """
  h, w = height(I), width(I)
  mid = w // 2
  offset = 1 - (w % 2)
  pos = (h - 1, mid + offset)
  return fill(fill(I, 4, {pos}), 4, {(h - 1, w - 1 - pos[1])}) 
 
10.666666666666666, 39.685818, def gifgdiibebafehgeijcijccfidddcabj(I):
  """
  Creates a canvas of '0's and paints the '4's at specific positions.
  """
  h, w = height(I), width(I)
  mid = w // 2
  offset = 1 - (w % 2)
  canvas_grid = canvas(0, (h, w)) 
  return paint(paint(canvas_grid, {(4, (h-1, mid - offset))}), {(4, (h-1, mid + offset))})
 
2.0, 2.3090434, def hfbcdgejagcdecbdbiecgfdajddccddf(I):
  obj = argmax(objects(I, T, F, T), lambda obj: len(obj)) if any(v != 0 for row in I for v in row) else {(0, 0)}
  j = centerofmass(obj)[1]
  offset = 1 if even(width(I)) else 0
  return fill(fill(I, 4, {(height(I)-1, j-offset)}), 4, {(height(I)-1, j+1+offset)})
 
3.0, 2.7488515, def eaacdigfbjfgeiicbhbieebcibibdcja(I):
  obj = argmax(objects(I, T, F, T), lambda x: len(x)) if sum(1 for row in I for v in row if v != 0) > 0 else {(0, 0)}
  center_j = centerofmass(obj)[1]
  return fill(fill(I, 4, {(height(I) - 1, center_j - (width(I) % 2))}), 4, {(height(I) - 1, center_j + 1)})
 
2.3333333333333335, 2.8934567, def daajagjcfbacechfahcdddgjdhbffibi(I):
  objs = objects(I, T, F, T)
  obj = max(objs, key=lambda x: len(x)) if len(objs) > 0 else {(0, (0, 0))}
  j = centerofmass(toindices(obj))[1]
  return fill(fill(I, 4, {(height(I) - 1, j - 1)}), 4, {(height(I) - 1, j + (1 if even(width(I)) else 0))})
 
3.6666666666666665, 2.897705, def cbajbedgjedheaaejdeejfjdaahbeajf(I):
  min_color = leastcolor(I)
  return tuple(
      tuple(4 if i == len(I) - 1 and (j == leftmost(ofcolor(I, min_color)) + 2 or j == rightmost(ofcolor(I, min_color)) - 2) else v for j, v in enumerate(row)) 
      for i, row in enumerate(I)
  )
 
12.0, 36.77254, def dbcjfcgaffbjeaecbefbbfhfaajdijac(I):
  least_color_obj = lambda obj: color(obj) == leastcolor(I)
  target_obj = extract(objects(I, True, False, True), least_color_obj)
  flanks = {(len(I)-1, leftmost(target_obj) + 2), (len(I)-1, rightmost(target_obj) - 2)}
  return paint(canvas(mostcolor(I), shape(I)), recolor(4, flanks))
 
2.3333333333333335, 2.8324912, def afidfdjaaiggegfcaibhibbjadccbica(I):
  w = width(I)
  offset = (w // 4)
  O = fill(I, 4, {(height(I) - 1, offset), (height(I) - 1,  3 * offset)})
  return O
 
1.6666666666666667, 2.329262, def daadbefbgicfeeajjecddfjifajbbceb(I):
  w = width(I)
  mid = w // 2
  quarter = w // 4
  O = fill(I, 4, {(height(I) - 1, mid - quarter), (height(I) - 1, mid + quarter)})
  return O
 
1.6666666666666667, 1.9951285, def fcchdddgfbfbefjajjhdfghbaddbbfef(I):
  return fill(I, 4, {(height(I)-1, width(I)//4), (height(I)-1, 3*width(I)//4)})
 
1.6666666666666667, 6.321297, def djdagecjdcbeeaceaafefajbffbjdcag(I):
  """
  Finds the center of the bottom row and places '4's symmetrically.
  """
  bottom_row = hfrontier((height(I) - 1, 0))
  c = center(bottom_row)
  offset = 1 - (width(I) % 2)
  return fill(fill(I, 4, {(c[0], c[1] - offset)}), 4, {(c[0], c[1] + offset)})
 
2.3333333333333335, 2.6428359, def gdabajfhafheedfhichiejfceegefici(I):
  """
  Creates a base object with '4's and shifts it based on grid width.
  """
  base_obj = {(4, (0, -1)), (4, (0, 1))}
  w = width(I)
  offset = (w // 2) - 1 + (w % 2)  
  shifted_obj = shift(base_obj, (height(I) - 1, offset))
  return paint(I, shifted_obj)
 
15.0, 5.9564443, def efbdfjcehcibeeegbdghdhgddbgacidd(I):
  """
  Fills a single '4' and mirrors it to achieve symmetry.
  """
  w = width(I)
  return hmirror(fill(I, 4, {(height(I) - 1, w // 2)})) 
 
3.0, 2.473915, def aeefabbjidcdefifbaagdhfhjechdfaf(I):
  def mark_object(grid, obj):
    w = width(obj) // 2
    row = height(grid) - 1
    return fill(fill(grid, 4, {(row, leftmost(obj)-w)}), 4, {(row, rightmost(obj)+w)})
  
  return next(mark_object(I, obj) for obj in objects(I, T, F, T) if obj)
 
3.3333333333333335, 2.809351, def bajedhabggeaefebjiadfbcccdhafdha(I):
  target_color = leastcolor(I)
  target_indices = ofcolor(I, target_color)
  left_border = leftmost(target_indices) - 1
  right_border = rightmost(target_indices) + 1
  return fill(fill(I, 0, {(len(I)-1, j) for j in range(len(I[0]))}), 4, {(len(I)-1, left_border), (len(I)-1, right_border)})
 
5.0, 8.472659, def icajdgjdbhebehdajjeagbjbecihebej(I):
  """
  Creates a canvas of '4's and overlays it on the bottom row. 
  """
  w = width(I)
  bottom_row = canvas(4, (1, w))
  return vconcat(I[:-1], bottom_row) 
 
3.0, 2.487879, def ecjjhcffdaefejedijdaeebfddjccjfe(I):
  obj = next((obj for obj in objects(I, T, F, T) if len(obj) > 1), {(0, (0, 0))})
  center_j = centerofmass(toindices(obj))[1]
  offset = (width(obj) - 1) // 2
  return fill(fill(I, 4, {(height(I) - 1, center_j - offset)}), 4, {(height(I) - 1, center_j + offset + (width(obj) % 2))}) 
 
3.0, 2.0029898, def bgacaeeffjfaecfdifbeadcfcccdeccg(I):
  obj =  {(v,ij) for v, ij in asobject(I) if v != mostcommon(sum(I, ())) } if any(sum(I, ())) else {(0, (0, 0))}
  j = centerofmass(toindices(obj))[1]
  return fill(fill(I, 4, {(height(I) - 1, j - (width(obj) // 2))}), 4, {(height(I) - 1, j + ((width(obj) + 1) // 2) - 1)})
 
1.6666666666666667, 6.321297, def deddaeeidbaieecfbccjaedcbfaffaaf(I):
  # Find the least common color
  target_color = leastcolor(I)
  # Find all occurrences of the least common color
  occurrences = ofcolor(I, target_color)
  # Create a set to store flanking positions
  flanking_positions = set()
  # Iterate over occurrences on the last row
  for i, j in occurrences:
    if i == len(I) - 1:
      # Add flanking positions to the set
      flanking_positions.add((i, j - 1))
      flanking_positions.add((i, j + 1))
  # Fill the flanking positions with '4'
  return fill(I, 4, flanking_positions)
 
2.6666666666666665, 3.9505982, def iaghfeahicabebfdidfaeecaeicadedi(I):
  # Find the least common color.
  target_color = leastcolor(I)
  # Get the last row of the grid.
  last_row = I[-1]
  # Find the leftmost and rightmost indices of the target color in the last row.
  left_border = next((j for j, v in enumerate(last_row) if v == target_color), -1) - 1
  right_border = next((len(last_row) - j - 1 for j, v in enumerate(last_row[::-1]) if v == target_color), -1) + 1
  # Fill the flanking positions with '4'.
  return fill(I, 4, {(len(I) - 1, left_border), (len(I) - 1, right_border)})
 
3.6666666666666665, 2.9392006, def aadadffiidaaeffiagddbfijebjbecca(I):
  obj = max(objects(I, T, F, T), key=lambda x: (len(x), -ulcorner(x)[0])) if sum(1 for row in I for v in row if v != 0) > 0 else {(0, (0, 0))}
  center_j = centerofmass(toindices(obj))[1]
  return fill(fill(I, 4, {(len(I) - 1, center_j - (width(obj) // 2))}), 4, {(len(I) - 1, center_j + (width(obj) // 2))})
 
3.6666666666666665, 2.752535, def iddbafbddjddeegebcddgbcdabacdbbb(I):
  # Find the least common color.
  target_color = leastcolor(I)
  # Find the indices of the target color on the last row.
  target_indices = ofcolor(I, target_color)
  last_row_indices = sfilter(target_indices, lambda x: x[0] == len(I) - 1)
  # Determine the flanking positions.
  left_border = 0 if not last_row_indices else min(j for i, j in last_row_indices) - 1
  right_border = len(I[0]) - 1 if not last_row_indices else max(j for i, j in last_row_indices) + 1
  # Fill the flanking positions with '4'.
  return fill(I, 4, {(len(I) - 1, left_border), (len(I) - 1, right_border)})
 
5.0, 8.472659, def ahaacdejaecdefcgiddhbhdeaddaajea(I):
  # Find the least common color.
  target_color = leastcolor(I)
  # Create a set of all column indices.
  all_columns = set(range(len(I[0])))
  # Find the column indices occupied by the target color on the last row.
  occupied_columns = {j for i, j in ofcolor(I, target_color) if i == len(I) - 1}
  # Find the flanking column indices.
  flanking_columns = all_columns - occupied_columns
  # Construct the flanking positions.
  flanking_positions = {(len(I) - 1, j) for j in flanking_columns}
  # Fill the flanking positions with '4'.
  return fill(I, 4, flanking_positions)
 
1.6666666666666667, 1.654443, def faabfjgcbiabeacbjfaebceeefcchdfh(I):
  """
  Identifies the bottom row and places '4's symmetrically around the center.
  """
  bottom_row = hfrontier((height(I)-1, 0)) # Get the bottom row indices
  center = width(I) // 2 # Find the center index of the row
  offset = 2 # Set the desired offset from the center

  # Generate indices for placing '4's
  left_index = (height(I)-1, center - offset)
  right_index = (height(I)-1, center + offset) 

  # Place '4's at calculated indices
  O = fill(I, 4, {left_index})  
  O = fill(O, 4, {right_index}) 
  return O
 
15.333333333333334, 6.8120894, def dcjbeedhbecjejgbbdidigacjgeibcaf(I):
  """
  Leverages symmetry to place a single '4' and then mirrors it.
  """
  w = width(I)
  O = fill(I, 4, {(height(I)-1, w//2 + 2)}) # Place one '4'
  O = hmirror(O) # Mirror the grid horizontally
  return O
 
3.0, 2.2606559, def ejheagfhdeieeggbicbhieiagiafaaca(I):
  """
  Calculates positions for '4's based on grid width and symmetry.
  """
  h, w = height(I), width(I)
  mid = w // 2
  offset = (w // 2) - 1 
  return fill(fill(I, 4, {(h-1, mid - offset)}), 4, {(h-1, mid + offset)})
 
76.0, 91.36189, def abfigebcgddiebeaafbdjiadahgdidhg(I):
  target_indices = ofcolor(I, leastcolor(I))
  left_border = leftmost(target_indices)
  right_border = rightmost(target_indices)
  bottom_row = list(I[-1])
  bottom_row[left_border] = 4
  bottom_row[right_border] = 4
  return hconcat(crop(I, (0, 0), (len(I)-1, len(I[0]))), (tuple(bottom_row),))
 
2.0, 2.0668845, def cgcabjiffecbegbhjaajaffbighadcce(I):
  """
  Uses 'rapply' to apply 'fill' with '4' at calculated indices on the bottom row.
  """
  h, w = height(I), width(I)
  center = w // 2
  offset = 1 - (w % 2)
  indices = ((h - 1, center - offset), (h - 1, center + offset))
  O = rapply((lambda ij: fill(I, 4, {ij}),), indices)
  return O[0] if len(O) == 1 else O
 
3.3333333333333335, 2.5164773, def gcejfcccadbgegbbifahchffddceeigb(I):
    # Identify the objects with color '4'
    obj = first(colorfilter(objects(I, T, F, T), FOUR))
    # Calculate horizontal expansion length 
    expansion = width(obj) - 1
    # Calculate the shift needed for centered expansion
    shift_amount = (0, expansion // 2)
    # Expand the object
    expanded_obj = shift(obj, shift_amount)
    # Paint the expanded object back onto the grid
    O = paint(I, expanded_obj)
    return O 
 
5.0, 8.472659, def caedebjcccjiecfcbbhabggehigabhaj(I):
    # Directly modify the grid rows where '4' is present
    O = tuple(
        tuple(FOUR if FOUR in row else cell for cell in row) 
        if FOUR in row else row 
        for row in I
    )
    return O
 
11.666666666666666, 36.36057, def aeiefcbibcbbefciafbfjbccecdfagce(I):
  least_color = leastcolor(I)
  target_indices = frozenset((height(I) - 1, j) for j in range(width(I)) if j % (width(I) // colorcount(I, least_color)) == 0)
  O = fill(I, least_color, target_indices)
  O = fill(O, 0, difference(asindices(O), target_indices))
  return O
 
4.333333333333333, 7.934015, def aacadecfaghjeafejjeiciajdgcefacd(I):
  least_color = leastcolor(I)
  count = colorcount(I, least_color)
  spacing = width(I) // count 
  O = canvas(0, shape(I))
  for i in range(height(I) - 1):
    O = tuple(O[:i] + (I[i],) + O[i + 1:])
  for j in range(count):
    O = tuple(O[:-1] + (O[-1][:spacing * j] + (least_color,) * spacing + O[-1][spacing * (j + 1):],))
  return O
 
3.3333333333333335, 3.6881757, def aecfggciddeaeagjaegcjgdbfcbajicf(I):
  least_color = leastcolor(I)
  indices = ofcolor(I, least_color)
  O = fill(I, 0, indices)
  target_indices = frozenset((height(I) - 1, j) for j in range(0, width(I), width(I) // len(indices)))
  return paint(O, recolor(least_color, target_indices))
 
1.6666666666666667, 6.3212976, def dajbfgccbcdfeeahiebbdhadbfdcedca(I):
  lc = leastcolor(I)
  n = colorcount(I, lc)
  w = width(I)
  O = fill(I, 0, ofcolor(I, lc))
  return tuple(
      tuple(v if i < height(O) - 1 else (lc if j % (w // n) == 0 and c < n else 0) for j, v in enumerate(r)) 
      for c, (i, r) in enumerate(zip(range(100), O))
  )
 
13.333333333333334, 5.345756, def behadefhaacgeacgbbhbbiedabaacfhd(grid):
  objs = objects(grid, T, F, T)
  four_obj = extract(objs, lambda obj: color(obj) == FOUR)
  start_j = leftmost(four_obj)
  end_j = rightmost(four_obj)
  center_j = (start_j + end_j) // 2
  extension = frozenset({(FOUR, (i, j)) for i in range(height(grid)) for j in range(start_j, center_j)} | 
                       {(FOUR, (i, j)) for i in range(height(grid)) for j in range(center_j + 1, width(grid))})
  return paint(grid, extension) 
 
23.333333333333332, 6.538806, def hbfbacidcaabebdhiaeafgaefcdicbdb(grid):
  four_indices = ofcolor(grid, FOUR)
  min_j, max_j = leftmost(four_indices), rightmost(four_indices)
  center_j = (min_j + max_j) // 2
  fill_indices = frozenset((i,j) for i in range(height(grid)) for j in range(width(grid)) if j < min_j or j > max_j)
  return fill(grid, FOUR, fill_indices)
 
34.666666666666664, 17.32922, def dahdeheeadeiecgeigfjfajcciceeahe(grid):
  fours = toindices(extract(objects(grid, T, F, T), lambda o: color(o) == 4))
  left = minimum(apply(lambda c: c[1], fours))
  right = maximum(apply(lambda c: c[1], fours))
  middle = (left + right) // 2
  to_paint = frozenset((i, j) for i in range(height(grid)) for j in range(width(grid)) 
                     if (j < middle and not contained((i, j), fours)) or 
                        (j > middle and not contained((i, j), fours)))
  return paint(grid, recolor(4, to_paint))
 
5.333333333333333, 4.0215974, def cbjbchbhbegceciaajgdbefccdhdgcfe(I):
  target_obj = argmin(objects(I, T, F, T), compose(size, lambda obj: colorfilter({obj}, leastcolor(I))))
  corner_left = (lowermost(target_obj), leftmost(target_obj))
  corner_right = (lowermost(target_obj), rightmost(target_obj))
  return fill(I, 4, {corner_left, corner_right}) 
 
5.333333333333333, 6.6548424, def cjfegfgbfgieeiebiihbdchgeaabjifb(I):
  w = width(I)
  offset = 1 if even(w) else 0
  left_index = tojvec(w // 2 - 1 - offset)
  right_index = tojvec(w // 2 + 1 + (1 - offset))
  bottom_row = hfrontier((height(I) - 1, 0))
  left_target = intersection({left_index}, toindices(bottom_row))
  right_target = intersection({right_index}, toindices(bottom_row))
  I = fill(I, 0, left_target)
  I = fill(I, 0, right_target)
  return fill(fill(I, 4, {left_index}), 4, {right_index})
 
3.0, 4.01375, def cdfdfidbcgecehgbiejdeachaaddbebj(I):
  objs = objects(I, False, False, False)
  fours = colorfilter(objs, 4)
  w = width(I)
  offset = 1 if even(w) else 0
  left_pos = (height(I) - 1, w // 2 - 1 - offset)
  right_pos = (height(I) - 1, w // 2 + 1 + (1 - offset))
  new_fours = frozenset({(4, left_pos), (4, right_pos)})
  return paint(cover(I, merge(fours)), new_fours)
 
1.6666666666666667, 1.6388978, def beebdaffdcabehidiegedfjhhehafbig(I):
  fours = ofcolor(I, 4)
  w = width(I)
  offset = 1 if even(w) else 0
  left_target = (height(I) - 1, w // 2 - 1 - offset)
  right_target = (height(I) - 1, w // 2 + 1 + (1 - offset))
  moved_fours = frozenset({(4, left_target), (4, right_target)})
  return paint(cover(I, fours), moved_fours)
 
3.6666666666666665, 2.4038315, def jgeiddcdfjbiecfbiaecfdedijcijhae(I):
  w = width(I)
  offset =  (w % 2) * 2 - 1
  fours = ofcolor(I, 4)
  return paint(cover(I, fours), {(4, (height(I) - 1, (w // 2) - 1 - offset)), (4, (height(I) - 1, (w // 2) + offset))})
 
5.0, 6.2158747, def acebddfbdbdfeaffjaddfegaebcjjeba(I):
  obj = first(colorfilter(objects(I, T, F, T), FOUR))
  left_edge = leftmost(obj)
  right_edge = rightmost(obj)
  O = fill(I, FOUR, {(height(obj)-1, left_edge - 1), (height(obj)-1, right_edge + 1)})
  return O
 
5.0, 5.705174, def ccfhchhdbdaaefgdjbgbgacffjgdeehi(I):
    O = I
    for j in range(width(I)):
        if index(I, (height(I) - 1, j)) == FOUR:
            O = fill(O, FOUR, {(height(I) - 1, j - 1)})
            O = fill(O, FOUR, {(height(I) - 1, j + 1)})
    return O
 
4.0, 5.4614835, def eigbddcbcgdbeefcaidgfdfcccacahgc(I):
  w = width(I)
  h = height(I) - 1
  center_left = w // 2 - (1 if even(w) else 0)
  center_right = center_left + 1
  target_indices = frozenset({(h, center_left), (h, center_right)})
  return fill(I, 4, target_indices)
 
3.6666666666666665, 5.4579225, def biibcfbggaiaejdcbiehcaabadcbecgh(I):
  return fill(I, 4, frozenset({(height(I) - 1, width(I) // 2 - 1), (height(I) - 1, width(I) // 2)}))
 
2.3333333333333335, 3.1167362, def cffaacifhcbfefbfidabfdheaadbdgdj(I):
  return vconcat(I[:-1], (tuple(4 if j == width(I) // 2 - 1 or j == width(I) // 2 else 0 for j in range(width(I))),))
 
37.333333333333336, 34.89748, def fdeaaeddcddjeaajjfabbeiaafbaifih(grid):
  for obj in objects(grid, T, F, T): # Iterate through objects
    if color(obj) == FOUR: # Check if object is '4'
      left_edge = leftmost(obj)
      right_edge = rightmost(obj)
      for i in range(height(grid)): # Iterate through rows
        for j in range(width(grid)):
          if j < left_edge or j > right_edge: # If outside object's horizontal bounds
            grid = fill(grid, FOUR, {(i, j)}) # Fill with '4'
  return grid
 
39.666666666666664, 46.11732, def baajhbaefjcbebcdjafhbfjgijgjbice(grid):
  four_obj = extract(objects(grid, T, F, T), lambda obj: color(obj) == FOUR) # Extract the '4' object
  return paint(
      grid, 
      recolor(
          FOUR, 
          difference(
              asindices(grid), # All grid indices
              toindices(four_obj) # Indices of the '4' object
          )
      )
  )
 
4.333333333333333, 4.0049133, def hfdjcibaheafefeijdcfbecbfffbahca(I):
  least_color = leastcolor(I)
  obj = first(colorfilter(objects(I, T, F, T), least_color))
  bottom_row = len(I) - 1
  left_pos = (bottom_row, leftmost(obj) - 1)
  right_pos = (bottom_row, rightmost(obj) + 1)
  return fill(I, 4, {left_pos, right_pos})
 
2.0, 2.164695, def abdadhadfadcecgjbbfhcefecfaidded(I):
  fours = ofcolor(I, 4) 
  bottom_row = height(I) - 1
  center_j = width(I) // 2
  offset = 1 if even(width(I)) else 0
  left_four = (bottom_row, center_j - offset)
  right_four = (bottom_row, center_j + offset)
  new_fours = frozenset({(4, left_four), (4, right_four)}) if len(fours) > 1 or not even(width(I)) else frozenset({(4, (bottom_row, center_j))})
  return paint(cover(I, fours), new_fours)
 
2.6666666666666665, 2.2742534, def ccdidcbbfhfjeajfbfecaaefcjjhdieg(I):
  fours = toindices(ofcolor(I, 4))
  new_fours = frozenset()
  w = width(I)
  center_j = w // 2 - int(even(w))
  for i, (row, col) in enumerate(fours):
    new_fours = new_fours | {(4, (height(I) - 1, center_j + 2 * i - len(fours) + 1))}
  return paint(cover(I, ofcolor(I, 4)), new_fours)
 
2.6666666666666665, 2.608326, def fiadcfbcdcfaefbdbjciibcfcfaceaha(I):
  fours = ofcolor(I, 4)
  target_row = height(I) - 1
  center_col = width(I) // 2
  if even(len(fours)):
    new_fours = frozenset({(4, (target_row, center_col - 1)), (4, (target_row, center_col + 1))})
  else:
    new_fours = frozenset({(4, (target_row, center_col))})
  return paint(cover(I, fours), new_fours)
 
2.0, 2.880152, def befhbbhdccdfeffiabibgcacdajhbhhd(I):
  fours = ofcolor(I, 4)
  target_row = height(I) - 1
  start_col = (width(I) - len(fours)) // 2
  new_fours = frozenset((4, (target_row, start_col + i)) for i in range(len(fours)))
  return paint(cover(I, fours), new_fours)
 
3.0, 2.99186, def fbhaaiecdbebeeebadfcbdiiegeccbdb(I):
  h, w = shape(I)
  return tuple(tuple(I[i][j] if (i != h - 1 or colorcount(I, I[i][j]) > 1) else I[i][w - 1 - j] for j in range(w)) for i in range(h))
 
2.0, 2.861087, def gjcfeigahjdeeeadjcacdjbhfjgjedgd(I):
  least_color = leastcolor(I)
  target_indices = ofcolor(I, least_color)
  O = fill(I, 0, target_indices)
  spacing = width(I) // (len(target_indices) + 1)
  for i, (row, col) in enumerate(target_indices):
    O = paint(O, {(least_color, (height(I) - 1, spacing * (i + 1)))})
  return O
 
11.0, 23.956053, def bfdhijiaeiebefgcjfdcacgeegcigdee(I):
  h = height(I)
  return tuple(tuple(branch(any(I[i][j] == FOUR for i in range(h)), FOUR, I[i][j]) for j in range(width(I))) for i in range(h))
 
5.0, 8.472659, def ecebbhcbjhebedefaicaibefcbdcffij(I):
  fours = ofcolor(I, FOUR)
  bottom_row = {(i, j) for i, j in fours if i == lowermost(fours)}
  stretched_fours = frozenset((FOUR, (i, j)) for i, _ in bottom_row for j in range(width(I)))
  return paint(I, stretched_fours)
 
10.666666666666666, 21.367395, def eiedfjecegbaeegbifecedcfeedaddaj(I):
  return tuple(tuple(4 if 4 in col else cell for cell in row) for row, col in zip(I, dmirror(I)))
 
3.6666666666666665, 2.5590303, def aajgdbfcgdjgegabjdghgfecabchafaf(I):
  least_color = leastcolor(I)
  obj_indices = ofcolor(I, least_color)
  left_edge = min(j for i, j in obj_indices)
  right_edge = max(j for i, j in obj_indices)
  O = fill(I, 4, {(len(I)-1, left_edge-1), (len(I)-1, right_edge+1)})
  return O
 
3.3333333333333335, 2.3739386, def hjeibbfdhfacefcaijffdchfadchaadj(I):
  fours = ofcolor(I, 4)
  target_row = height(I) - 1
  w = width(I) 
  if even(len(fours)):
    new_fours = frozenset({(4, (target_row, w // 2 - len(fours) // 2 - 1)), (4, (target_row, w // 2 + len(fours) // 2))})
  else:
    new_fours = frozenset({(4, (target_row, w // 2))})
  return paint(cover(I, fours), new_fours)
 
3.0, 2.5923638, def hcbieajdbaegeacdjfddgeghfffieidf(I):
  fours = toobject(ofcolor(I, 4), I)
  target_row = height(I) - 1
  w = width(I) 
  if even(len(fours)):
    left_four = shift(fours, (target_row - uppermost(fours), -width(fours) // 2))
    right_four = shift(fours, (target_row - uppermost(fours), w // 2 + width(fours) // 2 - rightmost(fours)))
    new_fours = left_four | right_four
  else:
    new_fours = shift(fours, (target_row - uppermost(fours), w // 2 - leftmost(fours)))
  return paint(cover(I, fours), new_fours)
 
2.6666666666666665, 2.1603, def aefccecfddcieadabaddiegdajfcfiea(I):
  fours = sorted(toindices(ofcolor(I, 4)), key=lambda x: x[1])
  target_row = height(I) - 1
  w = width(I)
  if len(fours) == 2:
    new_fours = frozenset({(4, (target_row, 1)), (4, (target_row, w - 2))})
  else: 
    new_fours = frozenset({(4, (target_row, w // 2))})
  return paint(cover(I, fours), new_fours)
 
3.6666666666666665, 2.3498733, def jcjbccdbgffcecfjjibbbbfabfeajeba(I):
  O = I
  for j in range(width(I)):
    if colorcount(I, index(I, (height(I) - 1, j))) == 1:
      O = fill(O, index(I, (height(I) - 1, j)), frozenset({(height(I) - 1, width(I) - 1 - j)}))
  return O
 
3.6666666666666665, 2.5579562, def aadcfdgjagiiejjbaajahgafgfdedfhe(I):
  objs = objects(I, True, False, True)
  single_cells = sfilter(objs, lambda o: size(o) == 1 and uppermost(o) == height(I) - 1)
  return paint(I, mapply(lambda o: shift(o, (0, width(I) - 1 - 2 * leftmost(o))), single_cells))
 
5.0, 5.705174, def cbfaecbhahceejfdafbjhedfiicdbace(I):
  min_color = leastcolor(I)
  filled_cells = set()
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == min_color:
        if j > 0:
          filled_cells.add((len(I)-1, j - 1))
        if j < len(row) - 1:
          filled_cells.add((len(I)-1, j + 1))
  return fill(I, 4, filled_cells)
 
2.3333333333333335, 1.9555608, def agdiacbcdcfheebeaedbfibadffbbehd(I):
  fours = toindices(ofcolor(I, 4))
  new_fours = frozenset()
  w = width(I)
  center_j = w // 2 - int(even(w))
  spacing = 1 + 2 * (len(fours) > 1)
  for i, (row, col) in enumerate(fours):
    new_fours = new_fours | {(4, (height(I) - 1, center_j + spacing * i - spacing * len(fours) // 2))}
  return paint(cover(I, ofcolor(I, 4)), new_fours)
 
2.6666666666666665, 2.4622724, def jefdjgiacdfdebdbaehcdagdjjfdfjig(I):
  fours = toindices(ofcolor(I, 4))
  target_row = height(I) - 1
  offset = (len(fours) > 1) * 2
  new_fours = frozenset((4, (target_row, width(I) // 2 + offset * i - offset * len(fours) // 2 + (len(fours) == 1))) for i in range(len(fours)))
  return paint(cover(I, ofcolor(I, 4)), new_fours)
 
2.6666666666666665, 2.0816865, def abidcdfafgajeadcjeffjadiafaafddf(I):
  bottom_row = I[height(I)-1]
  mirrored_row = bottom_row[::-1]
  return I[:-1] + (mirrored_row,) 
 
11.333333333333334, 12.272914, def gdcbifbghadaedebbifebbcfgehfahec(I):
  return vconcat(tophalf(I), hmirror(tophalf(vmirror(I))))
 
1.6666666666666667, 6.3212976, def dcbcfgabacdbecacjbeddabfddehcafe(I):
  four_loc = extract(asindices(I), lambda loc: index(I, loc) == FOUR)
  bottom_line = {(FOUR, (four_loc[0], j)) for j in range(width(I))}
  return paint(I, toobject(bottom_line, canvas(ZERO, shape(I))))
 
2.6666666666666665, 2.5132608, def cjjeebehaceaebffaaieedhcjdafdbdf(I):
  fours = toobject(ofcolor(I, 4), I)
  target_row = height(I) - 1
  spacing = 2 + (len(fours) == 1) 
  new_fours = set()
  for i, (_, (row, col)) in enumerate(fours):
    new_col = width(I) // 2 + spacing * i - spacing * len(fours) // 2
    new_fours.add((4, (target_row, new_col)))
  return paint(cover(I, fours), frozenset(new_fours))
 
2.0, 2.2238417, def aeddigahaaabeaffbedafciggicbfgcj(I):
  fours = toobject(ofcolor(I, 4), I)
  target_row = height(I) - 1
  center_j = width(I) // 2 
  offset = (len(fours) - 1) // 2
  new_fours = frozenset({(4, (target_row, center_j + 2 * i - 2 * offset)) for i in range(len(fours))})
  return paint(cover(I, fours), new_fours)
 
2.0, 5.465602, def ggdbbjdjhfbfeeefjifeadbeaeddfacd(I):
  fours = toobject(ofcolor(I, 4), I)
  bottom_row = frozenset((height(I) - 1, j) for j in range(width(I)))
  if len(fours) == 1:
    return paint(I, frozenset({(4, (height(I)-1, width(I)//2))}))
  else:
    return paint(cover(I, fours),  
                 frozenset((4, pos) for pos in sfilter(bottom_row, lambda p: manhattan(fours, frozenset({p})) == 3)))
 
2.3333333333333335, 4.3562117, def ejabecjgeaabehffidfdbdehihjiejba(I):
  #  Generate a new grid with the transformation applied to the last row
  return vconcat(I[:height(I)-1], (tuple(v if v != 4 else 4 if j % (2 * j + 1) == 0 else 0 for j, v in enumerate(I[height(I)-1])),))
 
19.666666666666668, 13.714884, def cfbdaafdbdgdebafbbffabbefcefbaad(I):
  fours = ofcolor(I, FOUR)  # Get indices of all '4' cells
  leftmost_col = minimum(apply(lambda x: x[1], fours))  # Find leftmost column
  rightmost_col = maximum(apply(lambda x: x[1], fours)) # Find rightmost column
  expanded_indices = {(i, j) for i in range(height(I)) for j in range(leftmost_col, rightmost_col + 1)}
  return fill(I, FOUR, expanded_indices)  # Fill the identified region with '4'
 
2.0, 3.0998166, def ddbiedhjbfceeaiajffededefeeahbbd(I):
  fours = ofcolor(I, 4)
  bottom_row = height(I) - 1
  center_j = width(I) // 2
  if len(fours) == 1:
    return paint(cover(I, fours), frozenset({(4, (bottom_row, center_j))}))
  else:
    left_four = (bottom_row, center_j - 1)
    right_four = (bottom_row, center_j)
    return paint(cover(I, fours), frozenset({(4, left_four), (4, right_four)}))
 
1.6666666666666667, 6.3212976, def ahdbedegcfcaeeccjchgaijdebideiah(I):
  fours = toobject(ofcolor(I, 4), I)
  bottom_row = frozenset((4, (height(I) - 1, j)) for j in range(width(I)))
  centered_fours = shift(normalize(fours), (height(I) - 1 - uppermost(fours), (width(I) - width(fours)) // 2))
  return paint(cover(I, fours),  centered_fours & bottom_row)
 
2.6666666666666665, 3.2877681, def fdhehigddhceecbfiafiajecaifhaagh(I):
  fours = ofcolor(I, 4)
  if not fours:
    return I
  center_j = width(I) // 2
  offset = (len(fours) - 1) // 2 
  new_fours = frozenset({(4, (height(I) - 1, center_j + i - offset)) for i in range(len(fours))})
  return paint(cover(I, fours), new_fours)
 
12.0, 36.327633, def ccdefbfjgbcdehgeighfccaiefdbaaaa(I):
  # Identify objects, filter for '4's in the last row, and extract indices
  target_indices = toindices(mfilter(objects(I, True, False, True), lambda o: color(o) == 4 and contained((height(I) - 1, leftmost(o)), toindices(o))))
  # Calculate mirrored indices across the horizontal center
  mirrored_indices = {(i, width(I) - 1 - j) for i, j in target_indices}
  # Combine original and mirrored indices
  all_indices = target_indices | mirrored_indices
  # Paint '4's at all identified indices 
  return paint(canvas(0, shape(I)), {(4, (i, j)) for i, j in all_indices})
 
4.0, 3.5741403, def dddacibjdccbedggadaebcfcfbbbddde(I):
  # Extract the last row as a separate grid
  last_row = crop(I, (height(I) - 1, 0), (1, width(I)))
  # Find indices of '4's in the last row
  fours_indices = ofcolor(last_row, 4)
  # Calculate the horizontal middle point of the last row
  mid = width(last_row) // 2
  # Mirror the indices across the middle point
  mirrored_indices = {(0, 2 * mid - j - 1) for i, j in fours_indices}
  # Create new objects from mirrored indices
  new_fours = {(4, (height(I) - 1, j)) for i, j in mirrored_indices}
  # Paint the mirrored objects onto the original grid
  return paint(I, new_fours)
 
12.333333333333334, 34.65997, def gedchihcchaaejdciaggfaiddhhcfbcc(I):
  # Create a blank canvas
  O = canvas(0, shape(I))
  # Get all '4' cells in the last row
  fours = {(4, (height(I) - 1, j)) for j in range(width(I)) if index(I, (height(I) - 1, j)) == 4}
  # Calculate horizontal center
  center_j = width(I) // 2
  # Mirror the '4' cells across the center
  mirrored_fours = {(4, (height(I) - 1, 2 * center_j - j - 1)) for _, (i, j) in fours}
  # Combine and paint
  return paint(paint(O, fours), mirrored_fours)
 
18.666666666666668, 11.045184, def fjeidcfjffiheaebijcfhhfeehhhiaee(I):
    h, w = shape(I)
    new_grid = canvas(ZERO, (h, w))
    for j in range(w):
        if any(index(I, (i, j)) == FOUR for i in range(h)):
            for i in range(h):
                new_grid = paint(new_grid, {(FOUR, (i, j))})
    return new_grid
 
3.6666666666666665, 2.8543289, def aedbdecfdeceecgcjjdifgcfehfifddb(I):
  obj = argmin(objects(I, T, F, T), compose(size, lambda obj: colorfilter({obj}, leastcolor(I))))
  O = fill(I, 4, {(len(I)-1, leftmost(obj) - 1), (len(I)-1, rightmost(obj) + 1)})
  return O
 
2.0, 4.9976063, def gafhfefcdhheeefcaidhfibifahdbdci(I):
  fours_indices = toindices(toobject(ofcolor(I, 4), I))
  target_row = height(I) - 1
  w = width(I)
  offset =  w // 4 if even(len(fours_indices)) else  w // 2
  new_fours = frozenset(
      (4, (target_row, (j + offset) % w)) for i, (j, k) in enumerate(sorted(fours_indices))
  )
  return paint(cover(I, fours_indices), toobject(new_fours, I))
 
2.3333333333333335, 3.8306866, def fdcbjjeebehfecdiaeecfbceidaffcdj(I):
  # Get the last row
  last_row = I[height(I) - 1]
  # Find the least common color in the last row
  least_color = leastcommon(last_row)
  # Create a new last row with mirrored least common color elements
  new_last_row = tuple(v if v != least_color else last_row[len(last_row) - 1 - i] for i, v in enumerate(last_row))
  # Replace the last row in the input grid
  return I[:-1] + (new_last_row,)
 
3.3333333333333335, 2.7891974, def dbaaggccgfjaeddeagcjhhgfdaadcfci(I):
  fours = toobject(ofcolor(I, 4), I)
  target_row = height(I) - 1
  num_fours = len(fours)
  if even(num_fours):
    spacing = width(I) // num_fours
    new_fours = frozenset({(4, (target_row, (spacing // 2) + i * spacing)) for i in range(num_fours)})
  else:
    new_fours = frozenset({(4, (target_row, width(I) // 2))})
  return paint(cover(I, fours), new_fours)
 
2.6666666666666665, 3.802658, def gfaecfibcdhdedgcbidcfcaiaifajgic(I):
  # Get the value of the bottom-right corner cell
  corner_val = I[height(I) - 1][width(I) - 1] 
  # Create a new last row with the corner value mirrored
  new_last_row = tuple(corner_val if j >= width(I) // 2 else I[height(I) - 1][j] for j in range(width(I)))
  # Combine the original grid with the new last row
  return I[:-1] + (new_last_row,)
 
7.666666666666667, 8.010494, def ccedbaibbbafedhcjghehjdfbeaddife(I):
  return vconcat(
    tophalf(I),
    hmirror(tophalf(vconcat(I, (I[-1],))))
  )
 
3.3333333333333335, 2.413495, def abhheeacefffejhbijddceihcahcijbb(I):
  h = height(I)
  w = width(I)
  target_color = leastcolor(I)
  left_edge = next((j for j in range(w) if I[h-1][j] == target_color), 0)
  right_edge = w - next((j for j in range(w-1, -1, -1) if I[h-1][j] == target_color), 0) - 1
  O = fill(I, 4, {(h-1, left_edge), (h-1, right_edge)})
  return O
 
