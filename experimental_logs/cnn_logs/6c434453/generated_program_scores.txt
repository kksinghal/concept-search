0.33999999999999997, 12.442503, def chheiafhhdccedjjacbabeibfcgeciec(I):
  objs = objects(I, T, T, T)
  shifted_objs = frozenset({(color(obj), (i - 1, j + 1)) for obj in objs for c, (i, j) in obj})
  O = paint(canvas(mostcolor(I), shape(I)), shifted_objs)
  return O
 
0.33999999999999997, 11.925401, def dfbceghffgeeeefajdihbfgbbhhhcceh(I):
  new_grid = tuple(tuple(2 if v == 1 else v for v in row) for row in I) # Direct color replacement on grid
  shifted_grid = canvas(mostcolor(I), shape(I)) # Create a canvas for shifted objects
  for i, row in enumerate(new_grid):
    for j, val in enumerate(row):
      if val == 2: 
        shifted_grid = fill(shifted_grid, val, {(i + 1, j + 1)}) # Fill shifted positions on new grid
  O = shifted_grid
  return O
 
0.265, 21.47878, def ebfeibhebfcaegdabddfjdfbcagaffca(I):
    def move_and_recolor(grid, loc): # Function to move and recolor object at location
        if index(grid, loc) == 1:
            grid = fill(grid, mostcolor(grid), {loc}) # Remove object at current location
            grid = fill(grid, 2, {(loc[0] + 1, loc[1] + 1)}) # Place object at new location with new color
        return grid
    for i in range(height(I)):
        for j in range(width(I)):
            I = move_and_recolor(I, (i, j)) # Apply to each cell 
    O = I
    return O
 
0.28, 13.183277, def caecbhbdeabceebdidceggcfaeiccddd(I):
  objs = objects(I, False, False, True)
  obj1 = argmax(objs, width) 
  obj2 = other(objs, obj1)
  
  # Calculate the new upper-left corner for obj1
  new_ul_obj1 = (1, width(I) - width(obj1))
  # Calculate the offset to move obj1
  offset1 = subtract(new_ul_obj1, ulcorner(obj1))
  # Move obj1
  obj1 = shift(obj1, offset1) 
  
  # Calculate the new upper-left corner for obj2
  new_ul_obj2 = add(ulcorner(obj1), (2, 0))
  # Calculate the offset to move obj2
  offset2 = subtract(new_ul_obj2, ulcorner(obj2))
  # Move obj2
  obj2 = shift(obj2, offset2) 
  
  # Recolor objects to 2
  obj1 = recolor(2, obj1)
  obj2 = recolor(2, obj2)
  
  O = paint(paint(I, obj1), obj2)
  return O 
 
0.23500000000000001, 12.182404, def ffbbccfeiaeiebeaieaejcacibdjcabb(I):
  objs = objects(I, False, False, True)
  obj1 = argmax(objs, lambda o: leftmost(o) + rightmost(o))
  obj2 = other(objs, obj1)
  
  target_right_edge = width(I) - 1
  
  # Move obj1 to the right edge
  obj1 = shift(obj1, (1, target_right_edge - rightmost(obj1)))
  # Align obj2 horizontally below obj1
  obj2 = shift(obj2, (uppermost(obj1) + 2 - uppermost(obj2), leftmost(obj1) - leftmost(obj2)))

  # Recolor the objects
  obj1 = recolor(2, obj1)
  obj2 = recolor(2, obj2)
  
  O = paint(paint(I, obj1), obj2)
  return O
 
0.19, 44.29276, def fafcadafcgaheaaeiabfghhjjadgbjhc(I):
    shifted_objs = {shift(obj, (-1, 1)) for obj in fgpartition(I)}  # Shift all objects
    O = I  # Initialize output grid
    for i, row in enumerate(I):
        for j, _ in enumerate(row):
            if any((i, j) in toindices(obj) for obj in shifted_objs):  # Check if cell is part of shifted object
                O = paint(O, {(I[i][j], (i, j))}) # Paint the cell 
            else:
                O = paint(O, {(mostcolor(I), (i, j))}) # Paint background color
    return O
 
0.35, 13.013756, def dffehecbaeaceeabjcijbbiehjbddbda(I):
    return tuple(  # Construct the output grid row by row
        tuple(
            I[i-1][j+1] if 0 <= i-1 < len(I) and 0 <= j+1 < len(row) and I[i-1][j+1] != mostcolor(I) else mostcolor(I)
            for j, _ in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
0.395, 14.569598, def dfajddebdagdebafjcadhebeccfigibb(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        length = size(obj)
        line = {(2, (0, j)) for j in range(length)}
        location = ulcorner(toindices(obj)) # Use top-left corner
        O = paint(O, shift(line, location))
    return O
 
0.35, 21.636276, def fadjdbbbbeiaeijfachfjdbaegjbbdgd(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    O = I
    for obj in objs:
        loc = first(toindices(obj)) # Take the first cell's location
        O = paint(cover(O, obj), recolor(2, toobject(shift({(0, j) for j in range(size(obj))}, loc), I)))
    return O
 
0.355, 18.354643, def efccdfachcjeeffbiidijbebgeefdeee(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    i, j = first(toindices(obj)) # First cell's location
    for k in range(size(obj)):
      O = paint(O, {(2, (i, j+k))})
  return O
 
0.33, 27.62129, def fchihfcfabfaeebdahddedcdfcegadbg(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    lines = {shift(recolor(2, {(0, j) for j in range(size(obj))}), ulcorner(toindices(obj))) for obj in objs}
    O = I
    for line in lines:
        O = underpaint(O, line) # Paint only on background
    return O
 
0.30500000000000005, 13.471259, def fhiccbddjihbeabjajefeacdjihbfbce(I):
  return tuple(
    tuple(
      I[i+1][j+1] if 0 <= i+1 < len(I) and 0 <= j+1 < len(I[0]) else mostcolor(I)
      for j in range(len(I[0]))
    )
    for i in range(len(I))
  )
 
0.355, 28.825092, def chffhgecihfeehhdijicbegfcfeddffe(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    row = uppermost(obj)
    start = (row, leftmost(obj))
    O = fill(O, 2, connect(start, (row, start[1] + size(obj) - 1)))
  return O
 
0.305, 51.544308, def djhececedfececccbciabfaceedecegi(I):
  def transform_object(obj):
    line = repeat(2, size(obj)) 
    indices = shift(product(interval(0, 1, 1), interval(0, size(obj), 1)), ulcorner(obj))
    return frozenset(zip(line, indices))

  return paint(canvas(mostcolor(I), shape(I)), merge(apply(transform_object, fgpartition(I))))
 
0.33, 32.36062, def eefcebdfdhifecdiifegacbhfcgjbgjb(I):
    O = I
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 1:
                new_i = i + 1 if i < len(I) - 1 else i
                new_j = j + 1 if j < len(row) - 1 else j
                O = fill(O, 2, {(new_i, new_j)})
    return O
 
0.18, 41.460533, def accidfcgeciieefcjafbbfijffcdaaaa(I):
  def process_cell(i, j, val):
    if val != 1:
      return val
    new_i = min(i + 1, len(I) - 1)
    new_j = min(j + 1, len(I[0]) - 1)
    return 2 if (i, j) == (new_i, new_j) else I[new_i][new_j]
  
  O = tuple(tuple(process_cell(i, j, val) for j, val in enumerate(row)) for i, row in enumerate(I))
  return O
 
0.18, 11.269097, def fefjiebadafgeeddjecaegehaagdegbb(I):
  objs = objects(I, False, False, True)
  small_objs = sizefilter(objs, 3)

  obj1 = next(iter(small_objs), None) # Handle cases with fewer objects 
  obj2 = next(iter(small_objs - {obj1}), None) if obj1 else None 

  if obj1 and obj2:  # Proceed only if both objects exist
    obj1 = recolor(2, shift(obj1, (1, -leftmost(obj1)))) 
    obj2 = recolor(2, shift(obj2, (uppermost(obj1) + 2, 1 - leftmost(obj2)))) 
    return paint(paint(I, obj1), obj2)
  else:
    return I # Return original grid if either object is missing
 
0.185, 11.307912, def ddagiaceiiejehbbjcfbjedfefeecadh(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)  # Extract single-color objects
  recolored_objs = set()
  for obj in objs:
    if hline(obj):  # Only process horizontal lines
      recolored_objs.add(recolor(2, shift(obj, (-1, 1)))) # Recolor to 2, shift up-right 
  O = I
  for obj in recolored_objs:
    O = paint(O, obj)  # Paint the transformed objects onto the output
  return O 
 
0.23, 68.67829, def efjiegaaaifbecdiifhbbedffeccadab(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background color
  for obj in objects(I, True, False, True):
    if hline(obj):
      new_start = add(ulcorner(toindices(obj)), (-1, 1)) # Calculate new starting point
      O = paint(O, recolor(2, shift(obj, subtract(new_start, ulcorner(toindices(obj))))))
  return O
 
0.22, 11.11333, def djacgfafidabedagidacfehjjbeebija(I):
  O = I  # Work directly on input copy
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1 and all(I[i][k] == 1 for k in range(j, min(j + width(I), len(row)))): # Check for horizontal line at (i, j)
        O = paint(cover(O, {(1, (i, k)) for k in range(j, len(row))}), recolor(2, {(2, (i - 1, k + 1)) for k in range(j, len(row))})) # Cover and paint
  return O
 
0.225, 70.18224, def ceehagccefcfebedbcchfcfhdhfdebgi(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    if hline(obj):
      start = ulcorner(obj)
      new_obj = recolor(2, {(2, (i + start[0] - 1, j + start[1] + 1)) for _, (i, j) in obj})  # Direct transformation within recolor
      O = paint(O, new_obj)
  return O 
 
0.195, 10.576608, def aijgbfehedgbedgjbfdbjfggbccjacgh(I):
  def transform_line(obj):
    return recolor(2, shift(obj, (-1, 1))) if hline(obj) else obj #  Transformation logic in a separate function

  return paint(canvas(mostcolor(I), shape(I)), 
               merge(apply(transform_line, objects(I, True, False, True)))) # Functional approach
 
0.16999999999999998, 12.428169, def fihjcjeehfcaeddabcbccafadfhiacfi(I):
    # Find the largest object
    largest_obj = argmax(objects(I, T, F, T), size)

    # Find the smallest object
    smallest_obj = argmin(objects(I, T, F, T), size)

    # Get the bounding box of the largest object
    bbox = backdrop(toindices(largest_obj))

    # Get the rightmost 'j' coordinate of the bounding box
    max_j = rightmost(bbox)

    # Calculate the shift amount for the smallest object
    shift_amount = max_j - rightmost(smallest_obj)

    # Shift the smallest object to the right edge of the bounding box
    shifted_smallest_obj = shift(smallest_obj, (0, shift_amount))

    # Recolor both objects to '2' and paint them on the input grid
    O = paint(paint(I, recolor(2, largest_obj)), recolor(2, shifted_smallest_obj))
    return O
 
0.25, 42.41537, def aabbcecdffcceaicigahaifcjdaedfbf(I):
  # Identify largest and smallest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  smallest = argmin(objs, size)

  # Calculate the horizontal shift needed to align the smallest object with the largest
  shift_amount = rightmost(largest) - rightmost(smallest)

  # Shift the smallest object horizontally
  shifted_smallest = shift(smallest, (0, shift_amount))

  # Recolor both objects to 2
  recolored_largest = recolor(2, largest)
  recolored_smallest = recolor(2, shifted_smallest)

  # Paint the recolored objects onto a blank canvas
  O = paint(canvas(0, shape(I)), recolored_largest)
  O = paint(O, recolored_smallest)
  return O
 
0.33999999999999997, 11.925401, def edfdfhcefafceeeabgaafegffaiedbdf(I):
  return paint(canvas(mostcolor(I), shape(I)), 
               merge(apply(lambda obj: recolor(2, shift(obj, (1, 1))), 
                           objects(I, True, False, True))))
 
0.255, 18.791195, def cibaafegeihiebbdicfaehhhhjgegabb(I):
  # Extract objects and find target column
  objs = objects(I, T, F, T)
  target_col = rightmost(argmax(objs, size)) + 1

  # Modify each object based on size
  O = I
  for obj in objs:
    if obj == argmax(objs, size):
      O = paint(O, recolor(2, obj)) # Recolor largest object
    else:
      O = paint(O, recolor(2, shift(obj, (0, target_col - leftmost(obj))))) # Shift and recolor others
  return O
 
0.255, 43.80152, def aheidafdaibdefciafjhgaddaefaacdf(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)

  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)

  # Create a canvas with the same dimensions as the input grid
  canvas_grid = canvas(mostcolor(I), shape(I))

  # Calculate the target position for the smallest object (next to the largest)
  target_pos = (uppermost(largest_obj), rightmost(largest_obj) + 1)

  # Move and recolor the smallest object on the canvas
  canvas_grid = paint(canvas_grid, recolor(2, shift(smallest_obj, subtract(target_pos, ulcorner(smallest_obj)))))

  # Recolor the largest object and paint it onto the canvas
  O = paint(canvas_grid, recolor(2, largest_obj))

  return O
 
0.36, 13.225405, def bghdabaeffceebjjjadcdacaaaeifbfd(I):
  shifted_grid = canvas(mostcolor(I), shape(I)) # Create a canvas for shifted objects
  for obj in objects(I, T, F, T): # Iterate over all objects
      if color(obj) == 1: # Process only objects with color '1'
          shifted_grid = paint(shifted_grid, shift(obj, (1,1))) # Paint shifted object onto the new grid
  O = shifted_grid
  return O
 
0.375, 22.385614, def cbafgjabbcchecbiaccbeadfddfiefch(I):
  O = I # Start with the input grid
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        O = fill(O, mostcolor(I), {(i,j)}) # Replace '1' with background color
        if 0 <= i+1 < len(I) and 0 <= j+1 < len(row):
          O = fill(O, 2, {(i+1, j+1)}) # Fill the diagonally shifted position with '2'
  return O
 
0.23, 12.239449, def ddbedceejdcbefgdijegccheaffibdai(I):
  objs = objects(I, True, False, True) 
  target_color = leastcolor(I)
  target_objs = colorfilter(objs, target_color)
  obj1 = first(target_objs)
  obj2 = other(target_objs, obj1)
  obj1_shifted = shift(recolor(2, obj1), (1, -leftmost(obj1)))
  obj2_shifted = shift(recolor(2, obj2), (uppermost(obj1_shifted) + 2, 1 - leftmost(obj2)))
  return paint(paint(I, obj1_shifted), obj2_shifted)
 
0.25, 14.798394, def dcgcfgecdfaceibejedcaefieeejbbab(I):
  target_color = leastcolor(I)
  objs = objects(I, True, False, True)
  sorted_objs = sorted(colorfilter(objs, target_color), key=lambda obj: (uppermost(obj), leftmost(obj)))
  obj1 = recolor(2, shift(sorted_objs[0], (1, -leftmost(sorted_objs[0]))))
  obj2 = recolor(2, shift(sorted_objs[1], (uppermost(obj1) + 2, 1 - leftmost(sorted_objs[1]))))
  return paint(paint(I, obj1), obj2) 
 
0.24, 17.227694, def ijbfdcheeeifecjaicfidbhiddcjdfeh(I):
  objs = objects(I, True, False, True)
  min_color = leastcolor(I)
  filtered_objs = sorted(colorfilter(objs, min_color), key=lambda x: (uppermost(x), leftmost(x)))
  obj1, obj2 = filtered_objs[:2]
  obj1_new = recolor(2, shift(obj1, (1, -leftmost(obj1))))
  obj2_new = recolor(2, shift(obj2, (uppermost(obj1_new) + 2, 1 - leftmost(obj2))))
  return underpaint(underpaint(I, obj1_new), obj2_new)
 
0.24, 10.86081, def hfabdbfbjgdeebeaahaideaaaeadcccb(I):
    target_color = leastcolor(I)
    objs = objects(I, True, False, True)
    target_objs = sorted([obj for obj in objs if color(obj) == target_color], key=lambda obj: len(obj))
    obj1, obj2 = target_objs[:2]
    obj1 = shift(recolor(2, obj1), (1, -leftmost(obj1)))
    obj2 = shift(recolor(2, obj2), (uppermost(obj1) + 2, 1 - leftmost(obj2)))
    return paint(paint(cover(I, target_objs[0]), obj1), obj2)
 
0.19, 43.674934, def bahafaibfceiejfiahacecegjheiabdd(I):
  h, w = len(I), len(I[0]) 
  bg = mostcolor(I)
  return tuple(
      tuple(
          index(I, ((i-1)%h, (j+1)%w)) if index(I, (i, j)) != bg else bg
          for j in range(w)
      )
      for i in range(h)
  ) 
 
0.36, 11.970231, def ihhfbbafebeiefacbbcefbhfffdbbjcb(I):
  h, w = len(I), len(I[0])
  top_row = crop(I, (0, 0), (1, w))
  bottom_section = crop(I, (1, 0), (h - 1, w))
  shifted_grid = vconcat(bottom_section, top_row)
  left_column = crop(shifted_grid, (0, 0), (h, 1))
  right_section = crop(shifted_grid, (0, 1), (h, w - 1))
  return hconcat(right_section, left_column)
 
0.425, 12.315008, def gjacddghcbbgefafjdbfafidffebbjcc(grid):
    return tuple(zip(*grid))
 
0.375, 22.385614, def dcbdajgaddfgefcdabbaajcecffjfadi(I):
  objs = objects(I, True, False, True) # Find connected objects of 1s
  shifted_objs = frozenset({recolor(2, shift(obj, (1,1))) for obj in objs}) # Shift and recolor objects
  O = I 
  for obj in shifted_objs:
    O = paint(O, obj) # Paint shifted objects
  O = fill(O, mostcolor(I), mapply(toindices, objs)) # Fill original locations with background
  return O
 
0.33499999999999996, 12.973692, def jjjcffeadbeaefebjebdbifbjbahhfbd(I):
  O = I
  for obj in objects(I, True, False, True):
    O = underpaint(cover(O, obj), recolor(2, shift(obj, (1, 1)))) # Cover original object, then underpaint shifted and recolored object
  return O
 
0.755, 41.579494, def idcfdachfcdbeiafaabgeciahbdbaaaj(I):
  shifted_indices = toindices(shift(asobject(I), (1, 1))) # Find shifted indices of all '1's
  O = fill(I, mostcolor(I), asindices(I)) # Create a grid filled with background color
  return paint(O, recolor(2, toobject(shifted_indices, I))) # Paint the shifted '1's as '2's on the background grid
 
0.15, 11.911249, def ffecadihbdfbecjgidgbhadffiebaaff(I):
  # Find the largest and smallest objects (excluding background)
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  smallest_obj = argmin(objs, size)

  # Calculate target position for smallest object (right of largest object)
  target_j = rightmost(largest_obj) + 1 
  target_pos = (uppermost(smallest_obj), target_j)

  # Shift smallest object to the target position
  shifted_obj = shift(smallest_obj, subtract(target_pos, ulcorner(smallest_obj)))

  # Recolor both objects to 2 and paint on the input grid
  O = paint(paint(I, recolor(2, largest_obj)), recolor(2, shifted_obj))
  return O 
 
0.235, 18.896217, def jefedbicadfjegefbcjbfadfefffafhe(I):
  corners = mapply(ulcorner, objects(I, T, F, T)) # Find top-left corners of '1' objects
  shifted_corners = apply(lambda corner: add(corner, (1, 1)), corners) # Shift corners diagonally
  O = fill(I, 2, shifted_corners) # Fill shifted corner positions with '2'
  return O
 
0.18, 10.030799, def hfgedhedgadiecibbfcafbfeghdbgigb(I):
    def check_adjacent(i, j):
        return ((i - 1, j - 1) in indices and I[i - 1][j - 1] == 1)
    
    indices = asindices(I)
    new_indices = set()
    for i, j in indices:
        if I[i][j] == 1 and check_adjacent(i, j):
            new_indices.add((i, j))

    O = fill(I, 2, frozenset(new_indices))
    return O
 
0.36, 20.492397, def dabhfigafgceefcabecjdcegegdaibaj(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  return tuple(
    tuple(
      I[(i-1) % h][(j-1) % w] if I[(i-1) % h][(j-1) % w] != bg else I[i][j] 
      for j in range(w)
    )
    for i in range(h)
  )
 
0.19, 40.86095, def dafejaiicbcaeihjiaiheeifebeeacdh(I):
  bg = mostcolor(I)
  return tuple(
      tuple(
          I[(i - 1) % len(I)][(j - 1) % len(I[0])] 
          if (i, j) in mapply(toindices, sfilter(objects(I, True, False, False), lambda obj: any(v != bg for v, _ in obj))) 
          else I[i][j] 
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
0.33, 32.36062, def acajabjaibcfebidibafeagjhcidfafe(I):
    objs = objects(I, True, False, True)  # Identify objects formed by '1', excluding background and single cells
    shifted_objs = apply(lambda obj: shift(obj, (1, 1)), objs)  # Shift each object down and right
    recolored_objs = apply(lambda obj: recolor(2, obj), shifted_objs)  # Recolor shifted objects to '2'
    painted_grid = paint(I, merge(recolored_objs))  # Paint the recolored objects onto the original grid
    return painted_grid
 
0.215, 9.1486635, def fihhjdhcejefegjajhfddafcibdefhag(I):
    def process_cell(i, j):
        if I[i][j] == 1:
            new_i, new_j = i + 1, j + 1
            if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
                return 2 
        return I[i][j] 

    O = tuple(tuple(process_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
    return O
 
0.35, 20.246735, def eafhhbefbjdbeabeiceacfdcaeiadcde(I):
    shifted_grid = canvas(0, shape(I)) 
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 1:
                new_i, new_j = i + 1, j + 1
                if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
                    shifted_grid = fill(shifted_grid, 2, {(new_i, new_j)}) 
    O = cellwise(shifted_grid, I, 1) 
    return O
 
0.225, 9.3100195, def ajajaejaaffcecejbbejfihjdecigbja(I):
  # Identify objects of the least common color
  objs = fgpartition(I)
  target_color = leastcolor(I)
  target_objs = colorfilter(objs, target_color)
  
  # Sort objects by size and select
  sorted_objs = sorted(target_objs, key=size)
  obj1 = sorted_objs[0] 
  obj2 = sorted_objs[1] if len(sorted_objs) > 1 else sorted_objs[0]

  # Move smaller object to the top left corner
  new_obj1 = recolor(2, shift(obj1, (-uppermost(obj1), -leftmost(obj1))))
  
  # Move the other object below the repositioned smaller object
  new_obj2 = recolor(2, shift(obj2, (uppermost(new_obj1) + height(new_obj1) + 1, -leftmost(obj2))))

  # Paint the modified objects onto the input grid
  return paint(paint(cover(I, obj1), new_obj1), new_obj2)
 
0.36, 21.350811, def hhgejddehgfbejjcjgdebcaebcjbahce(I):
  h, w = len(I), len(I[0])
  return tuple(
      tuple(
          I[(i + 1) % h][(j + 1) % w] if I[(i + 1) % h][(j + 1) % w] != mostcolor(I) else I[i][j]
          for j in range(w)
      )
      for i in range(h)
  )
 
0.36, 13.225405, def gjfbbbbfaaafeaaajdhcfjcacehajddj(I):
  return paint(
      cover(I, asindices(I)),
      shift(asobject(I), (1, 1))
  )
 
0.625, 13.918654, def gajdbhabfgbdejfgajagigeccbcfcece(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Find connected '1' objects
  O = I
  for obj in objs:
    O = paint(cover(O, obj), recolor(2, shift(obj, (1,1)))) # Replace with '2' and shift diagonally
  return O
 
0.765, 36.692734, def hbcechcjfcdieajcaacbacbeigjfdafj(I):
  O = I
  for obj in objects(I, True, False, False):
    for i, j in toindices(obj):
      if 0 <= i+1 < height(I) and 0 <= j+1 < width(I):
        O = fill(O, 2, {(i+1, j+1)}) # Fill diagonally for each cell of object within bounds
  return O
 
0.18, 40.40948, def fbccfcibadfgeadaieebdfdhafdiefbd(I):
  O = canvas(mostcolor(I), shape(I))  # Create an empty canvas with the input's dimensions and background color
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        new_i, new_j = i + 1, j + 1
        if 0 <= new_i < len(I) and 0 <= new_j < len(row):  # Boundary check
          O = fill(O, 2, {(new_i, new_j)})
        else:  # Keep original value if shifted outside the grid
          O = fill(O, val, {(i, j)})
      else:
        O = fill(O, val, {(i, j)})  # Keep other values unchanged
  return O
 
0.37, 12.966809, def gahbhfhfbcbaegiajcfbfbaeadjhjcig(I):
  h, w = len(I), len(I[0])
  return tuple(
      tuple(
          I[(i - 1) % h][(j - 1) % w] if I[(i - 1) % h][(j - 1) % w] != mostcolor(I)
          else mostcolor(I)
          for j in range(w)
      )
      for i in range(h)
  )
 
0.18, 11.269097, def gccifbbdfccfegbcbbdbcffbgibacfbd(I):
  bg = mostcolor(I)
  upscaled = upscale(I, 2)
  downscaled = downscale(upscaled, 2)
  return tuple(
      tuple(
          downscaled[i][j] if downscaled[i][j] != bg else I[i][j]
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
0.37, 21.586117, def giaiccfhdbdeeddiadadijddgagcadfj(I):
  O = I  # Initialize output with input
  for i, j in product(interval(0, len(I), 1), interval(0, len(I[0]), 1)):
    if index(I, (i, j)) == 1: # Check for '1' at current index
      O = cover(O, {(1, (i, j))}) # Remove '1' from output
      if 0 <= i+1 < len(I) and 0 <= j+1 < len(I[0]):
        O = paint(O, {(2, (i+1, j+1))}) # Paint '2' diagonally if in bounds
  return O
 
0.5800000000000001, 37.338776, def dacacdeffceceeeejigfaiijehjaedfi(I):
  O = I  
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      if I[i][j] == 1:
        for di, dj in dneighbors((0, 0)): 
          ni, nj = i + di + 1, j + dj + 1
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
            O = fill(O, 2, {(ni, nj)})
  return O
 
0.35, 20.246735, def jdifecbcgbeheeaiabbffdcdhfbcbjii(I):
  return tuple(
      tuple(
          I[i-1][j-1] if 0 < i < len(I) and 0 < j < len(I[0]) and I[i-1][j-1] != mostcolor(I) else I[i][j] 
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
0.37, 20.567678, def cfajadfadejhegceiddceeifdhgcdbic(I):
  O = I  # Initialize output as input
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:  # Find '1' cells
        new_i, new_j = i + 1, j + 1  # Calculate shifted indices
        if 0 <= new_i < len(I) and 0 <= new_j < len(row):  # Check bounds
          O = paint(cover(O, {(1, (i, j))}), {(2, (new_i, new_j))}) # Cover '1', paint '2' 
  return O
 
0.215, 14.491382, def gaadfdjedadfefccifdaddeffafhhhbh(I):
  # Identify objects of 1s (excluding background)
  objs = objects(I, T, F, T)
  O = I

  # Iterate over each object
  for obj in objs:
    # Get the top-left corner of the object
    corner_i, corner_j = ulcorner(obj) 

    # Fill the cell to the left with 2 if valid
    if corner_j > 0:
      O = fill(O, 2, {(corner_i, corner_j - 1)})

  return O
 
0.23, 17.453257, def hffbciiiicjbecfbiaffcagfcaceddce(I):
  obj1 = first(objects(I, T, F, T)) 
  obj1 = recolor(2, obj1)
  obj1 = shift(obj1, (2, 1)) 
  O = paint(I, obj1)
  return O
 
0.195, 14.35056, def hididceicefbegeiijaiaaffchejehfh(I):
  objs = objects(I, T, F, T)
  obj1 = argmax(objs, size)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    if obj == obj1:
      obj = recolor(2, obj)
      obj = shift(obj, (2, 1))
    O = paint(O, obj)
  return O
 
0.21000000000000002, 14.037755, def cgccfccfffjdeacaiceajfjdidcbbefg(I):
  obj1 = first(colorfilter(objects(I, T, F, T), 1))
  O = paint(I, recolor(2, shift(obj1, (2, 1))))
  return O
 
0.2, 14.337736, def fchcadeideccedhajfcfhcaiiabccige(I):
    # Find the object with the least color count (smaller object)
    target_object =  argmin(objects(I, T, T, T), lambda obj: colorcount(I, color(obj)))
    
    # Remove the target object from the grid
    I = cover(I, target_object)
    
    # Create a horizontally expanded version of the target object
    expanded_object = recolor(color(target_object), frozenset({(0, 0), (0, 1), (0, 2)}))
    
    # Place the expanded object one row above the original object's upper-left corner
    I = paint(I, shift(expanded_object, (ulcorner(target_object)[0] - 1, ulcorner(target_object)[1])))
    
    return I
 
0.2, 11.717392, def jbdicdiejdbheedajdbiajehjhidjide(I):
    # Assuming the smaller object is always a single cell, find its location
    target_cell = toindices(argmin(objects(I, T, T, T), size)) 
    
    # Get the color of the target cell
    target_color = index(I, first(target_cell))
    
    # Create a horizontal line object with the target color
    line_object = recolor(target_color, frozenset({(0, 0), (0, 1), (0, 2)})) 
    
    # Calculate the position to place the line object (one row above the target cell)
    new_position = add(first(target_cell), (-1, 0)) 
    
    # Paint the line object at the calculated position
    I = paint(I, shift(line_object, new_position)) 
    
    return I
 
0.235, 11.325327, def cjhbdgbbcegbecchbcgbbeaaeeehaedf(I):
    # Extract all objects from the input grid
    objs = objects(I, T, T, T) 
    
    # Find the object with the minimum size (smallest object)
    min_obj = argmin(objs, size) 
    
    # Remove the smallest object from the grid
    I = cover(I, min_obj) 
    
    # Create a horizontal line object with the color of the smallest object
    line_obj = recolor(color(min_obj), frozenset({(0, 0), (0, 1), (0, 2)})) 
    
    # Determine the position to place the line object based on the smallest object's location
    new_pos = (uppermost(min_obj) - 1, leftmost(min_obj))
    
    # Paint the line object at the calculated position
    I = paint(I, shift(line_obj, new_pos)) 
    
    return I
 
0.20500000000000002, 12.940153, def faejadjcbbddefdgiaagdfbccfebgcif(I):
    # Find the object with the minimum number of cells
    target_obj = argmin(objects(I, T, T, T), size)
    
    # Determine the upper-left corner of the target object
    target_corner = ulcorner(target_obj) 
    
    # Create a three-cell horizontal line with the same color as the target object
    line = recolor(color(target_obj), frozenset(zip(repeat(0, 3), range(3)))) 
    
    # Paint the line onto the grid, one row above the target object
    I = paint(I, shift(line, (target_corner[0] - 1, target_corner[1])))
    return I
 
0.225, 70.18224, def hhejdgbbhacaeaccicejebefdfgfecgf(I):
  objs = objects(I, True, False, False)  # Find connected components of '1's
  shifted_objs = frozenset({recolor(2, shift(obj, (2, 1))) for obj in objs}) # Shift and recolor
  O = I
  for obj in shifted_objs:
    O = paint(O, obj) # Paint shifted objects
  O = fill(O, 0, mfilter(objs, toindices)) # Remove original objects
  return O
 
0.425, 12.821953, def geacfhbjchgfedecibccecddjjhgadfa(I):
  objs = partition(replace(I, 0, 2)) # Treat everything as an object, replacing 0 with temporary color
  shifted_objs = frozenset({shift(obj, (2, 1)) for obj in objs if color(obj) == 1}) # Filter for objects originally '1' and shift
  O = canvas(0, shape(I)) # Start with a blank canvas
  for obj in shifted_objs:
    O = paint(O, obj) # Paint shifted objects
  return O
 
0.41000000000000003, 12.459742, def afaiigdhifcbebfjjajeebeibbhbcaae(I):
  indices = ofcolor(I, 1)  # Get indices of all '1's
  shifted_indices = shift(indices, (2, 1)) # Shift indices
  O = fill(I, 0, indices) # Clear original '1' positions
  O = fill(O, 2, shifted_indices) # Fill shifted indices with '2'
  return O
 
0.735, 41.960583, def aeegfbfjedigefaibcdbaddjegegjddf(I):
  return paint(canvas(0, shape(I)), 
               merge(apply(lambda obj: recolor(2, shift(obj, (-1, 1))),
                           objects(I, True, False, False)))) 
 
0.245, 24.11445, def bcbehhihfdaaebjebfdbdeddbeeahhge(I):
    return paint(I, merge(apply(lambda o: recolor(2, shift(o, (-1, 1))), 
                                sfilter(objects(I, True, False, True), 
                                        lambda obj: not bordering(obj, I)))))
 
0.225, 70.18224, def egdbabaejcfaeabciadafcjhebefchfh(I):
  return fill(paint(canvas(0, shape(I)), 
                   merge(apply(lambda obj: recolor(2, shift(obj, (-1, 1))),
                               objects(I, True, False, False)))),
              mostcolor(I), 
              merge(apply(lambda obj: toindices(shift(obj, (-1, 1))), 
                          objects(I, True, False, False))))
 
0.245, 28.63167, def ecjheddebhdeehjebfgiigacbcgdfcfe(I):
  # Find the two largest objects
  objs = objects(I, T, F, T) 
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Recolor the objects
  largest = recolor(TWO, largest)
  second_largest = recolor(TWO, second_largest)

  # Determine shift direction based on relative position
  direction = position(largest, second_largest)

  # Apply the shift
  largest = shift(largest, direction) 

  # Paint the objects onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, second_largest)
  return O
 
0.20500000000000002, 33.75653, def dcacbfajgceeeaifiebeghffdbfbjaea(I):
  # Extract the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate centers of mass for shifting
  center_largest = centerofmass(largest)
  center_second_largest = centerofmass(second_largest)

  # Determine shift direction based on centers of mass
  direction = (sign(center_largest[0] - center_second_largest[0]), 
               sign(center_largest[1] - center_second_largest[1]))

  # Recolor and apply the shift
  largest = shift(recolor(TWO, largest), direction)

  # Paint the objects onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, recolor(TWO, second_largest))
  return O 
 
0.22999999999999998, 31.420555, def fgjbiigifefbebfhbacfaajahhdcdbfb(I):
  # Find the two largest objects (assuming no ties in size)
  objs = objects(I, T, F, T)
  obj_list = sorted(objs, key=size, reverse=True)
  largest = obj_list[0]
  second_largest = obj_list[1]
  
  # Recolor both objects to '2'
  largest = recolor(TWO, largest)
  second_largest = recolor(TWO, second_largest)

  # Define possible shift directions
  shifts = ((0, 1), (1, 0), (0, -1), (-1, 0))

  # Find the shift that maximizes the distance between the objects
  best_shift = max(shifts, key=lambda s: manhattan(shift(largest, s), second_largest))
  largest = shift(largest, best_shift)

  # Paint the shifted objects onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, second_largest)
  return O
 
0.255, 40.323853, def hebbeadbcdeceffgicfbbcdcebegbffa(I):
  # Find objects, sort by size, and extract the largest two
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, size)
  largest = last(sorted_objs)
  second_largest = first(remove(largest, sorted_objs))

  # Determine the shift direction based on object corners
  if uppermost(largest) < uppermost(second_largest): 
    largest_shift = (ONE, ZERO)
    second_largest_shift = (ZERO, ONE)
  else:
    largest_shift = (ZERO, ONE)
    second_largest_shift = (ONE, ZERO)

  # Recolor and apply the shifts
  largest = shift(recolor(TWO, largest), largest_shift)
  second_largest = shift(recolor(TWO, second_largest), second_largest_shift)

  # Paint the objects onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), largest)
  O = paint(O, second_largest)
  return O
 
0.18, 11.269097, def cdfifceehiiaebjjaefcheaabdbeaabb(I):
  # Find the least common color.
  target_color = leastcolor(I)
  
  # Get objects of the target color.
  objs = colorfilter(objects(I, False, False, False), target_color)

  # If no objects of target color exist, return the original grid.
  if not objs:
    return I
  
  # Find the smallest object.
  target_obj = argmin(objs, size)
  
  # Move the object one cell up and one cell right.
  moved_obj = shift(target_obj, (-1, 1)) 
  
  # Recolor the objects to '2'.
  new_obj = recolor(2, moved_obj)

  # Return the modified grid.
  return paint(cover(I, target_obj), new_obj)
 
0.32499999999999996, 38.123547, def cadihebeijfbeeefaagihchegjibejdc(I):
  # Identify the least common object
  target_color = leastcolor(I) 
  target_objs = colorfilter(objects(I, T, T, T), target_color)
  
  # Create a three-cell horizontal line object 
  line_obj = frozenset({(target_color, (0, 0)), (target_color, (0, 1)), (target_color, (0, 2))})
  
  # Clear the original target objects from the grid
  I = cover(I, merge(target_objs))
  
  # Paint the line object above each original target object
  for obj in target_objs:
    I = paint(I, shift(line_obj, (uppermost(obj) - 1, leftmost(obj))))
  return I
 
0.51, 19.88132, def decdbdbjdffbehejiadgeijdiaabajbh(I):
  # Find the least common color and its occurrences
  target_color = leastcolor(I)
  occurrences = ofcolor(I, target_color)
  
  # Create a horizontal line pattern
  line_pattern = {(0, 0), (0, 1), (0, 2)} 
  
  # Clear original occurrences and paint the line pattern above each
  for i, j in occurrences:
    I = cover(I, {(target_color, (i, j))}) # Clear single cell
    I = paint(I, {(target_color, (i - 1, j + k)) for k in range(3)}) # Paint line
  return I
 
0.225, 70.18224, def bcfdijiebfhjededacjfhfjfdhccbjei(I):
  # Identify and remove the least common objects from the grid
  min_color = leastcolor(I)
  I = cover(I, merge(colorfilter(objects(I, T, T, T), min_color)))

  # Create and position the horizontal line object
  line = recolor(min_color, frozenset({(0, 0), (0, 1), (0, 2)}))
  line = shift(line, (-1, 0))  

  # Add the line above each original object location
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i + 1 < len(I) and I[i + 1][j] == min_color) and val != min_color:
        I = paint(I, shift(line, (i, j)))
  return I
 
0.47, 22.801752, def agahciecdeaeefbjifbjiacahjaahehb(I):
  # Directly modify the grid cells 
  target_color = leastcolor(I)
  new_grid = list(list(row) for row in I) # Create a mutable copy of the grid
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == target_color:
        if i > 0:  
          new_grid[i-1][j] = target_color
          if j > 0: new_grid[i-1][j-1] = target_color
          if j < len(row) - 1: new_grid[i-1][j+1] = target_color
        new_grid[i][j] = mostcolor(I) # Replace original cell with background color
  return tuple(tuple(row) for row in new_grid) 
 
0.185, 15.3163805, def cdhbgagjdcbheddjbhieebbcfeghjgab(I):
  shifted_indices = shift(asindices(I), (1, 2)) # Shift all indices down and right
  overlap = intersection(shifted_indices, asindices(I)) # Find overlapping indices
  shifted_ones =  frozenset({(2, idx) for idx in shifted_indices if index(I, idx) == 1}) # Mark shifted '1's
  O = paint(canvas(0, shape(I)), shifted_ones) # Paint shifted '1's as '2's on a blank canvas
  return paint(O, {(1, idx) for idx in overlap if index(I, idx) == 1}) # Restore overlapping '1's 
 
0.39, 14.507891, def djdedihgaaeaechdbgiejbbeeifaaeah(I):
  O = canvas(0, shape(I)) # Start with a blank canvas
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:  # For each '1' in the grid
        new_i, new_j = i + 1, j + 2 # Calculate the shifted location
        if 0 <= new_i < len(I) and 0 <= new_j < len(row): # Check if shifted location is within bounds
          if I[new_i][new_j] != 1: # If the shifted location doesn't already contain a '1'
            O = paint(O, {(2, (new_i, new_j))}) # Paint a '2' at the shifted location
          else:
            O = paint(O, {(1, (new_i, new_j))}) # Otherwise, paint a '1' to preserve it
        else:
          O = paint(O, {(1, (i, j))}) # If out of bounds, keep the original '1'
  return O
 
0.32999999999999996, 14.222111, def ddgdcdejeeffecabjdifciggefjajjfb(I):
    def transform_object(obj):
        direction = (-1, -1) if uppermost(obj) > len(I) // 2 else (1, 1)
        return recolor(2, shift(obj, direction))
    O = paint(canvas(mostcolor(I), shape(I)), merge(apply(transform_object, objects(I, True, False, True))))
    return O
 
0.32499999999999996, 14.715605, def dbcacfafefecedcaaefecfhcdaffhaii(I):
    O = I
    for obj in objects(I, True, False, True):
        shift_direction = (1, 1) if uppermost(obj) < len(I) // 2 else (-1, -1)
        O = move(O, obj, shift_direction)  # Directly move the object on the grid
        O = replace(O, next(iter(obj))[0], 2)  # Replace the original color with '2'
    return O
 
0.32999999999999996, 13.598367, def bbecedjbegaaecehiggeaecfgbfedabb(I):
    def transform_line(obj):
      if uppermost(obj) < len(I) // 2:
        return recolor(2, shift(obj, (1, 1)))
      else:
        return recolor(2, shift(obj, (-1, -1)))

    return paint(canvas(mostcolor(I), shape(I)), 
                 merge(apply(transform_line, objects(I, True, False, True))))
 
0.18, 18.026655, def abhbcccbbahbeidaaejecgfacebcfjah(I):
  # Find the two largest objects directly
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  second_largest = argmax(difference(objs, {largest}), size)

  # Calculate relative position of the two largest objects
  relative_pos = position(largest, second_largest)

  # Determine shift direction based on relative position
  shift_direction = multiply(relative_pos, (-1, 0)) 

  # Recolor and shift the second largest object
  shifted_obj = shift(recolor(TWO, second_largest), shift_direction)

  # Paint the shifted object onto the input grid
  O = paint(I, shifted_obj)
  return O
 
0.16499999999999998, 11.928267, def fhdhdgdibfaheffaagaedcbeehhjcbab(I):
  # Find objects and sort them by size
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: size(obj))

  # Extract the two largest objects
  second_largest = sorted_objs[-2]
  largest = sorted_objs[-1]

  # Determine shift direction based on center of mass
  if centerofmass(largest)[1] < centerofmass(second_largest)[1]:
    shift_direction = RIGHT
  else:
    shift_direction = LEFT 

  # Recolor and shift the second largest object
  recolored_obj = recolor(TWO, second_largest)
  shifted_obj = shift(recolored_obj, shift_direction)

  # Paint the shifted object onto the original grid
  O = paint(I, shifted_obj)
  return O
 
0.32, 38.683666, def facagicbdhddebihbcaefbiceebcaffi(I):
  # 1. Identify objects of the least common color
  target_color = leastcolor(I)
  objs = objects(I, T, T, T)
  target_objs = colorfilter(objs, target_color) 

  # 2. Generate line objects for each target object
  line_objs = set()
  for obj in target_objs:
    ul = ulcorner(obj)
    line_objs.add(frozenset({(TWO, (ul[0]-1, ul[1]-1)), (TWO, (ul[0]-1, ul[1])), (TWO, (ul[0]-1, ul[1]+1))}))

  # 3. Cover original objects and paint line objects
  I = cover(I, merge(target_objs))
  O = paint(I, merge(line_objs))
  return O
 
0.46499999999999997, 18.976597, def bbjccdgfffdfejbfijadefibbibcdacf(I):
  # 1. Find indices of the least common color
  target_color = leastcolor(I)
  indices = ofcolor(I, target_color)

  # 2. Generate line indices shifted from the target indices
  line_indices = set()
  for i, j in indices:
    line_indices |= {(i-1, j-1), (i-1, j), (i-1, j+1)}

  # 3.  Cover original and fill with lines
  I = cover(I, indices)
  O = fill(I, TWO, line_indices)
  return O
 
0.18, 11.269097, def ebbbgachejdcehadbgeichbifehajcee(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  
  # Sort objects by size in descending order
  sorted_objs = order(objs, lambda obj: -size(obj))
  
  # Select the two largest objects
  large_obj, small_obj = sorted_objs[0], sorted_objs[1]
  
  # Ensure the smaller object is truly 'inner'
  if contained(ulcorner(small_obj), toindices(large_obj)) and contained(lrcorner(small_obj), toindices(large_obj)):
    O = paint(paint(canvas(0, shape(I)), small_obj), recolor(2, large_obj))
    return O
  else:
    return I 
 
0.18, 13.462592, def dbaghjffghaaegidaaecaajiciiccihc(I):
  objs = objects(I, T, F, T)
  obj_list = totuple(objs)
  largest_obj = max(obj_list, key=lambda x: size(x))
  second_largest_obj = max((obj for obj in obj_list if obj != largest_obj), key=lambda x: size(x))
  shift_offset = RIGHT if leftmost(largest_obj) < leftmost(second_largest_obj) else LEFT
  shifted_obj = shift(recolor(TWO, second_largest_obj), shift_offset)
  O = paint(I, shifted_obj)
  return O
 
0.33999999999999997, 11.925401, def ffdefffffageegbfijcccbchaaeeeehh(I):
  target_value = leastcolor(I)
  target_objects = colorfilter(objects(I, True, False, False), target_value)
  def reposition(obj):
    return recolor(2, shift(obj, (1, 1)))
  new_objects = apply(reposition, target_objects)
  return paint(cover(I, merge(target_objects)), merge(new_objects))
 
0.24, 28.525074, def dbcffdeaegebebdjidfbbejdafdbdjah(I):
  def transform_object(obj):
    return recolor(2, shift(obj, (1, 1))) if color(obj) == leastcolor(I) else obj
  new_objects = apply(transform_object, objects(I, True, False, False))
  return paint(cover(I, merge(objects(I, True, False, False))), merge(new_objects))
 
0.225, 10.154645, def dhfjggibhccaeibjacacfcbbjafbiiaf(I):
  def process_cell(i, j):
    if I[i][j] == leastcolor(I):
      new_i, new_j = i + 1, j + 1
      if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
        return 2
      else:
        return 0  # Handle out-of-bounds cases by replacing with background color
    else:
      return I[i][j]
  return tuple(tuple(process_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
0.19, 40.70723, def fcacgbcbefdaecjfbagcebdghcdjaidg(I):
  min_color = leastcolor(I)
  new_grid = canvas(0, shape(I))  # Create a blank canvas
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == min_color:
        new_i, new_j = i + 1, j + 1
        if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
          new_grid = paint(new_grid, {(2, (new_i, new_j))})
      else:
        new_grid = paint(new_grid, {(value, (i, j))}) 
  return new_grid
 
0.33, 32.36062, def ibbfcdagheadefdhaehicbhdfdddbidc(I):
  def shift_and_recolor(obj):
    return recolor(2, shift(obj, (1,1)))
  return paint(I, merge(apply(shift_and_recolor, colorfilter(objects(I, True, False, False), leastcolor(I)))))
 
0.215, 51.79651, def bfhedfabfedeedgdbiacgefafchaejcg(I):
  # Find all objects 
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  
  # Identify the target object based on minimum upper-left corner
  target_obj = argmin(objs, lambda obj: ulcorner(obj)[0] * 100 + ulcorner(obj)[1])
  
  # Calculate the new position for the first object
  new_pos_1 = add(lrcorner(target_obj), (-1, 0))

  # Find the second object based on its bounding box intersecting 
  # with the new position of the first object
  second_obj = extract(objs, lambda obj: contained(new_pos_1, backdrop(obj)))

  # Calculate the new position for the second object 
  new_pos_2 =  add(ulcorner(second_obj), (-height(second_obj), 0))

  # Recolor and paint both objects
  O = paint(canvas(0, shape(I)), recolor(2, shift(target_obj, subtract(new_pos_1, lrcorner(target_obj)))))
  O = paint(O, recolor(2, shift(second_obj, subtract(new_pos_2, ulcorner(second_obj)))))
  return O
 
0.29000000000000004, 17.615093, def jdaebdejfaedejdbbeaidbccajdjdhai(I):
  return paint(canvas(mostcolor(I), shape(I)),
               mapply(lambda obj: recolor(2, shift(obj, (1, 1) if uppermost(obj) >= len(I) // 2 else (-1, -1))), 
                      objects(I, True, False, True)))
 
0.16499999999999998, 12.016183, def gdddjcaedfieegcbagfefcfciceebcce(I):
    objs = objects(I, T, F, T)
    
    # Create a list of (size, object) tuples
    sized_objs = frozenset({(size(obj), obj) for obj in objs})
    
    # Extract the two largest objects based on size
    largest = argmax(sized_objs, lambda x: x[0])[1]
    second_largest = argmax(remove(largest, sized_objs), lambda x: x[0])[1]
    
    # Calculate shift direction 
    shift_dir = (0, 1) if centerofmass(largest)[1] < centerofmass(second_largest)[1] else (0, -1)
    
    # Shift and recolor
    shifted_obj = shift(recolor(2, second_largest), shift_dir)
    O = paint(I, shifted_obj)
    return O
 
0.245, 57.480537, def bbbaadebaaefefeeadfgffcgeaabafad(I):
  # 1. Find the index of the least common color
  target_index = first(ofcolor(I, leastcolor(I)))
  
  # 2. Calculate the starting index of the 3-cell line
  line_start = add(target_index, (-2, -1))
  
  # 3. Generate indices for the 3-cell line
  line_indices = frozenset({add(line_start, (0, i)) for i in range(3)})
  
  # 4. Cover the original color and paint the line
  O = paint(replace(I, I[target_index[0]][target_index[1]], ZERO), recolor(TWO, line_indices))
  
  return O
 
0.235, 10.38303, def dfhhjcebgdgaedjgaabiaadeieaijiea(I):
    # 1. Find the smallest object's bounding box
    target_obj = argmin(objects(I, T, T, T), size)
    box_indices = box(target_obj)

    # 2. Find the upper-middle index of the bounding box
    target_index = (uppermost(box_indices), leftmost(box_indices) + width(box_indices) // 2)

    # 3. Construct the line indices
    line_indices = frozenset({(target_index[0]-1, target_index[1]-1), (target_index[0]-1, target_index[1]), (target_index[0]-1, target_index[1]+1)})

    # 4. Cover the original object and paint the line
    O = paint(cover(I, target_obj), recolor(TWO, line_indices))

    return O
 
0.24, 11.838955, def jhbbbdbjjfeiebfbjadbafbddffjjijd(I):
    # 1. Find smallest object and its center
    obj = argmin(objects(I, T, T, T), size)
    center_i, center_j = centerofmass(obj)

    # 2. Create a horizontal line object 
    line = recolor(color(obj), frozenset({(0, -1), (0, 0), (0, 1)}))

    # 3. Position the line above the object's center
    shifted_line = shift(line, (center_i - 1, center_j - 1))

    # 4. Cover the original object and paint the new line
    O = paint(cover(I, obj), shifted_line)
    return O
 
0.24, 11.415123, def fjfeafbafaebedibagacgebeededibhc(I):
  # 1. Find the smallest object 
  target_obj = argmin(objects(I, T, T, T), size)
  
  # 2. Get the upper-left corner of the object
  i, j = ulcorner(target_obj) 
  
  # 3. Create line indices one row above the object
  line_indices = frozenset({(i-1, j-1), (i-1, j), (i-1, j+1)})
  
  # 4. Cover the original object and paint the line
  O = paint(cover(I, target_obj), recolor(TWO, line_indices))
  
  return O
 
0.345, 31.744423, def jcdeddfcbfbcebdgbdacaedhffeibcgf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True) # Identify all objects
  top_obj = argmin(objs, lambda obj: ulcorner(obj)[0]) # Find the topmost object
  bottom_obj = argmax(objs, lambda obj: lrcorner(obj)[0]) # Find the bottommost object
  
  O = paint(canvas(0, shape(I)), recolor(2, shift(top_obj, (height(top_obj), 0)))) # Shift & recolor top object
  O = paint(O, recolor(2, shift(bottom_obj, (-height(bottom_obj), 0)))) # Shift & recolor bottom object
  return O
 
0.315, 24.03883, def beajbhjbhedceffdabejgafedbbfaced(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  top_obj = argmin(objs, lambda obj: ulcorner(obj)[0])
  bottom_obj = argmax(objs, lambda obj: lrcorner(obj)[0])

  O = I
  for obj in [top_obj, bottom_obj]:
    direction = (1,-1) if obj == top_obj else (-1,1) 
    for v, (i, j) in obj:
      new_i = i + height(obj) * direction[0]
      O = fill(O, 2, {(new_i, j)})
  return O
 
0.46499999999999997, 13.841415, def ehjibabeedhcegafihihdjedfciahhag(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  def transform_obj(obj):
    direction = (height(obj), 0) if uppermost(obj) < len(I) // 2 else (-height(obj), 0)
    return recolor(2, shift(obj, direction))
  
  transformed_objs = apply(transform_obj, objs)
  O = paint(canvas(0, shape(I)), merge(transformed_objs))
  return O
 
0.235, 46.20061, def gegaddfcbadfeecajcefbbfhdaceccac(I):
  shifted_grid = vconcat(bottomhalf(I), tophalf(I)) # Shift the entire grid vertically
  O = cellwise(I, shifted_grid, 0)  # Use cellwise comparison to determine where '1's match after shifting
  O = replace(O, 1, 2) # Recolor the matching '1's to '2'
  return O 
 
0.16, 20.401722, def cjffdbcedaciegffbdaaehhhdffbfcdc(I):
  # Find the two largest objects
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  remaining_objs = remove(largest, objs)
  second_largest = argmax(remaining_objs, size)
  # Determine the relative position 
  rel_pos = position(largest, second_largest)
  # Shift the second largest object based on relative position
  if rel_pos == (1, 1):
    second_largest = shift(second_largest, (-1, -1))
  elif rel_pos == (-1, 1):
    second_largest = shift(second_largest, (1, -1))
  elif rel_pos == (1, -1):
    second_largest = shift(second_largest, (-1, 1))
  elif rel_pos == (-1, -1):
    second_largest = shift(second_largest, (1, 1))
  # Recolor and combine objects
  O = paint(I, recolor(2, combine(largest, second_largest)))
  return O
 
0.16999999999999998, 10.146631, def efdcdbbgijciecddibijbbhccadbccgf(I):
  # Find all objects
  objs = objects(I, T, F, T)
  # Find the two objects with the most dissimilar sizes
  size_diff = lambda a, b: abs(size(a) - size(b))
  most_dissimilar = argmax(product(objs, objs), lambda pair: size_diff(*pair))
  largest, smallest = most_dissimilar
  # Recolor the two most dissimilar objects to 2
  O = paint(paint(I, recolor(2, largest)), recolor(2, smallest))
  return O
 
0.215, 10.309644, def hjadfdfcjfeeedadbddeaedadfgcfhba(I):
  def shift_cell(i, j, target_color):
    if I[i][j] == target_color:
      new_i, new_j = i - 1, j + 1
      if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
        return 2
      else:
        return 0
    else:
      return I[i][j]

  target_color = leastcolor(I)
  return tuple(tuple(shift_cell(i, j, target_color) for j in range(len(I[0]))) for i in range(len(I)))
 
0.20500000000000002, 12.344284, def gdbjcaadjefceijaaaffaifcbecbdebf(I):
  # Find bounding box of smallest object
  small_obj = argmin(objects(I, T, T, T), size)
  box_ind = box(small_obj)
  # Find upper-middle index of the bounding box
  target_i = uppermost(box_ind) - 1
  target_j = leftmost(box_ind) + width(box_ind) // 2 
  # Construct the line object
  line_obj = recolor(2, frozenset({(target_i, target_j-1), (target_i, target_j), (target_i, target_j+1)}))
  # Combine objects
  O = paint(I, line_obj)
  return O
 
0.21, 15.890548, def gfhjfbefecceeiheicfbejcffcfghidj(I):
  # Find the smallest object
  min_obj = argmin(objects(I, T, T, T), size)
  # Calculate line position
  line_pos = subtract(centerofmass(min_obj), (ONE, ONE))
  # Create line object
  line = recolor(2, shift(frozenset({(-1,-1), (-1,0), (-1,1)}), line_pos))
  # Combine object with line 
  O = paint(I, line)
  return O
 
0.5700000000000001, 45.51875, def dfbddahcbedcedjcidcfabaacfbgchfb(I):
  top = objects(tophalf(I), False, False, False)
  bottom = objects(bottomhalf(I), False, False, False)
  h = height(I)
  O = canvas(0, shape(I))
  for obj in top:
    O = paint(O, recolor(2, shift(obj, (h // 2, 0))))
  for obj in bottom:
    O = paint(O, recolor(2, shift(obj, (-h // 2, 0))))
  return O
 
0.43, 13.173566, def ijaagcfegjhbedabiddfgcefcjchacdd(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        new_i = (i + len(I) // 2) % len(I)
        O = fill(O, 2, {(new_i, j)})
  return O
 
0.295, 38.309586, def iebbbfjdaceiedebbeaebcihffecdiff(I):
  O = canvas(0, shape(I))
  for i in range(len(I) // 2):
    O = paint(O, recolor(2, shift(toobject(asindices(I[i:i+1]), I), (len(I) // 2, 0))))
    O = paint(O, recolor(2, shift(toobject(asindices(I[len(I)-i-1:len(I)-i]), I), (-len(I) // 2, 0))))
  return O
 
0.14, 10.393836, def eedijccfjefceedcbbaaeeagehiccigb(I):
  # Find all objects
  objs = objects(I, T, F, T)
  # Find the largest object
  largest_obj = argmax(objs, size)
  # Create a grid with only the largest object
  grid_largest = paint(canvas(0, shape(I)), largest_obj)
  # Find the object closest to the largest object in the original grid
  closest_obj = argmin(objs, lambda obj: manhattan(obj, largest_obj))
  # Recolor the largest object and the closest object to 2 in the original grid
  O = paint(paint(I, recolor(2, largest_obj)), recolor(2, closest_obj))
  return O
 
0.19, 13.985688, def dgdfbihgefchejdfaiggcdcfefcheidi(I):
    # Find objects, excluding background, and sort by size
    objs = order(objects(I, T, F, T), size)[::-1]
    # Extract the two largest objects
    a, b = objs[0], objs[1]
    # Recolor the largest object to 2
    a = recolor(2, a)
    # Calculate the difference in center coordinates
    i_diff, j_diff = subtract(centerofmass(a), centerofmass(b))
    # Determine the shift direction based on the coordinate difference
    direction = (sign(i_diff), sign(j_diff))
    # Shift the second largest object
    b = shift(b, direction)
    # Paint the transformed objects back onto the grid
    O = paint(paint(I, a), b) 
    return O
 
0.14, 10.356232, def ajdfibdcfjbgecidaffdfbebecbajgac(I):
    # Identify all objects in the input grid
    objs = objects(I, T, F, T)
    # Sort the objects based on their size in descending order
    sorted_objs = order(objs, size)[::-1]
    # Select the largest and second largest objects
    largest_obj = sorted_objs[0]
    second_largest_obj = sorted_objs[1]
    # Recolor the largest object to 2
    recolored_obj = recolor(2, largest_obj)
    # Determine the vertical shift direction based on object positions
    if uppermost(largest_obj) < uppermost(second_largest_obj):
        shift_direction = (1, 0)  # Shift down
    else:
        shift_direction = (-1, 0)  # Shift up
    # Shift the second largest object
    shifted_obj = shift(second_largest_obj, shift_direction)
    # Paint the transformed objects onto the original grid
    O = paint(paint(I, recolored_obj), shifted_obj)
    return O
 
0.275, 28.573385, def hhhfbbadedabecadjjdifeecddbacjec(I):
    # Extract objects from the input, excluding background, and order by size
    x1 = order(objects(I, T, F, T), size)[::-1]
    # Get the two largest objects
    x2, x3 = x1[0], x1[1] 
    # Recolor the largest object to '2'
    x4 = recolor(2, x2)
    # Calculate the vertical distance between the objects' centers
    x5 = subtract(centerofmass(x2)[0], centerofmass(x3)[0])
    # Determine the shift direction based on the distance: down if positive, up otherwise
    x6 = (1, 0) if x5 > 0 else (-1, 0)
    # Shift the second largest object
    x7 = shift(x3, x6) 
    # Paint the transformed objects onto a blank canvas of the input's size
    O = paint(paint(canvas(0, shape(I)), x4), x7) 
    return O
 
0.37, 11.742897, def hhbcceddbehiebifjajafafacbaecdfj(I):
  objs = objects(I, False, False, False)  # Identify all objects in the grid
  O = I
  for obj in objs:
    shifted_obj = shift(obj, (1, 1))  # Shift each object diagonally
    O = paint(O, shifted_obj)  # Paint the shifted object onto the grid
    if color(obj) == 1:  # If the object was a '1' object
      O = fill(O, 2, toindices(obj))  # Fill the original location with '2's
  return O 
 
0.92, 11.715837, def aecbhcfabfcjefchifaiehbaebecceie(I):
  ones = objects(replace(I, 0, 1), True, False, False)  # Treat all non-1 digits as background
  others = objects(I, True, False, True)  # Identify other objects without considering the background
  O = fill(I, 0, asindices(I))  # Create an empty canvas
  for obj in ones:
    O = paint(O, shift(obj, (1, 1)))  # Move and paint the '1' objects
    O = fill(O, 2, toindices(obj))  # Replace the original location of '1' objects with '2's
  for obj in others:
    O = paint(O, shift(obj, (1, 1)))  # Move and paint other objects
  return O
 
0.385, 32.23804, def cbfaaefdbbffejfgidfaegcdbaabahhg(I):
  O = I
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      if I[i][j] != 0:  # Check if the cell is not background
        O = fill(O, 2 if I[i][j] == 1 else I[i][j], {(i, j)})  # Fill with 2 if the cell was 1, otherwise keep the original value
        O = fill(O, I[i][j], {(i + 1, j + 1)})  # Move the digit diagonally
  return O
 
0.39, 31.71874, def acghaficfjbaefbdadfigaacgdbccdbd(I):
  shifted_grid = shift(asobject(I), (1, 1)) # Shift all non-zero cells
  O = paint(canvas(0, shape(I)), shifted_grid) # Create a blank canvas and paint shifted cells
  for i, j in ofcolor(I, 1):  # Find original positions of '1's
      if 0 <= i + 1 < len(I) and 0 <= j + 1 < len(I[0]): # Bounds check
        O = fill(O, 2, {(i, j)})  # Fill original '1' positions with '2's 
  return O
 
0.32999999999999996, 15.104398, def daafhaiedejcehediadficcaddbiefah(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      mpapply(
          lambda obj, offset: recolor(2, shift(remove(extract(obj, lambda x: x[1][1] == leftmost(obj)), obj), offset)),
          objects(I, True, False, True),
          repeat((1, 1), size(objects(I, True, False, True)))
      )
  )
 
0.295, 13.923218, def jajeijafecdeeaeebdggdeheebeheefh(I):
  # Find all objects
  objs = objects(I, T, F, T)
  # Create an empty canvas
  O = canvas(0, shape(I))
  # Paint the outline of each object onto the canvas
  for obj in objs:
    O = paint(O, recolor(2, box(obj)))
  return O
 
0.21000000000000002, 8.745558, def gaefhaehdcfcehcfjihiahjdbcbfcbbh(I):
  # Find the background color
  bg_color = mostcolor(I)
  # Create a set to store outline indices
  outline_indices = set() 
  # Iterate through each cell in the grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If a cell is not background and has a background neighbor, it's an outline cell
      if I[i][j] != bg_color and any(I[i+di][j+dj] == bg_color for di, dj in [(0,1),(0,-1),(1,0),(-1,0)] if 0<=i+di<len(I) and 0<=j+dj<len(I[0])):
        outline_indices.add((i,j))
  # Fill the outline indices with '2' on the input grid
  O = fill(I, 2, frozenset(outline_indices)) 
  return O
 
0.9, 70.12488, def efhhacjagdgeeghebiachdaffjdajehe(I):
  # Apply dilation followed by erosion to find outline
  dilated = mapply(lambda loc: dneighbors(loc), asindices(I)) 
  eroded = mapply(lambda loc: dneighbors(loc), asindices(I)) - asindices(I)
  outline = dilated - eroded
  # Recolor the outline to '2' on a copy of the input grid
  O = fill(I, 2, outline) 
  return O
 
0.2, 8.967761, def bbbajdifdgedeaebbcadfeejfdcbciae(I):
  O = I # Create a copy of the input grid
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] != mostcolor(I) and any(I[ni][nj] == mostcolor(I) for ni, nj in [(i-1,j), (i+1,j), (i,j-1), (i,j+1)]):
        # Check if the current cell is part of an object and has a background neighbor
        O = paint(O, {(2, (i,j))}) # If so, recolor the cell to '2'
  return O
 
0.16999999999999998, 13.185193, def abgdadecbfhjejcdjhfddhcgabcffcbf(I):
  shifted_indices = shift(asindices(I), (1, 1)) 
  recolored_obj = recolor(2, shifted_indices)
  return paint(canvas(0, shape(I)), toobject(shifted_indices, I))
 
0.5549999999999999, 34.395905, def gafahdecajjiecbfjjeifdihfdcaieha(I):
  def process_row(row, j_offset):
    return tuple(2 if 0 <= i + 1 < len(I) and 0 <= j + j_offset < len(row) else 0 for i, j in enumerate(range(len(row)))) 
  return tuple(process_row(row, j_offset) for j_offset, row in enumerate(I))
 
0.295, 11.790835, def cabaddbeajadebjfbdiihfbddhicfedb(I):
  # Find the largest object and its color
  largest_obj = argmax(objects(I, T, F, T), size)
  largest_color = color(largest_obj)
  # Find the second largest object
  second_largest_obj = argmax(objects(I, T, F, T) - {largest_obj}, size)
  # Determine the shift direction
  shift_dir = position(largest_obj, second_largest_obj)
  # Shift the second largest object
  shifted_obj = shift(second_largest_obj, shift_dir)
  # Paint the transformed objects onto the input grid
  O = paint(replace(I, largest_color, 2), shifted_obj)
  return O
 
0.275, 36.97397, def ccchbjafebadefdbjfcaccieabaeddbh(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  rest = objs - {largest}
  second_largest = argmax(rest, size)
  v = position(largest, second_largest)
  O = paint(paint(canvas(mostcolor(I), shape(I)), recolor(2, largest)), shift(second_largest, v))
  return O
 
0.225, 48.235004, def aheebeejddbhebbgjebbcceicbhijecc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  large_obj = argmax(objs, size)
  
  # Calculate the center of the largest object
  center_large = centerofmass(large_obj)

  # Define potential diagonal directions
  directions = [(-1, 1), (1, 1)]

  # Find a smaller object in one of the diagonal directions
  for direction in directions:
    target_loc = add(center_large, direction)
    target_obj = extract(objs, lambda obj: contained(target_loc, toindices(obj)))
    if target_obj:
      break
  
  # Recolor the target object and the largest object
  O = paint(paint(canvas(0, shape(I)), recolor(2, large_obj)), recolor(2, target_obj))
  return O
 
0.9, 10.328474, def hfcacfcfcedaefhaacbgiagdcifgejea(I):
  # Partition the grid into objects
  objs = partition(I)
  
  # Find the largest object
  large_obj = argmax(objs, size)
  
  # Calculate the bounding box of the largest object
  large_box = backdrop(large_obj)
  
  # Find an object overlapping with a diagonal neighbor of the bounding box
  target_obj = extract(objs, lambda obj: any(intersection(neighbors(loc), toindices(obj)) for loc in corners(large_box)))
  
  # Recolor the objects
  O = paint(paint(canvas(0, shape(I)), recolor(2, large_obj)), recolor(2, target_obj))
  return O 
 
0.225, 36.051662, def cdbhadbabajdehdiiiaceadbaajjbdaa(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  large_obj = argmax(objs, size)

  # Calculate the center of mass of the largest object
  center_l = centerofmass(large_obj)

  def distance_from_center(obj):
    center_o = centerofmass(obj)
    return subtract(center_o, center_l)

  # Find an object closest to the center of the largest object (excluding itself)
  target_obj = argmin(remove(large_obj, objs), lambda obj: abs(distance_from_center(obj)[0]) + abs(distance_from_center(obj)[1]))
  
  # Recolor the objects
  O = paint(paint(canvas(0, shape(I)), recolor(2, large_obj)), recolor(2, target_obj))
  return O 
 
0.345, 20.111364, def hcbabbdhecebeehebciffagcjbdcihbh(I):
  def transform_obj(obj):
    min_j = leftmost(obj)
    return frozenset((2, (i + 1, j + 1)) for v, (i, j) in obj if j != min_j)
  
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(apply(transform_obj, objects(I, True, False, True)))
  )
 
0.265, 9.494019, def dbhjjgfcfghaefeibaiccafaafdbegce(I):
  objs = objects(I, T, F, T) # Extract all objects from the input grid
  if len(objs) < 2:
    return I # Return the input if there's only one or zero objects
  largest = argmax(objs, size) # Find the largest object
  others = objs - {largest} # Get all objects except the largest
  isolated = sfilter(others, lambda obj: all(manhattan(obj, other) > 1 for other in others - {obj})) # Identify isolated objects
  bottom_right = argmax(others, lambda obj: lrcorner(obj)[0] + lrcorner(obj)[1]) # Find the bottom-right most object
  to_recolor = isolated | {bottom_right} # Combine isolated objects and the bottom-right most object
  O = I # Create a copy of the input grid
  for obj in to_recolor:
    O = paint(O, recolor(2, obj)) # Recolor selected objects to '2'
  return O
 
0.755, 41.579494, def cbiigggddaecedbbijcgiijfjjbfebae(I):
  return paint(canvas(0, shape(I)), 
               sfilter(
                 apply(lambda c: (2, (c[0] + 1, c[1] + 1)), asindices(I)), 
                 lambda x: 0 <= x[1][0] < len(I) and 0 <= x[1][1] < len(I[0]))) 
 
0.225, 9.3100195, def abeicdccgihjehfdjfhffgfidjiccgge(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  large_obj = argmax(objs, size)
  
  # Find the closest adjacent object using Manhattan distance
  target_obj = argmin(objs, lambda obj: manhattan(obj, large_obj) if adjacent(obj, large_obj) else 100) 
  
  # Recolor the objects
  O = replace(replace(I, color(large_obj), 2), color(target_obj), 2)
  return O
 
0.9, 70.12488, def fchacciccfebedifadacdecddebbfcda(I):
  large_obj = argmax(partition(I), size)
  
  # Find an object sharing a column with the largest object 
  target_obj = extract(partition(I), lambda obj: vmatching(obj, large_obj) and obj != large_obj)
  
  # Recolor on a blank canvas
  O = paint(canvas(0, shape(I)), recolor(2, large_obj))
  O = paint(O, recolor(2, target_obj))
  return O
 
0.225, 35.34374, def bacdjhfhdaeeeecdicgbghfiaceechgd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  large_obj = argmax(objs, size)
  
  # Find an object directly above or below the largest object
  target_obj = extract(objs, lambda obj: hmatching(obj, large_obj) and not vmatching(obj, large_obj))
  
  # Paint on a blank canvas using a loop
  O = canvas(0, shape(I))
  for obj in (large_obj, target_obj):
    for v, (i, j) in obj:
      O = fill(O, 2, {(i, j)})
  return O
 
0.315, 10.721712, def fgijicdcfeeceidjbaegedbcaeahhdea(I):
  def transform_object(obj):
    return recolor(2, shift(obj, (-1, 1))) 
  
  return paint(canvas(mostcolor(I), shape(I)), 
               merge(apply(transform_object, objects(I, True, False, True))))
 
0.215, 10.309644, def ecedcefcfjceebgfiieiiacaafehdfdj(I):
  def process_cell(v, i, j):
    return (2, (i-1, j+1)) if v != mostcolor(I) and 0 <= i-1 and j+1 < len(I[0]) else (mostcolor(I), (i, j))

  return tuple(
    tuple(process_cell(I[i][j], i, j)[0] for j in range(len(I[0])))
    for i in range(len(I))
  )
 
0.215, 10.161494, def ahjchdbabebcebabbgfadfagdeehdhcg(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
    return I
  bg = mostcolor(I)
  largest = argmax(objs, size)
  others = sorted(objs - {largest}, key=size)
  if len(others) > 1:
    smallest = others[0]
    second_smallest = others[1]
  else:
    smallest = others[0]
    second_smallest = smallest
  O = paint(I, recolor(2, second_smallest))
  if vline(smallest):
    O = paint(O, recolor(2, {(2, (uppermost(largest), leftmost(largest) + width(largest) // 2))}))
  else:
    O = paint(O, recolor(2, {(2, (i, leftmost(largest))) for i in range(uppermost(largest), lowermost(largest) + 1)}))
  return O
 
0.215, 10.5546255, def dhcabigbhaddecbcibibfafcgedacjbi(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
    return I
  bg = mostcolor(I)
  largest = argmax(objs, size)
  others = sorted(objs - {largest}, key=size)
  target = others[1] if len(others) > 1 else others[0]
  O = paint(I, recolor(2, target))
  if colorcount(target, bg) == 0: 
    O = paint(O, recolor(2, {(2, (uppermost(largest), leftmost(largest) + width(largest) // 2))}))
  else:
    O = paint(O, recolor(2, {(2, (i, leftmost(largest))) for i in range(uppermost(largest), lowermost(largest) + 1)}))
  return O
 
0.2, 10.555562, def ffcjjbihdbajeddaafadabbdgiafdaff(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
    return I
  bg = mostcolor(I)
  largest = argmax(objs, size)
  target = argmin(objs - {largest}, lambda obj: colorcount(obj, bg) * 100 + size(obj))
  O = paint(I, recolor(2, target))
  if colorcount(target, bg) == 0:
    O = paint(O, recolor(2, {(2, (uppermost(largest), leftmost(largest) + width(largest) // 2))}))
  else:
    O = paint(O, recolor(2, {(2, (i, leftmost(largest))) for i in range(uppermost(largest), lowermost(largest) + 1)}))
  return O
 
0.215, 10.536958, def baihebaeecgcebbabaeieeghbifeafhc(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
    return I
  bg = mostcolor(I)
  largest = argmax(objs, size)
  smallest = argmin(objs - {largest}, size)
  O = paint(I, recolor(2, smallest if len(objs) == 2 else argmin(objs - {largest, smallest}, size)))
  if vline(smallest):
    O = paint(O, recolor(2, {(2, (uppermost(largest) + height(largest) // 2, leftmost(largest)))})) 
  else:
    O = paint(O, recolor(2, {(2, (uppermost(largest), j)) for j in range(leftmost(largest), rightmost(largest) + 1)}))
  return O
 
0.36, 13.225405, def aecahahdbcageeccaafegchcbafadfbc(I):
    def shift_object(obj):
        return sfilter(apply(lambda cell: ((cell[0], (cell[1][0] + 1, cell[1][1] + 1)) 
                                            if 0 <= cell[1][0] + 1 < len(I) and 0 <= cell[1][1] + 1 < len(I[0]) 
                                            else (0, (-1, -1))), obj), 
                      lambda x: x[1] != (-1, -1))

    return paint(canvas(0, shape(I)), merge(apply(shift_object, partition(I))))
 
0.255, 55.649864, def bbdgcebbdbicecbbjaeihbchedbeghde(I):
  # 1. Find all non-background objects
  objs = objects(I, T, F, T) 
  # 2. Find the smallest object 
  smallest = argmin(objs, size)
  # 3. Find the largest object
  largest = argmax(objs, size)
  # 4. Recolor the smallest object to 2
  recolored_smallest = recolor(2, smallest)
  # 5. Calculate the shift direction
  shift_direction = position(smallest, largest)
  # 6. Shift the smallest object
  shifted_smallest = shift(recolored_smallest,  astuple(crement(shift_direction[0]), crement(shift_direction[1]))) 
  # 7. Paint the transformed object onto a blank canvas
  O = paint(canvas(mostcolor(I), shape(I)), shifted_smallest)
  return O 
 
0.24, 13.407529, def hdcgjebfaacfeadcidddibfcbgbhbiii(I):
  # 1. Find the smallest object
  smallest_obj = argmin(objects(I, T, T, T), size)
  # 2. Find the largest object
  largest_obj = argmax(objects(I, T, T, T), size)
  # 3. Calculate the relative position of the smallest object to the largest
  relative_pos = position(smallest_obj, largest_obj)
  # 4. Calculate the adjusted shift vector
  shift_vector = (crement(relative_pos[0]), crement(relative_pos[1]))
  # 5. Shift the smallest object towards the largest
  shifted_obj = shift(smallest_obj, shift_vector)
  # 6. Recolor the shifted object to '2'
  recolored_obj = recolor(2, shifted_obj)
  # 7. Paint the recolored object onto the original image
  O = paint(cover(I, smallest_obj), recolored_obj)
  return O
 
0.275, 40.90601, def eeafedfdfcfheffijbbbdhfejaddidjc(I):
  # 1. Extract all objects from the input
  objs = objects(I, T, F, T)
  # 2. Find the object with the minimum size
  smallest = argmin(objs, size)
  # 3. Find the object with the maximum size
  largest = argmax(objs, size)
  # 4. Calculate the direction to move the smallest object towards the largest
  direction = gravitate(smallest, largest)
  # 5. Shift the smallest object by the calculated direction
  shifted = shift(smallest, direction)
  # 6. Create a new canvas with the same dimensions and background color as the input
  new_canvas = canvas(mostcolor(I), shape(I))
  # 7. Paint the largest object onto the new canvas
  new_canvas = paint(new_canvas, largest)
  # 8. Recolor the shifted smallest object to 2
  recolored = recolor(2, shifted)
  # 9. Paint the recolored and shifted object onto the new canvas
  O = paint(new_canvas, recolored)
  return O
 
0.28, 43.09395, def chbcfdfdbigfedagbddgjabcggcdahie(I):
    # Find all objects in the input grid, excluding the background
    objs = objects(I, T, F, T)
    # Find the smallest object
    smallest = argmin(objs, size)
    # Find the largest object
    largest = argmax(objs, size)
    # Determine if the smallest object should move horizontally or vertically
    if hmatching(smallest, largest):
        move_direction = (sign(centerofmass(largest)[0] - centerofmass(smallest)[0]), 0)
    else:
        move_direction = (0, sign(centerofmass(largest)[1] - centerofmass(smallest)[1]))
    # Move the smallest object one step closer to the largest object
    moved_smallest = shift(smallest, move_direction)
    # Recolor the moved smallest object to 2
    recolored_smallest = recolor(2, moved_smallest)
    # Create a blank canvas with the same size and background color as the input grid
    canvas_ = canvas(mostcolor(I), shape(I))
    # Paint the moved and recolored smallest object onto the canvas
    O = paint(canvas_, recolored_smallest)
    # Paint the largest object onto the canvas
    O = paint(O, largest)
    return O
 
0.29000000000000004, 11.510902, def ccagegeiecbdehbhbfbdfifaeehgeddf(I):
  return paint(
           canvas(mostcolor(I), shape(I)),
           merge(
             apply(lambda obj: recolor(2, shift(obj, subtract(UP, RIGHT))), 
                   objects(I, True, False, True))
           )
         )
 
0.2, 8.790019, def efdfcbadecafedhijahcgfcbheedijce(I):
  bg_color = mostcolor(I)
  outline = set()
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != bg_color:
        if (i == 0 or I[i-1][j] == bg_color or 
            j == len(I[0])-1 or I[i][j+1] == bg_color):
          outline.add((i,j))
  return fill(I, 2, frozenset(outline))
 
0.18, 11.269097, def afcbgeghfhcaefdaiaaaicgddbfeafgc(I):
  return paint(
           fill(I, 2, frozenset((i,j) for i in range(len(I)) for j in range(len(I[0])) if i==0 or j==len(I[0])-1)),
           asobject(I)
         )
 
0.235, 58.806156, def jdgcddfbbhdeecfabddfaiebhegdaefd(I):
  return paint(
    cover(I, mapply(lambda obj: frozenset((i,j) for i,j in toindices(obj) if i!=0 and j!=len(I[0])-1), objects(I, False, False, True))),
    mapply(lambda obj: frozenset((2, (i,j)) for i,j in toindices(obj) if i==0 or j==len(I[0])-1), objects(I, False, False, True))
  )
 
0.18, 11.230135, def ggafaabbbibfejcdiefeccfdffejeegi(I):
  bg = mostcolor(I)
  return tuple(
    tuple(
      2 if (j == len(row)-1 or i == 0) and v != bg else v 
      for j, v in enumerate(row)
    ) 
    for i, row in enumerate(I)
  )
 
0.265, 7.5582013, def ibfjbjcjjbajebdajfdfggbbibfeeffa(grid):
  objs = objects(grid, T, F, F) # Identify all objects
  bg = mostcolor(grid) # Determine background color
  for obj in objs:
    if color(obj) == 1: # Filter for objects with color '1'
      if hline(obj): # Horizontal object condition
        offset = (height(obj)+1, 0) 
      else: # Other object condition
        offset = (1, 1)
      grid = move(grid, obj, offset) # Move the object
      grid = paint(grid, recolor(2, shift(obj, offset))) # Recolor moved object to '2'
  return grid
 
0.27, 9.081131, def bcaachefigaaeaajabcacejhhffbdabc(grid):
  for i in range(height(grid)):
    for j in range(width(grid)):
      if grid[i][j] == 1:
        if i + 1 < height(grid) and grid[i + 1][j] == 1: # Check for horizontal line
          obj_height = 1
          while i + obj_height < height(grid) and grid[i + obj_height][j] == 1:
            obj_height += 1
          grid = fill(grid, mostcolor(grid), {(i + k, j) for k in range(obj_height)}) # Remove original object
          grid = fill(grid, 2, {(i + obj_height + 1 + k, j) for k in range(obj_height)}) # Draw at new position
        else:
          grid = fill(grid, mostcolor(grid), {(i, j)}) # Remove original cell
          grid = fill(grid, 2, {(i+1, j+1)}) # Draw at new position
  return grid 
 
0.245, 8.464962, def diaafbcffchbeefgjebcefcdhacfagbb(I):
    O = canvas(mostcolor(I), shape(I)) # Create empty canvas
    for obj in objects(I, T, F, F):
      c = color(obj)
      if c == 1:
        if hline(obj):
          O = paint(O, recolor(2, shift(obj, (height(obj) + 1, 0)))) # Move and recolor horizontal lines
        else:
          O = paint(O, recolor(2, shift(obj, (1, 1)))) # Move and recolor other objects
      else:
        O = paint(O, obj) # Directly paint other colored objects 
    return O
 
0.245, 43.258896, def iagbbheeghcdejjfaffefgfdbbfadcic(grid):
  def move_object(obj):
    if hline(obj):
      return recolor(2, shift(obj, (height(obj) + 1, 0))) # Move and recolor horizontal lines
    return recolor(2, shift(obj, (1, 1))) # Move and recolor other objects

  objs = objects(grid, T, F, F) # Identify objects
  filtered_objs = sfilter(objs, lambda obj: color(obj) == 1) # Filter for color '1'
  moved_objs = apply(move_object, filtered_objs) # Move and recolor
  grid = paint(fill(grid, mostcolor(grid), asindices(grid)), merge(moved_objs)) # Paint onto a cleared grid
  return grid
 
0.39, 31.812489, def fibdeffcgcbfedcdjgceffiegafciacf(I):
  O = canvas(0, shape(I)) # Initialize output with a canvas of 0s
  for i, j in asindices(I):
    if index(I, (i, j)) != 0:  # For each non-zero cell
      new_i, new_j = i + 1, j + 1 # Calculate new indices
      if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):  # Check bounds
        O = paint(O, {(1, (new_i, new_j))}) # Paint '1' at the new location
        O = paint(O, {(2, (i, j))}) # Paint '2' at the original location
  return O
 
0.395, 34.421032, def ieccgafbddcaeihejafahfgabddicijc(I):
  objs = objects(I, univalued=False, diagonal=True, without_bg=True) # Get all objects
  O = canvas(0, shape(I))  # Initialize output grid
  for obj in objs:
      shifted_obj = shift(obj, (1, 1))  # Shift object diagonally
      O = underpaint(O, recolor(1, shifted_obj))  # Paint '1' at the shifted location
      O = underpaint(O, recolor(2, obj))  # Paint '2' at the original location
  return O
 
0.76, 13.991814, def iffbgbccabeieggfbcbdbaabfgeiacbe(I):
  O = replace(I, 0, -1)  # Replace background with a temporary value
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      if O[i][j] != -1:
        O = paint(O, {(1, (i + 1, j + 1))})  # Paint '1' diagonally
  O = replace(O, -1, 0)  # Restore background
  return replace(O, I[0][0], 2) # Replace original object color with '2'
 
0.395, 20.671326, def daeacbdbdbbfefaaiideicjhacaebbcf(I):
  shifted_grid = canvas(0, shape(I)) # Initialize a shifted grid with 0s
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      if I[i][j] != 0:
        shifted_grid = paint(shifted_grid, {(1, (i + 1, j + 1))}) # Fill shifted grid
  return cellwise(shifted_grid, I, 2) # Combine shifted and original grids with '2' as fallback
 
0.245, 53.58554, def gdgeacfagdcdehbeifcgehdbedcicede(I):
  # Identify the upper-left corner of the '2' object 
  corner_2 = ulcorner(toindices(first(colorfilter(objects(I, T, T, T), 2))))

  # Identify the upper-left corner of the '1' object
  corner_1 = ulcorner(toindices(first(colorfilter(objects(I, T, T, T), 1))))

  # Construct the transformed '2' object based on its corner position
  obj_2 = frozenset({
      (2, (corner_2[0] + 1, corner_2[1] + 1)),
      (2, (corner_2[0] + 2, corner_2[1])),
      (2, (corner_2[0] + 2, corner_2[1] + 1)),
      (2, (corner_2[0] + 2, corner_2[1] + 2))
  }) if portrait(first(colorfilter(objects(I, T, T, T), 2))) else frozenset({
      (2, (corner_2[0] + 1, corner_2[1] - 1)),
      (2, (corner_2[0], corner_2[1])),
      (2, (corner_2[0] + 1, corner_2[1])),
      (2, (corner_2[0] + 2, corner_2[1]))
  })

  # Construct the transformed '1' object based on its corner position
  obj_1 = frozenset({
      (1, (corner_1[0] + i, corner_1[1] + j)) 
      for i in range(height(first(colorfilter(objects(I, T, T, T), 1)))) 
      for j in range(width(first(colorfilter(objects(I, T, T, T), 1))))
  })
  
  # Position the '1' object in the bottom-right corner
  obj_1 = shift(obj_1, (height(I) - height(obj_1), width(I) - width(obj_1)))

  # Assemble the final grid
  return paint(paint(canvas(0, shape(I)), obj_2), obj_1)
 
0.275, 10.491711, def bbejedabffhbeedfjebdefdjceaedidh(I):
  # 1. Find the least common color and its objects
  target_color = leastcolor(I)
  objs = objects(I, T, T, T)
  target_obj = first(colorfilter(objs, target_color)) 

  # 2. Move the target object down by one row
  moved_obj = shift(target_obj, DOWN)

  # 3. Create a new object of color '1' above the moved object
  new_obj = recolor(1, shift(toindices(moved_obj), UP))

  # 4. Cover the original object, paint the moved object, and then the new object
  O = paint(paint(cover(I, target_obj), moved_obj), new_obj)
  return O
 
0.30000000000000004, 9.730251, def hfbcceedfffaegeeijdbbbbgbffdbdag(I):
  # 1. Find the least common color object
  target_obj = argmin(objects(I, T, T, T), lambda obj: colorcount(I, color(obj)))

  # 2. Calculate the new position for the object
  new_position = add(ulcorner(target_obj), DOWN)

  # 3. Create a new object of color '1' above the new position
  new_obj = recolor(1, initset(add(new_position, UP)))

  # 4. Modify the grid
  O = paint(paint(cover(I, target_obj), shift(target_obj, DOWN)), new_obj)
  return O
 
0.31999999999999995, 10.048163, def hccidacecdiheeeiiadjagfdieigdega(I):
  # 1. Extract the object with the least occurrences
  objs = objects(I, T, T, T)
  target_obj = argmin(objs, lambda obj: len(obj))

  # 2. Calculate the position of the new '1' object
  new_one_position = subtract(centerofmass(target_obj), DOWN)

  # 3. Modify the grid
  O = paint(fill(cover(I, target_obj), 1, initset(new_one_position)), shift(target_obj, DOWN))
  return O
 
0.25, 33.073593, def cacfeedeaeeeeacdjedeedihaeaebcdf(I):
  # Identify Objects
  obj_2 = toobject(ofcolor(I, 2), I)
  obj_3 = toobject(ofcolor(I, 3), I)
  obj_4 = toobject(ofcolor(I, 4), I)

  # Relocate Objects
  obj_2_shifted = shift(obj_2, (-1, -1))  
  obj_3_shifted = shift(obj_3, (1, -1)) 
  obj_4_replaced = recolor(1, {(lowermost(obj_4), center(obj_4)[1])})

  # Reconstruct Grid
  O = paint(
      paint(
          paint(canvas(0, shape(I)), obj_2_shifted), 
          obj_3_shifted
      ), 
      obj_4_replaced
  )
  return O 
 
0.29000000000000004, 11.968009, def adeehgecficeejddjdaffijcjjachafc(I):
  # Partition by color and filter background
  objs = fgpartition(I)
  
  # Define transformation rules
  def transform(obj):
    c = color(obj)
    if c == 2:
      return shift(obj, (-1,-1))
    elif c == 3:
      return shift(obj, (1, -1))
    elif c == 4:
      return recolor(1, {(lowermost(obj), center(obj)[1])})
    else:
      return obj

  # Apply transformations and paint on canvas
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = paint(O, transform(obj))
  return O
 
0.24, 28.098303, def aaabagfhhhebejghadafdiajghcffbbh(I):
  def process_object(obj):
    c = color(obj)
    if c == 2: 
      return shift(obj, (-1, -1))
    elif c == 3:
      return shift(obj, (1, -1))
    else:
      return recolor(1, {(lowermost(obj), center(obj)[1])})

  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, True):
    O = paint(O, process_object(obj))
  return O
 
0.31, 14.84159, def aeadcecacddhejafjgdecdegejeaccgf(I):
  objs = fgpartition(I)
  def move_object(obj):
    return shift(obj, {2: (-1,-1), 3: (1,-1)}.get(color(obj), (0, 0)))

  def replace_object(obj):
    return recolor(1, {(lowermost(obj), center(obj)[1])}) if color(obj) != 2 and color(obj) != 3 else obj
    
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    O = paint(O, move_object(obj))
    O = paint(O, replace_object(obj))
  return O
 
0.25, 17.797195, def jjegcffbebbaedfeaejecfddfibegbfd(I):
  def transform_cell(v, i, j):
    if v == 2:
      return (1, (i-1, j-1))
    elif v == 3:
      return (1, (i+1, j-1))
    elif v == 4:
      if i == lowermost(toobject(ofcolor(I, 4), I)) and j == center(toobject(ofcolor(I, 4), I))[1]:
        return (1, (i, j))
      else:
        return (0, (i, j))
    else:
      return (v, (i, j))

  O = canvas(0, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      v, (new_i, new_j) = transform_cell(I[i][j], i, j)
      O = paint(O, {(v, (new_i, new_j))}) 
  return O
 
0.365, 12.947807, def ddagcfbahdfceeeiaehehbbcffjdghbg(I):
  O = canvas(0, shape(I))  # Create an empty canvas
  for obj in objects(I, T, F, F):  # Iterate through objects
    if color(obj) == 2: 
      O = paint(O, shift(recolor(1, obj), (1, 1)))  # Shift and recolor '2' to '1'
    elif color(obj) == 3:
      O = paint(O, shift(recolor(1, obj), (1, 1)))  # Shift and recolor '3' to '1'
    elif color(obj) == 4:
      O = paint(O, shift(recolor(1, obj), (1, 1)))  # Shift and recolor '4' to '1'
    else:
      O = paint(O, shift(obj, (1, 1)))  # Shift other objects without recoloring
  return O
 
0.355, 16.564764, def ddhabcffcieaeaegabeddfihacefaief(I):
  O = I  # Initialize output as input
  for i, j in product(interval(0, len(I), 1), interval(0, len(I[0]), 1)):
    if index(I, (i, j)) in {2, 3, 4}: # Check for values 2, 3, or 4
      O = cover(O, {(index(I, (i, j)), (i, j))})  # Remove the value from output
      if 0 <= i+1 < len(I) and 0 <= j+1 < len(I[0]):
        O = paint(O, {(1, (i+1, j+1))}) # Paint '1' diagonally if in bounds
  return O
 
0.36, 13.225405, def ifcaeaddfadgecfabgdcbcfaeahdaffb(I):
  O = canvas(0, (len(I), len(I[0])))  # Create empty canvas
  for obj in objects(I, T, F, F):  # Iterate through connected components
    new_obj = shift(recolor(1, obj) if color(obj) > 1 else obj, (1, 1)) # Shift and recolor
    O = paint(O, new_obj)  # Paint shifted object to output
  return O
 
0.31999999999999995, 8.807534, def dcchhdbebagcebecjcefafccfiagdbca(I):
  # 1. Find smallest object (excluding background)
  objs = objects(I, T, T, T)
  smallest_obj = argmin(objs, size) 

  # 2. Calculate new positions 
  new_obj_pos = add(centerofmass(smallest_obj), DOWN)
  new_one_pos = add(ulcorner(smallest_obj), UP_RIGHT)

  # 3. Modify grid 
  O = paint(fill(cover(I, smallest_obj), 1,  
           product(interval(0, 3, 1), initset(new_one_pos))), 
           shift(smallest_obj, DOWN))
  return O
 
0.315, 9.669741, def agbajabdfafeecdaiedabjadffbhdffe(I):
  # 1. Find smallest object and its color
  objs = objects(I, T, T, T)
  smallest_obj = argmin(objs, size)
  color_smallest = color(smallest_obj)

  # 2. Find largest object for gravitation
  largest_obj = argmax(objs, size)

  # 3. Gravitate smallest object towards the largest
  grav_direction = gravitate(smallest_obj, largest_obj)
  new_obj_pos = shift(smallest_obj, grav_direction)

  # 4. Insert '1' object
  new_one_pos = add(ulcorner(smallest_obj), UP_RIGHT)
  one_obj = recolor(1, initset(new_one_pos))

  # 5. Modify the grid
  O = paint(paint(cover(I, smallest_obj), one_obj), new_obj_pos)
  return O
 
0.20500000000000002, 36.699512, def baficdfidbciehfficbcdefeegbfciie(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 2:
        ni, nj = (i + 1, j - 1) if colorcount(I, 2) == 3 else (i - 1, j + 1)
        if 0 <= ni < len(I) and 0 <= nj < len(row):
          O = paint(O, {(v, (ni, nj))})
      elif v == 3:
        ni, nj = (i - 1, j - 1) if colorcount(I, 3) == 3 else (i + height(I) - 1, j + width(I) - 1)
        if 0 <= ni < len(I) and 0 <= nj < len(row) and (v == 3 or colorcount(I, 3) == 9):
          O = paint(O, {(2 if v == 3 else v, (ni, nj))})
      elif (v == 4 and colorcount(I, 4) > 0) or (v == 5 and colorcount(I, 5) > 0):
        ni, nj = (i, j) if v == 4 else (i + 1, j + 1)
        if 0 <= ni < len(I) and 0 <= nj < len(row):
          O = paint(O, {(1 if v == 4 else v, (ni, nj))})
  return O
 
0.18, 40.50484, def cdbicdfadhgdecfaiecbdeiaehbgefee(I):
  two_rotation = rot270 if colorcount(I, 2) == 3 else rot90
  two_shift = (1, 1) if colorcount(I, 2) == 3 else (-1, 1)

  three_shift = (-1, -1) if colorcount(I, 3) == 3 else (height(I)-1, width(I)-1)

  target_color = 4 if colorcount(I, 4) > 0 else 5
  target_shift = (1, 1) if target_color == 5 else (0, 0)

  def transform_cell(v, i, j):
    if v == 2: return (v, (i + two_shift[0], j + two_shift[1]))
    if v == 3: return (2 if colorcount(I, 3) == 9 else v, (i + three_shift[0], j + three_shift[1]))
    if v == target_color: return (1 if v == 4 else v, (i + target_shift[0], j + target_shift[1]))
    return (0, (i, j))

  obj = asobject(I)
  transformed_obj = frozenset(transform_cell(v, i, j) for v, (i, j) in obj)

  O = paint(canvas(0, shape(I)), transformed_obj)
  return O
 
0.315, 9.462653, def ajifeadbedfheafibeabjdejacijbada(grid):
  objs = objects(grid, T, F, F) # Identify all objects
  bg = mostcolor(grid) # Determine background color
  for obj in objs:
    if color(obj) == 1: # Filter for objects with color '1'
      offset = (height(obj) + 1, 0) if hline(obj) else DOWN # Specific offset for horizontal lines
    elif color(obj) == 2: # Filter for objects with color '2'
      offset = (1, 1)
    else:
      continue  # Skip other colors
    grid = move(grid, obj, offset) # Move the object
  return grid
 
0.325, 8.946182, def jbcfhbcbfeeeebifjdedgbejaeacfcie(grid):
  return paint(
      paint(
          fill(grid, mostcolor(grid), mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 1)),
          shift(mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 1), DOWN)),
      shift(mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 2), (1, 1)))
 
0.275, 16.771986, def abcafbcecfdgecbfacdhfddidfdaeeba(grid):
  grid = fill(grid, mostcolor(grid), mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 1))
  grid = paint(grid, shift(mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 1), DOWN))
  grid = paint(grid, shift(mfilter(objects(grid, T, F, F), lambda obj: color(obj) == 2), (1, 1)))
  return grid
 
0.28500000000000003, 11.347382, def gfceichedgfhecafiegbccdddjfbeaej(grid):
  def transform_object(obj):
    if color(obj) == 1:
      return shift(obj, (height(obj) + 1, 0) if hline(obj) else DOWN)
    elif color(obj) == 2:
      return shift(obj, (1, 1))
    return obj  # No change for other colors

  return paint(canvas(mostcolor(grid), shape(grid)), 
               merge(apply(transform_object, objects(grid, T, F, F)))) 
 
0.245, 43.258896, def cbjdhfeefbieeabibdfiadifeaebdeic(I):
  O = canvas(0, shape(I))  # Create an empty canvas
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:  # Find '1' cells
        new_i, new_j = i + 1, j + 1  # Calculate shifted indices
        if 0 <= new_i < len(I) and 0 <= new_j < len(row):  # Check bounds
          O = paint(O, {(2, (new_i, new_j))})  # Paint '2' at shifted position
  return O
 
0.265, 7.5582013, def fcbdfabfjbaeecdjigfcibifhfdfjabb(I):
  O = I  # Initialize output with input
  ones = asobject(I) & {(1, (i, j)) for i in range(len(I)) for j in range(len(I[0]))}
  twos = {(2, (i + 1, j + 1)) for _, (i, j) in ones if 0 <= i + 1 < len(I) and 0 <= j + 1 < len(I[0])}
  return paint(cover(O, toindices(ones)), twos)
 
0.305, 34.209408, def fjicbdcgjaijecaijdffdcddgcibgbgf(I):
  def transform(obj):
    c = color(obj)
    return shift(
      branch(c == 1, hmirror(obj), obj),  # Horizontal flip instead of rotation
      branch(c == 1, (0, 0), (height(I) - height(obj), width(I) - width(obj))) # Reversed target positions
    )
  return paint(canvas(0, shape(I)), merge(apply(transform, objects(I, T, T, T))))
 
0.275, 10.659875, def hfeibffaeadcehjjiccaccjaaabecigg(I):
  I = switch(I, 1, 2)  # Swap colors 1 and 2
  def move_object(obj):
    return shift(obj, (height(I) - height(obj), width(I) - width(obj)) if color(obj) == 1 else (0, 0))
  return paint(canvas(0, shape(I)), merge(apply(move_object, objects(I, T, T, T))))
 
0.27, 10.765303, def bgegdbjgagcbecddjabicifedecjihei(I):
  return paint(canvas(0, shape(I)), 
               frozenset({(index(I, add((i, j), (1, 1))), add((i, j), (1, 1))) 
               for i in range(len(I)) for j in range(len(I[0])) if index(I, (i, j)) != mostcommon(I)}))
 
0.385, 11.683392, def hcchacfdcaicebeaaaedbbgdacefhcge(I):
  def transform_cell(i, j):
    new_i, new_j = i + 1, j + 1
    return (index(I, (i, j)), (new_i, new_j)) if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]) else None
  return paint(canvas(0, shape(I)), frozenset(filter(None, [transform_cell(i, j) for i in range(len(I)) for j in range(len(I[0]))])))
 
0.52, 11.24477, def cggcadabadbbecagjagccbabejbjafac(I):
  def shifted_object(obj):
    return shift(recolor(index(I, add(ulcorner(obj), (1, 1))), obj), (1, 1))
  return paint(canvas(0, shape(I)), merge(apply(shifted_object, objects(I, True, False, False)))) 
 
0.255, 36.88885, def bijcabhbjjcheedfafeiiecadebejedi(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = paint(O, {(1, (i,j))}) # Place a '1' at the current location
        if 0 <= j-1 < len(row) and 0 <= i+1 < len(I):
          O = paint(O, {(1, (i+1, j-1))}) # Place a '1' diagonally down-left
        if 0 <= j-2 < len(row) and 0 <= i+2 < len(I):
          O = paint(O, {(1, (i+2, j-2))}) # Place a '1' two steps diagonally down-left 
  O = replace(O, 1, 2)  # Swap '1's to '2's
  O = replace(O, 2, 1)  # Swap original '2's to '1's 
  return O
 
0.27, 48.373703, def bhcjdefcjdbaejeejbdaagccbbbcaadc(I):
  def process_cell(j, i):
    if I[i][j] == 2:
      return (1, (i,j)) # Return a tuple representing a cell with value '1'
    else:
      return (0, (i,j)) # Return a tuple representing a cell with value '0'

  transformed_grid = tuple(tuple(process_cell(j, i) for j in range(width(I))) 
                           for i in range(height(I)))
  rotated_grid = rot270(transformed_grid)
  O = canvas(0, shape(I))

  for i in range(height(I)):
    for j in range(width(I)):
      if rotated_grid[i][j][0] == 1:
        O = paint(O, {(2, (i, j))}) 
  return O
 
0.28, 15.259227, def icgeddeaadgfefdaiafgibedcfebiabe(I):
  O = fill(I, 0, ofcolor(I, 1)) # Replace 1s with background
  O = paint(O, recolor(1, shift(ofcolor(O, 2), (1, 1)))) # Shift and recolor 2s to 1s
  return O
 
0.245, 21.518108, def ecfbdafbahcgejidjdgfbbfidceebcda(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Extract all objects
  new_objs = set()
  for obj in objs:
    color_val, (i, j) = next(iter(obj)) 
    if color_val == 1:
      continue # Skip processing objects with color 1
    elif color_val == 2:
      new_objs.add(recolor(1, shift(obj, (1, 1)))) # Shift and recolor 2s to 1s
    else:
      new_objs.add(obj) # Keep other objects unchanged
  O = paint(canvas(mostcolor(I), shape(I)), frozenset.union(*new_objs)) # Paint onto a blank canvas 
  return O
 
0.245, 28.956697, def jahcfdadcjjjefhfabjadicbjighdedd(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if O[i][j] == 1:
        O = fill(O, 0, {(i, j)}) # Remove 1s
      elif O[i][j] == 2:
        if i < height(I) - 1 and j < width(I) - 1: # Check for boundary conditions
          O = fill(O, 0, {(i, j)})
          O = fill(O, 1, {(i + 1, j + 1)}) # Shift and replace with 1
  return O
 
0.235, 24.478607, def beehaghaeceeeaegiaaeideehhdgifca(I):
  O = canvas(mostcolor(I), shape(I)) # Start with blank canvas
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1:
        continue # Skip 1s
      elif I[i][j] == 2:
        if i < height(I) - 1 and j < width(I) - 1:
          O = fill(O, 1, {(i + 1, j + 1)}) # Place 1 at shifted location
      else:
        O = fill(O, I[i][j], {(i, j)}) # Copy other colors directly
  return O
 
0.27, 19.824308, def ebhbijffddeeecefbfcbbfahaagdcfbd(I):
  shifted_indices = shift(ofcolor(I, 2), (1, 1)) # Get shifted indices for 2s
  O = replace(I, 1, 0)  # Replace all 1s with 0s
  O = fill(O, 0, ofcolor(O, 2)) # Remove original 2s
  return paint(O, recolor(1, shifted_indices)) # Paint shifted 2s as 1s 
 
0.77, 25.418081, def egcaicidadjbecffbiabcfcdaccdbcda(I):
  main_obj = argmax(objects(I, True, False, False), size) # find the largest object
  shifted = shift(recolor(1, main_obj), (1, 1)) # shift and recolor
  outline = difference(box(main_obj), toindices(shifted)) # find the outline for the new object
  outlined = recolor(2, outline) # recolor the outline
  return paint(paint(canvas(0, shape(I)), shifted), outlined) # paint on a blank canvas
 
0.265, 36.09697, def jcgdfjdjaafhehbbifcedffcgfbgidae(I):
  target_obj = extract(objects(I, True, False, False), lambda obj: size(obj) > 1) # extract the object with size > 1
  new_grid = canvas(0, shape(I)) # create a blank canvas
  new_grid = paint(new_grid, shift(recolor(1, target_obj), (1, 1))) # shift, recolor and paint the object
  outline_indices = difference(box(target_obj), toindices(shift(target_obj, (1, 1)))) # calculate outline
  return paint(new_grid, recolor(2, outline_indices)) # paint the outline on the grid
 
0.775, 28.093502, def iieahdddjjieegbfbdfhgfjfeedejedb(I):
    primary_obj = argmax(objects(I, True, False, False), size) # find the largest object
    new_color = 2 if color(primary_obj) == 1 else 1  # determine the new color for the object 
    shifted_obj = shift(recolor(new_color, primary_obj), (1, 1))  # shift and recolor the object
    outline = box(primary_obj)  # get the bounding box of the object
    return paint(paint(canvas(0, shape(I)), shifted_obj), recolor(2, outline))  # paint the object and its outline
 
0.30000000000000004, 13.780135, def aeehbhbbedbbeeecbajdebaabahjhiah(I):
    O = replace(I, 4, 1) 
    O = paint(O, shift(toobject(ofcolor(I, 2), I), (1, 1)))
    O = paint(O, shift(toobject(ofcolor(I, 3), I), (-1, -1)))
    O = paint(O, shift(toobject(ofcolor(I, 5), I), (0, 1)))
    return O
 
0.415, 11.154364, def bidcfdjefbhgedhaaiaadcidfhfgcced(I):
  new_grid = canvas(0, shape(I)) # Create blank canvas
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcommon(I): # If not background color
        new_grid = paint(new_grid, {(I[i][j], (i+1, j+1))}) # Paint with shift
  return rot270(new_grid) # Rotate the entire grid
 
0.24, 65.13945, def dgdfeecajdifebjbbihcdhgbjjjffeeg(I):
  two_indices = totuple(ofcolor(I, 2)) # Get indices of all '2's
  one_indices = totuple(ofcolor(I, 1)) # Get indices of all '1's
  O = canvas(0, shape(I))  # Create a blank canvas
  for i in range(len(two_indices)): # Iterate through corresponding indices 
    O = fill(O, 2, {astuple(one_indices[i][0] + two_indices[i][1] - one_indices[i][1],
                          one_indices[i][1] - two_indices[i][0] + one_indices[i][0])}) # Calculate rotated position for '2' based on '1' index
  return switch(O, 1, 2) # Switch colors '1' and '2'
 
0.38, 18.464136, def dbeeefbaghfieficieccbgggicedicaf(I):
  O = switch(I, 1, 2) #  Swap colors '1' and '2' temporarily
  h, w = shape(I)
  for i in range(h):
    for j in range(w):
      if O[i][j] == 1:  # Process pixels that were originally '2'
        ni = j
        nj = w - i - 1 
        if 0 <= ni < h and 0 <= nj < w:
          O = fill(O, 1, {(ni, nj)}) # Place the rotated pixel 
  return switch(O, 1, 2) #  Switch back the colors 
 
0.28500000000000003, 12.512204, def faefibjhhbibefbejeehabjbeafeceda(I):
  two_indices = toindices(ofcolor(I, 2))
  one_loc = first(toindices(ofcolor(I, 1)))
  
  def new_color(i, j):
    if (i, j) in two_indices:
      obj_loc = subtract((i, j), one_loc)
      return 2 if (obj_loc[1], -obj_loc[0]) in two_indices else 0
    else:
      return 1 if (i, j) == one_loc else I[i][j]
  
  return tuple(tuple(new_color(i, j) for j in range(width(I))) for i in range(height(I)))
 
