0.1050175757040321, 3.5893714, def biieefeejjbgegigjjjcddaajaedicbf(I):
  """
  Swaps '3' and '4' using the switch function twice.
  """
  O = switch(I, THREE, FOUR)
  O = switch(O, FOUR, THREE)
  return O
 
0.15752636355604815, 3.512228, def hjbchfbejcecehccjfjfdeefcaghaaaf(grid):
  # Find the locations of '3' and '4'.
  three_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 3)
  four_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 4)
  # Swap the values at the identified locations.
  grid = fill(grid, 4, initset(three_loc))
  grid = fill(grid, 3, initset(four_loc))
  return grid
 
0.1069918640419568, 7.8971014, def iedfcbjedaeceebdabbdcicfcgddbhaf(I):
  h, w = shape(I)
  hc, wc = h // 2, w // 2
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if 0 <= i - hc < h and 0 <= j - wc < w:
        O = fill(O, index(I, (i - hc, j - wc)), ((i, j),))
  return O
 
0.1824695938981653, 16.704634, def affhiafhbddbedehicbidcfffjjjccbj(I):
  h, w = shape(I)
  return crop(hconcat(hconcat(canvas(mostcolor(I), (h, (w - width(I)) // 2)), I), canvas(mostcolor(I), (h, (w - width(I) + 1) // 2))), (h // 2, 0), (h, w))
 
0.15752636355604815, 3.512228, def hddacfihedbeehddbedjfbfgifdbigeh(I):
    # Create a mapping of colors for swapping
    color_map = {3: 4, 4: 3}
    
    # Apply the color mapping to each cell in the grid
    O = tuple(tuple(color_map.get(v, v) for v in row) for row in I)
    return O
 
0.1200660460957307, 6.8917546, def iajgigaebbhiehbebbadgbgdchihahdf(I):
  objs = fgpartition(I)
  centered_objs = frozenset(shift(obj, subtract((len(I) // 2, len(I[0]) // 2), centerofmass(obj))) for obj in objs)
  O = paint(canvas(mostcolor(I), shape(I)), merge(centered_objs))
  return O
 
0.13828911966203244, 4.9083543, def acgicaeeabdaehafibehdcgeececfcii(I):
  objs = sorted(fgpartition(I), key=lambda obj: centerofmass(obj)[0])
  offset = (0, len(I[0]) // 2 - centerofmass(objs[0])[1])
  shifted_objs = frozenset(shift(obj, offset) for obj in objs)
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
0.11435176038144498, 6.8765163, def afafheejddcfeficiafbjagbdadaichb(I):
  O = I
  for obj in fgpartition(I):
    O = move(O, obj, subtract((len(I) // 2, len(I[0]) // 2), centerofmass(obj)))
  return O
 
0.173844675217588, 3.5413818, def cfjadcfbibceecfebafbhgcdabfaafae(I):
  mid = len(I[0]) // 2
  O = canvas(mostcolor(I), shape(I))
  for obj in sorted(fgpartition(I), key=lambda obj: centerofmass(obj)[0]):
    O = paint(O, shift(obj, (0, mid - centerofmass(obj)[1])))
  return O
 
0.17813038950330226, 3.3804731, def abhfccfdefaaecacicfbifeacaeffdef(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    O = canvas(0, shape(I))
    for obj in objs:
        value = color(obj)
        i, j = ulcorner(obj)
        new_j = width(I) // 2  # Horizontal centering
        if value == 3:
            new_i = height(I) // 2 - (i < height(I) // 2)  # Conditional vertical placement
        else:
            new_i = height(I) // 2 + (i >= height(I) // 2)
        O = paint(O, shift(obj, (new_i - i, new_j - j)))
    return O 
 
0.17813038950330226, 3.3617213, def eadafjjhgabceedcjifgaacadhebfifh(I):
    threes = ofcolor(I, 3)
    fours = ofcolor(I, 4)
    O = canvas(0, shape(I))
    for i, j in threes:
        new_j = width(I) // 2
        new_i = height(I) // 2 - (i < height(I) // 2)
        O = paint(O, {(3, (new_i, new_j))}) 
    for i, j in fours:
        new_j = width(I) // 2
        new_i = height(I) // 2 + (i >= height(I) // 2)
        O = paint(O, {(4, (new_i, new_j))})
    return O
 
0.03009694078339718, 2.3039253, def aajifciacaabedcabgfeeeaebhgebfbb(grid):
    # Find the locations of '3' and '4'.
    three_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 3)
    # Calculate the center of the grid.
    center_row = height(grid) // 2
    center_col = width(grid) // 2
    center_loc = (center_row, center_col)
    # Move the '3' to the center.
    grid = fill(grid, 0, initset(three_loc))
    grid = fill(grid, 3, initset(center_loc))
    return grid
 
0.03009694078339718, 2.2125385, def dddjcfcieabheebcjehgeffccdjgcdbc(grid):
    # Get indices of '3'.
    three_indices = ofcolor(grid, 3)
    # Calculate center of the '3' object.
    three_center = centerofmass(three_indices)
    # Calculate center of the grid.
    grid_center = centerofmass(asindices(grid))
    # Calculate the offset to move '3' to the center.
    offset = subtract(grid_center, three_center)
    # Move the '3' object.
    grid = paint(cover(grid, three_indices), shift(recolor(3, three_indices), offset)) 
    return grid
 
0.19599737100664744, 2.6839135, def afdiigacfadfefaeaabfefdfgijdefae(I):
  mid = height(I) // 2  # Calculate the middle row index
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for obj in fgpartition(I): # Iterate through non-background objects
    O = paint(O, shift(obj, (mid - centerofmass(obj)[0], 0))) # Center each object vertically
  return O
 
0.19599737100664744, 2.680382, def jecciebdebgdehefjbgaiebagaiedgeb(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        O = paint(O, {(val, (len(I)//2, j))}) # Directly place at middle row
  return O
 
0.19599737100664744, 2.6975377, def deadafgafhdbeabdjbcfeabejdedcgdd(I):
  objs = fgpartition(I)
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge({shift(obj, (height(I)//2 - uppermost(obj) - height(obj)//2, 0)) for obj in objs})
      )
 
0.14781292918584196, 4.1445007, def ccfgefbdebggehiebejfahfbiecadabf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  new_j = width(I) // 2
  three_i = uppermost(three_obj)
  new_three_i = height(I) // 2 - (three_i < height(I) // 2)
  O = paint(O, shift(three_obj, (new_three_i - three_i, new_j - leftmost(three_obj))))
  O = paint(O, shift(four_obj, (new_three_i + 1 - uppermost(four_obj), new_j - leftmost(four_obj))))
  return O
 
0.12324064927033386, 3.907531, def acabhbfihfdceadajbbafabedgchfhcd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  centered_three = shift(three_obj, (0, width(I) // 2 - leftmost(three_obj))) # Center '3' horizontally
  O = paint(O, centered_three)
  O = paint(O, shift(four_obj, gravitate(four_obj, centered_three))) # Move '4' below '3'
  return O
 
0.14781292918584196, 3.4244826, def hbeccebdeaaeefebihjgbgcabcdaddjf(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  center_j = width(I) // 2
  O = canvas(0, shape(I))
  for i, j in three_indices:
    O = paint(O, {(3, (i, center_j))})
  for i, j in four_indices:
    O = paint(O, {(4, (i + 1, center_j))})
  return O
 
0.16686054823346103, 3.7611873, def aefafbfdabidecaiidgaebadccbbbbbb(I):
  O = hmirror(I)
  objs = objects(O, univalued=True, diagonal=False, without_bg=True)
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  O = cover(O, three_obj)
  O = cover(O, four_obj)
  center_j = width(I) // 2
  O = paint(O, shift(three_obj, (0, center_j - leftmost(three_obj))))
  O = paint(O, shift(four_obj, (1, center_j - leftmost(four_obj))))
  return O
 
0.1050175757040321, 3.1004848, def eccediibahjjebdbaggefafcbfaahhaa(grid):
  # Find the location of '3'.
  three_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 3)
  # Calculate the vertical center of the grid.
  center_row = height(grid) // 2 
  # Maintain the horizontal position of '3'.
  center_col = three_loc[1] 
  center_loc = (center_row, center_col)
  # Move the '3' to the center vertically.
  grid = fill(grid, 0, initset(three_loc))
  grid = fill(grid, 3, initset(center_loc))
  return grid
 
0.1050175757040321, 3.8100321, def cbbfafdjdcceefibifcbehaeafcjbeji(grid):
    # Find the '3' object.
    three_obj = extract(objects(grid, univalued=True, diagonal=False, without_bg=False), lambda obj: color(obj) == 3)
    # Create a new object with '3' at the vertical center.
    centered_obj = recolor(3, shift(normalize(three_obj), (height(grid) // 2, 0))) 
    # Modify the grid.
    grid = paint(cover(grid, three_obj), centered_obj)
    return grid
 
0.14781292918584196, 4.3504877, def acceacejjijjebibjhfgjaibecibjfce(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj))
  h = height(I)
  center_j = width(I) // 2
  O = canvas(0, shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(normalize(obj), (h//2 + i - len(objs)//2, center_j)))
  return O
 
0.11435176038144498, 6.892273, def cgechgidiecceifbaeijbcjfajcidcbc(I):
  objs = fgpartition(I)
  h, w = shape(I)
  center = (h // 2, w // 2)
  O = canvas(0, (h, w))
  for i, obj in enumerate(sorted(objs, key=lambda obj: centerofmass(obj)[0])):
    O = paint(O, shift(obj, subtract(center, centerofmass(obj))))
  return O
 
0.1535272149001277, 4.3464947, def cacadjdadbgdeffjifefaffaecjbfbec(I):
  non_zero_cells = [(I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != 0]
  sorted_cells = sorted(non_zero_cells, key=lambda x: x[1][0])
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for i, (v, (r, c)) in enumerate(sorted_cells):
    O = paint(O, {(v, (i + (h - len(sorted_cells)) // 2, w // 2))})
  return O
 
0.17955896093187373, 3.7133727, def bcdbjcbcjfdiefgciehjejcfbjjdceec(I):
  objs = fgpartition(I)  # Extract non-background objects
  center_j = width(I) // 2  # Calculate horizontal center of the grid
  shifted_objs = frozenset(
      shift(obj, (0, center_j - centerofmass(obj)[1])) for obj in objs
  )  # Center each object horizontally
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))  # Paint objects onto a blank canvas
 
0.13257483394774675, 4.8272986, def bdagdjfiebedefcfbeijcebehbefddcj(I):
  objs = sorted(fgpartition(I), key=lambda obj: centerofmass(obj)[1]) # Sort objects by horizontal position
  offset = (0,  width(I) // 2 - centerofmass(objs[0])[1]) # Calculate offset for first object
  return paint(
      canvas(mostcolor(I), shape(I)), # Blank canvas
      merge({shift(obj, offset) for obj in objs}) # Shift and merge objects
  )
 
0.12876531013822293, 3.4457424, def ffjjcbagiebeeacajedjacfgbifbbbjd(I):
  shifted_objs = frozenset(
      shift(
          obj, 
          (0, width(I) // 2 - (leftmost(obj) + width(obj) - 1) // 2) # Calculate horizontal shift
      ) 
      for obj in fgpartition(I) # Iterate through objects
  )
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs)) # Paint objects onto a blank canvas
 
0.14781292918584196, 3.6562872, def aicfeifgjhjjejbcbfbgdjfjjaedchdh(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  center_j = width(I) // 2 
  three_center_i = uppermost(three_obj) + height(three_obj) // 2
  new_three_i = three_center_i - height(three_obj) // 2
  O = paint(O, shift(three_obj, (new_three_i - uppermost(three_obj), center_j - leftmost(three_obj))))
  O = paint(O, shift(four_obj, (new_three_i + height(three_obj) - uppermost(four_obj), center_j - leftmost(four_obj))))
  return O 
 
0.13511451648742928, 4.0443573, def caefacebbdbaeacgadddccfbefgbbfia(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  center_j = width(I) // 2
  new_three_i = height(I) // 2 - height(three_indices) // 2 
  O = canvas(0, shape(I))
  O = fill(O, 3, shift(three_indices, (new_three_i - uppermost(three_indices), center_j - leftmost(three_indices))))
  O = fill(O, 4, shift(four_indices, (new_three_i + height(three_indices) - uppermost(four_indices), center_j - leftmost(four_indices))))
  return O
 
0.1069918640419568, 8.009167, def ffcbjegadhjgebfcbgfdehbaeghccdda(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  three = extract(objs, lambda obj: color(obj) == 3)
  four = extract(objs, lambda obj: color(obj) == 4)
  three_h, three_w = shape(three)
  four_h, four_w = shape(four)
  O = paint(O, shift(three, ((height(I) - three_h) // 2, (width(I) - three_w) // 2)))
  O = paint(O, shift(four, (((height(I) - four_h) // 2) + three_h, (width(I) - four_w) // 2)))
  return O
 
0.13940023077314356, 4.4666, def fbcjbaccadbceecibfhbfiahabigfegc(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  new_three_j = width(I) // 2 - width(three_indices) // 2
  new_four_j = width(I) // 2 - width(four_indices) // 2
  O = canvas(0, shape(I))
  O = fill(O, 3, shift(three_indices, (height(O) // 2 - height(three_indices) // 2, new_three_j - leftmost(three_indices))))
  O = fill(O, 4, shift(four_indices, ((height(O) // 2  + height(three_indices) // 2) - uppermost(four_indices), new_four_j - leftmost(four_indices)))) 
  return O
 
0.1069918640419568, 7.8971014, def gjbgfbdbjeieeaefaagicdcjdaefcgdf(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 3:
        O = fill(O, v, {(height(O) // 2 - height(ofcolor(I, 3)) // 2 + i, width(O) // 2 - width(ofcolor(I, 3)) // 2 + j)})
      if v == 4:
        O = fill(O, v, {(height(O) // 2 + height(ofcolor(I, 3)) // 2 + i, width(O) // 2 - width(ofcolor(I, 4)) // 2 + j)})
  return O
 
0.1050175757040321, 3.2014184, def dcbabbeaddbiehdejecfjjdfabeiahbd(grid):
  # Find the '3' location
  three_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 3) 
  # Calculate center row, adjusting for odd heights
  center_row = height(grid) // 2 + (height(grid) % 2) - 1 
  # Maintain '3' horizontal position
  center_col = three_loc[1]
  center_loc = (center_row, center_col)
  # Move '3' to the center
  grid = fill(grid, 0, initset(three_loc))
  grid = fill(grid, 3, initset(center_loc))
  return grid
 
0.15752636355604815, 5.448191, def dijbiiiebbdaeaagjdeeahbaaiiibhge(grid):
  # Extract objects, focusing on '3'
  objs = objects(grid, True, False, False)
  three = extract(objs, lambda obj: color(obj) == 3) 
  # Calculate center row
  center_row = height(grid) // 2  
  # Shift '3' object vertically 
  shifted_three = shift(three, (center_row - uppermost(three), 0))
  # Paint the shifted object back onto a blank canvas
  return paint(canvas(0, shape(grid)), shifted_three) 
 
0.1587266783927266, 3.4556856, def ejabigbhddaeeadjigejcbcfcicajjdf(grid):
  # Directly modify grid rows using slicing
  half_height = height(grid) // 2 
  if height(grid) % 2 == 0:  
    # Even height: Swap rows to center '3'
    grid = tuple(grid[i] if i != half_height - 1 else grid[half_height]
                   for i in range(len(grid))) 
  else:
    # Odd height: Swap rows around the center
    grid = tuple(grid[i] if i < half_height - 1 or i > half_height else
                   (grid[half_height + 1] if i == half_height - 1 else grid[half_height - 1]) 
                   for i in range(len(grid))) 
  return grid
 
0.03009694078339718, 2.3039253, def ccaddidcfbcfeifgibfhbdbbgcegafai(I):
  objs = fgpartition(I)
  three = extract(objs, lambda obj: color(obj) == 3)
  four = extract(objs, lambda obj: color(obj) == 4)
  new_three = shift(three, (height(I) // 2 - uppermost(three), width(I) // 2 - leftmost(three)))
  new_four = shift(four, (height(I) - uppermost(four), 0))
  O = paint(paint(cover(I, three), new_three), new_four) 
  return O
 
0.0716224529953658, 2.90668, def cfjidhdeaeeceiccbgaefeafdegdiggf(I):
    h, w = len(I), len(I[0])
    three_i, three_j = first(ofcolor(I, 3))
    four_i, four_j = first(ofcolor(I, 4))
    O = canvas(0, (h, w))
    O = paint(O, {(3, (h // 2, w // 2))})
    O = paint(O, {(4, (h - 1, four_j))})
    return O
 
0.05085969688938149, 4.3807034, def jabdfdjdbfgbedafjffieaedeaafjbaf(I):
    obj3 = extract(fgpartition(I), lambda obj: color(obj) == 3)
    obj4 = extract(fgpartition(I), lambda obj: color(obj) == 4)
    new_obj3 = shift(obj3, subtract((len(I) // 2, len(I[0]) // 2), ulcorner(obj3)))
    new_obj4 = shift(obj4, (len(I) - 1 - uppermost(obj4), 0))
    O = paint(paint(cover(I, obj3), new_obj3), new_obj4)
    return O
 
0.10762678467687745, 2.6173103, def bbbejdcfgfebedbajffbegdaahdeejdg(grid):
  # Find the column index of the leftmost '3' cell.
  col = leftmost(ofcolor(grid, 3)) 
  # Extract the column containing the '3' object.
  column = tuple(grid[i][col] for i in range(height(grid)))
  # Create a new column with '3' at the center.
  new_column = tuple(0 for _ in range(height(grid) // 2)) + (3,) + tuple(0 for _ in range(height(grid) // 2 + (height(grid) % 2) - 1))
  # Replace the original column with the new column.
  return tuple(tuple(v if j != col else new_column[i] for j, v in enumerate(r)) for i, r in enumerate(grid))
 
0.17955896093187373, 3.164916, def eggcadhjcacceaddbdafafgagbaghchg(grid):
  # Transpose the grid.
  transposed = rot90(grid)
  # Find the row index of the leftmost '3' in the transposed grid (which corresponds to the topmost '3' in the original grid).
  row = leftmost(ofcolor(transposed, 3))
  # Calculate the target row index for the center.
  target_row = height(transposed) // 2 
  # Calculate the offset to move the '3' row to the center.
  offset = target_row - row 
  # Shift the rows of the transposed grid.
  shifted = tuple(transposed[(i + offset) % height(transposed)] for i in range(height(transposed)))
  # Transpose the grid back to the original orientation.
  return rot270(shifted) 
 
0.17133588736557195, 5.0469465, def deggcfcagibfebcfjcjadjfbgdcddihc(I):
  objs = fgpartition(I)
  centered_objs = {shift(obj, ((height(I) - height(obj)) // 2, 0)) for obj in objs}
  return paint(canvas(mostcolor(I), shape(I)), merge(centered_objs))
 
0.17828911966203245, 3.9660127, def chfcfdacdddcecffbhbhcdhjahebcjbg(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  center_i = height(I) // 2
  center_j = width(I) // 2 - 1 
  O = paint(O, shift(three_obj, (center_i - uppermost(three_obj), center_j - leftmost(three_obj))))
  O = paint(O, shift(four_obj, (center_i + 1 - uppermost(four_obj), center_j - leftmost(four_obj))))
  return O 
 
0.12705017307985766, 5.699609, def afjeafeejfbdebchaaadaigfiaecgiei(grid):
  # Get the '3' object.
  three_obj = next(obj for obj in objects(grid, univalued=True, diagonal=False, without_bg=False) if color(obj) == 3)
  # Calculate the horizontal center.
  center_j = width(grid) // 2
  # Calculate the shift needed to center the '3'.
  shift_amount = center_j - (leftmost(three_obj) + width(three_obj) // 2)
  # Shift the '3' object.
  shifted_three = shift(three_obj, (0, shift_amount))
  # Paint the shifted object back onto a blank canvas.
  return paint(canvas(0, shape(grid)), shifted_three)
 
0.17955896093187373, 2.9268577, def cfccgcfaddjceagbjdcehegjcdeggheb(grid):
  # Find the column index of the '3' object's leftmost cell.
  col = leftmost(ofcolor(grid, 3))
  # Calculate the target column index for centering.
  target_col = width(grid) // 2
  # Calculate the offset needed to move the column.
  offset = target_col - col
  # Create a new grid by shifting columns.
  return tuple(tuple(r[(j - offset) % width(grid)] for j in range(width(grid))) for i, r in enumerate(grid))
 
0.13257483394774675, 4.8122945, def eacjddcfbfcbeedbaaaedbbajcceiagi(grid):
  # Extract all objects from the grid.
  objs = objects(grid, univalued=True, diagonal=False, without_bg=False)
  # Find the '3' object.
  three_obj = next(obj for obj in objs if color(obj) == 3)
  # Calculate the target center for the '3' object.
  target_center = (centerofmass(three_obj)[0], width(grid) // 2) 
  # Calculate the shift vector.
  shift_vector = subtract(target_center, centerofmass(three_obj))
  # Shift all objects by the calculated vector.
  shifted_objs = frozenset(shift(obj, shift_vector) for obj in objs)
  # Paint the shifted objects onto a blank canvas.
  return paint(canvas(0, shape(grid)), merge(shifted_objs))
 
0.19098753236044516, 3.6092598, def eiiddbfffeaceafejadggiabcaecbadh(grid):
  # Get the '3' indices.
  three_indices = ofcolor(grid, 3)
  # Calculate the horizontal center of the '3' indices.
  center_j = (leftmost(three_indices) + rightmost(three_indices)) // 2
  # Calculate the target center column.
  target_col = width(grid) // 2
  # Calculate the offset.
  offset = target_col - center_j
  # Shift the grid columns.
  return tuple(tuple(grid[i][(j + offset) % width(grid)] for j in range(width(grid))) for i in range(height(grid)))
 
0.10787471856117495, 3.4814336, def fdeafchedbeieffajgffcgdbeceadjde(I):
  """
  Centers objects in the grid by moving them horizontally.
  """
  mid = width(I) // 2  # Find the middle column index
  centered_objs = mapply(lambda obj: shift(obj, (0, mid - centerofmass(obj)[1])),
                        objects(I, False, False, False))  # Center each object
  return paint(canvas(mostcolor(I), shape(I)), centered_objs)  # Paint onto a blank canvas
 
0.15371683974652434, 7.7146173, def beehdcbdibegebbbafdbagibbbfddddd(I):
  """
  Moves objects to the center column of the grid.
  """
  offset = (0, width(I) // 2)  # Calculate the offset to center objects
  return paint(
      canvas(mostcolor(I), shape(I)),  # Create a blank canvas
      mapply(
          lambda obj: shift(obj, subtract(offset, centerofmass(obj))),
          objects(I, False, False, False)  # Get all objects
      )
  ) 
 
0.15953411667697384, 6.472649, def cdghjhacbabhejjcaiecjdfahagfgcaf(I):
  three_col = first(ofcolor(I, 3))[1]
  four_col = first(ofcolor(I, 4))[1]
  O = vconcat(
      fill(tophalf(I), 0, asindices(tophalf(I))),
      vconcat(
          ((0,) * (three_col) + (3,) + (0,) * (len(I[0]) - three_col - 1), ),
          ((0,) * (four_col) + (4,) + (0,) * (len(I[0]) - four_col - 1), )
      )
  )
  return O
 
0.17955896093187373, 3.0450706, def jjdgbieiefcbeabfidjicffdebeahafh(I):
    three_idx = first(ofcolor(I, 3))
    four_idx = first(ofcolor(I, 4))
    new_grid = canvas(0, shape(I))
    new_grid = paint(new_grid, {(3, (three_idx[0], len(I[0])//2))})
    new_grid = paint(new_grid, {(4, (len(I) - 1, len(I[0])//2))})
    return new_grid
 
0.1769497519590284, 3.8073578, def iaahifijbeiiehfdaibfecbddbagaeba(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  three_obj = extract(objs, lambda obj: color(obj) == 3)
  four_obj = extract(objs, lambda obj: color(obj) == 4)
  three_pos = centerofmass(three_obj)
  four_pos = centerofmass(four_obj)
  O = paint(canvas(0, shape(I)), shift(three_obj, (four_pos[0] - three_pos[0], 0)))
  O = paint(O, shift(four_obj, (three_pos[0] - four_pos[0], 0)))
  return O
 
0.15372805714178628, 2.9811914, def bbdgedjbgidcecicjgdabecccebecbee(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  O = canvas(0, shape(I))
  for i, j in three_indices:
    O = paint(O, {(3, (j, i))})
  for i, j in four_indices:
    O = paint(O, {(4, (j, i))})
  return O
 
0.15018614450896453, 4.1249685, def effcaefiedchedghbjebhbjaecdjfibd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  for obj in objs:
    color_val = color(obj)
    if color_val == 3:
      O = paint(O, shift(obj, (centerofmass(obj)[1] - centerofmass(obj)[0], 0)))
    elif color_val == 4:
      O = paint(O, shift(obj, (centerofmass(obj)[0] - centerofmass(obj)[1], 0)))
    else:
      O = paint(O, obj)
  return O
 
0.06774688309011129, 5.771774, def bcebidfahaeiecegbbaajeajbgfefagf(grid):
  # Find the row index of '3'
  three_row = extract(interval(0, height(grid), 1), lambda i: 3 in grid[i])
  # Calculate the target row index 
  target_row = height(grid) // 2
  # Calculate the offset 
  offset = target_row - three_row
  # Shift the row containing '3'
  return tuple(grid[i + offset] if i == three_row else row for i, row in enumerate(grid))
 
0.1939208410636982, 17.555864, def jiaafgfbcbhdejdfifheddigfjccicfj(grid):
  # Split the grid horizontally
  top_half, bottom_half = vsplit(grid, 2) if height(grid) % 2 == 0 else vsplit(grid, 3)[0:2]
  # Find which half contains '3'
  three_in_top = 3 in merge(top_half)
  # Concatenate based on '3' location 
  return vconcat(bottom_half, top_half) if three_in_top else vconcat(top_half, bottom_half) 
 
0.11172287411619508, 9.082548, def eccibfegbahbegbebafibfacejaidiic(I):
  """
  Moves all objects to the center column while maintaining their vertical positions.
  """
  objs = objects(I, False, False, False) # Identify all objects
  center_j = width(I) // 2 # Calculate the center column index
  new_objs = frozenset() # Initialize an empty set for modified objects
  for obj in objs:
    for v, (i, _) in obj: # Iterate through each cell of the object
      new_objs = insert((v, (i, center_j)), new_objs) # Move the cell to the center column
  return paint(canvas(mostcolor(I), shape(I)), new_objs) # Paint the shifted cells onto a blank canvas
 
0.11172287411619508, 11.343649, def fcaeeachcdfgeiaebcbhcbefgcabcadc(I):
  """
  Centers objects on a new grid using a mapping function.
  """
  center_col = width(I) // 2
  return paint(canvas(mostcolor(I), shape(I)),
              mapply(lambda obj: frozenset((v, (i, center_col)) for v, (i, _) in obj), 
                     objects(I, False, False, False)))
 
0.17955896093187373, 3.7133727, def bgjjacchebfaebfcjjgeajbfgedcfdca(I):
    """
    Iterates through grid cells and repositions non-background cells.
    """
    grid_height, grid_width = shape(I)
    center_j = grid_width // 2
    new_grid = canvas(mostcolor(I), (grid_height, grid_width))
    for i in range(grid_height):
        for j in range(grid_width):
            if I[i][j] != mostcolor(I):
                new_grid = fill(new_grid, I[i][j], {(i, center_j)})
    return new_grid
 
0.13511451648742928, 3.5070953, def efbeebbaiaefeddcbcjfdejgfjdbdaec(I):
  h, w = len(I), len(I[0])
  three_j = first(ofcolor(I, 3))[1]
  four_j = first(ofcolor(I, 4))[1]
  O = canvas(0, (h, w))
  O = fill(O, 3, {(h // 2, w // 2)}) 
  O = fill(O, 4, {(h - 1, w // 2)})
  return O
 
0.11733673870965149, 2.7251751, def bicdecdecdfjebdajaahihbcbbjdcahd(I):
  centered_objs = []
  for obj in fgpartition(I):
    offset = (0, width(I) // 2 - (leftmost(obj) + width(obj)) // 2)
    centered_objs.append(shift(obj, offset))
  return paint(canvas(mostcolor(I), shape(I)), merge(centered_objs))
 
0.18346890586222683, 4.242808, def bbhdbgjbggadechdaibbbjddhfcfdeeh(I):
  return switch(dmirror(I), 3, 4)
 
0.1502359936497228, 3.7204185, def cfcffeidfaheefecbceijcfjababcdfd(I):
  return switch(hmirror(rot90(I)), 3, 4)
 
0.07454138522784162, 2.310605, def hfacfcacfeebeaedbhbdibeibfgaidhd(grid):
  # Extract the '3' object from the grid.
  three_obj = next(obj for obj in partition(grid) if color(obj) == 3)
  # Calculate the horizontal offset needed to center the '3' object.
  offset = (width(grid) // 2) - (leftmost(three_obj) + width(three_obj) // 2)
  # Shift the '3' object horizontally by the calculated offset.
  centered_three_obj = shift(three_obj, (0, offset))
  # Remove the original '3' object from the grid.
  cleared_grid = cover(grid, three_obj)
  # Paint the centered '3' object back onto the cleared grid.
  return paint(cleared_grid, centered_three_obj)
 
0.17955896093187373, 3.0760076, def hbdcajdfdcfeebefadcafciahabbiafj(grid):
  # Transpose the grid to work with columns as rows.
  transposed_grid = dmirror(grid)
  # Find the row index of the leftmost '3' cell in the transposed grid.
  row_3 = leftmost(ofcolor(transposed_grid, 3))
  # Calculate the target row index for centering '3'.
  target_row = width(transposed_grid) // 2
  # Determine the offset to center the '3' row.
  offset = target_row - row_3
  # Shift the rows of the transposed grid to center '3'.
  centered_transposed_grid = tuple(transposed_grid[(i + offset) % height(transposed_grid)] for i in range(height(transposed_grid)))
  # Transpose the grid back to its original orientation.
  return dmirror(centered_transposed_grid)
 
0.12749546886838167, 2.9822857, def fbibaecaiecgebdfbbbcdieadfafdajg(I):
  three_idx = first(ofcolor(I, 3))
  four_idx = first(ofcolor(I, 4))
  new_grid = canvas(0, shape(I))
  new_grid = paint(new_grid, {(3, (len(new_grid)//2 - 1, len(I[0])//2))})
  new_grid = paint(new_grid, {(4, (len(I) - 1, four_idx[1]))})
  return new_grid
 
0.15807208046540142, 3.2237694, def iigfbegbacdjehagjfabbeaahcdgifcc(I):
  """
  Swaps the positions of 3 and 4 in the grid while
  preserving their row-column relationship.
  """
  h, w = shape(I)
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] == 3:
        O = fill(O, 4, {(j, i)})
      elif I[i][j] == 4:
        O = fill(O, 3, {(j, i)})
      else:
        O = fill(O, I[i][j], {(j, i)})
  return O
 
0.13928361269734182, 3.3185985, def fegefafgbaadegccjbbddahgcccficfc(grid):
  # Find the row index of the '3' object's uppermost cell.
  row_3 = uppermost(ofcolor(grid, 3))
  # Calculate the target row index for centering.
  target_row_3 = height(grid) // 2
  # Calculate the row offset for the '3' object.
  offset_3 = target_row_3 - row_3
  # Shift the '3' object vertically.
  shifted_3 = shift(ofcolor(grid, 3), (offset_3, 0))
  # Find the row index of the '4' object's uppermost cell.
  row_4 = uppermost(ofcolor(grid, 4))
  # Calculate the target row index for the '4' object (below the '3').
  target_row_4 = target_row_3 + 1
  # Calculate the row offset for the '4' object.
  offset_4 = target_row_4 - row_4
  # Shift the '4' object vertically.
  shifted_4 = shift(ofcolor(grid, 4), (offset_4, 0))
  # Clear the original '3' and '4' positions.
  cleared_grid = cover(cover(grid, ofcolor(grid, 3)), ofcolor(grid, 4))
  # Paint the shifted '3' and '4' objects onto the cleared grid.
  return paint(paint(cleared_grid, recolor(3, shifted_3)), recolor(4, shifted_4)) 
 
0.1366744037244965, 2.825242, def cddibebiffdbeihbacibghfhccfafece(grid):
  # Extract the column containing the '3' object.
  col_3 = leftmost(ofcolor(grid, 3))
  column_3 = tuple(grid[i][col_3] for i in range(height(grid)))
  # Extract the column containing the '4' object.
  col_4 = leftmost(ofcolor(grid, 4))
  column_4 = tuple(grid[i][col_4] for i in range(height(grid)))
  # Create new columns with '3' and '4' centered and below each other.
  new_column_3 = tuple(0 for _ in range(height(grid) // 2)) + (3,) + tuple(0 for _ in range(height(grid) // 2 + (height(grid) % 2) - 1))
  new_column_4 = tuple(0 for _ in range(height(grid) // 2 + 1)) + (4,) + tuple(0 for _ in range(height(grid) // 2 + (height(grid) % 2) - 2))
  # Replace the original columns with the new columns.
  return tuple(tuple(new_column_4[i] if j == col_4 else (new_column_3[i] if j == col_3 else v) for j, v in enumerate(r)) for i, r in enumerate(grid)) 
 
0.10787471856117495, 3.4904542, def ahhabfceghbeegbgiddedbceidabbfbg(I):
  """
  Applies a lambda function to each object to center it vertically 
  using the `centerofmass` function.
  """
  center_i = height(I) // 2
  return paint(canvas(mostcolor(I), shape(I)),
               mapply(lambda obj: shift(obj, (center_i - centerofmass(obj)[0], 0)),
                      objects(I, False, False, False))) 
 
0.17955896093187373, 3.7133727, def efejgdfaefdbecdfjbgfhecfibeiaaif(I):
  objs = fgpartition(I)
  centered_objs = frozenset({(color(obj), (i, len(I[0])//2 - width(obj)//2)) for obj in objs for i, _ in toindices(obj)})
  return paint(canvas(0, shape(I)), centered_objs)
 
0.1050175757040321, 13.787177, def hahjfehadbbbeccdaiebeejbabfifefc(I):
  h, w = shape(I)
  return tuple(tuple(branch((j == w//2 - sum(row) // (2 * max(row) or 1)), v, 0) for j, v in enumerate(row)) for i, row in enumerate(I))
 
0.1630510244239372, 3.7296264, def hgcfhjhggbdjeadcaaaiccaifccgdgbi(I):
    new_grid = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            if v != 0:
                new_grid = paint(new_grid, {(v, (i, len(I[0]) // 2 - (row.count(v) + 1) // 2))})
    return new_grid
 
0.1605113418842547, 2.7632146, def edcajghbeaeieefgacdccbbjahbbcche(I):
    output = []
    for row in I:
        non_zero_indices = [j for j, v in enumerate(row) if v != 0]
        mid = len(row) // 2
        offset = (len(non_zero_indices) - 1) // 2 
        new_row = [0] * len(row)
        for k, idx in enumerate(non_zero_indices):
            new_row[mid - offset + k] = row[idx]
        output.append(tuple(new_row))
    return tuple(output)
 
0.173844675217588, 3.4886236, def eeahhbhcjdhaeffiiafefbadajfigaef(I):
  new_grid = canvas(mostcolor(I), shape(I)) # Create canvas
  for obj in fgpartition(I):
    offset = (width(I) - width(obj)) // 2 - leftmost(obj)
    new_grid = paint(new_grid, shift(obj, (0, offset))) # Paint each object
  return new_grid
 
0.20260977118119974, 8.532999, def dbegicadceecegadadbbhjjbcaecfcgg(grid):
  # Split the grid into top and bottom halves.
  top = tophalf(grid)
  bottom = bottomhalf(grid)
  # Calculate the height difference for adjustment.
  height_diff = height(bottom) - height(top)
  # Conditionally adjust top or bottom for centering.
  return vconcat(top, vconcat(((0,) * width(grid)) * height_diff, bottom)) if height_diff > 0 else vconcat(vconcat(((0,) * width(grid)) * -height_diff, top), bottom)
 
0.1050175757040321, 13.787177, def fcecfeahaaefecdbiaegcfcdaefbcfde(I):
  """
  Iterates through grid rows and repositions non-background cells 
  to the center column using cell-based operations.
  """
  h, w = shape(I)
  center_j = w // 2
  return tuple(
      tuple(
        I[i][j] if j == center_j else mostcolor(I) 
        for j in range(w)
      )
      for i in range(h)
  )
 
0.08260572863541325, 4.839546, def iddecfcdiadbebceacfdhcbdabibacch(I):
    obj3 = extract(fgpartition(I), lambda obj: color(obj) == 3)
    obj4 = extract(fgpartition(I), lambda obj: color(obj) == 4)
    center_i = len(I) // 2
    center_j = len(I[0]) // 2
    new_obj3 = shift(obj3, subtract((center_i, center_j), ulcorner(obj3)))
    new_obj4 = shift(obj4, (len(I) - 1 - uppermost(obj4), center_j - leftmost(obj4)))
    O = paint(paint(cover(I, obj3), new_obj3), new_obj4)
    return O
 
0.19599737100664744, 2.7058187, def idcgeeccdjghebiebiegfdhfcfjbbeah(I):
  return paint(
    canvas(mostcolor(I), shape(I)),
    merge(apply(lambda obj: shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), 0)), fgpartition(I)))
  )
 
0.12070096673065134, 4.0652094, def febadabagiffeejaajbgbiddfbdjdega(grid):
  objs = fgpartition(grid)  # Partition the grid into objects, excluding background.
  three = extract(objs, lambda obj: color(obj) == 3)  # Extract the '3' object.
  four = extract(objs, lambda obj: color(obj) == 4) # Extract the '4' object.
  
  # Calculate the horizontal offset to maintain relative positioning.
  h_offset = leftmost(four) - leftmost(three) 
  
  # Move '3' to the vertical center, preserving the relative horizontal offset.
  new_three = shift(three, (height(grid) // 2 - uppermost(three), h_offset)) 
  
  # Move '4' to the rightmost column.
  new_four = shift(four, (0, width(grid) - width(four) - leftmost(four))) 
  
  return paint(paint(cover(grid, three), new_three), new_four) # Combine the shifted objects.
 
0.14781292918584196, 3.2684069, def feffefbgcddcecffiajddeeefbedaaci(grid):
  threes = ofcolor(grid, 3) # Get indices of '3'.
  fours = ofcolor(grid, 4) # Get indices of '4'.
  
  # Calculate the desired positions for '3' and '4'.
  new_three_pos = (height(grid) // 2, centerofmass(threes)[1]) 
  new_four_pos = (centerofmass(fours)[0], width(grid) - 1)
  
  # Calculate the offsets for '3' and '4'.
  three_offset = subtract(new_three_pos, centerofmass(threes))
  four_offset = subtract(new_four_pos, centerofmass(fours))
  
  # Move the objects using the calculated offsets.
  grid = paint(cover(grid, threes), shift(recolor(3, threes), three_offset))
  grid = paint(cover(grid, fours), shift(recolor(4, fours), four_offset))
  return grid 
 
0.05149461752430212, 3.7511551, def cebejaddbadieaibjhagddabehhgcegb(grid):
  objs = fgpartition(grid)
  three = extract(objs, lambda obj: color(obj) == 3)
  four = extract(objs, lambda obj: color(obj) == 4)
  
  new_three = shift(three, (height(grid) // 2 - uppermost(three), width(grid) // 2 - leftmost(three)))
  new_four = shift(four, (0, width(grid) - 1 - rightmost(four)))
  
  return paint(paint(cover(grid, three), new_three), new_four)
 
0.1050175757040321, 13.787177, def eadcdcajcbageabbjeeddadfdjceecjc(grid):
  # Find the row indices of '3' and '4'.
  three_row = extract(toindices(ofcolor(grid, 3)), lambda x: True)[0] 
  four_row =  extract(toindices(ofcolor(grid, 4)), lambda x: True)[0]
  
  # Create new grids with '3' and '4' in their desired positions.
  new_grid_three = canvas(0, shape(grid))
  new_grid_three = paint(new_grid_three, {(3, (height(grid) // 2, width(grid) // 2))})
  new_grid_four = canvas(0, shape(grid))
  new_grid_four = paint(new_grid_four, {(4, (four_row, width(grid) - 1))})
  
  # Combine the grids, prioritizing the placement of '3' and '4'.
  return cellwise(new_grid_three, new_grid_four, 0)
 
0.07454138522784162, 2.310605, def hibcafgeccecegadifjaaabhiegfcddf(grid):
  # Find the '3' object
  three_obj = extract(objects(grid, True, False, True), lambda obj: color(obj) == 3)
  # Calculate the target column for the '3' object
  target_column = width(grid) // 2
  # Calculate the shift needed for the '3' object
  shift_amount = (0, target_column - leftmost(three_obj))
  # Move the '3' object
  return paint(cover(grid, three_obj), shift(three_obj, shift_amount)) 
 
0.1050175757040321, 3.5893714, def iaacafabhdidebgdjfcdaaedajhjabdc(grid):
  # Find the column index of the leftmost '3' cell.
  col = leftmost(ofcolor(grid, 3))
  # Define a lambda function to reposition a cell value
  reposition = lambda j, v: (v, (j, width(grid) // 2)) if v == 3 else (v, (j, col)) if v == 4 else (0, (j, col))
  # Apply the reposition function to each cell and assemble the output grid
  return tuple(tuple(reposition(j, v)[0] for j, v in enumerate(row)) for i, row in enumerate(grid))
 
0.05511799682486139, 7.7765474, def baceebecacgjeacejdbhhhccfaabfcif(grid):
    # Get the middle column index
    mid = width(grid) // 2
    # Transpose the grid, making columns into rows
    transposed_grid = rot90(grid)
    # Create a new transposed grid
    new_transposed_grid = tuple()
    # Iterate over rows (originally columns)
    for i, row in enumerate(transposed_grid):
        # If the row (originally a column) contains a '3'
        if 3 in row:
            # Move it to the middle row (originally middle column)
            new_transposed_grid += ((transposed_grid[mid]),)
        else:
            # Otherwise, keep the row unchanged
            new_transposed_grid += (row,)
    # Transpose back to get the final grid
    return rot270(new_transposed_grid)
 
0.173844675217588, 3.5413818, def ececfhdddddcecaaiabddgafccabddec(I):
  objs = fgpartition(I)  # Partition the input into non-background objects
  mid = width(I) // 2  # Calculate the horizontal middle of the grid
  O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
  for obj in objs:
    O = paint(O, shift(obj, (0, mid - centerofmass(obj)[1]))) # Shift each object horizontally to the center
  return O
 
0.17955896093187373, 3.7133727, def ghihaedgcgbaejhcidafejdagabgdbdb(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge({shift(obj, (0, width(I)//2 - (leftmost(obj) + width(obj)//2))) for obj in fgpartition(I)})
      )
 
0.19599737100664744, 2.6975377, def ebffbgbjjedbeeebideecbhabeeacbaa(I):
  return paint(
    canvas(mostcolor(I), shape(I)),
    merge(apply(lambda obj: shift(obj, (height(I) // 2 - center(obj)[0], 0)), fgpartition(I)))
  )
 
0.19599737100664744, 2.7045522, def cfdafggeaeeeejaaibfdfgjgbajchdab(I):
  return paint(
    canvas(mostcolor(I), shape(I)), 
    merge([shift(obj, ((height(I) - height(obj)) // 2 - uppermost(obj), 0)) for obj in fgpartition(I)])
  )
 
0.1427532413988815, 3.565291, def aedgdcfaedaceaicjfjjeeheahfjgcfd(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(apply(lambda obj: shift(obj, (subtract(divide(height(I), 2), divide(add(uppermost(obj), height(obj)), 2)), 0)), fgpartition(I)))
  )
 
0.07454138522784162, 2.310605, def cchafddfaageecfcaedediabcfbcgcjg(grid):
  objs = fgpartition(grid)  # Partition the grid into objects, excluding background
  three = extract(objs, lambda obj: color(obj) == 3)  # Extract the object with color '3'
  center_column = width(grid) // 2  # Find the center column index
  three_center = centerofmass(three)[1] # Get the column index of the '3' object's center of mass
  offset =  (0, center_column - three_center) # Calculate the horizontal offset 
  new_three = shift(three, offset)  # Shift the '3' object horizontally
  return paint(cover(grid, three), new_three)  # Paint the shifted object back onto the grid
 
0.12705017307985766, 5.699609, def cecifbgecdhfeeaeiabiaacccagbaeba(grid):
  # Find the '3' object.
  three_obj = extract(partition(grid), lambda obj: color(obj) == 3)
  # Calculate the horizontal shift to center the '3' object.
  shift_amount = width(grid) // 2 - (leftmost(three_obj) + width(three_obj) // 2)
  # Shift all objects in the grid.
  return paint(canvas(0, shape(grid)), shift(three_obj, (0, shift_amount))) 
 
0.14781292918584196, 3.6126251, def ejdfecfihcceeiaabccbddbffciagbcg(grid):
  # Find the column index of the leftmost '3'.
  leftmost_3_j = min(j for i, row in enumerate(grid) for j, v in enumerate(row) if v == 3)
  # Calculate the shift amount to center the '3' object horizontally.
  shift_amount = width(grid) // 2 - leftmost_3_j - 1
  # Create a new grid by shifting each row of the input grid.
  return tuple(tuple(grid[i][(j + shift_amount) % width(grid)] for j in range(width(grid))) for i in range(height(grid)))
 
0.19098753236044516, 3.6092598, def dbeccbhahjdgedghaejfdgefjecehebd(grid):
  # Create a function to check if a cell contains '3'.
  is_three = lambda loc: index(grid, loc) == 3
  # Find the leftmost and rightmost occurrences of '3'.
  leftmost_3_j = min(j for i, row in enumerate(grid) for j, v in enumerate(row) if is_three((i, j)))
  rightmost_3_j = max(j for i, row in enumerate(grid) for j, v in enumerate(row) if is_three((i, j)))
  # Calculate the center of the '3' object.
  obj_center_j = (leftmost_3_j + rightmost_3_j) // 2 
  # Calculate the shift amount for centering.
  shift_amount = width(grid) // 2 - obj_center_j
  # Create a new grid by shifting each row of the input grid.
  return tuple(tuple(grid[i][(j + shift_amount) % width(grid)] for j in range(width(grid))) for i in range(height(grid)))
 
0.1050175757040321, 3.1004848, def ajdcaabcfbcgejihajehjjdfbdegaaef(grid):
  # Extract the '3' object.
  three_obj = extract(objects(grid, True, False, True), lambda obj: color(obj) == 3)
  # Calculate the target row for vertical centering.
  target_row = height(grid) // 2 
  # Calculate the vertical shift needed.
  shift_amount = (target_row - uppermost(three_obj) - height(three_obj) // 2, 0)
  # Move the '3' object.
  return paint(cover(grid, three_obj), shift(three_obj, shift_amount))
 
0.06774688309011129, 5.771774, def cgcabiacghbbejdcbdfgegacfbbgchej(grid):
  # Find the row index of the '3' object
  row_index = first(i for i, r in enumerate(grid) if 3 in r)
  # Calculate the target row for vertical centering.
  target_row = height(grid) // 2
  # Calculate the vertical shift amount
  shift_amount = target_row - row_index
  # Shift the row containing '3'
  return tuple(r if i != row_index else grid[i + shift_amount] for i, r in enumerate(grid)) 
 
0.15752636355604815, 7.7523637, def cjhefdebifbcecbabbdihfcddfcbacab(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(
          {shift(obj, subtract((height(I) // 2, 0), centerofmass(obj))) for obj in fgpartition(I)}
      )
  )
 
0.173844675217588, 3.4886236, def abbigcddahacehbcjebacdehdbdbifgc(I):
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    left_edge = leftmost(obj)
    right_edge = rightmost(obj)
    center_offset = (width(I) - (right_edge - left_edge + 1)) // 2
    new_grid = paint(new_grid, shift(obj, (0, center_offset - left_edge)))
  return new_grid
 
0.1050175757040321, 2.9255724, def hccadfddfhefedcbigbdjgajfjcecdce(grid):
  # Find the '3' object.
  three_obj = extract(partition(grid), lambda obj: color(obj) == 3)
  # Calculate the vertical offset to center the '3' object.
  offset = (height(grid) // 2) - (uppermost(three_obj) + height(three_obj) // 2)
  # If centering '3' would clash with '4', adjust the offset.
  four_obj = extract(partition(grid), lambda obj: color(obj) == 4)
  if hmatching(shift(three_obj, (offset, 0)), four_obj):
    offset -= 1
  # Shift the '3' object vertically.
  centered_three_obj = shift(three_obj, (offset, 0))
  # Remove the original '3' object and paint the centered one.
  return paint(cover(grid, three_obj), centered_three_obj)
 
0.1050175757040321, 3.093568, def cffdifffdchaefcabbfgjfffggcffida(grid):
  # Get indices of '3' and '4'.
  three_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 3)
  four_loc = extract(asindices(grid), lambda loc: index(grid, loc) == 4)
  # Calculate target row for '3'.
  target_row = height(grid) // 2 
  if three_loc[1] == four_loc[1]:
    target_row -= 1
  # Calculate vertical offset for '3'.
  offset = target_row - three_loc[0]
  # Shift the '3' by modifying the grid directly. 
  return fill(fill(grid, 0, initset(three_loc)), 3, initset((three_loc[0] + offset, three_loc[1])))
 
0.15181207784176243, 5.784354, def dfihdfacceceeebcjaahadecbcdjefga(grid):
  # Create a function to center an object vertically.
  def center_vertically(obj, grid):
    offset = (height(grid) // 2) - (uppermost(obj) + height(obj) // 2)
    return shift(obj, (offset, 0))
  # Apply centering to the '3' object.
  return paint(grid, center_vertically(extract(partition(grid), lambda obj: color(obj) == 3), grid)) 
 
0.2040383426097712, 8.55031, def jhiaagbdhefaedbcjieadebhfdjafbdb(grid):
  # Split the grid horizontally into two halves.
  top_half = tophalf(grid)
  bottom_half = bottomhalf(grid)
  # Find the '3' object.
  three_obj = extract(partition(grid), lambda obj: color(obj) == 3)
  # Determine if '3' is in the top or bottom half.
  in_top = any(index(top_half, (i, j)) == 3 for i, j in toindices(three_obj))
  # Concatenate the halves, placing '3' in the appropriate half.
  if in_top:
    return vconcat(top_half, bottom_half)
  else:
    return vconcat(bottom_half, top_half) 
 
0.1050175757040321, 3.2014184, def fhbddgbfhbdbebdhbcbjhajhafcaidaj(grid):
  # Find the '3' object.
  three_obj = extract(partition(grid), lambda obj: color(obj) == 3)
  # Calculate the desired center row for '3'.
  target_row = height(grid) // 2 - (1 if height(grid) % 2 == 0 else 0)
  # Calculate the vertical offset.
  offset = target_row - uppermost(three_obj)
  # Shift the '3' object.
  shifted_three = shift(three_obj, (offset, 0))
  # Clear the original '3' and paint the shifted '3'.
  return paint(cover(grid, three_obj), shifted_three)
 
0.15181207784176243, 5.784354, def ceaaiafhjadaehejbccecabadfbfejce(grid):
  three_indices = ofcolor(grid, 3)
  target_row = height(grid) // 2
  return tuple(
      tuple(
          3 if (i, j) in shift(three_indices, (target_row - uppermost(three_indices), 0)) else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
0.05822307356630176, 4.7551727, def habjdehhcbbeeecdacjhejibiaaccgcb(grid):
  return tuple(
      tuple(
          v if v != 3 else (
              3 if i == height(grid) // 2 else 0
          )
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
0.173844675217588, 3.5413818, def ijdffcecbbdjefeabhdeabeafhfcccbi(I):
  objs = []
  for obj in fgpartition(I):
    center_x = (leftmost(obj) + rightmost(obj)) // 2
    target_x = width(I) // 2
    offset_x = target_x - center_x
    objs.append(shift(obj, (0, offset_x)))
  return paint(canvas(mostcolor(I), shape(I)), merge(objs))
 
0.17955896093187373, 3.7133727, def bfbjeieeedaaegjabjdeibicfhibacfe(I):
  def center_object(obj):
    obj_width = rightmost(obj) - leftmost(obj) + 1
    offset = width(I) // 2 - (leftmost(obj) + obj_width // 2)
    return shift(obj, (0, offset))

  return paint(
      canvas(mostcolor(I), shape(I)), 
      merge(apply(center_object, fgpartition(I)))
  )
 
0.10673271276239736, 4.740036, def jacbgaadecabejbfieadddbcbcfdhjdh(I):
  objs = fgpartition(I) # Partition the grid into objects, excluding the background.
  three = extract(objs, lambda obj: color(obj) == 3) # Extract the object with color '3'.
  four = extract(objs, lambda obj: color(obj) == 4) # Extract the object with color '4'.
  new_three = shift(three, (height(I) // 2 - uppermost(three) - 1, width(I) // 2 - leftmost(three))) # Calculate the new position for '3'.
  new_four = shift(four, (height(I) - uppermost(four) - 1, 0))  # Calculate the new position for '4'.
  O = paint(paint(cover(I, three), new_three), new_four) # Paint the objects onto a blank canvas.
  return O
 
0.12749546886838167, 2.9822857, def deaedgadeddfefecidbfjaijieffceah(grid):
  threes = ofcolor(grid, 3)  # Get indices of '3'.
  fours = ofcolor(grid, 4)  # Get indices of '4'.
  new_three_pos = (height(grid) // 2 - 1, width(grid) // 2) # Calculate the new position for the center of '3'.
  new_four_pos = (height(grid) - 1, centerofmass(fours)[1]) # Calculate the new position for the center of '4'.
  three_offset = subtract(new_three_pos, centerofmass(threes)) # Calculate the offset to move '3'.
  four_offset = subtract(new_four_pos, centerofmass(fours)) # Calculate the offset to move '4'.
  grid = paint(cover(grid, threes), shift(recolor(3, threes), three_offset)) # Move '3' to its new position.
  grid = paint(cover(grid, fours), shift(recolor(4, fours), four_offset)) # Move '4' to its new position.
  return grid
 
0.1050175757040321, 3.1004848, def cbehdeeiaddeeiifaddjbhjbbbbbibac(grid):
  three_obj = extract(partition(grid), lambda obj: color(obj) == 3)
  center_row = height(grid) // 2
  obj_center_row = uppermost(three_obj) + height(three_obj) // 2
  offset = center_row - obj_center_row
  centered_three_obj = shift(three_obj, (offset, 0))
  cleared_grid = cover(grid, three_obj)
  return paint(cleared_grid, centered_three_obj)
 
0.08977948046593687, 2.5745254, def jichcedbafaceccfieiciacjfcaeecga(grid):
  # Find the row containing the '3' digit.
  three_row_index = first(i for i, row in enumerate(grid) if 3 in row)
  # Extract the row containing the '3' object.
  three_row = grid[three_row_index]
  # Create a new row with '3' at the center.
  new_row = tuple(0 for _ in range(width(grid) // 2)) + (3,) + tuple(0 for _ in range(width(grid) // 2 + (width(grid) % 2) - 1))
  # Replace the original row with the new row.
  return tuple(r if i != three_row_index else new_row for i, r in enumerate(grid)) 
 
0.5144094001236857, 69.86472, def hejifahdahfaecbcbacbdfihahfbdehg(grid):
  return tuple(
      tuple(
          3 if j == width(grid) // 2 else v 
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid) if 3 in row or not any(3 in r for r in grid)
  )
 
0.12705017307985766, 6.265324, def fcfheffadhgiebdeaacdieeeedaadaad(grid):
  return tuple(
      tuple(
          3 if (i, j) == (first(i for i, row in enumerate(grid) if 3 in row), width(grid) // 2) 
          else v 
          for j, v in enumerate(row)
      ) 
      for i, row in enumerate(grid)
  ) 
 
0.230158783702383, 21.197613, def chijjedabaicejcfidachcbfiicdfifb(grid):
  three_col = first(j for j in range(width(grid)) if any(3 == grid[i][j] for i in range(height(grid))))
  return tuple(
      tuple(
          3 if j == width(grid) // 2 else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
0.12166456507829422, 3.4155922, def gfcfjfeecbfaecbabbgadcfibfgffbhe(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      shift(merge(fgpartition(I)), (0, width(I)//2 - (leftmost(merge(fgpartition(I))) + width(merge(fgpartition(I)))//2)))
  )
 
0.19717800855092132, 3.5462515, def gfebfbgabggheffjjhgbhagbhjgfjacc(I):
  return hmirror(lefthalf(hconcat(I, hmirror(I))))
 
0.17955896093187373, 3.6654418, def aedcjajfaehbeccdajefecebfihdeebi(I):
  return paint(
    canvas(mostcolor(I), shape(I)),
    merge(apply(lambda obj: shift(obj, (0, -leftmost(obj) + (width(I) - width(obj)) // 2)), fgpartition(I)))
  )
 
0.09530414133382593, 4.440979, def cicgeghcadfbejjcaefbfcegdbdgciab(grid):
  objs = fgpartition(grid)  # Partition the grid into objects, excluding background
  three = extract(objs, lambda obj: color(obj) == 3)  # Extract the object with color '3'
  four = extract(objs, lambda obj: color(obj) == 4) # Extract the object with color '4'
  center_column = width(grid) // 2  # Find the center column index
  three_center = centerofmass(three)[1] # Get the column index of the '3' object's center of mass
  offset_three =  (0, center_column - three_center) # Calculate the horizontal offset for '3'
  new_three = shift(three, offset_three)  # Shift the '3' object horizontally
  offset_four = (height(grid) - 1 - uppermost(four), 0) # Calculate vertical offset to move '4' to bottom row
  new_four = shift(four, offset_four) # Shift '4' object vertically
  return paint(paint(cover(grid, three), new_three), new_four)  # Paint the shifted objects back onto the grid
 
0.11606689743981025, 2.8186743, def acifcbedgfajejaabhbdebccdccfaebf(grid):
  objs = fgpartition(grid)  # Partition the grid into objects, excluding background
  three = extract(objs, lambda obj: color(obj) == 3) # Extract '3' object
  four = extract(objs, lambda obj: color(obj) == 4) # Extract '4' object
  new_grid = grid
  for obj in [three, four]: 
    if color(obj) == 3:
      new_grid = paint(cover(new_grid, obj), shift(obj, (0, width(grid) // 2 - centerofmass(obj)[1]))) # Center '3'
    else:
      new_grid = paint(cover(new_grid, obj), shift(obj, (height(grid) - 1 - uppermost(obj), 0))) # Move '4' to bottom
  return new_grid
 
0.08914455983101623, 10.661972, def jefecjehbajhebdbjbdaiabcbdehjhad(grid):
  h, w = len(grid), len(grid[0]) # Get grid dimensions
  new_grid = canvas(0, (h, w)) # Create a blank canvas
  for i, row in enumerate(grid):
    for j, value in enumerate(row):
      if value == 3:
        new_grid = paint(new_grid, {(value, (i, w // 2))}) # Place '3' in center column
      elif value == 4:
        new_grid = paint(new_grid, {(value, (h - 1, j))}) # Place '4' in bottom row
      else:
        new_grid = paint(new_grid, {(value, (i, j))}) # Keep other values at original position
  return new_grid 
 
0.12641525244493707, 3.2886536, def fedadefdcgbfecdbjbgbecgcfbgiehga(grid):
  # Directly modify the grid using list comprehension.
  return tuple(
      tuple(
          3 if v == 3 else (
              grid[i][j + (width(grid) // 2 - (len(row) // 2 if len(set(row)) == 1 and 3 in row else 0))] 
              if j < width(grid) // 2 - (len(row) // 2 if len(set(row)) == 1 and 3 in row else 0) else v
          ) 
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
0.1050175757040321, 3.5893714, def dbgeaafbafceeefbjadbdgeeeefceadf(grid):
  # Create a new grid with the '3' object centered horizontally.
  new_grid = tuple(
      tuple(
          3 if (i, j) in shift(normalize(extract(partition(grid), lambda obj: color(obj) == 3)), (i, width(grid) // 2 - width(extract(partition(grid), lambda obj: color(obj) == 3)) // 2)) 
          else v 
          for j, v in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
  return new_grid
 
0.12025567094212733, 10.612432, def babfcbfhcjabedfabcdfjgadibbcbida(I):
  return tuple(
    tuple(
        v if j in range(width(I) // 2 - (len([x for x in row if x != mostcommon(row)]) // 2), 
                        width(I) // 2 + (len([x for x in row if x != mostcommon(row)]) + 1) // 2)
        else mostcommon(row)
        for j, v in enumerate(row) 
    )
    for row in I
  )
 
0.10952380952380951, 35.672874, def bdfbicjbibhgebaebaabbbaeefgbdeff(I):
  return tuple(
    tuple(
        v if any(v == c for c, (i2, j2) in obj) and j == width(I) // 2 - (leftmost(obj) + width(obj) // 2) + k
        else mostcolor(I) 
        for j, v in enumerate(row) 
        for k in range(width(obj))
    )
    for row in I
    for obj in fgpartition(I) if any(v == c for c, (i2, j2) in obj for v in row)
  )
 
0.1050175757040321, 3.1004848, def cedeeecacgdiedjcjbigaaccedbfibji(grid):
  objs = fgpartition(grid) # Partition the grid into foreground objects
  three = extract(objs, lambda obj: color(obj) == 3) # Extract the object with color '3'
  grid_center_row = height(grid) // 2 # Calculate the row index for the grid's vertical center
  three_center_row = centerofmass(three)[0] # Get the row index of the '3' object's center of mass
  row_offset = grid_center_row - three_center_row # Calculate the vertical offset
  new_three = shift(three, (row_offset, 0)) # Shift the '3' object vertically
  return paint(cover(grid, three), new_three)  # Paint the shifted object back onto the grid
 
0.19098753236044516, 3.6092598, def fbffeecceceeeeaeabdiefaeeicbfhdc(grid):
  # Calculate the horizontal offset needed to center the '3' object
  offset =  width(grid) // 2 - (leftmost(ofcolor(grid, 3)) + width(extract(objects(grid, True, False, True), lambda obj: color(obj) == 3)) // 2)
  # Create a new grid by shifting all elements horizontally
  new_grid = tuple(
      tuple(grid[i][(j + offset) % width(grid)] for j in range(width(grid)))
      for i in range(height(grid))
  )
  return new_grid
 
0.1050175757040321, 3.5893714, def behibebdibgcedjdajbceefbagbdfdhf(I):
  objs = fgpartition(I)
  mid = width(I) // 2
  return tuple(
    tuple(
      next((color(obj) for obj in objs if (i,j) in toindices(obj)), mostcolor(I))
      for j in range(width(I))
    )
    for i in range(height(I))
  )
 
0.1050175757040321, 13.787177, def ehfabehfbdfceaecibehbagadifdfdca(I):
  return tuple(
      tuple(
          index(I, (i, j + width(I) // 2 - centerofmass(extract(fgpartition(I), lambda obj: (i,j) in toindices(obj)))[1])) 
          if any((i,j) in toindices(obj) for obj in fgpartition(I)) 
          else mostcolor(I) 
          for j in range(width(I))
      )
      for i in range(height(I))
  )
 
0.06866836935482576, 2.8117216, def acfaceegefggeecaideeedbbddfbedjg(grid):
  # Create a function to center an object horizontally
  center_horizontally = lambda obj: shift(obj, ((width(grid) // 2) - (leftmost(obj) + width(obj) // 2), 0))
  # Create a function to center an object vertically
  center_vertically = lambda obj: shift(obj, (0, (height(grid) // 2) - (uppermost(obj) + height(obj) // 2)))
  # Find the '3' object.
  three_obj = next(obj for obj in partition(grid) if color(obj) == 3)
  # Center the '3' object both vertically and horizontally
  centered_three_obj = center_horizontally(center_vertically(three_obj))
  # Replace the original object with the centered one.
  return paint(cover(grid, three_obj), centered_three_obj)
 
0.20260977118119974, 8.532999, def cacfadeebdadebdfaajefheejcfjcjhc(grid):
  # Split the grid horizontally
  top_half = tophalf(grid)
  bottom_half = bottomhalf(grid)
  # Calculate the height difference
  height_diff = height(bottom_half) - height(top_half)
  # Add empty rows to the shorter half
  if height_diff > 0:
    top_half = vconcat(top_half, canvas(0, (height_diff, width(grid))))
  elif height_diff < 0:
    bottom_half = vconcat(canvas(0, (-height_diff, width(grid))), bottom_half)
  # Concatenate the halves back
  return vconcat(top_half, bottom_half)
 
0.09113852546134549, 3.7522886, def hhiadaeaffgeeefeaicabfiefgcieehb(grid):
  # Calculate the target row for the '3'
  target_row = height(grid) // 2
  # Find the row containing '3'
  three_row = next(i for i, row in enumerate(grid) if 3 in row)
  # Calculate the number of rows to move
  move_rows = target_row - three_row
  # Shift the row containing '3'
  if move_rows > 0:
    grid = tuple(grid[i + move_rows] if i < target_row else row for i, row in enumerate(grid))
  elif move_rows < 0:
    grid = tuple(grid[i + move_rows] if i >= target_row else row for i, row in enumerate(grid))
  return grid
 
0.0862291079359725, 4.687769, def cbjfabadhdffegiaaacifcagfghiefbb(grid):
  # Find the column index of the leftmost '3' cell.
  col = leftmost(ofcolor(grid, 3))
  # Calculate the target column index for centering
  target_column = width(grid) // 2 - (1 if col < width(grid) // 2 else 0)
  # Create a new grid by shifting the column with '3'
  return tuple(
      tuple(
        grid[i][j] if j != col else grid[i][(j + target_column - col) % width(grid)]
      for j in range(width(grid)))
      for i in range(height(grid))
  ) 
 
0.1249866810163656, 9.902514, def afaeadhdaabeeccabbadbbiifbgacjha(I):
  return tuple(
    tuple(
      next(
        (v for v, (i2, j2) in asobject(I) if i == i2 and j == width(I) // 2), 
        mostcolor(I)
      ) 
      for j in range(width(I))
    )
    for i in range(height(I))
  )
 
0.2684394434672728, 24.275324, def ehiadahaefhfedahibhajicacedgbcei(I):
  center_col = width(I) // 2
  return tuple(
      tuple(
          I[i][j] if j == center_col else next((v for v in I[i] if v != mostcolor(I)), mostcolor(I))
          for j in range(width(I))
      )
      for i in range(height(I))
  )
 
0.08977948046593687, 2.5745254, def eeabfceefgdfecfaiheibechidideabf(grid):
  # Iterate through rows to find the row containing '3'.
  for i, row in enumerate(grid):
    if 3 in row:
      # Find the column index of '3'.
      j = row.index(3)
      # Calculate the offset for centering.
      offset = (len(row) // 2) - j
      # Shift the '3' within the row.
      new_row = tuple(0 if k != j + offset else 3 for k in range(len(row)))
      # Replace the original row with the modified row.
      grid = tuple(r if k != i else new_row for k, r in enumerate(grid))
      break
  return grid
 
0.14781292918584196, 3.6126251, def dfdeheabiigaeddbbceccdedfgadgefd(grid):
  # Find the horizontal position of the '3' object's left edge
  left_edge = leftmost(extract(objects(grid, True, False, True), lambda obj: color(obj) == 3))
  # Calculate the shift amount to center the '3' object
  shift_amount = width(grid) // 2 - left_edge - 1
  # Create a new grid with shifted columns
  return tuple(
      tuple(
          grid[i][(j + shift_amount) % width(grid)] for j in range(width(grid))
      ) for i in range(height(grid))
  )  
 
0.18489747729079825, 4.0419807, def aehjegbdaebceeceibeacajadfejebbc(grid):
  # Calculate the horizontal shift based on the '3' object's position
  shift_amount = width(grid) // 2 - center(extract(objects(grid, True, False, True), lambda obj: color(obj) == 3))[1]
  # Create a new grid by shifting the existing grid horizontally
  return rot90(
      tuple(
          tuple(
              grid[i][(j + shift_amount) % width(grid)] 
              for j in range(width(grid))
          ) 
          for i in range(height(grid))
      )
  )
 
0.15752636355604815, 3.512228, def cbafidbdcfhiehfhifdbaifeaeceecjd(I):
  # Create a function to swap colors
  swap = lambda v: {3:4, 4:3}.get(v, v)
  # Apply the swap function to each cell of the grid
  return tuple(tuple(swap(v) for v in row) for row in I)
 
0.14781292918584196, 8.641878, def bgefhfjiibcaeaihjgfhfaedacfbcddb(grid):
  def transform_object(obj):
    if color(obj) == 3:
      return shift(obj, (0, width(grid) // 2 - centerofmass(obj)[1]))
    elif color(obj) == 4:
      return shift(obj, (height(grid) - 1 - uppermost(obj), 0))
    else:
      return obj 

  return paint(grid, merge(apply(transform_object, fgpartition(grid))))
 
0.12749546886838167, 3.760414, def ffbchfhfbgbeeicgbejidebgaeagefei(grid):
    # Get the row index of the '3' object's center.
    three_row = next(i for i, row in enumerate(grid) if 3 in row)
    # Calculate the vertical offset for centering.
    offset = (height(grid) // 2) - three_row - 1 
    # Shift all rows of the grid vertically.
    return tuple(grid[(i + offset) % height(grid)] for i in range(height(grid)))
 
0.15752636355604815, 5.448191, def bhgjbaeghibfefhbaahfjdcjbiahafdf(grid):
  # Directly construct a new grid with the '3' object centered.
  centered_grid = canvas(0, shape(grid))
  three_obj = next(obj for obj in partition(grid) if color(obj) == 3)
  centered_three_obj = shift(three_obj, ((height(grid) // 2) - (uppermost(three_obj) + height(three_obj) // 2), 0))
  return paint(centered_grid, centered_three_obj)
 
0.11606689743981025, 3.8047032, def idcfdiafbjhcedhciifaabffeehabaga(grid):
  # Check if the grid is already centered, and if so, return the original grid.
  three_row = next(i for i, row in enumerate(grid) if 3 in row)
  if three_row == height(grid) // 2:
    return grid
  else:
    # Otherwise, apply vertical centering (similar to Program Version 3).
    offset = (height(grid) // 2) - three_row - 1
    return tuple(grid[(i + offset) % height(grid)] for i in range(height(grid))) 
 
0.19314022814950457, 2.7179224, def debecfhbffaiecfcjegiifefbjbdddjb(I):
  objs = objects(I, True, False, True)
  new_objs = frozenset()
  for obj in objs:
    c = color(obj)
    i, j = centerofmass(obj)
    h = height(I)
    new_i = h // 2 - (height(obj) // 2) if h % 2 == len(obj) % 2 else h // 2 - (height(obj) // 2) - (1 if i < h // 2 else -1)
    new_objs = new_objs | shift(recolor(c, obj), (new_i - i, 0))
  O = paint(canvas(mostcolor(I), shape(I)), new_objs)
  return O 
 
0.19599737100664744, 2.7045522, def bgeeedafiddeedbdbgffhhgdacjcfcae(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  for j in range(w):
    column = tuple(I[i][j] for i in range(h))
    values = [v for v in column if v != bg]
    new_column = [bg for _ in range(h)]
    start_i = (h - len(values)) // 2
    for k, v in enumerate(values):
      new_column[start_i + k] = v
    O = tuple(O[i][:j] + (new_column[i],) + O[i][j+1:] for i in range(h))
  return O
 
0.14393387894315537, 5.242566, def cdddbdbhhihbedhbjfecfcfhedefgiee(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (-1, -leftmost(obj))))
    elif c == 4:
      O = paint(O, shift(obj, (height(I) - uppermost(obj) - 1, 0)))
  return O
 
0.14393387894315537, 5.712948, def adbcbbbbbacieddbjadabgdgbfhacbdc(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 3:
        O = paint(O, {(3, (i + 1, 0))})
      elif val == 4:
        O = paint(O, {(4, (height(I) - 1, j))})
  return O
 
0.06901324402252047, 3.3127997, def gjdbdgcaeedeehaiicfdacehdjaibcdd(I):
  objs = fgpartition(I)
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in objs:
    for v, (i, j) in obj:
      if v == 3:
        O = paint(O, {(v, (i, w // 2))})
      elif v == 4:
        O = paint(O, {(v, (h - 1, j))})
  return O
 
0.14393387894315537, 3.4508317, def dceejeghjbadediajegcfbfdabadfaee(I):
  objs = objects(I, True, False, True)
  def move_digit(obj, target_row):
    return shift(obj, (target_row - uppermost(obj), 0))
  new_objs = apply(lambda obj: move_digit(obj, height(I) // 2) if color(obj) == 3 else move_digit(obj, height(I) - 1), objs)
  O = paint(canvas(0, shape(I)), merge(new_objs))
  return O
 
0.19599737100664744, 2.6839135, def hdcfbjdgfgjgecidbhgbafjbefdacbfa(I):
  h = height(I)
  w = width(I)
  O = canvas(mostcommon(I), (h, w))
  for j in range(w):
    column_obj = frozenset((I[i][j], (i, j)) for i in range(h) if I[i][j] != mostcommon(I))
    if column_obj:
      min_i = uppermost(column_obj)
      max_i = lowermost(column_obj)
      new_i = (h - (max_i - min_i + 1)) // 2
      O = paint(O, shift(column_obj, (new_i - min_i, 0)))
  return O 
 
0.09285366251971075, 8.771567, def hfbicdadcgjcebdgjigbfabdbafiagee(I):
  threes = ofcolor(I, 3)  # Get indices of '3'
  fours = ofcolor(I, 4)   # Get indices of '4'
  h, w = shape(I)         # Get grid dimensions

  # Dynamic shift for '3' based on grid height
  new_threes = shift(threes, (-h // 2, 1)) 

  # Dynamic shift for '4' based on grid height
  new_fours = shift(fours, (h // 2, 0)) 

  O = fill(fill(canvas(0, (h, w)), 3, new_threes), 4, new_fours) # Fill canvas
  return O
 
0.13492837197846477, 3.4626443, def dbgabcejifjbedhajaaecbcaddafhefa(I):
  objs = fgpartition(I) # Partition into objects (excluding background)
  h, w = shape(I)       # Get grid dimensions
  O = canvas(0, (h, w))  # Create blank canvas

  for obj in objs:
    c = color(obj)     # Get object color
    if c == 3:
      O = paint(O, shift(obj, (-1, 1)))  # Move '3' up and right
    elif c == 4:
      # Calculate '4' movement based on '3'
      if leftmost(toobject(ofcolor(I, 3), I)) < leftmost(obj):
        O = paint(O, shift(obj, (h - uppermost(obj) - 1, -1))) # Down & left
      else:
        O = paint(O, shift(obj, (h - uppermost(obj) - 1, 0)))  # Down only
  return O
 
0.1393728164229092, 3.2961, def dfahihehifaceedciggcdehdhggaabif(I):
  h, w = shape(I)
  O = canvas(0, (h, w))
  
  for i in range(h):
    for j in range(w):
      if index(I, (i, j)) == 3:
        O = paint(O, {(3, (i - 1, j + 1))}) # Move '3' up and right
      elif index(I, (i, j)) == 4:
        # '4' movement based on '3' position
        if j < leftmost(toobject(ofcolor(I, 3), I)):
          O = paint(O, {(4, (h - i - 1, j - 1))}) # Down and left
        else:
          O = paint(O, {(4, (h - i - 1, j))})  # Down only
  return O
 
0.10075927576855222, 3.624789, def befafababicfejcdbaddebeedbabaafb(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    if color(obj) == 3:
      O = paint(O, shift(obj, (0, w // 2 - centerofmass(obj)[1])))
    elif color(obj) == 4:
      O = paint(O, shift(obj, (h - 1 - uppermost(obj), w - 1 - rightmost(obj))))
  return O
 
0.17567991068918712, 3.6683888, def dibcbedieafeebfcaafgjbijcbcfjhhg(I):
  objs = fgpartition(I)
  h, w = shape(I)
  O = canvas(0, (h, w))

  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (-1, 0))) # '3' up 
    elif c == 4:
      if any(i == uppermost(obj) and j > leftmost(toobject(ofcolor(I, 3), I)) 
             for i, j in toindices(obj)):
        O = paint(O, shift(obj, (h - uppermost(obj) - 1, -1))) # '4' down & left
      else:
        O = paint(O, shift(obj, (h - uppermost(obj) - 1, 0))) # '4' down
  return O
 
0.1384787445084291, 6.34856, def eddajfaddeddeeafaacehjeiffbdjebc(I):
  h, w = shape(I)
  objs = fgpartition(I)
  transformed_objs = frozenset({shift(obj, 
                              (h // 4 - uppermost(obj), w // 2 - centerofmass(obj)[1]) if color(obj) == 3 
                              else (h - height(obj), 0) if color(obj) == 4
                              else (0, 0)) 
                              for obj in objs})
  return paint(canvas(mostcolor(I), (h, w)), merge(transformed_objs))
 
0.1257803318100164, 6.266998, def daiafdedbgejecdhagdcaafbbhfcejdf(I):
  obj3 = toobject(ofcolor(I, 3), I)
  obj4 = toobject(ofcolor(I, 4), I)
  offset =  (width(I) - width(obj3)) // 2
  O = paint(canvas(0, shape(I)), shift(obj3, (0, offset)))
  O = paint(O, shift(obj4, (1, offset))) 
  return O
 
0.08260572863541325, 6.510853, def cdfbaaaaijceecddaadaedfbjagbjbae(I):
  h, w = shape(I)
  return paint(canvas(mostcolor(I), (h, w)),
               merge([shift(obj, (0, w // 2 - centerofmass(obj)[1])) if color(obj) == 3 
                      else shift(obj, (h - height(obj), 0)) if color(obj) == 4 
                      else obj for obj in fgpartition(I)]))
 
0.1384787445084291, 5.9755077, def ibdbdacibhjieebeifjijdfcfdcechac(I):
  def reposition(grid, value, target):  # Function to reposition an object
    indices = ofcolor(grid, value)
    if indices: # Check if indices is not empty
      new_indices = shift(indices, (target[0] - uppermost(indices), target[1] - leftmost(indices)))
      return fill(canvas(0, shape(grid)), value, new_indices)
    else:
      return grid # Return original grid if no object found

  target_three = (height(I) // 2 - 1, width(I) // 2)  # Define target for 3
  target_four = (height(I) -1, width(I) // 2)  # Define target for 4
  O = reposition(reposition(I, 3, target_three), 4, target_four)  # Reposition 3 then 4
  return O
 
0.18837832338759983, 3.3470712, def hacfeeiibbaceedebadeghhadhfafhca(I):
  def move_to_center_column(grid, value, target_row):
    indices = ofcolor(grid, value)
    if indices: # Check if indices is not empty
      column_offset = width(I) // 2 - leftmost(indices)
      return shift(indices, (target_row - uppermost(indices), column_offset))
    else:
      return frozenset() # Return empty set if no object found

  threes = move_to_center_column(I, 3, height(I) // 2 - 1)
  fours = move_to_center_column(I, 4, height(I) - 1)
  O = fill(fill(canvas(0, shape(I)), 3, threes), 4, fours)
  return O
 
0.19599737100664744, 2.5779572, def faciaeecfcjcehddbafdjbcbaggdebdh(I):
  h, w = shape(I)
  obj3 = {(3, (i-1, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == 3} # '3' up
  obj4 = {(4, (h-i-1, j - (1 if any(x > leftmost(obj3) for _, (x, _) in obj3) else 0))) for i, r in enumerate(I) for j, v in enumerate(r) if v == 4} # '4' conditional move
  return paint(paint(canvas(0, (h, w)), obj3), obj4) 
 
0.1050175757040321, 13.787177, def ebebbbdfbiifebcabaecejfceehegebb(I):
    h, w = shape(I)

    def move_and_paint(grid, value, target_row):
        indices = ofcolor(grid, value)
        if indices:
            new_indices = shift(indices, (target_row - uppermost(indices), w // 2 - leftmost(indices)))
            return fill(grid, value, new_indices)
        else:
            return grid

    O = canvas(0, (h, w))  
    O = move_and_paint(O, 3, h // 2 - 1)
    O = move_and_paint(O, 4, h - 1) 
    return O
 
0.15980689481617125, 3.7299533, def baffacbcdeeieafjjfaaieiidebceebf(I):
    threes = {(v, (i, width(I) // 2 - leftmost(ofcolor(I, 3)))) for v, (i, j) in asobject(I) if v == 3}
    fours =  {(v, (height(I) - 1, j + width(I) // 2 - leftmost(ofcolor(I, 4)))) for v, (i, j) in asobject(I) if v == 4}
    return paint(paint(canvas(0, shape(I)), threes), fours)
 
0.15091800592728236, 7.6998334, def bjcddeihjcbceifbihfacdcbecfebdge(I):
  objs = objects(I, True, True, True) # Extract objects
  h, w = shape(I)                   # Get grid dimensions
  center_col = w // 2                # Calculate center column

  def reposition(obj):
    if color(obj) == 3:
      return shift(obj, (-center_col + leftmost(obj), -uppermost(obj) + h // 2 - 1))
    elif color(obj) == 4:
      return shift(obj, (-center_col + leftmost(obj), -uppermost(obj) + h // 2 + 1))
    else:
      return obj 

  centered_objs = apply(reposition, objs) # Reposition objects
  O = paint(canvas(0, (h, w)), merge(centered_objs)) # Paint repositioned objects
  return O
 
0.11715059420068698, 11.46584, def fidgjeaiccdbedcfbcfcdfjbgajhfeff(I):
    h, w = shape(I)
    mid_col = w // 2
    mid_row = h // 2

    def transform_cell(v, loc):
        i, j = loc
        if v == 3:
            return (v, (mid_row - 1, mid_col)) 
        elif v == 4:
            return (v, (mid_row + 1, mid_col))
        else:
            return (v, (i, j))

    new_obj = frozenset(transform_cell(v, (i, j)) for i, row in enumerate(I) for j, v in enumerate(row))
    return paint(canvas(0, (h, w)), new_obj)
 
0.14393387894315537, 3.8714736, def aebdbcdcceeaeegdjgbiejdfcaeacbej(I):
  h, w = shape(I)
  output = canvas(0, (h, w))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 3:
        output = paint(output, {(3, (i-1, j))}) # '3' up
      elif v == 4:
        shift_j = w - 1 if any(v == 3 and x < j for x, row in enumerate(I) for v in row) else j # '4' right if '3' is to its left
        output = paint(output, {(4, (h-1, shift_j))}) # '4' to bottom row
  return output
 
0.14393387894315537, 3.4508317, def hfadadcfbiabefaibeabbhjccbbgabje(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    if color(obj) == 3:
      O = paint(O, shift(obj, (h // 2 - uppermost(obj) - height(obj) // 2, 0))) 
    elif color(obj) == 4:
      O = paint(O, shift(obj, (h - height(obj) - uppermost(obj), 0)))
  return O
 
0.18837832338759983, 3.3333728, def aeaeiiajdbdfefbhifebecahhabbcbfd(I):
  h, w = shape(I)
  three = ofcolor(I, 3)
  four = ofcolor(I, 4)
  target_row_three = h // 2 - 1 if len(four) > 0 else h // 2
  new_three = shift(three, (target_row_three - uppermost(three), w // 2 - leftmost(three)))
  new_four = shift(four, (h - 1 - uppermost(four), w // 2 - leftmost(four))) if len(four) > 0 else four
  O = fill(fill(canvas(0, (h, w)), 3, new_three), 4, new_four)
  return O
 
0.1257803318100164, 5.9412117, def bjieicjbbgacecdjiejcbffhbehgddfg(I):
  h, w = shape(I)
  center_col = w // 2
  O = canvas(0, (h, w))
  for color, target_row in ((3, h // 2 - (index(I, (h - 1, center_col)) == 4)), (4, h - 1)):
    for i, row in enumerate(I):
      if color in row:
        j = row.index(color)
        O = paint(O, {(color, (target_row, center_col + k - j)) for k in range(len(ofcolor(I, color)))})
        break
  return O
 
0.15091800592728236, 7.853907, def deddcfffdacceidabbgfaecafgbjijbb(I):
    h, w = shape(I)
    mid_col = w // 2
    mid_row = h // 2

    three = toobject(ofcolor(I, 3), I)
    four = toobject(ofcolor(I, 4), I)

    O = canvas(0, (h, w))
    if three:
        O = paint(O, shift(three, (-leftmost(three) + mid_col, -uppermost(three) + mid_row - 1)))
    if four:
        O = paint(O, shift(four, (-leftmost(four) + mid_col, -uppermost(four) + mid_row + 1)))
    
    return O
 
0.18837832338759983, 3.148227, def bicddbagbdieegahafafifbhibhfgcbg(I):
  h, w = shape(I)
  mid_col = w // 2
  O = canvas(0, (h, w))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 3:
        O = paint(O, {(3, (h // 2 - 1, mid_col))}) 
      elif v == 4:
        O = paint(O, {(4, (h // 2 + 1, mid_col))})
  return O
 
0.14456879957807603, 4.5950537, def bfcijaceffeheihaagfhjadefaacehbd(I):
  h, w = shape(I) 
  obj3 = toobject(ofcolor(I, 3), I)
  obj4 = toobject(ofcolor(I, 4), I)
  mid = h // 2
  return paint(
    paint(canvas(0, (h, w)), {(3, (mid, j)) for _, (i, j) in obj3}), # Move '3' directly to middle row
    {(4, (h-1, j + (rightmost(obj4) > rightmost(obj3)))) for _, (i, j) in obj4} # Move '4' directly to bottom row with conditional right shift
  )
 
0.15752636355604815, 5.448191, def aicecfebjabeebeejeefgbfbachiggef(I):
  h, w = shape(I)
  mid_row = h // 2
  return tuple(
    tuple(
      4 if i == h - 1 and v == 4 else # Place '4' in the bottom row
      3 if i == mid_row and v == 3 else # Place '3' in the middle row
      0 for v in row # Fill the rest with 0s
    ) for i, row in enumerate(I) # Iterate through rows and cells
  ) 
 
0.13511451648742928, 4.044358, def fafeeddbfhbaegfijagjfjbbgdejfeaj(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  target_three = (height(I) // 2, width(I) // 2)
  target_four = (target_three[0] + 1, target_three[1])
  O = fill(fill(canvas(0, shape(I)), 3, {target_three}), 4, {target_four})
  if three_indices:
    O = paint(O, {(3, (i, j)) for i, j in shift(three_indices, subtract(target_three, ulcorner(three_indices)))})
  if four_indices:
    O = paint(O, {(4, (i, j)) for i, j in shift(four_indices, subtract(target_four, ulcorner(four_indices)))})
  return O
 
0.13250530751458395, 3.8294892, def ejebdagjfadbebfeifjbbabccicgahbj(I):
  objs = fgpartition(I)
  target_col = width(I) // 2
  O = canvas(0, shape(I))
  for obj in objs:
    c = color(obj)
    if c == 3:
      O = paint(O, shift(obj, (height(I) // 2 - uppermost(obj), target_col - leftmost(obj))))
    elif c == 4:
      O = paint(O, shift(obj, (height(I) // 2 + 1 - uppermost(obj), target_col - leftmost(obj))))
  return O
 
0.14165334768303228, 4.867501, def cbbahbjfcffiehieibdiaefccbbadaci(I):
  h, w = shape(I)
  obj3 = toindices(toobject(ofcolor(I, 3), I))
  obj4 = toindices(toobject(ofcolor(I, 4), I))
  O = canvas(0, (h, w))
  for i, j in obj3:
    O = paint(O, {(3, (h // 2, j))})
  for i, j in obj4:
    offset = max(0, j - leftmost(obj3))
    O = paint(O, {(4, (h - 1, j + offset))})
  return O
 
0.13810297515306794, 2.918546, def cdfagiadgcfbecdhjfcffjbgebcgdafc(I):
  three_indices = ofcolor(I, 3)
  four_indices = ofcolor(I, 4)
  target_row_three = height(I) // 2
  target_row_four = target_row_three + 1
  O = canvas(0, shape(I))
  for i, j in three_indices:
    O = paint(O, {(3, (target_row_three, j))})
  for i, j in four_indices:
    O = paint(O, {(4, (target_row_four, j))})
  return O
 
