21.5, 27.42246, def ihbabfgfehcfeebgaeefadhaafadbfci(I):
  obj = ofcolor(I, ONE)
  up_left = ulcorner(obj)
  down_right = lrcorner(obj)
  frame =  frozenset((i, j) for i in range(up_left[0] - 1, down_right[0] + 2) for j in range(up_left[1] - 1, down_right[1] + 2))
  O = underfill(I, THREE, frame)
  return O 
 
10.5, 17.447838, def eajeddcabdaceedbbaefciefdchaeaeb(I):
  obj = ofcolor(I, ONE)
  box_indices = box(obj)
  expanded_box = box(shift(box_indices, (-1, -1)))
  frame = expanded_box - box_indices
  O = underfill(I, THREE, frame)
  return O
 
8.5, 24.661161, def ageceicciedeebbhjfiddjdfgfaabfdd(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    filled = I
    for obj in objs:
        shifted_obj = shift(obj, (1, 1))
        shifted_obj = shift(shifted_obj, (1, 0))
        shifted_obj = shift(shifted_obj, (0, 1))
        filled = underpaint(filled, shifted_obj)
    O = fill(filled, THREE, ofcolor(filled, ONE))
    return O
 
19.5, 16.409912, def iabccjcfedchebfgbfcbgdffjdfjbacd(I):
    one_locations = ofcolor(I, ONE)
    frame_locations = set()
    for loc in one_locations:
        frame_locations.update(neighbors(loc)) 
    O = underfill(I, THREE, frozenset(frame_locations))
    return O
 
12.5, 11.723037, def eeebccagcagbeafiidcchecfhihdhefh(I):
  min_color = leastcolor(I)
  objs = objects(I, True, False, True)
  target_indices = merge([toindices(obj) for obj in objs if color(obj) == min_color])
  shifted_indices = merge([shift(target_indices, d) for d in [(-1, 0), (1, 0), (0, -1), (0, 1)]])
  O = fill(I, THREE, shifted_indices)
  return O
 
7.0, 22.17505, def jddibeafiafeebfgbbdeebaegfgfdbhh(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  shadows = mapply(lambda obj: recolor(THREE, backdrop(shift(toindices(obj), (1, 0)))), objs)
  O = paint(I, shadows)
  return O
 
9.0, 13.689078, def cdacbdcfcghdeaejjggcfjfbhhfbhefh(I):
  objs = objects(I, True, False, True)
  shadows = mapply(lambda obj: recolor(THREE, {(i + k, j) for i, j in toindices(obj) for k in range(1, 4)}), objs)
  O = paint(I, shadows)
  return O
 
85.0, 22.935276, def bffacaacabjfeccaabdbjebahjibafhd(I):
  shifted = shift(asobject(I), (1, 0))
  shadow_obj = recolor(THREE,  intersection(toindices(shifted), asindices(I)))
  O = paint(I, shadow_obj)
  return O
 
11.5, 27.187092, def hcibcbecebadegabiggjhicdhdicbaga(I):
  shadow_grid = canvas(ZERO, shape(I))
  for obj in objects(I, True, False, True):
    for i, j in toindices(obj):
      for k in range(1, 4):
        if 0 <= i + k < len(I):
          shadow_grid = fill(shadow_grid, THREE, {(i + k, j)})
  O = cellwise(I, shadow_grid, lambda x,y: x if y==ZERO else y)
  return O
 
7.0, 29.310421, def gdbgbbdaeddfegjdaedffcdfcfdffbbi(I):
  objs = objects(I, T, F, T)
  output = I
  for obj in objs:
    w = width(obj)
    center_row = uppermost(obj) + height(obj) // 2
    leftmost_col = leftmost(obj)
    line = frozenset({(3, (center_row, j)) for j in range(leftmost_col, leftmost_col + w)})
    output = paint(output, line)
  return output
 
5.0, 16.152279, def bjjeeafccdgfeebibgcfcccccegjejib(I):
  objs = fgpartition(I)
  lines = set()
  for obj in objs:
    w = width(obj)
    center_i, center_j = centerofmass(obj)
    start_j = center_j - w // 2
    end_j = start_j + w
    for j in range(start_j, end_j):
      lines.add((center_i, j))
  O = paint(I, recolor(3, frozenset(lines)))
  return O
 
7.0, 29.310421, def bcjfabffcahaedcaibbfcejfiehfcafe(I):
  obj_ones = objects(I, True, False, True)
  filled = underfill(I, THREE, 
                    merge({backdrop(obj) for obj in obj_ones}))
  O = replace(filled, ONE, THREE)
  return O 
 
7.0, 37.382675, def adeagbbceeaceebcabeeebjfegfhfcgc(I):
  h, w = len(I), len(I[0])
  filled_grid = canvas(THREE, (h,w))
  O = cellwise(I, filled_grid, ZERO)
  return O
 
10.5, 17.134197, def aiifhcbfaehgecbjjciaiacdajfgcbdi(I):
  ones = ofcolor(I, ONE) 
  shifted_down_1 = shift(ones, DOWN)
  shifted_down_2 = shift(ones, (TWO, ZERO)) 
  shadow = combine(ones, combine(shifted_down_1, shifted_down_2))
  O = fill(I, THREE, shadow)
  return O
 
8.5, 16.57736, def fdghcghfccgceddaibjjfgiffaedcbaj(I):
  ones = ofcolor(I, ONE)
  shadow = frozenset()
  for i, j in ones:
    shadow = shadow | {(i + 1, j), (i + 2, j)} 
  O = fill(I, THREE, shadow)
  return O
 
6.5, 17.676542, def cagfbfejfjgbeebgifcfddeabieaecje(I):
  def line_indices(obj):
    i, _ = centerofmass(obj)
    w = width(obj)
    j, _ = ulcorner(obj)
    return frozenset((i, j + k) for k in range(w))

  O = paint(I, recolor(3, merge(apply(line_indices, fgpartition(I)))))
  return O
 
9.0, 13.583546, def badefhcegjedeeeiabdaeafbhbbbiddd(I):
  obj = toobject(ofcolor(I, ONE), I)
  if portrait(obj):
    newline = hfrontier(centerofmass(obj))
  else:
    newline = vfrontier(centerofmass(obj))
  O = underfill(I, THREE, newline)
  return O
 
12.0, 16.422096, def adeajddihbfiedabafcgidjbcceibcbj(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  line = extract(objs, lambda obj: vline(obj) or hline(obj))
  center_i, center_j = centerofmass(line)
  if vline(line):
    newline = {(THREE, (i, center_j)) for i in range(len(I))}
  else:
    newline = {(THREE, (center_i, j)) for j in range(len(I[0]))}
  O = paint(I, newline)
  return O
 
10.5, 12.622383, def aeegfcgcgbaeeggfibfeeedhehabbfcj(I):
    objs = objects(I, True, False, True)
    obj = extract(objs, lambda o: color(o) == ONE)
    center_point = center(obj)
    newline = hfrontier(center_point) if vline(obj) else vfrontier(center_point)
    O = underfill(I, THREE, newline)
    return O
 
10.5, 17.797241, def cddefhfejeegefehbdeccfcebhafggcd(I):
    targets = ofcolor(I, ONE)
    shifted_up = shift(targets, UP)
    shifted_down = shift(targets, DOWN)
    all_threes = merge({targets, shifted_up, shifted_down})
    O = fill(I, THREE, all_threes)
    return O
 
11.5, 19.51035, def bhbgjbicgcbfeaeajaffcbbaiddhjaii(I):
  O = canvas(ZERO, shape(I)) # Create a blank canvas of same size as input, filled with '0's
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        for k in range(1, 4):
          if j + k < len(row):  # Boundary check
            O = fill(O, THREE, {(i + 1, j + k)}) # Fill with '3's horizontally
  return O
 
9.5, 14.332185, def fcabjcebcdefefffjdeecbajagedhech(I):
    ones = ofcolor(I, ONE)
    shadow_indices = set()
    for one in ones:
        for k in range(1, 4):
            shadow_indices.add((one[0]+1, one[1]+k))  # Add indices for 'shadow'
    O = I 
    for i, row in enumerate(O):
        for j, _ in enumerate(row):
            if (i, j) in shadow_indices:
                O = fill(O, THREE, {(i, j)})  # Fill '3' at 'shadow' indices
    return O
 
7.5, 15.805136, def cejdeegfffcdececifdgfbhhdhfjjbbe(I):
  def draw_shadow(row, i):
    new_row = list(row)
    for j in range(len(row)-3):
      if row[j] == ONE:
        new_row[j+1:j+4] = [THREE]*3
    return tuple(new_row)

  O = tuple(draw_shadow(row, i) if i < len(I) - 1 else row for i, row in enumerate(I))
  return O
 
4.0, 23.937925, def dejffeigeaadeiigidaaegiaceaejiaa(I):
  obj = merge(fgpartition(I))  # Get all foreground cells as a single object
  if portrait(obj):
    line = connect((centerofmass(obj)[0], leftmost(obj)), (centerofmass(obj)[0], rightmost(obj)))  # Horizontal line
  else:
    line = connect((uppermost(obj), centerofmass(obj)[1]), (lowermost(obj), centerofmass(obj)[1]))  # Vertical line
  O = paint(I, recolor(3, line))  # Paint the line onto the input grid with color 3
  return O
 
8.0, 13.315206, def gdabfeeehaedeaiajaehadfcacgbdidf(I):
  obj = toobject(ofcolor(I, ONE), I)
  center_i, center_j = centerofmass(obj)
  newline = {(THREE, (i, center_j)) for i in range(len(I))} if vline(obj) else \
             {(THREE, (center_i, j)) for j in range(len(I[0]))} 
  O = underpaint(I, newline)
  return O
 
10.0, 12.714475, def cdhefdhaafececjbjiebdddjajecccec(I):
  obj = toobject(ofcolor(I, ONE), I)
  h = len(I)
  w = len(I[0])
  center_i, center_j = centerofmass(obj)
  newline = frozenset({(THREE, (i, center_j)) for i in range(h)}) if vline(obj) else \
             frozenset({(THREE, (center_i, j)) for j in range(w)})
  O = paint(cover(I, obj), newline)
  return O
 
9.5, 12.289214, def dgaddddfeffjeffiifaidacedccebebf(I):
  shadow = frozenset()  # Initialize an empty set for the shadow
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:  # Check for '1'
        for k in range(1, 4): # Generate diagonal shadow
          if i+k < len(I) and j+k < len(I[0]):
            shadow = shadow | {(i+k, j+k)}  
  O = fill(I, THREE, shadow) # Fill shadow indices with '3's
  return O
 
8.0, 17.949568, def ecfbgcebcgbcecaabcadehcdffcbfafh(I):
  O = I  # Copy the input grid
  for i in range(len(I)-1, 0, -1): # Iterate rows in reverse
    for j in range(len(I[0])-1, 0, -1): # Iterate columns in reverse
      if I[i][j] == ONE:
        for k in range(1,4): # Generate diagonal shadow
          if i+k < len(I) and j+k < len(I[0]):
            O = fill(O, THREE, {(i+k,j+k)}) # Fill shadow during iteration
  return O 
 
8.5, 21.597286, def dicbcheffejbeijajdhedbdbedffaeed(I):
  objs = fgpartition(I)
  def draw_T(obj):
    c = color(obj)
    h = height(obj)
    w = width(obj)
    center_j = leftmost(obj) + w // 2
    start = (uppermost(obj), center_j - h // 2)
    end = (uppermost(obj), center_j + h // 2)
    line = connect(start, end)
    return recolor(3, line)
  T_lines = mapply(draw_T, objs)
  O = paint(I, T_lines)
  return O
 
8.0, 19.22057, def cjaaeijdhffeefbciifggdficchdacac(I):
  def draw_line(obj, offset):
    return {(uppermost(obj), leftmost(obj) + width(obj) // 2 + offset)}
  T_lines = set()
  for obj in fgpartition(I):
    for offset in range(-height(obj) // 2, height(obj) // 2 + 1):
      T_lines |= draw_line(obj, offset)
  return paint(I, recolor(3, T_lines))
 
10.5, 15.870757, def eahhbfedjacdededabdabjdihcgafehi(I):
  objs = objects(I, False, False, True)
  obj = first(objs)
  center_point = center(toindices(obj))
  newline = hfrontier(center_point) if portrait(obj) else vfrontier(center_point)
  O = underfill(I, THREE, newline)
  return O
 
5.0, 9.135046, def gebfccbbdeajefhbabiejafccdiifdfi(I):
    one_cells = ofcolor(I, ONE)
    if not one_cells:
        return I
    
    first_row, first_col = next(iter(one_cells))
    is_horizontal = all(row == first_row for row, col in one_cells)
    
    if is_horizontal:
        start_col = min(col for row, col in one_cells)
        end_col = max(col for row, col in one_cells)
        newline = {(THREE, (first_row, col)) for col in range(start_col, end_col + 1)}
    else:
        start_row = min(row for row, col in one_cells)
        end_row = max(row for row, col in one_cells)
        newline = {(THREE, (row, first_col)) for row in range(start_row, end_row + 1)}

    return underfill(I, THREE, newline)
 
7.0, 10.973768, def afifcbaeajdjedheahbcceafcajeecbg(I):
    one_indices = ofcolor(I, 1)
    min_i, min_j = ulcorner(one_indices)
    max_i, max_j = lrcorner(one_indices)
    center_i, center_j = (min_i + max_i) // 2, (min_j + max_j) // 2
    if max_i - min_i > max_j - min_j: # Vertical line
        newline =  {(3, (i, center_j)) for i in range(len(I))}
    else: # Horizontal line
        newline =  {(3, (center_i, j)) for j in range(len(I[0]))}
    return underfill(I, THREE, newline) 
 
19.5, 22.038286, def fjhbhfgeehabeigdbaejdcfbjefjfedh(I):
  ones = ofcolor(I, ONE)  # Get indices of all '1's
  shadow_indices = set()
  for loc in ones:
    for i in range(1, 4):
      for j in range(i-2, i + 1):
        if 0 <= loc[0] + i < len(I) and 0 <= loc[1] + j < len(I[0]):
          shadow_indices.add((loc[0] + i, loc[1] + j))
  O = fill(I, THREE, frozenset(shadow_indices))  # Fill the shadow indices with '3's
  return O
 
15.0, 14.17529, def eafajecjheihejejaaabdfcgabfdfgac(I):
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if vline(obj) or hline(obj):
      ci, cj = center(obj)
      newline = hfrontier((ci,cj)) if vline(obj) else vfrontier((ci,cj))
      I = underfill(I, THREE, newline)
  return I
 
5.0, 29.678263, def eiffhfgbccaceageicdeefdafaeffcib(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        horizontal_line = {(ONE, (i, c)) for c in range(len(I[0]))}
        vertical_line = {(ONE, (r, j)) for r in range(len(I))}
        if set(horizontal_line).issubset(asobject(I)):
          I = underfill(I, THREE, vfrontier((i,j)))
        if set(vertical_line).issubset(asobject(I)):
          I = underfill(I, THREE, hfrontier((i,j)))
  return I
 
11.0, 17.253906, def gbbhfcdbbidceccajifbbjgegdfghihf(I):
  ones = ofcolor(I, ONE) # Get indices of all '1' cells
  make_line = lambda loc: frozenset((THREE, (loc[0], j)) for j in range(loc[1] - 1, loc[1] + 2))  # Draw 3-cell horizontal line
  three_indices = frozenset().union(*[make_line(loc) for loc in ones]) # Apply line drawing to each index and merge
  O = fill(I, THREE, three_indices) # Fill the grid with '3's at the specified indices
  return O
 
12.5, 11.723037, def hhaeeciibfjfebbfbceidahfdfffhchh(I):
  # Find "1" locations
  ones = ofcolor(I, ONE)
  
  # Create cross indices directly
  cross_indices = frozenset((i + di, j + dj) for i, j in ones for di in range(-1, 2) for dj in range(-1, 2) if abs(di) != abs(dj))

  # Recolor cross indices to "3"
  cross_obj = recolor(THREE, cross_indices)

  # Paint crosses onto the original grid
  O = paint(I, cross_obj)
  return O
 
14.5, 11.191943, def acfagfhajgjaecacjffdfgijbgaeafdb(I):
  # Get locations of "1" digits
  ones = ofcolor(I, ONE)

  # Generate cross indices using dneighbors
  cross_indices = merge(apply(dneighbors, ones)) | ones

  # Recolor cross indices to "3" and paint
  O = paint(I, recolor(THREE, cross_indices))
  return O
 
16.0, 26.413147, def cfbhfcigiieceajaaidjaebejdajddfa(I):
  one = first(ofcolor(I, ONE))  # Get the index of any '1'
  hLine = {(THREE, (one[0], j)) for j in range(len(I[0]))}
  vLine = {(THREE, (i, one[1])) for i in range(len(I))}
  hCount = colorcount(I, ONE)
  return underfill(underfill(I, THREE, hLine), THREE, vLine) if hCount > len(I[0]) else \
         underfill(underfill(I, THREE, vLine), THREE, hLine) 
 
9.5, 11.982318, def faeadagjbfcheejdbgcbeeaddeebgbad(I):
  threes = set() # Initialize an empty set to store indices for '3's
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE: # If a cell contains '1'
        threes.update({(i-1, j-1), (i-1, j), (i-1, j+1)}) # Add the indices for the line above it to the set
  O = fill(I, THREE, frozenset(threes)) # Fill the grid with '3's at the calculated indices
  return O 
 
8.5, 15.303118, def adaeafdfdecieebaicehjbdcagddfgaf(I):
  O = I # Initialize output as input
  for i, j in ofcolor(I, ONE): # Iterate over locations of '1's
    for k in range(1, 3): # Iterate for diagonal line length
      if 0 <= i+k < len(I) and 0 <= j+k < len(I[0]): # Check boundary conditions
        O = paint(O, {(THREE, (i+k, j+k))}) # Paint '3's diagonally
  return O
 
6.0, 29.455433, def aadjghahdgfeejbfafhhehcejajaaeee(I):
  def draw_hline(obj, grid):
    row = uppermost(obj) + height(obj) // 2
    return fill(grid, 3, {(row, j) for j in range(leftmost(obj), rightmost(obj) + 1)})
  
  objs = sfilter(objects(I, T, F, T), lambda obj: color(obj) != mostcolor(I))
  return last(tuple(draw_hline(obj, I) for obj in objs))
 
2.0, 15.065073, def edgdgjchfgebeebcjaffehbfhcfafeei(I):
  ones = ofcolor(I, ONE)
  center_loc = centerofmass(ones)
  if height(ones) > width(ones):
    newline = {(THREE, (i, center_loc[1])) for i in range(center_loc[0]-1, center_loc[0]+2)}
  else:
    newline = {(THREE, (center_loc[0], j)) for j in range(center_loc[1]-1, center_loc[1]+2)}
  O = underfill(I, THREE, newline)
  return O
 
7.0, 19.505493, def gdjbjabdbfdhebaejbddaddachdefdgf(I):
  objs = objects(I, univalued = True, diagonal = False, without_bg = True)
  obj = first(objs)
  center_i, center_j = center(obj)
  if height(obj) > width(obj):
    newline =  {(THREE, (i, center_j)) for i in range(center_i - 1, center_i + 2)}
  else:
    newline =  {(THREE, (center_i, j)) for j in range(center_j - 1, center_j + 2)}
  O = underfill(I, THREE, newline)
  return O
 
6.5, 20.758425, def edbfafcffebbeefjibfcffaadfeebejc(I):
  objs = objects(I, True, False, True) # Identify objects, excluding background
  shifted_objs = apply(lambda obj: shift(obj, (-1, 0)), objs) # Shift each object up by one unit
  threes = mfilter(shifted_objs, lambda obj: color(obj) == ONE) # Filter for shifted objects that were originally '1's
  O = paint(I, recolor(THREE, toindices(threes))) # Paint the filtered objects onto the original grid with color '3'
  return O
 
8.5, 21.35053, def gdegegfhjfgjecejijdgjcjdachfgdej(I):
  O = I  # Initialize output grid as a copy of the input
  for i, row in enumerate(I):
    if ONE in row: # Check if the row contains a '1'
      if i > 0: # Avoid index out of bounds
        O = tuple(tuple(THREE if j in range(len(row)) and I[i][j] == ONE else O[i-1][j] for j in range(len(row))) if i > 0 else row for i, row in enumerate(O)) # Replace the row above with '3's where the current row has '1's
  return O
 
7.5, 15.116249, def ceeiabbiicebeggjifgebdfchcdgdhde(I):
  h, w = len(I), len(I[0]) # Get grid dimensions
  O = tuple( # Generate the output grid
    tuple(
      3 if any((i-k, j-k) in zip(*ofcolor(I, 1)) and 0 <= i-k < h and 0 <= j-k < w for k in range(1, 3)) else I[i][j]
      for j in range(w)
    )
    for i in range(h)
  )
  return O
 
7.0, 34.548485, def bgjffbdefedaefdgidcehafccdgaegdc(I):
  # Create a grid with all "3s" where the original grid has "1s"
  crosses = cellwise(I, replace(I, ONE, THREE), ZERO)

  # Combine the original grid with the "crosses" grid using cellwise comparison
  O = cellwise(I, crosses, lambda a, b: THREE if b == THREE else a)

  return O
 
2.0, 15.462343, def agjdgeeadbbheifhaibdcddecbaagbhc(I):
    ones = ofcolor(I, ONE)
    center_i = uppermost(ones) + height(ones) // 2
    center_j = leftmost(ones) + width(ones) // 2
    if portrait(ones):
        I = fill(I, THREE, {(center_i, center_j - 1), (center_i, center_j), (center_i, center_j + 1)})
    else:
        I = fill(I, THREE, {(center_i - 1, center_j), (center_i, center_j), (center_i + 1, center_j)})
    return I
 
6.0, 14.793282, def cjciabebegdeedfabacgfcadfciacbja(I):
    ones = ofcolor(I, ONE)
    center_i = uppermost(ones) + height(ones) // 2
    center_j = leftmost(ones) + width(ones) // 2
    line = canvas(THREE, (3, 1)) if portrait(ones) else canvas(THREE, (1, 3))
    offset = (-1, -1) if portrait(ones) else (-1, 0) 
    I = underpaint(I, shift(asobject(line), (center_i + offset[0], center_j + offset[1])))
    return I
 
10.5, 16.416367, def cibeedacghfgefffjcjbdhfjhfjccebj(I):
    ones = ofcolor(I, ONE)
    for i, j in ones:
        if portrait(ones):
            for di in range(-1, 2):
                if 0 <= i + di < len(I):
                    I = fill(I, THREE, {(i + di, j)})
        else:
            for dj in range(-1, 2):
                if 0 <= j + dj < len(I[0]):
                    I = fill(I, THREE, {(i, j + dj)})
    return I
 
7.0, 22.17505, def fiahhfeeccbdehafigbegbdafjhhbaif(I):
  # Create a function to process each row
  process_row = lambda row_index: tuple(THREE if I[row_index - 1][col_index] == ONE and I[row_index][col_index] == ZERO else I[row_index][col_index] for col_index in range(len(I[0])))
  # Apply the function to each row except the first one
  O = tuple(process_row(row_index) for row_index in range(1, len(I)))
  # Add the first row back
  O = (I[0],) + O 
  return O
 
7.0, 37.382675, def bdfgdadihddbechhbecjaadcaadfbdhf(I):
  # Create an empty grid filled with zeroes
  O = canvas(ZERO, shape(I))
  # Iterate through the input grid and fill the output grid
  for i in range(len(I) - 1):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        O = fill(O, THREE, {(i + 1, j)})
      else:
        O = fill(O, I[i][j], {(i, j)})
  # Fill the last row of the output grid
  for j in range(len(I[0])):
    O = fill(O, I[-1][j], {(len(I) - 1, j)})
  return O
 
10.5, 15.778875, def eahdfibebfheebfdjgjbjfcdjcdbcfgg(I):
  O = I
  for i, j in ofcolor(I, 1):
    for di in range(3):
      if 0 <= i + di < len(I) and 0 <= j + di < len(I[0]):
        O = paint(O, {(3, (i + di, j + di))})
  return O
 
17.0, 14.982641, def fgcaaifibdgjeaddjecaiffcdcfafddc(I):
  lines = set()
  for obj in objects(I, T, F, T):
    i, _ = centerofmass(obj)
    lines |= {recolor(3, {(i, j) for j in range(width(I))})}
  return paint(I, merge(lines))
 
17.0, 18.584251, def hhgbddbhdbccegijabcfhhfafeajhaca(I):
  # Find "1" locations
  ones = ofcolor(I, ONE)

  # Use vfrontier to directly generate vertical lines 
  crosses = mapply(lambda loc: toindices(recolor(THREE, vfrontier(loc))), ones)

  # Recolor and paint as before
  O = paint(I, recolor(THREE, crosses))
  return O
 
6.5, 10.28114, def bababfdacfcaeddcbefbgfhbbejagaba(I):
  one_indices = ofcolor(I, ONE)
  if not one_indices:
    return I
  first_i, first_j = first(one_indices)
  is_horizontal = all(i == first_i for i, j in one_indices)

  line_start = minimum(j for i, j in one_indices) if is_horizontal else minimum(i for i, j in one_indices)
  line_end = maximum(j for i, j in one_indices) if is_horizontal else maximum(i for i, j in one_indices)
  line_length = line_end - line_start + 3

  if is_horizontal:
    start_j = line_start - 1
    newline = {(THREE, (first_i, start_j + j)) for j in range(line_length)}
  else:
    start_i = line_start - 1
    newline = {(THREE, (start_i + i, first_j)) for i in range(line_length)}

  return underfill(I, THREE, newline)
 
5.0, 8.985351, def bjabicbdebccecjejadahaddabcffibb(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  is_horizontal = hline(ones)
  line_center = centerofmass(ones)
  half_length = (width(ones) + 1) // 2

  if is_horizontal:
    newline = {(THREE, (line_center[0], line_center[1] - half_length + j)) for j in range(2 * half_length + 1)}
  else:
    newline = {(THREE, (line_center[0] - half_length + i, line_center[1])) for i in range(2 * half_length + 1)}

  return underfill(I, THREE, newline) 
 
7.0, 19.505493, def abbcegccfdedeaccifgfabagjedddefc(I):
  obj1 = objects(I, True, False, False)
  obj1 = extract(obj1, lambda obj: color(obj) == ONE)
  if not obj1:
    return I
  is_horizontal = hline(obj1)
  line_start = leftmost(obj1) if is_horizontal else uppermost(obj1)
  line_length = width(obj1) if is_horizontal else height(obj1)
  line_center = centerofmass(obj1)

  if is_horizontal:
    newline = {(THREE, (line_center[0], line_start - 1 + j)) for j in range(line_length + 2)}
  else:
    newline = {(THREE, (line_start - 1 + i, line_center[1])) for i in range(line_length + 2)}
  
  return underfill(I, THREE, newline)
 
6.0, 9.876, def dhdffgcaeicaeegcbdgecaicjeefaccc(I):
  one_cells = ofcolor(I, ONE)
  if not one_cells:
    return I

  first_loc = first(one_cells)
  direction = (0, 1) if all(i == first_loc[0] for i, j in one_cells) else (1, 0) 

  line_start = subtract(first_loc, direction)
  line_end = add(last(one_cells), direction) 
  newline = connect(line_start, line_end)

  return underfill(I, THREE, newline)
 
7.0, 29.310421, def dddbefdcacaaeaabidceediagjaccdcj(I):
  for obj in objects(I, T, F, T):
    I = fill(I, THREE, connect((center(obj)[0], leftmost(obj)), (center(obj)[0], rightmost(obj))))
    I = fill(I, THREE, connect((uppermost(obj), center(obj)[1]), (lowermost(obj), center(obj)[1])))
  return I
 
12.5, 11.723037, def gcbacbfjhafbebiaaegabefghbdcigcf(I):
  # Identify '1' cells
  ones = ofcolor(I, ONE) 
  # Shift the '1' cells up, down, left, right and combine indices
  shifted_cells = merge([shift(ones, direction) for direction in [UP, DOWN, LEFT, RIGHT]])
  # Fill the shifted indices with '3' on the original grid
  O = fill(I, THREE, shifted_cells) 
  return O
 
8.0, 12.993368, def bbaciedccjdcefcejgcjabbjbhbgdeii(I):
    O = I
    for obj in fgpartition(I):
        box_indices = backdrop(obj)
        shifted_box = shift(box_indices, (-1, 0))
        O = underfill(O, 3, shifted_box)
    return O
 
85.0, 22.74682, def cebhgfeeficbeedhjcegfbaaicgjdbbf(I):
    O = I
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value != mostcommon(I):
                O = fill(O, 3, {(i-1, j)})
    return O
 
8.5, 13.090988, def jdbjeefdfbceeiegbbhjdafhdecebbaa(I):
    return paint(I, merge(apply(lambda obj: recolor(3, shift(backdrop(obj), (-1, 0))), fgpartition(I))))
 
3.0, 20.000347, def ejaffdajcgjfeejejfcccjjgcfjbdefc(I):
  objs = fgpartition(I)
  transformed_objs = mapply(lambda obj: recolor(3, connect(centerofmass(obj), add(centerofmass(obj), (0, 1)))), objs)
  O = paint(I, transformed_objs)
  return O
 
2.0, 15.2593355, def bacfhdaeadjjeabjjiaghcajfdjcigfi(I):
  O = I
  for obj in fgpartition(I):
    center = centerofmass(obj)
    O = paint(O, recolor(3, {(center[0], center[1]-1), (center[0], center[1]), (center[0], center[1]+1)}))
  return O
 
10.5, 11.561318, def ceghbehfbcfcechgjbabjiadfaahcebj(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  direction = position(ones, shift(ones, (1, 1)))
  start = subtract(centerofmass(ones), multiply(halve(shape(ones)), direction))
  newline = shoot(start, direction)
  return underfill(I, THREE, newline)
 
5.0, 29.678263, def jdaaiehehcjcehdcbfbbedghhbadhcec(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  line = box(ones) if hline(ones) or vline(ones) else ones
  newline = recolor(THREE, line)
  return underfill(I, THREE, newline)
 
5.0, 14.049725, def gdccfidbbedheaeajedjbaiahaafbgbd(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  is_horizontal = hline(ones)
  center_i, center_j = centerofmass(ones)
  length = width(ones) if is_horizontal else height(ones)
  half_length = length // 2

  if is_horizontal:
    newline = {(THREE, (center_i, j)) for j in range(center_j - half_length, center_j + half_length + (length % 2))}
  else:
    newline = {(THREE, (i, center_j)) for i in range(center_i - half_length, center_i + half_length + (length % 2))}

  return underfill(I, THREE, newline)
 
14.5, 11.252631, def dcabhafaieeiedbeaadjfhbjdcbbcbba(I):
  # Create a new grid with the same dimensions as the input
  O = canvas(ZERO, shape(I))
  # Iterate through each cell of the input grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell value is '1'
      if I[i][j] == ONE:
        # Fill the surrounding plus shape in the output grid with '3'
        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
          # Check if the current index is within the grid boundaries
          if 0 <= i + di < height(I) and 0 <= j + dj < width(I):
            O = fill(O, THREE, {(i + di, j + dj)})
  return O
 
6.5, 20.758425, def cafdefaheacbehfhbfheccifaddjgdec(I):
  objs = objects(I, T, F, T)
  shifted_objs = mapply(lambda obj: shift(recolor(3, toindices(obj)), (-1, 0)), objs)
  O = paint(I, shifted_objs)
  return O
 
8.5, 29.04952, def efaffefahfbfeaaebbeddecjhfccbgad(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, shift(recolor(3, toindices(obj)), (-1, 0)))
  return O
 
7.0, 37.382675, def afgbbedcbfbgejdabdedcdfdgfeaiagg(I):
  shifted_grid = canvas(0, shape(I))
  for i in range(1, len(I)):
    for j in range(len(I[0])):
      if I[i][j] != 0:
        shifted_grid = paint(shifted_grid, {(3, (i-1, j))})
  O = cellwise(I, shifted_grid, 0)
  return O
 
6.5, 10.568811, def cefafbddhgibebediieafbeghdfhiacf(I):
  objs = fgpartition(I)
  h_lines = mapply(lambda obj: recolor(3, connect(add(centerofmass(obj), (0, -width(obj)//2)), add(centerofmass(obj), (0, width(obj)//2)))), objs)
  v_lines = mapply(lambda obj: recolor(3, connect(add(centerofmass(obj), (-height(obj)//2, 0)), add(centerofmass(obj), (height(obj)//2, 0)))), objs)
  O = paint(paint(I, h_lines), v_lines)
  return O
 
7.0, 10.511408, def caajccdeecfdeaaaafadcifecbaadifb(I):
    objs = fgpartition(I)
    def draw_lines(obj):
        center_i, center_j = centerofmass(obj)
        h_line = frozenset({(3, (center_i, j)) for j in range(leftmost(obj), rightmost(obj) + 1)})
        v_line = frozenset({(3, (i, center_j)) for i in range(uppermost(obj), lowermost(obj) + 1)})
        return combine(h_line, v_line)
    lines = mapply(draw_lines, objs)
    O = paint(I, lines)
    return O
 
7.0, 29.310421, def dahiijffdihcefadabafhfcbebbjijfd(I):
    objs = fgpartition(I)
    def modify_obj(obj):
        center_i, center_j = centerofmass(obj)
        return frozenset({(3 if i == center_i or j == center_j else v, (i, j)) for v, (i, j) in obj})
    modified_objs = mapply(modify_obj, objs)
    O = paint(I, modified_objs)
    return O
 
5.0, 10.125662, def ghjdcieeidefeahfbbfbdjbcjedagfaa(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  is_horizontal = hline(ones)
  line_center = centerofmass(ones)
  half_length = (width(ones) // 2) + 1

  if is_horizontal:
    newline = {(THREE, (line_center[0], j)) for j in range(line_center[1] - half_length, line_center[1] + half_length)}
  else:
    newline = {(THREE, (i, line_center[1])) for i in range(line_center[0] - half_length, line_center[0] + half_length)}

  return underfill(I, THREE, newline)
 
21.5, 16.452295, def fahabdefafebebibibahhcagfcfaifaf(I):
  objs = objects(I, True, False, False)
  new_objs = set()
  for obj in objs:
    if color(obj) == ONE:
      center_i, center_j = centerofmass(obj)
      h, w = height(obj), width(obj)
      new_h, new_w = h + 2, w + 2
      new_obj = set()
      for i in range(center_i - new_h // 2, center_i + new_h // 2 + new_h % 2):
        for j in range(center_j - new_w // 2, center_j + new_w // 2 + new_w % 2):
          new_obj.add((THREE, (i, j)))
      new_objs.add(frozenset(new_obj))
  return paint(I, merge(new_objs))
 
19.5, 16.409912, def gaifejceddedeghbbcggcgidfaabdedg(I):
  for i, r in enumerate(I):
    for j, v in enumerate(r):
      if v == ONE:
        I = underfill(I, THREE, {(THREE, (i - 1, j - 1)), (THREE, (i - 1, j)), (THREE, (i - 1, j + 1)),
                         (THREE, (i, j - 1)), (THREE, (i, j)), (THREE, (i, j + 1)),
                         (THREE, (i + 1, j - 1)), (THREE, (i + 1, j)), (THREE, (i + 1, j + 1))})
  return I
 
7.0, 12.807032, def idaaciebfeacehdfiggbhfaeajahicdd(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  is_horizontal = hline(ones)
  min_j = leftmost(ones)
  max_j = rightmost(ones)
  min_i = uppermost(ones)
  max_i = lowermost(ones)
  if is_horizontal:
    newline =  {(THREE, (min_i, j)) for j in range(min_j - 1, max_j + 2)}
  else:
    newline =  {(THREE, (i, min_j)) for i in range(min_i - 1, max_i + 2)}
  return underfill(I, THREE, newline)
 
12.5, 12.727204, def eddcibcbcgadejdbbaeidffigfadfecg(I):
  # Create an empty canvas for the output
  O = canvas(ZERO, shape(I))
  # Iterate through each cell of the input grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell value is '1'
      if I[i][j] == ONE:
        # Fill a horizontal line with '3's centered at this location
        O = fill(O, THREE, connect((i, max(0, j-2)), (i, min(j+2, width(I)-1))))
  return O
 
8.5, 19.284334, def hhhfiafejbfaeciebeiecbfheafffaee(I):
  # Find locations of '1's
  ones = ofcolor(I, ONE)
  # Shift '1' locations left and right to generate line segments
  left_shift = shift(ones, (0, -2))
  right_shift = shift(ones, (0, 2))
  # Combine all locations and filter out out-of-bounds indices
  all_indices = ones | left_shift | right_shift
  valid_indices = sfilter(all_indices, lambda loc: 0 <= loc[1] < width(I))
  # Fill the valid indices with '3'
  O = fill(I, THREE, valid_indices)
  return O
 
8.0, 15.019271, def dbiadhbbecebeceeahabfcaegebidaej(I):
  objs = fgpartition(I)
  extension = lambda obj: recolor(3, difference(backdrop(shift(obj,(height(obj),0))), backdrop(obj)))
  return paint(I, merge(apply(extension, objs))) 
 
6.5, 23.920586, def bbadcffbabhgecieiefdbeadffahihfb(I):
  return paint(I, merge(apply(lambda obj: recolor(3, frozenset((i + height(obj), j) for i, j in toindices(obj) if i + height(obj) < height(I))), fgpartition(I))))
 
11.5, 16.440548, def dachbeafedeeecjfjbdjafbfcfafgjee(I):
  extended_objs = set()
  for obj in fgpartition(I):
    for i, j in toindices(obj):
      for k in range(1, height(I) - i):
        extended_objs.add((3, (i + k, j)))
  return paint(I, frozenset(extended_objs))
 
6.5, 10.221309, def bjebgdaaefddeiceiciebfefdchbejec(I):
    return paint(I, merge(apply(lambda o: recolor(3, difference(backdrop(o),intersection(backdrop(o), {(i + 1, j) for i, j in toindices(o) if i + 1 < height(I)}))), fgpartition(I))))
 
6.0, 14.544433, def cbfacccfaidfeabdaheifgadgfcahjbf(I):
  obj = toobject(ofcolor(I, ONE), I)
  if not obj:
    return I
  orientation = hline(obj) if width(obj) > height(obj) else vline(obj)
  center_i, center_j = centerofmass(obj)
  length = width(obj) if orientation else height(obj)

  if orientation:
    line = {(THREE, (center_i, j)) for j in range(center_j - length // 2, center_j + length // 2 + length % 2)}
  else:
    line = {(THREE, (i, center_j)) for i in range(center_i - length // 2, center_i + length // 2 + length % 2)}

  return paint(I, line) 
 
7.0, 10.511408, def daffjbchffbieaebabfdcjfajdbabccj(I):
  obj = normalize(toindices(ofcolor(I, ONE)))
  if not obj:
    return I
  is_horizontal = width(obj) > height(obj)
  center_i, center_j = center(obj)
  line_length = width(obj) if is_horizontal else height(obj)

  if is_horizontal:
    line = {(THREE, (center_i, j)) for j in range(center_j - line_length // 2, center_j + (line_length + 1) // 2)}
  else:
    line = {(THREE, (i, center_j)) for i in range(center_i - line_length // 2, center_i + (line_length + 1) // 2)}

  return paint(I, shift(line, ulcorner(ofcolor(I, ONE))))
 
10.0, 18.831453, def cgabdgfagajbecbeiahbechaeeeajbae(I):
  # Find the locations of '1's
  ones = ofcolor(I, ONE)
  # Generate shifted lines
  left_line = shift(ones, (-2, 0))
  center_line = ones
  right_line = shift(ones, (2, 0))
  # Combine lines and fill with '3'
  all_lines = merge([left_line, center_line, right_line])
  O = fill(I, THREE, all_lines)
  return O
 
29.0, 22.341866, def chdbghjdefageehdbbibbcdibcijfecd(I):
  # Define a function to check for '1' in the neighborhood
  def check_neighborhood(loc):
    i, j = loc
    for x in range(max(0, i-1), min(i+2, len(I))):
      for y in range(max(0, j-2), min(j+3, len(I[0]))):
        if I[x][y] == ONE:
          return True
    return False
  # Create a new grid with '3's where the condition is met
  O = canvas(ZERO, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if check_neighborhood((i,j)):
        O = fill(O, THREE, {(i, j)})
  return O
 
5.0, 29.678263, def aaeaihbihjdeeaacjhegjcgfajbjhcca(I):
  objs = fgpartition(I)
  lines = merge(apply(lambda obj: recolor(3, {(lowermost(obj) + 1, j) for j in range(width(I)) if (lowermost(obj) + 1, j) in backdrop(obj)}), objs))
  return paint(I, lines)
 
3.0, 5.1901903, def djdaeaccacabecgfbeacbjbeagacecid(I):
  objs = fgpartition(I)
  cross = lambda obj: recolor(3, combine(
    connect(add(centerofmass(obj), (0, -width(obj)//2)), add(centerofmass(obj), (0, width(obj)//2))),
    connect(add(centerofmass(obj), (-1, 0)), add(centerofmass(obj), (1, 0)))
  ))
  crosses = mapply(cross, objs)
  O = paint(I, crosses)
  return O
 
44.0, 23.469091, def jeeahdiaabhdebbficacajfdaacbibdh(I):
  ones = ofcolor(I, ONE)
  center_j = centerofmass(ones)[1]
  line = {(THREE, (i, center_j - 2 + j)) for i in range(len(I)) for j in range(5)}
  return underfill(I, THREE, line)
 
68.0, 15.624011, def aaaffcafcfdgejiaibefgfidahcbajgh(I):
  ones = toindices(ofcolor(I, ONE))
  min_j, max_j = min(j for _, j in ones), max(j for _, j in ones)
  line = {(THREE, (i, j)) for i in range(len(I)) for j in range(max(0, min_j - 2), min(len(I[0]), max_j + 3))}
  return underfill(I, THREE, line)
 
10.5, 11.360968, def jggffdajedicefffjdbeiaebgaiagfda(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        I = underfill(I, THREE, {(THREE, (i, k)) for k in range(max(0, j - 2), min(len(I[0]), j + 3))})
  return I
 
4.0, 9.441324, def fbeccijgccgfehbficcaifejeicfbbbi(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  is_horizontal = hline(ones)
  line_center = centerofmass(ones)
  half_length = 2

  if is_horizontal:
    newline = {(THREE, (line_center[0], j)) for j in range(line_center[1] - half_length, line_center[1] + half_length + 1)}
  else:
    newline = {(THREE, (i, line_center[1])) for i in range(line_center[0] - half_length, line_center[0] + half_length + 1)}

  return underfill(I, THREE, newline)
 
8.0, 16.834196, def hjafababdacbedceiabbfcababedjcfc(I):
  # Find '1' cells
  ones = ofcolor(I, ONE)
  # Fill right cells sequentially
  O = I
  for i in range(1, 3):
    O = fill(O, THREE, shift(ones, (0, i)))
  return O
 
909.0, 29.804802, def cadbdfbahaajebdejdabhhhiheghbfbb(I):
  # Fill right cells using list comprehension
  O = tuple(tuple(THREE if (k == j or k == j + 1 or k == j + 2) and I[i][j] == ONE else I[i][k] for k in range(len(I[0]))) for i, row in enumerate(I) for j in range(len(row)))
  return O
 
7.0, 22.17505, def cffaaaajfbedecifadifcbcjbgabefce(I):
    return paint(I, mapply(lambda o: recolor(3, {(i + 1, j) for i, j in toindices(o) if i + 1 < height(I)}), fgpartition(I)))
 
8.0, 20.289068, def fbbhedbcacefebcfiffeacfbccfegadf(I):
  ones = ofcolor(I, ONE)
  center_i, center_j = centerofmass(ones)
  hline = {(THREE, (center_i, j)) for j in range(len(I[0]))}
  vline = {(THREE, (i, center_j)) for i in range(center_i - 2, center_i + 3) if i != center_i}
  return underfill(I, THREE, hline | vline)
 
9.0, 20.332838, def cffdaajhbbcaefcfafaaceebafihdgae(I):
    ones = ofcolor(I, ONE)
    center_i, center_j = centerofmass(ones)
    return paint(paint(I, {(THREE, (center_i, j)) for j in range(len(I[0]))}), 
                 {(THREE, (i, center_j)) for i in range(center_i - 2, center_i + 3) if i != center_i})
 
10.0, 17.439426, def bbbfbiehdaejeiajacacdidegajgbfci(I):
  # Find '1' cell coordinates
  ones = ofcolor(I, ONE) 
  # Create a set of indices to be filled
  fill_indices = set()
  for i, j in ones:
    for k in range(3):
      fill_indices.add((i, j + k))
  # Fill the indices with '3'
  O = fill(I, THREE, frozenset(fill_indices))
  return O
 
9.0, 16.170267, def jbhehjdfadhdeaheaefbgebfdibcegce(I):
  return paint(paint(I, merge(apply(lambda o: recolor(3, {(i + 1, j) for i, j in toindices(o) if i + 1 < height(I)}), fgpartition(I)))), 
               merge(apply(lambda o: recolor(3, {(i + 1, j + 1) for i, j in toindices(o) if i + 1 < height(I) and j + 1 < width(I)}), fgpartition(I))))
 
13.0, 15.433871, def bjgdhecefbdfebhfifhchcagaefjebeb(I):
  def cross_indices(obj):
    c_i, c_j = centerofmass(obj)
    u_i, l_j = uppermost(obj), leftmost(obj)
    return frozenset(
        {(c_i - u_i, j) for j in range(l_j, l_j + width(obj))} |
        {(i, c_j - l_j) for i in range(u_i, u_i + height(obj))})
  O = I
  for obj in fgpartition(I):
    O = paint(O, recolor(color(obj), cross_indices(obj)))
  return O
 
4.0, 15.38908, def dcfdfhedjbgbehddjgfbdjbifidbejae(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  line_center = centerofmass(ones)
  line_width = width(ones)
  start_j = line_center[1] - line_width // 2
  end_j = start_j + line_width
  newline = {(THREE, (line_center[0], j)) for j in range(start_j, end_j)}
  return underfill(I, THREE, newline)
 
4.5, 18.499498, def afffddediedbeaabbdiedbbdccjcedff(I):
  ones = ofcolor(I, ONE)
  if not ones:
    return I
  line = {(THREE, (uppermost(ones), j)) for j in range(leftmost(ones), rightmost(ones) + 1)}
  return underfill(I, THREE, line)
 
7.0, 29.310421, def ibjbhhigafeiefaeafbbcafceihddbbi(I):
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE:
        line_start = j
        line_end = j
        while line_start > 0 and I[i][line_start - 1] == ONE:
          line_start -= 1
        while line_end < len(row) - 1 and I[i][line_end + 1] == ONE:
          line_end += 1
        I = tuple(
          tuple(
            THREE if row_index == i and col_index >= line_start and col_index <= line_end else cell 
            for col_index, cell in enumerate(row)
          ) 
          for row_index, row in enumerate(I)
        )
  return I
 
8.0, 16.791107, def bbgdfbedgfhaeabfbjdgffdhadaeccdg(I):
  def process_row(row, row_index):
    return tuple(
      THREE if any(I[row_index][max(0, j - k):min(len(row), j + k + 1)].count(ONE) > 0 for k in range(width(ofcolor(I, ONE))))
      else cell
      for j, cell in enumerate(row)
    )
  return tuple(process_row(row, i) for i, row in enumerate(I))
 
5.0, 29.678263, def eihfiabfeddjecbebbdeceddcabceidd(I):
  # Identify '1' indices
  ones = ofcolor(I, ONE)
  # Create a shifted grid with '1's moved two cells to the right
  shifted_grid = paint(canvas(ZERO, shape(I)), recolor(ONE, shift(ones, (0, 2))))
  # Find overlapping '1's between original and shifted grid
  overlap = intersection(ones, ofcolor(shifted_grid, ONE))
  # Extend horizontal lines of '3's from overlapping '1's
  lines = mapply(lambda loc: {(loc[0], loc[1] + i) for i in range(3)}, overlap)
  # Fill the lines in the original grid with '3's
  O = fill(I, THREE, merge(lines))
  return O
 
8.0, 14.325972, def eeedcchdhdhiecciijbicehhajecbeha(I):
  return paint(
      I, 
      merge(
          apply(
              lambda o: recolor(
                  3, 
                  product(
                      {uppermost(o) + 1}, 
                      interval(leftmost(o), rightmost(o) + 1, 1)
                  )
              ), 
              fgpartition(I)
          )
      )
  )
 
20.0, 18.917948, def baeddbefefjceceabgdagcfehfdechdc(I):
  def cross_at(loc, value):
    i, j = loc
    h, w = height(I), width(I)
    return recolor(value, frozenset(
        {(i, k) for k in range(w)} |
        {(i - 1, j), (i + 1, j)}))
  crosses = frozenset(cross_at((i, j), I[i][j]) 
                      for i in range(len(I)) for j in range(len(I[0])) 
                      if I[i][j] != mostcolor(I))
  O = paint(I, merge(crosses))
  return O
 
6.0, 7.38881, def begdfcehjbdeejfdjeidffggechbbcid(I):
  O = I
  for obj in fgpartition(I):
    c_i, c_j = centerofmass(obj)
    O = fill(O, color(obj), frozenset(
        {(c_i, j) for j in range(leftmost(obj), rightmost(obj) + 1)}))
    O = fill(O, color(obj), frozenset({(c_i - 1, c_j), (c_i + 1, c_j)}))
  return O
 
7.0, 22.17505, def gdhchfgfagccebgejaadddbgifacjehb(I):
  lines = set()
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE:
        lines.add((i + 1, j))
  return underfill(I, THREE, frozenset(lines))
 
14.0, 14.857437, def jaecceddaaccebfajbabcbeefeaaiiee(I):
  O = canvas(ZERO, shape(I))  # Start with an empty canvas
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE:
        for k in range(max(0, j-2), min(j+3, width(I))):
          O = fill(O, THREE, {(i+2, k)})  # Fill below with boundary checks
  return O
 
12.0, 14.012499, def fheefgbgcfjjedegidfbdigbdeddccab(I):
  O = I 
  for loc in ofcolor(I, ONE):
    i, j = loc[0] + 2, loc[1]
    O = fill(O, THREE, connect((i, max(0, j-2)), (i, min(j+2, width(I)-1)))) 
  return O
 
11.5, 16.610252, def fcjffhagiefgeeecafiidgcfdbfdacdb(I):
  O = canvas(ZERO, shape(I)) # Start with an empty canvas
  for i, row in enumerate(I):  
    for j, value in enumerate(row):
      if value == ONE: # If the cell is a '1'
        for k in range(max(0, j-1), min(j+2, width(I))):
          O = fill(O, THREE, {(i+2, k)}) # Fill with '3's two rows below
  return O 
 
9.5, 13.680799, def ecajddcjhaffeedhiabeicaggbdibjee(I):
  lines = []
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == ONE:
        start_j = max(0, j-1)
        end_j = min(j+2, width(I))
        lines.append(connect((i+2, start_j), (i+2, end_j-1)))
  O = fill(I, THREE, merge(lines))
  return O
 
5.0, 29.678263, def ccafdhibgceaehgfjeeegbhibcidgbfi(I):
  objs = fgpartition(I)
  crosses = set()
  for obj in objs:
    ci, cj = centerofmass(obj)
    h_line = {(ci, j) for j in range(leftmost(obj), rightmost(obj) + 1)}
    v_line = {(ci + i, cj) for i in range(-1, 2)}
    crosses.add(toobject(recolor(color(obj), h_line | v_line), I))
  return paint(I, merge(crosses))
 
17.5, 13.81588, def aaebbgecfcchefiejjaahacjjdbccgba(I):
  # Find the object containing '1'
  target_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == ONE)
  
  # Calculate the center of the target object
  center_i, center_j = center(target_obj)

  # Create the 3x3 square object
  square_obj = frozenset({(THREE, (center_i - 1, center_j - 1)), 
                          (THREE, (center_i - 1, center_j)),
                          (THREE, (center_i - 1, center_j + 1)),
                          (THREE, (center_i, center_j - 1)),
                          (THREE, (center_i, center_j)),
                          (THREE, (center_i, center_j + 1)),
                          (THREE, (center_i + 1, center_j - 1)),
                          (THREE, (center_i + 1, center_j)),
                          (THREE, (center_i + 1, center_j + 1))}) 

  # Paint the square onto the input grid, overwriting the original object
  O = paint(cover(I, target_obj), square_obj)
  return O
 
17.0, 14.292275, def hcbihghhbjbbededbjafecdcibecfafb(I):
  # Find the upper-left corner of the object containing '1'
  obj_corner = ulcorner(extract(objects(I, T, F, T), lambda obj: color(obj) == ONE))

  # Create a 3x3 grid filled with '3'
  square_grid = canvas(THREE, (THREE, THREE))

  # Paint the square grid onto the input grid, offsetting by the corner position
  O = paint(I, shift(asobject(square_grid), obj_corner))
  return O
 
21.5, 16.452295, def bebdddeadfdhejajjdhcdhdcabbieedf(I):
  # Find the indices of all '1's in the grid
  ones_indices = ofcolor(I, ONE)

  # Create a function to generate a 3x3 square patch around a given index
  generate_square_patch = lambda i, j: frozenset({(i - 1, j - 1), 
                                                 (i - 1, j),
                                                 (i - 1, j + 1),
                                                 (i, j - 1),
                                                 (i, j),
                                                 (i, j + 1),
                                                 (i + 1, j - 1),
                                                 (i + 1, j),
                                                 (i + 1, j + 1)})

  # Generate square patches around each '1' index
  square_patches = apply(lambda idx: generate_square_patch(*idx), ones_indices)

  # Merge all square patches into a single patch
  merged_patch = merge(square_patches)

  # Fill the merged patch with '3' on the input grid
  O = fill(I, THREE, merged_patch)
  return O
 
12.5, 10.155534, def abffhbihaijhebaabcdjhbecfiibfcjf(I):
  # Find the indices of all '1's in the grid
  ones_indices = ofcolor(I, ONE)
  
  # Identify pairs of horizontally adjacent '1's
  adjacent_ones = frozenset(
    (i, j) for i, j in ones_indices 
    if (i, j + 1) in ones_indices and I[i][j] == I[i][j + 1]
  )
  
  # Create the cross pattern indices
  cross_indices = mapply(lambda ij: frozenset({ij, (ij[0] - 1, ij[1]), (ij[0] + 1, ij[1]), (ij[0], ij[1] + 1)}), adjacent_ones)
  
  # Fill the cross pattern with '3's
  O = fill(I, THREE, merge(cross_indices)) 
  return O
 
16.5, 21.485376, def gfacccdajbbaehehjdeeaiffjbhefdgj(I):
    obj2 = first(colorfilter(objects(I, T, F, F), TWO))  # Find the object with color '2'
    center_cell = centerofmass(obj2)  # Find the center of the object
    neighbors = dneighbors(center_cell)  # Get the indices of the neighboring cells
    all_cells = insert(center_cell, neighbors)  # Combine the center and neighboring indices
    O = fill(I, THREE, all_cells)  # Fill the selected cells with color '3'
    return O
 
12.5, 10.032921, def cajdfdagbhjeechciaiddiffbdaagfcc(I):
  obj = first(colorfilter(objects(I, T, F, F), TWO)) # Find the object with color '2'
  surrounding =  delta(obj) & dneighbors(centerofmass(obj)) # Find the surrounding cells of the object
  O = fill(I, THREE, surrounding | toindices(obj))  # Fill the original and surrounding cells with '3'
  return O
 
12.5, 10.493865, def afdcgfaddbegecddjiicbeedebcecbfj(I):
  target_obj = first(colorfilter(objects(I, T, F, F), TWO)) # Locate the object with color '2'
  expanded_obj = toobject(backdrop(shift(target_obj, (1, 1))), I)  # Create the expanded object
  recolored_obj = recolor(THREE, expanded_obj)  # Recolor the expanded object to '3'
  O = paint(I, recolored_obj) # Paint the recolored object onto the input grid
  return O
 
19.5, 20.000088, def beigaaafdgffeffejjhbijbjebaaiehj(I):
  objs = fgpartition(I)  # Extract objects from the grid
  lines = mapply(lambda obj: recolor(3, {(lowermost(obj) + 1, j) for j in range(leftmost(obj), rightmost(obj) + 1)}), objs) # Create underlines for each object
  return paint(I, lines) # Paint the underlines onto the original grid
 
19.5, 20.315723, def geddcacbcfcaefcdbfjbihddbdbgceeb(I):
    objs = objects(I, T, T, T) # Extract objects
    shifted_objs = apply(lambda obj: shift(obj, DOWN), objs) # Shift each object down by one row
    underlines = mapply(lambda obj: recolor(3, toindices(obj)), shifted_objs) # Replace each shifted object with 3s
    return paint(I, underlines) # Paint the underlines onto the original grid
 
20.0, 25.740507, def gfbcbgbjaaadecffabaacehcbibijcdh(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        I = fill(I, THREE, hfrontier((i,j)))
        I = fill(I, THREE, vfrontier((i,j)))
  return I
 
25.0, 41.83522, def cgaageaiffieecdgbcajcehcaeiejafc(I):
  def extend_cross(I, i, j):
    for k in range(len(I[0])):
      if I[i][k] == 0:
        I = fill(I, THREE, {(i, k)})
    for k in range(len(I)):
      if I[k][j] == 0:
        I = fill(I, THREE, {(k, j)})
    return I

  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:
        I = extend_cross(I, i, j)
  return I
 
27.0, 34.478653, def cbhbachfcfaiebfhjbdjbeefajcfdeeb(I):
  ones = ofcolor(I, ONE)
  crosses = frozenset()
  for one in ones:
    crosses = crosses |  hfrontier(one) | vfrontier(one)
  return fill(I, THREE, crosses)
 
14.5, 11.191943, def bbeddafaffcdeiefijfeijcabbhcdbaj(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = cover(O, obj)
    c = centerofmass(obj)
    h = height(obj)
    w = width(obj)
    s = max(h, w)
    ul = (c[0] - s // 2, c[1] - s // 2)
    new_obj = {(3, (i, j)) for i in range(ul[0], ul[0] + s) for j in range(ul[1], ul[1] + s)}
    O = paint(O, frozenset(new_obj))
  return O
 
14.5, 10.415795, def cfjefbfdjeddebbdaggdffbdfhjicafg(I):
  # Create a canvas of '0's with the same dimensions as the input
  O = canvas(ZERO, shape(I))
  
  # Iterate over the input grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If a cell contains '1', draw a '3' cross
      if I[i][j] == ONE:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < height(I) and 0 <= nj < width(I):
            O = fill(O, THREE, {(ni, nj)})
      # Otherwise, copy the original value
      else:
        O = fill(O, I[i][j], {(i, j)})
  return O
 
12.5, 11.723037, def digahfdcibbceehbjeddaiageahjebge(I):
  cross = frozenset()
  for i, row in enumerate(I):
      for j, value in enumerate(row):
          if value == ONE:
              if i > 0:
                  cross |= {(i - 1, j)}
              if i < len(I) - 1:
                  cross |= {(i + 1, j)}
              if j > 0:
                  cross |= {(i, j - 1)}
              if j < len(row) - 1:
                  cross |= {(i, j + 1)}
  return fill(I, THREE, cross)
 
18.5, 17.090345, def cbfahagdcjebeddbjfebjacjaaacbbig(I):
  objs = objects(I, True, False, True)  # Identify objects, excluding background
  ones = colorfilter(objs, ONE)  # Filter for objects with color '1'
  expanded_indices = merge(apply(lambda obj: connect(ulcorner(obj), (uppermost(obj), 9)), ones))  # Extend each '1' object to the right edge
  O = fill(I, THREE, expanded_indices)  # Fill the extended indices with color '3'
  return O
 
12.5, 10.155534, def bedfdabchjhgeajaadhdffidaffedhia(I):
  O = I  # Initialize output as input
  for i, row in enumerate(I): # Iterate through rows
    for j, value in enumerate(row): # Iterate through columns
      if value == ONE:  # If a '1' is encountered
        for k in range(j + 1, 10): # Fill rightwards with '3'
          if O[i][k] == ZERO:
            O = fill(O, THREE, {(i, k)})
          else:
            break  # Stop if another object is encountered
  return O
 
18.5, 19.820524, def ebhciceadiciegfabbeeacgffacchbdb(I):
  ones = ofcolor(I, ONE) # Find indices of all '1's
  h_frontiers = apply(hfrontier, totuple(ones)) # Get horizontal frontiers for each '1'
  filtered_frontiers = apply(lambda frontier: sfilter(frontier, lambda loc: index(I, loc) == ZERO), h_frontiers) # Filter frontiers to keep only indices with '0'
  expanded_indices = merge(filtered_frontiers) # Merge all filtered frontiers
  O = fill(I, THREE, expanded_indices) # Fill the expanded indices with '3'
  return O
 
12.5, 11.892244, def bffedhgajfdaehbebajadadbfdhbhbhf(I):
  objs = objects(I, True, False, True) # Identify objects, excluding background
  extended_objs = apply(lambda obj: toobject(product(range(uppermost(obj),lowermost(obj)+1),range(leftmost(obj),10)), I), objs)  # Extend each object to the right edge
  filtered_objs = mfilter(extended_objs, lambda obj: color(obj) == ONE) # Filter for extended objects that were originally '1's
  O = paint(I, recolor(THREE, toindices(filtered_objs))) # Paint the filtered objects onto the original grid with color '3'
  return O
 
14.5, 10.881858, def jchgjdaebdieeediifbdeaaahabhddfi(I):
  def modify_cell(i, j):
    if I[i][j] == ONE: # Check if the cell color is "1".
      return THREE  # If so, change it to "3".
    elif (i, j) in {(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)} and I[i][j] == 0:
      return THREE
    else:
      return I[i][j]  # Otherwise, keep the original color.
  return tuple(tuple(modify_cell(i, j) for j in range(len(I[0]))) for i in range(len(I))) # Apply modification to all cells.
 
14.5, 11.191943, def acbcgeadeaebediaabdjacjdfegajfcd(I):
  cross_indices = set()
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:  # If cell is "1"...
        cross_indices.update({(i, j), (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)}) # Add "+" shape indices.
  return fill(I, THREE, frozenset(cross_indices))  # Fill the "+" shape indices with "3".
 
12.5, 10.155534, def becfiaajdgajeefajjbjadidjaaefehh(I):
  def square_from_object(obj):
    ul = ulcorner(obj)
    s = max(shape(obj))
    return frozenset((ul[0] + i, ul[1] + j) for i in range(s) for j in range(s))

  objs = objects(I, T, F, T)
  new_objs = mapply(lambda obj: obj if size(obj) == 1 else recolor(3, square_from_object(obj)), objs)
  O = paint(canvas(0, shape(I)), new_objs)
  return O
 
24.0, 18.941236, def ccdeeaecegeeedddiebaecdbhfcjhfgf(I):
  cross_template = canvas(ZERO, (3, 3))
  cross_template = fill(cross_template, THREE, {(1, 0), (1, 2), (0, 1), (2, 1)})
  occurrences_indices = occurrences(I, recolor(ONE, {(1, 1)}))
  O = I
  for i, j in occurrences_indices:
    O = paint(O, recolor(THREE, shift(asindices(cross_template), (i, j))))
  return O
 
12.5, 11.535579, def fffbgejhfjbaefidifddiccfcjhcfacf(I):
  kernel = ((0, 1, 0), (1, 0, 1), (0, 1, 0))
  h, w = len(I), len(I[0])
  O = [list(row) for row in I]
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if I[i][j] == ONE:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if kernel[di + 1][dj + 1] == 1:
              O[i + di][j + dj] = THREE
  return tuple(tuple(row) for row in O)
 
17.0, 17.333204, def hfiddcbbiaeeeacgbggebffjhbejiajc(I):
  O = I  # Initialize output as input
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE:
        O = fill(O, THREE, {(i, k) for k in range(j + 1, len(row))})
  return O
 
16.5, 24.27331, def bafjafgajdchefefbchacaecehaeaacf(I):
  return paint(I, merge(apply(lambda loc: recolor(THREE, {(i, loc[1]) for i in range(loc[0] + 1, len(I[0]))}), totuple(ofcolor(I, ONE))))) 
 
14.5, 9.607831, def bbiddjedfbfeefjfbdceaafcjjfbfffc(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        O = paint(O, {(THREE, (i, k)) for k in range(j + 1, w)})
      else:
        O = paint(O, {(val, (i, j))})
  return O
 
16.5, 17.31335, def hgdacdcacdbfejddjjdhfecifffaicda(I):
  transformed_rows = []
  for row in I:
    transformed_row = list(row)
    found_one = False
    for j, val in enumerate(transformed_row):
      if val == ONE:
        found_one = True
      if found_one and val == ZERO:
        transformed_row[j] = THREE
    transformed_rows.append(tuple(transformed_row))
  return tuple(transformed_rows)
 
14.5, 10.818181, def hbebgefhdjfceeaijiahefbaiahaffba(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0), (0, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < height(I) and 0 <= nj < width(I):
            O = fill(O, THREE, {(ni, nj)})
      else:
        O = fill(O, val, {(i, j)})
  return O
 
19.5, 16.409912, def ghcdbcecgabcebbdbdghcagaibcdaahe(I):
  return paint(I, merge({recolor(THREE, neighbors((i, j))) for i, row in enumerate(I) for j, val in enumerate(row) if val == ONE}))
 
14.5, 11.191943, def fcahijehbaddegiaiiccfgjbcacbeche(I):
  cross_offsets = ((-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)) 
  return tuple(
    tuple(
      THREE if any(0 <= i + di < len(I) and 0 <= j + dj < len(row) and I[i + di][j + dj] == ONE for di, dj in cross_offsets) else val 
      for j, val in enumerate(row)
    )
    for i, row in enumerate(I)
  )
 
17.5, 16.315674, def acfgfhejcjicecaabjceabejdfaijegc(I):
    """
    Uses nested loops to iterate and create '+' shapes around '1's.
    """
    output = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == ONE:
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                      if 0 <= i + di < len(I) and 0 <= j + dj < len(row):
                        output = fill(output, THREE, {(i + di, j + dj)})
            else:
                output = fill(output, val, {(i, j)})
    return output
 
21.5, 16.452295, def cedhcdfdaabfedfijaacaccbcbeajjca(I):
    """
    Leverages map and lambda function for concise '+' shape generation.
    """
    return tuple(
        tuple(
            THREE if any(I[k][l] == ONE for k in range(max(0, i - 1), min(len(I), i + 2)) for l in range(max(0, j - 1), min(len(row), j + 2))) else val
            for j, val in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
17.5, 12.609455, def cjdfbbbeabbfeffdihfgaajddbbedbcd(I):
  objs = objects(I, T, F, F) # Get all objects
  expanded_objs = apply(lambda obj: recolor(THREE, {(i, k) for (v, (i, j)) in obj for k in range(j + 1, width(I))}) if color(obj) == ONE else obj, objs) # Expand right with 3s if color is 1
  O = paint(canvas(ZERO, shape(I)), merge(expanded_objs)) # Paint on a blank canvas
  return O
 
17.5, 17.793568, def ibcicajfdafdecdeafbhbegbebfhdced(I):
  objs = objects(I, T, T, T)
  underlines = frozenset()
  for obj in objs:
    w = width(obj)
    start = (lowermost(obj) + 1, leftmost(obj) + w // 2 - (w + 1) // 2)
    underline = {(start[0], start[1] + i) for i in range(w)} 
    underlines = underlines | recolor(3, underline)
  return paint(I, underlines)
 
11.0, 11.170665, def cdgcgcfjaaaeecbbbdhcbdcebfaaaihf(I):
  objs = colorfilter(objects(I, T, F, F), TWO)  # Find all objects with color '2'
  crosses = mapply(lambda obj: delta(obj) & (hfrontier(center(obj)) | vfrontier(center(obj))), objs) # Generate cross pattern indices for each object
  O = paint(cover(I, merge(objs)), recolor(THREE, crosses))  # Remove original objects and paint the cross patterns with '3'
  return O
 
17.0, 18.39329, def hafhdbegfhjcebdiaaccebadibebcdjf(I):
  twos = [(i,j) for i, row in enumerate(I) for j, val in enumerate(row) if val==TWO]  # Get indices of all '2's
  crosses = set().union(*[{(i+di,j+dj) for di, dj in [(0,1),(0,-1),(1,0),(-1,0)] if 0<=i+di<len(I) and 0<=j+dj<len(I[0])} for i,j in twos])  # Generate cross indices
  O = [[THREE if (i,j) in crosses else (ZERO if (i,j) in twos else I[i][j]) for j in range(len(I[0]))] for i in range(len(I))]  # Apply changes to grid
  return tuple(tuple(row) for row in O)  # Convert back to tuple of tuples
 
14.0, 14.08326, def ebfeccafdcdiecaijaadeccdceiaegbb(I):
  objs = colorfilter(objects(I, T, F, F), TWO)  # Find all objects with color '2'
  cross = lambda obj: hconcat(((THREE,),), vconcat(((THREE,),(THREE,),(THREE,)), ((THREE,),)))  # Define a lambda function to create a cross pattern grid
  crosses =  mapply(lambda obj: shift(asobject(cross(obj)), subtract(center(obj), (1,1))), objs) # Generate cross patterns at object centers
  O = paint(cover(I, merge(objs)), crosses)  # Remove original objects and paint crosses
  return O
 
14.5, 11.391901, def fiaihicjiabaebggjjiefaebheeehjda(I):
    target_indices = merge([ofcolor(I, value) for value in [1, 6, 7, 8]])
    return fill(fill(I, 0, target_indices), 3, target_indices)
 
33.5, 25.553854, def fcicgbabefadeefcbgdajbegggebcbae(I):
  objs = objects(I, T, F, T)
  target_objs = sfilter(objs, lambda obj: color(obj) in {1, 6, 7, 8})
  centers = apply(centerofmass, target_objs)
  squares = apply(lambda c: recolor(3, shift(asindices(canvas(0, (3, 3))), subtract(c, (1, 1)))), centers)
  return paint(canvas(0, shape(I)), merge(squares))
 
14.5, 11.31386, def ebddddbbcchfecgjbgdbccfefbbgacbe(I):
  def expand_object(obj):
    return recolor(3, backdrop(shift(obj, (1, 1))))
  objs = objects(I, T, F, T)
  target_objs = sfilter(objs, lambda obj: color(obj) in {1, 6, 7, 8})
  expanded_objs = apply(expand_object, target_objs)
  return paint(canvas(0, shape(I)), merge(expanded_objs))
 
311.5, 66.90278, def gbgbbedbhagdeeaiibaedfeeeiejdbfd(I):
  # Create a function to expand a single '1' into a '+' shape
  expand_one = lambda i, j: fill(canvas(ZERO, (3, 3)), THREE, frozenset({(1, 0), (1, 1), (1, 2), (0, 1), (2, 1)})) if I[i][j] == 1 else canvas(ZERO, (3, 3))
  # Apply the expansion function to each cell of the input grid
  expanded_grid = tuple(tuple(v for row in expand_one(i, j) for v in row) for i in range(len(I)) for j in range(len(I[0])))
  # Downscale the expanded grid to the original size 
  O = downscale(expanded_grid, 3)
  return O
 
95.0, 10.5069895, def cjgfcjbaebbfebgbbbcfcdddfgjdeecj(I):
  # Create a grid with '3's at the locations of '1's and their neighbors
  crosses = cellwise(I, switch(I, ZERO, ONE), THREE)
  # Replace remaining '1's with '0's
  O = replace(crosses, ONE, ZERO)
  return O
 
14.5, 10.899256, def dahafdbfcchceigiadddbcaadacbbgff(I):
  objs = colorfilter(objects(I, T, F, F), ONE)
  O = I
  for obj in objs:
    center_i, center_j = center(obj)
    bar_width = 3 * width(obj)
    start_j = center_j - bar_width // 2
    for dj in range(bar_width):
      O = fill(O, THREE, {(center_i, start_j + dj)})
  return O
 
14.5, 10.818181, def dbcfgabcacfieedaiibfccghejigbcfi(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == ONE and all(I[i + di][j + dj] != ONE for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] if 0 <= i + di < len(I) and 0 <= j + dj < len(row)):
                O = fill(O, THREE, {(i, j), (i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)})
            else:
                O = fill(O, val, {(i, j)})
    return O
 
26.0, 24.007513, def bbdhfcgdbabceacbaccjibcddhaifdcb(I):
  ones = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = fill(canvas(ZERO, shape(I)), THREE, 
           merge({shift(obj, d) for obj in ones for d in [UP, DOWN, LEFT, RIGHT, ORIGIN]}))
  return O
 
15.5, 17.145933, def ffhidacebjahedfgjfbdaaeddjcfhbif(I):
    painted = set()
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == ONE: 
                obj = extract(objects(I, T, F, F), lambda obj: (i,j) in toindices(obj))
                bar_width = 3 * width(obj)
                start_j = max(0, j - bar_width // 2 + width(obj) // 2)
                for k in range(bar_width):
                    if 0 <= start_j + k < len(row):
                        painted.add((i-1, start_j + k))
    O = paint(I, recolor(THREE, frozenset(painted)))
    return O
 
22.5, 18.020924, def hfbfhcjjeefbeccbjaaeeaehfcbieeee(I):
  objs = fgpartition(I)  # Partition the grid into foreground objects
  extended_boundaries = mapply(
      lambda obj: recolor(
          3, 
          frozenset(
              (i + 1, j + dj) 
              for i, j in toindices(obj) 
              if i + 1 == lowermost(obj) + 1 
              for dj in range(-1, 2)
          )
      ), 
      objs
  )  # Extend and recolor the bottom boundaries
  return paint(I, extended_boundaries)  # Paint the boundaries onto the grid
 
20.5, 17.032757, def dgbchfeegihcegbcjdcbcddbgcfdjadc(I):
  objs = fgpartition(I)
  bottom_lines = mapply(
      lambda obj: recolor(
          3,
          combine(
              {(lowermost(obj) + 1, leftmost(obj) - 1)}, 
              combine(
                  {(lowermost(obj) + 1, j) for i, j in toindices(obj) if i + 1 == lowermost(obj) + 1},
                  {(lowermost(obj) + 1, rightmost(obj) + 1)}
              )
          )
      ),
      objs
  )
  return paint(I, bottom_lines)
 
20.0, 13.435479, def faaaabdfbhfeeabbjabcfbhbdafacbca(I):
  changed = canvas(0, shape(I))
  for obj in fgpartition(I):
    for i, j in toindices(obj):
      if i + 1 == lowermost(obj) + 1:
        for dj in range(-1, 2):
          changed = fill(changed, 3, {(i + 1, j + dj)})
  return paint(I, asobject(changed))
 
14.0, 11.12989, def cdeebifadajieadabagfbbfbadcagece(I):
  O = I  # Initialize the output grid as a copy of the input grid
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == ONE:
        O = fill(O, THREE, {(i, j), (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)})  # Fill '+' shape if '1' is found
  return O
 
95.0, 37.687378, def dafcadfaiaffecacjcfchfiiaafdaffi(I):
  padded_I = canvas(ZERO, (height(I) + 2, width(I) + 2)) # Create a padded grid with zeros
  padded_I = fill(padded_I, ONE, shift(asindices(I), (1, 1))) # Fill the inner part with the input grid shifted by (1, 1)
  cross = {(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)}  # '+' shape relative indices
  O = canvas(ZERO, shape(I)) # Initialize output grid
  for i in range(1, height(padded_I) - 1):
    for j in range(1, width(padded_I) - 1):
      if padded_I[i][j] == ONE:
        O = fill(O, THREE, {(i + di - 1, j + dj - 1) for di, dj in cross}) # Fill '+' shape in the output grid
  return O
 
