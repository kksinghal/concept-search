0.98, 5.6818557, def gaagcidafbahecccjebefchiaeffdech(I):
    # Identify all objects
    objs = objects(I, T, F, F)
    
    # Find unique objects based on color (single occurrences)
    unique_objs = frozenset(obj for obj in objs if colorcount(I, color(obj)) == size(obj))
  
    # Pair unique objects based on their positions
    paired_objs = frozenset({(a, b) for a in unique_objs for b in unique_objs if a != b and position(a, b) == (1, 0)})
  
    # Swap colors of paired objects
    O = I
    for a, b in paired_objs:
        O = paint(cover(O, a), recolor(color(b), a))
        O = paint(cover(O, b), recolor(color(a), b))
    return O
 
0.30666666666666664, 6.75478, def fiehefeicfdbegebjfadcaefchacfghb(I):
  # Extract objects, treating different colors as separate
  objs = objects(I, F, F, F)

  # Create a dictionary mapping object colors to their counts
  color_counts = {}
  for obj in objs:
    color_val = color(obj)
    color_counts[color_val] = color_counts.get(color_val, 0) + 1
  
  # Filter for objects with unique colors
  unique_objs = frozenset(obj for obj in objs if color_counts[color(obj)] == 1)
  
  # Sort unique objects based on vertical position (top to bottom)
  sorted_objs = order(unique_objs, lambda obj: uppermost(obj))

  # Swap colors of consecutive objects in the sorted list
  O = I
  for i in range(0, len(sorted_objs) - 1, 2):
    a = sorted_objs[i]
    b = sorted_objs[i+1]
    O = paint(cover(O, a), recolor(color(b), a))
    O = paint(cover(O, b), recolor(color(a), b))
  return O
 
0.8700000000000001, 11.049245, def ebbbbecacbededcfbdbjcbbejdgfdgce(I):
  objs = objects(I, T, F, F)
  
  def is_paired(obj):
    for other in objs:
      if obj != other and position(obj, other) in {(1, 0), (-1, 0)}:
        return True
    return False
    
  paired_objs = sfilter(objs, is_paired)
  
  O = I
  for obj in paired_objs:
    for other in objs:
      if obj != other and position(obj, other) in {(1, 0), (-1, 0)}:
        O = paint(cover(O, obj), recolor(color(other), obj))
  return O
 
0.8966666666666666, 5.2052155, def iieeccfijbfceibjbaiacddcccfieffb(I):
  objs = objects(I, T, F, F)
  
  def find_pair(obj):
    for other in objs:
      if obj != other and position(obj, other) in {(1, 0), (-1, 0)}:
        return other
    return None
  
  O = I
  for obj in objs:
    pair = find_pair(obj)
    if pair is not None:
      O = paint(cover(O, obj), recolor(color(pair), obj))
  return O
 
0.7633333333333333, 45.16727, def jdegfefdgaiaebbfjeaejgcibbcbebab(I):
  obj1 = argmax(objects(I, T, F, F), lambda obj: uppermost(obj))  # Topmost object
  obj2 = argmax(objects(I, T, F, F), lambda obj: lowermost(obj))  # Bottommost object
  obj3 = extract(objects(I, T, F, F), lambda obj: hmatching(obj, obj1) and hmatching(obj, obj2))  # Object horizontally aligned with both
  
  color1 = color(obj1)
  color2 = color(obj2)
  color3 = color(obj3)
  
  O = replace(I, color1, color2) 
  O = replace(O, color2, color1)
  O = replace(O, color3, color2)
  O = replace(O, color2, color3)
  return O
 
0.32666666666666666, 67.1816, def achgdjfbfgeaeiifbbbefhbdhcbdbafa(I):
  objs = sorted(objects(I, False, False, True), key=lambda x: len(x))
  o1 = objs[0]
  o2 = objs[1]
  o3 = objs[2]
  
  v2 = subtract(llcorner(o2), ulcorner(o1))
  v3 = subtract(llcorner(o3), ulcorner(o1))
  
  g = paint(canvas(0, shape(I)), o1)
  g = underpaint(g, shift(o1, v2))
  O = underpaint(g, shift(o1, v3))
  return O
 
0.32666666666666666, 66.44607, def dcdcifbjfcicefccjeecdcccjhjdefce(I):
  objs = objects(I, False, False, True)
  
  o1 = min(objs, key=lambda x: ulcorner(x)[0] * 10 + ulcorner(x)[1])
  objs = objs - {o1}
  o2 = min(objs, key=lambda x: ulcorner(x)[0] * 10 + ulcorner(x)[1])
  o3 = max(objs, key=lambda x: ulcorner(x)[0] * 10 + ulcorner(x)[1])
  
  s2 = subtract(llcorner(o2), ulcorner(o1))
  s3 = subtract(llcorner(o3), ulcorner(o1))
  
  canvas_ = canvas(0, shape(I))
  canvas_ = paint(canvas_, o1)
  canvas_ = paint(canvas_, shift(o1, s2))
  O = paint(canvas_, shift(o1, s3))
  return O
 
0.31666666666666665, 7.797231, def jjceccabfbbaeidfbcehidebafccdage(I):
  # Directly paint the second largest object with the color of the largest.
  O = paint(I, recolor(
      color(last(order(objects(I, T, F, F), size))),
      first(remove(last(order(objects(I, T, F, F), size)), order(objects(I, T, F, F), size)))
  ))
  return O
 
0.30666666666666664, 66.92012, def fdhbhbcfefcdebdibehafabjcdfcbjha(I):
    # Define a function to count occurrences of a specific color.
    def count_color(grid, color):
        return sum(row.count(color) for row in grid)
    
    # Find the two most frequent colors.
    color_counts = [(count_color(I, c), c) for c in palette(I)]
    largest_color = max(color_counts)[1]
    second_largest_color = sorted(color_counts)[-2][1]

    # Replace the second largest color with the largest color in the grid.
    O = tuple(
        tuple(largest_color if v == second_largest_color else v for v in r) for r in I
    )
    return O
 
0.30666666666666664, 6.75478, def ibdbchbhafccedebjhgcaddbabccffjf(I):
    objs = objects(I, T, F, T)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        color_to_apply = next(iter(obj))[0]
        for c, (i, j) in obj:
            O = fill(O, color_to_apply, {(i, j)})
    return O
 
0.33666666666666667, 7.2579565, def abaeebdeaheieecfigafaaccbacadfhe(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj))
  new_objs = []
  for i in range(len(objs) - 1):
    obj1 = objs[i]
    obj2 = objs[i+1]
    color1 = color(obj1)
    color2 = color(obj2)
    new_objs.append(recolor(color2, obj1))
    new_objs.append(recolor(color1, obj2))
  if len(objs) % 2 == 1:
    new_objs.append(objs[-1]) 
  O = paint(I, merge(new_objs))
  return O
 
0.25666666666666665, 5.0201907, def idhfeijebfcaeghfbfcfbaciafaaeebe(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: uppermost(obj))
  O = I
  for i in range(len(objs) - 1):
    obj1 = objs[i]
    obj2 = objs[i+1]
    if vmatching(obj1, obj2):
      O = paint(cover(O, obj1), recolor(color(obj2), obj1))
      O = paint(cover(O, obj2), recolor(color(obj1), obj2))
  return O
 
0.98, 6.337494, def jdhhfhgbiebbegfabfegajbgheahdbcf(I):
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  smallest_obj = argmin(objs, size)
  largest_color = color(largest_obj)
  smallest_color = color(smallest_obj)
  O = I
  for obj in objs:
    if obj == largest_obj:
      O = paint(O, recolor(smallest_color, obj))
    elif obj == smallest_obj:
      O = paint(O, recolor(largest_color, obj))
    else:
      O = paint(O, obj)
  return O
 
0.30666666666666664, 6.75478, def dbbbffdccfbbehebjdedicebaeadbdbg(I):
  objs = objects(I, T, F, F)
  palette_I = palette(I)
  color_counts = [(c, colorcount(I, c)) for c in palette_I]
  most_frequent_color =  mostcommon(color_counts)[0]
  least_frequent_color = leastcommon(color_counts)[0]
  O = replace(I, most_frequent_color, TEN)
  O = replace(O, least_frequent_color, most_frequent_color)
  O = replace(O, TEN, least_frequent_color)
  return O
 
0.98, 6.365507, def iaheebeabdcdefiabbiecffjiadddjcj(I):
    objs = objects(I, True, False, False)
    sizes = list({(size(obj), color(obj)) for obj in objs})
    target_colors = sorted(sizes)[0][1], sorted(sizes)[-1][1]
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if index(I, (i, j)) == target_colors[0]:
                O = fill(O, target_colors[1], {(i, j)})
            elif index(I, (i, j)) == target_colors[1]:
                O = fill(O, target_colors[0], {(i, j)})
    return O
 
0.31666666666666665, 59.929337, def jjedahccgfdcecagiefhffbfgbbfhjha(I):
  objs = objects(I, False, False, True)
  obj1 = first(sorted(objs, key=lambda obj: llcorner(obj)[0])) # Find the topmost object
  ref_point = llcorner(obj1) # Reference point is the lower-left corner of the topmost object

  new_objs = []
  for obj in objs:
    offset = subtract(llcorner(obj), ref_point) # Calculate offset from the reference point
    new_objs.append(shift(obj1, offset)) # Shift object based on offset

  O = paint(canvas(0, shape(I)), merge(new_objs)) # Paint shifted objects on canvas
  return O 
 
0.31666666666666665, 59.501324, def hejaggbcbhehejefbdchcicecbcaegjc(I):
  objs = objects(I, False, False, True)
  sorted_objs = sorted(objs, key=lambda obj: (uppermost(obj), leftmost(obj)))  # Sort objects by top-left corner
  ref_obj = sorted_objs[0] # The reference object is the top-left most object
  O = canvas(0, shape(I)) 

  for i in range(len(sorted_objs)):
    offset = subtract(llcorner(sorted_objs[i]), llcorner(ref_obj)) # Calculate offset from the reference object
    O = paint(O, shift(ref_obj, offset)) # Shift and paint the reference object

  return O
 
0.39666666666666667, 51.181, def chhaegbfbajeeeidibfgchidfhdaicea(I):
  objs = objects(I, False, False, True)
  min_i = min(uppermost(obj) for obj in objs) # Find minimum row index among objects
  min_j = min(leftmost(obj) for obj in objs if uppermost(obj) == min_i) # Find min column index among topmost objects
  ref_point = (min_i, min_j) # Define reference point 

  O = canvas(0, shape(I))
  for obj in objs:
    offset = subtract(llcorner(obj), ref_point) # Calculate offset from reference point
    O = paint(O, shift(obj, offset)) # Shift object based on offset

  return O
 
0.30666666666666664, 31.31661, def cjibfddebcieegbdjgaadaiabfbefcch(I):
  # Identify objects and order them by size
  objs = order(objects(I, T, F, F), size)
  
  # Extract the two largest objects
  largest = last(objs)
  second_largest = last(remove(largest, objs))
  
  # Recolor the second largest object with the color of the largest
  recolored = recolor(color(largest), second_largest)
  
  # Paint the recolored object back onto the grid
  O = paint(I, recolored)
  return O
 
0.22333333333333336, 5.7283096, def dhfjicdcheiiehfijdhcafaaighafade(I):
    non_bg_colors = difference(palette(I), {mostcolor(I)}) # find all colors except background
    target_color = mostcommon(list(non_bg_colors)) # find the most common non-background color
    new_grid = []
    for i in range(len(I)):
        row = list(I[i])
        for j in range(len(row)):
            if row[j] in non_bg_colors:
                row[j] = target_color # replace color if it's not background
        new_grid.append(row)
    return tuple(tuple(row) for row in new_grid)
 
0.03, 1.6597819, def bbeeejbicjfdeccdiffgafiaiahccdee(I):
  objs = objects(I, T, F, T)  # Extract objects, not considering diagonals or background
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2)[0] == 1:  # Check for vertical adjacency and relative position
        I = paint(cover(I, obj1), recolor(color(obj2), obj1))  # Swap colors by repainting
        I = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return I
 
0.25666666666666665, 5.2518606, def hcdcdfccdajbedibifdbfabcbejeadbh(I):
  objs = objects(I, T, F, T)
  pairs = {(color(obj1), color(obj2)) for obj1 in objs for obj2 in objs 
           if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2)[0] == 1}  # Find pairs to swap
  for a, b in pairs:
    I = replace(I, a, -1) # Use temporary color for swapping
    I = replace(I, b, a)
    I = replace(I, -1, b)
  return I
 
0.31, 6.8014193, def hbfdfhiffecfehgcbicabhdedgbhfibb(I):
  O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  objs = objects(I, T, F, T)
  for obj in objs:
    for other_obj in objs:
      if obj != other_obj and vmatching(obj, other_obj) and position(obj, other_obj)[0] == 1:
        O = paint(O, recolor(color(other_obj), obj))  # Paint directly onto the new canvas
      else:
        O = paint(O, obj)  # If not a swap pair, paint the original object
  return O
 
0.26999999999999996, 6.9905887, def cfbbijecfeedegcaibbdbcadjcfdefgb(I):
  objs = objects(I, False, False, True)  # Extract objects without background
  colors = sorted(palette(I)) # Get sorted list of colors
  c1 = colors[1]  # Smallest color
  c2 = colors[2]  # Second smallest color
  c3 = colors[3]  # Third smallest color
  O = paint(paint(paint(canvas(0, shape(I)), recolor(c2, ofcolor(I, c2))), recolor(c1, ofcolor(I, c1))), recolor(c1, ofcolor(I, c3)))
  return O
 
0.3233333333333333, 45.273018, def heeajcbgaagdebdbbjiebjddhbaecjdc(I):
  objs = objects(I, False, False, True)
  color_objs = dict()
  for obj in objs:
    color_objs[color(obj)] = obj
  colors = sorted(color_objs.keys())
  obj1 = color_objs[colors[0]]
  obj2 = color_objs[colors[1]]
  obj3 = color_objs[colors[2]]
  O = paint(paint(paint(canvas(0, shape(I)), recolor(colors[1], obj2)), recolor(colors[0], obj1)), recolor(colors[0], obj3))
  return O
 
0.5033333333333334, 10.167231, def bbdedffbahceebeaabafhecbjhaefcja(I):
    objs = objects(I, T, F, T)  # identify objects
    return tuple(
        tuple(
            next((color(obj) for obj in objs if (i, j) in toindices(shift(obj, (-uppermost(obj), 0)))), v)  # find the color of the shifted object at the current cell, if any
            for j, v in enumerate(r)
        )
        for i, r in enumerate(I)
    )
 
0.31666666666666665, 32.83964, def badggfbfadbfejhjaidfffhdibegjidi(I):
  objs = objects(I, False, False, True)
  p = palette(I)
  obj1 = min(objs, key=lambda obj: color(obj)) # Find the object with the minimum color value
  p = p - {color(obj1)} # Remove the color from the palette
  obj2 = min(objs, key=lambda obj: color(obj) if color(obj) in p else 10) # Find the object with the next minimum color value
  p = p - {color(obj2)}
  obj3 = min(objs, key=lambda obj: color(obj) if color(obj) in p else 10)
  O = paint(paint(paint(canvas(0, shape(I)), recolor(color(obj1), obj2)), recolor(color(obj2), obj1)), recolor(color(obj2), obj3)) 
  return O
 
0.31, 44.890854, def ebebgcfcfadfeifbbeaihdjbaebgbdfe(I):
  objs = objects(I, False, False, True)
  color_objs = {color(obj): obj for obj in objs}  # Create a dictionary mapping colors to objects
  colors = sorted(color_objs)
  O = paint(paint(paint(canvas(0, shape(I)), recolor(colors[0], color_objs[colors[1]])), recolor(colors[1], color_objs[colors[0]])), recolor(colors[1], color_objs[colors[2]]))
  return O
 
0.30666666666666664, 6.8808026, def icjidgabahdjegbaicagagdbecfddfea(I):
  O = canvas(mostcolor(I), shape(I))  # Create canvas with background color
  objs = objects(I, T, F, T)  # Extract objects excluding background
  for obj in objs:
    shifted_obj = shift(obj, DOWN)  # Shift each object down
    if not any(index(I, pos) == mostcolor(I) for pos in toindices(shifted_obj)):
      # If shifted object doesn't overlap with background
      O = paint(O, recolor(color(obj), shifted_obj))  # Paint shifted object to the canvas
    else:
      O = paint(O, obj)  # Otherwise paint the original object to the canvas
  return O
 
0.41, 32.9375, def chdaaidacfjdehcbiegdbjibaedafbjf(I):
  # Identify objects based on size and corner positions
  objs = objects(I, True, False, False)
  obj1 = extract(objs, lambda o: size(o) == valmax(objs, len))
  obj2 = extract(remove(obj1, objs), lambda o: size(o) == valmax(remove(obj1, objs), len))
  obj3 = extract(objs, lambda o: lrcorner(o) == (height(I)-1,width(I)-1))
  obj4 = extract(objs, lambda o: urcorner(o) == (0, width(I) - 1))

  # Swap object positions while maintaining their colors
  O = paint(cover(I, obj1), shift(obj3, subtract(ulcorner(obj1), ulcorner(obj3))))
  O = paint(cover(O, obj2), shift(obj4, subtract(ulcorner(obj2), ulcorner(obj4))))
  O = paint(cover(O, obj3), shift(obj1, subtract(ulcorner(obj3), ulcorner(obj1))))
  O = paint(cover(O, obj4), shift(obj2, subtract(ulcorner(obj4), ulcorner(obj2))))
  return O
 
0.32666666666666666, 32.78188, def aaifeecabijeeieejidffecbffgceiaj(I):
    # Identify objects and their properties
    objs = objects(I, True, False, False)
    obj1 = extract(objs, lambda o: size(o) == valmax(objs, len))
    obj2 = extract(remove(obj1, objs), lambda o: size(o) == valmax(remove(obj1, objs), len))
    corner3 = (height(I) - 1, width(I) - 1)
    corner4 = (0, width(I) - 1)

    # Define a function to move an object to a specific location
    def move_object(grid, obj, target_corner):
        return paint(cover(grid, obj), shift(obj, subtract(target_corner, ulcorner(obj))))

    # Swap object positions using the move_object function
    O = move_object(I, obj1, corner3)
    O = move_object(O, obj2, corner4)
    O = move_object(O, extract(objects(O, True, False, False), lambda o: lrcorner(o) == corner3), ulcorner(obj1))
    O = move_object(O, extract(objects(O, True, False, False), lambda o: urcorner(o) == corner4), ulcorner(obj2))
    return O
 
0.30666666666666664, 6.75478, def egbbciabjeeaefehaefbbdaecdfifcgj(I):
  objs = objects(I, False, False, True) # Extract objects, excluding background
  colors = sorted(list(palette(I))) # Get sorted list of colors
  
  obj1 = next((obj for obj in objs if color(obj) == colors[0]), None)
  obj2 = next((obj for obj in objs if color(obj) == colors[1]), None)
  obj3 = next((obj for obj in objs if color(obj) == colors[2]), None)
  
  # Handle potential missing objects gracefully
  if not all([obj1, obj2, obj3]):
    return I  # Return the input unchanged if any object is missing
  
  canvas_ = canvas(0, shape(I))
  canvas_ = paint(canvas_, recolor(colors[0], obj2))
  canvas_ = paint(canvas_, recolor(colors[1], obj1))
  O = paint(canvas_, recolor(colors[1], obj3))
  return O
 
0.33666666666666667, 44.958897, def gajdjdbdaabeehheijgaddbcaafedbab(I):
  objs = objects(I, False, False, True)
  colors = sorted(list(palette(I)))
  
  obj_mapping = {color(obj): obj for obj in objs} 
  
  O = canvas(0, shape(I))
  for c in colors:
    if c == colors[0]:
      O = paint(O, recolor(colors[1], obj_mapping.get(c, frozenset())))
    elif c == colors[1]:
      O = paint(O, recolor(colors[0], obj_mapping.get(c, frozenset())))
    else:
      O = paint(O, recolor(colors[1], obj_mapping.get(c, frozenset())))
  return O
 
0.31666666666666665, 46.296825, def dcbfchibeijieiecagfejjabbafccgbd(I):
  objs = objects(I, False, False, True)
  colors = sorted(list(palette(I)))
  
  obj1_indices = toindices(next((obj for obj in objs if color(obj) == colors[0]), frozenset()))
  obj2_indices = toindices(next((obj for obj in objs if color(obj) == colors[1]), frozenset()))
  obj3_indices = toindices(next((obj for obj in objs if color(obj) == colors[2]), frozenset()))
  
  O = canvas(0, shape(I))
  O = fill(O, colors[1], obj1_indices)
  O = fill(O, colors[0], obj2_indices)
  O = fill(O, colors[1], obj3_indices)
  return O
 
0.26333333333333336, 33.21711, def ghefeceabdhcedgeihafagjjgddcgcic(I):
    objs = objects(I, False, False, True)
    colors = sorted(list(palette(I)))
    O = I
    for i, c in enumerate(colors):
      if i == 0:
        O = paint(canvas(0, shape(I)), recolor(colors[1], next((obj for obj in objs if color(obj) == c), frozenset())))
      elif i == 1:
        O = paint(O, recolor(colors[0], next((obj for obj in objs if color(obj) == c), frozenset())))
      else:
        O = paint(O, recolor(colors[1], next((obj for obj in objs if color(obj) == c), frozenset()))) 
    return O
 
0.2833333333333334, 29.772417, def hgeafabcgdidejdabbaahcbdjiafeadb(I):
  objs = objects(I, False, False, True)
  colors = sorted(list(palette(I)))
  
  O = canvas(0, shape(I))
  for obj in objs:
    c = color(obj)
    new_color = colors[1] if c in (colors[0], colors[2]) else colors[0] 
    O = paint(O, recolor(new_color, obj))
  return O
 
0.30666666666666664, 6.75478, def fdbjjaaidaccegicicghgdffghfeaeeh(I):
  objs = order(objects(I, T, F, F), size)
  second_largest_color = color(objs[-2])
  third_largest_color = color(objs[-3])
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    obj_color = color(obj)
    if obj_color == second_largest_color:
      O = paint(O, recolor(third_largest_color, obj))
    elif obj_color == third_largest_color:
      O = paint(O, recolor(second_largest_color, obj))
    else:
      O = paint(O, obj)
  return O
 
0.33666666666666667, 75.47546, def fcfdiefhgegheecbbcefdejjeffdhgae(I):
  objs = objects(I, T, F, T)  # Identify objects
  bg = mostcolor(I)
  target_color = mostcommon([v for row in I for v in row if v != bg])  # Find most frequent non-background color
  O = canvas(bg, shape(I))  # Create blank canvas
  for obj in sorted(objs, key=lambda obj: uppermost(obj), reverse=True):  # Sort objects from top to bottom
    shifted_obj = shift(obj, (-uppermost(obj), 0))  # Shift each object to the top
    for other_obj in objs:
      if color(obj) != color(other_obj) and hmatching(shifted_obj, other_obj):  # Check for horizontal matching with a different colored object
        shifted_obj = shift(shifted_obj, (uppermost(other_obj) - lowermost(shifted_obj) - 1, 0))  # Adjust position to sit on top of the other object
    O = paint(O, recolor(target_color if color(obj) != target_color else color(obj), shifted_obj))  # Paint the object at its new position
  return O
 
0.5133333333333333, 26.315086, def jcdefcbafjieefbhjedihdhjddeaffdc(I):
  def swap_logic(grid):
    objs = objects(grid, True, False, False)
    largest = argmax(objs, size)
    second_largest = argmax({obj for obj in objs if obj != largest}, size)
    bottom_right_color = grid[-1][-1]
    top_right_color = grid[0][-1]
    grid = paint(cover(grid, largest), recolor(bottom_right_color, largest))
    grid = paint(cover(grid, second_largest), recolor(top_right_color, second_largest))
    return grid
  O = swap_logic(I)
  return O 
 
0.42, 19.093119, def dheeacicheejecejjghgijfdffahbgbj(I):
    objs = objects(I, T, F, T)
    bg = mostcolor(I)
    target_color = mostcommon([v for row in I for v in row if v != bg])
    O = I
    for obj in objs:
        for i in range(height(obj)):
            shifted_obj = shift(obj, (-i-1, 0))
            collision = any(hmatching(shifted_obj, other_obj) and color(obj) != color(other_obj) for other_obj in objs)
            if i + 1 == height(I) or collision: 
                O = cover(O, obj)
                O = paint(O, recolor(target_color if color(obj) != target_color else color(obj), shifted_obj))
                break
    return O 
 
0.5433333333333333, 16.530895, def acaecchajhdfeijejecechaejfdeeife(I):
  # Identify objects and their colors
  objs = objects(I, T, F, F)
  colors = apply(color, objs)

  # Create a list to store object sizes
  sizes = list(map(size, objs))

  # Find the indices of the second and third largest objects
  second_idx = sizes.index(sorted(sizes)[-2])
  third_idx = sizes.index(sorted(sizes)[-3])

  # Swap the colors
  colors = list(colors) # Convert to list for modification
  colors[second_idx], colors[third_idx] = colors[third_idx], colors[second_idx] 

  # Paint the objects with the swapped colors
  O = canvas(mostcolor(I), shape(I))
  for obj, col in zip(objs, colors):
    O = paint(O, recolor(col, obj))

  return O
 
0.14, 2.2683756, def bdefdhihccgdecibbhfecggefaecbdib(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj1) > size(obj2) and manhattan(obj1, obj2) == 2:
        I = fill(I, color(obj2), toindices(obj1))
  return I
 
0.24666666666666667, 4.785051, def gchjdjhgdcddebibabaeheghheaabbff(I):
  objs = sorted(objects(I, T, F, T), key=size)
  for i in range(len(objs) - 1):
    for j in range(i + 1, len(objs)):
      if manhattan(objs[i], objs[j]) == 2:
        I = fill(I, color(objs[i]), toindices(objs[j]))
  return I
 
0.19333333333333333, 3.8223011, def iijceefedejheceejhibaeachgecjgae(I):
  objs = objects(I, T, F, T)
  to_fill = set()
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj1) > size(obj2) and manhattan(obj1, obj2) == 2:
        to_fill.add(obj1)
  for obj in to_fill:
    target_color = color(extract(objs, lambda x: manhattan(x, obj) == 2 and size(x) < size(obj)))
    I = fill(I, target_color, toindices(obj))
  return I
 
0.30666666666666664, 47.69656, def abcaeifdfhfcebbbiaifcjdcaiaaeaee(I):
  # 1. Find the second and third largest foreground objects
  objs = order(objects(I, T, F, T), lambda obj: -size(obj))
  second_largest = objs[1]
  third_largest = objs[2]

  # 2. Get their colors
  second_color = color(second_largest)
  third_color = color(third_largest)

  # 3. Swap the colors of these objects on the input grid
  O = paint(replace(I, second_color, -1), recolor(third_color, second_largest))
  O = paint(replace(O, third_color, -1), recolor(second_color, third_largest))
  O = replace(O, -1, mostcolor(I))
  return O
 
0.32666666666666666, 6.8361864, def acdeeacdeiahefabbbbifbgjdhbdejij(I):
    # 1.  Identify and extract the second and third largest objects
    objs = order(objects(I, T, F, T), size)
    second_largest_obj = objs[1]
    third_largest_obj = objs[2]

    # 2.  Get the colors of these objects
    second_largest_color = color(second_largest_obj)
    third_largest_color = color(third_largest_obj)

    # 3.  Define a function to recolor objects based on their size
    def recolor_obj(obj):
      if obj == second_largest_obj: return recolor(third_largest_color, obj)
      if obj == third_largest_obj: return recolor(second_largest_color, obj)
      return obj
    
    # 4. Apply the recolor function to each object and paint onto the canvas
    O = paint(canvas(mostcolor(I), shape(I)), merge(apply(recolor_obj, objs)))
    return O
 
0.4000000000000001, 10.796062, def gcfabdgdejddecdeiceafifcdibeeedc(I):
  objs = objects(I, T, T, T)
  
  obj1 = argmax(objs, size)
  remaining_objs = difference(objs, {obj1})
  obj2 = argmax(remaining_objs, size)
  obj3 = first(difference(remaining_objs, {obj2}))
  
  target_obj = obj1 

  offset1 = (-1, 0) 
  offset2 = (3 * sign(uppermost(obj2) - uppermost(target_obj)), 0) 
  offset3 = (2 * sign(lowermost(target_obj) - uppermost(obj3)), 0) 

  I = paint(cover(I, obj1), shift(recolor(color(obj1), obj1), offset1))
  I = paint(cover(I, obj2), shift(recolor(color(obj2), obj2), offset2))
  I = paint(cover(I, obj3), shift(recolor(color(obj3), obj3), offset3))
  
  return I
 
0.37999999999999995, 9.446661, def afjgicbfjfbfeddfaeaafccadbdccebf(I):
  objs = objects(I, True, True, True)
  
  obj1 = argmax(objs, lambda obj: uppermost(obj))
  obj2 = argmin(objs, lambda obj: uppermost(obj))
  obj3 = extract(difference(objs, {obj1, obj2}), lambda obj: True)
  
  I = paint(cover(I, obj1), shift(obj1, (-1, 0)))
  I = paint(cover(I, obj2), shift(obj2, (3, 0)))
  I = paint(cover(I, obj3), shift(obj3, (sign(lowermost(obj1) - uppermost(obj3)), 0)))
  return I
 
0.22, 6.118821, def djegdfcjdeabejagiccfhabjbcjcfajj(I):
  # 1. Partition the grid into objects, excluding the background
  objs = fgpartition(I)

  # 2. Find the second and third largest objects by their sizes
  second_largest = argmax(objs, lambda obj: size(obj) if size(obj) != size(argmax(objs, size)) else 0)
  third_largest = argmax(objs, lambda obj: size(obj) if (size(obj) != size(argmax(objs, size)) and size(obj) != size(second_largest)) else 0)

  # 3. Switch the colors of the second and third largest objects
  O = switch(I, color(second_largest), color(third_largest))
  return O
 
0.32, 7.8856096, def agciaccacgjgeddhaeacgeacadjfeefd(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj1) < size(obj2) and manhattan(obj1, obj2) == 2:
        I = fill(I, color(obj2), toindices(obj1))
  return I
 
0.19999999999999998, 3.9703236, def gejhjfebbafgefgajfaafcecfaedbbbc(I):
  def find_and_recolor(obj, objs):
    neighbors = sfilter(objs, lambda x: color(x) != color(obj) and manhattan(x, obj) == 2)
    if neighbors:
      target = argmax(neighbors, size) 
      return fill(I, color(target), toindices(obj))
    return I
  objs = objects(I, T, F, T)
  return last(apply(lambda obj: find_and_recolor(obj, objs), objs)) 
 
0.22333333333333336, 4.714613, def ahaidcaaecadejdbjgbfagcbbbeejchf(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2):
        I = paint(cover(I, obj1), recolor(color(obj2), obj1))
        I = paint(cover(I, obj2), recolor(color(obj1), obj2))
        break
    else:
      continue
    break
  return I
 
0.35666666666666663, 8.922883, def ahfbhfbegjdeedbfjbibfcihegfhdahe(I):
  objs = sorted(objects(I, T, T, T), key=lambda obj: colorcount(I, color(obj)))
  obj1, obj2, obj3 = objs[-1], objs[0], objs[1] if len(objs) > 2 else objs[0]

  I = move(I, obj1, UP)
  I = move(I, obj2, (THREE * sign(uppermost(obj2) - uppermost(obj1)), 0))
  I = move(I, obj3, (TWO * sign(lowermost(obj1) - uppermost(obj3)), 0))
  
  return replace(I, color(obj2), color(obj1))
 
0.4166666666666667, 11.318776, def diahfbibgeejeebiacbfefaadhfdajhj(I):
  objs = objects(I, T, T, T)
  obj1 = max(objs, key=lambda obj: len(obj))
  obj2 = min(objs, key=lambda obj: len(obj))
  obj3 = first(difference(objs, {obj1, obj2}))

  I = paint(cover(I, obj1), shift(obj1, UP))
  I = paint(cover(I, obj2), shift(obj2, (THREE * sign(uppermost(obj2) - uppermost(obj1)), 0)))
  I = paint(cover(I, obj3), shift(obj3, (TWO * sign(lowermost(obj1) - uppermost(obj3)), 0)))

  return replace(I, color(obj2), color(obj1))
 
0.2733333333333333, 7.502054, def cedhbebebaagefijbcjdaehagacfhbag(I):
  objs = objects(I, T, T, T)
  
  def get_object_by_frequency(rank):
    sorted_objs = sorted(objs, key=lambda obj: colorcount(I, color(obj)))
    return sorted_objs[rank]

  obj1 = get_object_by_frequency(-1)  # Most frequent
  obj2 = get_object_by_frequency(0)   # Least frequent
  obj3 = get_object_by_frequency(1 if len(objs) > 2 else 0)

  I = paint(cover(I, obj1), shift(obj1, UP))
  I = paint(cover(I, obj2), shift(obj2, (THREE * sign(uppermost(obj2) - uppermost(obj1)), 0)))
  I = paint(cover(I, obj3), shift(obj3, (TWO * sign(lowermost(obj1) - uppermost(obj3)), 0)))

  return switch(I, color(obj1), color(obj2))
 
0.32666666666666666, 6.6893263, def fcfbcbddhccbeabebbdbgeaaegfhhbef(I):
  # 1. Identify and sort objects by size
  objs = order(fgpartition(I), lambda obj: -size(obj))
  
  # 2. Extract second and third largest
  second_largest, third_largest = objs[1], objs[2]

  # 3. Recolor the grid directly
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if contained((val, (i, j)), second_largest):
        O = fill(O, color(third_largest), {(i, j)})
      elif contained((val, (i, j)), third_largest):
        O = fill(O, color(second_largest), {(i, j)})
  return O
 
0.20666666666666667, 4.93011, def igacceigcahfecffabaejfeafjcgbhfb(I):
  # 1. Find unique colors in the grid, excluding background
  colors = sorted(palette(I) - {mostcommon(I)})
  
  # 2. Determine the second and third most frequent colors
  second_color = colors[-2] 
  third_color = colors[-3]

  # 3. Create a recoloring function 
  recolor_func = lambda v: third_color if v == second_color else (second_color if v == third_color else v)
  
  # 4. Apply the function to each cell in the grid
  O = tuple(tuple(recolor_func(v) for v in row) for row in I)
  return O
 
0.30666666666666664, 6.75478, def ffdbiddbjgcdeadfjagbbcdecciaajfh(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj1) < size(obj2) and manhattan(obj1, obj2) == 1 and uppermost(obj2) - lowermost(obj1) == 1:
        I = paint(cover(I, obj1), recolor(color(obj2), obj1))
        I = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return I
 
0.32, 7.8856096, def fehffdbfeigceafcjafdejjcciafeggg(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) == 2:
        if size(obj1) < size(obj2):
          I = fill(I, color(obj2), toindices(obj1))
        else:
          I = fill(I, color(obj1), toindices(obj2))
  return I
 
0.15333333333333335, 2.642932, def ejjfgacbeadaecfdbfeiafddfeebfafb(I):
  objs = objects(I, T, F, T)
  smaller_objs = sorted(objs, key=size)
  for obj1 in smaller_objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and manhattan(obj1, obj2) == 2:
        I = fill(I, color(obj2), toindices(obj1))
        break
  return I
 
0.33666666666666667, 8.11757, def fccdbigbdhhhegagaibdfegcbbafbhcc(I):
  def find_closest_larger_neighbor(obj, objs):
    valid_neighbors = sfilter(objs, lambda x: color(x) != color(obj) and size(x) > size(obj))
    closest_neighbor = argmin(valid_neighbors, lambda x: manhattan(x, obj))
    return color(closest_neighbor) if closest_neighbor else color(obj)

  objs = objects(I, T, F, T)
  return paint(I, frozenset((find_closest_larger_neighbor(obj, objs), idx) for obj in objs for idx in toindices(obj)))
 
0.30666666666666664, 6.75478, def ibcjhheecfcdecaebdghjacibdcadafe(I):
  def recolor_if_smaller_neighbor_exists(obj, objs):
    neighbors = sfilter(objs, lambda x: color(x) != color(obj) and manhattan(x, obj) <= 2)
    if any(size(n) > size(obj) for n in neighbors):
      largest_neighbor = argmax(neighbors, size)
      return fill(I, color(largest_neighbor), toindices(obj))
    return I
  objs = objects(I, T, F, T)
  return last(apply(lambda obj: recolor_if_smaller_neighbor_exists(obj, objs), objs))
 
0.19999999999999998, 3.9950688, def gafeideehdjbeffaaiececcgcgcdcfdh(I):
  objs = objects(I, T, F, T) # Extract objects, excluding background
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2): # Check for criteria
        I = paint(I, recolor(color(obj2), obj1)) # Swap color of obj1 with obj2
        I = paint(I, recolor(color(obj1), obj2)) # Swap color of obj2 with obj1
  return I
 
0.26333333333333336, 52.218384, def efdcacccfidaebgbbdbejfcaihdbdbfj(I):
  def find_and_swap(obj, objs):
    for other in objs:
      if obj != other and vmatching(obj, other) and position(obj, other) == (1, 0) and height(obj) < height(other):
        return recolor(color(other), obj), recolor(color(obj), other)
    return obj, None

  objs = objects(I, T, F, T)
  new_objs = [find_and_swap(obj, objs) for obj in objs]

  for old_obj, new_obj in new_objs:
    I = cover(I, old_obj)
    if new_obj is not None:
      I = paint(I, new_obj)

  return I
 
0.30666666666666664, 6.75478, def ecceefcbecaeeabhijchjfaebiebchfa(I):
  for i in range(len(I) - 2, -1, -1):
    for j in range(len(I[0])):
      if I[i][j] != 0 and I[i+1][j] != 0:
        I = fill(I, I[i+1][j], {(i, j)})
  return I
 
0.32, 7.8856096, def dacfcbdcjeabeehfibeeecajdbcgjifa(grid):
  def recolor_if_neighbor(obj, all_objs):
    for other in all_objs:
      if color(other) != color(obj) and manhattan(obj, other) == 2 and size(other) > size(obj):
        return fill(grid, color(other), toindices(obj))
    return grid
  all_objs = objects(grid, T, F, T)
  for obj in all_objs:
    grid = recolor_if_neighbor(obj, all_objs)
  return grid
 
0.27999999999999997, 6.871814, def ejhbdbccjbheejheabcgfddbbdcdefea(grid):
  def recolor_by_distance(obj, objs):
    neighbors_at_2 = sfilter(objs, lambda x: manhattan(obj, x) == 2)
    if neighbors_at_2:
      largest_neighbor = argmax(neighbors_at_2, size)
      if color(largest_neighbor) != color(obj):
        return fill(grid, color(largest_neighbor), toindices(obj))
    return grid

  all_objs = objects(grid, T, F, T)
  for i in range(len(all_objs)):
    for obj in all_objs:
      grid = recolor_by_distance(obj, all_objs)
  return grid
 
0.32, 3.6673326, def gidfaaedddbaehbhjjiccgbjdbheiadi(I):
    objs = objects(I, T, F, T)  
    for obj1 in objs:
        for obj2 in objs:
          if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2):
            c1 = color(obj1)
            c2 = color(obj2)
            obj1_new = recolor(c2, extract(objs, matcher(color, c1)))
            obj2_new = recolor(c1, extract(objs, matcher(color, c2)))
            I = paint(I, obj1_new)
            I = paint(I, obj2_new)
    return I
 
0.22666666666666668, 5.5023556, def fbdadifabgfdefdhbgieaaahbbaadfch(I):
    objs = objects(I, T, F, T) 
    for obj1 in objs:
        for obj2 in objs:
          if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2):
            I = replace(I, color(obj1), 999) # Temporary color
            I = replace(I, color(obj2), color(obj1))
            I = replace(I, 999, color(obj2))
    return I
 
0.25333333333333335, 3.0819023, def baiabafddiacehbjiaibbajdfbcjiide(I):
  objs = objects(I, T, F, T)
  five_obj = extract(objs, lambda x: color(x) == 5)
  I = paint(I, recolor(6, five_obj))
  for obj in objs:
    if uppermost(obj) == lowermost(five_obj) + 1 and hmatching(five_obj, obj):
      I = paint(I, recolor(color(five_obj), obj))
  return I
 
0.2933333333333333, 5.6823273, def afbdbiabdcicejbfjgccdabeaghgecff(I):
  five_indices = ofcolor(I, 5)
  I = fill(I, 6, five_indices)
  for i, j in five_indices:
    if i < len(I) - 1:
      for dj in range(leftmost(five_indices), rightmost(five_indices) + 1):
        if I[i+1][dj] != 0:
          I = fill(I, 5, {(i+1, dj)})
  return I
 
0.22333333333333336, 5.608267, def fhhgcbgfaahdebgjjgafffcaefjabfei(I):
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 5:
        I = fill(I, 6, {(i, j)})
        if i < len(I) - 1:
          for dj in range(len(row)):
            if I[i+1][dj] != 0 and I[i+1][dj] != 6:
              I = fill(I, 5, {(i+1, dj)})
  return I
 
0.25666666666666665, 5.0201907, def fiaffcecdicgebbgiedbhefecdcahfbd(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: (uppermost(obj), size(obj)))
  for i in range(len(sorted_objs)-1):
    obj1 = sorted_objs[i]
    obj2 = sorted_objs[i+1]
    if color(obj1) != color(obj2) and size(obj1) < size(obj2) and vmatching(obj1, obj2):
      I = paint(paint(cover(I, obj1), recolor(color(obj2), obj1)), recolor(color(obj1), obj2))
      break  
  return I
 
0.31666666666666665, 6.931921, def dfbaagafacjhegbdbadceaccdfbafgbf(I):
  # 1. Find the second and least common colors 
  colors = sorted(palette(I) - {mostcommon(I)}, key=lambda c: colorcount(I, c))
  second_color = colors[1]
  least_color = colors[0]
  
  # 2. Recolor based on object positions
  O = I
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == second_color:
        O = fill(O, least_color, {(i, j)})
      elif any(I[k][j] == second_color for k in range(i) if 0 <= k < len(I)):
        if v == mostcommon(I):
          O = fill(O, second_color, {(i, j)})
  return O
 
0.21333333333333335, 5.5312195, def hddjcfabheabebcbjccgbhbidbdffdbh(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj1) < size(obj2) and (vmatching(obj1, shift(obj2, (1, 0))) or vmatching(obj1, shift(obj2, (-1, 0)))):
        smaller_color = color(obj1)
        larger_color = color(obj2)
        I = replace(I, smaller_color, larger_color)
        I = replace(I, larger_color, smaller_color)
        return I  # Only swap one pair
  return I
 
0.15333333333333335, 2.642932, def cicegaffehdiebefiicjabigdffdiheb(I):
  def recolor_object(obj, all_objs):
    neighbors = sorted(sfilter(all_objs, lambda x: manhattan(x, obj) == 2 and color(x) != color(obj)), key=size, reverse=True)
    return recolor(color(neighbors[0]), obj) if neighbors else obj
  return paint(I, merge(apply(lambda obj: recolor_object(obj, objects(I, T, F, T)), objects(I, T, F, T))))
 
0.2366666666666667, 4.4030485, def diebabbdebcdedicjcfcdfbbbcccffhf(I):
  objs = objects(I, T, F, T)
  for i in range(height(I) - 1):
    for j in range(width(I)):
      if index(I, (i, j)) != mostcolor(I):
        current_obj = extract(objs, lambda obj: contained((i, j), toindices(obj)))
        try:
          matching_obj = extract(objs, lambda obj2: current_obj != obj2 and vmatching(current_obj, obj2) and position(current_obj, obj2) == (1, 0) and height(current_obj) < height(obj2))
          I = paint(cover(I, current_obj), recolor(color(matching_obj), current_obj)) 
          I = paint(cover(I, matching_obj), recolor(color(current_obj), matching_obj))
          break  # Move to the next row after a swap
        except StopIteration:
          continue
  return I
 
0.15333333333333335, 2.642932, def cegcafdbfdjdeihabcbcfebdjhbbaeec(I):
  def swap_if_valid(obj1, obj2):
    if color(obj1) != color(obj2) and size(obj2) > size(obj1) and any(manhattan(obj1, shift(obj2, (dy, 0))) == 1 for dy in (-1, 1)):
      return paint(paint(I, recolor(color(obj2), obj1)), recolor(color(obj1), obj2))
    return I

  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      I = swap_if_valid(obj1, obj2) 
  return I
 
0.6, 18.651178, def fchjeccaffgaedafbeffafjhfebhccce(I):
  def recolor_cell(i, j, grid, objs):
    if grid[i][j] == mostcommon(grid):
      return grid[i][j]
    obj = toobject(initset((i, j)), grid)
    neighbors = sfilter(objs, lambda x: manhattan(x, obj) == 2 and size(x) > size(obj) and color(x) != color(obj))
    return color(argmax(neighbors, size)) if neighbors else grid[i][j]
  objs = objects(I, T, F, T)
  return tuple(tuple(recolor_cell(i, j, I, objs) for j in range(width(I))) for i in range(height(I)))
 
0.24333333333333332, 5.047358, def fiafbccafefaeccbafabbgdfecdacdhc(I):
  objs = objects(I, T, F, T)
  swapped = False
  new_grid = canvas(mostcolor(I), shape(I)) # Initialize with background color
  for obj1 in objs:
    if swapped: 
      new_grid = paint(new_grid, obj1)
      continue
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2):
        new_grid = paint(new_grid, recolor(color(obj2), obj1))
        new_grid = paint(new_grid, recolor(color(obj1), obj2))
        swapped = True
        break
    if not swapped:
      new_grid = paint(new_grid, obj1)
  return new_grid
 
0.33666666666666667, 8.11757, def hebjbbbbdcfaefddbababeddabjbfgeb(I):
  objs = objects(I, T, F, T)  # Extract objects
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and (vmatching(obj1, obj2) or hmatching(obj1, obj2)) and size(obj1) < size(obj2):
        I = paint(cover(I, obj1), recolor(color(obj2), obj1))
  return I
 
0.24333333333333332, 5.522797, def jfdcjbdadbiieeejidbcfcfccgedffgb(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    adjacent_objs = sfilter(objs, lambda obj2: obj1 != obj2 and (vmatching(obj1, obj2) or hmatching(obj1, obj2)))
    larger_obj = argmax(adjacent_objs, lambda obj: size(obj)) if adjacent_objs else None
    if larger_obj and size(obj1) < size(larger_obj):
      I = switch(I, color(obj1), color(larger_obj))
  return I
 
0.26666666666666666, 5.236983, def gefcibiajaejedihiibbeddcdffabchc(I):
    def swap_if_valid(grid, obj1, obj2):
        return paint(paint(cover(grid, obj1), recolor(color(obj2), obj1)), recolor(color(obj1), obj2)) if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0) and height(obj1) < height(obj2) else grid

    objs = objects(I, T, F, T)
    new_grid = I
    for i, obj1 in enumerate(objs):
        for obj2 in tuple(objs)[i+1:]:
            new_grid = swap_if_valid(new_grid, obj1, obj2)
    return new_grid
 
0.32, 7.8856096, def abfhbhfddcdfeiccaabacfjceabfcgbe(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2) and size(obj2) > size(obj1) and any(adjacent(obj1, shift(obj2, (dx, dy))) for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0))):
        I = paint(I, recolor(color(obj2), obj1))
        break
  return I
 
0.22666666666666668, 5.0680766, def chdcbcaaebdbedacicdedbdfbhaaajgf(I):
  def swap_colors(obj1, obj2):
    return paint(paint(I, recolor(color(obj2), obj1)), recolor(color(obj1), obj2))

  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        I = swap_colors(obj1, obj2)
  return I
 
0.22666666666666668, 5.0580535, def hgajcjeeiaeiejfdaiaeebjicfbefjde(I):
  def swap_if_size_condition(obj1, obj2):
    if size(obj1) > size(obj2):
      return paint(paint(I, recolor(color(obj2), obj1)), recolor(color(obj1), obj2))
    return I

  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) != color(obj2):
        I = swap_if_size_condition(obj1, obj2)
  return I
 
0.17, 2.8705459, def bffaeabgaaebebeababddfiedbeceaif(I):
  def process_object(obj, all_objs):
    larger_neighbor = argmax(all_objs, lambda other: size(other) if (manhattan(obj, other) == 2 and color(obj) != color(other)) else -1) 
    return recolor(color(larger_neighbor), obj) if larger_neighbor else obj
  objs = objects(I, T, F, T)
  return paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: process_object(obj, objs), objs)))
 
0.32, 6.9741845, def bdgddecdhbddecfebcedfebibacgabec(I):
  objs = objects(I, T, F, T) # Extract objects, excluding background
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (1, 0): # Check for vertical matching and relative position
        if size(obj1) < size(obj2): #Identify smaller object
          I = paint(I, recolor(color(obj2), obj1)) # Replace color of smaller object with larger
  return I 
 
0.30666666666666664, 6.75478, def igcejgjfbigcedjbafbfdaehfadjccah(I):
  objs = sorted(objects(I, T, F, T), key=lambda obj: (centerofmass(obj)[0], -size(obj))) # Sort objects by vertical position and size
  for i in range(len(objs) - 1):
    if vmatching(objs[i], objs[i + 1]) and position(objs[i], objs[i + 1]) == (1, 0):
      I = paint(I, recolor(color(objs[i + 1]), objs[i]))
  return I
 
0.1366666666666667, 2.8658433, def dfebebfcedjaefehbchbdfhacdddbfcb(I):
  objs = objects(I, T, F, T) 
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2)[0] == -1:
        I = paint(cover(I, obj1), recolor(color(obj2), obj1))
        I = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return I
 
0.08333333333333333, 1.9659501, def ebbaigbbjhgeecbfifbfecchajafdejb(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2):
        rel_pos = position(obj1, obj2)[0]
        if rel_pos == 1 or rel_pos == -1:
          I = paint(cover(I, obj1), recolor(color(obj2), obj1))
          I = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return I
 
0.30666666666666664, 6.6769004, def baaeidaeaajheechiecchedfjjciefaf(I):
  h, w = len(I), len(I[0])
  output = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        target_color = None
        for di in range(-2, 3):
          for dj in range(-2, 3):
            ni, nj = i + di, j + dj
            if 0 <= ni < h and 0 <= nj < w and abs(di) + abs(dj) == 2 and I[ni][nj] != I[i][j]:
              target_color = I[ni][nj]
              break  # Found a target, no need to search further
          if target_color:  
            break
        output = fill(output, target_color if target_color else I[i][j], {(i, j)})
  return output
 
0.20666666666666667, 3.3584332, def efcbcfcdjbafeegajgibghacfbfcfhfc(I):
  objs = objects(I, T, F, T)
  def swap_colors(obj1, obj2):
    return paint(paint(cover(I, obj1), recolor(color(obj2), obj1)), recolor(color(obj1), obj2))
  
  for i, obj1 in enumerate(objs):
    for j in range(i+1, len(objs)):
      obj2 = list(objs)[j] 
      if vmatching(obj1, obj2) and any(manhattan(obj1, shift(obj2, (dy, 0))) == 1 for dy in (-1, 1)):
        I = swap_colors(obj1, obj2)
  return I
 
0.3133333333333333, 7.2706413, def feaebbaeedfhefcejfiebdjdbdafaaac(I):
  def recolor_second_largest(objs):
    target = order(objs, size)[1] 
    neighbors = sfilter(objs, lambda x: color(x) != color(target) and manhattan(x, target) == 2)
    if neighbors:
      source = argmax(neighbors, size)
      return recolor(color(source), target)
    return target
  objs = objects(I, T, F, T)
  return paint(I, merge((*remove(recolor_second_largest(objs), objs), recolor_second_largest(objs))))
 
0.20333333333333334, 2.4133391, def jdjibeheceegefefageefgaddadcecaj(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and size(obj1) < size(obj2):
        I = switch(I, color(obj1), color(obj2))
  return I
 
0.27, 5.4819336, def efgjjebafdceedecjcaddcihccaaaafb(I):
  objs = objects(I, T, F, T)
  pairs = {(color(obj1), color(obj2)) for obj1 in objs for obj2 in objs 
           if obj1 != obj2 and vmatching(obj1, obj2) and size(obj1) < size(obj2)}
  for a, b in pairs:
    I = replace(I, a, b)  
  return I
 
0.3133333333333333, 6.314875, def aifdfehbcdeeebedbhfdcebaeahfagje(I):
  objs = objects(I, T, F, T) 
  target_color = 5
  for obj1 in objs:
    if color(obj1) == target_color:
      for obj2 in objs:
        if color(obj2) != target_color:
          I = paint(cover(I, obj1), recolor(color(obj2), obj1))
          I = paint(cover(I, obj2), recolor(target_color, obj2))
          return I  
  return I
 
0.32, 32.787827, def fhefghgededjeebhidafahagaahdfjcd(I):
  objs = objects(I, T, F, T)
  color_to_swap = leastcolor(I) if mostcolor(I) == 5 else mostcolor(I) 
  for obj in objs:
    if color(obj) == 5:
      I = paint(I, recolor(color_to_swap, obj))
    elif color(obj) == color_to_swap:
      I = paint(I, recolor(5, obj))
  return I
 
0.32, 3.6673324, def dihaffbbadaeeijfaiehacfdbedeibbd(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    if color(obj1) == 5:
      for obj2 in objs:
        if color(obj2) != 5 and any(manhattan({ind}, obj2) <= 1 for ind in toindices(obj1)):
          I = paint(cover(I, obj1), recolor(color(obj2), obj1))
          I = paint(cover(I, obj2), recolor(5, obj2))
          return I 
  return I
 
0.23, 3.5286126, def efdgdebgaeaaeihajhbeacagdgabhdjd(I):
  # 1. Partition the grid into objects based on color
  objs = partition(I)

  # 2. Find the second and third largest objects (excluding background)
  sorted_objs = sorted(objs, key=size)
  second_largest = sorted_objs[-2] if len(sorted_objs) > 1 else sorted_objs[0]
  third_largest = sorted_objs[-3] if len(sorted_objs) > 2 else sorted_objs[0]

  # 3. Swap the colors of these objects
  O = paint(paint(I, recolor(color(third_largest), second_largest)), recolor(color(second_largest), third_largest))
  return O
 
0.23, 3.5706615, def fjggjebfiajaeeahiffjfhdagdaajhea(I):
  def find_and_swap(obj):
    for other_obj in objects(I, T, F, T):
      if color(obj) != color(other_obj) and vmatching(obj, other_obj) and any(manhattan(obj, shift(other_obj, (dy, 0))) == 1 for dy in (-1, 1)):
        return recolor(color(other_obj), obj)
    return obj

  return paint(I, merge(apply(find_and_swap, objects(I, T, F, T))))
 
0.22666666666666668, 2.5044088, def faejgcdgbbfaeiccabiecfaefhcfccdc(I):
  objs = order(objects(I, T, F, T), size)
  recolor_map = {obj: i + 1 for i, obj in enumerate(objs)}
  new_objs = frozenset({(recolor_map[obj], idx) for obj in objs for val, idx in obj})
  O = paint(I, new_objs)
  return O
 
0.33, 3.0754066, def fbhddaajebiceecbicfcfeeaaebahahc(I):
  objs = objects(I, T, F, T)
  sizes = sorted({size(obj) for obj in objs})
  recolor_map = {s: i + 1 for i, s in enumerate(sizes)}
  new_objs = frozenset({(recolor_map[size(obj)], idx) for obj in objs for val, idx in obj})
  O = paint(I, new_objs)
  return O
 
0.32, 3.050471, def bdeecebaffgfeefcaebdefdhbheedeeg(I):
    O = I
    for i, s in enumerate(sorted({size(obj) for obj in objects(I, T, F, T)})):
        O = paint(O, recolor(i + 1, toindices(extract(objects(O, T, F, T), lambda x: size(x) == s))))
    return O
 
0.3066666666666667, 24.75742, def ceihcfidbcbhebbibdfbgfegeheecjdc(I):
  def swap_colors(grid, color1, color2):
    return replace(replace(grid, color1, -1), color2, color1)
  I = swap_colors(I, 5, 2) 
  I = swap_colors(I, 1, 7) 
  return I
 
0.27, 4.2506986, def eecejefhciaaebdiidfbjbhgaecjggbg(I):
  color_mapping = {5: 2, 1: 7, 7: 1}  
  return tuple(tuple(color_mapping.get(v, v) for v in row) for row in I)
 
0.29, 4.725576, def efcjdfhffbaeeebbicjjcfbafgefbaeb(I):
  def conditional_swap(grid, condition, color1, color2):
    return tuple(tuple(color2 if condition(i,j) else color1 if v == color1 else v for j, v in enumerate(row)) for i, row in enumerate(grid))
  I = conditional_swap(I, lambda i, j: I[i][j] == 5, 5, 2)
  I = conditional_swap(I, lambda i, j: I[i][j] == 1, 1, 7)
  return I
 
0.24666666666666667, 3.2355888, def afhfbgegfaeiecjgbgcbbadgchgabcja(I):
  for v in palette(I):
    if v != 0 and v != 5:
      I = switch(I, 5, v)
  return I
 
0.33, 3.7180119, def ebbebjdacgghedaiaefgeaaffhddbach(I):
  objs = objects(I, T, F, T)
  five_obj = argmax(objs, lambda obj: color(obj) == 5)
  other_color = argmax(palette(I) - {0, 5}, lambda c: True)
  other_obj = argmax(objs, lambda obj: color(obj) == other_color)
  return paint(paint(cover(I, five_obj), recolor(other_color, five_obj)), recolor(5, other_obj))
 
0.22333333333333336, 3.0954292, def habfciadecegeafaaaciedgbbacfbedd(I):
  # 1. Get object partitions excluding background
  objs = fgpartition(I) 
  
  # 2. Sort objects based on size (proxy for frequency)
  sorted_objs = order(objs, size)
  
  # 3. Extract the second and third most frequent objects
  second_obj = sorted_objs[-2]
  third_obj = sorted_objs[-3]
  
  # 4. Swap colors of the two objects
  O = paint(paint(I, recolor(color(third_obj), second_obj)), recolor(color(second_obj), third_obj))
  return O
 
0.3233333333333333, 5.2223797, def bacdigacfdebecahafhdhgdcfaadjhjj(I):
  def vertical_swap(obj1, obj2):
    if size(obj1) < size(obj2) and uppermost(obj1) < uppermost(obj2):
      return paint(paint(I, recolor(color(obj2), obj1)), recolor(color(obj1), obj2))
    return I

  objs = objects(I, T, F, T)
  for i in range(len(objs)):
    for j in range(i+1, len(objs)):
      I = vertical_swap(list(objs)[i], list(objs)[j])
  return I
 
0.2966666666666667, 3.4630184, def jbeeeigeejejehdaicifaccjhfgjdieb(I):
  objs = objects(I, T, F, T) # Get all objects except background
  objs_by_size = order(objs, size) # Sort objects based on size
  second_largest = objs_by_size[-2] # Get the second largest object
  third_largest = objs_by_size[-3] # Get the third largest object
  second_color = color(second_largest) # Get the color of the second largest
  third_color = color(third_largest) # Get the color of the third largest
  O = switch(I, second_color, third_color) # Swap the colors
  return O
 
0.23, 3.5286126, def biheiaabegcaeebcabjefhicdbfifdch(I):
  objs = objects(I, T, F, T)
  size_counts = {} 
  for obj in objs:
    s = size(obj)
    if s not in size_counts:
      size_counts[s] = 0
    size_counts[s] += 1
  sorted_sizes = sorted(size_counts.items(), key=lambda item: item[0])
  second_largest = next((s for s, c in reversed(sorted_sizes) if c > 0), None)
  third_largest = next((s for s, c in reversed(sorted_sizes) if c > 0 and s != second_largest), None)
  second_color = color(next((obj for obj in objs if size(obj) == second_largest), None))
  third_color = color(next((obj for obj in objs if size(obj) == third_largest), None))
  O = switch(I, second_color, third_color)
  return O
 
0.22666666666666668, 2.9624925, def ghddbeeccfdfeacabdbgcdaicdbajcjg(I):
  def recolor_by_rank(grid):
    objs = objects(grid, T, F, T)
    size_ranking = {s: i + 1 for i, (s, c) in enumerate(sorted(((size(obj), color(obj)) for obj in objs), key=lambda x: x[0]))}
    return paint(grid, {(size_ranking[size(obj)], idx) for obj in objs for val, idx in obj})
  return recolor_by_rank(I)
 
0.2333333333333333, 3.6770515, def hcjciachiccjedjcichcidjjiggeiijf(I):
  def swap_if_above(I, color1, color2):
    objs = objects(I, T, F, T)
    for obj1 in objs:
      if color(obj1) == color1:
        for obj2 in objs:
          if color(obj2) == color2 and vmatching(obj1, obj2) and position(obj1, obj2)[0] == -1:
            return switch(I, color1, color2)
    return I
  I = swap_if_above(I, 5, 2)
  I = swap_if_above(I, 1, 7)
  I = swap_if_above(I, 4, 1)
  return I
 
0.3, 3.9254467, def eeccdacgcbeaejaibafcbiaedbfbgcfd(I):
  objs = sorted(objects(I, univalued=True, diagonal=False, without_bg=True), key=size)
  target_objs = objs[-3:-1] if len(objs) > 2 else objs[-2:]
  O = I
  for i in range(len(target_objs) - 1):
    O = paint(paint(O, recolor(color(target_objs[i + 1]), target_objs[i])), recolor(color(target_objs[i]), target_objs[i + 1]))
  return O
 
0.9833333333333334, 6.1790648, def hfdegbefddaieajfbbabfddiebggacdc(I):
  objs = list(filter(lambda x: len(x) > 1, partition(I)))
  if len(objs) < 2: return I
  objs.sort(key=size)
  a, b = objs[-2], objs[-1]
  return paint(paint(I, recolor(color(a), b)), recolor(color(b), a))
 
0.2966666666666667, 3.4630184, def adaedbiijdaeeeaeabjcbffccfefgcgc(I):
  p = palette(I) - {mostcommon(I)}
  if len(p) < 3: return I
  objs = sorted(objects(I, True, False, True), key=size)
  ca = color(objs[-2])
  cb = color(objs[-3])
  return tuple(tuple(cb if v == ca else (ca if v == cb else v) for v in row) for row in I)
 
0.31666666666666665, 4.138286, def haffcdedbhjcebbfaccjdebdjffgdjeb(grid):
  def swap_first_two(objs):
    if len(objs) >= 2:
      obj1, obj2, *rest = objs
      return [recolor(color(obj2), obj1), recolor(color(obj1), obj2)] + rest
    else:
      return objs

  return paint(grid, merge(swap_first_two(list(objects(grid, T, F, T)))))
 
0.2466666666666667, 4.264876, def eaadieadegbfegadaeigcbafiebedfjc(I):
  def find_and_swap(obj, others):
    for other_obj in others:
      if color(obj) != color(other_obj):
        return recolor(color(other_obj), obj)
    return obj

  objs = list(objects(I, T, F, T))
  new_objs = [find_and_swap(obj, objs[:i] + objs[i+1:]) for i, obj in enumerate(objs)]
  return paint(I, merge(new_objs))
 
0.31666666666666665, 6.408006, def ebaefbgacaaiebcbafdeacchaddbabdb(grid):
  def process_objects(objs):
    for i in range(len(objs) - 1):
      obj1, obj2 = objs[i], objs[i+1]
      if color(obj1) != color(obj2):
        return [recolor(color(obj2), obj1), recolor(color(obj1), obj2)] + objs[i+2:]
    return objs

  return paint(grid, merge(process_objects(list(objects(grid, T, F, T)))))
 
0.32666666666666666, 3.658745, def bbebbhcfcbfgecadjbfcfiajchfbcebi(I):
  objs = order(objects(I, T, F, T), size)  # Get objects and sort by size
  recolor_map = {obj: (i + 1 if i < 2 else color(obj)) for i, obj in enumerate(objs)}  # Map objects to new colors
  new_objs = frozenset({(recolor_map[obj], idx) for obj in objs for val, idx in obj})  # Apply color mapping
  O = paint(I, new_objs)  # Paint new objects onto grid
  return O
 
0.3333333333333333, 4.1033554, def fihfdgfjhcaheaffbjccgjacfffiabfe(I):
    objs = objects(I, T, F, T)
    small_objs = order(sfilter(objs, lambda obj: size(obj) <= 6), size)  # Filter smaller objects
    O = I
    for i, obj in enumerate(small_objs):
        new_color = i + 2
        O = paint(O, recolor(new_color, toindices(obj)))
    return O
 
0.3333333333333333, 3.852573, def ccaebcdabeahecbjacaigdfebfjbgfee(I):
  O = I
  for i in range(1, 3):  # Target the two smallest object sizes
    for obj in sizefilter(objects(I, T, F, T), i):
      new_color = {1: 2, 2: 5}.get(i, color(obj))  # Recolor based on size
      O = paint(O, recolor(new_color, toindices(obj)))
  return O
 
0.32, 3.6673324, def cejaeibiccddejcfaacigejhifggccac(I):
  objs = objects(I, T, F, T)
  for obj1 in objs:
    for obj2 in objs:
      if obj1 != obj2 and vmatching(obj1, obj2) and position(obj1, obj2) == (-1, 0):
        I = switch(I, color(obj1), color(obj2))
        break # Only swap once per obj1
  return I
 
0.32666666666666666, 23.798727, def cgeaehbihiecefdeafbgaibgeibhaebd(I):
  other_color = min(filter(lambda c: c not in [0, 5], palette(I)))  # Find the minimum color other than 0 and 5
  return replace(replace(I, 5, -1), other_color, 5) # Replace 5 with a temporary color, then replace the target color with 5
 
0.32, 3.6673324, def jcbbdcbggedaefjgbfefadficcbcbged(I):
  # 1. Find the second and third largest objects (excluding background).
  objs = partition(I)
  bg_color = mostcommon(I)
  fg_objs = frozenset(obj for obj in objs if color(obj) != bg_color)
  sorted_objs = sorted(fg_objs, key=size)
  second_largest = sorted_objs[-2] if len(sorted_objs) > 1 else sorted_objs[0]
  third_largest = sorted_objs[-3] if len(sorted_objs) > 2 else sorted_objs[0]

  # 2. Create a color mapping function.
  def swap_color(v):
    if (v, None) in second_largest: 
      return color(third_largest)
    elif (v, None) in third_largest: 
      return color(second_largest)
    return v

  # 3. Apply the mapping to each cell in the grid.
  O = tuple(tuple(swap_color(v) for v in row) for row in I)
  return O
 
0.20333333333333334, 3.0305903, def dccbbbccefbaecdfbdcjjddegfbigcdc(grid):
  def get_second_and_third_most_common(grid):
    color_counts = {}
    for row in grid:
      for color in row:
        if color != 0:  # Exclude background
          if color not in color_counts:
            color_counts[color] = 0
          color_counts[color] += 1
    sorted_colors = sorted(color_counts, key=color_counts.get, reverse=True)
    return sorted_colors[1:3] # Return second and third most common
  
  second, third = get_second_and_third_most_common(grid)
  return switch(grid, second, third) 
 
0.2866666666666667, 4.590813, def bcbcfdafedigegabjfjbfecffidiajah(grid):
  def swap_colors_by_size(objs):
    if len(objs) >= 2:
      sorted_objs = sorted(objs, key=size, reverse=True)
      obj1, obj2, *rest = sorted_objs
      return [recolor(color(obj2), obj1), recolor(color(obj1), obj2)] + rest
    else:
      return objs

  filtered_objs = [obj for obj in objects(grid, T, F, T) if color(obj) != mostcommon(grid)]
  return paint(grid, merge(swap_colors_by_size(filtered_objs)))
 
0.25666666666666665, 3.3423972, def dbhadefajbeaebjeaahacijhdgbfbbid(grid):
  def find_and_swap_colors(objs):
    color_counts = {}
    for obj in objs:
      c = color(obj)
      if c not in color_counts:
        color_counts[c] = 0
      color_counts[c] += 1
    sorted_colors = sorted(color_counts, key=color_counts.get, reverse=True)
    if len(sorted_colors) >= 3:
      second, third = sorted_colors[1:3]
      return [(recolor(third if color(obj)==second else (second if color(obj)==third else color(obj)), obj)) for obj in objs]
    else:
      return objs
  
  return paint(grid, merge(find_and_swap_colors(list(objects(grid, T, F, T)))))
 
0.2966666666666667, 3.4630184, def bdeebdfcaheeedbebefbfeddgdacdefj(grid):
  def swap_colors_if_multiple(objs):
    if len(set(color(obj) for obj in objs)) >= 3:
      objs = sorted(objs, key=lambda obj: len(obj), reverse=True)
      c1 = color(objs[1])
      c2 = color(objs[2])
      return [recolor(c2 if color(obj)==c1 else (c1 if color(obj)==c2 else color(obj)), obj) for obj in objs]
    else:
      return objs

  return paint(grid, merge(swap_colors_if_multiple(list(objects(grid, T, F, T)))))
 
0.3, 2.9516919, def decfdifbbgaaebghaehcefeeiceegfcc(I):
  objs = objects(I, T, F, T)  # Extract objects from the input grid
  
  # Determine the new color based on object size
  def new_color(obj): 
    s = size(obj)
    if s == 3: return 6 
    elif s == 4: return 1
    elif s == 6: return 6
    elif s == 9: return 8
    else: return color(obj)  # Keep other colors unchanged

  # Recolor the objects based on their size
  recolored_objs = frozenset({(new_color(obj), idx) for obj in objs for val, idx in obj})  
  O = paint(I, recolored_objs)  # Paint the recolored objects onto the input grid

  # Swap colors 6 and 8 (or 1 and 7, or 4 and 7)
  O = switch(O, 6, 8) 
  return O
 
0.32, 3.1147823, def fdbdifcbfjhdecidjhedaabaajdfjbbe(I):
  O = I
  for a, b in [(6, 8), (1, 7), (4, 7)]:  # Color pairs to swap
    for s in sorted({size(obj) for obj in objects(I, T, F, T)}):
      if s in [3, 4, 6, 9]: # Sizes that need recoloring
        O = paint(O, recolor(b if s == 9 else a, toindices(extract(objects(O, T, F, T), lambda x: size(x) == s))))
  return O 
 
0.29, 3.2655067, def jdgfdgcbcbdcegbjihjhedfbididagaa(I):
  objs = objects(I, T, F, T)
  swap_pairs = [(6, 8), (1, 7), (4, 7)]
  size_map = {3: 6, 4: 1, 6: 6, 9: 8} 
  
  def new_color(obj):
    s = size(obj)
    for a, b in swap_pairs:
      if s == 9: return b
      if s in size_map: return a
    return color(obj) 

  recolored_objs = frozenset({(new_color(obj), idx) for obj in objs for val, idx in obj})
  return paint(I, recolored_objs)
 
0.3066666666666667, 3.2700264, def jbacaejchfhaeajfjiedbddbcjbebefe(I):
  O = I
  for obj in objects(I, T, F, T):
    s = size(obj)
    if s == 3: O = paint(O, recolor(6, toindices(obj)))
    elif s == 4: O = paint(O, recolor(1, toindices(obj)))
    elif s == 6: O = paint(O, recolor(6, toindices(obj)))
    elif s == 9: O = paint(O, recolor(8, toindices(obj)))
  return switch(switch(switch(O, 6, 8), 1, 7), 4, 7)
 
0.29, 3.4523175, def ehcbdhbddeaeeeieaeafeeccdbbhcfhc(I):
  five_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == 5) # Extract object with color 5
  other_color = next(iter(palette(I) - {0, 5})) # Find any color other than 0 and 5
  I = replace(I, 5, other_color) # Replace all occurrences of 5 with 'other_color'
  return paint(I, recolor(5, extract(objects(I, T, F, T), lambda obj: color(obj) == other_color))) # Recolor and paint the object with the swapped color 
 
0.3, 3.1618931, def dcfhbafafadjeaejibicdeejbaehbfaa(I):
  five_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == 5) # Extract object with color 5
  other_color = next(iter(palette(I) - {0, 5})) # Find any color other than 0 and 5
  return paint(
      paint(I, recolor(0, five_obj)), # Temporarily paint 'five_obj' with 0
      recolor(branch(color(five_obj) == 5, other_color, 5), 
              extract(objects(I, T, F, T), lambda obj: color(obj) != 0))) # Conditional recoloring based on initial color
 
0.33, 3.4998436, def iedddchbgbcdececafceaccifijecdbe(I):
  objs = objects(I, T, F, T)
  def new_color(obj):
    s = size(obj)
    if s == 2: return 1
    elif s == 3: return (2 if color(obj) == 5 else  color(obj))
    elif s == 4: return (1 if color(obj) == 4 else 6)
    elif s == 6: return 6
    elif s == 9: return (7 if color(obj) == 5 else 8)
    else: return color(obj)
  recolored_objs = frozenset({(new_color(obj), idx) for obj in objs for val, idx in obj})  
  O = paint(I, recolored_objs)
  O = switch(O, 6, 8) 
  O = switch(O, 4, 7) 
  return O
 
0.27666666666666667, 3.396977, def fbgajabfdbeiecdfbgeafdbfeicebbjh(I):
  def recolor_by_size(grid, size, new_color):
    objs = sizefilter(objects(grid, T, F, T), size)
    return paint(grid, frozenset((new_color, idx) for obj in objs for val, idx in obj))
  O = recolor_by_size(I, 2, 1)
  O = recolor_by_size(O, 3, 2)
  O = recolor_by_size(O, 4, (1 if O[0][0] == 4 else 6))
  O = recolor_by_size(O, 6, 6)
  O = recolor_by_size(O, 9, (7 if O[0][0] == 5 else 8))
  O = switch(O, 6, (8 if O[0][0] == 6 else 7))
  return O 
 
0.3566666666666667, 25.427233, def feiedabfihhhegdeafefddfddccaifad(I):
  # 1. Get object partitions excluding background
  objs = fgpartition(I) 
  
  # 2. Sort objects based on size (proxy for frequency)
  sorted_objs = order(objs, size)
  
  # 3. Extract the second and third most frequent objects
  second_obj = sorted_objs[-2]
  third_obj = sorted_objs[-3]
  
  # 4. Swap colors of the two objects
  I = paint(paint(I, recolor(color(third_obj), second_obj)), recolor(color(second_obj), third_obj))

  # 5. Move the now second most frequent object to the bottom-right corner
  I = move(I, recolor(color(third_obj), second_obj), (height(I)-height(second_obj), width(I)-width(second_obj)))
  return I 
 
0.32, 3.6673324, def hahchffcjjjbehcebaaeadbiiabjjdch(grid):
  def swap_colors(objs):
    if len(objs) < 3: return objs
    color_counts = {}
    for obj in objs:
      c = color(obj)
      color_counts[c] = color_counts.get(c, 0) + len(obj)
    sorted_colors = sorted(color_counts.items(), key=lambda item: item[1], reverse=True)
    c1, c2 = sorted_colors[1][0], sorted_colors[2][0]
    for obj in objs:
      if color(obj) == c1:
        obj = recolor(c2, obj)
      elif color(obj) == c2:
        obj = recolor(c1, obj)
    return objs

  return paint(grid, merge(swap_colors(objects(grid, T, F, T))))
 
0.3, 3.3921719, def hajdbeeiagceebaebgffahcficjfbfab(I):
  O = I
  for s in {size(obj) for obj in objects(I, T, F, T)}:
    for obj in sizefilter(objects(O, T, F, T), s):
      new_color = {2: 2, 9: 8, 8: 6, 4: 1, 5: 6, 3: 1}.get(s, color(obj))
      if s == 8 and color(obj) != 2:
        continue
      elif s == 4 and color(obj) != 5:
        continue
      elif (s == 5 or s == 3) and color(obj) != 7:
        continue
      O = paint(O, recolor(new_color, toindices(obj)))
  O = switch(O, 6, (8 if index(O, (0, 0)) == 0 else 7))
  return O
 
0.33, 3.6694174, def cdhddiefgfacecdcbhaifbgafebebbbe(I):
  O = I
  for obj in objects(I, T, F, T):
    s, c = size(obj), color(obj)
    new_color = {
        (2, 0): 2, (9, 0): 8, (8, 2): 6, 
        (4, 5): 4, (5, 7): 6, (3, 7): 1
    }.get((s, c), c)
    O = paint(O, recolor(new_color, toindices(obj)))
  return switch(O, 6, (8 if O[0][0] == 0 else 7))
 
0.25333333333333335, 3.2819538, def deebffdhbbbdedgbaacfaacfdiaacchj(I):
  color_a = 5
  other_colors = difference(palette(I), {0, color_a}) # find colors other than background and color A
  for color_b in other_colors:
    I = switch(I, color_a, color_b) # attempt swapping with each other color 
  return I
 
0.32, 3.7212834, def dfciccgcbcbheaadabdedifjebhccaab(I):
  objs = objects(I, T, F, T) # Identify all objects in the input grid.
  def new_color(obj):
    s = size(obj)  # Get the size of the object.
    c = color(obj) # Get the color of the object.
    if s == 2: 
        return {5: 2, 7: 1}.get(c, c) # Recolor size 2 objects based on original color.
    elif s in (8, 9): 
        return {5: 7, 8: 7}.get(c, c)  # Recolor size 8 and 9 objects based on original color.
    elif s == 4: 
        return 6 if c == 5 else 1 # Recolor size 4 objects based on original color.
    elif s == 3:
        return 6
    else:
        return c # Keep the original color for other sizes.
  recolored_objs = frozenset({(new_color(obj), idx) for obj in objs for val, idx in obj}) # Apply the recoloring logic.
  O = paint(I, recolored_objs)  # Paint the recolored objects onto the grid.
  return O 
 
0.33666666666666667, 51.804207, def ajbdjcdjbbbgehgfabfgfcabfefddifa(I):
  size_color_map = {2: lambda c: {5: 2, 7: 1}.get(c, c), # Map size 2 to a recolor function.
                    (8, 9): lambda c: {5: 7, 8: 7}.get(c, c), # Map sizes 8 & 9 to a recolor function.
                    4: lambda c: 6 if c == 5 else 1, # Map size 4 to a recolor function.
                    3: 6} # Direct color mapping for size 3.
  def new_color(obj):
    recolor_fn = size_color_map.get(size(obj))
    return recolor_fn(color(obj)) if callable(recolor_fn) else recolor_fn
  recolored_objs = frozenset({(new_color(obj), idx) for obj in objects(I, T, F, T) for val, idx in obj})
  return paint(I, recolored_objs)
 
0.15, 2.3398147, def babcbiefehbhegafadgadicbifaeedea(I):
  def process_column(j, grid):
    column_objs = sfilter(objects(grid, T, F, T), lambda obj: any(j == k for i, k in toindices(obj)))
    sorted_objs = order(column_objs, lambda obj: uppermost(obj))
    for i in range(len(sorted_objs) - 1):
      obj1 = sorted_objs[i]
      obj2 = sorted_objs[i+1]
      if size(obj1) < size(obj2):
        grid = switch(grid, color(obj1), color(obj2))
    return grid
  
  new_grid = I
  for j in range(width(I)):
    new_grid = process_column(j, new_grid)
  return new_grid
 
0.20666666666666667, 2.7879224, def hhcdghejgfjbecdjidfiehccehbfijib(I):
  """
  This version uses the switch function to directly swap or cyclically permute colors.
  """
  color_palette = palette(I)
  if 1 in color_palette and 4 in color_palette: # Input 1 condition
    I = switch(I, 1, 4) # 1 becomes 4
    I = switch(I, 4, 5) # 4 becomes 5
  elif 1 in color_palette and 7 in color_palette: # Input 2 condition
    I = switch(I, 1, 5) # 1 becomes 5
    I = switch(I, 5, 7) # 5 becomes 7
  else: # Input 0 condition
    I = switch(I, 2, 5) # 2 becomes 5
  return I 
 
0.21, 4.8287473, def hbeidbeedaabefiebadbeeabhiecaadi(I):
  """
  This version leverages the replace function for a more direct color substitution.
  """
  if 1 in palette(I) and 4 in palette(I): # Input 1 condition
    I = replace(I, 1, 4) 
    I = replace(I, 4, 5) 
    I = replace(I, 5, 1)
  elif 1 in palette(I) and 7 in palette(I): # Input 2 condition
    I = replace(I, 1, 5) 
    I = replace(I, 5, 7)
    I = replace(I, 7, 1)
  else: # Input 0 condition
    I = replace(I, 2, 5)
    I = replace(I, 5, 2)
  return I
 
0.3, 5.086526, def ccjfhgdchiaiedieiifidafbfgcjifbh(I):
  """
  This version uses a combination of object detection, color filtering, and recoloring.
  """
  objs = objects(I, T, F, T)
  if 1 in palette(I) and 4 in palette(I): # Input 1 condition
    I = paint(I, recolor(4, extract(objs, lambda obj: color(obj) == 1)))
    I = paint(I, recolor(5, extract(objs, lambda obj: color(obj) == 4)))
    I = paint(I, recolor(1, extract(objs, lambda obj: color(obj) == 5)))
  elif 1 in palette(I) and 7 in palette(I): # Input 2 condition
    I = paint(I, recolor(5, extract(objs, lambda obj: color(obj) == 1)))
    I = paint(I, recolor(7, extract(objs, lambda obj: color(obj) == 5)))
    I = paint(I, recolor(1, extract(objs, lambda obj: color(obj) == 7)))
  else: # Input 0 condition
    I = paint(I, recolor(5, extract(objs, lambda obj: color(obj) == 2)))
    I = paint(I, recolor(2, extract(objs, lambda obj: color(obj) == 5)))
  return I
 
0.3, 15.153505, def bdiiefgjjjecejdabcfeajjcdbchdjce(I):
  objs = sorted(objects(I,T,F,T), key=lambda obj: len(obj))
  second_obj, second_color = objs[-2], color(objs[-2])
  third_obj, third_color = objs[-3], color(objs[-3])
  O = paint(paint(cover(I, third_obj), shift(recolor(second_color, third_obj), (height(I)-height(second_obj), width(I)-width(second_obj)))), recolor(third_color, second_obj))
  return O
 
0.3, 3.9254467, def afacadibeejiehcfidaeacdjdheaaeag(grid):
  def swap_colors(objs):
    sorted_objs = sorted(objs, key=len, reverse=True)
    if len(sorted_objs) >= 3:
      second_largest = sorted_objs[1]
      third_largest = sorted_objs[2]
      second_color = color(second_largest)
      third_color = color(third_largest)
      return paint(paint(cover(grid, second_largest), recolor(third_color, second_largest)), recolor(second_color, third_largest))
    return grid

  objs = objects(grid, T, F, T)
  return swap_colors(objs)
 
0.29, 3.8534324, def ebbegafecdjeeedgbbibhjeeeefcbeda(I):
  size_color_map = {
      2: {5: 2, 7: 1},
      8: {5: 8},
      9: {5: 8},
      4: {2: 6, 4: 6},
      3: {7: 1}
  }
  def recolor_object(obj):
    s, c = size(obj), color(obj)
    new_c = size_color_map.get(s, {}).get(c, c)
    return frozenset({(new_c, idx) for val, idx in obj})
  return paint(I, merge(apply(recolor_object, objects(I, T, F, T))))
 
0.32, 3.6673324, def beabddifcdcbefehibebfddfcfdiddcf(I):
  def recolor_obj(obj, size_color_map):
    s, c = size(obj), color(obj)
    return frozenset({(size_color_map.get(s, {}).get(c, c), idx) for val, idx in obj})
  recolored_objs = frozenset()
  for s in (2, 8, 9, 4, 3):
    size_color_map = {
        2: {5: 2, 7: 1},
        8: {5: 8},
        9: {5: 8},
        4: {2: 6, 4: 6},
        3: {7: 1}
    }.get(s, {})
    recolored_objs |= merge(apply(lambda obj: recolor_obj(obj, size_color_map), sizefilter(objects(I, T, F, T), s)))
  return paint(I, recolored_objs)
 
0.3, 3.0982087, def aidbbcdhjjbeegchbiiagcdjhdebcadd(I):
  """
  Uses nested conditional statements to apply color swaps based on input conditions.
  """
  if 1 in palette(I) and 4 in palette(I): # Input 1 condition
    I = replace(I, 2, 5) 
    I = replace(I, 5, 2)
  elif 1 in palette(I) and 7 in palette(I): # Input 2 condition
    I = replace(I, 1, 4)
    I = replace(I, 4, 7)
    I = replace(I, 7, 1) 
  else: # Input 0 condition
    I = replace(I, 5, 7)
    I = replace(I, 7, 5)
  return I
 
0.16666666666666666, 3.181912, def ffiaaejcegidedidjbdbfabgeebffjde(I):
  """
  Iterates through possible color pairs and applies the switch function based on input conditions. 
  """
  color_pairs = [(2, 5), (1, 4), (4, 7), (5, 7)] 
  for a, b in color_pairs:
    if (a in palette(I) and b in palette(I)) or (a == 5 and b == 7): # Apply swap for all inputs if (a,b)=(5,7) 
      I = switch(I, a, b)
  return I
 
0.32, 3.5690498, def fdbedfacfgehedefiecbadeajejfcjfj(I):
  """
  Defines a helper function for swapping and applies it based on input conditions.
  """
  def swap_colors(grid, a, b):
    return replace(replace(grid, a, b), b, a)

  if 1 in palette(I) and 4 in palette(I):
    I = swap_colors(I, 2, 5)
  elif 1 in palette(I) and 7 in palette(I):
    I = swap_colors(I, 1, 4)
    I = swap_colors(I, 4, 7)
  else:
    I = swap_colors(I, 5, 7)
  return I
 
0.32, 3.5824583, def bdbddiheefcaejccbececdhddcfccaac(I):
  objs = objects(I, T, F, T)
  recolored_objs = frozenset()
  for obj in objs:
    s = size(obj)
    c = color(obj)
    new_color = c
    if s == 2:
      new_color = 2 if c == 5 else 1
    elif s == 8:
      new_color = 6 if c == 2 else 8
    elif s == 9:
      new_color = 7 if c == 5 else 8
    elif s == 4:
      new_color = 4 if c == 5 else 1
    elif s == 3:
      new_color = 6 if c == 5 else 1
    recolored_objs |= recolor(new_color, toindices(obj))
  return paint(I, recolored_objs)
 
0.29, 3.7090528, def jebdchbfffaeefeaafadbbhaafdgffec(I):
  def recolor_func(obj):
    s, c = size(obj), color(obj)
    return recolor({2: 2, 8: 6, 9: 8}.get(s, c), toindices(obj)) if c == 5 else \
           recolor({4: 1, 9: 7}.get(s, c), toindices(obj)) if c == 4 else \
           recolor({2: 1, 3: 6, 9: 7}.get(s, c), toindices(obj)) if c == 7 else obj

  return paint(I, merge(apply(recolor_func, objects(I, T, F, T))))
 
0.32, 3.6634812, def bhieehaddfbeeahdaebaafbjaffhgdaf(I):
  def recolor_rule(obj):
    s, c = size(obj), color(obj)
    return (s == 2 and c == 5) and 2 or (s == 8 and c == 2) and 6 or \
           (s in (3, 9) and c == 5) and 7 or (s == 9 and c != 5) and 8 or \
           (s in (2, 3, 4) and c in (4, 7)) and 1 or (s == 4 and c == 5) and 4 or c

  return paint(I, merge(apply(lambda obj: recolor(recolor_rule(obj), toindices(obj)), objects(I, T, F, T))))
 
0.30333333333333334, 3.2126293, def ejafejgdcfgiehdcjgdcbhacgbeecich(I):
  """
  Recolors objects based on specific color combinations present.
  """
  if {1, 4} <= palette(I):
    I = switch(I, 2, 5) 
  elif {1, 7} <= palette(I):
    I = replace(replace(replace(I, 1, 8), 4, 1), 8, 4)
    I = replace(replace(replace(I, 7, 9), 1, 7), 9, 1)
  else:
    I = switch(I, 5, 7)
  return I
 
0.3, 3.2636416, def fbaidhibcbdfeahdjccibdfaacjdeaba(I):
  """
  Applies functions conditionally based on color presence.
  """
  condition_1_4 = lambda : {1, 4} <= palette(I)
  condition_1_7 = lambda : {1, 7} <= palette(I)
  I = branch(condition_1_4(), switch(I, 2, 5), I)
  I = branch(condition_1_7(), replace(replace(replace(I, 1, 8), 4, 1), 8, 4), I)
  I = branch(condition_1_7(), replace(replace(replace(I, 7, 9), 1, 7), 9, 1), I)
  I = branch(not (condition_1_4() or condition_1_7()), switch(I, 5, 7), I)
  return I
 
0.29, 3.5480769, def fbicjgadijdceabcifiegdbdibhabebb(I):
  def recolor_by_size(obj):
    s = size(obj)
    if s == 3: return 2
    elif s == 4: return 6
    elif s == 9: return 8 
    else: return color(obj)

  objs = objects(I, T, F, T)
  recolored_objs = frozenset({(recolor_by_size(obj), idx) for obj in objs for val, idx in obj})
  return paint(I, recolored_objs) 
 
