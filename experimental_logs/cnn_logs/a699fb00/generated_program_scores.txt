3.6666666666666665, 8.425643, def cecbfdfacjchefeeacjccfchdbcabiac(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    for value, (i, j) in obj:
      if value == 1:
        I = fill(I, 2, {(i, j + 1)})
  O = I
  return O
 
4.666666666666667, 18.1163, def echabfbhgfbdefbeabihacgajdbcdbbc(I):
  objs = objects(I, T, F, T)
  modified_objs = set()
  for obj in objs:
    leftmost_col = min(j for i, j in toindices(obj))
    if size(sfilter(toindices(obj), lambda x: x[1] == leftmost_col)) > 1:
      modified_objs.add(combine(obj, recolor(2, shift(sfilter(toindices(obj), lambda x: x[1] == leftmost_col), (0, 1)))))
    else:
      modified_objs.add(obj)
  O = paint(I, merge(modified_objs))
  return O 
 
4.0, 5.0539265, def hdbaecbbfhfeebeebaehbbdfegjccbca(I):
  objs = objects(I, True, True, False)
  new_objs = set()
  for obj in objs:
    new_obj = set()
    for v, (i, j) in obj:
      new_obj.add((v, (i, j)))
      if v == 1:
        new_obj.add((2, (i, j + 1)))
    new_objs.add(frozenset(new_obj))
  O = paint(I, merge(new_objs))
  return O
 
3.6666666666666665, 8.425643, def cddfacbjgfagededbjadibaddgcfadea(I):
  indices_1 = ofcolor(I, 1)
  shifted_indices = shift(indices_1, RIGHT)
  O = I
  for i, j in shifted_indices:
    if 0 <= j < width(I):
      O = fill(O, 2, {(i, j)})
  return O
 
7.0, 15.772406, def bhiffggjfaggeecbbaficdjiefecbibi(I):
  def process_row(row, j):
    return tuple(2 if (j > 0 and row[j-1] == 1) or (j < len(row)-1 and row[j+1] == 1) else v for j, v in enumerate(row))

  modified_grid = tuple(process_row(row, j) for j, row in enumerate(I))
  return modified_grid
 
3.6666666666666665, 8.425643, def bcbfadfdbcaaegccihjdigfaecggdajb(I):
  objs = fgpartition(I)
  new_objs = set()
  for obj in objs:
    new_obj = set()
    for v, (i, j) in obj:
      new_obj.add((v, (i, j)))
      new_obj.add((2, (i, j + 1)))
    new_objs.add(frozenset(new_obj))
  O = paint(I, merge(new_objs))
  return O
 
4.666666666666667, 18.1163, def djafjafbdeieedhfbaafdaajefbcgfee(I):
  ones = ofcolor(I, 1)
  right_of_ones = mapply(lambda loc: (loc[0], loc[1] + 1), ones)
  O = fill(I, 2, intersection(right_of_ones, asindices(I)))
  return O
 
13.0, 17.657776, def fecbaajdeadaecacafbaadiafjfadgff(I):
  obj = asobject(I)
  shifted_obj = frozenset((2 if (v == 1 and (i, j+1) in toindices(obj) and next((c for c, (x, y) in obj if x == i and y == j+1), 0) == 0) else v, (i, j)) for v, (i, j) in obj)
  O = paint(canvas(0, shape(I)), shifted_obj)
  return O
 
13.0, 46.341167, def ccfjccgbdbaceiagadacdfbccdcadcec(I):
  shifted = rot270(hconcat(rot90(I), rot90(canvas(0, shape(I)))))
  merged = cellwise(I, shifted, 0)
  O = replace(merged, 1, 2)
  return O
 
12.0, 8.524867, def febhaaaifcaeefhdifdeffcehfgbfced(I):
  ones = ofcolor(I, 1)
  right_shifted = shift(ones, (0, 1))
  valid_positions = intersection(right_shifted, asindices(I))
  combined = ones | valid_positions
  O = paint(canvas(0, shape(I)), recolor(2, combined))
  return O
 
12.0, 17.774118, def agjifacaifcdeeiaafebcafebcicjdde(I):
  right_shifted = shift(asobject(I), RIGHT)
  O = canvas(0, shape(I))
  for v, (i, j) in right_shifted:
    if index(I, (i, j-1)) == 1:
      O = fill(O, 2, {(i, j)})
    else:
      O = fill(O, v, {(i, j)})
  return O
 
4.666666666666667, 18.1163, def eadbifbbcbgceibbjacdagabgjecedeb(I):
  objs = objects(I, True, True, False) # Find all objects in the input grid
  new_objs = set() # Initialize a set to store modified objects
  for obj in objs: # Loop through each object
    new_obj = set(obj) # Initialize the modified object as a copy of the original
    for v, (i, j) in obj:  # Loop through each cell in the object
      if v == 1:  # If the cell value is 1
        h, w = len(I), len(I[0]) # Get the height and width of the grid
        if j + 1 < w and (1, (i, j + 1)) in obj: # Check if the cell to the right exists and is part of the same object
          new_obj.add((2, (i, j + 1))) # Add a 2 to the right of the current cell
    new_objs.add(frozenset(new_obj)) # Add the modified object to the set of new objects
  O = paint(I, merge(new_objs)) # Paint the modified objects onto a copy of the input grid
  return O # Return the modified grid
 
4.666666666666667, 18.1163, def bbfcdfjaacbiecefiffbhfccdecceagh(I):
  indices = asindices(I)
  right_indices = apply(lambda loc: (loc[0], loc[1] + 1), indices)
  valid_indices = sfilter(right_indices, lambda loc: 0 <= loc[1] < len(I[0]))
  object_indices = mfilter(objects(I, univalued=True, diagonal=False, without_bg=True), toindices)
  filtered_indices = sfilter(valid_indices, lambda loc: subtract(loc, RIGHT) in object_indices)
  O = fill(I, 2, filtered_indices)
  return O
 
13.0, 46.341167, def bfihbcbeadigehbdjfchhdbeffcchdia(I):
  shifted_grid = rot90(I)
  shifted_grid = tuple(tuple(2 if c != 0 else 0 for c in row) for row in shifted_grid)
  shifted_grid = rot270(shifted_grid)
  O = cellwise(I, shifted_grid, 0)
  return O 
 
12.0, 17.774118, def bhehhefhhbeaefajaahgbbbebciifdfb(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != 0 and j + 1 < len(row):
        O = fill(O, 2, {(i, j + 1)})
  return O
 
3.6666666666666665, 8.425643, def bjdfedjibagdeafdajjaeeaigiddhhcf(I):
  ones = ofcolor(I, 1) # Get indices of all '1's
  right_neighbors = shift(ones, (0,1)) # Shift indices one position to the right
  valid_positions = intersection(right_neighbors, asindices(I)) # Find valid positions within grid
  twos = recolor(2, valid_positions) # Recolor valid positions to '2'
  O = paint(I, twos)  # Paint the '2's onto the original grid
  return O
 
4.333333333333333, 4.7836075, def djiajafbficbebfjabddefdhjbgcdbad(I):
  ones = ofcolor(I, 1)  # Get indices of all '1' cells
  extensions = shift(ones, RIGHT) # Calculate indices of extension cells
  return paint(I, asobject(I) | recolor(2, extensions)) # Paint extensions with value '2'
 
3.3333333333333335, 9.456279, def hgcdehcdgdefeachbbifaefaafbhdaea(I):
  return tuple(
    tuple(
      2 if j + 1 < len(row) and row[j + 1] == 1 else v 
      for j, v in enumerate(row)
    ) for row in I
  )
 
79.66666666666667, 28.1346, def aaabfbcdidcheadfbddddaadgfffadaj(I):
  return hconcat(
    I, 
    tuple(
      (2,) + tuple(0 for _ in range(len(row) - 1)) if row[0] == 1 else tuple(0 for _ in range(len(row))) 
      for row in I
    )
  )
 
8.333333333333334, 9.64747, def eceghcfegfbgecfaicdceeejiejgceac(I):
  shifted_ones = shift(recolor(1, ofcolor(I, 1)), (0, 1))  # Shift '1' indices right and convert to an object
  O = paint(I, shifted_ones)  # Paint the shifted object onto the input grid
  return O 
 
3.6666666666666665, 8.425643, def aaeddffbhbecegedbjeeechfdhdbjbbc(I):
    O = I
    for j in range(len(I[0]) - 1):
      for i in range(len(I)):
        if I[i][j] != 0 and I[i][j + 1] == 0:
          O = paint(O, {(2, (i, j + 1))})
    return O
 
13.0, 17.657776, def ahdjjddjibieeajaajeahfjfifjcebhd(I):
    def extend_right_conditional(v, loc):
        i, j = loc
        if j + 1 < len(I[0]):
            return (v, (i, j)) if I[i][j + 1] == 1 else (2, (i, j)) if v == 1 else (v, (i, j))
        else:
            return (2, (i, j)) if v == 1 else (v, (i, j))

    new_objects = set()
    for i, row in enumerate(I):
        for j, v in enumerate(row):
            new_objects.add(extend_right_conditional(v, (i, j)))
    return paint(canvas(0, shape(I)), frozenset(new_objects))
 
62.0, 28.06632, def aedbdideacchebdaahfjbeifgjhccafb(I):
  obj_one = asobject(I) # Convert grid to object
  shifted_obj = shift(obj_one, RIGHT) # Shift the entire object to the right
  valid_indices = toindices(shifted_obj) & asindices(I) # Find indices valid in both original and shifted positions
  filtered_obj = frozenset((2, index) for value, index in shifted_obj if index in valid_indices) # Create new object with '2' at valid indices
  O = paint(I, filtered_obj) # Paint the new object onto the input grid
  return O
 
67.0, 100.90118, def jbacdgahedbdebhejhhbfjfgfbiaaghe(I):
  h = height(I)
  split_grid = hsplit(I, width(I))
  modified_grid = []
  for row in split_grid:
    modified_row = []
    for i, v in enumerate(row[0]):
      modified_row.append(v)
      if v == 1 and i < len(row[0]) - 1:
        modified_row.append(2)
    modified_grid.append(tuple(modified_row))
  O = tuple(tuple(0 for _ in range(width(I))) for _ in range(h - len(modified_grid))) + tuple(modified_grid)
  return O
 
13.0, 17.657776, def fejccbedccgaedfijfdfafbacecfejec(I):
  O = apply(lambda row: tuple(v if j == len(row) or v != 1 else (v, 2)[j < len(row) - 1] for j, v in enumerate(row)), I)
  return O
 
22.333333333333332, 42.6733, def efiiaffcacdgeegbadaheghaafbabiba(I):
  ones = ofcolor(I, 1)
  shifted_right = shift(ones, (0, 1))
  shifted_left = shift(ones, (0, -1))
  shifted_up = shift(ones, (-1, 0))
  shifted_down = shift(ones, (1, 0))
  twos =  shifted_right | shifted_left | shifted_up | shifted_down 
  O = fill(I, 2, twos)
  return O
 
25.0, 14.51359, def deaabgfbdbeeefbfaijhjbefbhjhbbba(I):
  def extend_object(obj):
    return obj | recolor(2, shift(toindices(obj), RIGHT))
  return paint(I, merge(apply(extend_object, objects(I, True, True, False))))
 
2.6666666666666665, 6.164834, def afaffbcdibfgeeabijfaeadffdjceccd(I):
  return tuple(
      tuple(
        2 if k == 1 and j < len(row) - 1 else v 
        for j, (v, k) in enumerate(zip(row, (0,) + row[:-1]))
      )
      for row in I
  )
 
3.3333333333333335, 9.456279, def egcbaeheddccecgeadicdfbbeaifccaf(I):
    O = tuple(
        tuple(
            2 if j + 1 < len(row) and row[j + 1] == 1 else v 
            for j, v in enumerate(row)
        ) 
        for row in I
    )
    return O
 
44.666666666666664, 35.96485, def bedaedaaedacedecaicdhccfedjdibgb(I):
  upscaled = hupscale(I, 2)  # Horizontally upscale the grid
  O = replace(upscaled, (1, 1), (1, 2))  # Replace occurrences of (1, 1) with (1, 2)
  return downscale(O, 2)  # Downscale the grid back to its original size
 
5.666666666666667, 9.053631, def cbdcacaiebcaejgdbbabfeidiahgceab(I):
  objs = objects(I, T, F, T)
  shifted_objs = apply(lambda obj: shift(obj, (0, 1)), objs)
  expansion_area = difference(merge(apply(backdrop, shifted_objs)), merge(apply(backdrop, objs)))
  expanded_objs = mapply(lambda obj: obj | recolor(2, intersection(expansion_area, toindices(obj))), shifted_objs)
  O = paint(I, expanded_objs)
  return O
 
8.0, 9.1453905, def gbdbjdjbhbadehfdbcfedcehjbcadcdj(I):
  shifted_grid = hconcat(I, ((0,) * len(I[0]),))
  objs = objects(I, T, F, T)
  expanded_objs = mapply(lambda obj: obj | recolor(2, intersection(toindices(obj), ofcolor(shifted_grid, 0))), apply(lambda obj: shift(obj, (0, 1)), objs))
  O = paint(I, expanded_objs) 
  return O
 
12.333333333333334, 6.965709, def dhafcgcabjjeeabciheaafgjjbfcehic(I):
  return tuple(hconcat(left, ((2,) + right[1:]) if left[-1] == 1 and right[0] == 0 else right) for left, right in pair(I, ((0,) * len(I[0]),) + I))
 
11.0, 19.175007, def adfcgieicefdedceabecdhfgefbdcafc(I):
    def extend_right(grid, i, j):
        if j + 1 < len(grid[0]) and grid[i][j + 1] == 0:
            grid = fill(grid, 2, {(i, j + 1)})
            return extend_right(grid, i, j + 1)
        return grid

    new_grid = I
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 1:
                new_grid = extend_right(new_grid, i, j)
    return new_grid
 
16.0, 27.243078, def deadbhbbdaafeceibaafcbehbdffedfb(I):
  def extend_right(obj):
    rightmost_col = rightmost(obj) 
    return frozenset((v, (i, j + 1)) if j == rightmost_col and j + 1 < len(I[0]) else (v, (i, j))
                       for v, (i, j) in obj)
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Extract objects 
  extended_objs = frozenset(extend_right(obj) for obj in objs) # Extend each object to the right 
  O = paint(canvas(0, shape(I)), merge(extended_objs)) # Paint the extended objects onto a blank canvas
  return O
 
12.333333333333334, 29.466125, def baafcfcafgcceeeebaaafcgadccffejh(I):
  def extend_if_one(cell):
    v, (i, j) = cell
    return (2, (i, j + 1)) if v == 1 and j + 1 < len(I[0]) else cell 
  flattened = ((I[i][j], (i, j)) for i in range(len(I)) for j in range(len(I[0])))
  extended = frozenset(extend_if_one(cell) for cell in flattened)
  O = paint(canvas(0, shape(I)), extended) 
  return O
 
12.0, 8.524867, def babafaehbfcbehacbicjbdieeadehega(I):
  shifted =  hconcat(I, canvas(0, (len(I), 1))) # Concatenate a zero-filled column to the right
  extended = cellwise(shifted, hconcat(canvas(0, (len(I), 1)), I), 2) # Overlap and fill with "2" where differences occur
  O = crop(extended, (0, 0), shape(I)) # Crop to original size
  return O
 
3.6666666666666665, 8.425643, def chdfigafjddaecdhbdjbacabaajcebhb(I):
    # Iterate through rows and columns
    return tuple(
        tuple(
            2 if (j > 0 and row[j-1] == 1) else row[j]
            for j in range(len(row))
        ) 
        for row in I
    )
 
9.333333333333334, 15.799288, def eedjeadabccdeecibgefcbgbdcegbehb(I):
    return tuple(
        tuple(
            2 if v == 1 and row[j+1:].count(1) > 0 else v
            for j, v in enumerate(row)
        )
        for row in I
    )
 
9.333333333333334, 16.295544, def ahgebabbgfabedbcjedefcdbgiccahia(I):
    def process_row(row):
        new_row = list(row)
        one_indices = [i for i, v in enumerate(row) if v == 1]
        for i in range(len(one_indices)-1):
            new_row[one_indices[i+1]] = 2
        return tuple(new_row)
    return tuple(process_row(row) for row in I)
 
13.0, 17.657776, def dbjchaacbajgeceebafagebjfeejcfhi(I):
    objs = objects(I, T, F, T)
    new_objs = set()
    for obj in objs:
        indices = toindices(obj)
        ordered_indices = order(indices, lambda x: x[0] * 1000 + x[1])
        for i in range(1, len(ordered_indices), 2):
            indices = remove(ordered_indices[i], indices)
        new_objs.add(recolor(2, indices))
    O = paint(I, merge(new_objs))
    return O
 
10.333333333333334, 16.955421, def gaedggjcdaecejghabadiaaaeeadeeda(I):
    objs = objects(I, T, F, T)
    new_objs = mapply(lambda obj: recolor(2, sfilter(toindices(obj), lambda idx: even(idx[0] + idx[1]))), objs)
    O = paint(I, new_objs)
    return O
 
4.666666666666667, 18.1163, def adeejdejcdcbeabijbhffhcjaagaabee(I):
    objs = objects(I, T, F, T)
    checkered = prapply(lambda i, j: even(i + j), range(len(I)), range(len(I[0])))
    new_objs = mapply(lambda obj: recolor(2, intersection(toindices(obj), checkered)), objs)
    O = paint(I, new_objs)
    return O
 
3.6666666666666665, 8.425643, def dbefdjfcgecgeiiejigcjeciefhbbdaa(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  for obj in objs:
    for v, (i, j) in obj:
      if v == 1 and j + 1 < len(I[0]) and I[i][j+1] == bg:
        I = fill(I, 2, {(i, j+1)})
  return I
 
13.0, 17.657776, def badgdaidiiddeigcjejdadaheefiieca(I):
  return paint(I,  {(2, p) for obj in objects(I, True, False, True) for v, p in obj if v == 1 and index(I, add(p, RIGHT)) == 0 and add(p, RIGHT) not in toindices(obj)})
 
3.6666666666666665, 8.425643, def hcaedbcgdgdbefgiaaiidiegedgbebaa(I):
  O = tuple(
      tuple(
          2 if j > 0 and row[j-1] == 1 and v == 0 else v 
          for j, v in enumerate(row)
      ) 
      for row in I
  )
  return O
 
13.0, 17.657776, def hjieebdadhccedahafbddfbcabaafdbi(I):
  O = tuple(
      tuple(
          branch(
              both(j < len(row)-1, index(I, (i, j+1)) == 0),
              branch(v == 1, 2, v), 
              v
          )
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
  return O
 
4.666666666666667, 18.1163, def ajgaciafefdfeffdicghdjgfhefcbeac(I):
  return tuple(
      tuple(
        2 if v == 1 and j < len(row) - 1 and row[j+1] == 1 else v
        for j, v in enumerate(row)
      )
      for row in I
  )
 
12.333333333333334, 7.8325176, def cfbbcdcjfaececcfjgfaeaifgdhdabid(I):
    shifted_right = ((0,) * len(I[0]),) + I[:-1]
    return tuple(
        tuple(
            2 if left == 1 and right == 0 else right
            for left, right in zip(left_row, right_row)
        )
        for left_row, right_row in zip(shifted_right, I)
    ) 
 
13.0, 46.341167, def afbbajedjcaaeebfbecacdhfbaabdjaj(grid):
  painted = canvas(0, shape(grid))
  for i in range(len(grid)):
    for j in range(len(grid[0]) - 1):
      if grid[i][j] == 1 and grid[i][j+1] == 1:
        painted = fill(painted, 2, (i, j + 1))
  return cellwise(grid, painted, 0)
 
7.333333333333333, 8.167735, def ddbichfbfacdecdeajcfbidejiageagf(I):
  J = tuple(
      tuple(
          2 if k == 1 and j < len(row) - 1 else v
          for j, (v, k) in enumerate(zip(row, (0,) + row[:-1]))
      )
      for row in I
  )
  return tuple(
      tuple(
        1 if v==2 and j<len(row)-1 and row[j+1]==1 else v 
        for j, v in enumerate(row)
      )
      for row in J
  )
 
4.666666666666667, 18.1163, def dbaccfbcejaieeabiadiabaebefbhdbc(I):
  return tuple(tuple(2 if j > 0 and row[j-1] == 1 and col[i] == 1 else col[i] for j, col in enumerate(zip(*I))) for i, row in enumerate(I))
 
20.333333333333332, 16.988039, def ffdiahbgfefaeaebjicgeghccidfaeef(I):
  return paint(I,
               merge(
                   apply(
                       lambda obj: obj | recolor(2, {(i, j + 1) for (i, j) in toindices(obj) if 0 <= j + 1 < len(I[0]) and index(I, (i, j + 1)) == 0}), 
                       objects(I, True, False, False)
                   )
               )
           )
 
5.0, 17.795322, def cfbaadafagdfecegjcfjjgbfcfajeefb(grid):
  return tuple(
      tuple(
          v + (contained((1, 1), pair(row[max(0, j-1):j+1], row[j:min(len(row), j+2)])) and v == 1) 
          for j, v in enumerate(row)
      )
      for row in grid
  )
 
12.666666666666666, 17.450325, def dcbecbaidijaeegdjajjbhbehefcgiia(I):
  for j in range(len(I[0])-1, 0, -1):
    for i in range(len(I)):
      if I[i][j] == 1 and I[i][j-1] == 0:
        I = fill(I, 2, {(i, j)})
  return I
 
16.666666666666668, 9.753991, def fbbbahhafebbechejfgigdehgbccfdhh(I):
  return tuple(
      papply(lambda a, b: 2 if a == 1 and b == 0 else b, row, (0, *row)) 
      for row in I
  )
 
3.3333333333333335, 9.456279, def hfffbabecieheabejhcaccbafjjedcce(I):
  return tuple(
        tuple(
            2 if col == 0 and j < len(row) - 1 and row[j+1] == 1 else col 
            for j, col in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
5.333333333333333, 17.801249, def dcfhjjgfgcgaebcbbiccfcabacjbdcge(I):
  shifted_grid = (I[0],) + I
  return tuple(
    tuple(
      2 if v == 1 and shifted_row[j] == 1 else v
      for j, v in enumerate(row)
    )
    for row, shifted_row in zip(I, shifted_grid)
  )
 
11.333333333333334, 29.060362, def cbeigeabagicefehaedbieehbgeddeii(I):
  def add_border(obj):
    return recolor(2, difference(merge((shift(obj, DOWN), shift(obj, RIGHT))), obj))
  return paint(I, merge(apply(add_border, objects(I, True, False, True)))) 
 
3.0, 5.50269, def jaegebdfeiddeeffbfcejadejjdccdjf(I):
  shifted_right = shift(asobject(I), RIGHT)
  for (v1, (i, j)), (v2, _) in zip(asobject(I), shifted_right):
    if v1 == 1 and v2 == mostcolor(I):
      I = fill(I, 2, {(i, j + 1)})
  return I
 
20.666666666666668, 18.193851, def edbbgfbafecaefgdbjifccbccccjjjab(I):
  shifted_right = ((0,) * len(I[0]),) + I
  return tuple(
      tuple(
          branch(left[-1] == 1 and right[0] == 0, (2,) + right[1:], right)
          for left, right in pair(I, shifted_right)
      )
  )
 
33.666666666666664, 13.379019, def bidcgfbeaccfejacieecbcahiehbdhhe(I):
  objs = sorted(objects(I, True, False, True), key=lambda obj: (uppermost(obj), leftmost(obj)))
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, recolor(2, shift(normalize(obj), (i, 0))))
  return O
 
29.333333333333332, 6.1623197, def jabheaihbcbfebfejjehbeedgdbccdbb(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, obj in enumerate(sorted(objs, key=lambda obj: len(obj), reverse=True)):
    O = underpaint(O, recolor(2, shift(normalize(obj), ulcorner(toindices(obj)))))
  return O 
 
30.0, 13.83747, def ideeibibdfaiebbibdbiaccddbbiaded(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  painted = canvas(bg, shape(I))
  for obj in objs:
    painted = underpaint(painted, recolor(2, shift(obj, subtract((0,0), ulcorner(obj)))))
  return painted
 
23.666666666666668, 30.552847, def bfabdbbcfdecedcebgjdaaiaabchbefc(I):
  bg = mostcolor(I)
  shifted_objs = []
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != bg:
        shifted_objs.append(((val, (i, j)), (0, j))) 
  painted = canvas(bg, shape(I))
  for (val, (i, j)), (new_i, new_j) in shifted_objs:
    painted = paint(painted, {(2, (new_i, new_j))})
  return painted
 
16.0, 32.91764, def abbedfadfbdgeaeiidffbbahacdaecid(I):
    target = 5
    replacement = 2
    other_non_zero = 1
    
    def process_row(row):
        five_indices = [j for j, v in enumerate(row) if v == target]
        new_row = [0] * len(row)
        for j in five_indices:
            if j > 0 and row[j-1] != 0:
                new_row[j-1] = other_non_zero
                new_row[j] = replacement
            if j < len(row)-1 and row[j+1] != 0:
                new_row[j] = replacement
                new_row[j+1] = other_non_zero
            if new_row[j] == 0:  # Isolated '5'
                new_row[j] = other_non_zero
        return tuple(new_row)

    O = tuple(process_row(row) for row in I)
    return O
 
17.0, 27.812727, def fjcjejieaadieefdjbbedaaeedbdiahc(I):
    fives = ofcolor(I, 5)
    non_zeros = difference(asindices(I), ofcolor(I, 0))
    
    def neighbors_nonzero(loc):
        return len(intersection(dneighbors(loc), non_zeros)) > 0
    
    ones = frozenset(loc for loc in fives if not neighbors_nonzero(loc))
    twos = difference(fives, ones)
    adjacent_to_twos = mapply(dneighbors, twos)
    
    O = fill(canvas(0, shape(I)), 1, ones | adjacent_to_twos)
    O = fill(O, 2, twos)
    return O
 
13.0, 46.341167, def fefdhfddfddeecccjabdjeiecageafbf(I):
  objs = colorfilter(objects(I, T, F, F), FIVE)
  borders = mapply(lambda obj: delta(toindices(obj)), objs)
  O = fill(I, ZERO, asindices(I)) 
  O = fill(O, TWO, borders)
  return O
 
15.666666666666666, 30.545845, def bbigbabbdaaaefcajdbacgajhdejbcde(I):
  target_indices = ofcolor(I, FIVE)
  border_indices = mapply(dneighbors, target_indices) - target_indices
  O = canvas(ZERO, shape(I))
  O = fill(O, TWO, border_indices)
  return O
 
14.333333333333334, 34.03876, def ceadhegfjhcbecbgabbegbdhciibjcef(I):
  objs = objects(I, T, F, F)
  target_objs = colorfilter(objs, FIVE)
  expanded_objs = mapply(lambda obj: toindices(shift(obj, (1, 1))) | toindices(shift(obj, (-1, 1))) | toindices(shift(obj, (1, -1))) | toindices(shift(obj, (-1, -1))), target_objs)
  border_indices = expanded_objs - mapply(toindices, target_objs)
  O = canvas(ZERO, shape(I))
  O = fill(O, TWO, border_indices)
  return O
 
19.0, 6.620042, def hafhhcieabeeehadiagihgeejcaddhec(I):
  O = replace(I, FIVE, ZERO)
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == FIVE or I[i+1][j] == FIVE or I[i-1][j] == FIVE or I[i][j+1] == FIVE or I[i][j-1] == FIVE:
        O = fill(O, TWO, {(i, j)})
  return O
 
19.0, 5.6815605, def dbjgjbajdcjbebgcbaacaadedbbhicid(I):
  obj = extract(objects(I, T, F, F), lambda obj: contained(FIVE, palette(obj)))
  O = paint(fill(I, ZERO, toindices(obj)), recolor(TWO, intersection(toindices(obj), ofcolor(I, ONE))))
  return O
 
20.0, 6.515234, def gaeefebdgfbiedjgbjddjaichdaafaah(I):
  obj = extract(partition(I), lambda obj: contained(FIVE, palette(obj)))
  indices = toindices(obj)
  O = tuple(tuple(TWO if (i,j) in indices and v==ONE else v for j,v in enumerate(row)) for i,row in enumerate(I))
  return O
 
18.666666666666668, 5.6043797, def afcdiaaeafabececjifhihjbcbafhcga(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, F):
    if contained(FIVE, palette(obj)):
      O = paint(O, recolor(TWO, intersection(toindices(obj), ofcolor(I, ONE))))
    else:
      O = paint(O, obj)
  return O
 
20.333333333333332, 9.323805, def eebbcefbffajebcdbifbcdbibcadcfbb(I):
  target_color = FIVE
  replacement_color = TWO
  O = tuple(
      tuple(
          replacement_color if v == ONE and any(index(I, (i+di, j+dj)) == target_color for di, dj in [(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)]) else v
          for j, v in enumerate(row)
      )
      for i, row in enumerate(I)
  )
  return O
 
53.0, 14.296494, def bigaaaidafbdedbeabcffcidbbcfagaj(I):
    obj = toobject(ofcolor(I, 1), I) # Identify the '1' object
    bordered = delta(toindices(obj)) # Find indices surrounding the object
    O = paint(fill(I, 0, asindices(I)), obj) # Clear the grid and paint the '1' object
    O = fill(O, 2, bordered) # Fill the border with '2's
    return O 
 
53.666666666666664, 16.016392, def ccjjbfiedecbejebbdecbbbdjicajeif(I):
  ones = ofcolor(I, 1)
  surrounding = mapply(neighbors, ones)
  border = difference(surrounding, ones)
  O = fill(I, 0, asindices(I))
  O = fill(O, 2, border)
  O = fill(O, 1, ones)
  return O
 
44.0, 30.530863, def cabgjeaddjfjebfejdgaacbfbaddjaaj(I):
    obj_indices = ofcolor(I, 1)
    shifted_up = shift(obj_indices, UP)
    shifted_down = shift(obj_indices, DOWN)
    shifted_left = shift(obj_indices, LEFT)
    shifted_right = shift(obj_indices, RIGHT)
    border = merge((shifted_up, shifted_down, shifted_left, shifted_right))
    O = fill(I, 0, asindices(I))
    O = fill(O, 2, border)
    O = fill(O, 1, obj_indices)
    return O
 
32.666666666666664, 21.869637, def cdfbajbgacfceababcffdahcgfcdcfjg(I):
  obj = toobject(ofcolor(I, 1), I)
  border =  difference(box(obj), toindices(obj))
  O = paint(fill(I, 0, asindices(I)), obj)
  O = fill(O, 2, border)
  return O
 
44.333333333333336, 46.33189, def aiaafgedfcehefgabeaifeihffgbgeda(I):
  # Find objects containing '1'
  objs = objects(I, False, False, False)
  target_objs = colorfilter(objs, 1) 
  
  # Create a blank canvas
  O = canvas(0, shape(I)) 
  
  # Paint the target objects onto the canvas
  for obj in target_objs:
    O = paint(O, recolor(2, obj))
  
  return O
 
26.0, 5.9461646, def fddaeeeacffjeegfidfhhcgfijcfbbac(I):
  # Replace all non-1 digits with 0
  O = replace(I, 5, 0)
  for digit in palette(I)-{1, 5, 0}:
    O = replace(O, digit, 0)
  
  # Replace 1s with 2s
  O = replace(O, 1, 2)
  
  return O
 
70.33333333333333, 46.367615, def fcaddceddcbeedhbabcaifbcejbfdhbf(I):
  # Find objects, recolor those containing 1 to 2, and paint on a blank canvas
  return paint(canvas(0, shape(I)), 
              recolor(2, merge(
                        sfilter(objects(I, False, False, False), 
                                lambda obj: colorcount(obj, 1) > 0))))
 
68.0, 38.672096, def ihbdeebcciifebfcbfbgibedhabdbibj(I):
  O = replace(I, FIVE, ZERO) # Remove '5's
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == ONE or I[i+1][j] == ONE or I[i-1][j] == ONE or I[i][j+1] == ONE or I[i][j-1] == ONE:
        O = fill(O, TWO, {(i-1,j-1),(i-1,j),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j),(i+1,j+1)})
  return O
 
61.0, 24.490461, def jeefdhdbbceeedbajgiecfhdbedehbdg(I):
  O = replace(I, FIVE, ZERO) # Remove '5's
  for obj in objects(I, T, F, F): # Iterate over all connected objects
    if color(obj) == ONE: # Check if the object consists of '1's
      for (i, j) in toindices(obj):  # Iterate through the object's indices
        for di in range(-1, 2):  # Loop for neighbors in i-direction
          for dj in range(-1, 2): # Loop for neighbors in j-direction
            if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0]): # Boundary check
              O = fill(O, TWO, {(i + di, j + dj)}) # Fill the neighbor cell with '2'
  return O
 
27.333333333333332, 7.2548623, def ffceahfbfdciehdbjaaaceehcajibebc(I):
  ones = ofcolor(I, 1)
  shifted_right = mapply(lambda loc: (loc[0], loc[1] + 1), ones)
  O = fill(I, 2, ones)
  O = fill(O, 0, intersection(shifted_right, asindices(I)))
  return O
 
26.0, 5.9461646, def hejhdbhahecdeicgieedhjbffdbefcef(I):
    O = I
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == 1:
                O = fill(O, 2, {(i, j)})
                if j < len(row) - 1:
                    O = fill(O, 0, {(i, j + 1)})
    return O
 
26.666666666666668, 17.199762, def fafcddeachecefcbacjhbdchfgiceada(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        O = paint(O, {(1, (i, j)), (2, (i, j + 1))})
  return O
 
21.0, 7.547162, def dcaeaffbcfeaegcajhjffciadjiaeddg(I):
    shifted = shift(recolor(2, ofcolor(I, 1)), (0, 1))
    O = paint(fill(I, 0, asindices(I)), shifted)
    return O
 
36.0, 22.563171, def cbfafeefidffeiefjafddbhbehfejhhd(I):
  objs = objects(I, True, False, False)
  new_grid = canvas(ZERO, shape(I))
  for obj in objs:
    if color(obj) == ONE:
      box_indices = box(obj)
      inner_indices = delta(obj)
      new_grid = fill(new_grid, TWO, box_indices - inner_indices)
      new_grid = paint(new_grid, recolor(ONE, inner_indices))
  return new_grid
 
14.333333333333334, 40.81224, def bdbehhiadadjeehbjcfeegehfejbfacf(I):
  ones = ofcolor(I, 1) # Identify indices of all '1's
  shifted_left = mapply(lambda loc: (loc[0], loc[1] - 1), ones) # Shift indices one position to the left
  O = fill(I, 2, intersection(shifted_left, ones)) # Fill '2' at intersection, indicating rightmost '1's
  O = fill(O, 0, ones) # Fill '0' at all original '1' positions
  return O 
 
13.0, 46.341167, def cfajcgfdheagebdfbejdgjdajeafjdfe(I):
  objs = objects(I, True, False, False) # Identify objects formed by adjacent '1's
  O = I
  for obj in objs:
    rightmost_cell = argmax(obj, lambda cell: cell[1][1]) # Find the rightmost cell within each object
    O = fill(O, 2, {rightmost_cell[1]}) # Replace the rightmost cell with '2'
    O = fill(O, 0, toindices(obj)) # Replace all cells within the object with '0'
  return O
 
28.333333333333332, 6.8612986, def dcbbbfbihafiefhaiafabdjcdbehffga(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        if j == len(row) - 1 or I[i][j + 1] != 1: # Check if it's the rightmost '1'
          O = fill(O, 2, {(i, j)}) # Replace with '2' if it's the rightmost '1'
        else:
          O = fill(O, 0, {(i, j)}) # Replace with '0' otherwise
  return O
 
36.333333333333336, 8.499853, def hfbefbebfcjjejfbiafjebdacecfeied(I):
  objs = objects(I, True, False, False)  # Identify objects
  O = fill(I, 0, toindices(merge(objs)))  # Fill all object cells with 0 initially
  for obj in objs:
    rightmost_j = rightmost(obj)  # Find the rightmost column index
    rightmost_cells = sfilter(obj, lambda cell: cell[1][1] == rightmost_j)  # Get cells in that column
    O = fill(O, 2, toindices(rightmost_cells))  # Fill those cells with 2
  return O 
 
27.0, 7.6894608, def jcdaidadgfahecfcjdedaecdbibcafbh(I):
  O = canvas(0, shape(I)) # Initialize output grid with all '0's
  for i, row in enumerate(I):
    current_object = []
    for j, value in enumerate(row):
      if value == 1:
        current_object.append((i,j)) # Add '1' coordinates to current object
      if (value != 1 or j == len(row) - 1) and current_object: # Object ended or row ended
        O = fill(O, 2, {current_object[-1]}) # Fill last cell of object with '2'
        current_object = [] # Reset object
  return O 
 
31.666666666666668, 11.075948, def djeeahehfchaehdajefccabcjfedfaje(I):
  bg = mostcolor(I)
  h = height(I)
  new_objs = []
  for obj in objects(I, True, False, True):
    new_obj = frozenset()
    for v, (i, j) in obj:
      new_obj = new_obj | {(2, (h - uppermost(obj) - height(obj) + i, j))}
    new_objs.append(new_obj)
  return paint(canvas(bg, shape(I)), merge(new_objs))
 
20.0, 6.3722606, def gajiccjefddaeedhabbcdcfchchfadbf(I):
  obj = objects(I, True, False, False) # Identify connected '1' objects
  recolored = set()
  for o in obj:
    if color(o) == 1:
      for x, (i, j) in o:
        if j+1 < width(I) and I[i][j+1] == 5:
          recolored.add((i,j+1))
  O = paint(replace(I, 5, 0), recolor(2, frozenset(recolored)))
  return O
 
53.0, 18.020248, def adiiejedjbehefcaaaebdiefcfehbfgf(I):
  boundary = mapply(box, objects(I, True, False, False))
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, boundary))
  return paint(O, recolor(ONE, difference(ofcolor(I, ONE), boundary)))
 
24.666666666666668, 7.2199526, def adbigdabaeccegecbifadeefcbffhbbi(I):
  objs = objects(I, True, False, False)
  shifted_objs = frozenset({shift(obj, (0,1)) for obj in objs if color(obj) == 1})
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
26.0, 7.5215116, def idiaafaebiidefecajefbgfddgddfcef(I):
    O = I
    for obj in objects(I, True, False, False):
        if color(obj) == 1:
            shifted_obj = shift(obj, (0, 1))
            O = paint(cover(O, obj), shifted_obj)
    return O
 
32.0, 10.760543, def gfbgeecggeddebcbbaheajafdeeehejc(I):
  bg = mostcolor(I)  # Identify background color
  objs = objects(I, True, False, True)  # Extract objects
  h = height(I)  # Get the height of the grid
  shifted_objs = frozenset(shift(obj, (-uppermost(obj), 0)) for obj in objs)  # Shift each object upwards
  recolored_objs = frozenset(recolor(2, obj) for obj in shifted_objs)  # Recolor objects
  O = paint(canvas(bg, (h, width(I))), merge(recolored_objs))  # Paint on a blank canvas
  return O
 
26.666666666666668, 20.52847, def cfdjbcacbacceafeifebcafibabbdabd(I):
  objs = objects(I, True, False, False)
  for obj in objs:
    if color(obj) == 1:
      I = paint(I, recolor(2, shift(toindices(obj), RIGHT)))  
  O = replace(I, 5, 0)
  O = replace(O, 0, 0)
  for d in palette(O) - {0, 1, 2}:
    O = replace(O, d, 0)
  return O
 
20.0, 6.515234, def edddbbbbajjfeeeaigdchijfgdbfbdah(I):
    components = objects(I, T, F, F)  # Find connected components of '1's
    border_cells = set()
    for component in components:
        for cell in toindices(component):
            for neighbor in dneighbors(cell): 
                if 0 <= neighbor[0] < len(I) and 0 <= neighbor[1] < len(I[0]) and index(I, neighbor) != ONE:
                    border_cells.add(neighbor)
    O = fill(canvas(ZERO, shape(I)), TWO, frozenset(border_cells)) # Create canvas and fill border cells
    return paint(O, merge(components))  # Paint original '1' components back 
 
44.0, 30.530863, def idgihgbefbebebacadcahdadgcdfbhff(I):
  one_indices = ofcolor(I, ONE)  # Find all '1' indices
  border_indices = set()
  for i, j in one_indices:
    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:  # Check four directions
        ni, nj = i + di, j + dj
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]):  # Within grid bounds
          if (ni, nj) not in one_indices:
            border_indices.add((ni, nj))
  canvas_grid = canvas(ZERO, shape(I))  # Create a blank canvas
  O = fill(canvas_grid, TWO, frozenset(border_indices))  # Fill the border indices with '2'
  return paint(O, toobject(one_indices, I))  # Paint the original '1's back onto the canvas
 
30.0, 16.166132, def eaebgbedffbfeajfijbcfhfahaecdgeb(I):
  objs = objects(I, True, True, False)  # Find objects, including diagonals
  O = canvas(ZERO, shape(I))  # Initialize output with zeros
  for obj in objs:
    if color(obj) == ONE:
      O = paint(O, recolor(TWO, box(obj)))  # Draw outline
  return O
 
27.333333333333332, 7.2548623, def ajjiejgejeebegcijgjhcfaaidjbdbgj(I):
  O = I  # Modify input grid directly
  for i, j in asindices(I):
    if I[i][j] == ONE:
      if any(index(I, (k, l)) != ONE for k, l in neighbors((i, j))):
        O = fill(O, TWO, {(i, j)}) # Outline if neighbor is not '1'
      else:
        O = fill(O, ZERO, {(i, j)}) # Fill interior with '0'
  return O 
 
26.0, 5.9461646, def fbifafaifjjbeceajabffigbcafhcdeh(I):
    O = canvas(ZERO, shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == ONE and any(I[k][l] != ONE for k, l in neighbors((i, j)) if 0 <= k < len(I) and 0 <= l < len(row)):
                O = fill(O, TWO, {(i, j)}) 
    return O
 
30.333333333333332, 16.530258, def icdhjijjefbcefjbjbhaaafdffdfcbdf(I):
  O = replace(I, ONE, ZERO) # Replace all '1's with '0's
  for obj in objects(I, True, True, False):
    if color(obj) == ONE:
      for i, j in box(obj): # Iterate over outline indices
        if 0 <= i < len(I) and 0 <= j < len(I[0]): # Boundary check
          O = fill(O, TWO, {(i, j)}) 
  return O
 
26.0, 9.472299, def hjeedgacjbceeedjaeahfibhgdejgeab(I):
  # Create a copy of the input grid
  O = [list(row) for row in I]
  # Iterate through the grid
  for i in range(len(I)):
    for j in range(len(I[0])-1):
      # If a cell contains a '1'
      if I[i][j] == 1:
        # Shift the '1' to the right
        O[i][j] = 0
        if j+1 < len(I[0]):
            O[i][j+1] = 2
  # Convert the modified grid back to a tuple of tuples
  return tuple(tuple(row) for row in O)
 
26.666666666666668, 20.52847, def ciccahjbahdceffcbddgceebebcabdaj(I):
    return tuple(
        tuple(
            2 if (i, j - 1) in ofcolor(I, 1) else v
            for j, v in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
20.333333333333332, 20.52014, def dbadjdaiieafegdgaccacjegebacgffa(I):
    bg = mostcolor(I)
    shifted_objects = frozenset(
        frozenset(
            (2, (i - (lowermost(obj) - uppermost(obj)), j)) for v, (i, j) in obj
        ) for obj in objects(I, True, False, True)
    )
    return paint(canvas(bg, shape(I)), merge(shifted_objects))
 
52.333333333333336, 17.719666, def jeafjhdfadieehjcacfgeiaadehjdbif(I):
  O = replace(I, FIVE, ZERO)  # Replace '5's with '0's to avoid conflicts
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE:  
        for di in [-1, 0, 1]: # loop through neighbor offsets
          for dj in [-1, 0, 1]:
            ni, nj = i + di, j + dj  # calculate neighbor indices
            if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == ZERO: 
              O = fill(O, TWO, {(ni, nj)}) # fill if valid and empty in the original grid
  return O
 
26.0, 11.580774, def aaeagfidhjeheeedaaheeaeadffbdbcg(I):
  objs = objects(I, True, True, False) # Identify objects of connected '1's
  outline_objs = sfilter(objs, lambda obj: size(intersection(delta(obj), ofcolor(I, ZERO))) > 0) # Filter objects with adjacent '0's 
  outline = mfilter(outline_objs, lambda obj: delta(obj)) # Extract outline indices
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, outline)) # Paint outlines on a blank canvas
  return O 
 
46.666666666666664, 11.727947, def cbbibidbfjdbejfbacdcaeaiabcaagdb(I):
  on_cells = ofcolor(I, ONE) # Get indices of all '1's
  outline = frozenset(n for cell in on_cells for n in neighbors(cell) if index(I, n) == ZERO) # Find adjacent '0's to '1's
  O = paint(canvas(ZERO, shape(I)), recolor(TWO, outline))
  return O
 
18.666666666666668, 10.713317, def fbgeaaehchcaebbcieddcbgicaideaad(I):
    O = canvas(0, shape(I))  # Initialize output grid with '0's
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == 1:
                if j > 0 and I[i][j - 1] == 1:  # Check if previous cell was a '1'
                    O = fill(O, 2, {(i, j)})
                else:
                    O = fill(O, 1, {(i, j)})
    return O
 
18.666666666666668, 7.140097, def cabaegfdechieiadicijhbfedcbcafba(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Extract objects
  ones = sfilter(objs, lambda obj: color(obj) == 1) # Filter '1' objects
  O = canvas(0, shape(I)) # Initialize output grid with '0's
  for obj in ones:
    indices = toindices(obj)
    for k, (i, j) in enumerate(sorted(indices, key=lambda x: x[1])): # Sort indices by column
      O = fill(O, 1 if k == 0 or k > 1 else 2, {(i, j)}) # Apply pattern
  return O
 
25.333333333333332, 19.889013, def edccfcbbdadfeadgibbafddhidfajeha(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    start = -1
    for j, value in enumerate(row):
      if value == 1 and start == -1:
        start = j
      elif value != 1 and start != -1:
        O = fill(O, 1, {(i, start)})
        if j - start > 1:
          O = fill(O, 2, {(i, start + 1)})
          O = fill(O, 1, {(i, k) for k in range(start + 2, j)})
        elif j - start == 1:
          O = fill(O, 2, {(i, start + 1)})
        start = -1
    if start != -1:
      O = fill(O, 1, {(i, start)})
      if len(row) - start > 1:
        O = fill(O, 2, {(i, start + 1)})
        O = fill(O, 1, {(i, k) for k in range(start + 2, len(row))})
      elif len(row) - start == 1:
        O = fill(O, 2, {(i, start + 1)})
  return O
 
13.333333333333334, 10.79606, def iacdfafibefdeaidjfbchbifbgecfcca(I):
    O = canvas(0, shape(I))
    for i, row in enumerate(I):
        for j in range(len(row) - 1):
            if row[j] == 1 and row[j + 1] == 1:
                O = fill(O, 1, {(i, j)})
                O = fill(O, 2, {(i, j + 1)})
                k = j + 2
                while k < len(row) and row[k] == 1:
                    O = fill(O, 1, {(i, k)})
                    k += 1
                break
            elif row[j] == 1:
                O = fill(O, 1, {(i, j)})
    return O
 
20.0, 12.498048, def edbfjadhdddbegdfjhjcdejdabhjcehj(I):
    O = I
    for i, row in enumerate(I):
        for j in range(len(row) - 1):
            if row[j] == 1 and row[j+1] == 1:
                O = fill(O, 2, {(i, j+1)})
    return O
 
37.0, 22.04906, def fcecebgddcbfeacgaghdcfaceccgfgic(I):
  ones = ofcolor(I, ONE) # Get indices of all '1's
  surrounding = frozenset({n for loc in ones for n in dneighbors(loc) if index(I, n) == ZERO}) # Find surrounding '0's
  return fill(canvas(ZERO, shape(I)), TWO, surrounding) # Fill surrounding cells with '2's on a blank canvas
 
42.666666666666664, 32.122433, def efdabebbcffgedbejhihcadbecfafbjf(I):
    O = canvas(ZERO, shape(I)) # Create a blank canvas
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == ONE: # If cell is part of an object
                for di, dj in [(0,1),(1,0),(0,-1),(-1,0)]: # Check direct neighbors
                    ni, nj = i + di, j + dj
                    if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == ZERO: # If neighbor is within bounds and is a '0'
                        O = fill(O, TWO, {(ni, nj)}) # Fill that neighbor with '2'
    return paint(O, toobject(ofcolor(I, ONE), I)) # Paint original '1's onto the canvas
 
44.333333333333336, 23.65157, def jdbfheffbcbjebjbihcjhecbfdhiefia(I):
  objs = objects(I, T, F, T) # Identify objects of '1's
  return paint(fill(canvas(ZERO, shape(I)), TWO, merge(apply(lambda o: outbox(toindices(o)), objs))), toobject(merge(apply(toindices, objs)), I)) # Fill outbox of each object with '2's and paint original objects back
 
19.0, 6.9096336, def dgcfhffegafeecgcjbchfaddebgeceee(I):
  O = I
  for obj in objects(I, T, F, F):
    if contained(FIVE, palette(obj)):
      for x in ofcolor(I, ONE):
        if any(dneighbors(x) & ofcolor(I, FIVE)):
          O = paint(fill(O, ZERO, toindices(obj)), recolor(TWO, {x}))
  return O
 
13.0, 28.197634, def ajbcgiebcjededfaijdbaeccdadehdcf(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        if j < width(I) - 1 and I[i][j + 1] == 1:
          O = fill(O, 2, {(i, j + 1)})
        elif j > 0 and I[i][j - 1] == 1:
          O = fill(O, 1, {(i, j)})
  return O
 
27.333333333333332, 16.081564, def cafefeeiidcbehecbggebcifcaffcfbe(I):
  O = canvas(0, shape(I)) # Initialize with '0's
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == 1 and width(obj) > 1: # Only consider horizontal '1' lines 
      shifted_obj = shift(obj, (0, 1)) # Shift the object right
      O = paint(O, recolor(2, {(v, (i, j)) for v, (i, j) in shifted_obj if j > 0})) # Paint shifted object with '2's except the first cell
      O = paint(O, recolor(1, {(v, (i, j)) for v, (i, j) in obj if j < width(I) - 1})) # Paint original object with '1's except the last cell
  return O
 
34.0, 5.8052983, def jecfgbbcdihdehbajdhafbbagddabdge(I):
    bg = mostcolor(I)  # Identify background color
    objs = objects(I, True, False, True)  # Identify objects
    shifted_objs = frozenset(shift(obj, (-1, 0)) for obj in objs)  # Shift each object upwards
    recolored_objs = frozenset(recolor(2, obj) for obj in shifted_objs)  # Recolor each object to 2
    return paint(canvas(bg, shape(I)), merge(recolored_objs))  # Paint on canvas and merge
 
18.666666666666668, 24.127672, def chbdaahhbhffeecaihidhadgdceebdfh(I):
  O = replace(I, 5, 0)
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1 and (I[min(i+1, height(I)-1)][j] == 5 or I[max(i-1, 0)][j] == 5 or I[i][min(j+1, width(I)-1)] == 5 or I[i][max(j-1, 0)] == 5):
        O = paint(O, recolor(2, {(i, j)}))
        O = paint(O, recolor(2, {(min(i+1, height(I)-1), j)}))
        O = paint(O, recolor(2, {(max(i-1, 0), j)}))
        O = paint(O, recolor(2, {(i, min(j+1, width(I)-1))}))
        O = paint(O, recolor(2, {(i, max(j-1, 0))}))
  return replace(O, 1, 0)
 
16.333333333333332, 34.158146, def dcabfdihebhheijgbjgbecfigafjddde(I):
  O = canvas(0, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1:
        if any(index(I, (i+di, j+dj)) == 5 for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
          O = paint(O, recolor(2, {(i, j)}))
          for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
            if 0 <= i+di < height(I) and 0 <= j+dj < width(I) and I[i+di][j+dj] == 5:
              O = paint(O, recolor(2, {(i+di, j+dj)}))
  return O
 
15.0, 36.745926, def gcdiabcabahfebdiaadedgebhcfibbad(I):
  fives = ofcolor(I, 5)
  connected_ones = objects(I, True, False, False)
  to_replace = set()
  for one_obj in connected_ones:
    if color(one_obj) == 1:
      for one_cell in toindices(one_obj):
        if any(manhattan(initset(one_cell), initset(five_cell)) == 1 for five_cell in fives):
          to_replace.add(one_cell)
  O = replace(I, 5, 0)
  O = paint(O, recolor(2, frozenset(to_replace)))
  return replace(O, 1, 0)
 
23.0, 16.40467, def eeejehhecbdeehhcaahdeebgffffbefd(I):
  O = canvas(ZERO, shape(I)) # Initialize output canvas
  for obj in objects(I, T, F, T):
    O = fill(O, TWO, delta(toindices(obj))) # Fill surrounding cells for each object
  return O
 
38.333333333333336, 22.059538, def efjhbhgffdjeefagijcjfffaagfbdcde(I):
  surrounding = set()
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == ONE: # If cell is part of an object
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]: # Check direct neighbors
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] != ONE:
            surrounding.add((ni, nj))
  return fill(canvas(ZERO, shape(I)), TWO, frozenset(surrounding))
 
34.0, 11.128895, def adefbebebgbbegcciicgeabiefggafaf(I):
  objs = objects(I, True, False, False) # Get connected components of 1s.
  shifted_objs = frozenset({shift(obj, (0,1)) for obj in objs if color(obj) == 1}) # Shift each component by 1
  O = paint(canvas(0, shape(I)), merge(shifted_objs)) # Paint the shifted components onto a blank canvas
  O = cellwise(I, O, 2) # Use cellwise to replace the original 1s with 2s
  return O
 
33.0, 7.050155, def hgedfdjbfeabeedcbbeeaaeedecbgdfe(I):
  return paint(
      canvas(mostcolor(I), shape(I)), 
      frozenset(
          (2, (i - 1, j)) 
          for i, row in enumerate(I) 
          for j, v in enumerate(row) 
          if v == 1 and i > 0
      )
  )
 
19.0, 6.9096336, def dbjadcadcdjdedeajececgcgafbfhbji(I):
  border_indices = set()
  for obj in objects(I, True, False, False):
    if color(obj) == 1:
      for ij in toindices(obj):
        for neighbor in dneighbors(ij):
          if index(I, neighbor) == 5:
            border_indices.add(ij)
  O = replace(I, 5, 0)
  return paint(O, recolor(2, frozenset(border_indices))) 
 
24.666666666666668, 10.351868, def fdbfbejaagcjegfabecgbfagiiddjaae(I):
  objs = objects(I, T, F, T)
  filled = I
  for obj in objs:
    filled = fill(filled, ZERO, toindices(obj))
    filled = fill(filled, TWO, delta(toindices(obj)))
  return filled
 
18.666666666666668, 5.710827, def jhajgdigadeeeahabbbfdjgjcbfhcedj(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, F):
    if color(obj) == FIVE:
      O = paint(O, recolor(ZERO, obj))
      for loc in toindices(obj):
        for n in dneighbors(loc):
          if index(I, n) == ONE:
            O = paint(O, {(TWO, n)})
    else:
      O = paint(O, obj)
  return O
 
25.333333333333332, 23.458742, def daafgdbbdbajeefcjafaabedjcfbcfff(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1 and (j == 0 or row[j-1] != 1):
        O = paint(O, {(1, (i, j)), (2, (i, j + 1)), (1, (i, j + 2))})
  return O
 
21.333333333333332, 19.750551, def hbadcfacacaeehfbaffeaaefjcgcdagj(I):
  O = canvas(0, shape(I))
  for i in range(height(I)):
    j = 0
    while j < width(I):
      if I[i][j] == 1:
        O = paint(O, {(1, (i, j)), (2, (i, j + 1)), (1, (i, j + 2))})
        j += 2  # Skip the next cell as it's already handled
      j += 1
  return O
 
33.666666666666664, 7.4800806, def iibcfbbdjafcebgjibcjefidhdfcchji(I):
  ones = ofcolor(I, 1)
  filtered_ones = frozenset(
      (i, j) for i, j in ones if (j == 0 or (i, j - 1) not in ones)
  )
  pattern = {(0, (0, 0)), (1, (0, 1)), (0, (0, 2))} 
  transformed = mapply(lambda loc: shift(recolor(2, pattern), loc), filtered_ones)
  return paint(canvas(0, shape(I)), transformed)
 
13.0, 23.386662, def fibeiffefdabefdfjjedjebdacagiice(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j in range(width(I) - 2):
      if row[j:j+3] == (1,1,1):
        O = paint(O, {(1, (i, j)), (2, (i, j + 1)), (1, (i, j + 2))}) 
  return O
 
25.333333333333332, 8.624745, def ejbbfbfbbdfieddfacedgcabhccedefa(I):
  ones = recolor(ONE, ofcolor(I, ONE))
  return paint(
    replace(I, FIVE, mostcolor(I)), 
    shift(ones, (-1, 0))
  )
 
16.333333333333332, 33.746803, def afiaejedadfjeecjbcfeaffaechcgeje(I):
  ones = objects(I, True, False, False)
  border =  frozenset(ij for obj in ones if color(obj) == 1 for ij in toindices(obj) if any(index(I, n) == 5 for n in dneighbors(ij)))
  return paint(replace(I, 1, 0), recolor(2, border))
 
34.333333333333336, 25.17794, def hhfaghbebiebedefbdgccfidcedacbbh(I):
  objs = objects(I, T, F, T)
  outlines = mapply(lambda o: box(toindices(o)), objs) 
  return fill(I, TWO, outlines)
 
19.0, 5.884684, def adfebcajdfhceedaaebbaeafeiedbacc(I):
  new_grid = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == FIVE:
        new_grid = fill(new_grid, ZERO, {(i, j)})
        new_grid = underfill(new_grid, TWO, dneighbors((i, j)))
      else:
        new_grid = fill(new_grid, val, {(i, j)})
  return new_grid 
 
13.0, 24.613596, def djjiddjdiicgebadifdgaaaaffcaiaja(I):
  h, w = shape(I)
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w - 1): 
      if I[i][j] == 1 and I[i][j + 1] == 1:
        O = fill(O, 1, {(i, j), (i, j + 1)})
  return replace(O, 1, 2)
 
