12.666666666666666, 20.710733, def cecechbfbchjebidjgehgfegbchdehac(I):
  """
  Finds objects made of '2', replaces internal '0's with '1's
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  twos = colorfilter(objs, 2)
  for obj in twos:
    O = underfill(I, 1, toindices(obj))
  return O
 
42.0, 20.71745, def ahfjdcheecjiejddiiejeaicabeefdhd(I):
  """
  Iterates through grid cells, modifies if within a '2' object
  """
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2 or index(I, astuple(i, j)) == 2 and index(I, astuple(i, j)) == 0:
        O = paint(O, {(1, (i, j))})
      else:
        O = paint(O, {(val, (i, j))})
  return O
 
78.0, 80.619064, def ediaaehhgccfejddbdcbdccgaaddfeid(I):
  """
  Recursively explores '2' objects, filling with '1's
  """
  def fill_object(grid, i, j):
    if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] in (0, 2):
      grid = fill(grid, 1, {(i, j)})
      for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
        grid = fill_object(grid, i + di, j + dj)
      return grid
    return grid

  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = fill_object(O, i, j)
  return O
 
26.0, 9.894936, def caafcehhdhfheecdicfcghafdigjjibf(I):
  objs = objects(I, T, F, F)  # Extract connected components of any digit
  twos = colorfilter(objs, 2)  # Filter objects to get only those containing '2'
  indices = mapply(toindices, twos) # Get indices of all '2' objects
  neighbors = mapply(dneighbors, indices) # Find direct neighbors of all '2' indices
  filtered_neighbors = difference(neighbors, indices) # Exclude indices of '2' themselves
  O = fill(I, 1, filtered_neighbors)  # Fill the neighbor indices with '1'
  return O 
 
21.0, 5.731722, def hdgecbabaiideeacaeadaccfdccafdha(I):
  objs = partition(I)  # Partition grid into objects based on same value
  twos = colorfilter(objs, 2)  # Filter for objects of '2's
  surrounding = mapply(delta, twos)  # Get indices surrounding each '2' object 
  O = fill(I, 1, surrounding)  # Fill surrounding indices with '1'
  return O
 
22.0, 9.341531, def ggafjdddcbabeeefbffjbhcbhegaiecf(I):
  modified = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 2:  # Check for '2'
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Direct neighbor offsets
          if I[i+di][j+dj] == 0: # Check if neighbor is '0'
            modified = fill(modified, 1, {(i+di, j+dj)}) # Change '0' to '1'
  return modified
 
12.333333333333334, 6.555199, def ecidfjcbegdiegajagdebgfcfbaafcfa(I):
    O = I
    for obj in objects(I, T, T, T):
        O = underfill(O, ONE, inbox(toindices(obj))) # Directly underfill the inbox of each object
    return O
 
11.0, 12.340655, def hcchecdhdcddeaajacehbfbfeidbhfcj(I):
    modified_grid = I
    for obj in objects(I, T, T, T):
      for i in range(uppermost(obj) + 1, lowermost(obj)): # Iterate through rows within object bounds
        for j in range(leftmost(obj) + 1, rightmost(obj)): # Iterate through columns within object bounds
          if (i,j) not in toindices(obj): # Check if cell is within inbox
            modified_grid = fill(modified_grid, ONE, {(i, j)}) # Fill the inbox cell
    return modified_grid
 
23.0, 9.093307, def cbfbecjcdiaeeifejdedbaciefbbdiae(I):
  objs = objects(I, T, T, T)
  inboxes = apply(lambda obj: delta(toindices(obj)), objs) # Calculate delta (inbox) for each object
  return fill(I, ONE, merge(inboxes)) # Fill all delta indices with '1'
 
21.0, 5.731722, def bbeibfadddedefeiiffijfheddafhbff(I):
  # Partition the grid based on color, excluding background.
  x1 = fgpartition(I)
  # Select the partition corresponding to the color 2.
  x2 = extract(x1, lambda x: color(x) == TWO)
  # Get the indices of the cells within the selected partition.
  x3 = toindices(x2) 
  # Find the 'delta' (border) indices of the partition.
  x4 = delta(x3)
  # Fill the border indices with 1.
  x5 = fill(I, ONE, x4) 
  # Overwrite the original partition with 2s.
  O = paint(x5, x2) 
  return O
 
21.0, 5.731722, def hcaafaciiiafegcciaeedefecjaeeejj(I):
    # Find all objects made of '2'
    objs = objects(I, T, F, T)
    # Find the largest object
    largest_obj = argmax(objs, size)
    # Fill the background within the bounding box of the largest object with '1'
    O = underfill(I, ONE, backdrop(toindices(largest_obj)))
    return O
 
48.666666666666664, 17.986801, def jgfcaffcejfcejcdaajcaebgfbcebcdg(I):
    # Find the largest object
    largest_obj = argmax(partition(I), size)
    # Fill the background within the bounding box of the largest object with '1'
    O = underfill(I, ONE, backdrop(toindices(largest_obj)))
    return O
 
69.66666666666667, 24.66901, def djeeeecafajiedehaiegdhbfaedibfai(I):
    # Create a canvas of '1's with the same dimensions as the input
    canvas_one = canvas(ONE, shape(I))
    # Find indices of the digit '2'
    two_indices = ofcolor(I, TWO)
    # Fill the canvas with '0's outside the bounding box of '2' indices
    O = fill(canvas_one, ZERO, delta(two_indices))
    return O
 
26.0, 9.894936, def cgejacgfdjcaeebiadaehihgefcadfcd(I):
  """
  Finds '2' cells and their '0' neighbors, replacing the latter with '1'.
  """
  twos = ofcolor(I, 2)  # Get indices of all '2' cells.
  zeros = ofcolor(I, 0)  # Get indices of all '0' cells.
  neighbors_of_twos = mapply(dneighbors, twos)  # Find all direct neighbors of '2' cells.
  target_indices = intersection(neighbors_of_twos, zeros)  # Find '0' cells neighboring '2' cells.
  O = fill(I, 1, target_indices)  # Replace target '0' cells with '1'.
  return O
 
27.333333333333332, 18.76584, def dhgabiddfgcdeciaaaacicdgbbbdaahi(I):
    padded_grid = ((0,) * (len(I[0]) + 2),) + tuple((0,) + row + (0,) for row in I) + ((0,) * (len(I[0]) + 2),) # Pad the grid with zeros
    shifted_grids = (shift(asobject(padded_grid), (1, 0)), shift(asobject(padded_grid), (-1, 0)), shift(asobject(padded_grid), (0, 1)), shift(asobject(padded_grid), (0, -1))) # Create shifted versions of the grid
    merged_grid = paint(paint(paint(paint(canvas(0, shape(I)), shifted_grids[0]), shifted_grids[1]), shifted_grids[2]), shifted_grids[3]) # Merge shifted grids
    O = cellwise(I, merged_grid, 1) # Replace 0's in the merged grid with 1's where the original grid has values other than '2'
    return O
 
16.333333333333332, 4.999159, def adcfedbfbeeheaacihdgabaecadibfgb(I):
    return paint(I, merge(apply(lambda obj: recolor(ONE, inbox(toindices(obj))), objects(I, T, T, T))))
 
50.333333333333336, 46.02379, def fhdjdbcecdbeecbfbgchhbgfeidchadc(I):
    return fill(I, ONE, difference(
        merge(apply(lambda o: backdrop(toindices(o)), objects(I, T, T, T))),
        merge(objects(I, T, T, T))
    ))
 
11.666666666666666, 5.1302547, def edfddjhciefceigjababbegeahgafbji(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    O = paint(O, recolor(ONE, inbox(toindices(obj))))
    O = paint(O, toobject(toindices(obj), I))
  return O
 
22.0, 13.843826, def afheccifgdfhedeeaghebjbcajffjjce(I):
  # Find all objects made of '2'
  objs = objects(I, T, F, T)
  # Iterate through each object
  for obj in objs:
    # Get the indices of the object's corners
    corners_indices = corners(toindices(obj))
    # Fill diagonally from each corner
    for corner in corners_indices:
      I = underfill(I, ONE, shoot(corner, UP_RIGHT))
      I = underfill(I, ONE, shoot(corner, DOWN_LEFT))
  # Return the transformed grid
  return I 
 
28.333333333333332, 9.991029, def ghhaebdidjefeaaeijadhebdebeaadgj(I):
  # Find all indices of '2'
  indices_2 = ofcolor(I, TWO)
  # Get the diagonal neighbors of all '2' indices
  diag_neighbors = mapply(ineighbors, indices_2)
  # Fill the background cells at diagonal neighbor indices with '1'
  O = underfill(I, ONE, diag_neighbors)
  return O
 
14.666666666666666, 5.138593, def gbbcaiajabfcecabaceegafcbfbjabbd(I):
  # Find objects
  objs = objects(I, T, F, T)
  # Create a set to store indices to fill
  fill_indices = set()
  # Iterate through objects
  for obj in objs:
    # Get bounding box indices
    bbox = backdrop(toindices(obj))
    # Iterate through bounding box indices
    for i, j in bbox:
      # Check if index is a diagonal neighbor of the object
      if ((i - 1, j - 1) in toindices(obj) or
          (i - 1, j + 1) in toindices(obj) or
          (i + 1, j - 1) in toindices(obj) or
          (i + 1, j + 1) in toindices(obj)):
          fill_indices.add((i, j))
  # Fill the background at the collected indices
  O = underfill(I, ONE, frozenset(fill_indices))
  return O
 
46.666666666666664, 19.550734, def jaghffcaabfieaegjcdbiefjfjafcffb(I):
  # Find objects
  objs = objects(I, T, F, T)
  # Create a grid to store the fill pattern
  fill_grid = canvas(ZERO, shape(I))
  # Iterate through objects
  for obj in objs:
    # Get the bounding box of the object
    bbox = backdrop(toindices(obj))
    # Fill the diagonal lines within the bounding box
    for i, j in bbox:
      if (i + j) % 2 == (ulcorner(bbox)[0] + ulcorner(bbox)[1]) % 2:
        fill_grid = fill(fill_grid, ONE, {(i, j)})
  # Combine the fill pattern with the original grid 
  O = cellwise(fill_grid, I, ONE)
  return O
 
12.666666666666666, 20.710733, def bbdejdifejadeafijaefcccabedacdab(I):
  # Define a lambda function to check for diagonal adjacency to '2'
  is_diag_neighbor = lambda x: len(intersection(ineighbors(x), ofcolor(I, TWO))) > 0 
  # Get all background indices
  bg_indices = ofcolor(I, mostcommon(I)) 
  # Filter background indices to get those diagonally adjacent to '2'
  fill_indices = sfilter(bg_indices, is_diag_neighbor)
  # Fill the background at the filtered indices with '1'
  O = underfill(I, ONE, fill_indices)
  return O 
 
48.666666666666664, 17.986801, def fdfecdbadfdhebfbaicfccfhejeafhde(I):
  modified_grid = canvas(1, shape(I))  # Create a grid filled with '1's, having the same dimensions as the input.
  twos = ofcolor(I, 2)  # Find indices of all '2's in the input grid.
  O = paint(modified_grid, recolor(2, twos))  # Paint '2's onto the new grid at their corresponding locations from the input.
  return O
 
40.666666666666664, 30.426495, def abgddjdhejcbebegiedghchjiaacjfae(I):
    return cellwise(I, paint(canvas(ZERO, shape(I)), merge(apply(lambda obj: recolor(ONE, inbox(obj)), objects(I, T, T, T)))), ONE)
 
26.0, 9.894936, def dddfdcegaefaeejgihbabadccaheajaj(I):
  objs = objects(I, T, F, T)
  fill_indices = set()
  for obj in objs:
    for i, j in toindices(obj):
      neighbors = dneighbors((i, j))
      for ni, nj in neighbors:
        if (ni, nj) not in toindices(obj) and 0 <= ni < len(I) and 0 <= nj < len(I[0]):
          fill_indices.add((ni, nj))
  O = underfill(I, ONE, frozenset(fill_indices))
  return O 
 
11.666666666666666, 5.1302547, def feffeahcdjfdehceidafhecefaeecaec(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, ONE, difference(inbox(toindices(obj)), toindices(obj)))
  return O
 
25.333333333333332, 26.349619, def bbhdhchbcdfcebbiihfcafbejjicdeha(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    shifted_objs = (shift(obj, d) for d in (UP, DOWN, LEFT, RIGHT))
    for shifted_obj in shifted_objs:
      O = underpaint(O, shifted_obj)
  return O
 
21.0, 20.04743, def afgdffiifceaefffadfbaaahchfchdbd(I):
    O = I
    for obj in objects(I, False, False, False):
      if color(obj) == 2:
        for i, j in toindices(obj):
          for di, dj in ((1,0), (-1,0), (0,1), (0,-1)):
            ni, nj = i + di, j + dj
            if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
              O = fill(O, 1, {(ni, nj)})
    return O
 
11.333333333333334, 7.04108, def cfdefabggabaebhdabfiaaecggccbada(I):
  O = I
  for obj in objects(I, T, F, T):
    for (i, j) in difference(inbox(toindices(obj)), toindices(obj)):
      if ((i - 1, j - 1) in toindices(obj) or 
          (i - 1, j + 1) in toindices(obj) or
          (i + 1, j - 1) in toindices(obj) or
          (i + 1, j + 1) in toindices(obj)):
        O = fill(O, ONE, {(i, j)})
  return O
 
10.333333333333334, 7.2893558, def cedddeiaaaicejfcijfcfecaebdccfje(I):
  O = I
  for obj in objects(I, T, F, T):
    bbox_indices = inbox(toindices(obj))
    O = fill(O, ONE, frozenset((i, j) for i, j in bbox_indices if any((i + di, j + dj) in toindices(obj) and (i - di, j - dj) in toindices(obj) for di, dj in [(1, 1), (1, -1)])))
  return O
 
15.0, 13.35614, def dcfdfdabggdfeheibbdaahacigaabbjc(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, ONE, frozenset((i, j) for i, j in inbox(toindices(obj)) if any(n in toindices(obj) and (i + 2 * (n[0] - i), j + 2 * (n[1] - j)) in toindices(obj) for n in ineighbors((i, j)))))
  return O
 
10.0, 7.595262, def ediciefcfedieadfbcbdgfdiebffehee(I):
  filled_indices = set()
  for obj in objects(I, T, F, T):
    for i, j in inbox(toindices(obj)):
      for di, dj in [(1, 1), (1, -1)]:
        if (i + di, j + dj) in toindices(obj) and (i - di, j - dj) in toindices(obj):
          filled_indices.add((i, j))
  return underfill(I, ONE, frozenset(filled_indices))
 
12.333333333333334, 6.555199, def iddeceeaahdhefdajgegfijbegjaegef(I):
  O = fill(I, ONE, frozenset())
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    O = underfill(O, ONE,  inbox(toindices(obj)))
  return O
 
21.666666666666668, 4.3028507, def fcadafbccedgejeaaeabdaiegghabhff(I):
  O = I
  for obj in objects(I, T, F, T):
    border = difference(inbox(toindices(obj)), toindices(obj))
    extended_border = mapply(neighbors, border)
    O = underfill(O, ONE, extended_border)
  return O
 
23.666666666666668, 9.380379, def bdjjggjefbdceaffjbhfcbbaadejccah(I):
  O = I
  for obj in objects(I, T, F, T):
    outer_border = difference(outbox(toindices(obj)), toindices(obj))
    O = underfill(O, ONE, outer_border)
  return O
 
15.0, 8.804194, def cfdchddcdacbefhaaifhadfbaejdgjeh(I):
  O = I
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if index(I, (i,j)) == ZERO and any(index(I, (i+di, j+dj)) != ZERO for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        O = fill(O, ONE, {(i, j)})
  return O
 
21.0, 7.6332636, def afadiibadcfeebhhjffabfddbbadbiaf(I):
  return paint(I, merge(apply(lambda obj: recolor(ONE, outbox(obj) - toindices(obj)), objects(I, T, T, T))))
 
41.0, 8.157526, def hdjdjccgigdcehcbbbeebedhfbceggde(I):
    return paint(I, mapply(lambda obj: recolor(ONE, box(toindices(obj))), objects(I, T, T, T)))
 
24.666666666666668, 10.8277, def fbabadfbeadbeibgiaceefgaaaecaecf(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    O = paint(O, recolor(ONE, box(toindices(obj))))
    O = paint(O, toobject(toindices(obj), I))
  return O
 
14.0, 5.2351203, def ecjiaiefiacfedgaidffbedbedfccaid(I):
  O = I
  for obj in objects(I, T, F, T):
    for cell in toindices(obj):
      for direction in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        neighbor = add(cell, direction)
        if neighbor in delta(toindices(obj)):
          O = fill(O, ONE, {neighbor})
  return O
 
12.333333333333334, 7.6904173, def bibfcbgcbcbaefdfaecddcedgdbidbej(I):
  two_indices = ofcolor(I, 2)
  inbox_indices = inbox(two_indices)
  fill_indices = difference(inbox_indices, two_indices)
  O = fill(I, 1, fill_indices)
  return O
 
42.0, 81.70159, def abbbceicbhjaeiafajdgabdccfcfbdjf(I):
  return cellwise(
      I,
      trim(
          cellwise(
              upscale(I, 2), 
              upscale(replace(I, 2, 1), 2), 
              0
          )
      ),
      0
  )
 
12.666666666666666, 20.710733, def fafaecdcbceeefabaijjfaaaaegccbab(I):
  O = canvas(ZERO, shape(I)) 
  for obj in objects(I, T, F, T):
    O = underfill(O, ONE, delta(toindices(obj)))
  return paint(O, asobject(I))
 
42.0, 20.71745, def dfebbddbejjeeddbjffagbjaiecjaceg(I):
    O = I
    for obj in objects(I, T, F, T):
        for c in toindices(obj):
            n = neighbors(c)
            for x in n:
                if index(I, x) == mostcolor(I):
                    O = fill(O, ONE, {c})
                    break
    return O
 
36.333333333333336, 16.278873, def daghehfecdjdedhfjffhcdjgdcfeebhc(I):
  O = I
  for j in range(1, len(I[0]) - 1):
    for i in range(1, len(I) - 1):
      if I[i][j] != mostcolor(I) and any(I[x][y] == mostcolor(I) for x, y in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]):
        O = fill(O, ONE, {(i,j)})
  return O
 
34.333333333333336, 12.04965, def ecfjbidjbdbdecadibdbbcgbecjfbfcg(I):
  outline = set()
  for obj in objects(I, T, F, T):
    shifted_objs = [shift(obj, d) for d in [(0, 1), (0, -1), (1, 0), (-1, 0)]]
    for shifted_obj in shifted_objs:
      outline = outline.union(intersection(backdrop(shifted_obj), asindices(I)))
  outline = outline.difference(merge([toindices(obj) for obj in objects(I, T, F, T)]))
  return fill(I, ONE, outline)
 
20.333333333333332, 39.17604, def fccbiededaaeejbbiddabfjecdjfdife(I):
  objs = objects(I, False, False, False)
  filled_objs = frozenset(
        obj if color(obj) != 2 else recolor(1, difference(inbox(toindices(obj)), toindices(obj)))
        for obj in objs
    )
  O = paint(canvas(0, shape(I)), merge(filled_objs))
  return O
 
14.0, 12.730549, def jbafejbdbbeeecibaeaehgeahfbjjahe(I):
    objs = objects(I, False, False, False)
    O = I
    for obj in objs:
        if color(obj) == 2:
            for i in range(uppermost(obj) + 1, lowermost(obj)):
                for j in range(leftmost(obj) + 1, rightmost(obj)):
                    if index(I, (i, j)) != 2:
                        O = fill(O, 1, {(i, j)})
    return O
 
70.33333333333333, 10.4479685, def baffibaieadhedbfiadaeaibfabafice(I):
    padded_grid = canvas(1, (len(I) + 2, len(I[0]) + 2))  # Create a padded grid with '1's
    padded_grid = tuple(
        tuple(I[i][j] if 0 < i < len(I) and 0 < j < len(I[0]) else 1 for j in range(len(I[0]) + 2))
        for i in range(len(I) + 2)
    )
    O = tuple(
        tuple(
            1 if any(padded_grid[i + di][j + dj] == 2 for di in range(-1, 2) for dj in range(-1, 2)) and padded_grid[i][j] == 0 else padded_grid[i][j]
            for j in range(1, len(padded_grid[0]) - 1)
        )
        for i in range(1, len(padded_grid) - 1)
    )  
    return O
 
42.0, 20.71745, def fejdddeigbcceceabcadgfigacaiacec(I):
  # 1. Find indices of all '2's.
  x1 = ofcolor(I, TWO)
  # 2. Filter for '2's with at least one non-'2' neighbor within the grid bounds.
  x2 = frozenset(
      loc
      for loc in x1
      if any(
          0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] != TWO
          for ni, nj in neighbors(loc)
      )
  )
  # 3. Fill the filtered indices with '1's.
  O = fill(I, ONE, x2)
  return O
 
11.333333333333334, 4.806022, def iafachgbhbbeeeciaecbechbhhceiaef(I):
    objs = objects(I, T, F, T)  # Identify objects, excluding background
    border_cells = mapply(lambda obj: difference(inbox(toindices(obj)), toindices(obj)), objs) 
    O = underfill(I, ONE, border_cells) # Fill interior border cells with '1'
    return O
 
24.333333333333332, 11.229032, def eafjibhidadeefacahhjjcbhdebggdia(I):
  O = I
  for obj in objects(I, T, F, T):
    inner_border = difference(box(toindices(obj)), toindices(obj))
    O = underfill(O, ONE, inner_border)
  return O
 
26.0, 9.894936, def fjbbfjfecebheefdidcbeiagbbccdjca(I):
    O = I
    for obj in objects(I, T, F, T):
        border = mapply(dneighbors, toindices(obj))
        inner_border = sfilter(border, lambda loc: index(I, loc) == mostcolor(I))
        O = fill(O, ONE, inner_border) 
    return O
 
11.666666666666666, 5.1302547, def dcaiabdgiiajeajdibgcdcddfcddcbeh(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, obj)
    border = difference(inbox(toindices(obj)), toindices(obj))
    O = fill(O, ONE, border)
  return O
 
42.0, 20.71745, def fbhdbijajffbeafcbehcaabcfffffdef(I):
  O = I
  for obj in objects(I, T, F, T):
    for (i, j) in toindices(obj):
      if any(index(I, (i + di, j + dj)) == mostcolor(I) for (di, dj) in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        O = fill(O, ONE, {(i, j)})
  return O
 
50.333333333333336, 46.02379, def ghcbfafjbccdefbibfhfcfbfbeaacibf(I):
    return paint(I, merge(apply(lambda obj: recolor(ONE, backdrop(toindices(obj))), objects(I, T, T, T))))
 
12.666666666666666, 20.710733, def dfajfejefefaecdfjdghgbffbhfdcbdg(I):
  return paint(I, merge(apply(lambda obj: toobject(outbox(toindices(obj)), replace(I, color(obj), ONE)), objects(I, T, T, T))))
 
23.0, 9.093307, def cedhdghbddcaejchbacedfdhbaidjcdi(I):
  return paint(I, merge(apply(lambda obj:  recolor(ONE,
                                                  (backdrop(toindices(obj)) -
                                                  toindices(obj))),
                                                  objects(I, T, T, T))))
 
10.333333333333334, 7.025017, def ifeibbeaifgfecddigdhaafbcfgddecc(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    O = paint(O, toobject(toindices(obj), I))
    for cell in difference(inbox(toindices(obj)), toindices(obj)):
      if len(intersection(dneighbors(cell), toindices(obj))) > 0:
        O = paint(O, recolor(ONE, {cell}))
  return O
 
9.666666666666666, 4.497904, def adefeedbfffeejeeieabcdajbccieijd(I):
  O = I
  for obj in objects(I, T, T, T):
    box_indices = difference(inbox(toindices(obj)), toindices(obj))
    for cell in box_indices:
      neighbors_in_obj = intersection(neighbors(cell), toindices(obj))
      if size(neighbors_in_obj) > 0 and size(neighbors_in_obj) < 4:
        O = fill(O, ONE, {cell})
  return O
 
26.0, 9.894936, def fehgcjeabhjaeacciabdccibfhaijeea(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    O = paint(O, toobject(toindices(obj), I))
    for cell in toindices(obj):
      for neighbor in dneighbors(cell):
        if neighbor not in toindices(obj) and index(I, neighbor) == ZERO:
          O = fill(O, ONE, {neighbor})
  return O
 
25.666666666666668, 8.727907, def ebciefgbhcgbeghciceafhdfaebcehih(I):
  O = I
  for obj in objects(I, T, F, T):
    for dx in [-1, 1]:
      O = underfill(O, ONE, shift(toindices(obj), (dx, 0)))
    for dy in [-1, 1]:
      O = underfill(O, ONE, shift(toindices(obj), (0, dy)))
  return O
 
26.0, 9.894936, def decdfdjghbedegbajahacccdbfdcbbec(I):
    objs = objects(I, T, F, T)
    outline = set()
    for obj in objs:
        for i, j in toindices(obj):
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ni, nj = i + di, j + dj
                if (ni, nj) not in toindices(obj) and index(I, (ni, nj)) != color(obj):  # Check if it's a valid outer cell
                    outline.add((ni, nj))
    return fill(I, ONE, frozenset(outline))
 
15.0, 8.804194, def effhdibchjeceiheafbjiibdcafeeeac(I):
    O = I
    for i in range(1, len(I)-1):
        for j in range(1, len(I[0])-1):
            if I[i][j] == mostcolor(I) and (I[i-1][j] != mostcolor(I) or I[i+1][j] != mostcolor(I) or I[i][j-1] != mostcolor(I) or I[i][j+1] != mostcolor(I)):
                O = fill(O, ONE, {(i,j)})
    return O
 
13.0, 9.188101, def aidchedeabihecfdaaaechffdadihfhb(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    O = paint(O, obj)
    for x, y in toindices(obj):
      for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:
        if (x + dx, y + dy) in difference(inbox(toindices(obj)), toindices(obj)):
          if 1 <= size(intersection(neighbors((x + dx, y + dy)), toindices(obj))) < 4:
            O = fill(O, ONE, {(x + dx, y + dy)})
  return O
 
17.333333333333332, 9.513598, def giagbebebjffedeiieaebfbgfdahfbia(I):
    objs = partition(I)  # Partition the grid into objects
    twos = colorfilter(objs, 2)  # Select objects made of '2's
    borders = mapply(inbox, twos)  # Find the inner border of each object
    O = fill(I, 1, borders)  # Fill the borders with '1's
    return O
 
42.0, 20.71745, def cadcfcahhffbebjjabcbbebcdgdddcfh(I):
  objs = partition(I)
  border_cells = set()
  for obj in colorfilter(objs, 2):
    for i, j in toindices(obj):
      neighbors_coords = dneighbors((i, j))
      for n_i, n_j in neighbors_coords:
        if (n_i, n_j) not in toindices(obj):
          border_cells.add((i, j))
          break
  return fill(I, 1, frozenset(border_cells))
 
12.666666666666666, 20.710733, def ahccgcfbfegbeajbjgcfigfdhfffacab(I):
    O = I
    for obj in objects(I, T, F, T):
        border = delta(toindices(obj))
        inner_border = mfilter(border, lambda x: len(intersection(dneighbors(x), toindices(obj))) == 4)
        O = fill(O, ONE, inner_border)
    return O
 
41.0, 8.157526, def efacigahdbdbeddaahiebgcfdecjdbai(I):
  return paint(I, merge(apply(lambda obj: toobject(box(toindices(obj)), fill(I, ONE, box(toindices(obj)))), objects(I, T, T, T))))
 
28.0, 11.904412, def aiiafbaifdhaegajjcgdfibacddfjbac(I):
  O = I
  for obj in objects(I, T, T, T):
    for cell in asindices(I):
      if cell not in toindices(obj) and 1 <= size(intersection(neighbors(cell), toindices(obj))) <= 3:
        O = underfill(O, ONE, {cell})
  return O
 
31.0, 12.651155, def ijccdbihidfgejaiacjccegaaajcdaff(I):
  O = I
  for obj in objects(I, T, T, T):
    outline = set()
    for c in toindices(obj):
      for n in neighbors(c):
        if n not in toindices(obj) and size(intersection(neighbors(n), toindices(obj))) in (1,2,3):
          outline.add(n)
    O = underfill(O, ONE, frozenset(outline))
  return O
 
14.666666666666666, 5.269016, def cbcdcdfcgecaeiedacbdfbhccbddjgab(I):
  objs = partition(I)  # Partition the grid into objects
  target_color = 2  # Define the target color
  surrounding = mapply(
      lambda obj: sfilter(
          delta(obj), 
          lambda loc: index(I, loc) == 0 and any(index(I, n) == target_color for n in dneighbors(loc))
      ), 
      colorfilter(objs, target_color)  # Filter for objects with the target color
  )
  O = fill(I, 1, surrounding)  # Fill the surrounding cells with 1
  return O
 
26.0, 9.894936, def jbffbfheihfaeiacbiciecfbhafcfaac(I):
  twos = ofcolor(I, 2)  # Find all indices of '2's
  neighbors_of_twos = merge(apply(dneighbors, twos))  # Get indices of all neighbors of '2's
  valid_neighbors = intersection(neighbors_of_twos, ofcolor(I, 0))  # Find neighbors that are '0's
  O = fill(I, 1, valid_neighbors)  # Fill valid neighbors with '1'
  return O
 
21.0, 7.6332636, def cfcbdccjiiageafajicfeefageacabaf(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, ONE, difference(outbox(toindices(obj)), delta(toindices(obj))))
  return O
 
55.333333333333336, 23.24691, def ccbihdcejijaecgibchegbhaddbbcbbg(I):
  O = canvas(ZERO, shape(I)) 
  for obj in objects(I, T, F, T):
    expanded_obj = mapply(dneighbors, toindices(obj))
    border = difference(expanded_obj, toindices(obj))
    O = paint(O, recolor(ONE, border))
  return O
 
29.0, 10.366916, def jdaddfhabffeehegbchfdjhbbdgbbjag(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    for cell in toindices(obj):
       for n in neighbors(cell):
         if n not in toindices(obj) and 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]):
           O = underfill(O, ONE, {n})
    O = paint(O, obj)
  return O
 
21.0, 5.731722, def jedabbefeaijebcbibfhhfdacdadbdef(I):
  return underfill(I, ONE, mapply(delta, apply(toindices, objects(I, T, F, T)))) 
 
23.0, 9.093307, def deffaeeeaebhebhcibgfhhabfedeabfj(I):
  return paint(I, 
              frozenset((ONE, idx) 
                       for obj in objects(I, T, F, T) 
                       for idx in delta(toindices(obj))))
 
16.666666666666668, 11.326315, def biieiehacbfdedhcbbcffbjeifffhffd(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, ONE,  intersection(delta(toindices(obj)), backdrop(shift(toindices(obj), (1, 1)))))
  return O
 
12.666666666666666, 8.521191, def bajjefbebacieddbjeefbcdbadjefbfi(I):
  return paint(I, merge(apply(lambda obj: recolor(ONE, delta(toindices(obj)) & inbox(toindices(obj))), objects(I, T, T, T))))
 
31.333333333333332, 19.024689, def aeefcdjcbccaebjeaaghaahfjjecgejc(I):
  shifted_grids = (
      shift(asobject(I), UP),
      shift(asobject(I), DOWN),
      shift(asobject(I), LEFT),
      shift(asobject(I), RIGHT)
  )
  O = I
  for i in range(len(I)):
      for j in range(len(I[0])):
          if I[i][j] == 0 and any((i, j) in toindices(obj) and color(obj) == 2 for obj in shifted_grids):
              O = fill(O, 1, {(i, j)})
  return O
 
22.0, 8.433253, def eecaajdaacbdecabjjdejegiaecbdcfd(I):
    O = canvas(0, shape(I))
    for obj in colorfilter(partition(I), 2):
        O = paint(O, obj)
        for d in (UP, DOWN, LEFT, RIGHT):
            shifted = shift(obj, d)
            O = underpaint(O, recolor(1, shifted)) 
    return O
 
43.333333333333336, 27.020405, def jehbdjcedbdhedhajgefaadiidehcgbf(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, T, F, T):
    border = mapply(dneighbors, toindices(obj)) - toindices(obj)
    O = paint(O, recolor(ONE, intersection(border, backdrop(toindices(obj)))))
  return O
 
24.333333333333332, 11.229032, def dgbbejcfedajeabaaeebfdeddcacibbg(I):
  O = I
  for obj in objects(I, T, T, T):
    outline = difference(box(toindices(obj)), toindices(obj)) 
    O = underfill(O, ONE, outline)
  return O
 
10.0, 12.80749, def djabbiabaacbegfiidabjieghbddabde(I):
  return fill(I, ONE, merge(apply(
      lambda obj: intersection(
          dneighbors(centerofmass(obj)),
          delta(toindices(obj))
      ),
      objects(I, T, F, T)
  )))
 
9.666666666666666, 9.110302, def dccfejbdcbiheeeeibdcghbdejdfcfie(I):
  O = I
  for obj in objects(I, T, F, T):
    dilated = mapply(dneighbors, toindices(obj))
    eroded = mapply(dneighbors, dilated)
    border_cells = difference(dilated, eroded)
    O = underfill(O, ONE, border_cells)
  return O 
 
14.0, 5.2351203, def iebgdcgiieegeajbjdaeigabddefaabg(I):
  O = I  # Initialize the output grid as a copy of the input grid.
  for obj in objects(I, T, T, T):  # Iterate over each object in the input grid.
    for cell in delta(toindices(obj)):  # Iterate over cells in the object's bounding box but not part of the object.
      if 1 <= size(intersection(dneighbors(cell), toindices(obj))) < 4:  # Check if the cell has 1, 2, or 3 neighbors within the object.
        O = fill(O, ONE, {cell})  # If the condition is met, fill the cell with the value '1'.
  return O  # Return the modified output grid.
 
28.333333333333332, 9.991029, def aaebeaachfedehadagehbccbbhbfabhe(I):
  def process_object(obj):
    return mapply(ineighbors, toindices(obj))
  return underfill(I, ONE, merge(apply(process_object, objects(I, T, F, T))))
 
4.666666666666667, 3.981171, def bcbiceedeagiefdcbeiibfabbbdefbjc(I):
  O = I
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if I[i][j] == mostcolor(I) and len(intersection(dneighbors((i, j)), ofcolor(I, other(palette(I), mostcolor(I))))) > 1:
        O = fill(O, ONE, {(i, j)})
  return O
 
33.666666666666664, 9.101324, def gahihbdajbcbedibbedeaggaedeeffbj(I):
  O = I
  for obj in objects(I, T, F, T):
    border = mapply(dneighbors, difference(box(toindices(obj)), toindices(obj)))
    interior_border = intersection(border, toindices(obj))
    O = fill(O, ONE, difference(border, interior_border))
  return O
 
19.666666666666668, 12.9704275, def jdceiddaebefehdjabijcbfgagddache(I):
  def is_interior(obj, idx):
    return both(
        any(add(idx, d) in toindices(obj) for d in ((0, 1), (0, -1))),
        any(add(idx, d) in toindices(obj) for d in ((1, 0), (-1, 0)))
    )
  def fill_interior(obj):
    return recolor(ONE, sfilter(toindices(obj), lambda idx: is_interior(obj, idx)))
  return paint(I, merge(apply(fill_interior, objects(I, T, T, T)))) 
 
25.0, 13.018961, def efafcdhccfbcecdbbfadgahebdbifecb(I):
  """
  Identifies cells within the largest object surrounded by the object's color
  and recolors them to '1'.
  """
  target_color = mostcolor(I) 
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == target_color and all(I[i+di][j+dj] == target_color for di, dj in dneighbors((0, 0)) if 0 <= i+di < len(I) and 0 <= j+dj < len(row)):
        I = fill(I, 1, {(i, j)})
  return I 
 
48.666666666666664, 6.084399, def dbbgafbahhbaefgbbfbbgbahgfcgfgbc(I):
  """
  Finds cells within the largest object that don't share a border with another
  object and recolors them to '1'.
  """
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  target_indices = toindices(largest_obj)
  border_indices = set()
  for obj in objs:
    if obj != largest_obj:
      border_indices.update(toindices(obj))
  recolor_indices = target_indices - border_indices
  return fill(I, 1, recolor_indices)
 
18.0, 17.608475, def ecjfdbcdgiedefedabfacbbdjcbdjahb(I):
  """
  Iterates through cells of the largest object and recolors those with four
  neighbors of the same color. 
  """
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  O = I
  for v, (i, j) in largest_obj:
    if sum(1 for di, dj in dneighbors((0, 0)) if 0 <= i+di < len(I) and 0 <= j+dj < len(I[0]) and I[i+di][j+dj] == v) == 4:
      O = fill(O, 1, {(i, j)})
  return O
 
31.333333333333332, 7.125941, def efddccabajhdegfbigfbibijjcfcjdfe(I):
  """
  Creates a mask by shrinking the largest object and then recolors the difference
  between the original object and the mask.
  """
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  mask_indices = set()
  for v, (i, j) in largest_obj:
    if all(I[i+di][j+dj] == v for di, dj in dneighbors((0, 0)) if 0 <= i+di < len(I) and 0 <= j+dj < len(I[0])):
      mask_indices.add((i, j))
  recolor_indices = toindices(largest_obj) - mask_indices
  return fill(I, 1, recolor_indices) 
 
25.333333333333332, 12.327075, def hbbjfghgcefceaajbeahjfcfbbhdbeii(I):
  def fill_interior(obj):
    return difference(toindices(obj), box(toindices(obj)))
  return paint(I, merge(apply(lambda obj: recolor(ONE, fill_interior(obj)), objects(I, T, T, T))))
 
13.0, 21.01711, def cfbhibhaadfeecbcaibeagadgceaadcc(I):
  shifted_grids = [fill(I, 1, ofcolor(shift(asobject(I), d), 2)) for d in [(1, 0), (-1, 0), (0, 1), (0, -1)]]
  O = I
  for grid in shifted_grids:
    O = cellwise(O, grid, 0)
  return O
 
15.333333333333334, 12.350258, def bcjaddabcbfbebfeacfaeeafjdijbhbd(I):
  target_color = mostcolor(I)
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, size)
  for obj in objs:
    if obj != largest_obj:
      border = difference(inbox(toindices(obj)), toindices(obj))
      for cell in border:
        if all(I[i][j] == target_color for i, j in dneighbors(cell) if 0 <= i < len(I) and 0 <= j < len(I[0])):
          I = fill(I, 1, {cell})
  return I
 
14.333333333333334, 13.411108, def ebdfebfabdddegcaabcadcbcbffehbbd(I):
  target_color = mostcolor(I)
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] != target_color and all(I[x][y] == target_color for x, y in dneighbors((i, j))):
        I = fill(I, 1, {(i, j)})
  return I
 
18.333333333333332, 12.507409, def icgfffedbdddejecbbjicfbhaceejeje(I):
  O = I
  for obj in objects(I, T, T, T):
    outline = sfilter(box(toindices(obj)), lambda cell: any(n in toindices(obj) for n in dneighbors(cell)) and any(n not in toindices(obj) for n in dneighbors(cell)))
    O = underfill(O, ONE, outline)
  return O
 
55.333333333333336, 50.576317, def bgdcfgcfhdbaefeaafbbibfeedfihbec(I):
  def outline_cell(grid, i, j):
    return ONE if any(0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]) and grid[i+di][j+dj] != grid[i][j] for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]) else grid[i][j]
  return tuple(tuple(outline_cell(I, i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
44.333333333333336, 38.590668, def eedecfbafcfbebccjifecfjfedadfcge(I):
  def is_outline(grid, i, j):
    if 0 < i < len(grid)-1 and 0 < j < len(grid[0])-1:
      return int(grid[i][j] != grid[i-1][j] or grid[i][j] != grid[i+1][j] or grid[i][j] != grid[i][j-1] or grid[i][j] != grid[i][j+1])
    return 0
  return tuple(tuple(is_outline(I, i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
5.333333333333333, 4.0230207, def ghedddbibibdeabdjadfcdeffaifejfa(I):
  def check_neighbor(loc):
    return 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]) and I[loc[0]][loc[1]] == 2
  def valid_cell(loc):
    return 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]) and I[loc[0]][loc[1]] == 0 and sum((check_neighbor((loc[0] + di, loc[1] + dj)) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)])) >= 2
  O = [[1 if valid_cell((i, j)) else I[i][j] for j in range(len(I[0]))] for i in range(len(I))]
  return tuple(tuple(row) for row in O) 
 
14.666666666666666, 5.138593, def eadabaghiiddejfebigbdgebbhhcadee(I):
  obj = last(sorted(objects(I, False, False, False), key=rightmost))
  shift_amount = (0, width(I) - rightmost(obj) - 1)
  O = paint(cover(I, obj), shift(obj, shift_amount))
  return O
 
63.0, 70.09237, def iiefbafadbbiefjdijbdhcdhahdcjefe(I):
  objs = objects(I, False, False, False)
  rightmost_obj = argmax(objs, rightmost)
  target_position = (ulcorner(rightmost_obj)[0], width(I)-1)
  shift_amount = subtract(target_position, ulcorner(rightmost_obj))
  O = move(I, rightmost_obj, shift_amount)
  return O
 
43.666666666666664, 76.12516, def ieabebdbcgcaeeedjceejcbgbffaebhj(I):
  filled_grid = fill(I, 0, asindices(I))
  right_column = hsplit(I, width(I))[-1]
  right_obj = extract(objects(right_column, False, False, False), lambda obj: size(obj) > 1) 
  shifted_obj = shift(right_obj, (0, width(I) - width(right_column)))
  O = paint(filled_grid, shifted_obj)
  return O
 
25.333333333333332, 16.654236, def gaddfibiddfgeeeebdgjjdebbfjabeef(I):
  O = I
  for color in palette(I) - {mostcolor(I)}:
    while rightmost(ofcolor(O, color)) < len(O[0]) - 1:
      O = tuple(r[:-1] for r in O)
  return O
 
55.0, 68.82789, def eecdgbgdcfdfeadcagcedaaedafejdjh(I):
  objs = objects(I, True, False, True)
  min_rightmost = min(rightmost(toindices(obj)) for obj in objs)
  return crop(I, (0, 0), (len(I), min_rightmost + 1))
 
20.0, 13.017771, def dfaahbigaifbeffcaaadigdadcdifbce(I):
  one_indices = ofcolor(I, 1)
  target_column = width(I) - 1
  shifted_indices = frozenset((i, target_column) for i, j in one_indices)
  O = fill(fill(I, 0, one_indices), 1, shifted_indices)
  return O
 
16.0, 15.382789, def bhaachedebfdeheajbefdaegbagagdfg(I):
  objs = objects(I, True, False, False)  # Get all objects
  one_objs = colorfilter(objs, 1)  # Filter for objects of color 1
  rightmost_one_objs = {argmax(sfilter(one_objs, lambda obj: uppermost(obj) == i), lambda obj: rightmost(obj)) for i in range(height(I))} - {None}  # Find the rightmost object in each row
  indices_to_remove = merge(apply(toindices, rightmost_one_objs))  # Get indices of cells to remove
  O = fill(I, 0, indices_to_remove)  # Fill the cells with 0
  return O
 
11.333333333333334, 5.0625305, def bcejeeabacfieichbaejbghehfaeccij(I):
  O = tuple(
    tuple(0 if v == 1 and (i, j) == max(((i, j) for j, v in enumerate(r) if v == 1), default=(None, None)) else v for j, v in enumerate(r)) 
    for i, r in enumerate(I)
  )
  return O
 
14.333333333333334, 5.407118, def dhfebieahgicehdeideaebfbeiajddje(I):
  O = I
  for obj in colorfilter(objects(I, True, False, False), 1):
    rightmost_loc = argmax(toindices(obj), lambda x: x[1])
    if rightmost_loc:
      O = fill(O, 0, {rightmost_loc})
  return O
 
46.0, 6.1009545, def fjbcafdadabhehccagfdecdcehhffefj(I):
  objs = objects(I, False, False, False)
  rightmost_obj =  extract(objs, lambda obj: rightmost(obj) == valmax(objs, rightmost))
  return paint(cover(I, rightmost_obj), shift(rightmost_obj, (0, width(I) - width(rightmost_obj) - 1))) 
 
17.666666666666668, 7.4674406, def ejjbhbabejgbejffbcedaacejaaecbdh(I):
    return tuple(tuple(0 if j < len(I[0]) - len(r) + r.count(0) else v for j, v in enumerate(r)) for r in I)
 
25.333333333333332, 10.727504, def bjfdgchfcahdefjfbcbheeccccadbfbc(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    O = fill(O, mostcolor(I), {(i, j) for i, r in enumerate(O) for j in range(len(I[0]) - rightmost(ofcolor(I, c))) if O[i][j] == c})
  return O
 
17.333333333333332, 6.016098, def fcdededfjafhefbbjbbchjdfccejdbea(I):
  objects_list = list(fgpartition(I))
  one_object = next((obj for obj in objects_list if color(obj) == 1), None)
  if one_object:
      objects_list.remove(one_object)
      new_position = (uppermost(one_object), width(I) - width(one_object))
      moved_one_object = shift(one_object, subtract(new_position, ulcorner(one_object)))
      objects_list.append(moved_one_object)
  O = paint(I, merge(objects_list))
  return O
 
16.0, 9.856285, def ecbaajbcdacieidfbadeaeijjceaiedg(I):
  O = tuple(
      tuple(
          branch(
              both(v == 1, j == max(sfilter(interval(0, len(r), 1), lambda x: r[x] == 1), default = -1)),
              1,
              branch(v==1, mostcommon(r), v)
          ) for j, v in enumerate(r)
      ) for i, r in enumerate(I)
  )
  return O
 
34.666666666666664, 23.722298, def hdfiebbbedbaeebdbcdceaigciefijef(I):
  objs = objects(I, T, T, T)
  min_row, min_col = min(uppermost(obj) for obj in objs), min(leftmost(obj) for obj in objs)
  max_row, max_col = max(lowermost(obj) for obj in objs), max(rightmost(obj) for obj in objs)
  return crop(I, (min_row, min_col), (max_row - min_row + 1, max_col - min_col + 1))
 
67.33333333333333, 29.958519, def ejbfhcbeccjfeeeiieebjeefcghccjed(I):
  rows_to_remove = frozenset(i for i, row in enumerate(I) if len(set(row)) == 1)
  cols_to_remove = frozenset(j for j, col in enumerate(dmirror(I)) if len(set(col)) == 1)
  new_grid = tuple(
      tuple(v for j, v in enumerate(row) if j not in cols_to_remove) 
      for i, row in enumerate(I) if i not in rows_to_remove
  )
  return new_grid
 
67.66666666666667, 80.94952, def dfdecgacecibecfdbchficgfcbaeddig(I):
  shifted = I
  for i in range(width(I)):
    shifted = shift(asobject(shifted), (0, 1))
    shifted = paint(cover(canvas(mostcolor(I), shape(I)), asindices(I)), shifted)
  return shifted
 
19.0, 8.187709, def fahddeebhjbbebfgbbhhhbjibcfcebjc(I):
  for obj in fgpartition(I):
    if color(obj) == 1:
      return paint(cover(I, obj), shift(obj, (0, width(I) - rightmost(obj))))
  return I 
 
41.0, 9.992071, def ifdeeaeehdbdebcgacgadcacahfdbebc(I):
  objs = objects(I, T, F, T)  # Get foreground objects
  moved_objs = frozenset()
  for obj in objs:
    leftmost_j = leftmost(obj)
    moved_obj = shift(obj, (0, -leftmost_j))
    moved_objs = combine(moved_objs, moved_obj)
  O = paint(canvas(mostcolor(I), shape(I)), moved_objs)
  return O
 
46.666666666666664, 10.148601, def daeedfcbeaieebfcbjabgbfgddfcaiec(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = cover(O, obj)
    O = paint(O, shift(obj, (0, -leftmost(obj))))
  return O
 
66.66666666666667, 66.654396, def ehbbabbebcfdebdibgeecfeefjfdadie(I):
  O = I
  for j in range(width(I)):
    column = frozenset((I[i][j], (i, j)) for i in range(height(I)))
    if colorcount(column, mostcolor(I)) != height(I):
      O = cover(O, column)
      O = paint(O, shift(column, (0, -j)))
  return O
 
47.0, 9.684887, def abbecaccjfgbeabejcebeadhhccedhhg(I):
  objs = objects(I, True, False, True)
  shifted_objs = set()
  for obj in objs:
    leftmost_j = leftmost(obj)
    left_objs = {other_obj for other_obj in objs if other_obj != obj and leftmost(other_obj) < leftmost_j and hmatching(obj, other_obj)}
    rightmost_j = max({rightmost(other_obj) for other_obj in left_objs} | {0})
    shifted_objs.add(shift(obj, (0, rightmost_j - leftmost_j + 1)))
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
 
45.0, 11.05248, def ajcgiacfhddbefdcahdjabdejdfbagjj(I):
  objs = sorted(objects(I, True, False, True), key=lambda obj: (uppermost(obj), leftmost(obj)))
  grid = canvas(mostcolor(I), shape(I))
  current_j = 0
  for obj in objs:
    grid = paint(grid, shift(obj, (0, current_j - leftmost(obj))))
    current_j += width(obj)
  return grid
 
27.333333333333332, 14.351444, def daecbacadejceccaabhidfcfjajhgajb(I):
  return rot270(tuple(tuple(v for j, v in enumerate(r) if j not in {j for j in range(len(r)) if all(I[i][j] == mostcolor(I) for i in range(len(I)))} ) 
                 for r in rot90(I)))
 
58.0, 18.913858, def ggjecabfjbcfejfebbdeefaehcifbajb(I):
  target_color = leastcolor(I)
  for j in range(width(I) - 2, -1, -1):
    for i in range(height(I)):
      if index(I, (i, j)) == target_color:
        obj_above = extract(objects(crop(I, (0, 0), (height(I), j + 1)), False, False, False), lambda o: (i, j) in toindices(o))
        I = paint(cover(I, obj_above), shift(obj_above, (0, 1)))
  return I
 
30.666666666666668, 6.7599854, def efbceciiehaieebgjjcafcebbdgfjfaa(I):
  least_col = leastcolor(I)
  O = I
  for j in range(width(I) - 2, -1, -1):
    column = frozenset((i, j) for i in range(height(I)))
    for cell in sfilter(column, lambda c: index(I, c) == least_col):
      i, _ = cell
      obj = extract(objects(crop(I, (0, 0), (i + 1, j + 1)), False, False, False), lambda o: cell in toindices(o))
      O = paint(cover(O, obj), shift(obj, (0, 1))) 
  return O 
 
36.0, 13.038062, def gbdjbhefabdeedhbaagacjbcechgjahh(I):
  return tuple(
      tuple(v for v in r if v != mostcolor(I)) + tuple(mostcolor(I) for _ in range(len(I[0]) - len([v for v in r if v != mostcolor(I)])))
      for r in I
  )
 
35.0, 13.477406, def bbddbhgeeaffedbdjbjfbgfejcabbaag(I):
    return tuple(
        tuple(
            value if j >= len(I[0]) - sum(v != mostcolor(I) for v in row) else mostcolor(I)
            for j, value in enumerate(row)
        )
        for row in I
    )
 
46.333333333333336, 12.483844, def ehedfeadgaeaeechiajdggfbdfhdcibh(I):
  return tuple(
      tuple(mostcolor(I) if j < len(I[0]) - len(row) else row[j - (len(I[0]) - len(row))] for j in range(len(I[0])))
      for row in [tuple(v for v in r if v != mostcolor(I)) for r in I]
  )
 
20.0, 8.63791, def iiaejccaaifaeeadbihadcjfbbjgchdb(I):
  obj1 = next((obj for obj in fgpartition(I) if color(obj) == 1), frozenset()) # Find the object with color 1
  if obj1: # Check if the object exists
    shift_amount = width(I) - rightmost(obj1) - 1 # Calculate the shift amount
    shifted_obj = shift(obj1, (0, shift_amount)) # Shift the object
    O = paint(cover(I, obj1), shifted_obj) # Paint the shifted object back onto a clean canvas
  else: 
    O = I # If no object with color 1 is found, return the original grid
  return O
 
15.666666666666666, 6.558115, def dgdfiegbdfhdedfcahfediiibfcfabad(I):
  """
  This version iterates through each object of color '1', 
  finds the rightmost location, and replaces it with the background color.
  """
  O = I
  for obj in colorfilter(objects(I, True, False, False), 1):
    for i, row in enumerate(O):
        for j, val in enumerate(row):
            if (i, j) in toindices(obj) and j == rightmost(obj):
                O = fill(O, mostcolor(I), {(i, j)}) 
  return O
 
16.0, 7.2676167, def dedihhibbgbdedhjihegdbbieecjeeah(I):
  """
  This version uses a more direct approach to identify and replace rightmost cells.
  """
  O = I
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w-1, -1, -1):
        if I[i][j] == 1 and (j == w-1 or I[i][j+1] != 1):
          O = fill(O, mostcolor(I), {(i, j)})
  return O
 
21.666666666666668, 7.960029, def eeedcdaidahbebdgadaibcadbafbcfde(I):
    """
    This version uses a combination of shifting and cropping for transformation.
    """
    O = I
    for obj in colorfilter(objects(I, True, False, False), 1):
        if width(obj) > 1:
            shifted_obj = shift(obj, (0, -1))
            cropped_obj = frozenset((v, (i,j)) for v, (i,j) in shifted_obj if j >= leftmost(obj))
            O = paint(cover(O, obj), cropped_obj)
    return O
 
40.333333333333336, 13.084772, def jiifjbgehaceeaejbdabhcbifefaibhg(I):
  objs = objects(I, T, T, T)
  largest_obj = argmax(objs, size) 
  other_cells = difference(asindices(I), toindices(largest_obj))
  return paint(fill(I, mostcolor(I), other_cells), largest_obj) 
 
36.333333333333336, 12.033837, def fcajdaededjaeaddaabhebfeaadifbfc(I):
  h, w = len(I), len(I[0])
  J = I
  for j in range(w):
    column_cells = frozenset((i, j) for i in range(h))
    column_obj = toobject(column_cells, I)
    most_common_color = mostcolor(column_obj)
    J = fill(J, most_common_color, column_cells)
  return J
 
56.666666666666664, 12.673197, def hafcfeffeccgegdjaefegffefigfdeac(I):
  return tuple(tuple(mostcommon(column) for _ in range(len(column))) for column in zip(*I))
 
71.0, 46.036987, def dgefcbeaddceeieaifhcjccjachaaehj(I):
  objs = objects(I, True, False, True)  # Get unique color objects
  target = (0, width(I)-1) # Define the target location on the right edge
  for i, obj in enumerate(sorted(objs, key=lambda obj: -uppermost(obj))):
    shift_amount = subtract(target, urcorner(obj))  # Calculate shift amount
    I = paint(cover(I, obj), shift(obj, shift_amount))  # Move the object
    target = (target[0] + height(obj), target[1]) # Update target for next object
  return I
 
60.0, 19.914806, def ieafijdbcccgedahafedgfabcefbfjea(I):
    for v in palette(I) - {mostcommon(I)}: # Loop through unique colors
        obj = extract(objects(I, True, False, False), lambda o: color(o) == v) # Get object with color v
        shift_amount = (0, width(I) - rightmost(obj) - 1) # Calculate rightward shift
        I = paint(cover(I, obj), shift(obj, shift_amount))  # Move object to the right edge
    return I
 
45.0, 10.390994, def dgdcdjfdhccjeefdjgfdcgjecgcigbbj(I):
  O = I  # Create output grid copy
  for obj in sorted(objects(I, True, False, True), key=lambda obj: -uppermost(obj)): # Loop through unique objects
    w = width(obj)  # Get object width
    O = paint(cover(O, obj), shift(obj, (0, width(I) - w - leftmost(obj)))) # Move and paint to output
  return O
 
30.666666666666668, 10.297476, def cbidfeddiebceidcahhfgahejccfbfge(I):
    for value in palette(I) - {mostcolor(I)}:  # Iterate through unique colors
        obj = toobject(ofcolor(I, value), I) # Find the object with the current color
        shift_amount = (0, width(I) - rightmost(obj) - 1) # Calculate the shift amount
        I = paint(cover(I, obj), shift(obj, shift_amount)) # Move the object to the right edge
    return I
 
45.333333333333336, 9.910598, def djafeeefceafefififajafiffjdcfdcj(I):
    moved_objs = []
    for obj in objects(I, True, False, True):
        moved_objs.append(shift(obj, (0, width(I)-rightmost(obj)-1)))
    return paint(canvas(mostcolor(I), shape(I)), merge(moved_objs))
 
22.333333333333332, 8.838466, def edaafbciaabdediciceidefgfdafcbgd(I):
  return tuple(
      tuple(0 if j < len(r) - sum(1 for v in r if v != mostcolor(I)) else v for j, v in enumerate(r))
      for i, r in enumerate(I)
  )
 
57.0, 12.72064, def dabfcjijacddejdebjgfifgdfacfdibi(I):
  objs = objects(I, True, False, True)
  return paint(
      canvas(mostcolor(I), shape(I)), 
      frozenset({(v, (i, len(I[0]) - 1 - j)) for obj in objs for v, (i, j) in normalize(obj)})
  )
 
46.0, 17.215723, def gccaacedeefeeeffjgcedfdfeabdaaee(I):
  return tuple(
    tuple(v for j, v in enumerate(r) if j >= len(r) - max(len(sfilter(r, lambda x: x != mostcolor(I))) for r in I)) 
    for r in I
  )
 
20.0, 5.788003, def ahciacbcjcdeebgaacfadhegjbcbajjb(I):
  objs = fgpartition(I)  # Partition into objects without background
  shifted_objs = set()
  for obj in objs:
    rightmost_col = frozenset({(v, (i, rightmost(obj))) for v, (i, j) in obj}) # Identify rightmost column
    shifted_col = shift(rightmost_col, (0, 1)) # Shift right
    shifted_objs.add(obj - rightmost_col | shifted_col) # Combine original and shifted column
  O = paint(I, merge(shifted_objs)) # Paint shifted objects onto original grid
  return O
 
19.0, 5.734602, def jdeacfafcbdeecdhbebddhaajcjcgcee(I):
  O = I
  for obj in fgpartition(I):
    for i, j in toindices(obj):
      if j == rightmost(obj):  # If cell is in the rightmost column of the object
        O = paint(O, {(index(I, (i, j)), (i, j + 1))}) # Paint the cell one position to the right
  return O
 
14.666666666666666, 5.138593, def bfhiccfjabeaeccbabiedaegjfibdbji(I):
    shifted_objs = mfilter(
        fgpartition(I),
        lambda obj: paint(I, shift(obj, (0, width(obj) - rightmost(obj))))  # Shift object based on its width
    )
    O = paint(I, shifted_objs)
    return O
 
19.333333333333332, 5.775144, def hffhchcdehdbeefaigicfeghaacdjeac(I):
  O = I
  for j in range(width(I)):
    for i in range(height(I)):
      if j < width(I) - 1 and index(I, (i, j)) != 0 and index(I, (i, j + 1)) == 0: # Check for right edge of object
        O = paint(O, {(index(I, (i, j)), (i, j + 1))}) # Shift the cell one position to the right
  return O
 
42.0, 13.306974, def cgijheedfbbhehidacjecfdfgcfdffaf(I):
  """
  This version utilizes map and filter to process objects.
  """
  bg = mostcolor(I)
  non_bg_objs = sfilter(objects(I, True, False, False), lambda obj: color(obj) != bg and color(obj) != 1)
  shifted_objs = mapply(lambda obj: shift(obj, (-1, 0)), non_bg_objs)
  O = paint(canvas(bg, shape(I)), shifted_objs)
  return O
 
47.333333333333336, 10.644947, def efeajafadjdcecaabicbafidjgfcjbbd(I):
  """
  This version directly manipulates grid indices instead of using object representation.
  """
  bg = mostcolor(I)
  h, w = len(I), len(I[0])
  O = canvas(bg, (h,w))
  for i in range(h):
    for j in range(w-1):
      if I[i][j+1] != bg and I[i][j+1] != 1:
        O = paint(O, {(I[i][j+1], (i,j))})
  return O
 
46.0, 6.1009545, def jifdfgiebeeceeafibjabfedfeeeffbb(I):
    """
    This version utilizes hconcat and crop to achieve the shifting effect.
    """
    bg = mostcolor(I)
    trimmed_grid = crop(I, (0,1), (len(I), len(I[0])-1))
    O = hconcat(trimmed_grid, canvas(bg, (len(I), 1)))
    return O
 
17.0, 10.812995, def fadeebidefcaeaedjaaeicbibaadhfjb(I):
  objs = objects(I, T, F, T) 
  largest_obj = argmax(objs, size)
  other_objs = difference(objs, {largest_obj})
  shifted_objs = apply(
      lambda obj: shift(obj, (0, width(I) - rightmost(obj) - rightmost(largest_obj) - 1)), 
      other_objs
  )
  return paint(paint(canvas(ZERO, shape(I)), largest_obj), merge(shifted_objs)) 
 
16.0, 12.93924, def gffggheeahdeebcdifdcbgfdibeeahch(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  return paint(
      paint(canvas(ZERO, shape(I)), largest_obj),
      merge(apply(lambda obj: shift(obj, (0, width(I) - width(obj) - rightmost(largest_obj) - 1)), difference(objs, {largest_obj})))
  )
 
15.666666666666666, 13.122146, def bgjeeabddcfdehbcifbidjegabffdece(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  other_objs = difference(objs, {largest_obj})
  return paint(
      paint(canvas(ZERO, shape(I)), largest_obj), 
      merge(apply(lambda obj: shift(obj, (0, width(largest_obj) + sum(width(o) for o in other_objs) - rightmost(obj))), other_objs))
  )
 
18.666666666666668, 5.5804605, def iciffafjchbaefhfjadajhfaheeabhba(I):
  objs = objects(I, False, False, False)
  for obj in objs:
    for i, row in enumerate(I):
      row_indices = {(i,j) for j in range(len(row)) if (i,j) in toindices(obj)}
      if row_indices:
        max_j = rightmost(row_indices)
        I = fill(I, mostcolor(I), {(i, max_j)})
  O = I
  return O
 
34.666666666666664, 18.640617, def afdbdegegdddedcgacfdjdaafhdicabd(I):
  O = I
  for i, row in enumerate(I):
    for j in range(len(row)-1, 0, -1):
      if row[j] != mostcolor(I) and row[j-1] != row[j]:
        O = fill(O, mostcolor(O), {(i, j)})
  return O
 
70.0, 62.688072, def bfgeijddgbieeabcicfacdffcgdbcibg(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, False, False, False):
    for i, j in toindices(obj):
      left_j = max({k for k in range(j) if (i,k) in toindices(obj)}, default=j)
      if j == left_j:
        O = paint(O, {(color(obj),(i,j))})
  return O
 
56.666666666666664, 13.87217, def jidafacjiegcefeebddidijgdjcdefeb(I):
  return tuple(
      tuple(mostcolor(I) if j < len(I[0]) - len([v for v in r if v != mostcolor(I)]) else r[j - (len(I[0]) - len([v for v in r if v != mostcolor(I)]))]
            for j in range(len(I[0])))
      for r in I
  )
 
45.333333333333336, 9.910598, def iajdaeiedfajebidicbeaafeecaifcfg(I):
  objs = objects(I, True, False, True)
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    shifted_obj = shift(obj, (0, len(I[0]) - rightmost(obj) - 1))
    new_grid = paint(new_grid, shifted_obj)
  return new_grid
 
15.0, 4.9582977, def idjfcdfeajbdehceabcdccfbihecgijg(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)-1, -1, -1):
      if index(I,(i,j)) != 0:
        O = paint(O, recolor(0, {(i,j)}))
        break 
  return O
 
16.666666666666668, 5.8467116, def jcdghjeabhccefebbecfbfajdebfedfb(I):
  O = I
  for obj in objects(I, univalued=False, diagonal=True, without_bg=True):
    rightmost_cell = argmax(obj, lambda cell: cell[1][1])
    O = paint(O, recolor(0, {rightmost_cell[1]}))
  return O
 
13.0, 5.022909, def efhaeecjefjcebbcafeecfcebihjdcdd(I):
  return tuple(tuple(0 if k == len(r) - 1 and v != 0 else v for k, v in enumerate(r)) for r in I) 
 
40.333333333333336, 8.787952, def caccbeeaddbhejgabjeccijhaicfbfad(I):
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  return paint(
    cover(I, merge(difference(objs, {largest_obj}))),
    merge(
        apply(
            lambda obj: shift(obj, (0, width(I) - rightmost(obj) - rightmost(largest_obj) - 1)), 
            objs
        )
    )
  )
 
28.0, 11.833546, def dgbahaiabebeecfeacbafeegacadgffa(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, size)
  others = difference(objs, {largest})
  return paint(
    paint(
      fill(I, ZERO, asindices(I)),
      shift(largest, (0, width(I) - rightmost(largest) - 1))
    ),
    merge(apply(lambda o: shift(o, (0, width(I) - rightmost(o) - rightmost(largest) - 1)), others))
  )
 
44.666666666666664, 58.141518, def edebffecbaefecbbjfbdagebfajciaef(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, lambda obj: rightmost(obj))
  return paint(
    fill(I, ZERO, asindices(I)), 
    merge(apply(lambda o: shift(o, (0, width(I) - rightmost(o) - rightmost(largest) - 1)), objs))
  )
 
25.333333333333332, 13.45333, def ibefgdedbfcaegihjaagciaddghagdhb(I):
  objs = objects(I, T, F, T)
  rightmost_col = max(map(rightmost, objs))
  return paint(
    fill(I, ZERO, asindices(I)), 
    merge(apply(lambda o: shift(o, (0, rightmost_col - rightmost(o))), objs))
  )
 
18.666666666666668, 7.1734433, def jacjaeaaidifeibijfcbbccbdbbjicda(I):
  # Find the largest object
  objs = objects(I, False, False, True)
  largest_obj = argmax(objs, size)

  # Find the rightmost column index of the largest object
  rightmost_col = rightmost(largest_obj)

  # Shift all other objects
  shifted_objs = set()
  for obj in objs:
    if obj != largest_obj:
      shift_amount = rightmost_col - rightmost(obj)
      shifted_objs.add(shift(obj, (0, shift_amount)))
    else:
      shifted_objs.add(obj)

  # Construct the output grid
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
46.333333333333336, 8.703123, def eeabijbiiccbedaebdicbffbhafhiadb(I):
  # Find the bounding boxes of all objects
  objs = objects(I, False, False, True)
  bboxes = apply(box, objs)

  # Find the rightmost bounding box
  rightmost_bbox = argmax(bboxes, rightmost)

  # Shift objects based on bounding box alignment
  shifted_objs = set()
  for obj, bbox in zip(objs, bboxes):
    if bbox != rightmost_bbox:
      shift_amount = rightmost(rightmost_bbox) - rightmost(bbox)
      shifted_objs.add(shift(obj, (0, shift_amount)))
    else:
      shifted_objs.add(obj)

  # Construct the output grid
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
16.333333333333332, 5.573675, def ffiacedjidegebbfbdfbaceifabbffgh(I):
  return tuple(
    tuple(
      v if j >= len(r) - max(rightmost(obj) for obj in objects(I, True, False, True)) - 1 else mostcolor(I)
      for j, v in enumerate(r)
    )
    for i, r in enumerate(I)
  )
 
51.0, 10.3460045, def aghdaabbabcheffcbcicecehagefagii(I):
  objs = objects(I, True, False, True)
  shifted_objs = mapply(lambda obj: shift(obj, (0, len(I[0]) - rightmost(obj) - 1)), objs)
  return paint(canvas(mostcolor(I), shape(I)), shifted_objs)
 
27.0, 12.786047, def cfaaiefbadfaegbcidcaefbiibacbcad(I):
  return hmirror(
    tuple(
      tuple(
        v if j < sum(1 for v in r if v != mostcolor(I)) else mostcolor(I)
        for j, v in enumerate(r)
      )
      for r in hmirror(I)
    )
  )
 
29.333333333333332, 8.470968, def dcfgbhjijcheeibajdffecacbfffhbdb(I):
  O = canvas(mostcolor(I), shape(I)) # Create a canvas filled with the background color
  for obj in sorted(fgpartition(I), key=lambda x: uppermost(x)): # Iterate through objects from top to bottom
    w = width(obj) 
    O = paint(O, shift(obj, (0, width(I) - w - leftmost(obj)))) # Shift object to the right edge
  return O
 
29.0, 10.8020525, def cdeifdbidbefeaaabadbgffdebadfagb(I):
  O = I # Start with the input grid
  for obj in sorted(fgpartition(I), key=lambda x: leftmost(x), reverse=True): # Iterate objects from right to left
    w = width(obj)
    O = cover(O, obj) # Remove the object from its current position
    O = paint(O, shift(obj, (0, width(I) - w - leftmost(obj)))) # Shift and repaint the object
  return O 
 
49.333333333333336, 35.611717, def bfbedgfgdddgejgbijdgjfcbbcaibeba(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    j = width(I) - 1
    while j >= 0:
      if row[j] != mostcolor(I):
        O = paint(O, {(row[j], (i, j))})
        j -= 1
        while j >= 0 and row[j] != mostcolor(I):
          j -= 1 
      else:
        j -= 1
  return O
 
17.333333333333332, 11.508763, def jjbacffahcbgegdbbahhiaagffgeddeb(I):
  """
  This version uses replace to directly substitute the target color with the background color.
  """
  O = replace(I, 1, mostcolor(I))
  return O
 
33.666666666666664, 18.070368, def bgfddahajcaaeacajdcgfajacafegffc(I):
  """
  This version utilizes map to process the grid row by row, filtering out the target color.
  """
  bg = mostcolor(I)
  O = tuple(tuple(v for v in row if v != 1) + (bg,) * (len(row) - sum(v != 1 for v in row)) for row in I)
  return O
 
37.666666666666664, 9.723264, def aefgeahjbbbiecbhjbgbegbdgcjdfedi(I):
  objs = objects(I, T, T, T)
  shifted_objs = frozenset(shift(obj, (-leftmost(obj),0)) for obj in objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs)) 
 
40.0, 45.946312, def cdbihaafecfjecfgbdcgaagccbfdgbca(I):
  return paint(
      replace(I, mostcolor(I), -1), 
      merge(apply(lambda obj: shift(obj, (-leftmost(toindices(obj)), 0)), objects(I, T, T, T)))
  )
 
33.333333333333336, 16.479494, def chidbecbgdbdeaijbdeadagdbjdhgcid(I):
  return cellwise(
      I, 
      paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: shift(obj, (-leftmost(toindices(obj)), 0)), objects(I, T, T, T)))),
      mostcolor(I)
  )
 
21.333333333333332, 6.541348, def eiiccbfbcaafeeaabgcbfjhdbdaegcea(I):
  painted = paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: shift(obj, (-leftmost(toindices(obj)), 0)), objects(I, T, T, T))))
  return tuple(tuple(painted[i][j] if painted[i][j] != mostcolor(I) else I[i][j] for j in range(width(I))) for i in range(height(I)))
 
45.666666666666664, 9.498056, def ecbadbgbhefbeibibfddebdhdchcjhgc(I):
  objs = sorted(objects(I, T, T, T), key=lambda obj: leftmost(obj))
  result = canvas(mostcolor(I), shape(I))
  current_j = 0
  for obj in objs:
    result = paint(result, shift(obj, (-leftmost(obj) + current_j, 0)))
    current_j += width(obj)
  return result
 
23.666666666666668, 6.3819804, def bfhbbddhcdfeefbeadeceecebchcdegh(I):
  # Identify objects excluding the background
  objs_no_bg = objects(I, False, False, True)
  
  # Find objects not touching the grid borders
  inner_objs = sfilter(objs_no_bg, lambda obj: not bordering(obj, I)) 
  
  # Select the largest inner object
  largest_inner_obj = argmax(inner_objs, size) if inner_objs else None
  
  # If a valid object exists
  if largest_inner_obj:
    # Shift the object to the rightmost position
    return paint(cover(I, largest_inner_obj), shift(largest_inner_obj, (0, width(I) - rightmost(largest_inner_obj) - 1)))
  else:
    # No change if no valid object is found
    return I 
 
51.333333333333336, 32.37732, def jeeaajfjfficeebfachihecaedbfjgfg(I):
  objs = sorted(fgpartition(I), key=lambda obj: leftmost(obj))
  O = canvas(mostcolor(I), shape(I))
  current_j = width(I)
  for obj in objs:
    O = paint(O, shift(obj, (0, current_j - width(obj) - leftmost(obj))))
    current_j = min(current_j - width(obj), leftmost(obj))
  return O
 
30.666666666666668, 8.9285, def iabffdfadfeaegjabfiibedcabacbebf(I):
  def shift_right(obj):
    return shift(obj, (0, width(I) - rightmost(obj) - 1))
  return paint(canvas(mostcolor(I), shape(I)), mapply(shift_right, fgpartition(I)))
 
18.666666666666668, 5.5804605, def dcbaaadeccjaejcgafdgajfecaejfeja(I):
  O = tuple(r[:-1] + (mostcolor(I),) for r in I)
  return O
 
19.333333333333332, 8.849441, def cfibahecaicceegdjabcabhabdhebcfc(I):
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, T, T):
    new_obj = frozenset((color(obj), index) for index in difference(toindices(obj), {lrcorner(obj)}))
    new_grid = paint(new_grid, new_obj)
  return new_grid
 
49.666666666666664, 58.729588, def faehbfbhejeheeacicedeibcjbcdabga(I):
  modified_objs = set()
  for value in palette(I):
    filtered_objs = colorfilter(objects(I, T, T, T), value)
    if filtered_objs:
      rightmost_obj = argmax(filtered_objs, lambda obj: rightmost(obj))
      modified_objs.update(frozenset(obj for obj in filtered_objs if obj != rightmost_obj))
    else:
      modified_objs.update(filtered_objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(modified_objs))
 
21.0, 7.662366, def fajadbehfjfjecebahahfbhbccbhaagd(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  grid_h, grid_w = shape(I)
  centered_objs = set()
  for obj in objs:
    obj_h, obj_w = shape(obj)
    offset_i = (grid_h - obj_h) // 2 - uppermost(obj)
    offset_j = (grid_w - obj_w) // 2 - leftmost(obj)
    centered_objs.add(shift(obj, (offset_i, offset_j)))
  O = paint(canvas(bg, shape(I)), merge(centered_objs))
  return O
 
45.666666666666664, 6.0002303, def eieacdejhccdebbhiieifcjbdaffccad(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  grid_center = center(asindices(I))
  O = canvas(bg, shape(I))
  for obj in objs:
    obj_center = center(obj)
    offset = subtract(grid_center, obj_center)
    O = paint(O, shift(obj, offset))
  return O
 
61.333333333333336, 39.707325, def chcfefgccjeaeadfjebfjgdhjcfibibd(I):
  objs = fgpartition(I)
  shifted_objs = initset(toobject(frozenset(), I)) 
  for obj in objs:
    max_j = 0
    for other_obj in objs:
      if hmatching(obj, other_obj):
        max_j = max(max_j, rightmost(other_obj))
    shifted_objs = insert(shift(toobject(toindices(obj), I), (0, width(I) - max_j - width(obj))), shifted_objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
 
61.666666666666664, 21.84111, def gdccefcieddheeadjhijfjcfedidgdac(I):
  return hconcat(canvas(mostcolor(I), (height(I), width(I) - width(compress(I)))), compress(I))
 
21.0, 7.7854958, def ibfceaeegdfheajeadfcdifbdejgcbda(I):
  obj1 = next((obj for obj in objects(I, True, False, False) if color(obj) == 1), frozenset()) 
  obj2 = next((obj for obj in objects(I, True, False, False) if color(obj) == 2), frozenset())
  offset = (uppermost(obj1) - uppermost(obj2), leftmost(obj1) - leftmost(obj2))
  shifted_obj2 = shift(obj2, offset)
  O = paint(cover(I, obj2), shifted_obj2)
  return O
 
43.0, 19.638525, def eecafdbajaefeedeicbiejjcfdadcjee(I):
  obj1 = next((obj for obj in partition(I) if color(obj) == 1), frozenset())
  obj2 = next((obj for obj in partition(I) if color(obj) == 2), frozenset())
  j_shift = leftmost(obj1) - leftmost(obj2)
  O = paint(canvas(mostcolor(I), shape(I)), shift(obj2, (0, j_shift)))
  return O
 
67.0, 52.390755, def caahehibcdcbeedfbhcdddffdciahdfe(I):
  indices1 = ofcolor(I, 1)
  indices2 = ofcolor(I, 2)
  shift_amount = min(j1 - j2 for i1, j1 in indices1 for i2, j2 in indices2 if i1 == i2)
  O = paint(canvas(mostcolor(I), shape(I)), shift(recolor(2, indices2), (0, shift_amount)))
  return O
 
23.333333333333332, 6.1606765, def aiadgijdgiddehidbcafhbbfdhhfebac(I):
  obj1 = extract(objects(I, True, False, False), lambda obj: color(obj) == 1)
  obj2 = extract(objects(I, True, False, False), lambda obj: color(obj) == 2)
  j_diff = leftmost(obj1) - leftmost(obj2)
  shifted_obj2 = frozenset((v, (i, j + j_diff)) for v, (i, j) in obj2)
  O = paint(cover(I, obj2), shifted_obj2)
  return O
 
17.666666666666668, 5.729265, def dbedccaebbeeediciejhbgfidaechcdj(I):
  objs = objects(I, T, T, T)
  rightmost_cells = apply(lambda obj: frozenset({(color(obj), (i, rightmost(obj))) for i in range(uppermost(obj), lowermost(obj) + 1)}), objs)
  return paint(cover(I, merge(rightmost_cells)), merge(rightmost_cells))
 
23.666666666666668, 12.991762, def fbbhjedbhbbaebjbjcbddhbehbggfcdc(I):
  result = I
  for v in palette(I):
    obj = toobject(ofcolor(I, v), I)
    rightmost_column = frozenset({(v, (i, rightmost(obj))) for i in range(uppermost(obj), lowermost(obj) + 1)})
    result = cover(result, rightmost_column)
  return result
 
27.0, 10.844832, def cjebcfgcceaaebdeibafdeehibbjjhgd(I):
  trimmed_objects = apply(lambda obj: toobject(frozenset((i, j) for i, j in toindices(obj) if j != rightmost(obj)), I), objects(I, T, T, T))
  return paint(canvas(mostcolor(I), shape(I)), merge(trimmed_objects))
 
164.33333333333334, 129.54839, def accgfcbfehdaecdiadiebehbciiaadhd(I):
  return hconcat(tuple(r[:-1] for r in I), ((mostcolor(I),) * len(I),))
 
19.333333333333332, 4.5326757, def bbdbaeeeabcdeddgacijbddagdcbfcgc(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True) 
  centered_objs = set()
  for obj in objs:
    row = uppermost(obj)
    obj_width = width(obj)
    row_width = width(crop(I,(row,0),(1,len(I[0]))))
    offset = (row_width - obj_width) // 2 - leftmost(obj)
    centered_objs.add(shift(obj, (0, offset)))
  O = paint(canvas(bg, shape(I)), merge(centered_objs))
  return O
 
21.666666666666668, 6.0994964, def difbfcgjcffbeiahjadgfcehfaeafbdj(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i, row in enumerate(I):
    obj = frozenset({(v,(i,j)) for j,v in enumerate(row) if v != bg})
    if obj:
      obj_width = width(obj)
      row_width = len(row)
      offset = (row_width - obj_width) // 2 - leftmost(obj)
      O = paint(O, shift(obj,(0,offset)))
  return O
 
21.333333333333332, 5.358183, def badcfiicdfgaefeejdaabfddffeeghfc(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  O = canvas(bg, shape(I))
  for obj in objs:
    shifted_obj = shift(obj, (0, (width(I) - width(obj)) // 2 - leftmost(obj)))
    O = paint(O, shifted_obj)
  return O
 
44.666666666666664, 17.065172, def effhhgfjafdceegciaeefgicjehddeaa(I):
  O = canvas(mostcolor(I), shape(I))
  for j in range(width(I)):
    column = (I[i][j] for i in range(height(I)))
    filtered_column = tuple(c for c in column if c != leastcolor(I) or c == mostcolor(I))
    for i, v in enumerate(filtered_column):
      O = paint(O, recolor(v, {(i, j)}))
  return O
 
16.0, 7.1399236, def dcdcdcdgahbdegjfbcifjfcdecabfiej(I):
  O = tuple(
    tuple(v if v != 1 else (1 if j == max((idx for idx, val in enumerate(r) if val == 1), default=-1) else 0) for j, v in enumerate(r))
    for i, r in enumerate(I)
  )
  return O
 
14.666666666666666, 5.138593, def ghbfjcadbecaebigjddbcbdejibajcgc(I):
    O = tuple(
        tuple(v if j != max((idx if val == 1 else -1 for idx, val in enumerate(r)), default=-1) else 1 for j, v in enumerate(r)) 
        for i, r in enumerate(I)
    )
    return O
 
42.0, 12.584298, def jbedhcfdfdfjejbeahibdhiddhbagdgg(I):
  return tuple(
    tuple(1 if k==j and v==1 else (0 if v==1 else v) for k, v in enumerate(r))
    for j, r in enumerate(zip(*reversed(list(zip(*I)))))
  )
 
31.333333333333332, 16.820833, def ibebebffdafceaecifgcffgbebjbbecf(I):
  objs = objects(I, T, T, T)
  shifted_objs = apply(lambda obj: shift(obj, (0, -leftmost(obj))), objs)
  return paint(canvas(0, shape(I)), merge(shifted_objs))
 
23.333333333333332, 7.032685, def ihhbgdgdiiadechbjjedggicafedcbab(I):
  min_left = min(leftmost(obj) for obj in objects(I, T, T, T))
  return crop(I, (0, min_left), (height(I), width(I) - min_left))
 
31.666666666666668, 25.538858, def cjafdebfddccebecbbhdcbchajafgfbc(I):
  return paint(canvas(0, (height(I), sum(1 for col in zip(*I) if any(col)))), merge(objects(I, T, T, T)))
 
47.333333333333336, 6.110123, def gbbaciccabfeeaacicdffdadgcfaadbb(I):
  return tuple(tuple(v for v in r if v != 0) + tuple(0 for _ in range(len(r) - len(tuple(v for v in r if v != 0)))) for r in I)
 
