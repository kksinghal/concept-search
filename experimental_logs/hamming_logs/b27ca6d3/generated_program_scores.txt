0.0763888888888889, 15.778572, def ffbgdcfabccfeghdbbfbbcfbcaafbcdb(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 2:
        O = fill(O, 3, backdrop({(i - 1, j - 1)}))
  return O
 
0.16365740740740742, 27.39085, def bbbhdcbcbabgefiajdbhediagedgfche(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    for i, j in toindices(obj):
      for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
        I = fill(I, THREE, {(i+di, j+dj)})
  return I
 
0.22893518518518519, 25.125113, def gficfgeagceaedeeibbfjhibfcejcjbh(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    I = fill(I, THREE, outbox(toindices(obj)))
  return I
 
0.05810185185185185, 30.264742, def ffcfjbfcjicheifeibafaffeheehdiaa(I):
  objs = objects(I, T, F, T)
  return fill(I, THREE, merge({delta(shift(toindices(obj), d)) for obj in objs for d in [(0,1),(0,-1),(1,0),(-1,0)]})) 
 
0.2828703703703704, 19.358435, def hjcefeicfhidefgbbfaiddeifaihbbff(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    ul = ulcorner(obj)
    lr = lrcorner(obj)
    for i in range(ul[0]-1, lr[0]+2):
      for j in range(ul[1]-1, lr[1]+2):
        if 0 <= i < len(I) and 0 <= j < len(I[0]):
          if (i,j) not in toindices(obj):
            O = fill(O, 3, {(i,j)})
  return O
 
0.15, 17.05219, def cefehfcceaabeadebdifjjibjebhiheb(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    frame = box(shift(obj, (1,1)))
    O = fill(O, 3, frame)
  return O
 
0.7949074074074074, 14.052827, def fcbgcbajhdgbeceajcjdeggjfhbgcece(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    O = underfill(O, 3, backdrop(shift(obj,(1,1))))
  return O
 
0.0699074074074074, 12.407709, def cbfcgddfeecheghdafjbeffbfcfebbhb(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I,(i,j)) != mostcolor(I): 
        O = underfill(O, 3, backdrop({(i+1,j+1)})) 
  return O
 
0.05810185185185185, 30.264742, def gdhjciecfegfehadjbfhbcffcjcbdcab(I):
  objs = objects(I, T, F, F)
  frame_indices = set()
  for obj in objs:
    frame_indices = frame_indices | backdrop(shift(obj,(1,1)))
  O = fill(I, 3, frame_indices - toindices(merge(objs)))
  return O
 
0.07800925925925926, 27.05199, def affdcibbhcddedifbchdgfaeefdbbhaf(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    obj = extract(objs, lambda obj: hline(obj) and color(obj) == 2)
    bordered_obj = toindices(obj)
    for direction in [UP, DOWN, LEFT, RIGHT]:
        bordered_obj = bordered_obj | shift(bordered_obj, direction)
    O = fill(I, 3, bordered_obj)
    return O
 
0.1474537037037037, 28.793962, def fagjdcccfgcaecdfjcfdabhhiaeaaehg(I):
    objs = objects(I, univalued=True, diagonal=True, without_bg=True)
    filtered_objs = sfilter(objs, lambda obj: color(obj) == 2)
    border_cells = set()
    for obj in filtered_objs:
        for cell in toindices(obj):
            for direction in [UP, DOWN, LEFT, RIGHT]:
                neighbor = add(cell, direction)
                if neighbor not in toindices(obj) and index(I, neighbor) != 2:
                    border_cells.add(neighbor)
    O = fill(I, 3, frozenset(border_cells))
    return O
 
0.11990740740740741, 16.8873, def cjaeibegfeafehdfiifihccachddchdb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == TWO:
        O = paint(O, recolor(THREE, {(i - 1, j + 1), (i, j + 1), (i + 1, j + 1)}))
  return O
 
0.15185185185185185, 9.791275, def bffbfibffhchefeaicdcdjaaaciagbfi(I):
  O = I
  for loc in asindices(I):
    if index(I, loc) == TWO:
      O = paint(O, recolor(THREE, shift({(0, -1), (0, 0), (0, 1)}, loc)))
  return O
 
0.16365740740740742, 11.675141, def faaebfabdffbegdjjefadiejdbfhbcch(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == TWO:
      i, j = centerofmass(obj)
      line = shift({(0, -1), (0, 0), (0, 1)}, (i, j + 1))
      O = paint(O, recolor(THREE, line))
  return O
 
0.21782407407407406, 18.225765, def acieefbcdcejecacicdeeeeghehhbbbf(I):
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            ni, nj = i + di, j + dj
            if 0 <= ni < h and 0 <= nj < w:
              O = fill(O, 3, {(ni, nj)}) 
      else:
        O = fill(O, I[i][j], {(i, j)})
  return O 
 
0.11203703703703703, 29.963219, def ejhebhifbeeiebcgjbhcagcdfjcacdaj(I):
  objs = objects(I, T, F, T)
  for obj in objs:
    if color(obj) == 2:
      I = fill(I, THREE, box(toindices(obj)))
  return I
 
0.2571759259259259, 24.711285, def hadabgfhbbcbedddbchchdajiieegcgf(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        I = fill(I, THREE, box(dneighbors((i, j))))
  return I
 
0.7664351851851852, 13.174488, def ccbhbgbjffacebddaiabcgddegdbaccd(I):
  objs = objects(I, T, F, F)  # Extract objects from the input grid.
  O = I                      # Initialize the output grid as a copy of the input.
  for obj in objs:
    for dy in range(-1, 2):     # Iterate over a 3x3 neighborhood around each object cell.
      for dx in range(-1, 2):
        if dy != 0 or dx != 0:  # Exclude the object cell itself.
          shifted_obj = shift(obj, (dy, dx))  # Shift the object to check frame positions.
          O = underfill(O, 3, intersection(backdrop(obj), toindices(shifted_obj)))  # Fill frame pixels within the object's bounding box.
  return O
 
0.2446759259259259, 15.529777, def dbececcafifdegcbacfffabhjfbdiadc(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    O = underfill(O, 3, box(obj)) # Directly fill the bounding box outline.
  return O
 
0.2986111111111111, 17.492582, def ddfecdbdebcdeaiiibcdfcedfabacbdh(I):
  objs = objects(I, T, F, F)
  O = canvas(mostcolor(I), shape(I))  # Start with a blank canvas of the background color.
  for obj in objs:
    O = paint(O, obj)              # Paint the object onto the canvas.
    O = fill(O, 3, box(obj))        # Draw the frame directly, overwriting any overlapping object pixels.
  return O
 
0.887962962962963, 31.209042, def fdfcfddhdcggecfcaajfhiadbcajfacg(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    surrounding = difference(backdrop(obj), obj) # Find cells surrounding the object.
    O = underfill(O, 3, surrounding)             # Fill the surrounding cells if they are background.
  return O
 
0.05810185185185185, 30.264742, def eachehdgahjdecfbiicfiadgiedhichf(I):
  objs = objects(I, univalued=True, diagonal=True, without_bg=True)
  target_objs = sfilter(objs, lambda obj: color(obj) == 2)
  border_indices = mfilter(target_objs, lambda obj: delta(backdrop(obj)))
  O = fill(I, 3, border_indices)
  return O
 
0.15787037037037038, 11.465635, def bebfbhbabgccehjaafhebfhabcegjdgf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  target_objs = colorfilter(objs, TWO)
  O = I
  for obj in target_objs:
    center_i, center_j = centerofmass(obj)  # Get both i and j coordinates
    line = {(0, -1), (0, 0), (0, 1)}
    O = paint(O, recolor(THREE, shift(line, (center_i, center_j))))
  return O
 
0.22662037037037036, 18.515423, def dbghhgdiacieeehbifhfbfadebgeceeb(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 2:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0]):
              O = fill(O, 3, {(i + di, j + dj)})
  return O
 
0.4511574074074074, 42.498337, def dhffdjihfgfheaaebcbfgdcefdfbchhd(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    for cell in obj:
      for dx in range(-1, 2):
        for dy in range(-1, 2):
          if dx != 0 or dy != 0:
            O = underfill(O, 3, {(cell[1][0] + dy, cell[1][1] + dx)})
  return O
 
0.20046296296296295, 20.89728, def bjaigdjehfbbebbjbbedfhbbjacbdifd(I):
  O = I
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if I[i][j] != 0:
        O = fill(O, 3, neighbors((i, j)))
  return O
 
0.2828703703703704, 17.007616, def aedjcfdejebfedciiabfifjeajbdjgji(I):
  O = canvas(0, shape(I)) # Initialize a blank canvas
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != 0:
        for dy in range(-1, 2):
          for dx in range(-1, 2):
            if 0 <= i + dy < height(I) and 0 <= j + dx < width(I) and (dx != 0 or dy != 0):
              O = fill(O, 3, {(i + dy, j + dx)}) 
  return O
 
0.9418981481481481, 59.46244, def cehgaaadaheaeiajbeebaadafbhfaeaf(I):
  O = I
  for dx in range(-1, 2):
    for dy in range(-1, 2):
      if (dx, dy) != (0, 0):
        shifted = shift(asobject(I), (dy, dx))
        O = paint(O, recolor(3, intersection(backdrop(asobject(I)), toindices(shifted))))
  return O
 
0.11203703703703703, 29.963219, def jfaffdabbajfedccijeadecgcgbedejd(I):
    target_color = 2
    border_color = 3
    h, w = len(I), len(I[0])
    border_indices = set()
    for i in range(h):
        for j in range(w):
            if I[i][j] == target_color:
                for ni, nj in neighbors((i, j)):
                    if 0 <= ni < h and 0 <= nj < w:
                        if I[ni][nj] != target_color:
                            border_indices.add((i, j))
                            break
                    else:
                        border_indices.add((i, j))
                        break
    O = fill(I, border_color, frozenset(border_indices))
    return O
 
0.2828703703703704, 19.358435, def aeafjgfaccbaeajcbefgbffabcbdafgc(I):
    two_locations = ofcolor(I, 2)
    expanded_locations = frozenset({(i + di, j + dj) for i, j in two_locations for di in range(-1, 2) for dj in range(-1, 2)})
    O = I
    for i, j in expanded_locations:
        if 0 <= i < len(I) and 0 <= j < len(I[0]):
            O = fill(O, 3, {(i, j)})
    return O
 
0.1474537037037037, 28.793962, def ffbejefhcaejedceidebcfaedfddeeee(I):
    objs = objects(I, T, F, T)
    expanded = mapply(lambda obj: toindices(shift(obj, (1, 0))) | toindices(shift(obj, (-1, 0))) | toindices(shift(obj, (0, 1))) | toindices(shift(obj, (0, -1))), objs)
    return fill(I, THREE, difference(expanded, toindices(merge(objs))))
 
0.1462962962962963, 16.259855, def dhdceejefbfcebcebcfffcgffbfaecab(I):
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    for obj in objects(I, T, F, F):
        O = paint(fill(O, 3, mapply(dneighbors, toindices(obj))), obj) 
    return O
 
0.1474537037037037, 28.793962, def dggcchbgeadjefgaifegbfeehccdahfi(I):
    O = I
    for x in objects(I, T, F, T):
        O = underfill(O, 3, mapply(dneighbors, toindices(x)))
    return O
 
0.08009259259259259, 12.346359, def ijajiadgabeeeaehjdjbcbcbdbddface(I):
  """
  Identifies and shifts horizontal lines of 2s, recoloring them to 3s.

  Finds all objects in the grid, filters for those with color 2, 
  shifts them one position to the right, recolors them to 3, 
  and paints them onto the original grid.
  """
  return paint(I, recolor(THREE, shift(merge(sfilter(objects(I, univalued=True, diagonal=False, without_bg=True), 
                                                 lambda obj: color(obj) == TWO)), 
                                        (0, 1))))
 
0.11203703703703703, 29.963219, def egabdccfaghfebfdagbhjeacgcafdfcj(I):
  """
  Shifts and recolors horizontal lines of 2s using list comprehension.

  Creates a new grid by iterating through rows and within each row, 
  replaces each 2 with a 3 and inserts a 3 at the beginning if the 
  previous cell was also a 2.
  """
  O = tuple(
    tuple(
      THREE if (j>0 and row[j-1] == TWO and value == TWO) or value == TWO else value 
      for j, value in enumerate(row)
    ) 
    for row in I
  )
  return O
 
0.06018518518518518, 30.194696, def cfdfdaiicfebebajifibfddjdhdfbadf(I):
  """
  Replaces horizontal 2s with shifted 3s using cell-by-cell operations.

  Creates a copy of the input grid and then iterates through each cell. 
  If a cell and its right neighbor are 2, it colors the right neighbor 
  with 3 in the output grid.
  """
  O = [list(row) for row in I]
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w - 1):
      if I[i][j] == TWO and I[i][j + 1] == TWO:
        O[i][j + 1] = THREE
  return tuple(tuple(row) for row in O)
 
0.11203703703703703, 29.963219, def egfcjgdeagbeecgejdfbfjfhaigbbeec(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, 2)
  O = I
  for obj in target_objs:
    O = fill(O, 3, backdrop(obj))
  return O
 
0.05810185185185185, 30.264742, def cggdjhfdchgjedecabahcjebgfjbebaa(I):
  O = canvas(0, shape(I))
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, 2)
  for obj in target_objs:
    O = paint(O, obj)
    O = fill(O, 3, backdrop(obj) - toindices(obj))
  return O
 
0.9418981481481481, 59.46244, def bbbhbhgbfchgebchidbabiigfidieadf(I):
  objs = objects(I, T, F, T) # Identify objects, excluding the background.
  expanded_objs = mapply(lambda obj: recolor(THREE, backdrop(toindices(obj))), objs) # Expand each object's backdrop and recolor to 3.
  return paint(fill(I, THREE, asindices(I)), expanded_objs) # Paint the expanded objects onto a canvas filled with 3s.
 
0.2050925925925926, 26.034286, def aadbjidfchjbejbeijabffifcagbhaja(I):
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
    top, left = ulcorner(obj)
    bottom, right = lrcorner(obj)
    O = fill(O, 3, {(top - 1, j) for j in range(left, right + 2)}) # Top line
    O = fill(O, 3, {(bottom + 1, j) for j in range(left, right + 2)}) # Bottom line
    O = fill(O, 3, {(i, left - 1) for i in range(top, bottom + 2)}) # Left line
    O = fill(O, 3, {(i, right + 1) for i in range(top, bottom + 2)}) # Right line
  return O
 
0.08796296296296297, 16.514435, def bhdhebgebebaeieeiebhaffcecceifag(I):
  """
  Uses object detection and manipulation to shift and recolor 2s.

  Detects horizontal lines of 2s as objects, then shifts and recolors them.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    if hline(obj) and color(obj) == TWO:
      O = paint(O, recolor(THREE, shift(obj, (0, 1))))
  return O
 
0.08009259259259259, 13.074898, def ebjjaecbjifbeejcjgeffhehgeajdfaf(I):
  O = I
  for i in range(1, len(I)):
    for j in range(1, len(I[0])):
      if I[i][j] == 2:
        O = fill(O, 3, backdrop(frozenset({(i - 1, j - 1)})))
  return O
 
0.09004629629629629, 14.718954, def beecgfeidfjaeacjjfaabdgcaaafeeeh(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, 2)
  O = paint(canvas(3, shape(I)), asobject(I))
  for obj in target_objs:
    O = paint(O, shift(obj, (-1, -1)))
  return O
 
0.24351851851851852, 16.622139, def edacgafgdbaeedebjigbedbghehifbfe(I):
  shifted_grid = shift(asobject(I), (-1, -1))
  O = canvas(3, shape(I))
  for v, (i, j) in shifted_grid:
    if 0 <= i < len(I) and 0 <= j < len(I[0]):
      if v == 2:
        O = fill(O, 2, backdrop(frozenset({(i, j)})))
      else:
        O = fill(O, v, {(i, j)})
  return O
 
0.2013888888888889, 21.673504, def dciediigffgaeibbiijhgchefjbfcdba(I):
  objs = objects(I, T, F, T)  # Extract objects from the input grid
  expanded_indices = set()
  for obj in objs:
    for ind in toindices(obj): # For each cell in the object
      expanded_indices.update(dneighbors(ind)) # Add direct neighbors to the set
      expanded_indices.add(ind) # Add the cell itself
  return fill(I, THREE, frozenset(expanded_indices)) # Fill the expanded indices with '3'
 
0.15555555555555556, 28.10738, def ecjfdjedaabdedgdiaegadcdffcgaadj(I):
  output = [[0 for _ in range(len(I[0]))] for _ in range(len(I))] # Create empty output grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != 0: # For each non-background cell
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]: # Check its neighbors
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]): # Ensure neighbor indices are within bounds
            output[ni][nj] = THREE
        output[i][j] = I[i][j]  # Retain the original object cell value
  return tuple(tuple(row) for row in output)
 
0.8337962962962964, 19.598406, def hgaebajffadiedaeagbdfgdfeibdcecb(I):
  O = I
  for obj in objects(I, T, F, F):
    for d in range(1, 4):
      for direction in ((-d, 0), (d, 0), (0, -d), (0, d)):
        O = underfill(O, 3, toindices(shift(obj, direction)))
  return O
 
0.0699074074074074, 29.58925, def bbhccfbfcjchefaiaeafjddbdhddbgbi(I):
  O = I
  for obj in objects(I, T, F, F):
    O = paint(fill(O, 3, box(obj)), obj)
  return O
 
0.11203703703703703, 29.963219, def fhbheaajegagejfebehdadecabfgdjge(I):
  O = I
  for obj in objects(I, T, F, F):
    O = fill(O, 3, delta(obj))
  return O
 
0.10810185185185187, 29.803322, def fefjfdhefaijebabifbhddijdacecdda(I):
    objs = objects(I, univalued=True, diagonal=True, without_bg=True)
    target_objs = sfilter(objs, lambda obj: color(obj) == 2)
    border_indices = frozenset()
    for obj in target_objs:
        indices = toindices(obj)
        border_indices = border_indices | frozenset(papply(
            lambda cell, n: cell if (n in asindices(I) and index(I, n) != 2) or n not in asindices(I) else None, 
            indices, 
            tuple(n for cell in indices for n in dneighbors(cell) | ineighbors(cell))
        ))
    O = fill(I, 3, frozenset(x for x in border_indices if x is not None))
    return O
 
0.08009259259259259, 11.437073, def ifaieibhjgadecbdabbaejhiicbfedaa(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    w = width(obj)
    trail = recolor(3, {(i, j + w) for _, (i, j) in obj})
    O = paint(O, trail)
  return O
 
0.05810185185185185, 21.992846, def hjiieeaeebdhedbdjffegfjdaabeeebb(I):
  h = len(I)
  O = tuple(row + tuple(3 if any(I[i][k] == 2 for i in range(h)) else 0 for k in range(len(row))) for row in I)
  return O
 
0.30300925925925926, 20.504232, def dgaefegffifeehaaaefhicehafdiceid(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, 2)
  O = I
  for obj in target_objs:
    center_i, center_j = centerofmass(obj)
    for di in range(-1, 2):
      for dj in range(-1, 2):
        i, j = center_i + di, center_j + dj
        if 0 <= i < len(I) and 0 <= j < len(I[0]):
          O = fill(O, 3, {(i, j)})
  return O
 
0.22083333333333333, 22.253412, def cfihfdfdjadcedeijdbffcfiedbdebaj(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if any(I[i + di][j + dj] == 2 for di in range(-1, 2) for dj in range(-1, 2)):
        O = fill(O, 3, {(i, j)})
  return O
 
0.2828703703703704, 17.16015, def caafifgjdbdieaddjbdaffddbbjdfeia(I):
  return paint(canvas(0, shape(I)), merge(apply(lambda obj: recolor(THREE, outbox(toindices(obj))), objects(I, T, F, T))))
 
0.05393518518518518, 25.907423, def aahabgadaabeeejibheegccfdhehaebe(I):
  O = I
  two_indices = ofcolor(I, 2)
  for i, j in two_indices:
    if any((i, j + offset) in two_indices for offset in [-1, 1]):
      O = fill(O, 3, dneighbors((i, j)))
  return O
 
0.08958333333333333, 19.099821, def fiaahaccfiaeecbejaccjbeceddeaida(I):
  twos = partition(I)
  targets = sfilter(twos, lambda obj: width(obj) > 1)
  return paint(I, merge(apply(lambda obj: recolor(3, dneighbors(centerofmass(obj))), targets)))
 
0.10578703703703704, 50.443752, def iiacehgfbdhdeiifjgciccbbfdgfhabb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    if color(obj) == 2 and width(obj) > 1:
      O = paint(O, obj)
      O = paint(O, recolor(3, dneighbors(centerofmass(obj))))
  return O
 
0.0699074074074074, 12.407709, def iacdbefefcededfeihbaabdfihiehefi(I):
  objs = objects(I, univalued=True, diagonal=True, without_bg=True)
  O = I
  for obj in sfilter(objs, lambda obj: color(obj) == 2):
    for cell in toindices(obj):
      if any(n not in asindices(I) or index(I, n) != 2 for n in neighbors(cell)):
        O = fill(O, 3, backdrop(shift(frozenset({cell}), (1, 1))))
  return O
 
0.05810185185185185, 29.04753, def cfbcjdgaeddfebebabebfehdbbbhhafa(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    if color(obj) == 2:
      start_j = leftmost(obj)
      end_j = rightmost(obj) + width(obj)
      row_i = uppermost(obj)
      O = paint(O, recolor(3, frozenset((row_i, k) for k in range(start_j + 1, min(end_j, len(I[0]))))))
  return O
 
0.29467592592592595, 36.50156, def iaagaegadecbehfbjfeacbajcaejcfib(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        k = j + 1
        while k < len(row) and row[k] != 2:
          O = paint(O, {(3, (i, k))})
          k += 1
  return O
 
0.27708333333333335, 35.73837, def cbheeefjbcabebaiadacbffcfhbfahdh(I):
  O = I
  for i, row in enumerate(I):
    extension = False
    for j, value in enumerate(row):
      if value == 2:
        extension = True
      elif extension:
        O = paint(O, {(3, (i, j))})
      else:
        O = paint(O, {(value, (i, j))})
    O = paint(O, {(row[-1], (i, len(row) - 1))})  # Handle last cell
  return O
 
0.1675925925925926, 26.989635, def ciegbhfaffdfefcbaiahaadhadbadeff(I):
  return paint(I, merge(apply(lambda obj: recolor(THREE, difference(dneighbors(centerofmass(obj)), toindices(obj))), objects(I, T, F, T)))) 
 
0.07430555555555556, 29.749086, def cbhefbbhacfceffbbddfbbdjiiaebbad(I):
  objs = objects(I, T, F, T)
  return fill(I, THREE, merge(apply(lambda obj: sfilter(box(toindices(obj)), lambda loc: any(n in toindices(obj) for n in dneighbors(loc))), objs)))
 
0.11203703703703703, 58.2238, def bfjcceffhdbbehdhieceegfgccjfbcge(I):
  return paint(canvas(0, shape(I)), merge(apply(lambda obj: recolor(THREE, difference(backdrop(toindices(obj)), toindices(obj))), objects(I, T, F, T))))
 
0.8368055555555556, 25.316936, def fibidbdacaegecajbejdbfeabgacefjd(I):
  shifted_grid = shift(asobject(I), (1,1)) # Shift the entire grid by (1,1)
  objs = objects(I, T, F, F)
  O = I
  for obj in objs:
      O = paint(O, recolor(3, shift(obj, (1, 1))))  # Paint shifted objects with '3'
  O = cellwise(O, I, 3) # Prioritize original grid values, otherwise fill with 3
  return O
 
0.2013888888888889, 21.673504, def ajafagcddfcbegggbafefjhdjehefcbg(I):
    objs = objects(I, T, F, F)
    border_cells = set()
    for obj in objs:
        for i, j in toindices(obj):
            for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: # Directions to check neighbors
                ni, nj = i + di, j + dj
                if (0 <= ni < len(I) and 0 <= nj < len(I[0]) and
                        (ni, nj) not in toindices(obj)):
                    border_cells.add((3, (ni, nj)))
    return paint(I, frozenset(border_cells)) 
 
0.07222222222222223, 29.895954, def hgcdaffffdebecdijdjcjcbcfabbfibj(I):
  O = asobject(I) # Start with input as object
  twos = ofcolor(I, 2) # Get indices of '2's
  for i, j in twos:
    O = O | recolor(3, shift(frozenset({(1, 1)}), (i - 1, j - 1))) # Add recoloured shifted squares to object
  return paint(canvas(0, shape(I)), O) # Paint the final object onto a blank canvas
 
0.9560185185185185, 35.602665, def adcagjeigbbjeaehigaahjdbcjggdjce(I):
  objs = objects(I, T, F, T)
  shifted_objs = mapply(lambda obj: shift(obj, (1, 1)), objs)
  return paint(fill(I, THREE, asindices(I)), shifted_objs)
 
0.2828703703703704, 19.358435, def ahdajdhfdeefejdfbdcadbehjhbgjghi(I):
  def box_around_cell(i, j):
    return {(i-1,j-1), (i-1,j), (i-1,j+1), 
            (i,j-1),   (i,j),   (i,j+1),
            (i+1,j-1), (i+1,j), (i+1,j+1)}
  boxes = set()
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != 0:
        boxes.update(box_around_cell(i, j))
  return fill(I, THREE, boxes)
 
0.22893518518518519, 25.125113, def fdceaahfeaefebjejdijaafjchebacec(I):
  O = I
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  for obj in objs:
    if color(obj) == 2:
      O = paint(O, recolor(3, outbox(toindices(obj))))
      O = paint(O, recolor(3, inbox(toindices(obj))))
      O = paint(O, obj)
  return O
 
0.1474537037037037, 28.793962, def fjaedjbffgcjeebgjbbaebgcdbebdgec(I):
  O = I
  target_indices = ofcolor(I, 2)
  for i, j in target_indices:
    for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:
      new_i, new_j = i + di, j + dj
      if 0 <= new_i < len(I) and 0 <= new_j < len(I[0]):
        if I[new_i][new_j] != 2:
          O = fill(O, 3, {(new_i, new_j)})
  return O
 
0.10347222222222223, 9.664192, def cgjbegiadhfieddbbcacgafdfgfhfegf(I):
  O = I
  for i, j in ofcolor(I, 2):
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
      ni, nj = i + di, j + dj
      if (0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0 and
          any((i, j + offset) in ofcolor(I, 2) for offset in [-1, 1] + [0 if di else 1, 0 if di else -1])):
        O = fill(O, 3, {(ni, nj)}) 
  return O
 
0.04398148148148148, 20.214108, def fejhabfdfdciegffbbgjihgedebffhac(I):
  objs = objects(I, T, F, F)
  border_cells = set()
  for obj in objs:
    if color(obj) == 2:
      for i, j in toindices(obj):
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0 and (ni, nj) not in toindices(obj) and any((i + offset * di, j + offset * dj) in toindices(obj) for offset in [-1, 2]):
            border_cells.add((3, (ni, nj)))
  return paint(I, frozenset(border_cells))
 
0.01990740740740741, 7.171308, def acfceaedffjbehbcbdfacbdcacfefbeg(I):
  O = I
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2 and ((j > 0 and I[i][j-1] == 2) or (j < w - 1 and I[i][j+1] == 2) or (i > 0 and I[i-1][j] == 2) or (i < h - 1 and I[i+1][j] == 2)):
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < h and 0 <= nj < w and I[ni][nj] == 0:
            O = fill(O, 3, {(ni, nj)})
  return O
 
0.3486111111111111, 31.544968, def jciibeebeafeebejjgjhfdhecaabcgfi(I):
  O = I
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        if j == 0 or I[i][j-1] != 2:  # Start of a new line or isolated '2'
          O = paint(O, recolor(3, frozenset((i, k) for k in range(j, w))))
  return O
 
0.3678240740740741, 34.353676, def hiejbfifejejeieejfddfefgafifdaie(I):
  h, w = len(I), len(I[0])
  return tuple(
    tuple(
      3 if any(I[i][k] == 2 for k in range(j, w)) else value 
      for j, value in enumerate(row)
    )
    for i, row in enumerate(I)
  )
 
0.25555555555555554, 23.27755, def djeddehciibgeeabbecafiahhdacahbj(I):
  O = canvas(0, shape(I))
  for obj in objects(I, True, False, False):
    if color(obj) == 2 and hline(obj):
      start_j = leftmost(obj)
      i = uppermost(obj)
      O = paint(O, recolor(3, frozenset((i, k) for k in range(start_j, len(I[0])))))
    else:
      O = paint(O, obj)
  return O
 
0.30300925925925926, 20.504232, def gagedcbhghjaeacabcbdfccaieebdcgd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  twos = colorfilter(objs, 2)
  indices_to_paint = frozenset()
  for two in twos:
    center_i, center_j = centerofmass(two)
    for i in range(center_i-1, center_i+2):
      for j in range(center_j-1, center_j+2):
        indices_to_paint = indices_to_paint.union(frozenset({(i, j)}))
  O = fill(I, 3, indices_to_paint)
  return O
 
0.22662037037037036, 18.515423, def dfhggcabcichedijjfghehdgfciaiffj(I):
  O = I
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] == 2:
        O = fill(O, 3, {(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)})
  return O
 
0.08009259259259259, 13.074898, def eefgfaigbabheddaacfdabhacffafceh(I):
  indices_two = ofcolor(I, 2)
  indices_to_paint = frozenset()
  for i, j in indices_two:
    indices_to_paint = indices_to_paint.union(backdrop({(i-1, j-1)}))
  O = fill(I, 3, indices_to_paint)
  return O
 
0.29467592592592595, 19.382292, def hfifdadjgegbeafbifbdfcbffadebddc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    if color(obj) == 2:
      center_i, center_j = center(obj)
      O = fill(O, 3, {(center_i-1, center_j-1), (center_i-1, center_j), (center_i-1, center_j+1),
                       (center_i,   center_j-1), (center_i,   center_j), (center_i,   center_j+1),
                       (center_i+1, center_j-1), (center_i+1, center_j), (center_i+1, center_j+1)})
  return O
 
0.16365740740740742, 27.39085, def iaadbfgdcbgcegeibjcaebgfbgdjfbfc(I):
  objs = objects(I, T, F, F)  # Identify objects
  target_color = 2 
  expansion_color = 3
  target_objs = colorfilter(objs, target_color) # Filter objects with target color
  expanded_indices = mapply(lambda obj: mapply(dneighbors, toindices(obj)), target_objs) # Expand each object
  O = fill(I, expansion_color, expanded_indices) # Fill expanded cells
  return O
 
0.1474537037037037, 28.793962, def fbhbdhbdchihedhdigcaffebebehbajf(I):
  target_color = 2
  expansion_color = 3
  target_indices = ofcolor(I, target_color) # Find indices of target color
  expanded_indices = mapply(dneighbors, target_indices) # Expand each index
  O = fill(I, expansion_color, expanded_indices - target_indices) # Fill only new cells
  return O
 
0.8523148148148147, 17.248398, def fgjebdbgfehfehhgjceccahgbjcbeaef(I):
  target_color = 2
  expansion_color = 3
  padded_I = canvas(0, (len(I) + 2, len(I[0]) + 2)) # Create padded grid
  padded_I = fill(padded_I, expansion_color, asindices(I))
  padded_I = fill(padded_I, target_color, ofcolor(I, target_color))
  O = trim(padded_I)
  return O
 
0.887962962962963, 31.209042, def dceecbeeacaieaiaaffdjjaggcaceeea(I):
  target_color = 2
  expansion_color = 3
  expansion_area = mapply(lambda obj: mapply(lambda loc: backdrop({loc}), toindices(obj)), objects(I, T, F, F)) # Find expansion area
  O = fill(I, expansion_color, expansion_area) # Fill expansion area
  O = fill(O, target_color, ofcolor(I, target_color)) # Refill original cells
  return O
 
0.05416666666666667, 26.859709, def idhahgdhabhdefajbjcdibefbfeddffc(I):
  # Find the object formed by the digit '2'
  obj = argmax(objects(I, T, T, T), size)
  # Get the upper-left corner of the object
  i, j = ulcorner(obj)
  # Draw a horizontal line of '3's above the object
  line = {(THREE, (i - 1, k)) for k in range(j, j + width(obj))}
  # Combine the line with the original grid
  O = paint(I, line)
  return O
 
0.06365740740740741, 22.848305, def bacjcghabfaeehajaaagceajjbhfijjd(I):
  # Find indices of all '2's 
  indices_2 = ofcolor(I, TWO)
  # Find the uppermost row containing a '2'
  uppermost_row = uppermost(indices_2)
  # Create a horizontal line of '3's above the '2' object 
  line = {(THREE, (uppermost_row-1, j)) for i, j in indices_2}
  # Paint the line on the grid
  O = paint(I, line)
  return O
 
0.056249999999999994, 28.484718, def bgcdfbccecjeeeieaggadfecfbdcjife(I):
  # Get a horizontally mirrored version of the input grid
  mirrored_grid = hmirror(I)
  # Apply the transformation designed for the original grid orientation
  transformed_mirrored_grid = solve_original(mirrored_grid) 
  # Mirror the transformed grid back to the original orientation
  O = hmirror(transformed_mirrored_grid)
  return O
 
0.05787037037037037, 28.264751, def gefadfcdhjgfefecabeagfgcbeiadiac(I):
    # Find all objects in the input grid
    objs = objects(I, T, T, T)
    # Find the '2' object
    obj = extract(objs, lambda obj: color(obj) == TWO)
    # Find the upper left corner of the '2' object
    i, j = ulcorner(obj)
    # Calculate the width of the object
    w = width(obj)
    # Create a new object representing the line of '3's
    line = frozenset({(THREE, (i - 1, j + k)) for k in range(w)})
    # Paint the line onto the original grid
    O = paint(I, line)
    return O
 
0.08032407407407408, 17.286266, def fcccbfifibgdeibdbhdddahfiijejfff(I):
  # Find the bounding box of all '2's in the grid
  bbox = backdrop(ofcolor(I, TWO))
  # Get the upper left corner of the bounding box
  i, j = ulcorner(bbox)
  # Calculate the width of the bounding box
  w = width(bbox)
  # Create a line of '3's one row above the bounding box
  line = frozenset({(THREE, (i-1, j + k)) for k in range(w)})
  # Paint the line onto the original grid
  O = paint(I, line)
  return O
 
0.1474537037037037, 28.793962, def dcebhbeagfieejbaagceaeeggcibhfef(I):
  objs = objects(I, T, F, F) # Extract connected components, no diagonals
  outline = set()
  for obj in objs:
    if color(obj) == 2:  # Only process objects made of '2's
      for i, j in toindices(obj):  # Iterate over each cell of the object
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: # Check 4-directional neighbors
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:  # Check if neighbor is within bounds and empty
            outline.add((3, (ni, nj)))  # Add outline cell
  return paint(I, frozenset(outline)) # Paint the outline onto the input grid
 
0.05810185185185185, 30.264742, def faaejeifeadfeibdjcjfbecacgfghffe(I):
  objs = objects(I, T, F, T) # Extract objects without background
  outline = set()
  for obj in objs:
    if color(obj) != mostcolor(I):  # Exclude the background object
      outline |= delta(toindices(obj)) # Directly add the delta (outline indices)
  return fill(I, 3, outline)  # Fill outline cells with '3'
 
0.11203703703703703, 29.963219, def fdfcaefechccebhdacgdbjeiidehdged(I):
  objs = objects(I, True, False, True) # Identify all objects
  twos = colorfilter(objs, 2) # Filter for objects with color '2'
  boxes = mapply(box, twos) # Get the bounding boxes for '2' objects
  O = fill(I, 3, boxes)  # Fill the bounding boxes with '3'
  return O
 
0.22893518518518519, 25.125113, def dfabfggbfeafeifgbgaaafeddiafibad(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 2:
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
                            O = fill(O, 3, {(ni, nj)})
    return O
 
0.05810185185185185, 30.264742, def baieabaebibbeffdjdajiecfcifjceag(I):
  padded = canvas(0, (len(I) + 2, len(I[0]) + 2)) # Create a padded canvas
  padded = paint(padded, shift(asobject(I), (1, 1))) # Place input onto the padded canvas
  objs = objects(padded, True, False, True) # Find objects on the padded canvas
  filtered = colorfilter(objs, 2)  # Filter for objects with color '2'
  O = paint(padded, recolor(3, merge(apply(delta, filtered)))) # Paint the delta of '2' objects with '3'
  return trim(O)  # Trim the padded borders
 
0.05810185185185185, 30.264742, def ebfdiebjcfbfefceibgeiiedabeeieee(I):
  objs = objects(I, univalued=True, diagonal=True, without_bg=True)
  O = I
  for obj in objs:
    if color(obj) == 2:
      border_indices = delta(toindices(obj))
      O = fill(O, 3, border_indices)
  return O
 
0.20046296296296295, 20.89728, def dicaaejadbbcedcfiieedahcbbgachdd(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 2:
        O = fill(O, 3, {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1),
                       (i, j - 1),                 (i, j + 1),
                       (i + 1, j - 1), (i + 1, j), (i + 1, j + 1)})
  return O
 
0.08009259259259259, 13.074898, def bidfcacaidgfejehjfadjbgefceediac(I):
  objs = objects(I, False, True, True)
  target_objs = colorfilter(objs, 2)
  expanded_indices = mapply(lambda obj: backdrop(shift(obj, (-1,-1))), target_objs)
  O = underfill(I, 3, expanded_indices)
  return O
 
0.2828703703703704, 19.358435, def biheacbddageeigeiddjhdhfbbeffeba(I):
  twos = ofcolor(I, 2)
  offsets = [(i,j) for i in range(-1, 2) for j in range(-1, 2)]
  shifted_indices =  mapply(lambda offset: {add(index, offset) for index in twos}, offsets)
  filtered_indices =  sfilter(shifted_indices, lambda idx: 0 <= idx[0] < len(I) and 0 <= idx[1] < len(I[0]))
  O = fill(I, 3, filtered_indices)
  return O 
 
0.22893518518518519, 25.125113, def edbfdachfcbdefgiifjdaiafjgchcjbh(I):
  O = I
  for i in range(len(I)):
      for j in range(len(I[0])):
        if I[i][j] == 2:
          for di in range(-1, 2):
            for dj in range(-1, 2):
              ni, nj = i + di, j + dj
              if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
                O = paint(O, {(3, (ni, nj))})
  return O
 
0.1076388888888889, 9.875483, def gbdjgfbbdhdbecbfjagdebjebbjjgcif(I):
  objs = objects(I, T, T, T)
  lines = frozenset()
  for obj in objs:
    i, j = ulcorner(obj)
    line_above = frozenset({(THREE, (i - 1, k)) for k in range(j, j + width(obj))})
    line_below = frozenset({(THREE, (i + height(obj), k)) for k in range(j, j + width(obj))})
    lines = lines | line_above | line_below
  O = paint(I, lines)
  return O
 
0.11967592592592594, 10.240304, def ciaeeajjjgggebccajbeghbgbbaacaee(I):
  lines = frozenset()
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        lines = lines | {(THREE, (i-1, j)), (THREE, (i+1, j))}
  O = paint(I, lines)
  return O
 
0.11365740740740742, 9.913427, def gjfhhdbbacaheabaijdcecbgedfacaca(I):
  h = len(I)
  w = len(I[0])
  O = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        O[i][j] = 2
        if i > 0:
          O[i - 1][j] = 3
        if i < h - 1:
          O[i + 1][j] = 3
  return tuple(tuple(row) for row in O)
 
0.27708333333333335, 24.474083, def dbbhadibhafgejjabibbfcdhacijcdec(I):
  objs = objects(I, True, False, True) # Find objects on the grid
  filtered = colorfilter(objs, 2)  # Filter objects with color '2'
  O = paint(I, recolor(3, merge(apply(inbox, filtered)))) # Paint the inbox of '2' objects with '3'
  return O
 
0.1474537037037037, 28.793962, def eeciededbjeeecfhbabccjeeggeegcch(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        for di, dj in [(0,1),(1,0),(-1,0),(0,-1)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
            O = fill(O, 3, {(ni, nj)})
  return O
 
0.1675925925925926, 26.989635, def jdgjifdgfbfcefdjaggacaejbbbbejcd(I):
    padded = canvas(0, (len(I) + 2, len(I[0]) + 2))
    padded = paint(padded, shift(asobject(I), (1, 1)))
    objs = objects(padded, True, False, True)
    filtered = colorfilter(objs, 2)
    O = paint(padded, recolor(3, mapply(lambda obj: difference(dneighbors(centerofmass(obj)),toindices(obj)), filtered)))
    return trim(O)
 
0.11203703703703703, 29.963219, def eagaffccbifcegehieeafdeafbedibdg(I):
  two_objects = objects(I, univalued=True, diagonal=True, without_bg=True)
  expanded_indices = mapply(lambda obj: backdrop(toindices(obj)), colorfilter(two_objects, 2))
  O = fill(I, 3, expanded_indices)
  return O
 
0.2828703703703704, 19.358435, def ffehdbcdbchbefchigffcjdcdcjjfafb(I):
  two_indices = ofcolor(I, 2)
  shifted_indices = mapply(lambda idx: neighbors(idx), two_indices)
  O = fill(I, 3, shifted_indices | two_indices) 
  return O
 
0.13657407407407407, 23.753195, def dadegfbdaaffedgaicbbdacghigcbjcd(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 2:
        O = fill(O, 3, dneighbors((i, j)))
  return O
 
0.2013888888888889, 21.673504, def jfecfjiecieceeijbchhfebabgfgegjf(I):
  two_objects = objects(I, univalued=True, diagonal=True, without_bg=True)
  expanded_objects = mapply(lambda obj: shift(obj, (1, 0)) | shift(obj, (-1, 0)) | shift(obj, (0, 1)) | shift(obj, (0, -1)) | obj, two_objects)
  O = paint(I, recolor(3, expanded_objects))
  return O
 
0.09189814814814815, 16.573305, def cefcffcegegceadfadeeaceffagehdbf(I):
  twos = ofcolor(I, 2)  # Find indices of '2'
  shifted_up = shift(twos, (-1, 0)) # Shift indices one row up
  filtered_indices = intersection(shifted_up, ofcolor(I, 0)) # Intersection with empty cells ('0')
  O = fill(I, 3, filtered_indices)  # Fill with '3'
  return O
 
0.05810185185185185, 30.264742, def ebjahbcgbfbaebabiiebibfbgfaaffjb(I):
  shifted_indices = mapply(lambda idx: (idx[0] - 1, idx[1]), ofcolor(I, 2)) # Get indices shifted upwards
  filtered_indices = intersection(shifted_indices, ofcolor(I, 0)) # Keep only indices with '0' originally
  O = fill(I, 3, filtered_indices) # Fill those indices with '3'
  return O
 
0.09189814814814815, 16.573305, def chaadhcafifhehefjabbfdaeijdgejbd(I):
  # Identify objects of '2's
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, TWO) 
  # Iterate through each '2' object 
  line = frozenset()
  for obj in twos:
    # Get the uppermost row index of the object
    uppermost_row = uppermost(obj) 
    # Create a horizontal line of '3's above the object
    for j in range(leftmost(obj), rightmost(obj) + 1):
        line = insert((THREE, (uppermost_row - 1, j)), line)
  # Paint the lines onto the original grid
  O = paint(I, line)
  return O
 
0.09791666666666668, 16.731316, def chbbedicihfiehdbjifcfjegbgcdbbhf(I):
  # Get indices of all '2's
  indices_2 = ofcolor(I, TWO)
  # Shift the indices upwards by one unit
  shifted_indices = shift(indices_2, (-1, 0)) 
  # Filter out indices that are outside the grid 
  valid_indices = frozenset(loc for loc in shifted_indices if 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]))
  # Create a line of '3's at the valid indices
  line = frozenset((THREE, loc) for loc in valid_indices)
  # Paint the line onto the grid
  O = paint(I, line)
  return O
 
0.05393518518518518, 28.796698, def bejdaaeebfjaeaadbbfdaaajehfbggad(I):
  O = I
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(1, w - 1):
      if I[i][j] == 2 and (I[i][j - 1] == 2 or I[i][j + 1] == 2):
        if I[i][j - 1] == 0:
          O = fill(O, 3, {(i, j - 1)})
        if I[i][j + 1] == 0:
          O = fill(O, 3, {(i, j + 1)})
  return O
 
0.09791666666666668, 10.781635, def dccajcabbfdcedgficehehahccecfaja(I):
  objs = objects(I, T, F, F)
  extensions = set()
  for obj in objs:
    if color(obj) == 2:
      for i, j in toindices(obj):
        if j > 0 and I[i][j-1] == 0:
          extensions.add((3, (i, j-1)))
        if j < len(I[0]) - 1 and I[i][j+1] == 0:
          extensions.add((3, (i, j+1)))
  return paint(I, frozenset(extensions))
 
0.09166666666666667, 10.322759, def chebgfchjjifeghdiehgbbedieeiedaj(I):
  h, w = len(I), len(I[0])
  return tuple(
      tuple(
          3 if 0 < j < w - 1 and I[i][j] == 0 and (I[i][j-1] == 2 or I[i][j+1] == 2) else I[i][j]
          for j in range(w)
      )
      for i in range(h)
  )
 
0.13703703703703704, 21.966585, def gedeebdfeiabeeaijaebgabebchbiead(I):
  objs = objects(I, True, False, True)
  filtered_objs = sfilter(objs, lambda obj: color(obj) == 2 and not bordering(obj, I))
  borders =  frozenset({(i + di, j + dj) for obj in filtered_objs 
                       for i, j in toindices(obj) 
                       for di, dj in [(0,1),(1,0),(0,-1),(-1,0)]
                       if (i + di, j + dj) not in toindices(obj) and 0 <= i + di < len(I) and 0 <= j + dj < len(I[0])})
  return fill(I, 3, borders)
 
0.22893518518518519, 25.125113, def bbgiahgbbaifeiecaccceigcffebcfjf(I):
  twos = ofcolor(I, 2)
  expansion_area = mapply(neighbors, twos)
  O = fill(I, 3, expansion_area - twos)
  return O
 
0.9418981481481481, 59.46244, def cgdbaaijfbcaecgcadabeefebjhgccch(I):
  def process_object(obj):
    shifted_obj = shift(obj, (-1, 0)) 
    return frozenset((3, (i + len(I) if i < 0 else i, j)) for _, (i, j) in shifted_obj if 0 <= j < len(I[0]))
  
  objs = objects(I, True, False, False) 
  shifted_objs = apply(process_object, objs) 
  O = paint(I, merge(shifted_objs)) 
  return O
 
0.09814814814814815, 16.572588, def fbffafchbgbeeahajhgccgbiiecffdbe(I):
  def process_cell(i, j):
    return 3 if I[i][j] == 0 and I[(i + 1) % len(I)][j] == 2 else I[i][j]

  O = tuple(tuple(process_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
  return O
 
0.08796296296296297, 13.956858, def bfeddfacbgedebafbfaefcfhjdchgbga(I):
  objs = objects(I, F, F, T)
  twos = colorfilter(objs, TWO)
  line = frozenset()
  for obj in twos:
    if hline(obj):
      for j in range(leftmost(obj), rightmost(obj) + 1):
        line = insert((THREE, (uppermost(obj) - 1, j)), line)
    elif vline(obj):
      for i in range(uppermost(obj), lowermost(obj) + 1):
        line = insert((THREE, (i, rightmost(obj) + 1)), line)
  O = paint(I, line)
  return O
 
0.05416666666666667, 26.799696, def fcjcjgjegecheddgiaeahbdadjfehjhh(I):
  lines = frozenset()
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == TWO:
        if (i > 0 and I[i - 1][j] == TWO) and (j > 0 and I[i][j - 1] != TWO):
          lines = insert((THREE, (i, j + 1)), lines)
        elif (j > 0 and I[i][j - 1] == TWO) and (i > 0 and I[i - 1][j] != TWO):
          lines = insert((THREE, (i - 1, j)), lines)
  O = paint(I, lines)
  return O
 
0.1439814814814815, 16.077168, def ebefcddcbddeefaciicjeeddcgbbchhc(I):
  O = I
  for obj in colorfilter(objects(I, F, F, T), TWO):
    if hline(obj):
      O = fill(O, THREE, {(uppermost(obj) - 1, j) for j in range(leftmost(obj) - 1, rightmost(obj) + 2)})
    elif vline(obj):
      O = fill(O, THREE, {(i, rightmost(obj) + 1) for i in range(uppermost(obj) - 1, lowermost(obj) + 2)})
  return O
 
0.05810185185185185, 30.264742, def faidjfcaghhbefahjcgheacdfafgdici(I):
  def extend_line(obj):
    if hline(obj):
      return frozenset((THREE, (uppermost(obj) - 1, j)) for j in range(leftmost(obj) - 1, rightmost(obj) + 2))
    elif vline(obj):
      return frozenset((THREE, (i, rightmost(obj) + 1)) for i in range(uppermost(obj) - 1, lowermost(obj) + 2))
    else:
      return frozenset()
  
  extended_lines = mfilter(objects(I, F, F, T), extend_line)
  return paint(I, extended_lines)
 
0.08587962962962964, 29.544168, def ccdbcaideefjefafiafedebdfcecbefi(I):
  objs = objects(I, True, False, True)
  filtered_objs = sfilter(colorfilter(objs, 2), lambda obj: not bordering(obj, I))
  outlines = apply(lambda obj: difference(box(obj), obj), filtered_objs)
  return fill(I, 3, merge(outlines))
 
0.14583333333333334, 36.66027, def gahgdfebfaedeebhadehecccadgccbci(I):
    O = canvas(0, shape(I)) # Initialize output grid with all '0's
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 2:  # If we find a '2'
                new_i = i - 1  # Calculate the row index above
                if new_i < 0:
                    new_i += len(I)  # Wrap around if necessary
                if 0 <= new_i < len(I) and 0 <= j < len(row) and I[new_i][j] == 0:
                    O = fill(O, 3, {(new_i, j)})  # Fill with '3' if valid
            else:
                O = fill(O, val, {(i, j)}) # Otherwise, copy the original value
    return O
 
0.22893518518518519, 25.125113, def gicbbccdicgeechajebbedcfafffcaae(I):
  objs = objects(I, F, F, T)
  twos = colorfilter(objs, TWO)
  bordered = mapply(lambda obj: outbox(obj), twos)
  O = paint(I, recolor(THREE, bordered))
  return O
 
0.1474537037037037, 28.793962, def beadbbdfcbjeedffachfajdhhbdjjfea(I):
  dilated = mapply(dneighbors, ofcolor(I, TWO))
  O = paint(I, recolor(THREE, dilated - ofcolor(I, TWO)))
  return O
 
0.16365740740740742, 27.39085, def fddehdchjjadefcjiegadjddefceebib(I):
  padded = canvas(ZERO, add(shape(I), (2, 2)))
  padded = paint(padded, shift(asobject(I), (1, 1)))
  bordered = mapply(lambda loc: frozenset({(THREE, add(loc, d)) for d in [(1, 0), (-1, 0), (0, 1), (0, -1)]}), ofcolor(padded, TWO))
  O = trim(paint(padded, bordered))
  return O
 
0.17569444444444443, 27.17949, def ajdiabcfcabfebhdifhedffhchbjacab(I):
  O = I
  for obj in objects(I, True, False, True):
      O = paint(O, recolor(THREE,  dneighbors(centerofmass(obj))))
  return O
 
0.07962962962962963, 9.193013, def acfaeeabadjaeegaaedeaejdccbfbfgb(I):
  return paint(I, merge(apply(lambda loc: frozenset({(3, (loc[0], loc[1] - 1))}) if index(I, (loc[0], loc[1] - 1)) == 0 else frozenset() | frozenset({(3, (loc[0], loc[1] + 1))}) if index(I, (loc[0], loc[1] + 1)) == 0 else frozenset(), ofcolor(I, 2))))
 
0.09050925925925926, 9.009652, def efeedeeefcaeebbdjifejdjidbbfeaai(I):
  h, w = len(I), len(I[0])
  new_grid = [[I[i][j] for j in range(w)] for i in range(h)]
  for i in range(h):
    for j in range(1, w-1):
      if I[i][j] == 2:
        if I[i][j - 1] == 0:
          new_grid[i][j - 1] = 3
        if I[i][j + 1] == 0:
          new_grid[i][j + 1] = 3
  return tuple(tuple(row) for row in new_grid)
 
0.21782407407407406, 11.980622, def aaadgecgcedceefcaccefgehffecdaab(I):
  """
  Identifies and expands objects of '2' using a sliding window approach.
  """
  h, w = len(I), len(I[0])
  output = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            ni, nj = i + di, j + dj
            if 0 <= ni < h and 0 <= nj < w and I[ni][nj] == 0:
              output[ni][nj] = 3
      else:
        output[i][j] = I[i][j]
  return tuple(tuple(row) for row in output)
 
0.07175925925925926, 22.00766, def haeigafedfacefcfjddddfcdaecegeaa(I):
    x1 = mostcolor(I)
    x2 = objects(I, True, False, True)  # Find objects, excluding background
    x3 = sfilter(x2, lambda x: size(x) > 1 and (hline(x) or vline(x)))  # Lines longer than one cell
    O = canvas(x1, shape(I))  # Create a canvas filled with background color
    for x4 in x3:
        x5 = toindices(x4)
        x6 = {(i + 1, j) for i, j in x5} | {(i - 1, j) for i, j in x5}  # Above and below
        x7 = {(i, j + 1) for i, j in x5} | {(i, j - 1) for i, j in x5}  # Left and right
        O = branch(hline(x4), fill(O, 3, x6), fill(O, 3, x7))  # Fill based on line orientation
        O = paint(O, x4)  # Paint the original line back
    return O
 
0.036111111111111115, 6.697313, def aefcjfjfdcciegcebgdfdbbbbjaeaagd(I):
    x1 = leastcolor(I)
    x2 = objects(I, True, False, False)
    x3 = sfilter(x2, lambda x: size(x) > 1 and (hline(x) or vline(x)))
    O = I
    for x4 in x3:
      for x5 in toindices(x4):
        i, j = x5
        O = fill(O, 3, {(i + 1, j), (i - 1, j)})  # Always fill above and below
        O = fill(O, 3, {(i, j + 1), (i, j - 1)})  # Always fill left and right
    return O
 
0.06620370370370371, 24.527277, def fahjifijdcbcecadbaddjidgecaiccji(I):
    x1 = objects(I, True, False, False)
    x2 = sfilter(x1, lambda x: (hline(x) or vline(x)) and size(x) > 1)
    O = I
    for obj in x2:
        x3 = toindices(obj)
        x4 = {(i + sign(i - centerofmass(x3)[0]), j) for i, j in x3}
        x5 = {(i, j + sign(j - centerofmass(x3)[1])) for i, j in x3}
        O = fill(O, 3, x4 | x5)  # Union of vertical and horizontal fills
    return O
 
0.13703703703703704, 27.642496, def eadicicehjdgeehdacjideegdeejjcdh(I):
  h, w = len(I), len(I[0])
  O = tuple(
      tuple(
          3 if (0 < j < w - 1 and I[i][j] == 0 and (I[i][j - 1] == 2 or I[i][j + 1] == 2)) 
             or (0 < i < h - 1 and I[i][j] == 0 and (I[i - 1][j] == 2 or I[i + 1][j] == 2))
          else I[i][j]
          for j in range(w)
      )
      for i in range(h)
  )
  return O
 
0.15023148148148147, 20.1179, def jheedbhbdajjejdaaafichbiajdcefde(I):
  """
  Expands '2' objects by one layer using a convolution-like operation.
  """
  kernel = ((0, 1, 0),
            (1, 1, 1),
            (0, 1, 0))
  h, w = len(I), len(I[0])
  output = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(1, h - 1):
    for j in range(1, w - 1):
      if I[i][j] == 0 and any(I[i + di][j + dj] == 2 for di in range(-1, 2) for dj in range(-1, 2) if kernel[di + 1][dj + 1] == 1):
        output[i][j] = 3
      else:
        output[i][j] = I[i][j]
  return tuple(tuple(row) for row in output)
 
0.15208333333333335, 35.989475, def ebfbceajadadeicejaahdcebaeagecad(I):
  O = canvas(0, shape(I)) # Initialize output grid
  for i, j in product(range(len(I)), range(len(I[0]))):
    if I[i][j] == 2:
      new_i = (i - 1 + len(I)) % len(I) # Calculate shifted row index with wrap-around
      if I[new_i][j] == 0:
        O = fill(O, 3, {(new_i, j)}) # Fill with '3' if valid
  return O
 
0.2828703703703704, 19.358435, def ebdbheiigbjgedeeiefjhgcfiiefcecf(I):
  O = I
  for obj in colorfilter(objects(I, F, F, T), TWO):
    O = fill(O, THREE, {(i, j) for i in range(uppermost(obj) - 1, lowermost(obj) + 2) for j in range(leftmost(obj) - 1, rightmost(obj) + 2)})
  return O
 
0.9377314814814814, 54.3037, def hfdeabjibfbhejcjifccbcaejfhdcica(I):
  return paint(I, 
               merge(apply(lambda obj: 
                           recolor(3, 
                                   frozenset((i, j) for i, j in toindices(obj) 
                                            for di in [-1, 1] if 0 <= j + di < len(I[0]) 
                                            and I[i][j + di] == 0)), 
                           objects(I, T, F, F))))
 
0.1252314814814815, 10.627536, def aeaacccjiebceecbjhcdaecffebdheed(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])//2, len(I[0])):  # Iterate over the right half
            if I[i][j] == 2:
                for di in range(-1, 2):
                    for dj in range(-1, 2):
                        ni, nj = i + di, j + dj
                        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == 0:
                            O = fill(O, 3, {(ni, nj)})
    return O
 
0.04953703703703703, 37.921555, def bfjecjagieabeaejajacfahjddabdcbg(I):
    O = lefthalf(I)
    for j in range(len(I[0])//2, len(I[0])):
        for i in range(len(I)):
            if I[i][j] == 2:
                O = paint(O, recolor(3, neighbors((i, j))))
            else:
                O = paint(O, {(I[i][j], (i, j))})
    return O
 
0.11226851851851852, 16.671618, def ejcedjecgdbeeeebahafcaicjjegehea(I):
    O = canvas(0, shape(I))
    for i in range(len(I)):
        for j in range(len(I[0])):
            if j >= len(I[0]) // 2 and I[i][j] == 2:
                O = paint(O, recolor(3, dneighbors((i, j))))
            else:
                O = paint(O, {(I[i][j], (i, j))})
    return O
 
0.16365740740740742, 19.570705, def aihadfbfdacgedabaahbaabfedcgbcah(I):
  """
  Expands '2' objects by one layer, filling only '0' cells.
  """
  h, w = len(I), len(I[0])
  output = [[0 for _ in range(w)] for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]: # Only consider direct neighbors
          ni, nj = i + di, j + dj
          if 0 <= ni < h and 0 <= nj < w and I[ni][nj] == 0:
            output[ni][nj] = 3
      else:
        output[i][j] = I[i][j]
  return tuple(tuple(row) for row in output)
 
0.15601851851851853, 16.236086, def aeafejafejdaefdjiefbjheejfdbehbf(I):
  shifted_indices = apply(lambda idx: (idx[0] - 1, idx[1]), ofcolor(I, 2))
  wrapped_indices = apply(lambda idx: (idx[0] + len(I), idx[1]) if idx[0] < 0 else idx, shifted_indices)
  O = fill(I, 3, ofcolor(I, 2))
  return underpaint(O, recolor(2, wrapped_indices))
 
0.9398148148148148, 32.83565, def acaaddjciaeaefbhahehedahhdagfdaf(I):
  objs = objects(I, True, False, False)
  shifted_objs = apply(lambda obj: shift(obj, (-1, 0)), objs)
  wrapped_objs = apply(lambda obj: frozenset(((v, (i + len(I), j)) if i < 0 else (v, (i, j))) for v, (i, j) in obj), shifted_objs)
  O = I
  for obj in objs:
    O = cover(O, obj)
  for obj in wrapped_objs:
    O = paint(O, obj)
  return fill(O, 3, ofcolor(O, 0)) 
 
0.14375, 16.186434, def jidbgjgbiabbefejbechchiihfbdafib(I):
  O = paint(canvas(0, shape(I)), recolor(2, apply(lambda idx: (idx[0] - 1, idx[1]), ofcolor(I, 2))))
  return fill(paint(I, recolor(3, ofcolor(I, 2))), 2, ofcolor(O, 2))
 
0.15000000000000002, 16.148073, def dggehfgebfieeaaebdgjgehcageadfea(I):
  O = canvas(0, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        new_i = (i - 1 + len(I)) % len(I)
        O = paint(O, {(2, (new_i, j))})
  return fill(paint(I, recolor(3, ofcolor(I, 2))), 2, ofcolor(O, 2))
 
0.14004629629629628, 17.741756, def fjdachfdddejefccbheccaffebdcafac(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        if i > 0 and I[i-1][j] != TWO:
          O = fill(O, THREE, {(i - 1, j)})
        if j > 0 and I[i][j-1] != TWO and I[i-1][j-1] != TWO:
          O = fill(O, THREE, {(i - 1, j - 1)})
        if j < len(row) - 1 and I[i][j+1] != TWO and I[i-1][j+1] != TWO:
          O = fill(O, THREE, {(i - 1, j + 1)})
  return O
 
0.8291666666666666, 22.61625, def djdccfbfbidfedbfaegdhfhagcefgafe(I):
  return paint(I, 
               merge(apply(lambda obj: 
                             recolor(3, 
                                     frozenset((i-1,j) for i, j in toindices(obj) 
                                              if i > 0 and index(I, (i-1,j))==0)), 
                             objects(I,T,F,F))))
 
0.09189814814814815, 16.573305, def cbbdbdagdfceeebcjefhfhgedebadddi(I):
  return paint(I, 
               frozenset((3, (i - 1, j)) 
                         for i in range(1, len(I)) 
                         for j in range(len(I[0])) 
                         if I[i][j] == 2 and I[i - 1][j] == 0)) 
 
0.16365740740740742, 27.39085, def ecjhffcdfbafegiaidbafbihdidcfhfe(I):
  objs = objects(I, True, False, True)
  filtered_objs = colorfilter(objs, 2)
  modified_grid = I
  for obj in filtered_objs:
    for value, (i, j) in obj:
      for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        ni, nj = i + di, j + dj
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]):
          modified_grid = fill(modified_grid, 3, {(ni, nj)})
  return modified_grid
 
0.16412037037037036, 17.462053, def ehjiciffeediejfebchffcdbffiaafce(I):
  O = upscale(I, THREE)
  O = replace(O, TWO, THREE)
  objs = objects(I, T, F, T)
  for obj in objs:
    for v, (i, j) in obj:
      O = fill(O, v, {(THREE * i + ONE, THREE * j + ONE)})
  return O
 
0.11805555555555555, 50.0565, def hcfjeebbbebiedecagadgiacbbhjddgf(I):
  O = canvas(ZERO, multiply(shape(I), THREE))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        O = paint(O, recolor(val, {(THREE * i + ONE, THREE * j + ONE)}))
        O = paint(O, recolor(THREE, backdrop({(THREE * i + ONE, THREE * j + ONE)})))
  return O
 
0.11805555555555555, 50.257614, def bfgachjjghbcejddbbacebabcfeafbhe(I):
  objs = objects(I, T, F, T)
  O = canvas(ZERO, multiply(shape(I), THREE))
  for obj in objs:
    for v, (i, j) in obj:
      O = paint(O, recolor(THREE, backdrop({(THREE * i + ONE, THREE * j + ONE)})))
      O = paint(O, recolor(v, {(THREE * i + ONE, THREE * j + ONE)}))
  return O
 
0.24351851851851852, 26.206413, def iiejcbbccaccecchidfcefgfdcgjbaac(I):
    O = upscale(I, TWO)
    for obj in objects(O, univalued=T, diagonal=F, without_bg=T):
        O = underfill(O, THREE, outbox(toindices(obj)))
    return O
 
0.2585648148148148, 13.794484, def dbdejdajdgdfebdjbjecccbjddacfaed(I):
    O = upscale(I, TWO)
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        O = paint(O, shift(recolor(THREE, outbox(toindices(obj))), (ONE, ONE)), )
    return O
 
0.16458333333333333, 17.053928, def bdacecbicgfbedbgbfgaegbcbbjaaibd(I):
    O = upscale(I, TWO)
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        indices = toindices(obj)
        shifted_indices = shift(indices, (ONE, ONE))
        O = fill(O, THREE, delta(shifted_indices))
        O = paint(O, shift(recolor(color(obj), indices), (ONE, ONE)))
    return O
 
0.18194444444444446, 15.387824, def hcefabfbhedjeeefiabcfadchcbjdibj(I):
    O = canvas(mostcolor(I), multiply(shape(I), TWO))
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        O = paint(O, shift(upscale(obj, TWO), (ONE, ONE)))
    return O
 
0.21481481481481482, 10.484965, def fbaceadcfcbdejfbbidfdjdbbedaagja(I):
    O = upscale(replace(I, mostcommon(I), THREE), TWO)
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        O = underpaint(O, shift(upscale(obj, TWO), (ONE, ONE)))
    return O
 
0.16805555555555557, 15.185486, def haaiadddgccgefcgifbefbdedeiebggc(I):
  objs = objects(I, T, F, T)
  new_objs = []
  for obj in objs:
    if color(obj) == 2:
      indices = toindices(obj)
      new_indices = set()
      for i, j in indices:
        new_indices.update(dneighbors((i,j)))
      new_obj = recolor(3, frozenset(new_indices))
      new_objs.append(new_obj)
  return paint(canvas(0, (15, 18)), merge(new_objs)) 
 
0.08865740740740741, 40.96522, def bccgjgbgeiedefbgaaabedaddebfdacg(I):
  objs = objects(I, T, F, T)
  bordered_objs = mfilter(objs, lambda obj: recolor(3, outbox(toindices(obj))) if color(obj) == 2 else initset(0))
  return paint(canvas(0, (15, 18)), bordered_objs)
 
0.12407407407407407, 43.25343, def dbaghaaeejcfeibbaideabgddaccccfc(I):
    objs = objects(I, T, F, T)
    new_grid = canvas(0, (15,18))
    for obj in objs:
        if color(obj) == 2:
            shifted_obj = shift(obj, (1,1))
            new_grid = paint(new_grid, recolor(3, toindices(shifted_obj)))
    return new_grid 
 
0.17754629629629629, 11.93491, def eidaijfcaiefeaddbigebdibicgcceie(I):
    objs = objects(I, T, F, T)  # Extract objects, excluding background
    twos = colorfilter(objs, 2)  # Filter for objects with color '2'
    new_grid = canvas(0, (15, 18))  # Create a blank canvas for the output
    
    for obj in twos:
        i, j = centerofmass(obj)  # Find center of each '2' object
        new_grid = fill(new_grid, 3, connect((i,j-1), (i, j+1)))  # Draw horizontal line of '3's
        new_grid = fill(new_grid, 3, connect((i-1,j), (i+1, j)))  # Draw vertical line of '3's
        new_grid = paint(new_grid, shift(obj, (i, j + 13)))  # Paint the '2' object shifted right
    
    return new_grid 
 
0.17731481481481481, 11.298077, def jfbceehaficbeabgachgbbabdfbjfaad(I):
    objs = objects(I, T, F, T)
    twos = colorfilter(objs, 2)
    new_grid = canvas(0, (15, 18))
    pattern = ((3, 3, 3), (3, 2, 3), (3, 2, 3), (3, 3, 3))  # Define the '+' pattern

    for obj in twos:
        i, j = ulcorner(obj)  # Get the upper-left corner of the '2' object
        for di, row in enumerate(pattern):
            for dj, value in enumerate(row):
                new_grid = fill(new_grid, value, {(i + di, j + dj + 13)})  # Paint the pattern
        new_grid = paint(new_grid, shift(obj, (0, 13)))  # Shift the '2' object right

    return new_grid
 
0.3055555555555556, 27.340326, def egdjdjijabaaedhabfefaiafeejafaeb(I):
    left_part = hsplit(I, 1)[0]  # Extract the left portion of the input grid
    right_part = canvas(0, (15, 3))  # Create a blank right portion
    new_grid = hconcat(left_part, right_part)  # Concatenate to form the output grid
    objs = objects(I, T, F, T)
    twos = colorfilter(objs, 2)

    for obj in twos:
        i, j = centerofmass(obj)
        new_grid = fill(new_grid, 3, connect((i, j - 1), (i, j + 14)))  # Horizontal line extended to the right

    return new_grid
 
0.2328703703703704, 9.861441, def djgfedbdecjeedjdiceecbfgeabiaadf(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  new_grid = hupscale(I, 3)  #  Triple the grid horizontally
  
  for obj in twos:
    i, j = ulcorner(obj)
    new_grid = fill(new_grid, 3, {(i, j + 1), (i, j + 2), (i + 1, j), (i + 1, j + 3), (i + 2, j), (i + 2, j + 3)}) # Draw the '+' pattern
  
  return new_grid
 
0.1509259259259259, 18.58266, def ehafbdjjfaahecaajcfdifacfajffhab(I):
  O = upscale(I, 2)
  objs = objects(O, False, False, False)
  for obj in objs:
    if color(obj) == 2 and any(manhattan(obj, other) == 1 for other in objs - {obj}):
      for loc in toindices(obj):
        for d in [UP, DOWN, LEFT, RIGHT]:
          O = underfill(O, 3, shoot(loc, d))
  return O 
 
0.16666666666666669, 13.167695, def adgcijgcejffejjejdceafcbbdajfgij(I):
  O = canvas(0, (len(I) * 2, len(I[0]) * 2))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      O = fill(O, v, {(2*i, 2*j), (2*i + 1, 2*j), (2*i, 2*j + 1), (2*i + 1, 2*j + 1)})
      if v == 2:
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
          ni, nj = 2*i + di, 2*j + dj
          if 0 <= ni < len(O) and 0 <= nj < len(O[0]) and O[ni][nj] == 0:
            O = fill(O, 3, {(ni, nj)})
  return O
 
0.21782407407407406, 24.346659, def dceddfdaijghebbeibggechjehebjgdj(I):
  O = upscale(I, 2)
  for i in range(len(O)):
    for j in range(len(O[0])):
      if O[i][j] == 2 and ((i > 0 and O[i-1][j] == 2) or (i < len(O)-1 and O[i+1][j] == 2) or (j > 0 and O[i][j-1] == 2) or (j < len(O[0])-1 and O[i][j+1] == 2)):
        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
          ni, nj = i + di, j + dj
          if 0 <= ni < len(O) and 0 <= nj < len(O[0]) and O[ni][nj] == 0:
            O = fill(O, 3, {(ni, nj)})
  return O
 
0.3053240740740741, 15.321392, def ifgaeejdeadceadjajgfjgcegeegiafc(I):
    O = canvas(mostcolor(I), multiply(shape(I), TWO))
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        upscaled_obj = shift(upscale(obj, TWO), (ONE, ONE))
        O = paint(O, upscaled_obj)
        for (v, (i, j)) in upscaled_obj:
            if i > 0 and j > 0 and i < len(O)-1 and j < len(O[0])-1:
                O = fill(O, THREE, {(i-1,j),(i+1,j),(i,j-1),(i,j+1)})
    return O
 
0.045370370370370366, 42.12921, def eaeicddhafehefebbbhgfjcacghdeaff(I):
  objs = objects(I, T, F, T) 
  def modify_obj(obj):
    return recolor(3, outbox(toindices(obj))) if color(obj) == 2 else initset(0)
  bordered_objs = mfilter(objs, modify_obj)
  return paint(canvas(0, shape(I)), bordered_objs) 
 
0.09212962962962962, 41.569664, def feeedajebjceefehigbfjbhjceebhcbc(I):
  objs = objects(I, T, F, T)
  box_indices = mfilter(objs, lambda obj: outbox(toindices(obj)) if color(obj) == 2 else initset(0))
  output_grid = canvas(0, shape(I))
  return fill(output_grid, 3, box_indices)
 
0.5581018518518519, 15.639456, def bfhfhdebbgeiegbbaffgaicgdibefhfh(I):
  # Upscale input grid
  x1 = upscale(I, 2) 
  # Identify objects
  x2 = objects(I, T, F, F)
  # Create shifted outline (down by one)
  x3 = mapply(lambda o: shift(delta(toindices(o)), (1, 0)), x2)
  # Combine outline with original object
  x4 = mapply(lambda o: combine(toindices(o), x3), x2)
  # Remove original object from the combined set
  x5 = mapply(lambda o: difference(x4, toindices(o)), x2)
  # Paint outline on the upscaled grid
  O = paint(x1, recolor(THREE, x5)) 
  return O
 
0.21620370370370373, 23.58343, def bigfhfjihgfieebgadaffjgfiddhdeac(I):
  # Upscale input grid and find objects
  x1 = upscale(I, 2) 
  x2 = objects(x1, T, F, F)
  # Create an expanded bounding box (one cell larger on all sides except bottom)
  x3 = mapply(lambda o: difference(outbox(toindices(o)), {(lowermost(o) + 1, j) for j in range(leftmost(o) - 1, rightmost(o) + 2)}), x2) 
  # Paint expanded bounding box as the outline
  O = paint(x1, recolor(THREE, x3)) 
  return O
 
0.9398148148148148, 18.840887, def dagjfijcabgjeiceaabbhgabfbdbedaf(I):
  # Upscale the input grid
  x1 = upscale(I, 2)
  # Find the background color
  x2 = mostcolor(x1)
  # Create a grid filled with the outline color
  x3 = canvas(THREE, shape(x1))
  # Paint the upscaled grid onto the outline grid
  x4 = paint(x3, asobject(x1))
  # Replace the background color with the original background color
  O = replace(x4, x2, THREE) 
  return O
 
0.16203703703703703, 17.884949, def adghadbjjjfjebhiihjcaffafjifabda(I):
  O = upscale(I, THREE)
  objs = objects(I, False, False, False)
  for obj in objs:
    if color(obj) == TWO:
      for _, (i, j) in obj:
        O = fill(O, THREE, crop(O, (THREE * i, THREE * j), THREE_BY_THREE))
        O = fill(O, TWO, {(THREE * i + ONE, THREE * j + ONE)})
  return O
 
0.3476851851851852, 32.433468, def edhfeabcdiadecdgjhdjajeadbgfjcff(I):
    O = canvas(mostcolor(I), multiply(shape(I), TWO))  # Create upscaled canvas
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        upscaled_obj = shift(upscale(obj, TWO), (ONE, ONE)) # Upscale and shift object
        for di in range(-1, 2):
            for dj in range(-1, 2):
                if di != 0 or dj != 0:
                    O = underfill(O, THREE, shift(toindices(upscaled_obj), (di, dj))) # Draw outline layer by layer
        O = paint(O, upscaled_obj)  # Paint upscaled object
    return O
 
0.05897435897435897, 41.68091, def jafdhhhegcfaeeejbabjehbbbbcbifae(I):
  def process_object(obj):
    return recolor(3, outbox(toindices(obj))) if color(obj) == 2 else initset(0)
  return paint(canvas(0, add(shape(I), (2, 4))), mfilter(objects(I, T, F, T), process_object)) 
 
0.23098290598290597, 14.546151, def dffgfegaffggeghjjfbchcaibdeefbci(I):
    new_grid = canvas(0, add(shape(I), (2, 4)))
    for obj in objects(I, T, F, T):
        if color(obj) == 2:
            new_grid = paint(new_grid, recolor(3, outbox(toindices(obj))))
    return new_grid
 
0.19282407407407406, 14.596561, def ddfbeeeaabcbeeedacfdjfjedjgbbfbf(I):
  # Upscale the input
  x1 = upscale(I, 2) 
  # Identify objects in the upscaled grid
  x2 = objects(x1, T, F, F)
  # Create the right and top outline
  x3 = mapply(lambda o: difference(outbox(toindices(o)),
                                     {(i,j) for i,j in outbox(toindices(o)) if i == lowermost(o) + 1 or j == leftmost(o) -1}), x2) 
  # Paint the outline
  O = paint(x1, recolor(THREE, x3)) 
  return O
 
0.1509259259259259, 18.58266, def dbhiciabaifgeifbachdhafbjefchdce(I):
  x1 = upscale(I, 2)
  x2 = objects(x1, T, F, F)
  x3 = mapply(lambda o: frozenset((i + 1, j) for i, j in toindices(o)), x2)
  x4 = mapply(lambda o: frozenset((i, j + 1) for i, j in toindices(o)), x2)
  x5 = merge((x3, x4))
  O = paint(x1, recolor(THREE, difference(x5, toindices(merge(x2)))))
  return O
 
0.18449074074074073, 14.531221, def ddcefgfgbadfefaijcbefeajcbafahff(I):
  O = upscale(I, 2)
  for i, j in asindices(I):
    if I[i][j] == 2:
      if j + 1 < len(I[0]):
        O = fill(O, 3, {(2*i, 2*j + 2), (2*i + 1, 2*j + 2)})
      if i + 1 < len(I):
        O = fill(O, 3, {(2*i + 2, 2*j), (2*i + 2, 2*j + 1)})
  return O
 
0.18842592592592594, 9.886918, def gbcagifdfcgjebheibgbciagedcbgdca(I):
  O = upscale(I, 2)
  twos =  toobject(ofcolor(I, 2), I)
  shifted_right = shift(twos, (0, 1))
  shifted_down = shift(twos, (1, 0))
  shifted_diagonal = shift(twos, (1, 1))
  combined_shifts = shifted_right | shifted_down | shifted_diagonal
  filtered_shifts = frozenset((v, (i, j)) for v, (i, j) in combined_shifts if 0 <= i < len(O) and 0 <= j < len(O[0]))
  return paint(O, recolor(3, filtered_shifts))
 
0.16412037037037036, 16.857893, def ceefigbfhdebefehbceacciigfdfhefd(I):
  O = upscale(I, THREE)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        O = fill(O, THREE, crop(O, (THREE * i + ONE, THREE * j + ONE), (TWO, TWO)))
        O = fill(O, TWO, {(THREE * i + ONE, THREE * j + ONE)})
  return O
 
0.12199074074074075, 47.846603, def ehdcefecccehegdjieffibbgecffbfbc(I):
  O = canvas(ZERO, multiply(shape(I), THREE))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        O = fill(O, THREE,  crop(O, (THREE * i + ONE, THREE * j + ONE), (TWO, TWO)))
        O = paint(O, recolor(TWO, {(THREE * i + ONE, THREE * j + ONE)}))
  return O
 
0.3476851851851852, 31.78685, def cgafjejbajcaegdeaefeefjafgebgddf(I):
  O = canvas(mostcolor(I), multiply(shape(I), TWO))  # Create upscaled canvas
  for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
    shifted_obj = shift(upscale(obj, TWO), (ONE, ONE)) # Upscale & shift object
    outline = paint(O, recolor(THREE, outbox(toindices(shifted_obj)))) # Create outline separately
    O = paint(outline, shifted_obj)  # Paint the object on the outline
  return O
 
0.21574074074074073, 10.987211, def aejjecedcgbeedcbjffahgbagjafddgc(I):
  return paint(
      canvas(0, (15, 18)),
      merge(apply(lambda obj: recolor(3, outbox(toindices(obj))), colorfilter(objects(I, T, F, T), 2)))
  )
 
0.15300925925925926, 19.094282, def fjgbageafcadecfcjciifgiacdffbdbc(I):
  x1 = upscale(I, 2)
  x2 = objects(x1, T, F, F)
  x3 = mapply(lambda o: delta(shift(backdrop(toindices(o)), (1, 1))), x2)
  x4 = mapply(lambda o: delta(shift(backdrop(toindices(o)), (-1, -1))), x2)
  O = paint(x1, recolor(THREE, merge((x3, x4, mapply(delta, x2)))))
  return O
 
0.22060185185185183, 28.05921, def abccfhjddhideadejagbbebfcheafcbh(I):
  O = upscale(I, 2)
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        start_j = 2 * j 
        end_j = len(O[0])
        for k in range(j + 1, len(I[0])):
          if I[i][k] == 2:
            end_j = 2 * k 
            break
        fill_indices = {(2 * i, l) for l in range(start_j, end_j)}
        O = underfill(O, 3, fill_indices)
  return O
 
0.21689814814814812, 27.89554, def jcidecbcbcadecjfbgcfdffecbdadedc(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    j = 0
    while j < len(row):
      if row[j] == 2:
        try:
          next_two = next(k for k in range(j + 1, len(row)) if row[k] == 2)
          O = underfill(O, 3, {(2 * i, l) for l in range(2 * j, 2 * next_two)})
          j = next_two 
        except StopIteration:
          O = underfill(O, 3, {(2 * i, l) for l in range(2 * j, len(O[0]))})
          break 
      j += 1
  return O
 
0.18032407407407408, 15.283345, def dbjdibhbffedeabeiabagiebbccedefh(I):
  O = canvas(mostcolor(I), multiply(shape(I), TWO)) # Initialize with background
  for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
    upscaled_obj = shift(upscale(obj, TWO), (ONE, ONE))  # Upscale and shift object
    O = paint(O, upscaled_obj)  # Paint the upscaled object
    O = paint(O, recolor(THREE, box(toindices(upscaled_obj)))) # Draw outline using box
  return O
 
0.18310185185185185, 17.30763, def ebdegjeabcbaecdjaabbabhacjhcegei(I):
  objs = objects(I, T, F, T)  # Identify all '2' objects
  twos = colorfilter(objs, 2)  # Filter for objects with color '2'
  new_grid = canvas(0, (15, 18))  # Create the larger output grid

  for obj in twos:
    i, j = ulcorner(obj)  # Get the upper-left corner of the '2' object
    
    # Draw the '+' pattern around each '2'
    new_grid = fill(new_grid, 3, {(i-1,j), (i+1,j), (i,j-1), (i,j+1)})  
    
    new_grid = paint(new_grid, shift(obj, (0, 13)))  # Shift the '2' object right 

  return new_grid
 
0.17754629629629629, 15.085092, def affbheeacgfbegadjedgcfgbceeaaeif(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  new_grid = canvas(0, (15, 18))

  for obj in twos:
    for cell in obj:
      i, j = cell[1] # Get cell indices
      neighbors = dneighbors((i, j)) # Get direct neighbors
      new_grid = fill(new_grid, 3, neighbors)  # Fill neighbors with '3'
    new_grid = paint(new_grid, shift(obj, (0, 13)))

  return new_grid
 
0.1375, 37.840515, def badjeedagiideibejbhagbffcadeecdb(I):
    objs = objects(I, T, F, T)
    twos = colorfilter(objs, 2)
    new_grid = canvas(0, (15, 18))

    for obj in twos:
        outer_box = box(shift(obj, (0, 1)))  # Get the outer box of the shifted object
        new_grid = fill(new_grid, 3, difference(outer_box, toindices(obj)))  # Fill the difference with '3'
        new_grid = paint(new_grid, shift(obj, (0, 13)))  # Shift the '2' object right

    return new_grid
 
0.2150462962962963, 27.276682, def bgjbcabaffbeedjaaacaicfdahefbibd(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    twos = [j for j, v in enumerate(row) if v == 2]
    start = 0
    while start < len(twos):
      end = start + 1 if start + 1 < len(twos) else len(row)
      O = underfill(O, 3, {(2 * i, l) for l in range(2 * twos[start], 2 * end)})
      start += 2
  return O
 
0.1902777777777778, 20.245129, def bjeijdagccaeeghcbbjfcbbeeagbdgei(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    for j in range(0, len(row), 2):
      if row[j] == 2:
        try:
          next_two = next(k for k in range(j + 1, len(row)) if row[k] == 2)
          O = fill(O, 3, {(2 * i, l) for l in range(2 * j, 2 * next_two)})
        except StopIteration:
          O = fill(O, 3, {(2 * i, l) for l in range(2 * j, len(O[0]))})
  return O
 
0.19027777777777777, 14.735144, def fbgedideedhieffjbdedgeidcchbchaa(I):
  O = canvas(mostcolor(I), multiply(shape(I), TWO)) # Create a canvas with background color and double size
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != mostcolor(I): # Check for non-background cells
        O = paint(O, recolor(value, {(2*i+1, 2*j+1), (2*i+1, 2*j+2), (2*i+2, 2*j+1), (2*i+2, 2*j+2)}))  # Paint 2x2 block
        O = underfill(O, THREE, outbox({(2*i+1, 2*j+1)})) # Draw outline
  return O
 
0.18819444444444444, 13.326128, def cifijheciajiejdbjbeiegeeiciaecig(I):
    O = upscale(I, TWO)  # Upscale the input grid
    for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
        for (i, j) in toindices(obj):
            O = underfill(O, THREE, outbox({(2*i+1, 2*j+1)}))  # Draw outline
            O = fill(O, I[i][j], {(2*i+1, 2*j+1), (2*i+1, 2*j+2), (2*i+2, 2*j+1), (2*i+2, 2*j+2)}) # Paint 2x2 block
    return O
 
0.1509259259259259, 18.58266, def cddjafgjcdhdedeibaabbeihhcegfhfa(I):
    O = upscale(I, TWO)  # Upscale the input grid
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] != mostcolor(I): # For non-background cells
                O = underfill(O, THREE, box({(2*i+1, 2*j+1)})) # Draw outline using box 
    return O
 
0.09212962962962962, 58.766834, def abafgajgebdeehjbjjcjjdhacfhgfaha(I):
  objs = colorfilter(objects(I, T, F, T), 2)
  border_indices = set()
  for obj in objs:
    border_indices.update(backdrop(obj))  # Get all indices in the object's bounding box
  return paint(
      canvas(0, shape(I)), 
      recolor(3, border_indices - toindices(merge(objs)))  # Remove the object itself from the border
  )
 
0.30462962962962964, 28.113382, def iidifgfdhbifeaacibbjccegchceecbb(I):
  combined_obj = merge(colorfilter(objects(I, T, F, T), 2))  # Combine all objects into one
  return paint(
      canvas(0, shape(I)),
      recolor(3, box(toindices(combined_obj)))  # Find the border of the combined object
  )
 
0.3162037037037037, 26.782856, def aaajbigchfacebejacheiacbjhcaafcj(I):
  O = canvas(0, (height(I), width(I) * 2))  # Double the width
  for obj in colorfilter(objects(I, T, F, T), 2):
    i, j = centerofmass(obj)
    O = paint(O, obj)  # Replicate object
    O = fill(O, 3, connect((i, j), (i, width(O) - 1))) # Draw horizontal line
  return O
 
0.30637254901960786, 12.554074, def hcebhdbiifbeeheabdcabicbjffaejbe(I):
  O = canvas(0, (height(I), width(I) + 8))  # Expand width by 8
  for obj in colorfilter(objects(I, T, F, T), 2):
    i, j = centerofmass(obj)
    O = paint(O, obj) # Replicate object
    for di in range(-1, 2):  
      for dj in range(4):
        O = fill(O, 3, {(i + di, j + dj)})  # Draw surrounding pattern
  return O 
 
0.20875816993464053, 10.515254, def aecdfaedgcafebaaabedcheiaaejccba(I):
    O = canvas(0, (height(I), width(I) * 2 - 1)) # Adjust width 
    for obj in colorfilter(objects(I, T, F, T), 2):
        i, j = centerofmass(obj)
        O = paint(O, obj) # Replicate object
        O = fill(O, 3, connect((i, j), (i, j + 2))) # Horizontal segment
        for di in range(-1, 2):
            O = fill(O, 3, {(i + di, j + 3)}) # Vertical segment
    return O
 
0.18909313725490196, 11.643681, def eddabcfgbbfdeefabhaafebdaffbajib(I):
  O = canvas(0, (height(I), width(I) + 8))  # Expand width 
  for obj in colorfilter(objects(I, T, F, T), 2):
    O = paint(O, obj)  # Replicate object
    for dj in range(1, 4):
      O = paint(O, recolor(3, shift(obj, (0, dj)))) # Shift and paint pattern
    O = paint(O, recolor(3, shift(obj, (-1, 3)))) # Additional shift for pattern 
    O = paint(O, recolor(3, shift(obj, (1, 3))))  # Additional shift for pattern
  return O
 
0.15277777777777776, 14.076406, def djcegcbjdadheajbibcfbiaeaeccjjde(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    twos = [j for j, x in enumerate(row) if x == 2]
    for k in range(len(twos) - 1):
      start = 2 * twos[k] + 2
      end = 2 * twos[k + 1]
      O = fill(O, 3, {(2 * i, l) for l in range(start, end)})
  return O
 
0.32407407407407407, 26.346117, def gjidgifbedfjehfdaddifhhjdbadfhjf(I):
  O = upscale(I, TWO)
  for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
    for direction in ((-1, 0), (1, 0), (0, -1), (0, 1)):
      shifted_obj = shift(upscale(obj, TWO), add((ONE, ONE), direction))
      O = underpaint(O, recolor(THREE, toindices(shifted_obj))) # Draw outline by shifting and underpainting
  return O
 
0.30694444444444446, 29.67893, def jgdjjgfgdjjheiaajffddejbjaafceab(I):
  O = canvas(mostcolor(I), multiply(shape(I), TWO)) # Initialize with background
  for obj in objects(I, univalued=T, diagonal=F, without_bg=T):
    upscaled_obj = shift(upscale(obj, TWO), (ONE, ONE))  # Upscale and shift object
    O = paint(O, upscaled_obj)  # Paint the upscaled object
    for i, j in toindices(upscaled_obj):
      for di, dj in ((-1, 0), (1, 0), (0, -1), (0, 1)):
        if (i+di, j+dj) not in toindices(upscaled_obj): # Check if neighboring cell is not part of object
          O = paint(O, {(THREE, (i+di, j+dj))}) # Paint the outline
  return O
 
0.23098290598290597, 13.375345, def dfdbfahcagfeeadebhchfdegcdghghgb(I):
  padded_grid = canvas(0, add(shape(I), (4, 4)))
  return paint(
      padded_grid,
      merge(
          apply(
              lambda obj: recolor(3, outbox(toindices(obj))),
              colorfilter(objects(I, T, F, T), 2)
          )
      )
  )
 
0.09081196581196581, 42.80163, def effddbjbafcbecabjgchafhiecghahee(I):
  return paint(
    canvas(0, (height(I) + 4, width(I) + 4)), # Create padded canvas
    merge([recolor(3, delta(obj) | box(obj)) for obj in objects(I, T, F, T) if color(obj) == 2])
  )
 
0.1420343137254902, 28.798351, def hdeihhhafjbbedeeafcjggjfaabdhfbc(I):
  O = canvas(0, (height(I), width(I) + 8)) # Expand width
  for obj in colorfilter(objects(I, T, F, T), 2):
    O = paint(O, shift(obj, (0, 13))) # Shift '2' objects right by 13
    for v, (i, j) in obj:
      for di in range(-1, 2):
        for dj in range(1, 4):
          if (di != 0 or dj != 1) and (di != 0 or dj != 2): # Specific gaps in the frame
            O = fill(O, 3, {(i + di, j + dj + 13)}) # Draw the frame with '3's
  return O
 
0.20698529411764705, 11.484943, def fdaicdfabcibeccejgfhdadfdgiegiej(I):
  O = canvas(0, add(shape(I), (0, 8))) # Using 'add' for expansion
  for obj in colorfilter(objects(I, T, F, T), 2):
    O = paint(O, shift(obj, (0, width(I) + 3))) # Shift by input width + 3
    box_indices = difference(outbox(shift(obj, (0, width(I) + 3))),
                            shift(obj, (0, width(I) + 3))) # Calculate outbox and remove object
    O = fill(O, 3, box_indices) # Fill the frame using 'outbox'
  return O
 
0.1224264705882353, 45.243076, def cdhdfgabifcgeaefiejbfcafdchejgfa(I):
  O = canvas(0, (height(I), width(I) + 8))
  for obj in objects(I, T, F, T):
    if color(obj) == 2:
      O = paint(O, shift(obj, (0, 13)))
      shifted_obj = shift(obj, (0, 13))
      for index in backdrop(shifted_obj):
        if index not in shifted_obj and abs(index[0] - centerofmass(shifted_obj)[0]) <= 1: # Conditional frame drawing
          O = fill(O, 3, {index})
  return O
 
0.11825980392156862, 45.629883, def eefhbjdbaggdebefbdbcabdcciijbjab(I):
  O = canvas(0, (height(I), width(I) + 8))
  for obj in colorfilter(objects(I, T, F, T), 2):
    O = paint(O, shift(obj, (0, 13)))
    upper_part = {(i, j) for (i, j) in delta(shift(obj, (0, 13))) if i < centerofmass(obj)[0]} # Calculate upper frame indices
    lower_part = {(i, j) for (i, j) in delta(shift(obj, (0, 13))) if i > centerofmass(obj)[0]} # Calculate lower frame indices
    O = fill(O, 3, upper_part)
    O = fill(O, 3, lower_part)
  return O
 
0.2226851851851852, 27.549135, def iabcbbbcaaigejecibbdjcchejbaaafg(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        try:
          next_two = next(k for k in range(j + 1, len(row)) if row[k] == 2)
          O = fill(O, 3, {(2 * i, l) for l in range(2 * j, 2 * next_two)})
        except StopIteration:
          O = fill(O, 3, {(2 * i, l) for l in range(2 * j, len(O[0]))})
  return O
 
0.15300925925925926, 17.560236, def cgadhdgceccaeidcjdabaefjbhcccbdj(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    connected = False
    for j, val in enumerate(row):
      if val == 2:
        connected = True
        O = fill(O, 3, {(2 * i, 2 * j), (2 * i, 2 * j + 1)})
      else:
        connected = False
    if connected:
      O = fill(O, 3, {(2 * i, l) for l in range(2 * len(row) - 2, len(O[0]))})
  return O
 
0.1509259259259259, 18.623756, def iecdfbjjfbbfebiaaiibdddgcfeigfid(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    for j in range(len(row) - 1):
      if row[j] == 2 and row[j + 1] == 2:
        O = fill(O, 3, {(2 * i, 2 * j), (2 * i, 2 * j + 1), (2 * i, 2 * j + 2), (2 * i, 2 * j + 3)})
    if row and row[-1] == 2:
      O = fill(O, 3, {(2 * i, l) for l in range(2 * (len(row) - 1), len(O[0]))})
  return O
 
0.12407407407407407, 42.095795, def aajehbdhcfbfefjdihbceacijbefgcab(I):
  O = canvas(mostcolor(I), multiply(shape(I), THREE))
  for i, j in asindices(I):
    if I[i][j] == TWO:
      O = paint(O, {(THREE, (THREE * i + ONE, THREE * j + ONE))})
      O = paint(O, {(TWO, (THREE * i + TWO, THREE * j + TWO))})
  return O
 
0.16203703703703703, 17.906885, def ccfbhcfaeggheabiafbbbjbejbbajhdf(I):
  O = upscale(I, THREE)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        O = fill(O, THREE,  {(THREE * i + ONE, THREE * j), (THREE * i + ONE, THREE * j + ONE), (THREE * i, THREE * j + ONE)})
        O = fill(O, TWO, {(THREE * i + ONE, THREE * j + ONE)})
  return O
 
0.1877314814814815, 10.225418, def biaeegcaafedebhiaceddgjbdfigagaj(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  new_grid = hupscale(I, 2)  # Double the grid horizontally

  for obj in twos:
    i, j = ulcorner(obj)
    shift_amount = 10 - i  # Shift amount decreases with row index
    new_grid = paint(new_grid, shift(recolor(3, obj), (0, shift_amount))) # Shift and recolor the '2' object
    new_grid = fill(new_grid, 3, {(i, j + shift_amount - 1), (i, j + shift_amount + 1), (i - 1, j + shift_amount), (i + 1, j + shift_amount)}) # Draw '+' pattern

  return new_grid
 
0.2136574074074074, 14.393153, def ifbhgeddhiciegceadeabegbaeeigabd(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  new_grid = hupscale(I, 2)

  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        if i < 5:
          new_grid = paint(new_grid, shift(recolor(3, {(2, (i, j))}), (0, 7)))  # Top '2' shift
        elif i < 10:
          new_grid = paint(new_grid, shift(recolor(3, {(2, (i, j))}), (0, 9)))  # Middle '2' shift
        else:
          new_grid = paint(new_grid, shift(recolor(3, {(2, (i, j))}), (0, 1)))  # Bottom '2' shift
        new_grid = fill(new_grid, 3, {(i, j + 6), (i, j + 8), (i - 1, j + 7), (i + 1, j + 7)}) # Draw '+' pattern

  return new_grid
 
0.28240740740740744, 40.070553, def beachaajdgaeebbfibcfcififaagcgge(I):
  O = upscale(I, 2)
  for i, row in enumerate(O):
    for j, v in enumerate(row):
      if v == 2:
        k = j + 1
        while k < len(row) and row[k] == 0:
          O = fill(O, 3, {(i, k)})
          k += 1
  return O
 
0.28240740740740744, 37.428364, def ccjbdhfeedieeeabigbgiejgeccajhie(I):
  O = upscale(I, 2)
  for (i, j) in ofcolor(O, 2):
    O = paint(O, recolor(3, connect((i, j + 1), (i, len(O[0]) - 1))))
  return O
 
0.21689814814814812, 27.882053, def cifecbchabfaejdfbeidddbcdfcdbgca(I):
  O = upscale(I, 2)
  for obj in objects(O, True, False, False):
    if color(obj) == 2:
      i, j = ulcorner(obj)
      O = paint(O, recolor(3, connect((i, j + 2), (i, len(O[0]) - 1))))
  return O
 
0.16759259259259257, 12.851787, def cghfabdjecgdeaeeibaajcfeghbhafbg(I):
  O = canvas(0, (len(I) * 2, len(I[0]) * 2))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      O = fill(O, v, {(2*i, 2*j), (2*i + 1, 2*j), (2*i, 2*j + 1), (2*i + 1, 2*j + 1)})
      if v == 2:
        for k in range(j + 2, len(O[0])):
          if O[2*i][k] == 0:
            O = fill(O, 3, {(2*i, k)})
          else:
            break
  return O
 
0.17754629629629629, 17.680777, def ccbajfhhjjceedfaifidjidjbcdejehf(I):
  new_grid = hupscale(I, 2)
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        shift_amount = (0, 7) if i < 5 else ((0, 9) if i < 10 else (0, 1))
        new_grid = paint(new_grid, shift(recolor(3, {(2, (i, j))}), shift_amount))
        new_grid = fill(new_grid, 3, {(i * 2, j * 2 + 6), (i * 2, j * 2 + 8), (i * 2 - 1, j * 2 + 7), (i * 2 + 1, j * 2 + 7)})
  return new_grid
 
0.14421296296296296, 23.880419, def dgebjbcccadieageidccgabjadiddica(I):
  new_grid = canvas(0, (height(I) * 2, width(I) * 2))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        shift_amount = (0, 7) if i < 5 else ((0, 9) if i < 10 else (0, 1))
        new_grid = underpaint(new_grid, shift(recolor(3, {(2, (i * 2, j * 2))}), shift_amount))
        new_grid = fill(new_grid, 3, {(i * 2, j * 2 + 6), (i * 2, j * 2 + 8), (i * 2 - 1, j * 2 + 7), (i * 2 + 1, j * 2 + 7)})
  return new_grid
 
0.1733796296296296, 15.789951, def gdjeffbdffeieiceifgecbbjgeefbffh(I):
  objs = objects(I, T, F, T)
  new_grid = hupscale(I, 2)
  for obj in colorfilter(objs, 2):
    i, j = centerofmass(obj)
    shift_amount = (0, 7) if i < 5 else ((0, 9) if i < 10 else (0, 1))
    shifted_obj = shift(recolor(3, obj), shift_amount)
    new_grid = paint(new_grid, shifted_obj)
    new_grid = fill(new_grid, 3, {(i * 2 - 1, j * 2 + 6), (i * 2 - 1, j * 2 + 8), (i * 2 - 2, j * 2 + 7), (i * 2, j * 2 + 7)})
  return new_grid
 
0.17569444444444443, 15.521662, def hiccfcaiicdgeddeafbbeijddchcidhe(I):
  new_grid = hupscale(I, 2)
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        shift_amount = [(0, 7), (0, 9), (0, 1)][(i // 5) % 3] 
        new_grid = paint(new_grid, shift(recolor(3, {(2, (i * 2, j * 2))}), shift_amount))
        new_grid = fill(new_grid, 3, {(i * 2, j * 2 + 6), (i * 2, j * 2 + 8), (i * 2 - 1, j * 2 + 7), (i * 2 + 1, j * 2 + 7)})
  return new_grid
 
0.337037037037037, 43.57177, def afhhgfbadfeceaagbhgcgefehbcfidae(I):
  O = upscale(I, 2)
  for obj in objects(O, True, False, False):
    if color(obj) == 2:
      i, j = ulcorner(obj)
      O = paint(O, recolor(3, connect((i, j + 2), (i + len(O) - 1 - i, j + 2 + len(O) - 1 - i))))
      O = paint(O, recolor(3, connect((i, j + 2), (i, len(O[0]) - 1))))
      O = paint(O, recolor(3, connect((i, j + 2), (len(O) - 1, j + 2))))
  return O
 
0.34074074074074073, 43.550877, def bbbfchbgcaabecefaggdaieigejifcea(I):
  O = upscale(I, 2)
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (i * 2 + len(O) - 1 - i * 2, j * 2 + 2 + len(O) - 1 - i * 2))))
        O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (i * 2, len(O[0]) - 1))))
        O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (len(O) - 1, j * 2 + 2))))
  return O
 
0.3226851851851852, 42.68, def cbcjceffbcdeecfgjabfeaiidbfffaef(I):
  O = canvas(0, shape(upscale(I, 2)))
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      i, j = ulcorner(obj)
      O = paint(O, recolor(2, upscale(obj, 2)))
      O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (i * 2 + len(O) - 1 - i * 2, j * 2 + 2 + len(O) - 1 - i * 2))))
      O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (i * 2, len(O[0]) - 1))))
      O = paint(O, recolor(3, connect((i * 2, j * 2 + 2), (len(O) - 1, j * 2 + 2))))
  return O
 
0.4872685185185185, 44.295162, def fcbfbbcdiacceijbjfeaacfciejedbab(I):
  O = upscale(I, 2)
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      i, j = ulcorner(upscale(obj, 2))
      O = paint(O, recolor(3, connect((i, j + 2), (i + len(O) - 1 - i, j + 2 + len(O) - 1 - i))))
      O = paint(O, recolor(3, connect((i, j + 2), (i, len(O[0]) - 1))))
      O = paint(O, recolor(3, connect((i, j + 2), (len(O) - 1, j + 2))))
  return O
 
0.11203703703703703, 40.488277, def fbbhffaehedfebcebiabbecfbcediadf(I):
  return paint(
      canvas(0, (15, 18)),
      merge(
          apply(
              lambda obj: recolor(3, box(toindices(obj))),
              colorfilter(objects(I, T, F, T), 2)
          )
      )
  )
 
0.21412037037037035, 17.589872, def gdcifgcdacfaebjfjdfbahbcaedjcfic(I):
  O = upscale(I, 2)
  h = len(O)
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == 2:
        O = paint(O, recolor(3, {(a, j * 2) for a in range(i * 2, h)}))
  return O
 
