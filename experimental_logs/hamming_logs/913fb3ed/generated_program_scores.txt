15.75, 42.91138, def cghibfcafadcecddaeaagejijadaedhi(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    O = fill(O, SIX, {ulcorner(obj)})
    O = fill(O, FOUR, {urcorner(obj)})
    O = fill(O, SIX, {llcorner(obj)})
    O = fill(O, ONE, {lrcorner(obj)})
  return O
 
15.75, 42.591312, def deicbfcbcbgaeagdjadeeefgcfbedcge(I):
  objs = objects(I, T, T, T)
  O = I
  for obj in objs:
    box_indices = box(obj)
    for i, j in box_indices:
      if (i, j) == ulcorner(box_indices): O = fill(O, SIX, {(i, j)})
      elif (i, j) == urcorner(box_indices): O = fill(O, FOUR, {(i, j)})
      elif (i, j) == llcorner(box_indices): O = fill(O, SIX, {(i, j)})
      elif (i, j) == lrcorner(box_indices): O = fill(O, ONE, {(i, j)})
  return O
 
8.0, 3.3288517, def cddadbedbffbefajbcegaffdfgbbbhhi(I):
  objs = fgpartition(I)
  framed_objs = mapply(lambda obj: recolor(6, outbox(toindices(obj))), objs) 
  O = paint(I, framed_objs)
  return O
 
8.0, 3.3288517, def fgbabgccecgdeijfidffcjeaaebaejje(I):
  objs = objects(I, T, F, T)
  framed = fill(I, 6, mapply(outbox, objs))
  pattern_area = difference(mapply(backdrop, objs), mapply(toindices, objs))
  patterned = fill(framed, 4, pattern_area)
  for i, row in enumerate(patterned):
    for j, val in enumerate(row):
      if (i,j) in pattern_area:
        if (i + j) % 2 == 0:
          patterned = fill(patterned, 1, {(i, j)})
        elif (i + j) % 4 == 1:
          patterned = fill(patterned, 2, {(i, j)})
        elif (i + j) % 4 == 3:
          patterned = fill(patterned, 1, {(i, j)}) 
  O = patterned
  return O
 
8.5, 4.728766, def jeadddfbfechedffiafhcegbjjafffcd(I):
  objs = objects(I, T, F, T)
  result = I
  for obj in objs:
    up = uppermost(obj)
    down = lowermost(obj)
    left = leftmost(obj)
    right = rightmost(obj)
    result = fill(result, 6, {(up - 1, j) for j in range(left - 1, right + 2)})  # Top
    result = fill(result, 6, {(down + 1, j) for j in range(left - 1, right + 2)}) # Bottom
    result = fill(result, 6, {(i, left - 1) for i in range(up - 1, down + 2)})  # Left
    result = fill(result, 1, {(i, right + 1) for i in range(up, down + 2)})    # Right
    if up == 0:
      result = fill(result, 1, {(up, right + 1)}) # Top Right Corner 
    if down == len(I) - 1:
      result = fill(result, 1, {(down, right + 1)}) # Bottom Right Corner
  return result
 
11.5, 13.074022, def badajcfdhbbbedigigbddcabfjdffdba(I):
  objs = objects(I, T, F, T)
  grid = I
  for obj in objs:
    box = outbox(obj) 
    grid = fill(grid, 6, box - (shoot(ulcorner(box), (0, 1)) | shoot(llcorner(box), (0, 1))))
    grid = fill(grid, 1, box - (shoot(ulcorner(box), (1, 0)) | shoot(urcorner(box), (1, 0))))
    if uppermost(obj) == 0:
      grid = fill(grid, 1, {urcorner(box)})
    if lowermost(obj) == len(I) - 1:
      grid = fill(grid, 1, {lrcorner(box)})
  return grid
 
22.0, 6.33786, def dgcjffecedgcefcgaagjiddiafgdbbib(I):
  objs = objects(I, T, F, T)
  canvas_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    shifted_obj = shift(obj, (1, 1))
    canvas_grid = underpaint(canvas_grid, recolor(6, outbox(shifted_obj)))
    canvas_grid = underpaint(canvas_grid, recolor(1, {(i, rightmost(shifted_obj)) for i in range(uppermost(shifted_obj), lowermost(shifted_obj) + 1)}))
    if uppermost(obj) == 0:
      canvas_grid = underpaint(canvas_grid, recolor(1, {(0, rightmost(shifted_obj))}))
    if lowermost(obj) == len(I) - 1:
      canvas_grid = underpaint(canvas_grid, recolor(1, {(len(I) - 1, rightmost(shifted_obj))}))
  return canvas_grid
 
12.75, 25.943726, def ciiecdcecaibejcijagedcdfhdfebfih(I):
  O = I
  for obj in objects(I, T, F, T):
    ul = add(ulcorner(obj), (-1, -1))
    lr = add(lrcorner(obj), (1, 1))
    for i in range(ul[0], lr[0] + 1):
      for j in range(ul[1], lr[1] + 1):
        if i == ul[0] or i == lr[0] or j == ul[1] or j == lr[1]:
          if i in range(uppermost(obj), lowermost(obj) + 1):
            if j == lr[1]:
              O = fill(O, 1, {(i, j)})
            else:
              O = fill(O, 6, {(i, j)})
  return O
 
8.75, 7.86775, def jhfdeacfebaeefaejcaegejccbjbchgi(I):
  grid = I
  for obj in objects(I, T, F, T):
    top, left = ulcorner(obj)
    bottom, right = lrcorner(obj)
    for i in range(top - 1, bottom + 2):
      for j in range(left - 1, right + 2):
        if 0 <= i < len(grid) and 0 <= j < len(grid[0]):
          if i == top - 1 or i == bottom + 1:
            grid = fill(grid, 6, {(i, j)})
          elif j == left - 1:
            grid = fill(grid, 6, {(i, j)})
          elif j == right + 1 and top <= i <= bottom:
            grid = fill(grid, 1, {(i, j)})
          if j == right + 1 and (i == top - 1 or i == bottom + 1): 
            grid = fill(grid, 1, {(i, j)}) 
  return grid
 
12.5, 28.031164, def dbececffbdcbeigbijaaehchjdcdccdf(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        O = fill(O, SIX, box(shift(obj, (-1, -1))))  # Outer border
        O = fill(O, SIX, box(shift(obj, (1, 1))))  # Outer border
        for i, row in enumerate(crop(O, ulcorner(shift(obj, (-1,-1))), shape(shift(obj,(2,2))))):
            for j, val in enumerate(row):
                if val == 0:
                  if  (i == 1 and j == 0) or (i == 0 and j == 1) or (i == len(row) - 2 and j == len(row[0]) - 1) or (i == len(row) - 1 and j == len(row[0]) - 2):
                    O = underfill(O, FOUR, (i + ulcorner(shift(obj, (-1,-1)))[0], j + ulcorner(shift(obj, (-1,-1)))[1]))
                  else:
                    O = underfill(O, ONE, (i + ulcorner(shift(obj, (-1,-1)))[0], j + ulcorner(shift(obj, (-1,-1)))[1]))
    return O
 
86.0, 14.19642, def bfadadcechaceiaebbighdbdbbdfiabj(I):
  objs = fgpartition(I)
  box_color = 6
  rect_color = 1
  boxed_grid = paint(I, mapply(lambda obj: recolor(box_color, outbox(toindices(obj))), objs))
  filled_grid =  paint(boxed_grid, mapply(lambda obj: recolor(rect_color, 
                                                     difference(
                                                        {(i, j) for i in range(lowermost(obj), len(I)) for j in range(len(I[0]))},
                                                        backdrop(toindices(obj))
                                                      )), objs))
  return filled_grid
 
66.75, 13.130059, def bcbdeehibifbefggabcajjaihajbaibi(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(obj)))
    for i in range(lowermost(obj) + 1, len(I)):
      for j in range(len(I[0])):
        if index(O, (i, j)) == 0:
          O = paint(O, {(1, (i, j))})
        else:
          break
  return O
 
12.5, 13.4764595, def gcdcafdbfbjeeabcabcfbdfdgddbhibe(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = fill(O, 6, outbox(obj))
    upper_left = ulcorner(obj)
    for i in range(height(obj) + 2):  # Iterate through the backdrop
      for j in range(width(obj) + 2):
        if (i, j) not in normalize(obj):  # Exclude the object itself
          curr_pos = add(upper_left, (i - 1, j - 1))
          if 0 <= curr_pos[0] < len(I) and 0 <= curr_pos[1] < len(I[0]):
            if (curr_pos[0] + curr_pos[1]) % 2 == 0:
              O = fill(O, 4, {curr_pos})
            elif (curr_pos[0] + curr_pos[1]) % 4 == 1:
              O = fill(O, 2, {curr_pos})
            else:
              O = fill(O, 1, {curr_pos})
  return O
 
113.25, 56.54256, def jhieadejbaabedcbjeehdjcedahgajjf(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(6, shape(I)), asobject(I))  # Draw frame and paint original objects
  for i in range(len(I)):
    for j in range(len(I[0])):
      if (i, j) not in mapply(toindices, objs):  # If cell is not part of any object
        if (i + j) % 2 == 0:
          O = fill(O, 4, {(i, j)})
        elif (i + j) % 4 == 1:
          O = fill(O, 2, {(i, j)})
        elif (i + j) % 4 == 3:
          O = fill(O, 1, {(i, j)})
  return O
 
8.0, 3.3288517, def fceefjbeiadheedbjdjcecicheeceecc(I):
  objs = objects(I, T, F, T)
  result = I
  for obj in objs:
    if size(obj) > 1:
      result = underfill(result, color(obj), outbox(obj))
    result = fill(result, 6, outbox(obj))
  return result
 
71.25, 8.7526455, def gahfeddaddedebbajiaddfbdgebbdeca(I):
  objs = fgpartition(I)
  outboxed_objs = mapply(lambda obj: recolor(6, outbox(toindices(obj))), objs)
  filled_area = mapply(lambda obj: recolor(1, 
                        difference(
                          product(interval(0,lowermost(obj)+1,1), interval(0,len(I[0]),1)), 
                          backdrop(toindices(obj))
                        )), objs)
  O = paint(paint(I, outboxed_objs), filled_area)
  return O 
 
21.75, 16.18239, def cahcdccbehejedaebcagifddbhgeeeid(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(toindices(obj))))
    for i in range(uppermost(obj), lowermost(obj) + 1):
        O = paint(O, recolor(1, difference(hfrontier((i,0)), toindices(obj))))
  return O
 
112.0, 51.924744, def bfhehafgcfbdebajieibccaecebdedbf(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != mostcommon(I):
        O = paint(O, recolor(6, outbox({(i, j)})))
        O = paint(O, recolor(1, {(k, l) for k in range(i+1, len(I)) for l in range(len(I[0]))}))
  return O
 
70.5, 8.117445, def jcfbeegajhfieadejdcjfejbabjicibb(I):
  objs = fgpartition(I)
  O = paint(I, mapply(lambda obj: recolor(6, outbox(toindices(obj))), objs))
  bottom_row = maximum({lowermost(obj) for obj in objs})
  O = paint(O, recolor(1, difference(product(interval(0,bottom_row+1,1), interval(0,len(I[0]),1)), 
                                        merge(apply(toindices, objs)))))
  return O
 
31.25, 12.943016, def idafaabbhfhbeedcaibjjhdibaaeccfh(I):
  O = I
  for j in range(len(I[0])):
    for i in range(len(I)):
      if I[i][j] != mostcommon(I):
        O = paint(O, recolor(6, outbox({(i,j)})))
        O = paint(O, recolor(1, connect((i+1, 0), (i+1, len(I[0])-1))))
        break 
  return O
 
110.25, 55.133068, def cefdeajcaajcebdhiecggfjbcdfgibeg(I):
  objs = objects(I, T, F, T)
  O = fill(I, 6, mapply(outbox, objs)) # Frame objects
  for i in range(len(I)):
    for j in range(len(I[0])):
      if (i, j) not in mapply(outbox, objs) and (i, j) not in mapply(toindices, objs):
        if (i + j) % 4 == 1:
          O = fill(O, 4, {(i, j)})
        elif (i + j) % 4 == 2:
          O = fill(O, 2, {(i, j)})
        else:
          O = fill(O, 1, {(i, j)}) 
  return O
 
10.0, 3.0434868, def baideibdajgeecjgjbddhjfdigijebbh(I):
  objs = objects(I, T, F, T)
  result = I
  for obj in objs:
    result = underfill(result, 4, outbox(obj)) # Outline the object with 4
    result = underfill(result, 1, difference(outbox(obj), box(obj))) # Fill inside outline with 1, excluding the actual border
  return result
 
114.0, 41.628162, def daaeejfgfbedefiebceeidbdcabcdjcc(I):
  objs = objects(I, T, F, T)
  result = fill(I, 1, asindices(I)) # Start with a grid filled with 1
  for obj in objs:
    result = paint(result, recolor(color(obj), obj)) # Paint original objects
    result = paint(result, recolor(4, box(obj))) # Paint outline with 4
  return result
 
10.0, 11.929681, def cfjegecgcdacejibiibdebaaedffjdbf(I):
  objs = objects(I, T, F, T)
  result = I
  for obj in objs:
    for d in (UP, DOWN, LEFT, RIGHT): # Iterate through four directions
      result = underfill(result, 4, shift(obj, d)) # Outline by shifting object in each direction and filling
    result = underfill(result, 1, inbox(obj)) # Fill the area within the object's inner box with 1
  return result
 
11.5, 14.110212, def hbccegicadfaebdabcaigdadbjeihchb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = fill(O, SIX, box(shift(obj, (-1, -1))))  
    O = fill(O, SIX, box(shift(obj, (1, 1))))  
    O = underfill(O, ONE, box(obj))  
    O = underfill(O, FOUR, box(shift(obj, (0, -1)))) 
    O = underfill(O, FOUR, box(shift(obj, (-1, 0)))) 
    O = underfill(O, FOUR, intersection(box(obj), box(shift(obj, (-1, -1))))) 
    O = underfill(O, FOUR, intersection(box(obj), box(shift(obj, (-1, 1)))))
  return O
 
11.75, 2.6977198, def eghbbcegbbfbefdfjbehejfcffecibba(I):
  objs = fgpartition(I)
  # Create the outer frame
  framed_objs = mapply(lambda obj: recolor(6, outbox(toindices(obj))), objs)
  # Create the inner frame
  inner_framed_objs = mapply(lambda obj: recolor(4, outbox(toindices(obj))), objs)
  # Fill the area between frames with 1s
  filled_objs = mapply(lambda obj: recolor(1, delta(inbox(toindices(obj)))), objs)
  O = paint(paint(paint(I, framed_objs), inner_framed_objs), filled_objs)
  return O
 
12.0, 14.200399, def ffhafigebdcaeiegiebbcaecbfaibbdg(I):
  result = I  
  for obj in objects(I, T, F, T):
    result = underfill(result, 4, shift(obj, UP) | shift(obj, DOWN) | shift(obj, LEFT) | shift(obj, RIGHT)) # Outline
    result = underfill(result, 6, backdrop(obj)) # Fill bounding box
    extension = connect(urcorner(obj), (urcorner(obj)[0], urcorner(obj)[1] + width(obj))) # Calculate extension line
    result = underfill(result, 1, extension) # Apply extension 
  return result
 
15.25, 34.261326, def gifidcfbifccecaaafedcahfjaeccibg(I):
  grid = canvas(mostcolor(I), shape(I)) # Initialize with background
  for obj in objects(I, T, F, T):
    grid = paint(grid, recolor(4, box(obj))) # Draw outline directly
    grid = paint(grid, recolor(6, difference(backdrop(obj), obj))) # Fill without underfill
    right_edge = sfilter(box(obj), lambda loc: loc[1] == rightmost(obj)) # Get right edge indices
    for start in right_edge:
      grid = paint(grid, recolor(1, connect(start, (start[0], start[1] + width(obj))))) # Extend line from each edge cell
  return grid 
 
15.0, 38.422356, def dgcbjdgichdceabgjjdcabcecabacjhd(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, obj) # Paint original object
    O = underfill(O, 4, box(obj)) # Outline 
    O = underfill(O, 6, difference(backdrop(obj), obj)) # Fill
    O = paint(O, recolor(1, hconcat(canvas(0, (height(obj), width(obj))), canvas(1, (height(obj), width(obj))))))  # Extension as separate canvas
  return O
 
12.0, 18.686773, def egjcfgdceibjedecbdaadfjedheadgcf(I):
  O = paint(canvas(SIX, shape(I)), asobject(I))
  for i, row in enumerate(I):
      for j, val in enumerate(row):
          if val != 0:  # For each non-background cell
              for di in [-1, 1]:
                  for dj in [-1, 1]:
                      O = underfill(O, ONE, {(i + di, j + dj)}) # Fill '1' around
                      if (di == -1 and dj == -1) or (di == 1 and dj == 1):
                        O = underfill(O, FOUR, {(i + di, j + dj)}) # Fill corner '4'
  return O
 
8.25, 2.3656597, def cchichegedhdechejfhbcidbeggefbfa(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(toindices(obj))))
    for j in range(leftmost(obj), rightmost(obj) + 1):
      for i in range(uppermost(obj) + 1, lowermost(obj) + 2):
        if index(I, (i, j)) == 0:
          O = paint(O, {(1, (i, j))})
  return O
 
10.5, 11.69331, def fbceaejdgafdebacbjbcahdbbcefbjdd(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    ul = ulcorner(obj)
    O = paint(O, recolor(6, {(ul[0] - 1, ul[1] - 1), (ul[0] - 1, ul[1] + width(obj)), (ul[0] + height(obj), ul[1] - 1), (ul[0] + height(obj), ul[1] + width(obj))}))
    O = paint(O, recolor(1, {(i, j) for i in range(ul[0] + 1, ul[0] + height(obj) + 1) for j in range(ul[1], ul[1] + width(obj))}))
  return O
 
15.75, 42.591312, def gcaaecaebfbdedhgbfjfjddfchdabecc(I):
  objs = objects(I, T, F, T) # Identify all objects in the input grid
  O = paint(canvas(ZERO, shape(I)), asobject(I)) # Create a canvas filled with '0' and paint the input objects onto it.
  for obj in objs:
    O = fill(O, SIX, box(obj)) # Draw the outline ('6') around each object.
    O = underfill(O, ONE, delta(obj)) # Fill the delta between object and outline with '1'.
    O = underfill(O, FOUR, corners(box(obj))) # Fill the corners of the outline with '4'. 
  return O
 
15.75, 42.587852, def jfaifdfebajheajiaabbcffdffefaggf(I):
  objs = objects(I, T, F, T)  # Identify non-background objects
  O = paint(canvas(ZERO, shape(I)), asobject(I))  # Create base grid from input
  for obj in objs:
    O = fill(O, SIX, box(obj)) # Draw the outline
    O = fill(O, FOUR, corners(box(obj)))  # Fill the corners
    O = underfill(O, ONE, delta(obj)) # Fill the interior
  return O
 
11.0, 12.945175, def aeddbbhccbaeeccaiffbdddbecdcccdf(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(ZERO, shape(I)), asobject(I))
  for obj in objs:
    O = fill(O, SIX, box(shift(obj, (-1,0))))  # Left outline
    O = fill(O, SIX, box(shift(obj, (1,0))))   # Right outline
    O = fill(O, SIX, box(shift(obj, (0,-1))))  # Top outline
    O = fill(O, SIX, box(shift(obj, (0,1))))   # Bottom outline
    O = underfill(O, FOUR, corners(obj)) # Fill the corners
    O = underfill(O, ONE, delta(obj))
  return O
 
10.5, 6.3249927, def cfajhidfchfdebagjbbhdecbheeegdbe(I):
  O = I
  for obj in fgpartition(I):
    O = paint(O, recolor(6, outbox(toindices(obj))))
    for i in range(leftmost(obj), rightmost(obj) + 1):
      for j in range(lowermost(obj) + 1, lowermost(obj) + 3):
        if 0 <= j < len(I) and 0 <= i < len(I[0]) and index(I, (j, i)) == 0:
          O = paint(O, {(1 if color(obj) == 8 else 4, (j, i))})
  return O
 
8.75, 2.3142474, def hbaababjbhhfeeicjajaceacbabghaga(I):
  def frame_object(O, obj):
    return paint(O, recolor(6, outbox(toindices(obj))))

  def fill_object(O, obj):
    fill_color = 1 if color(obj) == 8 else 4
    fill_area = product(interval(lowermost(obj) + 1, lowermost(obj) + 2, 1), interval(leftmost(obj), rightmost(obj) + 1, 1))
    return paint(O, recolor(fill_color, fill_area))

  O = I
  for obj in fgpartition(I):
    O = frame_object(O, obj)
    O = fill_object(O, obj)

  return O
 
9.75, 4.4568925, def cehbeefbedeeeeeebfbebddefjhihggj(I):
  def process_cell(i, j):
    for obj in fgpartition(I):
      if (i, j) in toindices(obj):
        return color(obj)
      elif (i, j) in outbox(toindices(obj)) or (i in range(lowermost(obj) + 1, lowermost(obj) + 3) and j in range(leftmost(obj), rightmost(obj) + 1)):
        return 6 if (i, j) in outbox(toindices(obj)) else (1 if color(obj) == 8 else 4)
    return 0

  return tuple(tuple(process_cell(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
11.0, 14.609475, def fgbbjigfadgeegijbeecabcagbjcfcdi(I):
  O = replace(I, THREE, SIX)  # Replace 3s with 6s
  O = fill(O, SIX, merge(apply(lambda loc: connect(subtract(loc, (THREE, ZERO)), loc), ofcolor(I, THREE))))  # Draw vertical 6 line
  O = replace(O, EIGHT, FOUR)  # Replace 8s with 4s
  O = fill(O, FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(I, EIGHT))))  # Draw 3x3 square of 4s
  O = replace(O, TWO, ONE)  # Replace 2s with 1s
  O = fill(O, ONE, merge(apply(lambda loc: connect(add(loc, (ONE, NEG_ONE)), add(loc, (ONE, ONE))), ofcolor(I, TWO))))  # Draw horizontal 1 line
  O = fill(O, TWO, merge(apply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(I, TWO))))  # Shift 2s down
  return O
 
10.5, 14.817176, def bfdgabbgaacieaacjhahfdehbffgffbg(I):
  O = paint(I, recolor(SIX, merge(apply(lambda loc: connect(subtract(loc, (THREE, ZERO)), loc), ofcolor(I, THREE))))) # Draw vertical 6 line & replace 3s with 6s
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(I, EIGHT))))) # Draw 3x3 square of 4s & replace 8s with 4s
  O = paint(O, recolor(ONE, merge(apply(lambda loc: connect(add(loc, (ONE, NEG_ONE)), add(loc, (ONE, ONE))), ofcolor(I, TWO))))) # Draw horizontal 1 line & replace 2s with 1s
  O = paint(O, recolor(TWO, merge(apply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(I, TWO))))) # Shift 2s down
  return O
 
15.75, 40.79854, def eaheaadaahefefhbjaabcghcbjbahabi(I):
  def apply_transformations(grid, value, transformation):
    return fill(grid, value, merge(apply(transformation, ofcolor(I, value))))
  O = apply_transformations(I, SIX, lambda loc: connect(subtract(loc, (THREE, ZERO)), loc))  # Draw vertical 6 line
  O = replace(O, THREE, SIX)  # Replace 3s with 6s
  O = apply_transformations(O, FOUR, lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))))  # Draw 3x3 square of 4s
  O = replace(O, EIGHT, FOUR)  # Replace 8s with 4s
  O = apply_transformations(O, ONE, lambda loc: connect(add(loc, (ONE, NEG_ONE)), add(loc, (ONE, ONE))))  # Draw horizontal 1 line
  O = replace(O, TWO, ONE)  # Replace 2s with 1s
  O = apply_transformations(O, TWO, lambda loc: frozenset({add(loc, DOWN)}))  # Shift 2s down
  return O
 
12.25, 10.463384, def aichceficddeeddcjbdaehadcbfefead(I):
  def process_object(obj):
    fill_value = 1 if color(obj) == 8 else 4
    frame = recolor(6, outbox(obj))
    fill_area = product(interval(lowermost(obj) + 1, lowermost(obj) + 2, 1), interval(leftmost(obj), rightmost(obj) + 1, 1))
    return lambda grid: paint(paint(grid, frame), recolor(fill_value, fill_area))
  return last(rapply(apply(process_object, fgpartition(I)), I)) 
 
113.75, 47.122524, def dcabbidfeafgeiccihfachdehddefbae(I):
    objs = objects(I, T, F, T)
    O = canvas(1, shape(I)) # Canvas of 1s
    for i, row in enumerate(O):
        for j, _ in enumerate(row):
            if (i + j) % 2: # Checkerboard with 2s
              O = fill(O, 2, {(i, j)})
    O = underpaint(O, mapply(lambda obj: recolor(4, obj), objs))  # Fill objects with 4
    O = underpaint(O, mapply(lambda obj: recolor(6, outbox(obj)), objs))  # Frame objects with 6
    return O
 
11.0, 14.768902, def aaefbdcdjfjfebbgbdchcdgcdccjdaaa(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == THREE:
        O = paint(O, recolor(SIX, connect((i, j), subtract((i, j), (THREE, ZERO)))))
      elif value == EIGHT:
        O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract((i, j), (ONE, ONE))))))
      elif value == TWO:
        O = paint(O, recolor(TWO, {(i + 1, j)}))
        O = paint(O, recolor(ONE, connect((i, j - 1), (i, j + 1))))
  return O
 
129.75, 22.281729, def cdgafcdeafibecicidigcccddfcfhcbc(I):
  grid = I
  new_grid = canvas(mostcolor(grid), (height(grid), width(grid) * 2))
  for obj in objects(grid, T, F, T):
    obj_indices = toindices(obj)
    new_grid = fill(new_grid, 4, outbox(obj))
    new_grid = underfill(new_grid, 6, difference(backdrop(obj), obj_indices))
    new_grid = paint(new_grid, recolor(1, {(i, j + width(grid)) for i, j in obj_indices}))
  return new_grid
 
472.0, 25.047613, def fijfebbjecdbejadjeceabhdffffbdbj(I):
  grid = I
  for obj in objects(grid, T, F, T):
    grid = paint(fill(grid, 4, outbox(obj)), obj) # Outline and repaint object
    grid = underfill(grid, 6, difference(backdrop(obj), toindices(obj))) # Fill inner area
    duplicate_indices = {(i, j + width(grid)) for i, j in toindices(obj)}
    duplicate = recolor(1, {(i, 2 * width(obj) - 1 - j) for i, j in duplicate_indices})
    grid = paint(hconcat(grid, canvas(mostcolor(grid), shape(grid))), duplicate) # Concatenate
  return grid 
 
11.75, 2.8226259, def bagbjcceahedefaajejfdgcedfaeagfa(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(ZERO, shape(I)), asobject(I)) 
  for obj in objs:
    O = fill(O, SIX, box(obj)) # Draw the border
    O = underfill(O, FOUR, inbox(obj))  # Fill the inside of the border 
    O = underfill(O, ONE, corners(inbox(obj))) # Fill the corners
  return O
 
11.75, 11.057372, def aefcaidfhcgfeghjbiebbfbiehbjachb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = fill(O, SIX, box(obj)) # Draw the border
    O = fill(O, FOUR, difference(inbox(obj), corners(inbox(obj))))  # Fill non-corner cells inside
    O = fill(O, ONE, corners(inbox(obj))) # Fill the corners
  return O
 
9.0, 12.588458, def acebcagafcadecbcabcbaibdeeajjbde(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(ZERO, shape(I)), asobject(I)) # Initialize output grid
  for obj in objs:
    for d in [(-1,0), (1,0), (0,-1), (0,1)]:
      O = fill(O, SIX, shift(obj, d))  # Draw border lines by shifting object 
    O = underfill(O, FOUR, inbox(obj)) # Fill the inside
    corner_indices = frozenset({(i,j) for i,j in inbox(obj) if len(dneighbors((i,j)) & inbox(obj)) < 4})
    O = underfill(O, ONE, corner_indices)  # Fill corners based on neighbor count
  return O
 
13.75, 19.782316, def chaiideefaceeddhjdjhebjbdeefhdci(I):
  objs = objects(I, T, F, T)
  O = paint(canvas(ZERO, shape(I)), asobject(I))
  for obj in objs:
    O = fill(O, SIX, box(obj)) # Border
    inner_area = difference(backdrop(obj), box(obj))
    O = underfill(O, FOUR, inner_area)  # Fill inside
    corner_indices = frozenset({
        (uppermost(obj) + 1, leftmost(obj) + 1),
        (uppermost(obj) + 1, rightmost(obj) - 1),
        (lowermost(obj) - 1, leftmost(obj) + 1),
        (lowermost(obj) - 1, rightmost(obj) - 1)
    })
    O = underfill(O, ONE, corner_indices)  # Explicitly fill corners
  return O
 
110.25, 46.595886, def eebdbghcgieeeaddjcjfbifedbgigaff(I):
    objs = objects(I, T, F, T)
    O = paint(I, mapply(lambda obj: recolor(6, outbox(obj)), objs)) # Frame objects
    O = underpaint(O, mapply(lambda obj: recolor(4, obj), objs))  # Fill objects with '4'
    for i in range(len(I)):
      for j in range(len(I[0])):
        if O[i][j] == 0:
          if (i + j) % 2 == 0:
            O = fill(O, 1, {(i, j)})
          else:
            O = fill(O, 2, {(i, j)})
    return O
 
11.5, 14.342646, def ddadecejafgcecebiedeehfjdffgdhdb(I):
  O = paint(I, recolor(SIX, merge(apply(lambda loc: connect(loc, add(loc, (THREE, ZERO))), ofcolor(I, THREE))))) # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(O, EIGHT))))) # Eights to Four Squares
  O = paint(O, recolor(ONE, merge(apply(lambda loc: connect(add(loc, (ZERO, NEG_ONE)), add(loc, (ZERO, ONE))), ofcolor(O, TWO))))) # Twos to One-Two-One Horizontal Lines
  O = paint(O, recolor(TWO, merge(apply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(O, TWO))))) # Shift Twos Down
  return O 
 
11.5, 12.980687, def biibghdgjegaefefbbcffjbbcfieeijg(I):
  O = I
  for loc in ofcolor(I, THREE): # Threes to Six Vertical Lines
    O = paint(O, recolor(SIX, connect(loc, add(loc, (THREE, ZERO)))))
  for loc in ofcolor(I, EIGHT): # Eights to Four Squares
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))))))
  for loc in ofcolor(I, TWO):
    O = paint(O, recolor(ONE, connect(add(loc, (ZERO, NEG_ONE)), add(loc, (ZERO, ONE))))) # Twos to One-Two-One Horizontal Lines
    O = paint(O, recolor(TWO, frozenset({add(loc, DOWN)}))) # Shift Twos Down
  return O
 
10.0, 22.776964, def cjecfdeebdgcehcdjadfdddachgcejga(I):
  O = paint(I, recolor(SIX, mfilter(asindices(I), lambda loc: index(I, loc) == THREE and index(I, add(loc, (ONE, ZERO))) == THREE))) # Threes to Six Vertical Lines (optimized)
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(O, EIGHT))))) # Eights to Four Squares
  O = paint(O, recolor(ONE, mapply(lambda loc: connect(add(loc, (ZERO, NEG_ONE)), add(loc, (ZERO, ONE))), ofcolor(O, TWO)))) # Twos to One-Two-One Horizontal Lines (optimized)
  O = paint(O, recolor(TWO, mapply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(O, TWO)))) # Shift Twos Down (optimized)
  return O
 
11.0, 13.110779, def hccdcigdcbfhebbjbcbcdaebaadcddjf(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 3:
                O = fill(O, 6, connect((i, j), (i + 3, j)))  # Threes to Six Vertical Lines
            if I[i][j] == 8:
                O = fill(O, 4, backdrop(shift(asindices(canvas(0, (3, 3))), (i - 1, j - 1))))  # Eights to Four Squares
            if I[i][j] == 2:
                if i < len(I) - 1:
                  O = fill(O, 2, {(i + 1, j)})  # Shift Twos Down
                O = fill(O, 1, {(i, j - 1), (i, j + 1)})  # Twos to One-Two-One Horizontal Lines
    return O
 
10.0, 3.0434868, def fedcffeedecdegacbcebjjciddbahahf(I):
  objs = fgpartition(I)
  result = I
  for obj in objs:
    top_bottom = remove(outbox(obj), (intersection(outbox(obj), inbox(obj))))
    left_right = intersection(outbox(obj), inbox(obj))
    result = underfill(result, 4, top_bottom)
    result = underfill(result, 6, left_right)
    result = underfill(result, 1, (intersection(outbox(obj), outbox(shift(obj, (-1, -1))))))
    result = underfill(result, 1, (intersection(outbox(obj), outbox(shift(obj, (-1, 1))))))
    result = underfill(result, 1, (intersection(outbox(obj), outbox(shift(obj, (1, -1))))))
    result = underfill(result, 1, (intersection(outbox(obj), outbox(shift(obj, (1, 1))))))

  return result
 
10.0, 11.040353, def eccbgidaejhcededaebaaccadaccdacc(I):
    objs = fgpartition(I)
    recolored_objs = mapply(lambda obj: (
        recolor(4, remove(outbox(obj), (intersection(outbox(obj), inbox(obj))))
        ) | 
        recolor(6, intersection(outbox(obj), inbox(obj))) | 
        recolor(1, (intersection(outbox(obj), outbox(shift(obj, (-1, -1)))))) | 
        recolor(1, (intersection(outbox(obj), outbox(shift(obj, (-1, 1)))))) | 
        recolor(1, (intersection(outbox(obj), outbox(shift(obj, (1, -1)))))) | 
        recolor(1, (intersection(outbox(obj), outbox(shift(obj, (1, 1))))))
    ), objs)
    return paint(I, recolored_objs) 
 
10.0, 3.480501, def afdccjdcafeeedhabidgbcedbababcja(I):
    objs = fgpartition(I)
    result = I
    for obj in objs:
        for i, j in outbox(obj):
            if (i, j) not in obj:
                if (i - 1, j) in obj or (i + 1, j) in obj:
                    result = fill(result, 4, {(i, j)})
                elif (i, j - 1) in obj or (i, j + 1) in obj:
                    result = fill(result, 6, {(i, j)})
                else:
                    result = fill(result, 1, {(i, j)})
    return result
 
14.0, 42.52262, def faefjcdfgigbedejidgjbhihbjfhgdeb(I):
  objs = fgpartition(I)
  result = I
  for obj in objs:
    for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        shifted_obj = shift(obj, (dx, dy))
        intersection_indices = toindices(obj) & toindices(shifted_obj)
        for i, j in intersection_indices:
            if index(result, (i+dx, j+dy)) == 0:
              if dx == 0:
                result = fill(result, 4, {(i+dx, j+dy)})
              else:
                result = fill(result, 6, {(i+dx, j+dy)})
    for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
        shifted_obj = shift(obj, (dx, dy))
        intersection_indices = toindices(obj) & toindices(shifted_obj)
        for i, j in intersection_indices:
            if index(result, (i+dx, j+dy)) == 0:
              result = fill(result, 1, {(i+dx, j+dy)})
  return result
 
7.25, 6.102348, def aaciedbibjacecacjabbfceiddceahbh(I):
  def frame_and_fill(O, obj):
    O = paint(O, recolor(6, outbox(toindices(obj)))) # Frame with 6
    fill_color = 4 if color(obj) == 8 else 1  # Conditional fill color
    fill_area = product(interval(lowermost(obj) + 1, lowermost(obj) + 2, 1), 
                       interval(leftmost(obj) - 1, rightmost(obj) + 2, 1))
    return paint(O, recolor(fill_color, fill_area))

  O = I 
  for obj in fgpartition(I):
    O = frame_and_fill(O, obj) 
  return O
 
13.25, 10.9332, def bfiiagfabfdceiihjfdcegcbcachdagf(I):
  O = I
  for obj in objects(I, T, F, T):
    O = paint(O, recolor(6, outbox(obj))) # Frame
    if color(obj) == 8:
      O = underfill(O, 4, shift(inbox(obj), DOWN)) # Fill with 4 if color is 8
    else:
      O = underfill(O, 1, shift(inbox(obj), DOWN)) # Fill with 1 otherwise
  return O 
 
8.0, 3.3288517, def aajdeefcdbhaedcbbjfbbcdjdajhjgei(I):
  O = paint(I, recolor(6, mapply(outbox, objects(I, T, F, T)))) # Frame all
  for obj in objects(I, T, F, T):
    fill_color =  4 if color(obj) == 8 else 1
    O = underfill(O, fill_color, shift(backdrop(obj), DOWN))
  return O
 
9.75, 2.6458528, def adddadaaagfjeacdacbcbibdefjgaefg(I):
  grid = I
  for obj in objects(I, T, F, T):
    border_color = 1 if lowermost(obj) == len(grid) - 1 else 6 
    grid = fill(grid, border_color, inbox(obj))
    grid = fill(grid, 4, toindices(obj))
    if border_color == 1:
      grid = fill(grid, 6, {(i, j) for i, j in inbox(obj) if i == uppermost(obj) - 1})
  return grid 
 
11.5, 12.881255, def hcfigfdedgceecghbidfdcfeefeafcah(I):
  objs = fgpartition(I)
  result = I
  for obj in objs:
    result = underfill(result, 4, shift(toindices(obj), (1, 0)) - toindices(obj)) # Top
    result = underfill(result, 4, shift(toindices(obj), (-1, 0)) - toindices(obj)) # Bottom
    result = underfill(result, 6, shift(toindices(obj), (0, 1)) - toindices(obj)) # Right
    result = underfill(result, 6, shift(toindices(obj), (0, -1)) - toindices(obj)) # Left
    result = underfill(result, 1, delta(outbox(obj))) # Corners
  return result
 
11.0, 13.554914, def ijahjdjbgfcfegfdaagbfccdcgdbfgja(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(obj)))
    for i in range(uppermost(obj) - 1, lowermost(obj) + 2):
      for j in range(leftmost(obj) - 1, rightmost(obj) + 2):
        if (i, j) not in toindices(obj):
          if (i + j) % 2 == 0:
            O = paint(O, {(4, (i, j))})
          elif (i + j) % 4 == 1:
            O = paint(O, {(1, (i, j))})
          elif (i + j) % 4 == 3:
            O = paint(O, {(2, (i, j))})
  return O
 
112.0, 51.924744, def jciecibeacadefefiaecbjhffcfceccf(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcommon(I):
        O = paint(O, recolor(6, outbox({(I[i][j], (i, j))})))
        for di in range(-1, 2):
          for dj in range(-1, 2):
            ni, nj = i + di, j + dj
            if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and (di, dj) != (0, 0) and I[ni][nj] == mostcommon(I):
              if (ni + nj) % 2 == 0:
                O = paint(O, {(4, (ni, nj))})
              elif (ni + nj) % 4 == 1:
                O = paint(O, {(1, (ni, nj))})
              elif (ni + nj) % 4 == 3:
                O = paint(O, {(2, (ni, nj))})
  return O
 
12.25, 6.6173983, def iecbghaedccgehgejhejaecfhfacebij(I):
  O = paint(canvas(ZERO, shape(I)), asobject(I)) # Initialize output grid
  for obj in objects(I, T, F, T):
    O = fill(O, SIX, box(obj))  # Draw border 
    O = underfill(O, FOUR, inbox(obj)) # Fill the inside
    bottom = lrcorner(obj)[0]
    left, right = leftmost(obj)-1, rightmost(obj)+1
    for j in range(left, right + 1):
      if 0 <= bottom + 1 < len(O) and 0 <= j < len(O[0]):
        O = fill(O, ONE, {(bottom + 1, j)})  # Draw horizontal line
    for v, (i, j) in obj:
      if v == TWO and 0 <= i + 1 < len(O) and 0 <= j < len(O[0]):
        O = fill(O, TWO, {(i + 1, j)})  # Replace '1' with '2' under '2's
  return O
 
9.25, 5.4298763, def cbejhebffjcdeeecafggcbbbdcabffag(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, SIX, outbox(obj))  # Draw border using 'outbox'
    O = underfill(O, FOUR, inbox(obj)) # Fill the inside
    start = (lowermost(obj)+1, leftmost(obj)-1)
    O = paint(O, recolor(ONE, connect(start, add(start, (0, width(obj) + 1))))) # Draw & paint horizontal line 
    for i, j in ofcolor(I, TWO):
      if 0 <= i + 1 < len(O) and 0 <= j < len(O[0]):
        O = fill(O, TWO, {(i + 1, j)})  # Replace '1' with '2' under '2's
  return O
 
12.25, 3.4161859, def cahejdgegfieejjjadjfejgegaigbeba(I):
  O = I 
  for obj in objects(I, T, F, T):
    O = fill(O, SIX, box(obj)) # Draw border
    O = underfill(O, FOUR, inbox(obj)) # Fill the inside
    for i, j in toindices(obj):
      if 0 <= i + 1 < len(O) and 0 <= j < len(O[0]):
        O = fill(O, branch(I[i][j] == TWO, TWO, ONE), {(i + 1, j)}) # Conditionally fill '1' or '2' 
  return O
 
7.0, 2.246569, def gfgcgdcabbjcegcjjfehahjabfdcadgb(I):
  O = I  
  for obj in fgpartition(I):
    O = paint(O, recolor(6, outbox(toindices(obj)) - corners(toindices(obj)))) # Outbox with corners removed
    if color(obj) in [8, 2]:
      O = paint(O, recolor(color(obj), shift(toindices(obj), DOWN))) # Add row below for 8 and 2
    if color(obj) == 2:
      O = paint(O, recolor(1, shift(toindices(obj), LEFT) | shift(toindices(obj), RIGHT))) # Horizontal lines for 2
  return O
 
10.0, 11.929681, def djjdhjcbbbdeeciebadebeejfcbijhbc(I):
  result = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != 0:
        result = fill(result, value, {(i, j)})  # Paint original object
        for (dx, dy), val in [((0, 1), 4), ((0, -1), 4), ((1, 0), 4), ((-1, 0), 4)]:
          ni, nj = i + dx, j + dy
          if 0 <= ni < len(I) and 0 <= nj < len(row) and I[ni][nj] == 0:
            result = fill(result, val, {(ni, nj)})  # Direct outline
        for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:
          ni, nj = i + dx, j + dy
          if 0 <= ni < len(I) and 0 <= nj < len(row) and I[ni][nj] == 0:
            result = fill(result, 1, {(ni, nj)})  # Diagonal outline
  return paint(result, recolor(6, outbox(asindices(I)))) # Frame
 
15.75, 42.591312, def hbfgjghaebbaeacbbeadhjcbgabfdafc(I):
  grid = paint(canvas(0, shape(I)), asobject(I))  # Initialize output grid
  for obj in objects(I, T, F, T):
    grid = underfill(grid, 4, obj) # Fill interior with '4'
    grid = fill(grid, 6, box(obj)) # Draw border with '6'
    if uppermost(obj) == 0 or lowermost(obj) == len(I) - 1:
      border_segment = {(i, j) for i, j in box(obj) if i == uppermost(obj) + 1 or i == lowermost(obj) - 1}
      grid = fill(grid, 1, border_segment)  # Modify top/bottom border 
  return grid
 
8.0, 3.3288517, def aeaacafbeehheeehigdfdbfifaicbfie(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill interior
    border_color = 1 if uppermost(obj) == 0 or lowermost(obj) == len(I) - 1 else 6
    O = fill(O, border_color, inbox(obj)) # Conditional border
  return O
 
4.0, 2.715799, def ejhibjdfbgdjefbajeeedcefiejgeice(I):
  O = I
  for obj in fgpartition(I):
    O = paint(O, recolor(6, outbox(toindices(obj)) - corners(toindices(obj))))  # Outlining
    if color(obj) in [8, 2]:
      O = paint(O, recolor(color(obj), shift(toindices(obj), DOWN)))  # Vertical Shift
    if color(obj) == 2:
      O = paint(O, recolor(1, connect((uppermost(obj), leftmost(obj) - 1), (uppermost(obj), rightmost(obj) + 1))))  # Horizontal Lines
    if color(obj) == 8:
      center_i, center_j = centerofmass(obj)  # Square Expansion
      O = paint(O, recolor(4, frozenset((i, j) for i in range(center_i - 1, center_i + 2) for j in range(center_j - 1, center_j + 2))))
  return O
 
3.5, 2.8775015, def deebbbhiddjaeddaaffhdfahajgbbbii(I):
  def outline_object(obj):
    return recolor(6, outbox(toindices(obj)) - corners(toindices(obj)))
  
  def shift_down(obj):
    return recolor(color(obj), shift(toindices(obj), DOWN)) if color(obj) in [8, 2] else obj
  
  def extend_lines(obj):
    return recolor(1, shift(toindices(obj), LEFT) | shift(toindices(obj), RIGHT)) if color(obj) == 2 else frozenset()

  def expand_square(obj):
    if color(obj) != 8:
      return frozenset()
    center_i, center_j = centerofmass(obj)
    return recolor(4, frozenset((i, j) for i in range(center_i - 1, center_i + 2) for j in range(center_j - 1, center_j + 2)))
  
  transformed = [
      outline_object(obj) 
      for obj in fgpartition(I)
  ]
  transformed += [
      shift_down(obj)
      for obj in fgpartition(I) if color(obj) in [2,8]
  ]
  transformed += [
      extend_lines(obj) 
      for obj in fgpartition(I) if color(obj) == 2
  ]
  transformed += [
      expand_square(obj) 
      for obj in fgpartition(I) if color(obj) == 8
  ]
  return paint(I, merge(transformed))
 
44.5, 15.926098, def aajgieebjcgeeeecigjbjcfbbjbgfdcf(I):
  def transform_cell(loc, value):
    if value == 0 and any(index(I, n) != 0 for n in dneighbors(loc)):
      return 6  # Outlining
    if value == 8:
      ci, cj = subtract(loc, (1, 1))
      return 4 if any((abs(ci - i) <= 1 and abs(cj - j) <= 1) for i, j in ofcolor(I, 8)) else 0  # Square Expansion
    if value == 2:
      return 2 if loc[0] + 1 < len(I) and I[loc[0] + 1][loc[1]] == 0 else 0  # Vertical Shift for 2
    return value

  transformed_grid = tuple(
      tuple(transform_cell((i, j), value) for j, value in enumerate(row)) for i, row in enumerate(I)
  )
  return paint(transformed_grid, recolor(1, mapply(lambda loc: connect(add(loc, (0, -1)), add(loc, (0, 1))), ofcolor(transformed_grid, 2))))  # Horizontal Lines for 2
 
10.0, 3.0434868, def eeghbfdbdahiecfhbaecibfaibeedabj(I):
  objs = fgpartition(I)  
  O = fill(I, 6, mapply(outbox, objs)) # Create the frame first
  for obj in objs:
    for i in range(uppermost(obj) - 1, lowermost(obj) + 2):
      for j in range(leftmost(obj) - 1, rightmost(obj) + 2):
        if index(O, (i, j)) == 6: # Check if within the frame
          if i == uppermost(obj) - 1 or i == lowermost(obj) + 1 or j == leftmost(obj) - 1 or j == rightmost(obj) + 1:
            O = paint(O, {(4, (i, j))}) # Apply '4' at specific frame cells
          else:
            if (i + j) % 2 == 0:
              O = paint(O, {(1, (i, j))}) # Alternate between '1' and '2'
            else:
              O = paint(O, {(2, (i, j))})
  return O
 
9.75, 2.6458528, def gaeifcfedaaeefcebejaabhaihfeahdb(I):
  objs = fgpartition(I)
  O = fill(I, 6, mapply(outbox, objs)) # Create frame
  for obj in objs:
    O = fill(O, 4, box(toindices(obj))) # Fill the direct outline with '4'
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(leftmost(obj), rightmost(obj) + 1):
        if index(O, (i, j)) == 6: # If inside the frame and not '4'
          if (i + j) % 2 == 0: 
            O = paint(O, {(1, (i, j))})
          else:
            O = paint(O, {(2, (i, j))})
  return O
 
9.5, 7.5202603, def diebdechdcedegdebffbfbdcecjejdab(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(toindices(obj))))
    start = (uppermost(obj) - 1, leftmost(obj)) # Start from top-left corner of frame
    for di in range(height(obj) + 2):
      for dj in range(width(obj) + 2):
        i, j = start[0] + di, start[1] + dj
        if index(O, (i, j)) == 6:
          if di == 0 or di == height(obj) + 1 or dj == 0 or dj == width(obj) + 1:
            O = paint(O, {(4, (i, j))})
          else:
            if (i + j) % 2 == 0:
              O = paint(O, {(1, (i, j))})
            else:
              O = paint(O, {(2, (i, j))}) 
  return O
 
12.0, 11.801768, def fbajdfahdbeheeadaaffjbdbfhbbcaeh(I):
  def process_object(obj):
    O = paint(I, recolor(6, outbox(obj))) # Outline the object with '6'
    fill_color = 4 if color(obj) == 8 else 1 # Determine fill color
    fill_area = product(interval(lowermost(obj) + 1, lowermost(obj) + 2, 1), 
                       interval(leftmost(obj) - 1, rightmost(obj) + 2, 1)) # Area below object
    return underfill(O, fill_color, fill_area) # Fill the area

  return last(apply(process_object, objects(I, T, F, T))) # Apply to all objects
 
9.0, 11.728835, def cdfebcecaacfefccifjgebddejeebbgc(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill the interior with '4'
    O = fill(O, 1, inbox(obj)) # Draw border with '1's
    O = fill(O, 6, {(uppermost(obj)-1, leftmost(obj)-1), (uppermost(obj)-1, rightmost(obj)+1),
                     (lowermost(obj)+1, leftmost(obj)-1), (lowermost(obj)+1, rightmost(obj)+1)}) # Replace corners with '6's
  return O
 
15.75, 42.91138, def bbehcgagdjgeeddabdjeiajecfiaeifh(I):
  O = paint(canvas(0, shape(I)), asobject(I))  # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill the interior with '4'
    O = fill(O, 1, box(obj)) # Draw initial box border with '1's
    O = fill(O, 6, corners(obj) & delta(obj))  # Replace appropriate corners with '6's
  return O
 
12.0, 11.5345335, def debdahegaaacecddibafcadbafdbihhb(I):
  objs = fgpartition(I)  # Get objects without background
  O = fill(I, 6, mapply(outbox, objs))  # Create frame with '6'
  for obj in objs:
    for i in range(uppermost(obj) - 1, lowermost(obj) + 2):
      for j in range(leftmost(obj) - 1, rightmost(obj) + 2):
        if index(O, (i, j)) == 6:  # Check if inside the frame
          if (i + j) % 2 == 0:
            O = paint(O, {(1, (i, j))})  # Fill with '1'
          else:
            O = paint(O, {(2, (i, j))})  # Fill with '2'
  return O
 
13.75, 14.073829, def bedijigfbhdeeafaaaddebbjifgibeid(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = fill(O, 6, outbox(obj)) # Create frame
    upper_left = (uppermost(obj) - 1, leftmost(obj) - 1)
    for i in range(height(obj) + 2):
      for j in range(width(obj) + 2):
        if (i + j) % 2 == 0:
          O = fill(O, 1, {add(upper_left, (i,j))})
        else:
          O = fill(O, 2, {add(upper_left, (i,j))})
  return O
 
12.0, 11.194563, def ihceeffhbajhehgfjcefaaajiebbbffj(I):
  objs = fgpartition(I)
  O = fill(I, 6, mapply(outbox, objs))  # Create the frame
  for obj in objs:
    start = (uppermost(obj) - 1, leftmost(obj) - 1)  # Frame's upper-left
    for i in range(height(obj) + 2):
      for j in range(width(obj) + 2):
        current = add(start, (i, j))
        if index(I, current) == mostcolor(I): # Check if background in the input
          if (i + j) % 2 == 0:
            O = paint(O, {(1, current)}) 
          else:
            O = paint(O, {(2, current)}) 
  return O
 
9.75, 3.0475295, def gdbfabaffcgdegdbihcdbhgegffdjbfc(I):
  O = paint(canvas(0, shape(I)), asobject(I))  # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill the interior with '4'
    O = paint(O, recolor(6, inbox(obj))) # Draw the frame
    O = paint(O, recolor(1, {(i, j) for i, j in box(obj) if i == lowermost(obj)})) # Extend bottom frame
  return O 
 
15.25, 33.74179, def ebfjfjeddfaheihfbabaicgacdjcefjb(I):
  O = paint(canvas(0, shape(I)), asobject(I))  # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill the interior with '4'
    O = paint(O, recolor(6,  {(i, j) for i, j in box(obj) if i != lowermost(obj) + 1})) # Draw frame except extended part
    O = paint(O, recolor(1, {(lowermost(obj) + 1, j) for i, j in toindices(obj)}))  # Extend bottom frame 
  return O
 
13.5, 33.42883, def chbedcaifbieecdgaefbhaiaecaeaeaa(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, 4, difference(toindices(obj), corners(obj))) # Fill interior, excluding corners
    for i, j in box(obj):
      if i == lowermost(obj): # Extend bottom frame
        O = fill(O, 1, {(i + 1, j)})
      else: # Draw the rest of the frame
        O = fill(O, 6, {(i, j)})
  return O
 
6.0, 3.6632352, def bdidccibdgdcefdbjaafddadjcfeibgh(I):
  def process_object(obj):
    obj_color = color(obj)
    obj_indices = toindices(obj)
    transformed = recolor(6, outbox(obj_indices) - corners(obj_indices)) # Outlining
    if obj_color == 8:
      center_i, center_j = centerofmass(obj)
      transformed |= recolor(4, frozenset((i, j) for i in range(center_i - 1, center_i + 2) for j in range(center_j - 1, center_j + 2)))  # Square Expansion
      transformed |= recolor(obj_color, shift(obj_indices, DOWN))  # Vertical Shift for 8
    if obj_color == 2:
      transformed |= recolor(obj_color, shift(obj_indices, DOWN))  # Vertical Shift for 2
      transformed |= recolor(1, shift(obj_indices, LEFT) | shift(obj_indices, RIGHT))  # Horizontal Lines for 2
    return transformed
  return paint(I, merge(apply(process_object, fgpartition(I))))
 
11.0, 5.802247, def abfdbafbdeieeajcbiafefahidceaehg(I):
  objs = objects(I, T, F, T)  # Identify objects
  O = fill(I, 6, mapply(outbox, objs))  # Frame the objects
  for obj in objs:
    O = underfill(O, 4, inbox(toindices(obj)))  # Fill inside the frame
    for i, j in toindices(inbox(toindices(obj))):
      if (i + j) % 2 == 0:  # Diagonal pattern replacement
        O = fill(O, 1, {(i, j)})
      elif (i + j) % 4 == 1:
        O = fill(O, 2, {(i, j)})
      elif (i + j) % 4 == 3:
        O = fill(O, 1, {(i, j)})
  return O
 
19.25, 15.436934, def adhhfgaaehdbehcfbehjeififiedhdcf(I):
  objs = fgpartition(I)  # Identify objects
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(toindices(obj))))  # Frame objects
    O = underfill(O, 4, difference(inbox(toindices(obj)), toindices(obj)))  # Fill inside frame
    shifted_obj = shift(obj, (1, 1)) # Shift object diagonally
    O = paint(O, recolor(1, difference(inbox(toindices(shifted_obj)), toindices(shifted_obj)))) # Replace every other diagonal with 1
    O = paint(O, recolor(2, intersection(inbox(toindices(obj)), toindices(shifted_obj)))) # Replace remaining diagonal intersections with 2 
  return O
 
10.5, 6.950142, def ffeajdhfdejieaaeabibdecgbcbbabdb(I):
  def process_object(obj):
    outline = recolor(6, outbox(obj))
    fill_color = 4 if color(obj) == 8 else 1
    fill_area = product(interval(lowermost(obj) + 1, lowermost(obj) + 2, 1),
                       interval(leftmost(obj) - 1, rightmost(obj) + 2, 1))
    filled = recolor(fill_color, fill_area)
    return paint(paint(I, outline), filled)
  return last(apply(process_object, objects(I, T, F, T)))
 
14.5, 42.471695, def ehaiiabibaebeehgjbbebcjbicafddba(I):
  O = asobject(I)
  for obj in objects(I, T, F, T):
    O = O.union(recolor(4, difference(backdrop(obj), box(obj)))) # Add interior with '4'
    O = O.union(recolor(1, difference(box(obj), corners(box(obj))))) # Add border with '1's
    O = O.union(recolor(6, corners(obj)))  # Add corners with '6's
  return paint(canvas(0, shape(I)), O) # Paint the final object on an empty canvas
 
13.0, 33.215813, def bbdfhgdbcfeceighiieeadfbghfeaajc(I):
  O = paint(canvas(6, shape(I)), asobject(I))
  for i in range(1, height(I)):
    for j in range(width(I)):
      if index(O, (i, j)) == 0 and index(I, (i - 1, j)) != 0:
        fill_value = 4 if index(I, (i - 1, j)) == 8 else 1
        O = paint(O, {(fill_value, (i, j))})
  return O
 
7.75, 2.213597, def ecfcdgjdghjgeacdjafahcbcjbdjdejc(I):
  objs = fgpartition(I)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(obj)))
    fill_area = difference(
      shift(backdrop(obj), (1, 0)),
      backdrop(obj)
    )
    fill_value = 4 if color(obj) == 8 else 1
    O = paint(O, recolor(fill_value, fill_area))
  return O
 
13.0, 11.094588, def cicfieiiicaiecbciacffgdebbdedddf(I):
  def process_object(obj):
    outlined = paint(I, recolor(6, outbox(obj)))
    fill_color = 4 if color(obj) == 8 else 1
    filled = paint(outlined, recolor(fill_color, toindices(obj)))
    return underfill(filled, fill_color, shift(obj, (1, 0)))
  return last(apply(process_object, fgpartition(I)))
 
11.75, 2.8226259, def aafdaheafcafeebaaecfagbdeeaggedf(I):
  O = I
  for obj in objects(I, T, F, T):
    O = fill(O, 4, inbox(obj)) # Fill the interior with '4'
    O = fill(O, 6, box(obj)) # Draw the frame
    O = fill(O, 1, {(i, j) for (i, j) in backdrop(obj) if i == lowermost(obj) + 1}) # Extend bottom frame
  return O
 
8.25, 4.0203996, def jhaiafdefgaiehdfieecbgehhdcehjcj(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = paint(O, recolor(6, outbox(toindices(obj))))
    start = (uppermost(obj) + 1, leftmost(obj) + 1)
    for i in range(height(obj)):
      for j in range(width(obj)):
        if (i + j) % 2 == 0:
          O = paint(O, {(4, (start[0] + i, start[1] + j))})
        else:
          O = paint(O, {(1, (start[0] + i, start[1] + j))})
  return O
 
15.25, 33.15218, def edahfffcdeiheicfadgeaeadfffbbhjh(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj)  # Fill the interior with '4'
    O = paint(O, recolor(6, box(obj)))  # Draw the frame
    O = paint(O, recolor(1, {(lowermost(obj), rightmost(obj) + 1)})) # Extend bottom frame 
  return O
 
9.75, 2.8129914, def ahbigcfgcfdbeeaebiffjjdbgdccaahe(I):
  objs = fgpartition(I) 
  O = fill(I, 6, mapply(outbox, objs)) # Draw outboxes
  for obj in objs:
    fill_value = 4 if color(obj) == 8 else 1  # Determine fill value
    for i, j in toindices(difference(backdrop(obj), obj)): 
      if (i - uppermost(obj) + j - leftmost(obj)) % 2 == 0: # Alternating pattern
        O = paint(O, {(fill_value, (i, j))})
  return O
 
18.0, 18.415342, def facaafhejeaeeiadaifjcfacecjdhdbi(I):
  objs = objects(I, True, False, True)
  O = fill(I, 6, mapply(outbox, objs))  # Draw outboxes
  for obj in objs:
    fill_value = 4 if color(obj) == 8 else 1
    pattern =  tuple(
        tuple(
            fill_value if (i + j) % 2 == 0 else 1
            for j in range(width(obj) + 2)  # +2 to cover the outbox area
        )
        for i in range(height(obj) + 2)
    )
    O = paint(O, shift(asobject(pattern), ulcorner(obj))) 
  return O
 
10.0, 3.480501, def cdieahibdfidedhbiiggagfaahafbbdd(I):
  O = paint(canvas(0, shape(I)), asobject(I))  # Initialize grid with background
  for obj in objects(I, T, F, T):  # Iterate over non-background objects
    O = underfill(O, 4, obj)  # Fill object interior with 4
    O = fill(O, 6, outbox(obj)) # Fill outer border with 6
    if uppermost(obj) != 0 and lowermost(obj) != len(I) - 1:  # Check if object touches top/bottom edges
      O = fill(O, 1, inbox(obj)) # Fill inner border with 1
  return O
 
15.0, 34.730984, def ahaddebbjigaeaeeidfbidbbgihjfaaj(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid 
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill interior with 4
    O = fill(O, 6, box(shift(obj, (1, 1))) ) # Outer Border
    if not bordering(obj, I): # Check if bordering
        O = fill(O, 1, box(obj)) # Inner Border
  return O
 
14.0, 42.52262, def fhacahijidehehcdicfajafghgjhjcij(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid 
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill interior with 4
    for (i, j) in delta(obj):
        if index(I, (i, j)) == 0:
            O = fill(O, 6, {(i, j)}) # Outer Border
        else:
            O = fill(O, 1, {(i, j)}) # Inner Border
  return O
 
6.5, 3.4085467, def bfhecfehhjgiebfajhdbaehdcjccfagj(I):
  def transform_object(obj):
    color_val = color(obj)
    indices = toindices(obj)
    transformed = recolor(6, outbox(indices) - corners(indices))  # Outlining
    if color_val in [8, 2]:
      transformed = transformed | recolor(color_val, shift(indices, DOWN))  # Vertical shift
    if color_val == 2:
      left = add(ulcorner(indices), (0, -1))
      right = add(ulcorner(indices), (0, 1))
      line = connect(left, right) - recolor(6, outbox(frozenset({ulcorner(indices)})))
      transformed = transformed | recolor(1, line)  # Horizontal Lines
    if color_val == 8:
      center_i, center_j = centerofmass(indices)
      square_indices = backdrop(shift(asindices(canvas(8, (3, 3))), subtract((center_i, center_j), (1, 1))))
      transformed = transformed | recolor(4, square_indices)  # Square Expansion
    return transformed

  return paint(I, merge(apply(transform_object, fgpartition(I))))
 
4.0, 2.5907476, def fedeeeefaegaefddabbbdbbcbacbgfcc(I):
  O = I
  for obj in fgpartition(I):
    O = paint(O, recolor(6, outbox(toindices(obj)) - corners(toindices(obj))))
    if color(obj) == 8:
      ci, cj = centerofmass(obj)
      O = paint(O, recolor(4, backdrop(shift(asindices(canvas(8, (3, 3))), (-1 + ci, -1 + cj)))))
    if color(obj) in [8, 2]:
      O = paint(O, recolor(color(obj), shift(toindices(obj), DOWN)))
    if color(obj) == 2:
      O = paint(O, recolor(1, (shift(toindices(obj), LEFT) | shift(toindices(obj), RIGHT)) - recolor(6, outbox(toindices(obj))))) 
  return O
 
9.25, 3.210523, def beebafjbfaafegdaaeadefebdhfecceg(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill interior
    O = fill(O, 6, intersection(inbox(obj), 
                             (vfrontier((0,0)) | vfrontier((len(I)-1,0))))) # Draw top/bottom borders
    O = fill(O, 1, difference(inbox(obj), 
                             (vfrontier((0,0)) | vfrontier((len(I)-1,0))))) # Draw remaining borders
  return O
 
11.0, 3.2569864, def ahfhbhbdjadaehfiaificadaeefejgbc(I):
  O = I # Directly work on the input grid
  for obj in objects(I, T, F, T):
    O = fill(O, 4, difference(toindices(obj), inbox(obj))) # Fill interior
    O = fill(O, 6, intersection(inbox(obj), 
                             (vfrontier((0,0)) | vfrontier((len(O)-1,0))))) # Draw top/bottom borders
    O = fill(O, 1, difference(inbox(obj), 
                             (vfrontier((0,0)) | vfrontier((len(O)-1,0))))) # Draw other borders
  return O
 
9.25, 3.3607938, def gfagbabhbefcefcgadfjbfhbeafdabhb(I):
  O = paint(canvas(0, shape(I)), asobject(I)) # Initialize grid
  for obj in objects(I, T, F, T):
    O = underfill(O, 4, obj) # Fill interior
    border = inbox(obj) 
    for i, j in border:
        O = fill(O, 6 if i == 0 or i == len(I) - 1 else 1, {(i, j)}) # Conditional fill for each border cell
  return O
 
9.0, 4.7512174, def fgcceecdadfieddbicfjbfahfhbabaij(I):
  O = I
  for obj in fgpartition(I):
    O = paint(O, recolor(6, outbox(toindices(obj)) - corners(toindices(obj))))
    if color(obj) == 8:
      center_i, center_j = centerofmass(obj)
      O = paint(O, recolor(4, backdrop(shift(asindices(canvas(8, (3, 3))), (center_i - 2, center_j - 2)))))
      O = paint(O, recolor(8, shift(toindices(obj), DOWN)))
    if color(obj) == 2:
      O = paint(O, recolor(1, connect((uppermost(obj), leftmost(obj) - 1), (uppermost(obj), rightmost(obj) + 1))))
      O = paint(O, recolor(2, shift(toindices(obj), DOWN)))
  return O
 
4.5, 2.6651042, def fdadegbcdfjceiiebbjhdghhbcffaaec(I):
  O = paint(I, recolor(TWO, mapply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(I, TWO))))  # Shift Twos Down (optimized)
  O = paint(O, recolor(ONE, mapply(lambda loc: connect(loc, add(loc, DOWN)), ofcolor(I, TWO))))  # Twos to One-Two Vertical Lines (optimized)
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(O, EIGHT)))))  # Eights to Four Squares
  return O
 
4.5, 2.5266082, def jfaebiecbbefehcaicbfaifcfcfiaehf(I):
  O = I
  for loc in ofcolor(I, EIGHT):
    for i in range(-1, 2):
      for j in range(-1, 2):
        O = paint(O, {(FOUR, (loc[0] + i, loc[1] + j))}) # Eights to Four Squares (iterative)
  O = paint(O, recolor(ONE, apply(lambda loc: add(loc, DOWN), ofcolor(O, TWO)))) # Shift Twos Down and replace with Ones
  O = paint(O, recolor(TWO, apply(lambda loc: add(loc, DOWN), ofcolor(I, TWO)))) # Shift Twos Down
  return O
 
114.25, 4.7540755, def iedffaddbbbceaecbghaffcdchfbhfbe(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == EIGHT:
        O = paint(O, recolor(FOUR, {(i, j)})) # Replace 8 with 4
        O = paint(O, recolor(ONE, connect((i + 1, j), (i + 1, len(row) - 1)))) # Draw 1s line
        O = paint(O, recolor(EIGHT, {(i + 1, j)})) # Shift 8 down
      elif value != SIX:
        O = paint(O, recolor(ONE, {(i, j)})) # Replace other values with 1
        O = paint(O, recolor(value, {(i + 1, j)})) # Shift the original value down
  return O
 
96.5, 10.816577, def ddfedcejaddaehidbaabacjbbdcffgad(I):
  O = replace(I, EIGHT, FOUR) # Replace 8s with 4s
  O = fill(O, ONE, merge(apply(lambda loc: connect((loc[0] + 1, loc[1]), (loc[0] + 1, len(I[0]) - 1)), ofcolor(I, EIGHT)))) # Draw 1s line
  O = paint(O, recolor(EIGHT, shift(toobject(ofcolor(I, EIGHT), I), DOWN))) # Shift 8s down 
  return fill(O, ONE, shift(toobject(difference(asindices(I), ofcolor(I, SIX)), I), DOWN)) # Shift other values down and replace with 1
 
8.5, 2.223751, def ebcfdbichjbceabhjgejccicacdbcgca(I):
  shifted_others = shift(toobject(difference(asindices(I), ofcolor(I, SIX)), I), DOWN)
  return paint(fill(replace(I, EIGHT, FOUR), ONE, merge(apply(lambda loc: connect((loc[0] + 1, loc[1]), (loc[0] + 1, len(I[0]) - 1)), ofcolor(I, EIGHT)))), toobject(shifted_others,  replace(I, EIGHT, ONE)))
 
17.25, 11.026077, def ahacfhdeejigeaccadaejbaedbecacdj(I):
  O = I
  for obj in objects(I, False, False, False):
    value = color(obj)
    if value == EIGHT:
      O = underpaint(O, recolor(FOUR, obj)) # Replace 8 with 4
      O = underpaint(O, recolor(ONE, connect(add(ulcorner(obj), DOWN), (add(ulcorner(obj), DOWN))[0], len(I[0]) - 1))) # Draw 1s line
      O = underpaint(O, recolor(EIGHT, shift(obj, DOWN))) # Shift 8 down
    elif value != SIX:
      O = underpaint(O, recolor(ONE, obj)) # Replace other values with 1
      O = underpaint(O, recolor(value, shift(obj, DOWN))) # Shift the original value down
  return O
 
7.25, 5.3429403, def hfgabeafijedeeebbgagbcdccfgbcdfe(I):
  O = paint(I, recolor(SIX, mapply(lambda loc: connect(loc, (loc[0] + THREE, loc[1])), ofcolor(I, THREE))))  # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, mapply(lambda loc: backdrop(shift(asindices(canvas(ZERO, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(O, EIGHT))))  # Eights to Four Squares
  for i in range(len(I)-1, 0, -1):  # Iterate reversely for shifting
    for j in range(len(I[0])):
      if O[i][j] == TWO:  # Shift Twos Down
        O = fill(O, ZERO, {(i, j)})
        O = fill(O, TWO, {(i+1, j)})
      if O[i][j] == TWO: # Twos to One-Two-One Horizontal Lines
        O = fill(O, ONE, {(i, j-1), (i, j+1)})
  return O
 
3.5, 2.5617542, def ficcccggbacheecdibgbaffhdfhefcjj(I):
  O = I
  for loc in ofcolor(I, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (THREE, THREE))), subtract(loc, (ONE, ONE))))))
  for loc in ofcolor(I, TWO):
    O = paint(O, recolor(ONE, connect(add(loc, (ZERO, NEG_ONE)), add(loc, (ZERO, ONE)))))
    O = paint(O, recolor(TWO, frozenset({loc}))) 
  return O 
 
9.75, 3.0475304, def ecageafdabjceaiaiihafahaaacijfjf(I):
  objs = sorted(fgpartition(I), key=uppermost)
  main_obj = objs[0]
  def recolor_fn(obj):
    return branch(
        equality(obj, main_obj), 
        obj, 
        branch(
            greater(uppermost(obj), uppermost(main_obj)), 
            recolor(ONE, obj), 
            recolor(FOUR, obj)
        )
    )
  return paint(I, merge(apply(recolor_fn, objs)))
 
21.5, 15.344092, def afdbhjfdbhhjehbabfbecgcfegaeeebe(I):
  def process_row(row_index, row):
    objs_in_row = sfilter(fgpartition(I), lambda obj: contained(row_index, apply(lambda idx: idx[0], toindices(obj))))
    if size(objs_in_row) > 1:
      ref_obj = min(objs_in_row, key=uppermost)
      return tuple(ONE if v != color(ref_obj) and loc[0] < uppermost(ref_obj) else FOUR if v != color(ref_obj) else v for v, loc in zip(row, repeat(tojvec(row_index), len(row))))
    else:
      return row
  return tuple(process_row(i, r) for i, r in enumerate(I))
 
9.0, 2.5048993, def abdfdeiadeaaebdhihhfbejgcdjbedaa(I):
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: backdrop(shift({(FOUR, (0, 0))}, loc)), ofcolor(I, EIGHT)))))  # Eights to Four Squares
  O = paint(O, recolor(ONE, mapply(lambda loc: connect(loc, add(loc, DOWN)), ofcolor(I, TWO))))  # Twos to One-Two Vertical Lines
  O = paint(O, recolor(TWO, apply(lambda loc: add(loc, DOWN), ofcolor(I, TWO))))  # Shift Twos Down
  return O
 
5.0, 2.4157622, def eddaibaefacfebhbbbdeabigebhgcbee(I):
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))), ofcolor(I, EIGHT)))))  # Eights to Four Squares
  twos = ofcolor(I, TWO)
  O = paint(O, recolor(ONE, merge([connect(loc, add(loc, DOWN)) for loc in twos]))) # Twos to One-Two Vertical Lines (list comprehension)
  O = paint(O, recolor(TWO, {add(loc, DOWN) for loc in twos}))  # Shift Twos Down (set comprehension)
  return O
 
9.75, 2.8129916, def cgafbcfgdaebedhhjabdififddedecgb(I):
  O = replace(I, EIGHT, FOUR)
  O = replace(O, TWO, ONE)
  for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
    if color(obj) == THREE:
      O = fill(O, ONE, connect((centerofmass(obj)[0], leftmost(obj)), (centerofmass(obj)[0], rightmost(obj))))
  return O
 
15.75, 42.89408, def dbaadecgdgafeaajidcdifaehgeccdcb(I):
  O = canvas(ZERO, shape(I))  # Create an empty canvas
  O = paint(O, recolor(FOUR, ofcolor(I, EIGHT)))  # Paint 4s where 8s were
  O = paint(O, recolor(ONE, ofcolor(I, TWO)))  # Paint 1s where 2s were
  for obj in fgpartition(I):  # Iterate through objects (excluding background)
    if color(obj) == THREE:
      start_j = leftmost(obj)
      end_j = rightmost(obj)
      center_i = centerofmass(obj)[0]
      O = fill(O, ONE, {(center_i, j) for j in range(start_j, end_j + 1)})
  return O
 
6.5, 4.5763206, def facfbicahedeebhbihdfcffccjjcdaib(I):
    O = I
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == THREE and i < len(I) - 2:
                O = fill(O, SIX, connect((i, j), (i+2, j))) # Threes to Six Vertical Lines
            if I[i][j] == EIGHT:
                for x in range(i-1, i+2):
                    for y in range(j-1, j+2):
                        if 0 <= x < len(I) and 0 <= y < len(I[0]):
                            O = fill(O, FOUR, {(x,y)}) # Eights to Four Squares
    for i in range(len(I)-1, 0, -1):
        for j in range(len(I[0])):
            if O[i][j] == TWO:
                O = fill(O, ZERO, {(i, j)})
                O = fill(O, TWO, {(i+1, j)}) # Shift Twos Down
            if O[i][j] == TWO:
                if j > 0:
                    O = fill(O, ONE, {(i, j-1)})
                if j < len(I[0])-1:
                    O = fill(O, ONE, {(i, j+1)}) # Twos to One-Two-One Horizontal Lines
    return O
 
4.5, 2.5672235, def haicehbijgaaeceaieafadegdiaebgfe(I):
  # Square Transformation
  O = I
  for loc in ofcolor(I, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (THREE, THREE))), subtract(loc, (ONE, ONE))))))
  
  # Line Transformation
  objs = objects(I, False, False, False)
  for obj in objs:
    if color(obj) == TWO and hline(obj):
      start = (uppermost(obj), leftmost(obj))
      end = (uppermost(obj), rightmost(obj))
      O = paint(O, recolor(ONE, connect(start, end)))
  return O
 
9.0, 7.7038693, def hgfhhjacdjfieacbjediideeafafedfe(I):
  # Square Transformation
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == EIGHT:
        O = paint(O, recolor(FOUR, {(i-1, j-1), (i-1, j), (i-1, j+1),
                                      (i, j-1),              (i, j+1),
                                      (i+1, j-1), (i+1, j), (i+1, j+1)}))
  
  # Line Transformation
  for loc in ofcolor(I, TWO):
    O = paint(O, recolor(ONE, connect((loc[0], 0), (loc[0], len(I[0])-1))))
  return O
 
4.5, 0.9881165, def ecffaabgddafebbfacdffdfeedeeifcc(I):
  O = I
  h, w = len(I), len(I[0])
  # Square Transformation
  for i in range(h):
    for j in range(w):
      if I[i][j] == EIGHT and 0 < i < h - 1 and 0 < j < w - 1:
        O = fill(O, FOUR, {(i-1, j-1), (i-1, j), (i-1, j+1), 
                           (i,   j-1),            (i,   j+1), 
                           (i+1, j-1), (i+1, j), (i+1, j+1)})
  
  # Line Transformation
  line_indices = set()
  for i in range(h):
    for j in range(w):
      if I[i][j] == TWO:
        line_indices.add((i, j))
  O = paint(O, recolor(ONE, backdrop(line_indices)))
  return O
 
9.75, 2.645853, def aibgjaeaigibeffdjhfeedcfbbdcidje(I):
  objs = fgpartition(I)  # Identify non-background objects
  if len(objs) <= 1:
    return I  # No change if only one object or less
  ref_obj = max(objs, key=size)  # Find largest object
  ref_color = color(ref_obj)
  def recolor_logic(obj):
    return branch(
        obj == ref_obj,  # Keep reference object unchanged
        obj, 
        branch(
            uppermost(obj) < uppermost(ref_obj),  # Above reference object
            recolor(ONE, obj),
            recolor(FOUR, obj)  # Below reference object
        )
    )
  return paint(I, merge(apply(recolor_logic, objs)))  # Paint the recolored objects
 
8.0, 2.5086658, def fcbagdcafbajegihiciaigabjfagbiaf(I):
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: backdrop(shift({(FOUR, ORIGIN)}, subtract(loc, UNITY))), ofcolor(I, EIGHT)))))  # Eights to Four Squares
  O = paint(O, recolor(TWO, mapply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(I, TWO))))  # Shift Twos Down
  O = paint(O, recolor(ONE, merge([connect(l, add(l, DOWN)) for l in ofcolor(O, TWO)])))  # Twos to One-Two Vertical Lines 
  return O
 
7.5, 2.6430986, def jaaabafhecgjehfaaeedajdfhedagaba(I):
  # Eights to Four Squares (using nested loop and fill)
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == EIGHT:
        O = fill(O, FOUR, backdrop(shift({(FOUR, ORIGIN)}, subtract((i, j), UNITY))))
  # Shift Twos Down (using two separate paints for wrapping)
  O = paint(O, recolor(ZERO, frozenset((len(O)-1, j) for i, j in ofcolor(O, TWO) if i == len(O)-1)))
  O = paint(O, recolor(TWO, mapply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(O, TWO)))) 
  # Twos to One-Two Vertical Lines (using apply and connect)
  O = paint(O, recolor(ONE, merge(apply(lambda loc: connect(subtract(loc, DOWN), add(loc, DOWN)), ofcolor(O, TWO)))))
  return O
 
10.75, 3.255024, def jfabcciaaggbehahajcefcgdacbdjdbi(I):
  O = replace(replace(I, TWO, ONE), EIGHT, FOUR) # Replace 2s with 1s and 8s with 4s in one line
  for i, row in enumerate(I):
    if THREE in row:
      left_edge = next(j for j, val in enumerate(row) if val == SIX) # Find the index of the first 6
      right_edge = len(row) - next(j for j, val in enumerate(row[::-1]) if val == SIX) - 1 # Find the index of the last 6
      O = fill(O, ONE, connect((i, left_edge), (i, right_edge)))  # Fill with 1s between the first and last 6
  return O
 
11.25, 2.1776104, def dfhbfcdbfcdbeccfifhfajficbbgecce(I):
    O = I # Start with the original grid
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == TWO:
                O = paint(O, recolor(ONE, {(i, j)})) # Replace 2 with 1
            elif I[i][j] == EIGHT:
                O = paint(O, recolor(FOUR, {(i, j)})) # Replace 8 with 4
            elif I[i][j] == THREE:
                left_edge = j
                right_edge = j
                while left_edge > 0 and I[i][left_edge - 1] == SIX:
                    left_edge -= 1
                while right_edge < len(I[0]) - 1 and I[i][right_edge + 1] == SIX:
                    right_edge += 1
                O = fill(O, ONE, connect((i, left_edge), (i, right_edge))) # Draw the horizontal line
    return O
 
4.0, 4.858627, def bdfdcgceaecbeeabbbbidagfjdfaifjd(I):
  O = I
  for i in range(len(I)):
      for j in range(len(I[0])):
          if I[i][j] == THREE and i < len(I) - 2:
              O = fill(O, SIX, {(i + k, j) for k in range(3)})  # Threes to Six Vertical Lines
          if I[i][j] == EIGHT:
              O = fill(O, FOUR, {(i + k, j + l) for k in range(-1, 2) for l in range(-1, 2)})  # Eights to Four Squares
  O = paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in ofcolor(O, TWO)}))  # Shift Twos Down
  O = paint(O, recolor(ONE, {(loc[0], loc[1] - 1) for loc in ofcolor(O, TWO)} | {(loc[0], loc[1] + 1) for loc in ofcolor(O, TWO)}))  # Twos to One-Two-One Horizontal Lines
  return O
 
11.75, 2.6977203, def fdfigcdhcaddefbciifeaddadbcffdgb(I):
  objs = sorted(fgpartition(I), key=uppermost)
  main_obj = objs[0]
  def recolor_fn(obj):
    return branch(
        equality(obj, main_obj), 
        recolor(FOUR, obj),  # Recolor main object to 4
        branch(
            greater(uppermost(obj), uppermost(main_obj)), 
            recolor(ONE, obj), 
            recolor(FOUR, obj)
        )
    )
  return paint(I, merge(apply(recolor_fn, objs)))
 
11.75, 3.545198, def efebaffbabdheebbiebebbbedjajcecd(I):
  objs = fgpartition(I)
  def recolor_fn(obj):
    return branch(
        any(uppermost(obj) < uppermost(other) for other in remove(obj, objs)),
        recolor(ONE, obj),  # Recolor if above any other object
        recolor(FOUR, obj)   # Otherwise, recolor to 4
    )
  return paint(I, merge(apply(recolor_fn, objs)))
 
11.75, 4.401478, def cbbiiccbhgdfegiiaahfeefabcdeehdi(I):
  objs = fgpartition(I)
  def recolor_fn(obj):
    return branch(
      contained(ONE, palette(obj)),  # Check if object contains color 1
      obj,                            # Keep original color if it contains 1
      recolor(FOUR, obj)             # Otherwise, recolor to 4
    )
  return paint(I, merge(apply(recolor_fn, objs)))
 
11.75, 5.560368, def gbjfabdibfedeidcihgfcfehdbfbceib(I):
  objs = fgpartition(I)
  def recolor_fn(obj):
    return branch(
        any(hmatching(obj, other) for other in remove(obj, objs)), 
        recolor(ONE, obj),  # Recolor to 1 if horizontally matching with another object
        recolor(FOUR, obj)   # Otherwise, recolor to 4
    )
  return paint(I, merge(apply(recolor_fn, objs)))
 
5.0, 2.845417, def bcefadfaiiabedehjjjebcgaadafjcec(I):
  # Eights to Four Squares (using nested loops and conditional replacement)
  O = I
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] == EIGHT:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            O = paint(O, {(FOUR, (i+di, j+dj))})
  # Shift Twos Down (using paint and offset)
  O = paint(O, recolor(ZERO, frozenset((len(O)-1, j) for i, j in ofcolor(O, TWO) if i == len(O)-1))) 
  O = paint(O, recolor(TWO, mapply(lambda loc: frozenset({add(loc, DOWN)}), ofcolor(O, TWO)))) 
  # Twos to One-Two-One Vertical Lines (using paint and direct indexing)
  O = paint(O, recolor(ONE, {(i-1, j) for i, j in ofcolor(O, TWO) if i > 0}))
  O = paint(O, recolor(ONE, {(i+1, j) for i, j in ofcolor(O, TWO) if i < len(O) - 1}))
  return O
 
5.5, 4.48135, def bbedfcbichdfeafeicefceeccdcggefb(I):
  O = I
  for loc in ofcolor(I, THREE):
    O = paint(O, recolor(SIX, frozenset((i, loc[1]) for i in range(loc[0], loc[0]+3))))  # Threes to Six Vertical Lines
  for loc in ofcolor(O, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(loc, (1, 1))))))  # Eights to Four Squares
  for i in range(len(I)-1, 0, -1):
    for j in range(len(I[0])):
      if O[i][j] == TWO:
        O = fill(O, ZERO, {(i, j)})
        O = fill(O, TWO, {(i+1, j)}) # Shift Twos Down
  O = paint(O, recolor(ONE, merge(apply(lambda loc: frozenset({(loc[0], loc[1] - 1), (loc[0], loc[1] + 1)}), ofcolor(O, TWO)))))  # Twos to One-Two-One Horizontal Lines
  return O
 
5.0, 4.7904487, def gcfbgfbcebfbeicabaeebhbbcbfbcafe(I):
  threes = ofcolor(I, THREE)
  eights = ofcolor(I, EIGHT)
  twos = ofcolor(I, TWO)
  O = paint(I, recolor(SIX, merge([connect(loc, (loc[0] + 2, loc[1])) for loc in threes])))  # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), (loc[0]-1, loc[1]-1))) for loc in eights])))  # Eights to Four Squares
  O = paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in twos}))  # Shift Twos Down
  O = paint(O, recolor(ONE,  {(loc[0], loc[1] - 1) for loc in twos} | {(loc[0], loc[1] + 1) for loc in twos}))  # Twos to One-Two-One Horizontal Lines
  return O
 
10.5, 2.9825568, def cgadeidcagfeeafdjbhbhbfjdgjgdced(I):
  objs = fgpartition(I)  # Identify objects excluding background
  def recolor_rule(obj):
    original_color = color(obj)
    new_color = {6: 4, 2: 1}.get(original_color, original_color)  # Recoloring logic
    return recolor(new_color, obj)
  recolored_objs = apply(recolor_rule, objs)
  O = paint(I, merge(recolored_objs)) # Paint the recolored objects onto the input grid
  return O 
 
5.5, 3.6132946, def hgacfibjafejeejgabegfegccahbbefd(I):
  # Eights to Four Squares
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: backdrop(shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE)))), ofcolor(I, EIGHT))))) 
  # Shift Twos Down (using modulo for wrapping)
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines (using shift for line creation)
  O = paint(O, recolor(ONE, merge(apply(lambda loc: merge((shift({(ONE, (0,0))}, loc), shift({(ONE, (2,0))}, loc))), ofcolor(O, TWO)))))  
  return O
 
4.5, 3.3093545, def aahdhbedfbgeehceadhcbedcbehhaega(I):
  # Eights to Four Squares 
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: frozenset({(FOUR, (loc[0]+i, loc[1]+j)) for i in range(-1,2) for j in range(-1,2)}), ofcolor(I, EIGHT)))))
  # Shift Twos Down (using modulo for wrapping)
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines (using direct index manipulation)
  O = paint(O, recolor(ONE, merge(apply(lambda loc: frozenset({(ONE, (loc[0]-1, loc[1])), (ONE, (loc[0]+1, loc[1]))}), ofcolor(O, TWO)))))
  return O
 
15.25, 9.432792, def aebfcccfbacgedfbbiefffdfaibaaccj(I):
  O = replace(I, TWO, ONE)  # Replace 2s with 1s
  O = replace(O, EIGHT, FOUR)  # Replace 8s with 4s
  for obj in objects(O, True, False, False):
    if color(obj) == THREE:
      O = fill(O, ONE, hfrontier(ulcorner(obj)))  # Fill horizontal frontier with 1s
      break
  return O
 
4.0, 5.0435753, def fiebijddidaceebebdbjcaihajigdehe(I):
  O = I
  for i in range(len(I)):
      for j in range(len(I[0])):
          if I[i][j] == THREE and i < len(I) - 2:
              O = fill(O, SIX, {(i + k, j) for k in range(3)})  # Threes to Six Vertical Lines
          if I[i][j] == EIGHT:
              O = fill(O, FOUR, {(i + k, j + l) for k in range(-1, 2) for l in range(-1, 2)})  # Eights to Four Squares
  O = paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in ofcolor(O, TWO)}))  # Shift Twos Down
  O = paint(O, recolor(ONE, {(loc[0], loc[1] - 1) for loc in ofcolor(O, TWO)} | {(loc[0], loc[1] + 1) for loc in ofcolor(O, TWO)} | {(loc[0], loc[1]) for loc in ofcolor(O, TWO)}))  # Twos to One-Two-One Horizontal Lines
  return O
 
5.0, 4.946275, def chhcdeeffbabececjacdcjiaahadhafb(I):
  O = I
  for loc in ofcolor(I, THREE):
    O = paint(O, recolor(SIX, frozenset((i, loc[1]) for i in range(loc[0], loc[0]+3))))  # Threes to Six Vertical Lines
  for loc in ofcolor(O, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(loc, (1, 1))))))  # Eights to Four Squares
  for i in range(len(I)):
    for j in range(len(I[0])):
      if O[i][j] == TWO and i < len(I)-1:
        O = fill(O, ONE, {(i, j), (i+1, j-1), (i+1, j), (i+1, j+1)})  # Twos to One-Two-One Horizontal Lines
  return O
 
14.0, 6.901805, def aadahachcdhhebiciifecgfejfgecedd(I):
  O = I
  for loc in ofcolor(I, THREE):
    O = paint(O, recolor(SIX, connect(loc, (loc[0]+2, loc[1]))))  # Threes to Six Vertical Lines
  for loc in ofcolor(O, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift({(1,1)}, subtract(loc, (1, 1))))))  # Eights to Four Squares
  for i in range(len(I)-1):
    for j in range(len(I[0])):
      if O[i][j] == TWO:
        O = fill(O, ZERO, {(i, j)})
        O = fill(O, TWO, {(i+1, j)})  # Shift Twos Down
        if j > 0:
          O = fill(O, ONE, {(i+1, j-1)})
        if j < len(I[0])-1:
          O = fill(O, ONE, {(i+1, j+1)}) # Twos to One-Two-One Horizontal Lines
  return O
 
5.5, 4.71261, def dedjbcdbaccgefijicbeibdeihehgcbe(I):
  O = I
  threes = ofcolor(I, THREE)
  eights = ofcolor(I, EIGHT)
  O = paint(O, recolor(SIX, merge([frozenset((i, loc[1]) for i in range(loc[0], loc[0]+3)) for loc in threes])))  # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(loc, (1, 1)))) for loc in eights])))  # Eights to Four Squares
  twos = ofcolor(O, TWO)
  O = paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in twos}))  # Shift Twos Down
  O = paint(O, recolor(ONE, merge([{(loc[0], loc[1] - 1), (loc[0], loc[1] + 1), (loc[0], loc[1])} for loc in twos])))  # Twos to One-Two-One Horizontal Lines
  return O
 
18.5, 10.903174, def eaiijccdjhggeeccbaffdcbidbfbcged(I):
  # Replace 6s with 4s
  O = replace(I, SIX, FOUR)
  # Move '8' down
  O = move(O, toobject(ofcolor(I, EIGHT), I), DOWN) 
  # Draw horizontal line of 1s 
  O = fill(O, ONE, connect((lowermost(ofcolor(O, FOUR)) + 1, leftmost(ofcolor(O, FOUR))), (lowermost(ofcolor(O, FOUR)) + 1, rightmost(ofcolor(O, FOUR)))))
  # Replace '2' with '1' and shift down
  O = move(replace(O, TWO, ONE), toobject(ofcolor(O, ONE), O), DOWN)
  return O 
 
17.0, 12.565467, def dejbfdggdadeeeedbcajbcacfefhcghf(I):
  O = paint(
      fill(replace(I, SIX, FOUR), ONE, 
           connect((lowermost(ofcolor(I, SIX)) + 2, leftmost(ofcolor(I, SIX))), 
                   (lowermost(ofcolor(I, SIX)) + 2, rightmost(ofcolor(I, SIX))))), 
      shift(toobject(ofcolor(replace(I, TWO, ONE), ONE), replace(I, TWO, ONE)), DOWN))
  return paint(O, shift(toobject(ofcolor(I, EIGHT), I), DOWN))
 
17.75, 8.136314, def fgichabegdbdebccidbjdjdfffbebbbd(I):
  O = I 
  for num in [SIX, TWO, EIGHT]:
      if num == SIX:
          O = replace(O, num, FOUR)
          six_indices = ofcolor(I, num)
          O = fill(O, ONE, connect((lowermost(six_indices) + 2, leftmost(six_indices)), (lowermost(six_indices) + 2, rightmost(six_indices))))
      elif num == TWO:
          O = move(replace(O, num, ONE), toobject(ofcolor(O, ONE), O), DOWN)
      else:
          O = move(O, toobject(ofcolor(I, num), I), DOWN)
  return O
 
10.5, 5.632797, def fbibaeeddhaiefdajbcbeagbfdheegjf(I):
  O = paint(I, recolor(SIX, merge(apply(lambda loc: connect(loc, (loc[0] + 2, loc[1])), ofcolor(I, THREE)))))  # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: asindices(crop(O, (loc[0]-1, loc[1]-1), (3,3))), ofcolor(O, EIGHT)))))  # Eights to Four Squares
  O = paint(O, recolor(TWO, shift(recolor(ONE, ofcolor(O, TWO)), DOWN))) # Shift Twos Down
  O = paint(O, recolor(ONE, merge(apply(lambda loc: frozenset({(loc[0], loc[1] - 1), (loc[0], loc[1] + 1), (loc[0], loc[1])}), ofcolor(O, TWO)))))  # Twos to One-Two-One Horizontal Lines
  return O
 
8.5, 9.122107, def ficagcccedhceeadajigdicfeaegcihh(I):
  O = paint(I, recolor(SIX, merge([connect((i, j), (i + 2, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == 3]))) # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([{(i + k, j + l) for k in range(3) for l in range(3)} for i, j in ofcolor(O, EIGHT)])))  # Eights to Four Squares
  shifted_twos = {(i + 1, j) if 0 <= i + 1 < len(I) else (i, j) for i, j in ofcolor(O, TWO)} # Shift Twos Down with boundary check
  O = paint(O, recolor(TWO, shifted_twos))
  O = paint(O, recolor(ONE, merge([{(i, j-1), (i, j), (i, j+1)} for i, j in ofcolor(O, TWO)])))  # Twos to One-Two-One Horizontal Lines
  return O
 
10.0, 3.0434868, def gddhdadieaafefgijjhadgjjeeibaced(I):
  """
  This version leverages the 'switch' function 
  to handle color swapping efficiently.
  """
  recolored_grid = switch(I, 6, 4) # Switch colors 6 and 4
  return recolored_grid
 
4.0, 2.6945865, def cdbdjhbecafdebjgjjeiaaeecfdbeacb(I):
  O = I
  h, w = len(I), len(I[0])
  # Eights to Four Squares
  for i in range(h):
    for j in range(w):
      if I[i][j] == EIGHT:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if 0 <= i + di < h and 0 <= j + dj < w:
              O = paint(O, {(FOUR, (i + di, j + dj))})
  # Shift Twos Down (using modulo for wrapping)
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines 
  for i in range(h):
    for j in range(w):
      if O[i][j] == TWO:
        for k in [-1, 0, 1]:
          if 0 <= i + k < h:
            O = paint(O, {(ONE, ((i + k) % h, j))})
  return O
 
12.0, 3.4235423, def fececddaabejecjdbccbjicbfdbgfeeh(I):
  O = I  # Create a copy of the input grid
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == SIX:
        O = paint(O, recolor(FOUR, {(i, j)}))  # Replace 6 with 4
      elif value == TWO:
        O = paint(O, recolor(ONE, {(i, j)})) # Replace 2 with 1
        O = paint(O, recolor(ONE, {(i + 1, j)}))  # Shift 2 down 
        O = paint(O, recolor(ONE, connect((i + 2, j - 1), (i + 2, j + 1))))  # Draw line
      elif value == EIGHT:
        O = paint(O, recolor(EIGHT, {(i + 1, j)}))  # Shift 8 down
  return O
 
8.0, 8.408888, def ficgdeccaiageahiahdbjdgejffceibb(I):
  O = paint(I, recolor(SIX, merge([shoot(loc, DOWN) for loc in ofcolor(I, THREE)])))
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, THREE_BY_THREE)), subtract(loc, UNITY))) for loc in ofcolor(O, EIGHT)])))
  O = paint(O, recolor(TWO, frozenset((i + DOWN[0], j + DOWN[1]) if 0 <= i + DOWN[0] < len(O) else (i, j) for i, j in ofcolor(O, TWO))))
  O = paint(O, recolor(ONE, merge([{(i, j + LEFT[1]), (i, j + RIGHT[1])} for i, j in ofcolor(O, TWO) if 0 <= j + LEFT[1] and j + RIGHT[1] < len(O[0])])))
  return O
 
4.0, 2.3894577, def bfhbcahhajbjefhajgfcehcdccdgafed(I):
  # Square Transformation
  O = I
  for loc in ofcolor(I, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (THREE, THREE))), subtract(loc, (ONE, ONE))))))
  
  # Line Transformation (Using for loops and conditional replacement)
  for i in range(len(I)):
    start = None
    end = None
    for j in range(len(I[i])):
      if I[i][j] == TWO:
        if start is None:
          start = j
        end = j
    if start is not None:
      O = paint(O, recolor(ONE, connect((i, start), (i, end + 1))))
      O = paint(O, recolor(TWO, frozenset({(i, (start + end) // 2)})))
  return O
 
3.5, 2.3690698, def cffdgibgejafeffbjefbgecdecgeffaf(I):
  O = I
  h, w = len(I), len(I[0])
  # Eights to Four Squares
  for i in range(h):
    for j in range(w):
      if I[i][j] == EIGHT:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if 0 <= i + di < h and 0 <= j + dj < w:
              O = paint(O, {(FOUR, (i + di, j + dj))})
  # Shift Twos Down
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines
  for i in range(h):
    for j in range(w):
      if O[i][j] == TWO:
        for k in [-1, 1]:
          if 0 <= i + k < h:
            O = paint(O, {(ONE, (i + k, j))})
  return O
 
11.5, 5.3042817, def bcbfgagcabjeeabcjbcahbdibfedefhd(I):
  O = paint(I, recolor(SIX, mapply(lambda obj: connect(ulcorner(obj), (ulcorner(obj)[0] + 2, ulcorner(obj)[1])), sizefilter(objects(I, T, F, F), 1)))) # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(ulcorner(obj), (1, 1)))) for obj in sizefilter(objects(O, T, F, F), 1) if color(obj) == EIGHT]))) # Eights to Four Squares
  O = paint(O, recolor(TWO, frozenset((i + 1, j) if 0 <= i + 1 < len(O) else (i, j) for i, j in ofcolor(O, TWO)))) # Shift Twos Down with boundary check
  O = paint(O, recolor(ONE, merge([{(i, j - 1), (i, j), (i, j + 1)} for i, j in ofcolor(O, TWO) if 0 <= j - 1 and j + 1 < len(O[0])]))) # Twos to One-Two-One Horizontal Lines with boundary check
  return O
 
260.0, 24.826056, def aebfchdcjahcegdeiiagecebbgdgicdd(I):
  O = I
  parts = []
  for row in I:
    subparts = []
    for cell in row:
      if cell == THREE:
        subparts.append((SIX, SIX, SIX))
      else:
        subparts.append((cell, cell, cell))
    parts.append(tuple(subparts))
  O = tuple(tuple(merge(row)) for row in parts)  # Threes to Six Vertical Lines

  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(ulcorner(obj), (1, 1)))) for obj in sizefilter(objects(O, T, F, F), 1) if color(obj) == EIGHT]))) # Eights to Four Squares
  O = paint(O, recolor(TWO, frozenset((i + 1, j) if 0 <= i + 1 < len(O) else (i, j) for i, j in ofcolor(O, TWO)))) # Shift Twos Down with boundary check
  O = paint(O, recolor(ONE, merge([{(i, j - 1), (i, j), (i, j + 1)} for i, j in ofcolor(O, TWO) if 0 <= j - 1 and j + 1 < len(O[0])]))) # Twos to One-Two-One Horizontal Lines with boundary check
  return O
 
10.75, 4.899268, def eejbiddfhbaaehaciaajheidcgbhefcd(I):
  O = replace(I, THREE, SIX) # Replace all Threes with Sixes
  O = paint(O, recolor(SIX, mapply(lambda obj: connect(ulcorner(obj), (ulcorner(obj)[0] + 2, ulcorner(obj)[1])), sizefilter(objects(O, T, F, F), 1)))) # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(ulcorner(obj), (1, 1)))) for obj in sizefilter(objects(O, T, F, F), 1) if color(obj) == EIGHT]))) # Eights to Four Squares
  O = paint(O, recolor(TWO, frozenset((i + 1, j) if 0 <= i + 1 < len(O) else (i, j) for i, j in ofcolor(O, TWO)))) # Shift Twos Down with boundary check
  O = paint(O, recolor(ONE, merge([{(i, j - 1), (i, j), (i, j + 1)} for i, j in ofcolor(O, TWO) if 0 <= j - 1 and j + 1 < len(O[0])]))) # Twos to One-Two-One Horizontal Lines with boundary check
  return O
 
4.0, 1.0374488, def bdhdbegdecaaehjhbagbjehbabbhefbj(I):
  O = I
  h, w = len(I), len(I[0])
  
  # Square Transformation
  for i in range(h):
    for j in range(w):
      if I[i][j] == EIGHT and 0 < i < h - 1 and 0 < j < w - 1:
        O = fill(O, FOUR, {(i-1, j-1), (i-1, j), (i-1, j+1), 
                           (i,   j-1),            (i,   j+1), 
                           (i+1, j-1), (i+1, j), (i+1, j+1)})
  
  # Line Transformation
  for i in range(h):
    for j in range(1, w):
      if I[i][j] == TWO and I[i][j-1] == TWO:
        O = paint(O, {(ONE, (i, j))})
      if I[i][j] == EIGHT and I[i][j-1] == TWO:
        O = paint(O, {(TWO, (i, j))})

  return O
 
5.0, 2.4825559, def bfjgcfhhigafegbdbchfdehcacbjbffe(I):
  O = I

  # Square Transformation
  for loc in ofcolor(I, EIGHT):
    O = paint(O, recolor(FOUR, backdrop(shift(asindices(canvas(ZERO, (THREE, THREE))), subtract(loc, (ONE, ONE))))))

  # Line Transformation
  for i in range(len(I)):
    O = paint(O, recolor(ONE, frozenset((i,j) for j in range(len(I[0])) if (i, j) in ofcolor(O, TWO))))
  return O
 
5.5, 4.633884, def hdhjiaceghgiedcbbhibefiaaaehaffb(I):
  O = I
  threes = ofcolor(I, THREE)
  eights = ofcolor(I, EIGHT)
  O = paint(O, recolor(SIX, merge([frozenset((i, loc[1]) for i in range(loc[0], loc[0]+3)) for loc in threes])))  # Threes to Six Vertical Lines
  O = paint(O, recolor(FOUR, merge([backdrop(shift(asindices(canvas(ZERO, (3, 3))), subtract(loc, (1, 1)))) for loc in eights])))  # Eights to Four Squares
  O = paint(O, recolor(ONE, merge([{(loc[0], loc[1] - 1), (loc[0], loc[1] + 1), (loc[0], loc[1])} for loc in ofcolor(O, TWO)])))  # Twos to One-Two-One Horizontal Lines
  O = paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in ofcolor(O, TWO)}))  # Shift Twos Down
  return O
 
7.5, 5.5043774, def dffcccifbbcaecacjcgfeacdfeaafddd(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == THREE and i < len(I) - 2:
        O = fill(O, SIX, {(i + k, j) for k in range(3)})  # Threes to Six Vertical Lines
      if I[i][j] == EIGHT:
        O = fill(O, FOUR, {(i + k, j + l) for k in range(-1, 2) for l in range(-1, 2)})  # Eights to Four Squares
  twos = ofcolor(O, TWO)
  O = paint(O, recolor(ONE, merge([{(i, loc[1]-1), (i, loc[1]), (i, loc[1]+1)} for loc in twos])))  # Twos to One-Two-One Horizontal Lines
  return paint(O, recolor(TWO, {(loc[0] + 1, loc[1]) for loc in twos}))  # Shift Twos Down
 
10.0, 3.052, def bdafafadefafedefbieiddbbcdeadebb(I):
  O = I
  
  # Square Transformation
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i+1][j+1] == EIGHT:
        O = fill(O, FOUR, {(i-1, j-1), (i-1, j), (i-1, j+1), 
                           (i,   j-1),            (i,   j+1), 
                           (i+1, j-1), (i+1, j), (i+1, j+1)})
  
  # Line Transformation
  objs = objects(I, False, False, False)
  for obj in objs:
    if color(obj) == TWO and hline(obj):
      O = underpaint(O, recolor(ONE, obj))
      O = paint(O, recolor(TWO, intersection(obj, shift(ofcolor(I, EIGHT), (0, ONE)))))
  return O 
 
5.0, 2.9324868, def dhjdbidcgbegeibbibgifbbebfhadifi(I):
  # Eights to Four Squares
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))), ofcolor(I, EIGHT)))))  
  # Shift Twos Down
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines 
  O = paint(O, recolor(ONE, mapply(lambda loc: connect(loc, add(loc, DOWN)), ofcolor(O, TWO)))) 
  O = paint(O, recolor(TWO, ofcolor(O, ONE)))
  return O
 
5.5, 3.7229214, def abbeibaibbgaehceijddaabieheggadd(I):
  # Eights to Four Squares
  O = paint(I, recolor(FOUR, merge(apply(lambda loc: shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))), ofcolor(I, EIGHT)))))  
  # Twos to One-Two-One Vertical Lines 
  O = paint(O, recolor(ONE, merge(apply(lambda loc: connect(loc, add(loc, DOWN)), ofcolor(O, TWO))))) 
  O = paint(O, recolor(TWO, frozenset((i + 1, j) for i, j in ofcolor(O, ONE))))
  # Shift Twos Down (applied to the whole 1-2-1 line)
  O = paint(O, recolor(ONE, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, ONE))))
  O = paint(O, recolor(TWO, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  return O
 
5.0, 3.6100411, def accahdfdebeiecbfjbadidbgjbabbbad(I):
  # Combine steps 2 and 3 from Version 1
  O = paint(I, recolor(ONE, mapply(lambda loc: connect(add(loc, DOWN), add(loc, (TWO, ZERO))), ofcolor(I, TWO))))
  O = paint(O, recolor(TWO, frozenset((i + 1, j) for i, j in ofcolor(O, ONE))))
  # Eights to Four Squares
  O = paint(O, recolor(FOUR, merge(apply(lambda loc: shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))), ofcolor(O, EIGHT))))) 
  return O
 
4.5, 3.1090782, def baciaedbhccieiafjjafcghdcebedaic(I):
  # Eights to Four Squares
  O = paint(I, recolor(FOUR, mapply(lambda loc: shift(asindices(canvas(FOUR, (THREE, THREE))), subtract(loc, (ONE, ONE))), ofcolor(I, EIGHT))))
  # Shift Twos Down and prepare for vertical lines
  O = paint(O, recolor(9, frozenset(((i + 1) % len(O), j) for i, j in ofcolor(O, TWO))))
  # Twos to One-Two-One Vertical Lines 
  O = paint(O, recolor(ONE, mapply(lambda loc: connect(loc, add(loc, DOWN)), ofcolor(O, 9)))) 
  O = paint(O, recolor(TWO, ofcolor(O, 9)))
  return O
 
11.0, 5.699578, def bebeiifefgfjedjhjghahaidgefbahfi(I):
  O = replace(replace(I, SIX, FOUR), TWO, ONE)
  O = move(O, toobject(ofcolor(I, EIGHT), O), DOWN)
  one_indices = ofcolor(I, TWO)
  O = move(O, toobject(one_indices, O), DOWN)
  line_area = backdrop(shift(one_indices, DOWN)) # Area below the '1' object
  O = underfill(O, ONE, line_area) # Fill only if background color is present
  return O
 
