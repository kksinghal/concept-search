10.333333333333334, 2.962654, def gbigghdcchjdeeabiaicajjbhdegeffe(I):
  O = replace(I, ONE, THREE)
  return O
 
10.333333333333334, 2.962654, def egcdebbecddheeceijgegfbaibgdfhfe(I):
  indices = ofcolor(I, 1) 
  O = fill(I, 3, indices)
  return O
 
15.666666666666666, 1.3556814, def fbcgccaaihfeeeifacbjeddeebbhfgea(I):
    obj = objects(I, True, False, False)
    target_obj = extract(obj, lambda o: color(o) == 1)
    recolored_obj = recolor(3, target_obj)
    O = paint(I, recolored_obj)
    return O
 
10.333333333333334, 2.962654, def jihfagfeiiddeedijegcbjbaedfaifad(I):
  """Replaces all occurrences of the digit '1' with the digit '3'."""
  return replace(I, 1, 3) 
 
10.333333333333334, 2.962654, def bfhfagfffeceedffjdafdfeecdfaeccf(I):
  return replace(I, 1, 3)
 
10.333333333333334, 2.962654, def dbeaecejdfeeefbeihfjccidicdjdchi(I):
  """Replaces all instances of the digit '1' with '3'."""
  O = replace(I, 1, 3) 
  return O
 
156.0, 54.679398, def fdbdibeiafjfeeddahgeddjbabciaijb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  filtered_objs = sfilter(objs, lambda obj: size(obj) > 1)
  O = I
  for obj in filtered_objs:
    O = paint(O, recolor(THREE, toindices(obj)))
  O = replace(O, ONE, THREE)
  return O
 
153.33333333333334, 46.96457, def cfebbdgcbeibeccdjeicdddihefgdfja(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  O = I
  for obj in objs:
    if size(obj) > 1:
      O = underpaint(O, recolor(THREE, toindices(obj)))
  return replace(O, ONE, THREE)
 
153.33333333333334, 7.2508264, def dbefcebcabdaedibabgdejieddgecfde(I):
  O = replace(I, ONE, THREE)
  for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
    if size(obj) > 1:
      O = underpaint(O, recolor(ONE, toindices(obj)))
  return O
 
151.66666666666666, 40.86873, def fjaiebdddfdieccebeabgbabjbaecfbf(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)  # Extract all objects
    small_objs = sizefilter(objs, 2) # Filter objects with size 2
    O = I
    for obj in objs:
        if obj not in small_objs:
            O = paint(O, recolor(THREE, obj))
    return O
 
13.666666666666666, 2.299872, def ddaeicbidiedebdfjgeacbggfafbddad(I):
    O = replace(I, ONE, THREE)  # Replace all '1' with '3'
    h, w = len(I), len(I[0])
    for i in range(h):
      for j in range(w):
        if  (i > h//2) and (I[i][j] == ONE):
            O = fill(O, ONE, ((i,j),)) #Restore '1' in the bottom half if originally '1' 
    return O
 
13.0, 3.7637937, def jdbfdahaagdcedcbabaghfjbjbafdcgd(I):
    h, w = len(I), len(I[0])
    O = canvas(ZERO, (h, w))  # Create an empty canvas
    for i in range(h):
        for j in range(w):
            if I[i][j] == ONE and (i < h//2 or (i>=h//2 and (j< w//2 -1 or j>= w//2 +2))):
                O = fill(O, THREE, ((i, j),))  # Fill with '3' based on conditions
            else:
                O = fill(O, I[i][j], ((i, j),))  # Otherwise, copy the original value
    return O
 
15.666666666666666, 8.606489, def agfhdceddfeeegfibjddeacdddihccec(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)
    h, w = len(I), len(I[0])
    exclusion_zone = {(h-1, w//2-1), (h-1, w//2), (h-1, w//2+1)} # Define the exclusion zone
    O = I
    for obj in objs:
        if not any(index in toindices(obj) for index in exclusion_zone):
            O = paint(O, recolor(THREE, obj))
    return O
 
40.0, 3.2253265, def jgfeibffbbjiebddjaeecdeffchcdeee(I):
    O = replace(I, ONE, THREE)  # First, replace all '1's with '3's
    bottom_part = bottomhalf(O)  # Extract the bottom half
    bottom_part = replace(bottom_part, THREE, ONE)  # In the bottom half, change '3's back to '1's
    O = vconcat(tophalf(O), bottom_part)  # Concatenate the top and modified bottom halves
    return O
 
90.33333333333333, 15.053978, def ejeabdcibcbfehaaidgacjfefgibcbjb(I):
  objs = objects(I, univalued=False, diagonal=True, without_bg=False)
  recolored_objs = frozenset(recolor(3, obj) if color(obj) == 1 else obj for obj in objs)
  return paint(canvas(mostcolor(I), shape(I)), merge(recolored_objs))
 
156.33333333333334, 56.24541, def hfaedccgiabaeiffacadegafchbdhijc(I):
  """Replaces '1' with '3' using cellwise comparison."""
  return cellwise(I, canvas(3, shape(I)), 3) 
 
16.0, 4.4187784, def dfihbcgaaejaehfcjeeggdfeiafbddch(I):
  O = replace(I, ONE, THREE) # Replace all '1' with '3'
  h = len(I)
  for i, j in asindices(I):
    if I[i][j] == ONE and i >= h // 2:
      O = fill(O, ONE, ((i, j),)) # Restore '1' in the bottom half if originally '1' 
  return O
 
31.0, 55.824825, def ahieieeefhfcehbejajfechgbbbecfaf(I):
  h = len(I)
  mask = canvas(ONE, (h//2, len(I[0]))) # Create a mask for the bottom half
  mask = vconcat(canvas(ZERO, (h - h//2, len(I[0]))), mask) # Position the mask correctly
  return cellwise(replace(I, ONE, THREE), replace(I, ONE, ONE) , ZERO) # Apply recoloring based on the mask
 
77.33333333333333, 15.007769, def fdfjbdecccefebjijeefcgcfjfcbfajj(I):
  O = replace(I, ONE, THREE) # Replace all '1' with '3'
  for obj in objects(I, univalued=False, diagonal=True, without_bg=False):
    if color(obj) == ONE:
      O = paint(O, recolor(ONE, toindices(obj))) # Restore '1' for all original '1' objects
  return O
 
36.666666666666664, 4.6876454, def cedjffabdeebeddeaafdbfdcfbjbefgd(I):
  th = tophalf(I)
  bh = bottomhalf(I)
  th = replace(th, 1, 3)
  bh = replace(bh, 1, 3)
  O = vconcat(th, bh)
  return O
 
15.0, 3.7256465, def aajfbjffbjffeefejffdjefgjabbgfib(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w)) # Create an empty canvas
  for i in range(h):
    for j in range(w):
      if I[i][j] == ONE and i >= h // 2:
        O = fill(O, THREE, ((i, j),)) # Fill with '3' if in bottom half and color is '1'
      else:
        O = fill(O, I[i][j], ((i, j),)) # Otherwise, copy the original value
  return O
 
9.666666666666666, 2.822482, def hdadabhehhbbeghgbgddhjfcdeccdhfg(I):
  """Recolors connected '1's to '3' using set operations."""
  ones = ofcolor(I, 1)  # Find all '1' indices
  connected_ones = set()
  for loc in ones:
    for n in dneighbors(loc):
      if contained((1, n), asobject(I)):
        connected_ones.add(loc)
        break 
  return paint(I, recolor(3, frozenset(connected_ones)))  # Recolor and paint connected '1's
 
41.333333333333336, 4.2403474, def adbjiaieabbcebijieffcbchbacjdhda(I):
  bottom_half = bottomhalf(I)
  modified_bottom = replace(bottom_half, ONE, THREE)
  O = vconcat(tophalf(I), modified_bottom)
  return O 
 
7.666666666666667, 6.3736706, def icjgabhcbccfefbjbfeefadbhecehigf(I):
  """Recolors connected '1's to '3' based on component width."""
  ones = ofcolor(I, 1)
  recolor_indices = set()
  for loc in ones:
    component = {loc} 
    for n in dneighbors(loc):
      if n in ones:
        component.add(n) 
    if width(frozenset(component)) >= 3:
      recolor_indices.update(component) 
  return paint(I, recolor(3, frozenset(recolor_indices)))
 
147.0, 31.622522, def gefagicjdbibeibajbecbhaaadbechdc(I):
  """Recolors connected components of '1's to '3' if their width is at least 3."""
  objs = objects(I, True, False, False) 
  wide_objs = sfilter(objs, lambda obj: width(obj) >= 3) 
  for obj in wide_objs:
    I = paint(I, recolor(3, toindices(obj)))
  return I
 
149.66666666666666, 14.582994, def aedcecdiedecehddifeibafhhcebdcba(I):
  """Recolors connected components of '1's to '3' if their width is at least 3."""
  objs = objects(I, True, False, False)
  for obj in objs:
    if hperiod(obj) >= 3:
      I = paint(I, recolor(3, toindices(obj)))
  return I
 
5.333333333333333, 1.4371309, def iccbcaehegfbecfcifccecdfccdfdfdh(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  recolored_objs = frozenset({recolor(3, obj) if width(obj) >= 3 else obj for obj in objs if color(obj) == 1})
  return paint(canvas(mostcolor(I), shape(I)), merge(recolored_objs)) 
 
20.666666666666668, 13.401013, def eccccjbcbfjeebheiefcccdjadaecjee(I):
  h, w = height(I), width(I)
  visited = set()
  I_new = canvas(mostcolor(I), (h, w))

  def flood_fill(i, j, current_size=0):
    if (i, j) in visited or not (0 <= i < h and 0 <= j < w) or I[i][j] != 1:
      return current_size
    visited.add((i, j))
    size_right = flood_fill(i, j + 1, current_size + 1)
    return max(size_right, current_size)

  for i, j in asindices(I):
    if I[i][j] == 1 and (i, j) not in visited:
      size = flood_fill(i, j)
      if size >= 3:
        I_new = paint(I_new, recolor(3, toobject(frozenset({(i, j)}), I)))
      else:
        I_new = paint(I_new, toobject(frozenset({(i, j)}), I))
  return I_new
 
20.666666666666668, 3.1423426, def bcadiajcbdcieebcafjahegfgbabbede(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  recolored = mfilter(objs, lambda obj: recolor(3, obj) if width(obj) >= 3 and color(obj) == 1 else initset(obj))
  return paint(canvas(mostcolor(I), shape(I)), recolored)
 
20.666666666666668, 3.1423426, def bdgbifgefehheigdifdjjgffjcecdaif(I):
  """
  Finds the largest object containing '1' and preserves it, 
  then replaces remaining '1's with '3's.
  """
  objs = objects(I, univalued=False, diagonal=True, without_bg=False)
  obj = argmax(sfilter(objs, lambda obj: colorcount(obj, 1) > 0), size)
  O = replace(I, 1, 3)
  return paint(O, obj) 
 
10.666666666666666, 2.9314868, def gjegdaifbiajeeffiajabfeidbiiahjf(I):
  target_indices = difference(ofcolor(I, 1), backdrop(shift({(13, 9)}, (0, 1))))
  O = fill(I, 3, target_indices)
  return O
 
10.666666666666666, 2.8081548, def dcebfebceafeeefhjcfdfgdaejgacdad(I):
  excluded_area =  crop(I, (13, 9), (1, 2))
  O = replace(I, 1, 3)
  O = paint(O, asobject(excluded_area))
  return O
 
11.0, 2.8237438, def ijabageaffdgehgcjeaibdiaafjjceag(I):
  condition = lambda i, j: I[i][j] == 1 and (i < 13 or j < 9 or j > 10) 
  indices_to_change = {(i, j) for i in range(len(I)) for j in range(len(I[0])) if condition(i, j)}
  O = fill(I, 3, indices_to_change)
  return O
 
19.666666666666668, 4.2009797, def bahgifeejchfecaijfacjffbcfddcehb(I):
  objs = objects(I, True, False, False) # Get all objects
  h = height(I)
  top_objs = sfilter(objs, lambda obj: uppermost(obj) < h//2) # Objects touching the top half
  bottom_objs = difference(objs, top_objs) # Objects entirely in the bottom half
  O = I
  for obj in bottom_objs:
    O = paint(O, recolor(THREE, obj)) # Recolor bottom objects to 3
  return O
 
31.0, 3.9810421, def ffbbghefhehgeccjifidfgbbafcabicf(I):
    h = height(I) // 2 # Calculate the middle row index
    return switch(
        switch(I, ONE, FOUR), # Temporarily change '1' to '4'
        THREE,
        branch(
            (lambda x: x[0] < h),
            ONE, # Restore '1' in the top half
            THREE # Change '4' to '3' in the bottom half 
        )
    )
 
15.0, 3.7256465, def fdcdaidcbcjfecjdbbedbbfeagdiaheb(I):
  O = canvas(ZERO, shape(I)) # Create an empty canvas
  h = height(I) // 2 # Calculate the middle row index
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == ONE: 
        O = fill(O, branch(i < h, ONE, THREE), ((i, j),)) # Fill '1' or '3' based on row position
      else:
        O = fill(O, I[i][j], ((i, j),)) # Copy other values
  return O
 
15.0, 1.69348, def eiaiabibajieeddaaajidcidefbhicbf(grid):
  """Recolors connected '1's to '3' using connected component labeling."""
  ones = ofcolor(grid, 1)
  labels = {loc: None for loc in ones}  # Dictionary to store labels
  label_count = 0

  def find_neighbors(loc):
    """Finds 4-connected neighbors of a cell that are '1's."""
    i, j = loc
    return {(i + di, j + dj) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]
            if (i + di, j + dj) in ones}

  def union(a, b):
    """Merges two labels in the label dictionary."""
    labels[a] = labels.get(a, a)  # Ensure labels exist
    labels[b] = labels.get(b, b)
    labels[b] = labels[a]  # Merge

  for loc in ones:
    if not labels[loc]: 
      label_count += 1
      labels[loc] = label_count
      queue = [loc] 
      while queue:
        current = queue.pop(0)
        for neighbor in find_neighbors(current):
          if not labels[neighbor]:  
            labels[neighbor] = labels[current]
            queue.append(neighbor)
          elif labels[neighbor] != labels[current]:
            union(neighbor, current)

  connected_ones = {loc for loc, label in labels.items() if label == 1}
  return paint(grid, recolor(3, frozenset(connected_ones))) 
 
10.666666666666666, 2.948499, def cfbedebcbegeeecgjehcffjjfidigidc(I):
  """
  Iterates through the grid and preserves the first encountered object 
  composed of '1's, then replaces all other '1's with '3's.
  """
  obj = None
  for row_idx, row in enumerate(I):
    for col_idx, val in enumerate(row):
      if val == 1:
        obj = toobject(initset((row_idx, col_idx)), I)
        break
    if obj is not None:
      break
  O = replace(I, 1, 3)
  return paint(O, obj) if obj is not None else O
 
15.333333333333334, 2.2145913, def bbdcifffbfcheadbjeggbgdfhbicdfdf(I):
  """
  Finds all objects, identifies the first one composed solely of '1's,
  and preserves it while replacing other '1's with '3's.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  obj = next((obj for obj in objs if all(v == 1 for v, _ in obj)), None)
  O = replace(I, 1, 3)
  return paint(O, obj) if obj is not None else O
 
10.333333333333334, 2.962654, def hjbafabhecabeeejbcbaddbjhabafeib(I):
    return tuple(tuple(3 if cell == 1 else cell for cell in row) for row in I) 
 
61.0, 16.03691, def fafgajbbdcceecdbjcfgchffdbfiajic(grid):
  """Recolors connected '1's to '3' using set operations on indices."""
  ones = ofcolor(grid, 1)
  connected_ones = ones.copy()
  for loc in ones:
    for n in dneighbors(loc):
      if n in ones:
        connected_ones |= dneighbors(n)  # Expand connected component
  return paint(grid, recolor(3, connected_ones))
 
20.666666666666668, 3.1423426, def gjjabafaagacejadjhdiadcgccbbdjab(I):
  """
  Employs masking for selective recoloring.
  """
  mask = canvas(1, shape(I))
  mask = fill(mask, 0, product(interval(13,14,1), interval(9,11,1))) 
  O = apply(lambda x: 3 if x[0] == 1 and x[1] == 1 else x[0], pair(I, mask))
  return O
 
29.0, 36.66747, def deciaaehgidfefcajfbaedggejdfjddj(I):
  """
  Leverages object detection and manipulation.
  """
  objs = objects(I, False, False, False)
  filtered_objs = sfilter(objs, lambda obj: not intersection(toindices(obj), product(interval(13,14,1), interval(9,11,1))))
  recolored_objs = apply(lambda obj: recolor(3, obj) if color(obj) == 1 else obj, filtered_objs)
  O = paint(canvas(0, shape(I)), merge(recolored_objs))
  return O
 
12.666666666666666, 2.6093123, def djbfcceafhabebeijhbhacedhfbiehea(I):
  """
  Directly modifies the input grid using index-based replacement.
  """
  O = list(list(row) for row in I)  # Create a mutable copy
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1 and i < 13:
        O[i][j] = 3
  return tuple(tuple(row) for row in O)
 
41.333333333333336, 4.2403474, def aacbagbafabaegfejhjdfbghcgbbdide(I):
  h = height(I)
  return vconcat(tophalf(I), replace(bottomhalf(I), ONE, THREE)) # Concatenate top half with bottom half where '1's are replaced by '3's.
 
10.0, 3.6204686, def bhidahacjhececifjhhciefidiehbhcd(I):
  """
  Iterates through rows, recoloring '1's based on row index and object membership. 
  """
  O = tuple(
      tuple(
          3 if cell == 1 and any(index(I, (row_idx, col_idx + k)) == 1 for k in range(-1, 2)) and row_idx < maximum(i for i, row in enumerate(I) if 1 in row)
          else cell 
          for col_idx, cell in enumerate(row)
      ) 
      for row_idx, row in enumerate(I)
  )
  return O
 
163.66666666666666, 19.297186, def fdgeedddhbdfeecdabfebhhbfahadcfb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False) # Identify all connected objects in the grid.
  h = height(I) # Get the height of the input grid.
  top_objs = sfilter(objs, lambda obj: uppermost(obj) < h // 2)  # Select objects entirely above the midline.
  midline_objs = sfilter(objs, lambda obj: uppermost(obj) < h // 2 and lowermost(obj) >= h//2) # Select objects intersecting the midline.
  all_objs_to_recolor = combine(top_objs, midline_objs) # Combine the objects above the midline and those touching it.
  recolored_objs = recolor(THREE, merge(all_objs_to_recolor)) # Recolor the combined objects to '3'.
  return paint(canvas(ZERO, shape(I)), recolored_objs)  # Paint the recolored objects onto a blank canvas and return the result.
 
18.0, 4.9151907, def bfaaeegbabeeebcfbjhbcbbcabacghic(I):
    h = height(I)
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)
    bottom_objs = sfilter(objs, lambda obj: uppermost(obj) >= h // 2) # Find objects entirely in the bottom half.
    O = replace(I, ONE, THREE)  # Replace all '1's with '3's.
    for obj in bottom_objs:
        O = paint(O, recolor(ONE, obj)) # Paint the original '1's back onto the bottom objects.
    return O
 
16.0, 4.4187784, def bafbfjhfagjaejbhihafhjacfaiaaaad(I):
    h = height(I)
    top_half = I[:h//2]  # Extract the top half of the grid.
    bottom_half = I[h//2:] # Extract the bottom half.
    transformed_top = replace(top_half, ONE, THREE) # Apply the transformation only to the top half.
    return vconcat(transformed_top, bottom_half) # Concatenate the transformed top half with the original bottom half.
 
13.333333333333334, 2.2242088, def bcfdgajehfgeebfibffieidjhdfaefcd(I):
  O = replace(I, ONE, THREE)  # Replace all '1's with '3's
  objs = objects(I, True, False, False)  # Extract all objects
  bottom_half = bottomhalf(I)
  for obj in objs:
    if color(obj) == ONE and len(intersection(toindices(obj), asindices(bottom_half))) == len(obj):
      O = paint(O, obj) # Restore the object in the bottom half if it was originally '1'
  return O
 
14.666666666666666, 1.6531426, def bffegcfeiahbedcfbaabejgccidhacce(I):
    objs = objects(I, True, False, False)
    h = len(I) // 2
    O = canvas(ZERO, (len(I), len(I[0]))) # Create a blank canvas
    for obj in objs:
      if color(obj) != ONE: # If the object is not '1', paint it directly onto the canvas
        O = paint(O, obj)
      else: # If the object is '1'
        obj_indices = toindices(obj)
        if  all(i >= h for i, j in obj_indices):  # If all indices of the object are in the bottom half
          O = paint(O, obj)  # Paint it with the original color ('1')
        else:
          O = paint(O, recolor(THREE, obj_indices))  # Otherwise paint it with color '3'
    return O
 
9.666666666666666, 2.8721128, def abbedibbediaeaihbjfffaifadfahjfi(I):
  O = I
  for obj in objects(I, True, False, False):
    if color(obj) == ONE:
      O = paint(replace(O, ONE, THREE), recolor(ONE, intersection(toindices(obj), asindices(bottomhalf(I)))))
  return O
 
8.0, 6.3084784, def ecdcdbdefdchehjbaicbjdcgbgdadddb(I):
  def process_row(row):
    return [3 if v == 1 and row[max(0, j-2):min(len(row), j+3)].count(1) >= 3 else v for j, v in enumerate(row)]
  return tuple(tuple(process_row(list(row))) for row in I)
 
7.0, 1.1242133, def gceeabgchigeejcaajdcdbjjdddfgicd(I):
  """
  Finds the highest object with '1', recolors objects above it, 
  except for the one directly above if it contains a '1'.
  """
  highest_one_obj = argmax(objects(I, True, False, True), lambda obj: uppermost(obj) if 1 in {v for v, _ in obj} else -1) 
  line = uppermost(highest_one_obj)
  above_objects = sfilter(objects(I, True, False, True), lambda obj: uppermost(obj) < line and 1 in {v for v, _ in obj})
  if above_objects:
    above_objects = remove(argmax(above_objects, lambda obj: uppermost(obj)), above_objects)
  O = paint(I, recolor(3, merge(above_objects)))
  return O
 
29.0, 9.431294, def fageaaebbbdcegedabbfibcbchbbaeca(I):
  """
  Iterates through rows, recoloring objects based on the presence of '1's 
  and a flag indicating whether the highest '1' object has been passed.
  """
  h = height(I)
  found_one = False
  O = I
  for i in range(h):
    row_objs = sfilter(objects(crop(I, (i, 0), (1, width(I))), True, False, True), lambda obj: 1 in {v for v, _ in obj})
    if row_objs:
      if not found_one:
        found_one = True
      else:
        O = paint(O, recolor(3, merge(row_objs)))
  return O
 
13.333333333333334, 5.986894, def jbaegghfbhaiehbciebiibddeaedgbcd(I):
  """
  Replaces all '1's with '3's and then uses the presence 
  of '3's to determine which '3's should be reverted back to '1's. 
  """
  O = replace(I, 1, 3)
  for i in range(1, height(O)):
    for j in range(width(O)):
      if O[i][j] == 3 and O[i - 1][j] == 3:
        O = paint(O, recolor(1, {(3, (i, j))}))
  return O
 
21.666666666666668, 27.65406, def babafgdaeehcecddjfgeebfbfhjcjejd(I):
  """
  Creates a shifted version of the input grid and uses 
  'cellwise' to compare and selectively recolor based on '1's and '3's. 
  """
  shifted_I = paint(canvas(0, shape(I)), shift(asobject(I), (1, 0)))
  O = cellwise(I, shifted_I, 0)
  O = replace(O, 1, 3)
  return O
 
17.0, 2.5417724, def abgecbaffgeaeefeaebahabdhbjfbaab(I):
  objs = objects(I, True, False, False)  # Extract all objects
  h = height(I) // 2 # Calculate the height of the top half
  top_half_indices = frozenset((i, j) for i in range(h) for j in range(width(I)))  # Get indices for the top half
  O = I
  for obj in objs:
    if color(obj) == ONE and len(intersection(toindices(obj), top_half_indices)) > 0:
      O = paint(replace(O, ONE, THREE), obj) # Replace '1' with '3' in the object if it intersects the top half
  return O
 
104.66666666666667, 19.043276, def hadjebdfcaadefigbaebebebedebcaad(I):
  O = canvas(ZERO, shape(I)) # Create a canvas of '0's with the same shape as the input
  h = height(I) // 2  # Calculate the height of the top half
  for i in range(h):
    for j in range(width(I)):
      if I[i][j] == ONE:
        O = paint(O, {(THREE, (i, j))})  # Paint '3' at the corresponding location in the canvas if it was '1' in the top half
      else:
        O = paint(O, {(I[i][j], (i, j))})  # Otherwise, copy the original value from the input
  O = vconcat(O, bottomhalf(I)) # Concatenate the modified top half with the original bottom half
  return O
 
40.0, 3.2253265, def fdbfbcjbhaeeebgcjbdfecfcdegddidc(I):
  h = height(I) // 2 # Calculate the height of the top half
  top_half = crop(I, (0, 0), (h, width(I))) # Crop the top half
  bottom_half = bottomhalf(I) # Extract the bottom half
  modified_top = replace(top_half, ONE, THREE) # Replace '1's with '3's in the top half
  return vconcat(modified_top, bottom_half) # Vertically concatenate the modified top half and the original bottom half
 
14.666666666666666, 2.2910469, def biacdehfeccdedfbafcheehjdeafagba(grid):
  """
  Recolors connected '1's to '3' except for the component 
  containing the top-leftmost '1' using a flood fill approach.
  """
  h, w = len(grid), len(grid[0])
  start = next((i, j) for i in range(h) for j in range(w) if grid[i][j] == 1)

  def flood_fill(grid, loc, target, replacement):
    """
    Recursive flood fill helper function.
    """
    i, j = loc
    if 0 <= i < h and 0 <= j < w and grid[i][j] == target:
      grid = fill(grid, replacement, {(i, j)})
      for n in dneighbors((i, j)):
        grid = flood_fill(grid, n, target, replacement)
    return grid

  grid = flood_fill(grid, start, 1, 2)  # Mark the initial component
  grid = replace(grid, 1, 3)         # Recolor the rest
  grid = replace(grid, 2, 1)         # Restore the initial component
  return grid
 
166.66666666666666, 5.7635236, def bafaibggidiaeeaaibbacabfgdebegij(I):
  """
  Recolors connected '1's to '3' except for the component 
  containing the top-leftmost '1' using object detection.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_color = color(first(colorfilter(objs, 1)))
  return paint(I, recolor(3, merge(sfilter(objs, lambda obj: color(obj) != target_color))))
 
16.0, 2.5634446, def jiaffdiefbbiegbcjaidhiaefiabcbic(I):
  """
  Recolors connected '1's to '3' except for the component 
  containing the top-leftmost '1' using optimized set operations.
  """
  ones = ofcolor(I, 1)  # Find all indices of '1'
  h, w = len(I), len(I[0])

  def get_connected_component(loc):
    """
    Finds the connected component of a given location.
    """
    visited = set()
    stack = [loc]
    while stack:
      i, j = stack.pop()
      if (i, j) not in visited and 0 <= i < h and 0 <= j < w and I[i][j] == 1:
        visited.add((i, j))
        for n in dneighbors((i, j)):
          stack.append(n)
    return visited

  start = next(iter(ones)) # Get any '1' to start
  main_component = get_connected_component(start)
  other_ones = ones - main_component 

  return paint(I, recolor(3, other_ones)) 
 
6.0, 2.3242245, def dcgjbehbhhacegcebidiefafbdefdjjb(I):
  """
  Finds the highest object containing '1', then recolors all other objects to '3'.
  """
  highest_one_obj = argmax(objects(I, True, False, True), lambda obj: uppermost(obj) if 1 in {v for v, _ in obj} else -1)
  other_objects = difference(objects(I, True, False, True), {highest_one_obj})
  O = paint(I, recolor(3, merge(other_objects)))
  return O 
 
5.666666666666667, 2.2293549, def fchcfededjiaecfdjbacbhfafhhffhfe(I):
  """
  Finds the highest row containing '1' and recolors all objects above that row.
  """
  highest_one_row = max({uppermost(obj) for obj in objects(I, True, False, True) if 1 in {v for v, _ in obj}})
  objects_to_recolor = sfilter(objects(I, True, False, True), lambda obj: uppermost(obj) < highest_one_row)
  O = paint(I, recolor(3, merge(objects_to_recolor)))
  return O
 
56.0, 10.743334, def fgdhbeidjbfcedjiidebcadhbbhdaaba(I):
  """
  Creates a mask of cells belonging to the highest object with '1' or above it, then recolors all cells not in the mask.
  """
  highest_one_obj = argmax(objects(I, True, False, True), lambda obj: uppermost(obj) if 1 in {v for v, _ in obj} else -1)
  mask = {(i, j) for i in range(uppermost(highest_one_obj) + 1) for j in range(len(I[0]))}
  indices_to_recolor = asindices(I) - mask
  O = fill(I, 3, indices_to_recolor)
  return O
 
10.333333333333334, 2.962654, def gdfjcaaabeaceibejbhcehjcdbacccic(I):
  return replace(I, ONE, THREE)
 
20.666666666666668, 3.1423426, def jdiiafeffjaaeajfadebajifbbfdidhf(I):
  """Iteratively recolors connected '1's to '3'."""
  output = I
  ones = ofcolor(I, 1) 
  for loc in ones:
    if size(sfilter(objects(crop(output, subtract(loc, (1, 1)), (3, 3)), univalued=True, diagonal=False, without_bg=False), lambda obj: color(obj) == 1 and contained(loc, toindices(obj)))) > 1:
      output = paint(output, recolor(3, {(3, loc)}))
  return output
 
166.66666666666666, 5.7635236, def dfachifjdaagegebjceffaahgfaihhad(I):
  """
  Iterates through the grid, recoloring cells based on object membership.
  """
  objs = objects(I, True, False, True)
  O = canvas(3, shape(I)) 
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if any(1 in {val for val, _ in obj} and (i, j) in toindices(obj) for obj in objs):
        O = paint(O, {(v, (i, j))})
  return O
 
28.666666666666668, 8.525168, def adefecjcfbbbebbijajadddbgcebcebf(I):
  O = I
  for i, row in enumerate(I):
    if i >= height(I) // 2:  # Bottom half
      O = fill(O, THREE, ofcolor(crop(I, (i, 0), (1, width(I))), ONE))
  return O
 
156.33333333333334, 56.24541, def cajcdeefdjdjedjcbiejaeabffbdaeac(I):
  """Recolors connected '1's to '3's."""
  return paint(I, recolor(3, merge(objects(I, True, False, False))))
 
13.0, 2.8056462, def dddadadeaahbedhfjjdbbcdfecafcfbc(I):
  """
  Iterates through objects, recoloring those containing '1' to '3',
  unless they occupy the same minimum row and column as the bottom-leftmost '1'.
  """
  min_row, min_col = float('inf'), float('inf')
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        min_row, min_col = min(min_row, i), min(min_col, j)
  return paint(canvas(0, shape(I)),
              merge(frozenset(recolor(3, obj) if 1 in palette(obj) and not (uppermost(obj) == min_row and leftmost(obj) == min_col) else obj
                              for obj in objects(I, True, False, False))))
 
22.0, 3.821666, def beihfejcaadbebffjjbaddfeeccbbeab(I):
  """
  Iterates through rows and recolors objects to '3' until a '1' is encountered.
  """
  O = I
  for i in range(len(I)):
    if any(1 in {v for v, _ in obj} for obj in objects(crop(O, (i, 0), (1, len(I[0]))), True, False, True)):
      break
    O = paint(O, recolor(3, merge(objects(crop(O, (i, 0), (1, len(I[0]))), True, False, True))))
  return O
 
28.666666666666668, 8.706909, def fijjcdeghcehegfhaaahiechjiccegaf(I):
  """
  Finds the highest row with '1', then recolors objects row by row from top to that row. 
  """
  highest_one_row = max({uppermost(obj) for obj in objects(I, True, False, True) if 1 in {v for v, _ in obj}})
  O = I
  for i in range(highest_one_row):
    O = paint(O, recolor(3, merge(objects(crop(O, (i, 0), (1, len(I[0]))), True, False, True))))
  return O
 
25.0, 2.7498524, def gedfdacjeeideaibbhgegfddiaidifec(I):
  """
  Creates a mask based on the highest '1'-containing object and applies it for recoloring.
  """
  highest_one_obj = argmax(objects(I, True, False, True), lambda obj: uppermost(obj) if 1 in {v for v, _ in obj} else -1)
  mask = paint(canvas(0, shape(I)), recolor(1, backdrop(highest_one_obj)))
  O = paint(I, recolor(3, merge(objects(cellwise(I, mask, 0), True, False, True)))) 
  return O
 
27.333333333333332, 9.077744, def ccjbfbbjccbjeeeaiidieceefabedaee(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  lines = sfilter(objs, lambda obj: hline(obj) or vline(obj))
  return paint(I, recolor(3, merge(lines)))
 
10.666666666666666, 3.214765, def aececjeadfgfefjjbcchhbeeegffbffe(I):
  """
  Recolors '1' objects to '3' except the bottom-leftmost one using loops.
  """
  h, w = len(I), len(I[0])
  out = [[0 for _ in range(w)] for _ in range(h)]
  bl_found = False
  for i in range(h-1, -1, -1):
    for j in range(w):
      if I[i][j] == 1:
        if not bl_found:
          bl_found = True
        else:
          out[i][j] = 3
      else:
        out[i][j] = I[i][j]
  return tuple(tuple(row) for row in out)
 
21.0, 3.0876656, def ffbhibgccbjaeeehahbeiabejaaceifc(I):
  """
  Utilizes a single set comprehension to identify and recolor objects.
  """
  highest_one_row = max({uppermost(obj) for obj in objects(I, True, False, True) if 1 in {v for v, _ in obj}})
  O = paint(I, recolor(3, merge({obj for obj in objects(I, True, False, True) if uppermost(obj) < highest_one_row and 1 not in {index(I, loc) for loc in  dneighbors(center(obj))}})))
  return O
 
165.33333333333334, 6.2548685, def bhffcadiacceedjdbhaaidaageicbcid(I):
  """
  Leverages 'flood fill' logic to mark connected objects for recoloring.
  """
  highest_one_obj = argmax(objects(I, True, False, True), lambda obj: uppermost(obj) if 1 in {v for v, _ in obj} else -1)
  highest_one_row = uppermost(highest_one_obj)
  recolor_indices = set()
  def flood_fill(i, j):
    if (i, j) in recolor_indices or i < 0 or i >= len(I) or j < 0 or j >= len(I[0]) or I[i][j] == 1 or (i, j) in toindices(highest_one_obj):
      return
    recolor_indices.add((i, j))
    flood_fill(i+1, j)
    flood_fill(i-1, j)
    flood_fill(i, j+1)
    flood_fill(i, j-1)
  for i in range(highest_one_row):
    for j in range(len(I[0])):
      if (i, j) not in toindices(highest_one_obj) and I[i][j] != 1:
        flood_fill(i, j)
  O = paint(I, recolor(3, {(I[i][j], (i, j)) for i, j in recolor_indices}))
  return O
 
20.666666666666668, 3.1423428, def ehababeieffaeeaiaecbaacajejeijcd(grid):
  objs = objects(grid, True, False, True) 
  target_color = 3
  for obj in objs:
    if color(obj) == target_color:
      grid = paint(cover(grid, obj), recolor(1, obj))
  return grid
 
13.0, 9.669147, def gaihdbbaejcfeebhbjggbaccbdbiedgc(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_indices = frozenset()
  for obj in objs:
    if color(obj) == 3:
      bottom_row = max(i for i, j in toindices(obj))
      target_indices |= frozenset((bottom_row, j) for i, j in toindices(obj) if i == bottom_row)
  return fill(I, 1, target_indices)
 
11.333333333333334, 7.0735407, def bbdcdaeeciaceahjjiffjgghgeieedbd(I):
  return tuple(
      tuple(
          1 if cell == 3 and all(I[i + 1][j] != 3 for i in range(k, len(I) - 1)) else cell
          for j, cell in enumerate(row)
      )
      for k, row in enumerate(I)
  )
 
15.333333333333334, 6.7899685, def gjeahebeaiceeigfaadgffddejbadecd(I):
  h, w = len(I), len(I[0])
  new_grid = list(list(row) for row in I)
  for j in range(w):
    for i in range(h - 1, -1, -1):
      if I[i][j] == 3 and (i == h - 1 or I[i + 1][j] != 3):
        new_grid[i][j] = 1
  return tuple(tuple(row) for row in new_grid) 
 
20.666666666666668, 3.1423428, def fdbbbbaagfadeecebdgbgbfeabddefcb(I):
  return tuple(
      tuple(
          1 if cell == 3 and all(grid[k][j] != 3 for grid in (I,)[i + 1:] for k in range(i + 1, len(I))) else cell
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
20.666666666666668, 3.1423428, def bdafgffcgaideifgbdjbejbgffibafhb(I):
  """Replaces objects of 3s with 1s."""
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  target_objs = colorfilter(objs, 3) 
  replaced_grid = I
  for obj in target_objs:
    replaced_grid = paint(cover(replaced_grid, obj), recolor(1, obj))
  return replaced_grid 
 
7.666666666666667, 1.7480977, def hedfcdgdfcbdeeaejbiaghaedgcccfed(I):
  """Leverages object properties for replacement."""
  objs = objects(I, True, False, False)
  target_obj = extract(objs, lambda obj: color(obj) == 3)
  return paint(cover(I, target_obj), recolor(1, target_obj)) 
 
6.0, 2.3242242, def cbccfibfdaedejcgadehadijhdfajaii(I):
  obj = last(sorted(objects(I, T, F, T), key=lambda obj: ulcorner(obj)[0] * 100 + ulcorner(obj)[1]))
  new_obj = recolor(1, obj)
  O = paint(cover(I, obj), new_obj) 
  return O
 
10.0, 2.3369596, def ajhcbchabfhdegabjbafededbajbdaef(I):
  objs = objects(I, True, False, True)
  target_obj = argmax(objs, lambda obj: lrcorner(obj)[0] + lrcorner(obj)[1])
  target_indices = toindices(target_obj)
  O = fill(I, 1, target_indices)
  return O 
 
12.333333333333334, 1.9570094, def hdfjeedadjfcehacaijbgfbagbebffbg(I):
  filtered_objs = sfilter(objects(I, T, F, T), lambda obj: bordering(obj, I))
  sorted_objs = sorted(filtered_objs, key=size)
  target_obj = last(sorted_objs) if len(sorted_objs) > 0 else None
  O = paint(I, recolor(1, target_obj)) if target_obj is not None else I
  return O
 
23.0, 5.071282, def cejdbbhbedhjeeeaabbfdbjeebfededd(I):
  return tuple(
    tuple(
      1 if I[i][j] == 3 and sum(I[i][k] == 3 for k in range(max(0, j-2), min(len(I[0]), j+3))) >= 3 
      else I[i][j] 
      for j in range(len(I[0]))
    ) 
    for i in range(len(I))
  )
 
12.333333333333334, 1.9570094, def fbffefcacaegehdbbdbfcchbicbdcfdh(grid):
  def bottom_border_touch(obj):
    return lowermost(obj) == len(grid) - 1
  def recolor_3_to_1(obj):
    return recolor(1, obj) if color(obj) == 3 else obj
  return paint(grid, merge(apply(recolor_3_to_1, sfilter(objects(grid, T, F, F), bottom_border_touch))))
 
19.0, 2.685305, def hfcegjdaccabeadfiacicghbhfeceaga(I):
  return vconcat(
    tuple(
      tuple(
        1 if cell == 3 and any(I[k+a][j] != 3 for a in range(1, len(I)-k)) else cell
        for j, cell in enumerate(row)
      )
      for k, row in enumerate(I[:-1])
    ),
    I[-1:]
  )
 
15.333333333333334, 5.6787233, def adcccghabifbejafbcgfbdceidcfabdc(I):
  def helper(row, prev_row):
    return tuple(
      1 if cell == 3 and (prev_row is None or prev_row[j] != 3) else cell
      for j, cell in enumerate(row)
    )
  
  new_rows = []
  for i, row in enumerate(I):
    if i == 0:
      new_rows.append(helper(row, None)) # Handle first row
    else:
      new_rows.append(helper(row, I[i-1]))
  return tuple(new_rows)
 
28.0, 13.532984, def cfdhbjhdhcddebcjbifideijfjcaehfi(I):
  """Replaces digits within bounding boxes of objects."""
  target_objs = objects(I, True, False, False)
  for obj in target_objs:
    if color(obj) == 3:
      I = fill(I, 1, backdrop(toindices(obj)))
  return I
 
15.0, 1.8925936, def efcejbdafiecebeeicfjbgafgbeejcda(I):
  objs = sorted(objects(I, T, F, T), key=size, reverse=True)
  second_largest_obj = objs[1] if len(objs) > 1 else None
  O = paint(I, recolor(1, second_largest_obj)) if second_largest_obj is not None else I
  return O
 
19.333333333333332, 16.473995, def chebdbchdcheefdhaeheifedeijciidb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  filtered_objs = colorfilter(objs, 3)
  shifted_objs = frozenset({shift(obj, (1, 0)) for obj in filtered_objs})
  recolored_objs = frozenset({recolor(1, intersection(obj, shift(obj, (1, 0)))) for obj in shifted_objs})
  return paint(I, merge(recolored_objs))
 
10.0, 3.6204686, def idacdbchbhibedibadefjiecfddefcde(I):
  objs = fgpartition(I)
  target_obj = extract(objs, lambda obj: color(obj) == 3)
  bottom_row = sfilter(target_obj, lambda cell: cell[1][0] == lowermost(target_obj))
  recolored_row = recolor(1, bottom_row)
  return paint(I, combine(recolored_row, difference(target_obj, bottom_row))) 
 
13.0, 9.669147, def edhbafeiifbbeidgiiighfcbeeafjdfe(I):
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    if color(obj) == 3:
      bottom_indices = sfilter(toindices(obj), lambda idx: idx[0] == lowermost(obj))
      I = fill(I, 1, bottom_indices)
  return I
 
15.333333333333334, 6.7899685, def ddicjecfbgfcebdcjdbdcdejfagdbijf(I):
  target_color = 3
  replacement_color = 1
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == target_color and (i == len(I) - 1 or I[i + 1][j] != target_color):
        I = fill(I, replacement_color, {(i, j)})
  return I
 
15.0, 1.8385041, def cfeiadbeeabfeejhiaggiadcccjaghff(I):
  objs = order(objects(I, T, F, T), compfunc=size)
  second_largest_obj = objs[-2] if len(objs) > 1 else None
  O = paint(I, recolor(1, second_largest_obj)) if second_largest_obj is not None else I
  return O 
 
9.0, 2.7972312, def ffbeaahbceieehfcbdhcebfhfedfifga(I):
  objs = objects(I, T, F, T)
  if len(objs) <= 1:
    return I 
  sorted_objs = order(objs, compfunc=size)
  second_largest_obj = first(filter(lambda obj: obj != sorted_objs[-1], sorted_objs))
  O = paint(I, recolor(1, second_largest_obj))
  return O
 
25.666666666666668, 2.5063117, def cdjefjddgeaeedbbbadeibeefccgjgec(I):
  return paint(I, mapply(lambda obj: recolor(1, obj) if color(obj) == 3 and width(obj) >= 3 else obj, objects(I, univalued=True, diagonal=False, without_bg=False)))
 
5.333333333333333, 1.4371308, def adejagacachjefabjbiaafcefafacdca(I):
  """Replaces smaller objects of a specific color with another color."""
  objs = objects(I, True, False, False) # Extract objects from the grid
  small_objs = sfilter(objs, lambda obj: size(obj) <= 4) # Filter objects by size
  target_objs = sfilter(small_objs, lambda obj: color(obj) == 3) # Filter by color
  return paint(cover(I, merge(target_objs)), recolor(1, merge(target_objs)))  # Replace with '1'
 
15.333333333333334, 2.214591, def behjcjfaeadfeagaiabddgeddccffgfc(I):
  objs = objects(I, T, F, T)
  objs_sizes = apply(size, objs)
  second_largest_size = last(order(dedupe(totuple(objs_sizes)), compfunc=identity)) 
  second_largest_obj = extract(objs, matcher(size, second_largest_size))
  O = paint(I, recolor(1, second_largest_obj)) if second_largest_obj is not None else I
  return O
 
13.666666666666666, 1.6011313, def bddcabeiihicedcbidcebfijchbabcbg(I):
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 3 and i > 5:
        I = fill(I, 1, {(i, j)})
  return I
 
10.0, 3.6204686, def bfdeadjcjhhbedbibdieadbgbhcdddaf(I):
  return tuple(
      tuple(
          1 if cell == 3 and k == lowermost(ofcolor(I, 3)) else cell
          for j, cell in enumerate(row)
      )
      for k, row in enumerate(I)
  )
 
9.333333333333334, 1.5512732, def bhebcfddciedecjgiccbejdcffieabia(I):
  obj = argmax(objects(I, T, F, T), lambda obj: lrcorner(obj)[0] * 100 + lrcorner(obj)[1])
  new_obj = recolor(1, obj)
  O = paint(cover(I, obj), new_obj)
  return O
 
5.666666666666667, 2.2293546, def icaifdbehfbeeecbjdghdifajfbbihac(grid):
  target_color = 3
  replacement_color = 1
  objs = objects(grid, True, False, False)
  threshold_row = valmax(
      {uppermost(obj) for obj in objs if color(obj) == target_color}, 
      lambda x: x
  )
  new_objs = ({recolor(replacement_color, obj) if uppermost(obj) >= threshold_row else obj for obj in objs if color(obj) == target_color}
             | {obj for obj in objs if color(obj) != target_color})
  return paint(grid, merge(new_objs))
 
19.666666666666668, 6.0905414, def bffjddfeghfdefcgihbfgbehahcgebgb(I):
  return tuple(
      tuple(
          1 if cell == 3 and any(I[k][j] == 3 for k in range(i + 1, len(I))) else cell
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(I)
  )
 
25.333333333333332, 2.6761777, def efacjfbhbdbjefbfjegdjebeggffbhce(grid):
  target_color = 3
  replacement_color = 1
  objs = objects(grid, True, False, False)
  threshold_row = valmax(
      {uppermost(obj) for obj in objs if color(obj) == target_color}, 
      lambda x: x
  )
  new_objs = ({recolor(replacement_color, obj) if uppermost(obj) < threshold_row else obj for obj in objs if color(obj) == target_color}
             | {obj for obj in objs if color(obj) != target_color})
  return paint(grid, merge(new_objs))
 
19.333333333333332, 2.871529, def fdbeaffhbfcaebdebdejeggdcbbaaacf(I):
    return tuple(
        tuple(
            1 if any(I[k + 1][l] != 3 for l in range(max(0, j - 1), min(j + 2, len(I[0])))) and cell == 3 else cell
            for j, cell in enumerate(row)
        ) for k, row in enumerate(I[:-1])
    ) + (I[-1],)
 
10.333333333333334, 10.889364, def ffjaefhfffbbehafbfbfbbeafffaiccg(I):
  """
  Identifies objects, filters by color and size, and recolors them.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=True) 
  filtered_objs = sfilter(objs, lambda obj: color(obj) == 3 and width(obj) >= 3)
  recolored_objs = mfilter(filtered_objs, lambda obj: recolor(1, obj))
  return paint(canvas(mostcolor(I), shape(I)), recolored_objs)
 
23.666666666666668, 2.6685371, def eeceffaehbefecddjcaffibdefbdiifj(I):
  """
  Iterates through the grid, recoloring cells based on neighborhood.
  """
  h, w = len(I), len(I[0])
  return tuple(
    tuple(
      1 if I[i][j] == 3 and sum(1 for di in range(-1, 2) for dj in range(-2, 3) if 0 <= i+di < h and 0 <= j+dj < w and I[i+di][j+dj] == 3) >= 3 else I[i][j] 
      for j in range(w)
    )
    for i in range(h)
  )
 
20.333333333333332, 6.4207892, def bdfijdcgcdiiedbcjjfebajicebfbfed(I):
  """
  Employs a sliding window approach to identify and recolor.
  """
  h, w = len(I), len(I[0])
  for i in range(h):
    for j in range(w - 2):
      if I[i][j:j+3].count(3) >= 3:
        I = fill(I, 1, {(i, k) for k in range(j, j+3)})
  return I
 
