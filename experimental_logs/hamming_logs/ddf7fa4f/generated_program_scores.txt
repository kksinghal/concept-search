0.91, 71.32332, def dffaadhiacadeccijdagafhdfihjegib(I):
  objs = objects(I, T, F, F) 
  target_objs = sizefilter(objs, 1)
  for target_obj in target_objs:
    target_color = color(target_obj)
    I = paint(I, recolor(target_color, mfilter(objs, lambda obj: color(obj) != target_color)))
  O = I
  return O
 
0.8966666666666666, 74.790375, def cgjhgcfdhfjcebdciaahfchbefbdgdaf(I):
  objs = objects(I, T, F, F)
  min_size = valmin(objs, size)
  for obj in objs:
    if size(obj) == min_size:
      target_color = color(obj)
      O = paint(I, recolor(target_color, mfilter(objs, lambda o: color(o) != target_color)))
      return O
 
0.30666666666666664, 6.75478, def jjafaifdcdbbeddgiecfegedeedjfgee(I):
    p = palette(I)
    s = sizefilter(objects(I,T,F,F), 1)
    for v in p:
        if len(colorfilter(s, v)) > 0:
            c = v
    O = replace(I, mostcommon(I), c)
    return O
 
0.42333333333333334, 30.098566, def jjcdbbaacjccegeajchacbcbfbeddbcd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  obj1 = first(objs)
  obj2 = other(objs, obj1)
  v1 = color(obj1)
  v2 = color(obj2)
  p = position(obj1, obj2)
  shifted_obj1 = shift(obj1, multiply(p, shape(obj2)))
  shifted_obj2 = shift(obj2, multiply(invert(p), shape(obj1)))
  O = paint(paint(canvas(0, shape(I)), recolor(v2, shifted_obj1)), recolor(v1, shifted_obj2))
  return O
 
0.41, 24.52021, def iegceafeadadeadgbfdcafdfhjdecghh(I):
  objs = objects(I, True, False, True)
  a = first(objs)
  b = other(objs, a)
  va = color(a)
  vb = color(b)
  sa = shape(a)
  sb = shape(b)
  O = paint(paint(canvas(0, shape(I)), recolor(vb, shift(a, position(a, b)))), recolor(va, shift(b, invert(position(a, b)))))
  return O
 
0.21, 4.658983, def jcfgcbabifeiegfjadebjfcecebdcfeb(I):
  target_color = extract(I[0], lambda v: v != 0) 
  O = switch(I, FIVE, target_color)
  return O
 
0.20333333333333334, 5.7357793, def habfcgiabcccehadaaibcbbbeeejhfib(I):
  top_row_objects = objects(I[:1], False, False, True)
  target_color = color(first(top_row_objects))
  O = switch(I, FIVE, target_color)
  return O
 
0.30666666666666664, 6.75478, def feffabcecdiaeefdibeehedibfeidjec(I):
    for v in I[0]:
        if v != 0:
            target_color = v
            break
    obj_5 = recolor(FIVE, ofcolor(I, FIVE))
    obj_target = recolor(target_color, ofcolor(I, target_color))
    O = paint(paint(cover(I, obj_5), obj_target), obj_5)
    return O
 
0.31666666666666665, 6.9532166, def agacddffahifeeffiefhbcbfbdjbidhc(I):
    # Identify objects and their sizes
    objs = objects(I, T, F, T)
    largest_obj = argmax(objs, size)
    smallest_obj = argmin(objs, size)
    
    # Extract colors of largest and smallest objects
    largest_color = color(largest_obj)
    smallest_color = color(smallest_obj)

    # Swap the colors
    O = replace(I, largest_color, smallest_color)
    O = replace(O, smallest_color, largest_color)
    
    return O
 
1.0, 6.954697, def ibcbceadecfiedffjbgieajbcefecgba(I):
    # Identify objects, background is not excluded 
    objs = objects(I, T, F, F) 

    # Find the largest and smallest objects
    largest_obj = argmax(objs, size)
    smallest_obj = argmin(objs, size)

    # Create new objects with swapped colors
    new_largest = recolor(color(smallest_obj), largest_obj)
    new_smallest = recolor(color(largest_obj), smallest_obj)

    # Paint the new objects onto a blank canvas
    O = paint(canvas(mostcolor(I), shape(I)), new_largest)
    O = paint(O, new_smallest)

    return O
 
0.22333333333333336, 5.5144873, def ebfabdedeafjehccjeieaheedgafgcba(I):
    # Directly swap colors without explicitly identifying objects
    largest_color = color(argmax(objects(I, T, F, T), size))
    smallest_color = color(argmin(objects(I, T, F, T), size))
    O = switch(I, largest_color, smallest_color)
    return O
 
0.31666666666666665, 3.9786696, def dafbedgiaicfedjhbcjggadeecbacafe(I):
    # Find the largest and smallest objects
    objs = objects(I, T, F, T)
    largest_obj = argmax(objs, size)
    smallest_obj = argmin(objs, size)

    # Create a mask for areas to be modified
    mask = combine(toindices(largest_obj), toindices(smallest_obj))

    # Apply color swapping only within the mask
    O = I 
    for i, j in mask:
        if (I[i][j] == color(largest_obj)):
            O = fill(O, color(smallest_obj), {(i, j)})
        elif (I[i][j] == color(smallest_obj)):
            O = fill(O, color(largest_obj), {(i, j)})
    return O 
 
0.21, 5.0409718, def fjbdafajbahfedabbjcjbebdchbfecea(I):
    # Use a helper function to swap colors based on object size comparison
    def swap_if_different_size(obj1, obj2):
        if size(obj1) != size(obj2):
            return recolor(color(obj2), obj1), recolor(color(obj1), obj2)
        else: 
            return obj1, obj2
    
    # Find all object pairs 
    objs = objects(I, T, F, T)
    obj_pairs = [(obj1, obj2) for obj1 in objs for obj2 in objs if obj1 != obj2]

    # Apply color swapping to each object pair
    O = I
    for pair in obj_pairs:
        new_obj1, new_obj2 = swap_if_different_size(pair[0], pair[1])
        O = paint(O, new_obj1)
        O = paint(O, new_obj2)

    return O
 
0.9899999999999999, 9.046486, def dbjgcbdcecabebebbeiedjcfajhdfcjd(I):
  for c in palette(I):
    obj = recolor(1, ofcolor(I, c))
    if size(obj) > 1:
      for d in palette(I):
        adj_obj = recolor(1, ofcolor(I, d))
        if size(adj_obj) == 1 and adjacent(obj, adj_obj):
          I = replace(I, c, d)
  return I
 
0.98, 6.365507, def gdfbafiidjdcejehahbcbdcadfdijfgd(I):
  # Find the two least common colors
  color_a = leastcolor(I)
  color_b = leastcommon(list(remove(color_a, palette(I))))

  # Swap colors using nested list comprehension
  O = tuple(
      tuple(
          color_b if v == color_a else color_a if v == color_b else v 
          for v in row
      )
      for row in I
  )
  return O
 
1.0, 5.7005606, def ejigjfhehefgebidbaajdaabadadbbhd(I):
  # Partition the grid into objects
  objs = partition(I)

  # Find the two least common objects
  color_a = leastcolor(I)
  color_b = leastcommon(list(remove(color_a, palette(I))))
  obj_a = extract(objs, lambda obj: color(obj) == color_a)
  obj_b = extract(objs, lambda obj: color(obj) == color_b)

  # Swap the object colors
  O = paint(
      paint(canvas(mostcolor(I), shape(I)), recolor(color_b, obj_a)),
      recolor(color_a, obj_b)
  )
  return O
 
0.33666666666666667, 27.593143, def aebhbdccaffdeecbigecibfhdaebeecg(I):
  objs = objects(I, True, False, True)
  a = first(objs)
  b = other(objs, a)
  ca = color(a)
  cb = color(b)
  O = paint(paint(canvas(0, shape(I)), recolor(cb, a)), recolor(ca, b))
  return O
 
0.24333333333333332, 3.4868922, def fbdfdecfcfaaehdfacejjafcabjjccib(I):
  objs = objects(I, True, False, True)
  source_obj = extract(objs, lambda obj: color(obj) == FIVE)
  target_color = next((v for r in I for v in r if v != 0 and v != FIVE), None)
  target_obj = extract(objs, lambda obj: color(obj) == target_color)
  O = paint(cover(I, source_obj), recolor(target_color, source_obj))
  O = paint(O, recolor(FIVE, target_obj))
  return O
 
0.9766666666666666, 6.598426, def biddbcfbaabeeibabadbjgbhghcfadbc(I):
  color_a = leastcolor(I)
  color_b = leastcommon(list(remove(color_a, palette(I))))
  color_c = leastcommon(list(remove(color_b, remove(color_a, palette(I)))))
  O = tuple(
      tuple(
          color_c if v == color_b else color_b if v == color_c else v 
          for v in row
      )
      for row in I
  )
  return O
 
0.32666666666666666, 6.8304343, def caacffijcecfecicidgighcefebfcjdf(I):
  palette_sorted = order(palette(I), lambda c: colorcount(I, c))
  color_b = palette_sorted[1] 
  color_c = palette_sorted[2]
  O = tuple(
      tuple(
          color_c if v == color_b else color_b if v == color_c else v 
          for v in row
      )
      for row in I
  )
  return O
 
0.32666666666666666, 6.7877235, def bddcjjfgfdhieddcjadjfedgefefiifc(I):
    objs = partition(I)
    objs_sorted = order(objs, size)
    obj_b = objs_sorted[1]
    obj_c = objs_sorted[2]
    O = paint(paint(cover(I, obj_b), recolor(color(obj_b), toindices(obj_c))), recolor(color(obj_c), toindices(obj_b)))
    return O
 
0.98, 6.121702, def dhddbggeeaaaeiahijihhcbbgfeceebg(I):
  color_a = leastcolor(I)
  filtered_grid = tuple(tuple(v if v != color_a else 0 for v in row) for row in I)
  color_b = leastcolor(filtered_grid)
  color_c = leastcommon(list(remove(color_b, palette(filtered_grid))))
  O = tuple(
      tuple(
          color_c if v == color_b else color_b if v == color_c else v 
          for v in row
      )
      for row in I
  )
  return O
 
0.24333333333333332, 3.4296896, def dicbffgbjgadefdijcgechbhbibfcdhe(I):
  objs = objects(I, True, False, True)
  source_obj = extract(objs, lambda obj: color(obj) == FIVE)
  target_color = extract(palette(I) - {ZERO, FIVE}, identity)
  target_obj = extract(objs, lambda obj: color(obj) == target_color)
  O = paint(cover(I, source_obj), recolor(target_color, source_obj))
  O = paint(O, recolor(FIVE, target_obj))
  return O
 
0.21333333333333335, 4.945614, def ffaeiccefgbbedhfjdafhfiehheacbej(I):
  source_color = FIVE
  target_color = extract(sfilter(palette(I), lambda c: c != ZERO and c != FIVE), identity)
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == source_color:
        O = paint(O, {(target_color, (i, j))})
      elif val == target_color:
        O = paint(O, {(source_color, (i, j))})
  return O
 
0.30666666666666664, 12.99026, def bfcgabjcheagebieiedafahejbaiacfb(I):
  objs = objects(I, T, F, T) 
  largest = argmax(objs, size)
  rest = remove(largest, objs)
  second_largest = argmax(rest, size)
  O = paint(
      paint(
          replace(I, color(largest), -1), 
          recolor(color(largest), second_largest)
      ),
      recolor(color(second_largest), largest)
  )
  return O
 
0.30666666666666664, 6.75478, def adbecgjecgigedhjjecfagdhccajedfe(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, lambda obj: len(obj))
  second_largest = argmax(difference(objs, {largest}), lambda obj: len(obj))
  l_color = color(largest)
  sl_color = color(second_largest)
  O = tuple(
      tuple(
          sl_color if v == l_color else (l_color if v == sl_color else v) 
          for v in r
      ) 
      for r in I
  )
  return O
 
0.30666666666666664, 27.931759, def ddbdbgbideiaeabajaafgcjeifadbaci(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, len)
  second_largest = argmax(remove(largest, objs), len)
  O = paint(
      replace(
          replace(I, color(largest), -1),
          color(second_largest), 
          color(largest)
      ), 
      recolor(color(second_largest), second_largest)
  )
  return O
 
0.34, 8.9532, def bieeeebhedcceaeabggffcaffgajecde(I):
  # Sort colors by frequency
  palette_sorted = order(palette(I), lambda c: colorcount(I, c))
  # Extract the second and third most frequent colors
  color_b = palette_sorted[1]
  color_c = palette_sorted[2]
  # Create objects based on the extracted colors
  obj_b = objects(replace(I, color_c, 0), True, False, True)
  obj_c = objects(replace(I, color_b, 0), True, False, True)
  # Find the displacement needed to swap the objects
  displacement = subtract(centerofmass(extract(obj_c, identity)), centerofmass(extract(obj_b, identity)))
  # Swap the objects by shifting them
  O = paint(paint(cover(I, extract(obj_b, identity)), shift(extract(obj_b, identity), displacement)), shift(extract(obj_c, identity), invert(displacement)))
  return O 
 
0.7033333333333333, 5.99313, def cgdecdehfdjbegcjbbdecbedefdffdbd(I):
  """
  Swaps the colors of two objects in the grid.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with swapped object colors.
  """
  o1 = first(partition(I))  # Get the first object
  o2 = other(partition(I), o1)  # Get the second object
  c1 = color(o1)
  c2 = color(o2)
  return switch(I, c1, c2)  # Switch the colors of the two objects
 
0.5199999999999999, 29.041319, def ecbbidagdjjieeedbaaaafjjgecfcjbc(I):
  """
  Swaps the colors of two objects in the grid using nested replace.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with swapped object colors.
  """
  o1 = first(partition(I))
  o2 = other(partition(I), o1)
  c1 = color(o1)
  c2 = color(o2)
  return replace(replace(I, c1, c2), c2, c1)  # Replace c1 with c2, then c2 with c1
 
0.7266666666666667, 7.839476, def ffcechgbefbdeahjjbbcebbcfdbhccbi(I):
  """
  Swaps the colors of two objects in the grid using paint and recolor.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with swapped object colors.
  """
  o1 = first(partition(I))
  o2 = other(partition(I), o1)
  c1 = color(o1)
  c2 = color(o2)
  return paint(paint(canvas(0, shape(I)), recolor(c2, o1)), recolor(c1, o2))
 
0.31, 5.2443695, def addejbdagdebegieafjjdhaeddbbgfcb(I):
  """
  Swaps the colors of two objects in the grid using objects and list comprehension.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with swapped object colors.
  """
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  o1 = first(objs)
  o2 = other(objs, o1)
  c1 = color(o1)
  c2 = color(o2)
  new_grid = [[c2 if (c, (i, j)) in o1 else c1 if (c, (i, j)) in o2 else c for j, c in enumerate(row)] for i, row in enumerate(I)]
  return tuple(tuple(row) for row in new_grid)
 
0.33666666666666667, 20.964262, def daeehajahbbgegehbdeaebheagicahff(I):
  # Identify objects excluding background
  objs = objects(I, T, F, T)

  # Find the two largest objects
  largest = argmax(objs, size)
  rest = remove(largest, objs)
  second_largest = argmax(rest, size)

  # Swap colors
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)), 
          recolor(color(largest), second_largest)
      ), 
      recolor(color(second_largest), largest)
  )
  return O
 
0.33666666666666667, 31.918068, def fdihfbfedabeejafaidjifgebadeigdf(I):
  # Find objects without background
  objs = objects(I, T, F, T)

  # Define a function to count occurrences of a specific color in the grid
  def count_color(obj):
    return colorcount(I, color(obj))

  # Sort objects based on color occurrence count
  sorted_objs = order(objs, count_color)[::-1]

  # Extract the two most frequent colored objects
  largest, second_largest = sorted_objs[0], sorted_objs[1]

  # Swap colors 
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(largest), second_largest)
      ),
      recolor(color(second_largest), largest)
  )
  return O
 
0.31666666666666665, 7.797231, def deeieddjdfdeedbabfbajfbefabjegac(I):
  smallest = argmin(objects(I, T, F, F), size)
  adjacent_singles = mfilter(objects(I, T, F, F), lambda x: adjacent(x, smallest) and size(x) == 1)
  new_color = color(first(adjacent_singles)) if adjacent_singles else mostcolor(I)
  return paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: recolor(new_color, obj) if obj == smallest else obj, objects(I, T, F, F))))
 
0.41, 24.353498, def cejagaecabdeejaiiaccdcfficchjchf(I):
  objs = list(objects(I, True, False, True))
  a, b = objs[0], objs[1]
  va, vb = color(a), color(b)
  O = paint(paint(canvas(0, shape(I)), recolor(vb, shift(a, position(a, b)))), recolor(va, shift(b, invert(position(a, b)))))
  return O 
 
0.4066666666666667, 33.397793, def defbfgaebabaegacafccdfdifedbeabf(I):
  objs = objects(I, True, False, True)
  a = argmin(objs, size)
  b = argmax(objs, size)
  va, vb = color(a), color(b)
  O = paint(paint(canvas(0, shape(I)), recolor(vb, shift(a, position(a, b)))), recolor(va, shift(b, invert(position(a, b)))))
  return O
 
0.33666666666666667, 68.55184, def jaiffafaebbbeaieicaeaggcdbfbeecc(I):
  objs = objects(I, T, F, T)  # Get non-background objects

  def obj_size(obj):
    return len(obj)
  
  sorted_objs = order(objs, obj_size)  # Sort objects by size

  # Handle cases with less than three objects
  if len(sorted_objs) < 3:
    return I

  smallest = sorted_objs[0]
  third_smallest = sorted_objs[2]

  # Swap colors
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(smallest), third_smallest)
      ),
      recolor(color(third_smallest), smallest)
  )
  return O
 
0.2966666666666667, 44.959873, def jeggafehiaiaeeiaacbbeceihgfeheij(I):
  # Get all objects and their sizes
  objs = objects(I, T, F, T)
  obj_sizes = apply(size, objs)

  # Combine objects and sizes into a list of tuples
  obj_data = totuple(zip(objs, obj_sizes))

  # Sort objects based on their size
  sorted_obj_data = order(obj_data, lambda item: item[1])

  # Handle cases with less than three objects
  if len(sorted_obj_data) < 3:
    return I

  # Extract the smallest and third smallest objects
  smallest, _ = sorted_obj_data[0]
  third_smallest, _ = sorted_obj_data[2]

  # Swap the colors of the smallest and third smallest objects
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(smallest), third_smallest)
      ),
      recolor(color(third_smallest), smallest)
  )
  return O
 
0.33666666666666667, 69.58034, def ddaffhfaddbgebddbbjaaabedddgjgff(I):
  objs = objects(I, T, F, T)

  # Create a list to store object sizes
  obj_sizes = []

  # Iterate through each object
  for obj in objs:
    # Calculate object size and append to the list
    obj_sizes.append(size(obj))

  # Find indices of the smallest and third smallest objects
  smallest_idx = 0
  third_smallest_idx = 0
  for i in range(1, len(obj_sizes)):
    if obj_sizes[i] < obj_sizes[smallest_idx]:
      third_smallest_idx = smallest_idx
      smallest_idx = i
    elif obj_sizes[i] < obj_sizes[third_smallest_idx] or third_smallest_idx == smallest_idx:
      third_smallest_idx = i

  # Extract the objects using the indices
  smallest = totuple(objs)[smallest_idx]
  third_smallest = totuple(objs)[third_smallest_idx]

  # Swap colors 
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(smallest), third_smallest)
      ),
      recolor(color(third_smallest), smallest)
  )
  return O
 
0.9700000000000001, 7.056012, def eghhaajcedhieeeebdeddeeafiabdgbb(I):
    def transform_object(obj, all_objs):
        if size(obj) != 1: 
            adjacent_singles = sfilter(all_objs, lambda x: adjacent(x, obj) and size(x) == 1)
            new_color = color(first(adjacent_singles)) if adjacent_singles else mostcolor(I)
            return recolor(new_color, obj)
        return obj
    return paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: transform_object(obj, objects(I, T, F, F)), objects(I, T, F, F))))
 
0.33666666666666667, 75.47546, def fchgdaejaifjeeafjhefaddcdgajijfe(I):
  objs = objects(I, T, F, F)
  obj_data = tuple((color(obj), ulcorner(obj), obj) for obj in objs)
  sorted_data = order(obj_data, lambda x: (x[1][0], x[1][1]))
  new_objs = []
  for i, (v, (ti, tj), obj) in enumerate(sorted_data):
    if i == 0:
      new_objs.append(recolor(v, shift(obj, (height(I) - height(obj), 0))))
    elif i == 1:
      new_objs.append(recolor(v + 1, shift(obj, (-2, 0))))
    elif i == 2:
      new_objs.append(recolor(v, shift(obj, (-2, 0))))
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
0.34, 72.870125, def aefgjcdiidfiejdfigffdjbbhjihjica(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, lambda obj: (len(obj), -uppermost(obj), -leftmost(obj)))
  new_objs = []
  for i, obj in enumerate(sorted_objs):
    if i == 0:
      new_objs.append(recolor(color(obj), shift(obj, (height(I) - height(obj), 0))))
    elif i == 1:
      new_objs.append(recolor(color(obj) + 1, shift(obj, (-2, 0))))
    elif i == 2:
      new_objs.append(recolor(color(obj), shift(obj, (-2, 0))))
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
0.41333333333333333, 34.08097, def eadedbacaideeeifabaeeaahcaagagca(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, lambda obj: (-len(ofcolor(I, color(obj))), uppermost(obj), leftmost(obj)))
  new_objs = []
  for i, obj in enumerate(sorted_objs):
    if i == 0:
      new_objs.append(recolor(color(obj), shift(obj, (height(I) - height(obj), 0))))
    elif i == 1:
      new_objs.append(recolor(color(obj) + 1, shift(obj, (-2, 0))))
    elif i == 2:
      new_objs.append(recolor(color(obj), shift(obj, (-2, 0))))
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
0.45333333333333337, 32.336864, def adcfjdaafieeefehadbchdiddaieabcj(I):
  objs = objects(I, T, F, F)
  obj_data = [(color(obj), obj, i) for i, obj in enumerate(objs)]
  sorted_objs = order(obj_data, lambda x: (x[2]))
  new_objs = []
  for i, (v, obj, _) in enumerate(sorted_objs):
    if i == 0:
      new_objs.append(recolor(v, shift(obj, (height(I) - height(obj), 0))))
    elif i == 1:
      new_objs.append(recolor(v + 1, shift(obj, (-2, 0))))
    elif i == 2:
      new_objs.append(recolor(v, shift(obj, (-2, 0))))
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
0.3066666666666667, 6.715771, def aeadfbdddeddefcdbhcdjifddbefibff(I):
  """
  Swaps the colors of two objects and moves one object to the other's location.
  """
  objs = list(objects(I, True, False, True))
  a, b = objs[0], objs[1]
  va, vb = color(a), color(b)
  return paint(replace(I, va, vb), recolor(va, shift(b, position(a, b))))
 
0.33666666666666667, 26.578651, def agdbdeaaebedecfbabefffihehhjdhcc(I):
  """
  Uses a canvas to construct the output grid after swapping colors and moving an object.
  """
  objs = list(objects(I, True, False, True))
  a, b = objs[0], objs[1]
  ca, cb = color(a), color(b)
  return paint(paint(canvas(mostcolor(I), shape(I)), recolor(ca, toindices(b))), recolor(cb, toindices(a)))
 
0.31, 16.664154, def eeaajdhfddebeacbabbehahfaaaieahg(I):
  """
  Utilizes a lambda function to determine color swapping and object movement.
  """
  objs = list(objects(I, True, False, True))
  a, b = objs[0], objs[1]
  f = lambda x, y: (color(y), toindices(x)) if x == a else (color(x), toindices(y))
  return paint(replace(I, *f(a, b)), recolor(*f(b, a))) 
 
0.30333333333333334, 5.6142416, def egfegegeiecdeiecadcffgfjdfhhfaij(I):
    target_color = I[0][next((j for j, v in enumerate(I[0]) if v), 0)]
    source_colors = set(v for r in I for v in r if v not in {0, target_color})
    source_color = source_colors.pop() if source_colors else 0 
    grid_painted = list(list(row) for row in I)
    for i, r in enumerate(grid_painted):
        for j, v in enumerate(r):
            if v == target_color:
                grid_painted[i][j] = source_color
            elif v == source_color:
                grid_painted[i][j] = target_color
    return tuple(tuple(row) for row in grid_painted)
 
0.32666666666666666, 6.7097077, def baeehccafaeceaiijcjcfecbcddgdbfd(I):
  objs = objects(I, T, F, T)

  def obj_area(obj):
    return height(obj) * width(obj)

  smallest = argmin(objs, obj_area)
  third_smallest = argmin(difference(objs, {smallest, argmax(objs, obj_area)}), obj_area)

  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if contained((I[i][j], (i, j)), smallest):
        O = fill(O, color(third_smallest), {(i, j)})
      elif contained((I[i][j], (i, j)), third_smallest):
        O = fill(O, color(smallest), {(i, j)})
  return O
 
0.26333333333333336, 40.477596, def ccjacjjbbicgebiajgidedafcbgbcjha(I):
  objs = objects(I, T, F, T)

  def obj_size(obj):
    return len(toindices(obj))

  obj_sizes = apply(obj_size, objs)
  sorted_sizes = order(obj_sizes, identity)
  smallest_size = first(sorted_sizes)
  third_smallest_size = sorted_sizes[2]

  smallest = extract(objs, matcher(obj_size, smallest_size))
  third_smallest = extract(objs, matcher(obj_size, third_smallest_size))

  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(smallest), third_smallest)
      ),
      recolor(color(third_smallest), smallest)
  )
  return O
 
0.33666666666666667, 71.27818, def ahdabbbeigaceaajbdfhfagdedabggfa(I):
  objs = objects(I, T, F, F)
  objs_sorted = order(objs, lambda obj: len(obj))
  smallest = objs_sorted[0]
  second_smallest = objs_sorted[1]
  largest = objs_sorted[-1]
  shifted_second_smallest = shift(second_smallest, (-2 * height(second_smallest), 0))
  shifted_largest = shift(largest, (2 * height(largest), 0))
  recolored_smallest = recolor(color(second_smallest), smallest)
  O = paint(paint(paint(canvas(mostcolor(I), shape(I)), shifted_second_smallest), shifted_largest), recolored_smallest)
  return O
 
0.3866666666666667, 50.007374, def ccbcggcjjedceadbihcbagedbgfcejic(I):
  objs = objects(I, T, F, F)
  size_dict = {}
  for obj in objs:
    size_dict[len(obj)] = obj
  size_sorted = order(size_dict, identity)
  smallest_size = size_sorted[0]
  second_smallest_size = size_sorted[1]
  recolored = recolor(color(size_dict[second_smallest_size]), size_dict[smallest_size])
  shifted_up = shift(size_dict[second_smallest_size], (-2 * height(size_dict[second_smallest_size]), 0))
  shifted_down = shift(size_dict[size_sorted[-1]], (2 * height(size_dict[size_sorted[-1]]), 0))
  O = paint(paint(paint(canvas(mostcolor(I), shape(I)), recolored), shifted_up), shifted_down)
  return O
 
0.33666666666666667, 71.36087, def bdbcegfdcdebeacjjfbedhgjhcfbiihd(I):
  objs = objects(I, T, F, F)
  smallest = argmin(objs, len)
  largest = argmax(objs, len)
  remaining = difference(objs, frozenset({smallest, largest}))
  second_smallest = argmin(remaining, len)
  shifted_up = shift(second_smallest, (-2 * height(second_smallest), 0))
  shifted_down = shift(largest, (2 * height(largest), 0))
  recolored = recolor(color(second_smallest), smallest)
  O = paint(paint(paint(canvas(mostcolor(I), shape(I)), shifted_up), shifted_down), recolored)
  return O
 
0.29, 6.2389607, def bbecjbfjfgdbedefbcbgcfbcbiefdbda(I):
  """
  Swaps colors by iterating through all cells.
  """
  objs = list(objects(I, True, False, True))
  color1, color2 = color(objs[0]), color(objs[1])
  O = tuple(tuple(color2 if v == color1 else (color1 if v == color2 else v) for v in r) for r in I)
  return O
 
0.32666666666666666, 6.923973, def djffdbdaeedfehbejdgdjbdbaacdbfbd(I):
  target_color = next((v for r in I for v in r if v != 0), 0)  # Find first non-zero color (target)
  source_color = next((v for r in I for v in r if v not in {0, target_color}), 0) # Find a different non-zero color (source)
  O = switch(I, target_color, source_color) # Swap target and source colors
  return O 
 
0.32666666666666666, 6.7877235, def afjcfehdcicbedajadaahdeggbgijgif(I):
  target_color = color(first(objects(I[:1], False, False, True))) # Extract color from first object in top row
  source_color = next((v for v in palette(I) if v not in {0, target_color}), 0) # Find different non-zero color
  O = replace(replace(I, target_color, -1), source_color, target_color) # Two-step replacement
  O = replace(O, -1, source_color)  # Restore original source color
  return O
 
0.5299999999999999, 6.510381, def hdecaeigabdaedehbafcjffdecjaecdd(I):
  top_row_indices = frozenset((0, j) for j in range(len(I[0]))) # Get the indices of the top row
  target_color = index(I, first(top_row_indices)) # Get the color at the first index of the top row
  source_color = next((v for r in I for v in r if v not in {0, target_color}), 0) # Find different non-zero color
  O = switch(I, target_color, source_color) # Swap the target and source colors
  return O
 
0.31, 6.89612, def gieaaacjdfeceabciiafcjbdhiaejjhc(I):
  objs = totuple(objects(I, T, F, T))

  def obj_size(obj):
    return len(obj)

  obj_sizes = apply(obj_size, objs)
  sorted_indices = order(range(len(objs)), rbind(lambda i, j: obj_sizes[i] < obj_sizes[j], 0))
  smallest_idx = first(sorted_indices)
  third_smallest_idx = sorted_indices[2]

  smallest_color = color(objs[smallest_idx])
  third_smallest_color = color(objs[third_smallest_idx])

  O = replace(replace(I, smallest_color, third_smallest_color), third_smallest_color, smallest_color)
  return O
 
0.33666666666666667, 68.88952, def iebjfiadbffcecbfijhddbbfdfcebddi(I):
  objs = objects(I, T, F, T)

  def obj_size(obj):
    return size(obj)

  smallest = argmin(objs, obj_size)
  remaining = difference(objs, {smallest})
  third_smallest = argmin(remaining, obj_size)

  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          recolor(color(third_smallest), smallest),
      ),
      recolor(color(smallest), third_smallest),
  )
  return O
 
0.31666666666666665, 6.6909494, def bicegjcbabdjedadadciaeadefaiffbe(I):
  objs = totuple(objects(I, T, F, T))

  def obj_size_index(index):
    return len(objs[index])

  smallest_idx = argmin(range(len(objs)), obj_size_index)
  remaining_indices = list(range(len(objs)))
  remaining_indices.remove(smallest_idx)
  third_smallest_idx = argmin(remaining_indices, obj_size_index)

  smallest_color = color(objs[smallest_idx])
  third_smallest_color = color(objs[third_smallest_idx])

  O = replace(replace(I, smallest_color, third_smallest_color), third_smallest_color, smallest_color)
  return O
 
0.32666666666666666, 6.803167, def cibcaehbeadceddajhjdcejigcbhbbec(I):
  objs = objects(I, T, F, T)

  def obj_size(obj):
    return len(toindices(obj))

  smallest = argmin(objs, obj_size)
  objs_without_smallest = difference(objs, {smallest})
  third_smallest = argmin(objs_without_smallest, obj_size)

  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if any(contained((I[i][j], (i, j)), obj) for obj in [smallest, third_smallest]):
        target_color = color(third_smallest) if contained((I[i][j], (i, j)), smallest) else color(smallest)
        O = fill(O, target_color, {(i, j)})
  return O
 
0.33666666666666667, 10.806132, def fjefibbafdcaejccbbddfefcdccebfac(I):
  def process_object(obj, objs):
    if size(obj) == min(size(o) for o in objs):
      adjacent_objs = sfilter(objs, lambda x: adjacent(x, obj) and size(x) == 1)
      return recolor(color(first(adjacent_objs)) if adjacent_objs else mostcolor(I), obj)
    return obj
  return paint(canvas(mostcolor(I), shape(I)), merge(apply(lambda obj: process_object(obj, objects(I, T, F, F)), objects(I, T, F, F))))
 
0.30666666666666664, 3.3056047, def dagecebiabcbebbcjfehbdahgigbhchf(I):
  # Sort colors by frequency
  palette_sorted = order(palette(I), lambda c: colorcount(I, c))
  # Extract the second and third most frequent colors
  color_b = palette_sorted[1]
  color_c = palette_sorted[2]
  # Create objects based on the extracted colors
  obj_b = objects(replace(I, color_c, 0), True, False, True)
  obj_c = objects(replace(I, color_b, 0), True, False, True)
  # Swap the object colors directly
  O = paint(paint(cover(I, extract(obj_b, identity)), recolor(color_c, extract(obj_b, identity))), 
            recolor(color_b, extract(obj_c, identity)))
  return O
 
0.31666666666666665, 7.3192825, def edggjbbicceaechcieidhedgeehadaai(I):
  target_obj = next(iter(objects(I[:1], False, False, True))) # Isolate first object in top row
  target_indices = toindices(target_obj) # Extract indices of target object
  target_color = index(I, first(target_indices)) # Determine color of target object
  source_obj = next((obj for obj in objects(I, False, False, True) if color(obj) not in {0, target_color} and size(obj) > 1), 0) # Find a different non-zero color object that has more than one cell
  source_color = color(source_obj)
  O = fill(I, source_color, target_indices) # Replace target with source color
  return O
 
0.31666666666666665, 7.3193507, def bfbbaacafchdeaeijbefaijfabgjehfb(I):
  for target_color in palette(I[:1]): # Loop through colors in the top row
    if target_color != 0: 
      break  # Find the first non-zero color in the top row
  source_color = next((c for c in palette(I) if c not in {0, target_color} and colorcount(I, c) > 1), 0) # Find a different non-zero color that appears more than once
  O = replace(I, target_color, source_color)  # Replace the target color with the source color
  return O
 
0.31666666666666665, 7.318927, def adbhhbhbhgafegafaehdabfffaehbabi(I):
  target_color = next((v for v in I[0] if v != 0), 0) # Find the first non-zero color in the top row 
  source_color = next((v for r in I for v in r if v not in {0, target_color} and colorcount(I, v) > 1), 0) # Find a different non-zero color that appears more than once
  new_grid = tuple(tuple(source_color if c == target_color else c for c in row) for row in I) # Create a new grid with replaced colors
  return new_grid 
 
0.31333333333333335, 4.0293403, def gcfadfacbccdebcfjdfaeaajeggdcfdd(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  smallest_size = minimum(sizes)
  sizes = remove(smallest_size, sizes)
  second_smallest_size = minimum(sizes)
  O = I
  for obj in objs:
    if size(obj) == smallest_size:
      O = paint(O, recolor(second_smallest_size, obj))
    elif size(obj) == second_smallest_size:
      O = paint(O, recolor(smallest_size, obj))
  return O
 
0.21666666666666667, 6.0237846, def cgfbfeighchceefficfgebibgfaaciai(I):
    p = palette(I) # Get the set of unique colors
    objs = objects(I,T,F,F) # Extract objects from the grid
    for v in p:
        if colorcount(I, v) == 1: # If a color appears only once
            source_color = v 
        else:
            target_color = v # Other colors are considered target colors
    O = paint(I, recolor(source_color, mfilter(objs, lambda obj: color(obj) == target_color))) # Recolor target with the source color
    return O
 
0.9700000000000001, 6.453514, def gehibciibghieeiiijeecafjhebidebi(I):
  objs = objects(I, T, F, F)
  sizes = {size(obj): color(obj) for obj in objs} # Create dictionary: size -> color
  source_color = sizes[min(sizes)] # Source color from the object with the smallest size
  target_color = sizes[max(sizes)] # Target color from the object with the largest size
  O = paint(I, recolor(source_color, mfilter(objs, lambda obj: color(obj) == target_color))) # Recolor and paint
  return O 
 
0.9700000000000001, 7.0016704, def jiacbgfehcecedcbjccefadebihffiag(I):
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size) # Find the largest object
  target_color = color(target_obj) # Get the color of the largest object 
  source_color = color(argmin(objs, size)) # Get the color of the smallest object
  O = paint(I, recolor(source_color, mfilter(objs, lambda obj: color(obj) == target_color))) # Recolor and paint
  return O
 
1.0, 6.954697, def dbiceddejfdbedbdjjedbadfdfaccdbc(I):
  objs = objects(I, T, F, F)
  sizes = apply(size, objs)
  largest_obj = extract(objs, matcher(size, maximum(sizes)))
  smallest_obj = extract(objs, matcher(size, minimum(sizes)))
  rest_objs = difference(objs, combine(largest_obj, smallest_obj))
  second_largest_obj = argmax(rest_objs, size)
  O = paint(
      paint(
          paint(
              canvas(mostcolor(I), shape(I)), 
              largest_obj
          ), 
          recolor(color(smallest_obj), second_largest_obj)
      ),
      recolor(color(second_largest_obj), smallest_obj)
  )
  return O
 
0.2633333333333333, 3.6448894, def aahfdaiibabeeaifihfdbffibfceiedi(I):
  objs = objects(I, T, F, F)
  size_obj_pairs = order(
      apply(lambda obj: (size(obj), obj), objs), 
      lambda x: x[0]
  )
  largest_obj = size_obj_pairs[-1][1]
  second_largest_obj = size_obj_pairs[-2][1]
  smallest_obj = size_obj_pairs[0][1]
  O = I
  for obj in objs:
      if obj == largest_obj:
          O = paint(O, obj)
      elif obj == second_largest_obj:
          O = paint(O, recolor(color(smallest_obj), obj))
      elif obj == smallest_obj:
          O = paint(O, recolor(color(second_largest_obj), obj))
  return O
 
0.33666666666666667, 32.586086, def jacddehdbiafeafejhdbiidiibbebjeh(I):
  objs = order(objects(I, T, F, F), size)
  smallest_color = color(objs[0])
  second_largest_color = color(objs[-2])
  O = paint(
      paint(
          canvas(mostcolor(I), shape(I)),
          objs[-1]
      ),
      recolor(smallest_color, objs[-2])
  )
  return paint(O, recolor(second_largest_color, objs[0]))
 
0.7200000000000001, 11.804883, def cfbcceafjdddecfcidagccibjgiaedca(I):
  objs = objects(I, T, F, F)
  obj_sizes = dict(zip(objs, apply(size, objs)))
  largest_obj = max(obj_sizes, key=obj_sizes.get)
  smallest_obj = min(obj_sizes, key=obj_sizes.get)
  second_largest_obj = max(
      {k: v for k, v in obj_sizes.items() if k not in (largest_obj, smallest_obj)}.items(),
      key=lambda item: item[1]
  )[0]
  O = I
  for obj in objs:
      if obj == largest_obj:
          O = paint(O, obj)
      elif obj == second_largest_obj:
          O = paint(O, recolor(color(smallest_obj), obj))
      elif obj == smallest_obj:
          O = paint(O, recolor(color(second_largest_obj), obj))
  return O
 
0.32666666666666666, 6.7097077, def hcbcigabdbgbehfjjeachhfeacfiffcc(I):
  objs = objects(I, T, F, F)
  def recolor_helper(objs):
    if len(objs) < 3:
      return objs
    objs_sorted = order(objs, size)
    smallest, second, largest = objs_sorted[0], objs_sorted[1], objs_sorted[2]
    return combine(
        recolor_helper(difference(objs, {smallest, second, largest})), 
        {
            recolor(color(second), smallest), 
            recolor(color(smallest), second), 
            largest
        }
    )
  return paint(canvas(mostcolor(I), shape(I)), merge(recolor_helper(objs)))
 
0.30666666666666664, 22.666674, def gecjaidijbbceaheabiidgbddedaeaad(I):
  objs = objects(I, T, F, T)
  largest, second_largest = order(objs, size)[NEG_TWO:] # Get the two largest objects directly
  O = paint(
      replace(
          replace(I, color(largest), -1), # Similar logic as version 1, but with optimized object selection
          color(second_largest),
          color(largest)
      ),
      recolor(color(second_largest), second_largest)
  )
  return O
 
0.30666666666666664, 13.930675, def ccdgfjaajhebeagjjjhaeecafjcjhecc(I):
  objs = objects(I, T, F, T)
  largest = argmax(objs, lambda obj: colorcount(I, color(obj)))
  rest = remove(largest, objs)
  second_largest = argmax(rest, lambda obj: colorcount(I, color(obj)))
  return paint(paint(replace(I, color(largest), -1), recolor(color(largest), second_largest)), recolor(color(second_largest), largest))
 
0.7766666666666667, 63.223785, def dbdghfaccdajehcdbdbdbhaeffahdebe(I):
  p = palette(I) - {mostcommon(sum(I, ()))}
  a = mostcommon(sum((r for r in I if len(set(r))>1), ()))
  b = other({a, *p}, a)
  return replace(replace(I, a, -ONE), b, a)
 
0.2833333333333333, 3.9297059, def ibgiidaebcaeeifgjfiacbcefffdbeab(I):
  objs = objects(I, T, F, F)
  size_obj_pairs = order(
      apply(lambda obj: (size(obj), obj), objs), 
      lambda x: x[0]
  )
  smallest_color = color(size_obj_pairs[0][1])
  second_largest_color = color(size_obj_pairs[-2][1])
  O = I
  for obj in objs:
    if size(obj) == size(size_obj_pairs[-2][1]):
      O = paint(O, recolor(smallest_color, obj))
    elif size(obj) == size(size_obj_pairs[0][1]):
      O = paint(O, recolor(second_largest_color, obj))
  return O
 
0.33666666666666667, 4.5447907, def bcbhcehehbefejbeaghjbajfdifdfiee(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, lambda obj: size(obj))
  smallest_color = color(sorted_objs[0])
  second_largest_color = color(sorted_objs[-2])
  O = I
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      for obj in sorted_objs:
        if (i, j) in toindices(obj):
          if size(obj) == size(sorted_objs[-2]):
            O = paint(O, {(smallest_color, (i, j))})
          elif size(obj) == size(sorted_objs[0]):
            O = paint(O, {(second_largest_color, (i, j))})
          break 
  return O
 
0.31666666666666665, 3.9786696, def iagahcbefcieefgcjddfciifdaiaeacc(I):
  objs = objects(I, T, F, F)
  size_objs = [(size(obj), obj) for obj in objs]
  size_objs.sort(key=lambda x: x[0])
  smallest_color = color(size_objs[0][1])
  second_largest_color = color(size_objs[-2][1])
  O = paint(I, recolor(smallest_color, size_objs[-2][1]))
  O = paint(O, recolor(second_largest_color, size_objs[0][1]))
  return O
 
0.33666666666666667, 8.11757, def caicahigafgbeddhjfhdcfbbhddaabde(I):
  """
  Utilizes nested `paint` and `replace` functions for a concise solution.
  """
  objs = list(objects(I, True, False, True))
  a, b, *rest = objs  # Unpack objects
  va, vb, *vrest = tuple(color(obj) for obj in objs)  # Unpack colors
  O = I
  for i in range(len(objs)):
    O = replace(paint(O, recolor(vb, objs[i])), va, vb)
    va, vb = vb, va  # Swap colors for next iteration
  return O
 
0.2733333333333334, 3.900264, def icccfcjccahbehfdafegagajdeacfcdf(I):
  """
  Employs a recursive approach to swap colors and relocate objects.
  """
  def helper(grid, objs, colors):
    if not objs:
       return grid
    a, *objs = objs
    va, *colors = colors
    vb = colors[0] if colors else va  # Handle cases with less than two colors
    return helper(
        replace(paint(grid, recolor(vb, a)), va, vb),
        objs,
        (colors + [va])[1:],  # Rotate colors
    )
  objs = list(objects(I, True, False, True))
  colors = tuple(color(obj) for obj in objs)
  return helper(canvas(mostcolor(I), shape(I)), objs, colors)
 
0.22666666666666668, 6.488433, def beeaadjbfcbiedbeacjagdbjbigccaab(I):
  objs = fgpartition(I)
  a, b = order(totuple(objs), size)[-TWO:]
  return paint(paint(cover(I, a), b), recolor(color(a), toindices(b)))
 
0.20333333333333334, 5.7357793, def edaedfeadifdeffbjacgbgihgehechdc(I):
  a, b = order(totuple(palette(I) - {mostcolor(I)}), lambda c: colorcount(I, c))[-TWO:]
  O = canvas(mostcolor(I), shape(I))
  for v, (i, j) in asobject(I):
    if v == a:
      O = fill(O, b, {(i, j)})
    elif v == b:
      O = fill(O, a, {(i, j)})
    else:
      O = fill(O, v, {(i, j)})
  return O
 
0.9700000000000001, 68.39096, def facgaecaeddfeebbjeefccabeecbgaga(I):
  objs = objects(I, T, F, F)
  size_objs = apply(size, objs)
  second_smallest_size =  sorted(size_objs)[1]
  smallobj = extract(objs, matcher(size, second_smallest_size))
  largeobj = argmax(objs, size)
  O = paint(cover(I, largeobj), recolor(color(smallobj), toindices(largeobj)))
  return O
 
0.9700000000000001, 7.8824887, def eedfehbjcbfiediiifcgcfaagceaccbf(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, size)
  second_smallest = sorted_objs[1] if len(objs) > 1 else sorted_objs[0]
  largest = sorted_objs[-1]
  O = paint(cover(I, largest), recolor(color(second_smallest), toindices(largest)))
  return O
 
0.91, 66.846016, def ffcagadhfefiedbabeaddbccdiddjfdc(I):
    objs = objects(I, T, F, F)
    single_cells = sizefilter(objs, 1)
    multi_cells = difference(objs, single_cells)
    for single_cell in single_cells:
        single_color = color(single_cell)
        for multi_cell in multi_cells:
            multi_color = color(multi_cell)
            if single_color != multi_color:
                I = paint(I, recolor(multi_color, toindices(single_cell)))
                I = paint(I, recolor(single_color, toindices(multi_cell)))
    O = I
    return O
 
0.94, 3.8281782, def hjcfhhhfjfbeeeffbbdfjecejdcifghc(I):
  objs = objects(I, T, F, F)
  single_cells = order(sfilter(objs, lambda obj: size(obj) == 1), color)
  multi_cells = order(sfilter(objs, lambda obj: size(obj) != 1), color)
  for i in range(size(single_cells)):
    I = paint(I, recolor(color(multi_cells[i]), toindices(single_cells[i])))
    I = paint(I, recolor(color(single_cells[i]), toindices(multi_cells[i])))
  O = I
  return O
 
1.0, 6.4680066, def efgaajcdcdjeehfjaffabcfcbgbfgcfi(I):
  objs = objects(I, T, F, F)
  single_cell_colors = {color(obj) for obj in objs if size(obj) == 1}
  multi_cell_colors = {color(obj) for obj in objs if size(obj) != 1}
  for single_color in single_cell_colors:
    multi_color = extract(multi_cell_colors, lambda c: c != single_color)
    I = paint(I, recolor(multi_color, toindices(extract(objs, lambda obj: color(obj) == single_color))))
    I = paint(I, recolor(single_color, toindices(extract(objs, lambda obj: color(obj) == multi_color))))
  O = I
  return O
 
0.86, 6.2061977, def affbcajbhhhbefeiidegdciggdfgieib(I):
    f = lambda obj: (size(obj) == 1, color(obj))
    objs = order(objects(I, T, F, F), f)
    single_colors = [color(obj) for obj in objs if size(obj) == 1]
    multi_colors = [color(obj) for obj in objs if size(obj) != 1]
    for i in range(len(single_colors)):
        I = replace(I, single_colors[i], multi_colors[i])
        I = replace(I, multi_colors[i], single_colors[i])
    O = I
    return O
 
0.5199999999999999, 4.163647, def fchhhdcceeibejjeaiaeefagbagbeccc(I):
    objs = objects(I, T, F, F)
    single_cell = extract(objs, lambda obj: size(obj) == 1)
    multi_cell = extract(objs, lambda obj: size(obj) != 1)
    single_color = color(single_cell)
    multi_color = color(multi_cell)
    O = paint(paint(I, recolor(multi_color, toindices(single_cell))), recolor(single_color, toindices(multi_cell)))
    return O
 
0.31, 6.7504454, def ddbghheebcfaeihgjifjgaghfdbcdeae(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    color = first(obj)[0]
    upper_obj = sfilter(obj, lambda c: c[1][0] < len(I) // 2)
    lower_obj = sfilter(obj, lambda c: c[1][0] >= len(I) // 2)
    upper_color = color + 4 if color == 2 else color
    O = paint(O, recolor(upper_color, toindices(upper_obj)))
    O = paint(O, recolor(color, toindices(lower_obj)))
  return O
 
0.9700000000000001, 8.326672, def jeiaibcaccbaegfcbhhjfadadedceaih(I):
    # Get color of the upper-left corner cell (assuming it's part of the target object)
    target_color = I[0][0] 
    # Swap the target color with color 5
    O = switch(I, FIVE, target_color)
    return O
 
0.21, 4.658983, def hgehghdhacebejiaifdbbfaejcgaiibd(I):
    # Iterate through the top row to find a non-zero color
    target_color = next((v for v in I[0] if v != 0), 0) 
    # Swap the target color with color 5
    O = switch(I, FIVE, target_color)
    return O
 
0.30666666666666664, 6.75478, def gijeecaabeceedheadbdibfjddffhhff(I):
  objs = order(objects(I, T, F, T), size)[-TWO:]
  if len(objs) == 2:
    a, b = objs
    return paint(paint(cover(cover(I, a), b), recolor(color(b), a)), recolor(color(a), b))
  else:
    return I
 
0.22666666666666668, 5.974823, def idjdhhcigieheiejjbagfbjiebjabeac(I):
  color_counts = [(colorcount(I, c), c) for c in palette(I) - {mostcolor(I)}]
  color_counts.sort(reverse=True)
  if len(color_counts) >= 2:
    a = color_counts[0][1]
    b = color_counts[1][1]
    return switch(I, a, b)
  else:
    return I 
 
0.31666666666666665, 6.9993525, def ecbbjabjbdbeeajjaejbfdcefaedjaba(I):
  objs = objects(I, T, F, F)
  size_objs = list(zip(objs, apply(size, objs)))
  size_objs.sort(key=lambda x: x[1])
  smallobj = size_objs[1][0]
  largeobj = size_objs[-1][0]
  O = paint(cover(I, largeobj), recolor(color(smallobj), toindices(largeobj)))
  return O
 
0.9700000000000001, 47.57375, def eahgbibacdbgeidebejdcdaeagabigdf(I):
  objs = objects(I, T, F, F)  # Extract all objects from the grid
  objs = sfilter(objs, lambda obj: size(obj) > 1) # Remove single-cell objects 
  if size(objs) < 2:  # Handle cases with less than two multi-cell objects
    return I
  smallest = argmin(objs, size) # Find the smallest object
  largest = argmax(objs, size)  # Find the largest object
  I = paint(I, recolor(color(largest), toindices(smallest)))  # Swap colors 
  I = paint(I, recolor(color(smallest), toindices(largest))) 
  O = I
  return O 
 
0.31666666666666665, 8.194395, def hhbgacchdabfeefabidegbfefhffefdc(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    c = color(obj)
    if c == 2:
      O = move(O, obj, (4, 0)) # Move object with color 2 down by 4
    elif c == 6:
      O = move(O, obj, (-1, 0)) # Move object with color 6 up by 1
    elif c == 8:
      O = move(O, obj, (-3, 0)) # Move object with color 8 up by 3
  return O
 
0.3033333333333333, 6.2875776, def jacdhfdddffiebabiaedffcbcadegecg(I):
  move_object = lambda obj, v: branch(v == 2, shift(obj, (4, 0)), branch(v == 6, shift(obj, (-1, 0)), branch(v == 8, shift(obj, (-3, 0)), obj)))
  return paint(I, merge(apply(lambda obj: move_object(obj, color(obj)), objects(I, T, F, T))))
 
0.91, 8.046726, def jfhjddceabbfefeebffbhjdjdecdbfbj(I):
    # Extract top row and the rest of the grid
    top_row = I[0]
    rest_of_grid = I[1:]

    # Replace target colors in the rest of the grid
    modified_rest_of_grid = tuple(
        tuple(
            leastcommon(top_row) if v == I[0][0] else v 
            for v in row
        )
        for row in rest_of_grid
    )
    
    # Replace target color in the top row
    modified_top_row = tuple(
        I[0][0] if v == leastcommon(top_row) else v 
        for v in top_row
    )

    # Combine the modified top row and the rest of the grid
    O = (modified_top_row,) + modified_rest_of_grid
    return O
 
0.32666666666666666, 6.835365, def ecbhfbfbaiedebbgahffbffhhaechabd(I):
  a, b = order(totuple(palette(I) - {mostcolor(I)}), lambda c: colorcount(I, c))[:TWO]
  return switch(I, a, b) 
 
0.9700000000000001, 7.0016704, def bdjcbbfdejabeggjbaadfbcjbadbfcfb(I):
  objs = objects(I, T, F, F)  # Extract all objects from the grid
  sorted_objs = sorted(objs, key=size)  # Sort objects by size
  smallobj = sorted_objs[0] # Smallest object
  largeobj = sorted_objs[-1] # Largest object
  target_color = color(smallobj)  # Get the color of the smallest object
  recolored = recolor(target_color, toindices(largeobj))  # Recolor the largest object
  O = paint(cover(I, largeobj), recolored)  # Paint the recolored object onto a blank canvas
  return O
 
0.9066666666666666, 70.658424, def bhfeedfecgfdebdcafddacaacdeijbgb(I):
  objs = objects(I, T, F, F)
  smallest_obj = argmin(objs, size)
  target_color = color(smallest_obj)
  O = I
  for obj in objs:
    if obj != smallest_obj:
      O = paint(O, recolor(target_color, toindices(obj)))
  O = paint(O, recolor(color(first(objs - {smallest_obj})), toindices(smallest_obj)))
  return O
 
0.30666666666666664, 6.75478, def cjgadiecejdeecaeaaieiagidgbebfaj(I):
  objs = objects(I, T, F, F)
  smallest_color = color(argmin(objs, size))
  O = canvas(smallest_color, shape(I))
  for obj in objs:
    if color(obj) != smallest_color:
      O = paint(O, obj)
  return O
 
0.8866666666666667, 66.377945, def fiedccdfbfjfeafdbiejfdjhihcdbchc(I):
  objs = objects(I, T, F, F)
  min_size = size(argmin(objs, size))
  target_color = color(extract(objs, lambda obj: size(obj) == min_size))
  O = I
  for obj in objs:
    if size(obj) != min_size:
      O = paint(O, recolor(target_color, toindices(obj)))
  O = paint(O, recolor(color(first(objs - {extract(objs, lambda obj: size(obj) == min_size)})), toindices(extract(objs, lambda obj: size(obj) == min_size))))
  return O
 
0.9899999999999999, 30.264338, def ebebidgdfgfaedbfiadebgeffefifjea(I):
  objs = objects(I, T, F, F)
  smallest_color = color(min(objs, key=len))
  other_colors = palette(I) - {smallest_color}
  O = I
  for c in other_colors:
    O = paint(O, recolor(smallest_color, toindices(extract(objs, lambda obj: color(obj) == c))))
  return O
 
0.5066666666666667, 9.911364, def hcigcbidccffehaibeaffadfifadbdaa(I):
  def move_object(obj, v):
    upper_shift = (0, 4) if v == 2 else ((-1, 0) if v == 6 else (-3, 0))
    lower_shift = (0, 3) if v == 8 else ((-2, 0) if v == 4 else (-3, 0))
    return branch(uppermost(obj) < len(I) // 2, 
                   shift(obj, upper_shift), 
                   shift(obj, lower_shift))
  return paint(I, merge(apply(lambda obj: move_object(obj, color(obj)), objects(I, T, F, T)))) 
 
0.30666666666666664, 6.75478, def djdaebgaecaheaccacifjbeafbigacab(I):
  def move_rule(v, loc):
    return branch(v == 2, add(loc, (4, 0)),
                 branch(v == 6 and loc[0] < len(I) // 2, add(loc, (-1, 0)),
                   branch(v == 8 and loc[0] < len(I) // 2, add(loc, (-3, 0)),
                     branch(v == 8 and loc[0] >= len(I) // 2, add(loc, (0, 3)),
                       branch(v == 4 and loc[0] >= len(I) // 2, add(loc, (-2, 0)),
                         branch(v == 7, add(loc, (0, 3)), loc))))))
  return paint(I, frozenset((I[i][j], move_rule(I[i][j], (i, j))) 
                               for i in range(len(I)) for j in range(len(I[0]))))
 
0.5033333333333334, 9.802187, def debbahdejbdgejdhabjcaaciafcbbech(I):
  def move_component(comp, v):
    up_move = lambda c: branch(v==2, add(c,(4,0)), branch(v==6, add(c,(-1,0)), add(c,(-3,0))))
    down_move = lambda c: branch(v==8, add(c,(0,3)), branch(v==4, add(c,(-2,0)), add(c,(-3,0))))
    return branch(comp[1][0] < len(I) // 2, up_move(comp[1]), down_move(comp[1]))
  return paint(I, frozenset((v, move_component(comp, v)) for obj in objects(I, T, F, T) for comp in obj for v in {color(obj)}))
 
0.32666666666666666, 6.7097077, def idafjebibdggehffijbacibheifdbcfb(I):
  objs = sorted([obj for obj in objects(I, T, F, T) if color(obj) != mostcolor(I)], key=lambda obj: len(obj))[:TWO]
  return paint(paint(cover(I, objs[0]), recolor(color(objs[1]), objs[0])), recolor(color(objs[0]), objs[1]))
 
0.32666666666666666, 6.923973, def iaeeigfehaefebbgjabbibaadgdcfaaf(I):
  color_counts = {c: colorcount(I, c) for c in palette(I) if c != mostcolor(I)}
  a, b = sorted(color_counts, key=color_counts.get)[:TWO]
  I_new = tuple(tuple(a if cell == b else b if cell == a else cell for cell in row) for row in I)
  return I_new
 
0.9700000000000001, 7.3800783, def iabdffedhibfedabbcbbdhifgcefbfdc(I):
  color_1 = leastcolor(I)
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  O = paint(I, recolor(color_1, toindices(largest_obj)))
  return O
 
0.9700000000000001, 6.453514, def eajaaecebedcejaibedabjbdccjhhecc(I):
  objs = objects(I, T, F, F)
  size_counts = {size(obj): obj for obj in objs}
  smallest_obj = size_counts[min(size_counts)]
  largest_obj = size_counts[max(size_counts)]
  O = paint(cover(I, largest_obj), recolor(color(smallest_obj), toindices(largest_obj)))
  return O 
 
0.31666666666666665, 3.9786696, def aefjagdfcjiceeiaiihbcffafafaddcd(I):
  objs = objects(I, T, F, T) # Identify non-background objects
  if len(objs) < 2: # Handle cases with less than two objects
      return I
  smallest_obj = argmin(objs, size) # Find smallest object
  largest_obj = argmax(objs, size) # Find largest object
  smallest_color = color(smallest_obj) # Get color of smallest
  largest_color = color(largest_obj) # Get color of largest
  O = paint(I, recolor(largest_color, toindices(smallest_obj))) # Paint smallest with largest color
  O = paint(O, recolor(smallest_color, toindices(largest_obj))) # Paint largest with smallest color
  return O
 
0.24333333333333332, 6.4691234, def idieiafgfbeaecigjegefcaeefjceaga(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
      return I
  sorted_objs = order(objs, size) # Sort objects by size
  smallest_color = color(first(sorted_objs))
  largest_color = color(last(sorted_objs))
  O = I
  for obj in sorted_objs:
    if color(obj) == smallest_color:
      O = paint(O, recolor(largest_color, toindices(obj)))
    else:
      O = paint(O, recolor(smallest_color, toindices(obj)))
  return O
 
0.22999999999999998, 4.960135, def bcijdcjfhcegefjgagfcgfdcheicdefi(I):
  objs = objects(I, T, F, T)
  if len(objs) < 2:
      return I
  size_color_pairs = apply(lambda obj: (size(obj), color(obj)), objs)
  smallest_color = last(order(size_color_pairs, lambda x: x[0]))[1]
  largest_color = first(order(size_color_pairs, lambda x: x[0]))[1]
  O = I
  for obj in objs:
    if color(obj) == smallest_color:
      O = paint(O, recolor(largest_color, toindices(obj)))
    else:
      O = paint(O, recolor(smallest_color, toindices(obj)))
  return O
 
0.34, 9.465204, def efidefehiachegeajiciidbbebfichef(I):
  objs = objects(I, T, F, T) # Identify objects, not considering diagonal connections and excluding background
  O = I
  for obj in objs:
    c = color(obj)
    if c == 1:
      O = paint(cover(O, obj), shift(recolor(7, obj), (2,0))) # Move down by 2 and recolor to 7
    elif c == 2:
      O = paint(cover(O, obj), shift(recolor(6, obj), (4,0))) # Move down by 4 and recolor to 6
    elif c == 4:
      O = paint(cover(O, obj), shift(obj, (5,0))) # Move down by 5
    elif c == 6:
      O = paint(cover(O, obj), shift(obj, (-1,0))) # Move up by 1
    elif c == 7:
      O = paint(cover(O, obj), shift(obj, (-2,0))) # Move up by 2
    elif c == 8:
      O = paint(cover(O, obj), shift(obj, (-3,0))) # Move up by 3
  return O 
 
0.34, 10.670856, def haeehidfbdcdecjciafhbcebaefaccfg(I):
  shifts = {1: (2,0), 2: (4,0), 4: (5,0), 6: (-1,0), 7: (-2,0), 8: (-3,0)} # Dictionary for color-specific shifts
  recolors = {1: 7, 2: 6} # Dictionary for color-specific recoloring
  O = I
  for c in palette(I):
    obj = toobject(ofcolor(I, c), I)
    O = paint(cover(O, obj), shift(recolor(recolors.get(c, c), obj), shifts.get(c, (0,0))))
  return O
 
0.2333333333333333, 9.037285, def deagfeagidchejiebfgdhgbjccecibbc(I):
  # Identify top row indices
  top_row_indices = frozenset((0, j) for j in range(len(I[0])))
  
  # Get target colors
  top_left_color = I[0][0]
  top_row_colors = frozenset(v for v in I[0] if v != 0) - {top_left_color}
  other_target_color = leastcommon(tuple(top_row_colors)) if top_row_colors else top_left_color
  
  # Recolor objects based on intersection with top row
  O = I
  for obj in objects(I, T, F, F):
    target_color = top_left_color if any(index in top_row_indices for index in toindices(obj)) else other_target_color
    O = paint(cover(O, obj), recolor(target_color, obj))
  return O
 
0.8866666666666667, 50.074757, def degjgcajgagbebgdjacjciehcbecebbb(I):
  top_row_colors = tuple(filter(lambda x: x != 0, I[0]))  # Extract non-background colors from the top row
  target_color_top = top_row_colors[0]  # First non-background color in the top row
  target_color_other = leastcommon(top_row_colors) if len(set(top_row_colors)) > 1 else target_color_top

  O = I
  for obj in objects(I, T, F, F):
    if any(i == 0 for i, j in toindices(obj)):
      O = paint(cover(O, obj), recolor(target_color_top, obj))
    else:
      O = paint(cover(O, obj), recolor(target_color_other, obj))
  return O
 
0.32666666666666666, 7.7256713, def hdbfcifddjfaedbdjfacgcbibhcjdhbe(I):
  obj_a, obj_b = sorted([obj for obj in objects(I, T, F, T) if color(obj) != mostcolor(I)], key=lambda obj: len(obj))[:TWO]
  return paint(paint(cover(I, obj_a), obj_b), recolor(color(obj_a), shift(obj_a, subtract(centerofmass(obj_b), centerofmass(obj_a))))) 
 
0.98, 8.899049, def cbdebdhfdgfhebhfifeajcbcjffjgegc(I):
  objs = objects(I, T, F, F) # Extract all the objects
  sorted_objs = order(objs, size) # Sort objects by size
  smallest = color(sorted_objs[0]) # Color of the smallest object
  largest = color(sorted_objs[-1]) # Color of the largest object
  second_smallest = color(sorted_objs[1]) if len(sorted_objs) > 1 else largest # Color of the second smallest object
  O = replace(I, largest, smallest) # Replace largest color with smallest
  O = replace(O, smallest, second_smallest) # Replace smallest color with second_smallest
  return O
 
0.98, 6.2286263, def bjdbjeidibejeicgbdbbhagcagiabgac(I):
  objs = objects(I, T, F, F)
  smallobj = argmin(objs, size) # Object with the smallest size
  largeobj = argmax(objs, size) # Object with the largest size
  second_smallest = argmin(difference(objs, {smallobj}), size) # Object with the second smallest size
  O = paint(cover(I, largeobj), recolor(color(smallobj), toindices(largeobj))) # Replace the largest object with the color of the smallest object
  O = paint(cover(O, smallobj), recolor(color(second_smallest), toindices(smallobj))) # Replace the smallest object with the color of the second smallest object
  return O 
 
0.9899999999999999, 6.817736, def gabafbcdehececeaaifbdcjacejgcaej(I):
  objs = objects(I, T, F, F)
  sorted_objs = order(objs, size)
  small_color = color(sorted_objs[0])
  large_color = color(sorted_objs[-1])
  second_small_color = color(sorted_objs[1]) if len(sorted_objs) > 1 else large_color
  O = switch(I, large_color, small_color) # Switch the colors of the largest and smallest objects
  O = switch(O, small_color, second_small_color) # Switch the colors of the smallest and second smallest objects
  return O
 
0.98, 8.400212, def cbbgcgbgeggbeibfjfhdehebjaabdjda(I):
  objs = objects(I, T, F, F)
  object_colors = apply(color, objs) # Create a set of colors of all objects
  sorted_colors = order(object_colors, identity) # Sort the colors based on their values
  smallest = sorted_colors[0] # Smallest color
  second_smallest = sorted_colors[1] if len(sorted_colors) > 1 else sorted_colors[0] # Second smallest color
  largest = sorted_colors[-1] # Largest color
  O = replace(I, largest, smallest) # Replace largest color with smallest
  O = replace(O, smallest, second_smallest) # Replace smallest color with second smallest
  return O
 
0.31, 4.9787264, def caecjdfejeabebfaadbjdjehaabhjcid(I):
  objs = objects(I, T, F, T)
  obj_sizes = totuple(apply(size, objs))
  min_index, max_index = obj_sizes.index(min(obj_sizes)), obj_sizes.index(max(obj_sizes))
  min_obj, max_obj = totuple(objs)[min_index], totuple(objs)[max_index]
  O = paint(I, recolor(color(max_obj), toindices(min_obj)))
  O = paint(O, recolor(color(min_obj), toindices(max_obj)))
  return O 
 
0.33666666666666667, 4.5447907, def faddbefbdcjfebffjbhbcdahjfedcifa(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
      if size(obj) == minimum(apply(size, objs)):
          O = paint(O, recolor(color(argmax(objs, size)), toindices(obj)))
      elif size(obj) == maximum(apply(size, objs)):
          O = paint(O, recolor(color(argmin(objs, size)), toindices(obj)))
  return O
 
0.3, 5.254362, def djeiahdbbjabegegjdhbabbbffdjdcia(grid):
  color_map = {
    2: (2, (4, 0)), 
    6: (6, (-1, 0)), 
    8: (8, (-3, 0)),
    1: (1, (2, 0)), 
    4: (4, (4, 0)), 
    7: (7, (2, 0)) 
  } 
  new_objects = []
  for obj in objects(grid, T, F, T):
    original_color = color(obj)
    new_color, shift_amount = color_map.get(original_color, (original_color, (0, 0))) 
    new_objects.append(shift(recolor(new_color, obj), shift_amount))
  return paint(grid, merge(new_objects))
 
0.30666666666666664, 5.5000477, def bfcbbajbcjeaegjdiaeedacgchbgdcfh(grid):
  def transform_object(obj):
    c = color(obj)
    new_color = c
    shift_amount = (0, 0)
    if c == 2:
      shift_amount = (4, 0)
    elif c == 6:
      shift_amount = (-1, 0)
    elif c == 8:
      shift_amount = (-3, 0)
    elif c == 1:
      shift_amount = (2, 0)
    elif c == 4:
      shift_amount = (4, 0)
    elif c == 7:
      shift_amount = (2, 0)
    return shift(recolor(new_color, obj), shift_amount)
  return paint(grid, merge(apply(transform_object, objects(grid, T, F, T))))
 
0.33, 8.441263, def cibeebfdaejjegacjeideeeadeccfeae(grid):
  new_grid = grid
  for obj in objects(grid, T, F, T):
    c = color(obj)
    new_grid = cover(new_grid, obj)
    if c == 2:
      obj = shift(recolor(c, obj), (4, 0))
    elif c == 6:
      obj = shift(recolor(c, obj), (-1, 0))
    elif c == 8:
      obj = shift(recolor(c, obj), (-3, 0))
    elif c == 1:
      obj = shift(recolor(c, obj), (2, 0))
    elif c == 4:
      obj = shift(recolor(c, obj), (4, 0))
    elif c == 7:
      obj = shift(recolor(c, obj), (2, 0))
    new_grid = paint(new_grid, obj)
  return new_grid
 
0.31666666666666665, 7.797231, def bdjcbeeadbafecebjgedbjcbhjbbafbb(I):
  objs = objects(I, T, F, F) # Identify all objects
  smallobj = argmin(objs, size) # Find the smallest object 
  largeobj = argmax(objs, size) # Find the largest object
  if size(smallobj) < size(largeobj):
    O = paint(cover(I, smallobj), recolor(color(largeobj), toindices(smallobj))) 
  else:
    O = paint(cover(I, largeobj), recolor(color(smallobj), toindices(largeobj)))
  return O
 
0.30666666666666664, 16.66877, def ecbbgdahfgcgeffbidcbddadffbccgfa(I):
  objs = objects(I, T, F, F)
  sizes = apply(size, objs)
  sorted_sizes = sorted(sizes)
  second_smallest_size = sorted_sizes[1] 
  smallobj = extract(objs, matcher(size, second_smallest_size))
  largeobj = argmax(objs, size)
  return branch(size(smallobj) < size(largeobj),
            paint(cover(I, smallobj), recolor(color(largeobj), toindices(smallobj))),
            paint(cover(I, largeobj), recolor(color(smallobj), toindices(largeobj))))
 
0.3133333333333333, 6.3897333, def ijdddceehjjeebddaihidjhgccjbchgc(grid):
  def transform_object(obj):
    c = color(obj)
    if c == 2:
      return shift(obj, (3, 1))
    elif c == 6:
      return shift(obj, (-1, 0))
    elif c == 8:
      return shift(obj, (-3, 1))
    elif c == 1:
      return shift(obj, (2, 0))
    elif c == 4:
      return shift(obj, (5, 0))
    elif c == 7:
      return shift(obj, (-2, 0))
    return obj
  return paint(grid, merge(apply(transform_object, objects(grid, T, F, T)))) 
 
0.30666666666666664, 5.946554, def jhijbdfdfdfeeeiebaceiebbbgadigeg(grid):
  color_shift_map = {
    2: (3, 1),
    6: (-1, 0),
    8: (-3, 1),
    1: (2, 0),
    4: (5, 0),
    7: (-2, 0)
  }
  new_objects = [shift(obj, color_shift_map.get(color(obj), (0, 0))) for obj in objects(grid, T, F, T)]
  return paint(grid, merge(new_objects))
 
0.32666666666666666, 6.8995833, def caahcdccadcceecdieeaacigedjhihjd(I):
  a, b = sorted(palette(I) - {mostcolor(I)}, key=lambda c: colorcount(I, c))[1:3]
  return paint(paint(cover(I, ofcolor(I, a)), recolor(b, ofcolor(I, a))), recolor(a, ofcolor(I, b)))
 
0.9899999999999999, 6.9864283, def edabiiaibecfebhiifjajdebffddeajf(I):
  objs = objects(I, T, F, F)
  size_objs = order(objs, size)
  small_obj = size_objs[0]
  large_obj = size_objs[-1]
  second_small_obj = size_objs[1] if len(size_objs) > 1 else large_obj
  O = paint(paint(I, recolor(color(small_obj), large_obj)), 
            recolor(color(large_obj), small_obj))
  O = paint(paint(O, recolor(color(second_small_obj), large_obj)), 
            recolor(color(large_obj), second_small_obj))
  return O
 
0.9899999999999999, 6.1226816, def befjeafdedaeefhejagbaacgjecedjae(I):
  objs = objects(I, T, F, F)
  small_color = color(argmin(objs, size))
  large_color = color(argmax(objs, size))
  second_small_color = color(argmin(remove(argmin(objs, size), objs), size)) if len(objs) > 1 else large_color
  O = switch(switch(I, large_color, small_color), small_color, second_small_color)
  return O
 
0.9899999999999999, 6.4554567, def ccghcaicaeffejhcagibahhhddbaecac(I):
  objs = objects(I, T, F, F)
  small_obj = min(objs, key=len)
  large_obj = max(objs, key=len)
  second_small_obj = min(objs - {small_obj}, key=len, default=large_obj)
  O = I
  for cell in small_obj:
    O = paint(O, {(color(large_obj), cell[1])})
  for cell in large_obj:
    O = paint(O, {(color(small_obj), cell[1])})
  for cell in second_small_obj:
    O = paint(O, {(color(large_obj), cell[1])})
  return O
 
0.31666666666666665, 69.5182, def cbhdeeifcfjaeicfihccijdffhfdeeid(I):
  objs = objects(I, T, F, F)
  objs_by_size = sorted(objs, key=lambda x: len(x))
  small_color = color(objs_by_size[0])
  large_color = color(objs_by_size[-1])
  second_small_color = color(objs_by_size[1]) if len(objs_by_size) > 1 else large_color
  O = canvas(large_color, shape(I))
  for obj in objs_by_size:
    if color(obj) == small_color:
      O = paint(O, recolor(small_color, obj))
    elif color(obj) == second_small_color:
      O = paint(O, recolor(second_small_color, obj))
  return O
 
0.3133333333333333, 5.673287, def fdfgfegfeajhebfabcbdabfcagacfjbe(grid):
  shifts = {
    2: (-2, -1),
    6: (-3, 0),
    8: (3, -1),
    1: (-2, 1),
    4: (2, 0),
    7: (2, 1)
  }
  return paint(grid, merge(apply(lambda obj: shift(obj, shifts.get(color(obj), (0, 0))), objects(grid, T, F, T))))
 
0.47666666666666674, 21.137417, def egcdgacdaadaeccdbcdcdfdfajibbgef(I):
  largest_obj = argmax(objects(I, T, F, F), size)
  O = I
  for j in range(len(I[0])):
    target_color = I[0][j]
    if target_color != 0:
      column_patch = frozenset((i, j) for i in range(1, len(I)))
      O = underfill(O, target_color, column_patch)
  return O
 
0.32666666666666666, 6.8304343, def bceffgcbeccfeaaejceeiiaedeegegfh(I):
  color_counts = [(colorcount(I, c), c) for c in palette(I) - {mostcolor(I)}]
  color_counts.sort(reverse=True)
  a = color_counts[1][1]
  b = color_counts[2][1]
  return switch(I, a, b)
 
0.32666666666666666, 6.8361864, def babicbdficjdedcbbcfbbcdebjdhffae(I):
  objs = order(objects(I, T, T, T), size)[1:3]
  obja, objb = objs if colorcount(I, color(objs[0])) >= colorcount(I, color(objs[1])) else (objs[1], objs[0])
  return paint(paint(cover(I, obja), recolor(color(objb), obja)), recolor(color(obja), objb))
 
0.30666666666666664, 6.75478, def gfeeeeabdaggeeaibeddfiechbffffha(I):
  objs = objects(I, T, F, F)
  obj1 = argmax(objs, size) 
  obj2 = argmin(objs, size)
  color1 = color(obj1)
  color2 = color(obj2)
  obj1_shifted = shift(obj1, gravitate(obj1, obj2))
  O = paint(paint(I, recolor(color2, toindices(obj1_shifted))), recolor(0, toindices(obj1)))
  return O
 
0.31, 7.098972, def bafifbeccfehefhcacddhbfaeijbabbj(I):
  objs = objects(I, T, F, F)
  obj1 = argmin(objs, lambda obj: ulcorner(obj)[0])
  obj2 = argmax(objs, lambda obj: ulcorner(obj)[0])
  obj1_shifted = shift(obj1, gravitate(obj1, obj2))
  O = paint(paint(I, recolor(color(obj2), toindices(obj1_shifted))), recolor(0, toindices(obj1)))
  return O
 
0.98, 6.337494, def aeaefcbajegdeeacicaajcibghbhdegb(I):
  def process_object(obj):
    return (size(obj), color(obj) == mostcommon(I), obj)
  objs = objects(I, T, F, F)
  objs = sorted(objs, key=process_object)
  target_obj1, target_obj2 = objs[0], objs[-1]
  return paint(paint(I, recolor(color(target_obj2), toindices(target_obj1))), recolor(color(target_obj1), toindices(target_obj2))) 
 
0.32666666666666666, 7.761721, def djchhiebdffeefcfbcehbhdbidhahfce(I):
  color_counts = sorted(((colorcount(I, c), c) for c in palette(I) if c != mostcolor(I)))[1:3]
  a = color_counts[0][1]
  b = color_counts[1][1]
  return replace(replace(I, a, -1), b, a) if a is not None and b is not None else I
 
0.33666666666666667, 69.58034, def bbadfgdcgcgcehffajdfcdaabbgeafed(I):
  objs = list(objects(I, T, F, F)) # Get all objects as a list
  objs.sort(key=size) # Sort objects by size
  obj1, obj2 = objs[0], objs[1] # Get two smallest objects
  ul1, ul2 = ulcorner(obj1), ulcorner(obj2) # Get upper-left corners
  obj1_shifted = shift(obj1, subtract(ul2, ul1)) # Shift obj1 to obj2's location
  obj2_shifted = shift(obj2, subtract(ul1, ul2)) # Shift obj2 to obj1's location
  O = paint(paint(canvas(mostcolor(I), shape(I)), obj1_shifted), obj2_shifted) # Paint on a blank canvas
  return O
 
0.32666666666666666, 6.803167, def bfbadaefdbgfebjiidjbececbjdadjge(I):
  objs = objects(I, T, F, F)
  obj1 = min(objs, key=len)
  objs = frozenset(o for o in objs if o != obj1) # Remove obj1 from objs
  obj2 = min(objs, key=len)
  O = paint(paint(I, recolor(color(obj2), toindices(obj1))), recolor(color(obj1), toindices(obj2)))
  return O
 
0.32666666666666666, 6.923973, def eccceifhdcbeegeabfhebjehebdfbcec(I):
  objs = list(objects(I, T, F, F))
  objs.sort(key=lambda x: (len(x), ulcorner(x))) # Sort by size then upper-left corner
  obj1, obj2 = objs[0], objs[1]
  O = paint(I, recolor(color(obj2), toindices(obj1)))
  O = paint(O, recolor(color(obj1), toindices(obj2)))
  return O
 
0.32666666666666666, 7.793549, def gbeidedfhcabeedfadcfbbjchcaeaeib(I):
  objs = list(objects(I, T, F, F))
  small_obj = min(objs, key=len)
  objs.remove(small_obj)
  second_small_obj = min(objs, key=len)
  diff = subtract(ulcorner(second_small_obj), ulcorner(small_obj))
  O = move(move(I, small_obj, diff), second_small_obj, invert(diff))
  return O
 
0.8933333333333332, 70.53738, def gjcbjjhafbeheafabbjgfaicfdceedad(I):
  objs = objects(I, T, F, F)
  def swap(obj): 
    return (size(obj), color(obj))
  sorted_objs = order(apply(swap, objs), lambda x: x[0])
  smallest_color = sorted_objs[0][1]
  largest_color = sorted_objs[-1][1]
  return paint(I, merge({recolor(largest_color if color(obj) == smallest_color else smallest_color, toindices(obj)) for obj in objs})) 
 
0.3333333333333333, 10.265766, def eabffdfhbihfeibijdaiejdfccgcgbbc(grid):
  new_grid = canvas(0, shape(grid))  # Initialize an empty grid
  for obj in objects(grid, T, F, T): # Iterate over univalued objects
    c = color(obj)
    if c == 2:
      new_grid = paint(new_grid, shift(obj, (4, 0)))
    elif c == 6:
      new_grid = paint(new_grid, shift(obj, (-1, 0)))
    elif c == 8:
      new_grid = paint(new_grid, shift(obj, (-3, 0)))
    elif c in {1, 4, 7}:  # Combine similar shifts
      new_grid = paint(new_grid, shift(obj, (-2, 0)))
    else:  # Keep other colors in place
      new_grid = paint(new_grid, obj)
  return new_grid
 
0.98, 32.288326, def hhedacjbiabcegebbfcddfcefdijidcc(I):
  objs = objects(I, T, F, F)
  small_obj = argmin(objs, size)
  large_obj = argmax(objs, size)
  medium_obj = extract(objs, lambda obj: obj != small_obj and obj != large_obj)
  O = paint(paint(paint(I, recolor(color(large_obj), toindices(small_obj))), 
                   recolor(color(small_obj), toindices(medium_obj))), 
                   recolor(color(medium_obj), toindices(large_obj)))
  return O 
 
0.33666666666666667, 6.754832, def eebeecgcbeebebeebjahdfhadeahbbfa(I):
  objs = sorted(objects(I, T, F, F), key=size)
  small_obj, medium_obj, large_obj = objs[0], objs[1], objs[2]
  return paint(paint(paint(I, recolor(color(large_obj), toindices(small_obj))),
                   recolor(color(small_obj), toindices(medium_obj))),
                   recolor(color(medium_obj), toindices(large_obj)))
 
0.32666666666666666, 6.803167, def cecfddbgjgjgeebajidfijjcccccadbf(I):
  objs = objects(I, T, F, F) # Extract all objects from the grid
  
  def obj_color_count(obj):
    return colorcount(I, color(obj)) # Count occurrences of object's color
  
  # Find the two objects with the least common colors and smallest size
  target_obj1 = argmin(objs, obj_color_count)
  objs = remove(target_obj1, objs)
  target_obj2 = argmin(objs, obj_color_count)
  
  # Swap colors 
  O = paint(I, recolor(color(target_obj2), toindices(target_obj1)))
  O = paint(O, recolor(color(target_obj1), toindices(target_obj2)))
  return O
 
0.33666666666666667, 10.806132, def cefiibcecfffedfebabcbifaibcaddib(grid):
  new_grid = canvas(0, shape(grid))
  for obj in objects(grid, T, F, T):
    c = color(obj)
    if c == 1:
      new_grid = paint(new_grid, shift(obj, (-2, 0)))
    elif c == 2:
      new_grid = paint(new_grid, shift(obj, (-4, 0)))
    elif c == 4:
      new_grid = paint(new_grid, shift(obj, (-2, 0)))
    elif c == 6:
      new_grid = paint(new_grid, shift(obj, (-3, 0)))
    elif c == 7:
      new_grid = paint(new_grid, shift(obj, (-2, 0)))
    elif c == 8:
      new_grid = paint(new_grid, shift(obj, (-3, 0)))
    else:
      new_grid = paint(new_grid, obj) 
  return new_grid
 
0.30666666666666664, 6.75478, def feijaaejdcidefijbjfeagfafahajcbc(I):
  largest_obj = argmax(objects(I, T, F, F), size)
  O = I
  for j in range(len(I[0])):
    target_color = I[0][j]
    if target_color != 0:
      column_objs = objects(crop(I, (1, j), (len(I) - 1, 1)), T, F, F) # Get objects in the column below the first row
      for obj in column_objs:
        if not any((I[i][j], (i, j)) in largest_obj for i in range(len(I))): # Check if the object is not part of the largest object
          O = paint(cover(O, obj), recolor(obj, target_color))
  return O
 
0.66, 7.48864, def adgdhaebcjhdebjfaahhcefbbagcgjfe(I):
  objs = objects(I, T, F, F) 
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) == 1 and adjacent(obj1, obj2):
        I = paint(cover(I, obj2), recolor(color(obj1), obj2))
  return I
 
0.20333333333333334, 5.7357793, def ddaebfdbaadcedgjigaedifidcadbeie(I):
  objs = objects(I, T, F, F)
  def recolor_if_adjacent(obj1):
    return lambda obj2: recolor(color(obj1), obj2) if adjacent(obj1, obj2) else obj2
  return paint(I, merge(apply(lambda obj1: mfilter(objs, recolor_if_adjacent(obj1)), sfilter(objs, lambda x: color(x) == 1)))) 
 
0.6666666666666666, 6.6909566, def bdfbffhbdigbeebejfdabeidfedbbbce(I):
  objs = objects(I, T, F, F)
  for obj1 in objs:
    for obj2 in objs:
      if color(obj1) == 1 and adjacent(obj1, obj2):
        I = switch(I, color(obj1), color(obj2))
  return I
 
0.2233333333333333, 9.704942, def fijdbafdcabdehiaaecfibcebcccafbd(I):
  bg = mostcolor(I) # Background color
  objs = objects(I, T, F, F) # All objects
  small_objs = sizefilter(objs, ONE) # Single-cell objects
  largest_obj = argmax(objs, size) # Largest object
  target_color = color(largest_obj) # Color of the largest object
  recolored_objs = frozenset({recolor(target_color, obj) if obj in small_objs else obj for obj in objs}) # Recolor small objects
  O = paint(canvas(bg, shape(I)), merge(recolored_objs)) # Paint on a blank canvas
  return O
 
0.21333333333333335, 6.504379, def hfgeiabfbaafeadaifabhbaabhbfadjg(I):
  x1 = objects(I, T, F, T) # All objects, excluding background
  x2 = sizefilter(x1, ONE) # Single-cell objects
  x3 = argmax(x1, size) # Largest object
  x4 = color(x3) # Color of the largest object
  x5 = lambda o: recolor(x4, o) if o in x2 else o # Recolor if object is single-cell
  O = paint(I, merge(apply(x5, x1))) # Paint back onto the original grid
  return O 
 
0.26, 8.586234, def eaihejjeccaiehfebfjfcebgfaaheifb(I):
  small_objs = sfilter(objects(I, False, False, True), lambda o: size(o) == 1)
  for obj in small_objs:
    v, (i, j) = first(obj)
    I = fill(I, v, {(i - 1, j - 1), (i - 1, j + 1), (i + 1, j - 1), (i + 1, j + 1)})
  return I
 
0.2233333333333333, 3.4321458, def cjafeeeecgfjehafieiefacdjibeabca(I):
  paint_objs = sfilter(objects(I, False, False, True), lambda o: size(o) == 1)
  target_objs = sfilter(objects(I, False, False, True), lambda o: size(o) > 1)
  for paint_obj in paint_objs:
    for target_obj in target_objs:
      if manhattan(paint_obj, target_obj) == 2:
        p_color = color(paint_obj)
        I = underpaint(cover(I, target_obj), recolor(p_color, target_obj)) 
  return I
 
0.4666666666666666, 17.203081, def efadehfceaffececjcgbjcfadfbffeed(I):
    for i in range(1, len(I) - 1):
        for j in range(1, len(I[0]) - 1):
            if I[i][j] == mostcolor(I):
                if I[i - 1][j - 1] != mostcolor(I):
                    I = fill(I, I[i - 1][j - 1], {(i, j)})
                elif I[i - 1][j + 1] != mostcolor(I):
                    I = fill(I, I[i - 1][j + 1], {(i, j)})
                elif I[i + 1][j - 1] != mostcolor(I):
                    I = fill(I, I[i + 1][j - 1], {(i, j)})
                elif I[i + 1][j + 1] != mostcolor(I):
                    I = fill(I, I[i + 1][j + 1], {(i, j)})
    return I
 
0.20333333333333334, 5.575298, def fehbhcfafidjebiajfbhcicfadfcgcda(I):
    objs = objects(I, T, F, T)  # Get all objects
    sizes = apply(size, objs)  # Get sizes of all objects
    sorted_objs = order(objs, lambda obj: size(obj))  # Sort objects by size
    second_smallest = first(remove(first(sorted_objs), sorted_objs))  # Get the second smallest object
    second_largest = first(remove(last(sorted_objs), sorted_objs))  # Get the second largest object
    color_a = color(second_smallest) 
    color_b = color(second_largest)
    O = replace(I, color_a, color_b)  # Replace color a with b
    O = replace(O, color_b, color_a)  # Replace color b with a
    return O
 
0.20333333333333334, 5.7357793, def badbeededejfebffijbdhebdfgaegdcc(I):
    objs = objects(I, T, F, T)
    size_obj = astuple(size(argmin(objs, size)), size(argmax(objs, size)))  # Get sizes of the smallest and largest objects
    filtered_objs = sfilter(objs, lambda obj: size(obj) != size_obj[0] and size(obj) != size_obj[1]) # Filter out objects with the smallest and largest sizes
    sorted_objs = order(filtered_objs, lambda obj: size(obj))  # Sort the remaining objects by size
    second_smallest = first(sorted_objs)  # Get the second smallest object
    second_largest = last(sorted_objs)  # Get the second largest object
    color_a = color(second_smallest)
    color_b = color(second_largest)
    O = replace(I, color_a, color_b)  # Replace color a with b
    O = replace(O, color_b, color_a)  # Replace color b with a
    return O 
 
0.21333333333333335, 5.3095446, def fcdecfhfjebjehdcjbdebecebcdfbjda(I):
  objs = objects(I, T, F, T)
  obj_sizes = tuple((size(obj), obj) for obj in objs)  # Create tuples of (size, object)
  sorted_objs = order(obj_sizes, lambda x: x[0]) # Sort tuples by size
  second_smallest = sorted_objs[1][1]  # Get the second smallest object
  second_largest = sorted_objs[-2][1] # Get the second largest object 
  color_a = color(second_smallest)
  color_b = color(second_largest)
  O = replace(I, color_a, color_b) 
  O = replace(O, color_b, color_a) 
  return O
 
0.24000000000000002, 5.163523, def efbfaidfgafceiebifcdedgahcdhhhfj(I):
    objs = objects(I, T, F, T)
    objs_without_smallest = remove(argmin(objs, size), objs) # Remove the smallest object 
    objs_without_extremes = remove(argmax(objs_without_smallest, size), objs_without_smallest) # Remove the largest object from the remaining objects
    second_smallest = argmin(objs_without_extremes, size) # Now the smallest object is actually the second smallest 
    second_largest = argmax(objs_without_extremes, size) # Now the largest object is actually the second largest
    color_a = color(second_smallest)
    color_b = color(second_largest)
    O = replace(I, color_a, color_b) 
    O = replace(O, color_b, color_a)
    return O
 
0.23333333333333336, 4.3249464, def facgcjdehfgfebfjiebbcafhccjdgjfj(I):
  obj1 = next(obj for obj in objects(I, False, False, True) if ulcorner(obj)[0] == 0 and ulcorner(obj)[1] > 0)
  obj2 = next(obj for obj in objects(I, False, False, True) if color(obj) != color(obj1) and size(obj) > 1)
  temp_grid = paint(cover(I, obj1), recolor(color(obj2), toindices(obj1)))
  O = paint(cover(temp_grid, obj2), recolor(color(obj1), toindices(obj2)))
  return O
 
0.24, 4.185272, def bddbbfcbaeedefiebfcccfhbacfafcfd(I):
  objs = objects(I, False, False, True)
  obj1 = min(objs, key=lambda obj: (ulcorner(obj)[0], -ulcorner(obj)[1]))
  obj2 = next((obj for obj in objs if size(obj) > 1 and color(obj) != color(obj1)), 0)
  indices1 = toindices(obj1)
  indices2 = toindices(obj2)
  O = fill(fill(I, color(obj2), indices1), color(obj1), indices2)
  return O
 
0.21333333333333335, 3.186347, def aabijeccfebfeicgaaadbggidbjccagb(I):
  x1 = leastcolor(I)  # Background color
  x2 = objects(I, T, F, T) # Objects excluding background
  x3 = argmax(x2, size) # Largest object
  x4 = color(x3) # Color of the largest object
  x5 = lambda o: recolor(x4, o) if size(o) == 1 else recolor(x1, o) if o == x3 else o # Recolor single-cell objects to largest object color and vice-versa
  O = paint(I, merge(apply(x5, x2))) # Paint the modified objects back onto the grid
  return O
 
0.26666666666666666, 31.225903, def edbfdebcafcjeiaeibfedebgfhbdbcea(I):
  x1 = mostcolor(I) # Background color
  x2 = objects(I, T, F, F)  # All objects including background
  x3 = sizefilter(x2, 1)  # Single-cell objects
  x4 = lambda o: colorcount(o, x1) == size(o) # Function to check if object is single-colored and same as background
  x5 = argmax(x2, lambda o: size(o) if not x4(o) else 0) # Largest object excluding the background
  x6 = color(x5) # Color of the largest object 
  x7 = lambda o: recolor(x6, o) if o in x3 else recolor(x1, o) if o == x5 else o # Recolor as needed
  O = paint(I, merge(apply(x7, x2))) # Paint the modified objects back onto the grid
  return O
 
0.21333333333333335, 5.482283, def gbfcbeabbdfeecjdacjdifcfeeddccdg(I):
  x1 = objects(I, T, F, T)  # All objects excluding background
  x2 = lambda o: (size(o) == 1, -size(o)) # Function to prioritize single-cell objects then by negative size
  x3 = sorted(x1, key=x2) # Sort objects, prioritizing single-cell then by size
  x4 = color(x3[-1]) # Color of the largest object (last in sorted list)
  x5 = lambda o: recolor(x4, o) if size(o) == 1 else recolor(mostcolor(I), o) if o == x3[-1] else o # Recolor as needed
  O = paint(I, merge(apply(x5, x3))) # Paint the modified objects back onto the grid
  return O
 
0.20333333333333334, 5.7357793, def bedhgcgadjbdeddcibcfdaehadccbbfc(I):
  objs = objects(I, False, False, True) # Identify all objects in the grid, excluding background
  for paint in sfilter(objs, lambda o: size(o) == 1): # Iterate through single-cell "paint" objects
    for target in sfilter(objs, lambda o: size(o) > 1 and manhattan(paint, o) == 1): # Find larger objects adjacent to the "paint"
      I = paint(cover(I, target), recolor(color(paint), toindices(target))) # Recolor the "target" object with the "paint" color
  return I
 
0.2333333333333333, 5.323766, def gdbbabecaajjeihbiadfebgjficcgbgi(I):
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if index(I, (i, j)) == mostcolor(I):
        adjacent_colors = {index(I, (i + di, j + dj)) for di in [-1, 0, 1] for dj in [-1, 0, 1] if (di, dj) != (0, 0)}
        paint_colors = {c for c in adjacent_colors if c != mostcolor(I) and colorcount(I, c) == 1}
        if len(paint_colors) == 1:
          I = fill(I, paint_colors.pop(), {(i, j)})
  return I
 
0.20333333333333334, 5.529713, def bgidbhcfbfjcegbfacjdahgfbbeabcbj(I):
  objs = objects(I, T, F, T)  # Get all objects excluding background
  bg_color = mostcommon(I)  # Identify the background color
  filtered_objs = sfilter(objs, lambda obj: color(obj) != bg_color) # Filter out the background object
  sizes = apply(size, filtered_objs)  # Get sizes of all objects
  sorted_objs = order(filtered_objs, lambda obj: size(obj))  # Sort objects by size
  second_smallest = first(remove(first(sorted_objs), sorted_objs))  # Get the second smallest object
  second_largest = first(remove(last(sorted_objs), sorted_objs))  # Get the second largest object
  color_a = color(second_smallest)
  color_b = color(second_largest)
  O = replace(I, color_a, color_b)  # Replace color a with b
  O = replace(O, color_b, color_a)  # Replace color b with a
  return O
 
0.23, 5.3755393, def chgaafcfbafiecjiachcagbfcecbbaab(I):
  objs = objects(I, T, F, T) # Get all objects excluding background
  bg_color = mostcommon(I)  # Identify the background color
  filtered_objs = list(sfilter(objs, lambda obj: color(obj) != bg_color)) # Filter out the background object
  filtered_objs.sort(key=size) # Sort objects by size
  color_a = color(filtered_objs[1]) 
  color_b = color(filtered_objs[-2])
  O = replace(I, color_a, color_b)  # Replace color a with b
  O = replace(O, color_b, color_a)  # Replace color b with a
  return O
 
0.21333333333333335, 5.572832, def haeegbaheegbehiibbiedbbdhaaecdcc(I):
  objs = objects(I, False, False, True)
  objs = sfilter(objs, lambda obj: ulcorner(obj) != (0, 0)) 
  obj1 = min(objs, key=size) 
  color1 = color(obj1)
  objs = sfilter(objs, lambda obj: color(obj) != color1) 
  obj2 = min(objs, key=size) 
  color2 = color(obj2)
  O = paint(cover(I, obj1), recolor(color2, toindices(obj1)))
  O = paint(cover(O, obj2), recolor(color1, toindices(obj2)))
  return O
 
0.2233333333333333, 5.802845, def dfffjdeeiffhedcfafbbcajbjaabagdb(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: (size(obj), ulcorner(obj) != (0, 0)))
  obj1, obj2 = objs[1], next((obj for obj in objs[2:] if color(obj) != color(objs[1])), 0)
  O = fill(I, color(obj2), toindices(obj1))
  O = fill(O, color(obj1), toindices(obj2))
  return O
 
0.19333333333333333, 3.827427, def chjdejdjbfgeedghjbcacbhhchbggcac(I):
  objs = sorted(objects(I, False, False, True), key=size)
  obj1 = next((obj for obj in objs if ulcorner(obj) != (0, 0)), 0)
  color1 = color(obj1)
  obj2 = next((obj for obj in objs if size(obj) > size(obj1) and color(obj) != color1), 0)
  O = I
  for i, j in toindices(obj1):
    if 0 <= i < len(I) and 0 <= j < len(I[0]):
      O = fill(O, color(obj2), {(i, j)})
  for i, j in toindices(obj2):
    if 0 <= i < len(I) and 0 <= j < len(I[0]):
      O = fill(O, color(obj1), {(i, j)})
  return O
 
0.18999999999999997, 3.9772103, def aefddfefacaiecgajdejejfegiihhhia(I):
  def key_func(obj):
    return (size(obj), -ulcorner(obj)[0], -ulcorner(obj)[1])

  objs = sorted(objects(I, False, False, True), key=key_func)

  obj1 = next((obj for obj in objs if ulcorner(obj) != (0,0)), 0)
  obj2 = next((obj for obj in objs if color(obj) != color(obj1) and size(obj) > 1), 0)

  O = paint(cover(I, obj1), recolor(color(obj2), toindices(obj1)))
  O = paint(cover(O, obj2), recolor(color(obj1), toindices(obj2)))
  
  return O
 
0.19333333333333333, 3.736327, def eiadbeifaaeheefdbgjaabaabhgbajad(I):
  objs = objects(I, False, False, True)
  obj1 = min([obj for obj in objs if ulcorner(obj) != (0, 0)], key=lambda obj: (size(obj), ulcorner(obj)[0], ulcorner(obj)[1]))
  obj2 = min([obj for obj in objs if color(obj) != color(obj1) and size(obj) > 1], key=lambda obj: (size(obj), ulcorner(obj)[0], ulcorner(obj)[1]))
  ind1 = toindices(obj1)
  ind2 = toindices(obj2)
  O = fill(fill(I, color(obj2), ind1), color(obj1), ind2)
  return O
 
0.6633333333333332, 45.866478, def aaeefefbaigbeabfiffafbbeeabdhiab(I):
  objs = objects(I, T, F, F)  # Identify all objects
  smallest_obj = argmin(objs, size)  # Find the smallest object
  adjacent_objs = sfilter(objs, lambda obj: adjacent(obj, smallest_obj))  # Find objects adjacent to the smallest object
  recolor_source = extract(objs, lambda obj: obj != smallest_obj and color(obj) != color(smallest_obj)) # Find the first object that isn't the smallest one or its color
  recolored_objs = apply(lambda obj: recolor(color(recolor_source), obj), adjacent_objs)  # Recolor adjacent objects
  return paint(cover(I, merge(adjacent_objs)), merge(recolored_objs))  # Paint recolored objects onto the original image
 
0.2733333333333333, 4.5153875, def ebddfadgicbhedhcjeafgbejhihbacbb(I):
    objs = objects(I, T, F, T)
    bg_color = mostcommon(I)
    filtered_objs = list(sfilter(objs, lambda obj: color(obj) != bg_color))
    filtered_objs.sort(key=size)
    try:
        color_a = color(filtered_objs[1])
        color_b = color(filtered_objs[-2])
        O = paint(paint(cover(I, filtered_objs[1]), recolor(color_b, filtered_objs[1])), filtered_objs[-2])
        O = paint(cover(O, filtered_objs[-2]), recolor(color_a, filtered_objs[-2]))
    except IndexError:
        O = I
    return O
 
0.24666666666666667, 3.5628517, def ccfdjiebaejfebidjaabacjfhbbdefff(I):
  objs = sorted(objects(I, False, False, True), key=size)
  source = objs[-1] 
  target = next((obj for obj in objs if color(obj) != color(source)), 0)
  O = fill(I, color(target), toindices(source))
  O = fill(O, color(source), toindices(target))
  return O
 
0.8666666666666667, 8.109073, def faddcdcabdcfeeibafifdbfefhafiebf(I):
  objs = objects(I, T, F, F) # Find all objects on the grid
  smallest = argmin(objs, size) # Identify the smallest object
  target = extract(objs, lambda obj: adjacent(obj, smallest)) # Find the adjacent object
  return paint(cover(I, target), recolor(color(smallest), target)) # Recolor and paint
 
0.21333333333333335, 6.360706, def bijeecaaaeijeafaihbjcabhhiafiffe(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  single_cell_objs = sizefilter(objs, ONE)
  
  for obj1 in single_cell_objs:
    closest_obj = argmin(objs, lambda obj2: manhattan(obj1, obj2) if obj2 != obj1 else float('inf'))
    I = paint(cover(I, obj1), recolor(color(closest_obj), obj1))
  return I
 
0.20333333333333334, 5.7357793, def bcffcicfjejeeigcjecahbjdfchbcica(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  single_cell_objs = sizefilter(objs, ONE)

  for obj1 in single_cell_objs:
    neighbors =  frozenset({obj2 for obj2 in objs if adjacent(obj1, obj2) and obj2 != obj1})
    closest_obj = argmax(neighbors, size) if neighbors else obj1 # Use original color if no neighbors
    I = paint(cover(I, obj1), recolor(color(closest_obj), obj1))
  return I
 
0.2233333333333333, 5.8104873, def ebhfiffaceibegfaiaccbdjaidhcdcec(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  single_cell_objs = sizefilter(objs, ONE)
  
  for obj1 in single_cell_objs:
    hmatched_objs = frozenset({obj2 for obj2 in objs if hmatching(obj1, obj2) and obj2 != obj1})
    closest_obj = argmax(hmatched_objs, size) if hmatched_objs else argmin(objs, lambda obj2: manhattan(obj1, obj2) if obj2 != obj1 else float('inf'))
    I = paint(cover(I, obj1), recolor(color(closest_obj), obj1))
  return I
 
0.3666666666666667, 8.644094, def iacbfgebfbdeeaceabecdajjebagbibe(I):
    objs = order(objects(I, False, False, True), size)
    obj1, obj2 = objs[-1], objs[-2]
    I = cover(I, obj1)
    I = cover(I, obj2)
    I = paint(I, shift(obj1, gravitate(obj1, obj2)))
    I = paint(I, shift(obj2, gravitate(obj2, obj1)))
    return I
 
0.38333333333333336, 13.46251, def daibbficechdebeeiedffejadicdeiah(I):
  objs = order(objects(I, False, False, True), size)
  obj1, obj2 = objs[-1], objs[-2]
  pos = position(obj1, obj2)
  I = move(I, obj1, multiply(TWO, pos))
  I = move(I, obj2, multiply(NEG_TWO, pos))
  return I
 
0.24000000000000002, 5.4453197, def fdefbgccbbdeeccgaafbdjcabbbididh(I):
    objs = objects(I, T, F, T)
    bg_color = mostcommon(I)
    filtered_objs = list(sfilter(objs, lambda obj: color(obj) != bg_color))
    if len(filtered_objs) <= 2: 
        return I
    filtered_objs.sort(key=lambda obj: len(obj))
    a = color(filtered_objs[1])
    b = color(filtered_objs[-2])
    return tuple(tuple(b if v == a else (a if v == b else v) for v in r) for r in I)
 
0.22333333333333336, 5.068413, def baaddicaecfgehgfigeaeabgcdbfhefg(I):
  objs = objects(I, T, F, T)
  bg_color = mostcommon(I)
  filtered_objs = list(filter(lambda obj: color(obj) != bg_color, objs))
  if len(filtered_objs) <= 2:
      return I
  filtered_objs.sort(key=len)
  a = color(filtered_objs[1])
  b = color(filtered_objs[-2])
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
        if O[i][j] == a:
            O = fill(O, b, {(i, j)})
        elif O[i][j] == b:
            O = fill(O, a, {(i, j)})
  return O
 
0.10666666666666667, 2.78625, def fhdjjebecgejecfdbaejcjbcjeedcbgf(I):
  objs = objects(I, False, False, True)
  source = min(objs, key=lambda obj: (size(obj), ulcorner(obj)[0], ulcorner(obj)[1]))
  target = min(((obj, manhattan(source, obj)) for obj in objs if color(obj) != color(source) and size(obj) > 1), key=lambda x: (x[1], size(x[0]), ulcorner(x[0])[0], ulcorner(x[0])[1]))[0]
  O = paint(cover(I, source), recolor(color(target), toindices(source)))
  O = paint(O, recolor(color(source), toindices(target)))
  return O
 
0.21999999999999997, 5.8328214, def hcejagjddffaehcgaeecabjhfhcfdidd(I):
  objs = sorted(objects(I, False, False, True), key=lambda obj: (size(obj), ulcorner(obj)[0], ulcorner(obj)[1]))
  source_color = color(objs[0])
  target_color = color(objs[1])
  O = fill(fill(I, target_color, ofcolor(I, source_color)), source_color, ofcolor(I, target_color))
  return O
 
0.21333333333333335, 6.9054747, def iiebcabibifbebhdjbbibehcbbcadfgc(I):
  objs = objects(I, T, F, T)
  smallest = min(objs, key=size) 
  rest = objs - {smallest}
  second_smallest = min(rest, key=size)
  new_smallest = recolor(color(second_smallest), smallest)
  O = paint(cover(I, second_smallest), new_smallest)
  return O
 
0.21333333333333335, 5.823083, def caajfhgijceaegbbbbbiagjfdadedgid(I):
  objs = sorted(objects(I, T, F, T), key=size) # Sort by size
  smallest_color = color(objs[0])  # Color of the smallest object
  second_smallest_loc = ulcorner(objs[1])  # Location of the second smallest
  new_smallest = recolor(smallest_color, {(smallest_color, second_smallest_loc)})  # Recolored object at new location
  O = paint(cover(I, objs[1]), new_smallest)  # Paint the modified object
  return O 
 
0.21333333333333335, 6.422097, def bcijhfaddgcjegheijdgfgdacbdcehbd(I):
  objs = list(objects(I, T, F, T))
  objs.sort(key=size)
  if len(objs) > 1:
    target_color = color(objs[1]) 
    smallest_obj = objs[0]
    I = cover(I, objs[1])  
    I = paint(I, recolor(target_color, smallest_obj))
  return I
 
0.2233333333333333, 5.802845, def fgifdhjcbgadeiaaacidbdeddfdhfahe(I):
  objs = objects(I, T, F, T)
  bg_color = mostcommon(I)
  filtered_objs = sorted(sfilter(objs, lambda obj: color(obj) != bg_color), key=len)
  if len(filtered_objs) <= 2:
    return I
  second_smallest_obj = filtered_objs[1]
  third_smallest_obj = filtered_objs[2]
  return tuple(
    tuple(
      color(third_smallest_obj) if (i, j) in toindices(second_smallest_obj) else (
        color(second_smallest_obj) if (i, j) in toindices(third_smallest_obj) else I[i][j]
      )
      for j in range(len(I[0]))
    ) for i in range(len(I))
  )
 
0.2233333333333333, 6.511876, def gfdjdjdbbfagejebagadjbjcdcecibbc(I):
  objs = objects(I, T, F, T)
  bg = mostcommon(I)
  objs = sfilter(objs, lambda obj: color(obj) != bg)
  if len(objs) <= 2:
    return I
  objs = order(objs, lambda obj: len(obj))
  a = color(objs[1])
  b = color(objs[2])
  return replace(replace(I, a, -1), b, a)
 
0.21666666666666667, 5.8382344, def adffdhjfbbgaebifageabbhcabacdjgd(I):
  color_counts = {}
  for color in palette(I):
    if color != mostcommon(I):
      color_counts[color] = colorcount(I, color)
  sorted_colors = sorted(color_counts, key=color_counts.get)
  source_color = sorted_colors[0] 
  target_color = sorted_colors[1]
  O = paint(cover(I, recolor(0, ofcolor(I, source_color))), recolor(target_color, ofcolor(I, source_color)))
  O = paint(O, recolor(source_color, ofcolor(I, target_color)))
  return O 
 
0.20333333333333334, 5.575298, def hiffbbbfjbaieffbbbejaceaddffecff(I):
  objs = objects(I, T, F, T)
  sorted_objs = order(objs, lambda obj: size(obj))
  smallest_obj = first(sorted_objs)
  second_smallest_obj = first(remove(smallest_obj, sorted_objs))
  new_color = color(second_smallest_obj)
  O = paint(cover(I, smallest_obj), recolor(new_color, smallest_obj))
  return O
 
0.24000000000000002, 6.232257, def ibeeefffhgaaejafiacaeddjehcbjgag(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  objs_no_bg = sfilter(objs, lambda obj: color(obj) != bg)
  sorted_objs = order(objs_no_bg, size)
  a = color(sorted_objs[1])
  b = color(sorted_objs[-2])
  return replace(replace(I, a, -1), b, a)
 
0.33666666666666667, 42.44032, def dfcagfbcddffebicjbjadiicaegahcgg(I):
  def get_color_by_size_rank(rank):
    return color(order(objs_no_bg, size)[rank])
  
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  objs_no_bg = sfilter(objs, lambda obj: color(obj) != bg)
  a = get_color_by_size_rank(1)
  b = get_color_by_size_rank(-2)
  return paint(paint(canvas(bg, shape(I)), recolor(a, extract(objs, lambda obj: color(obj) == b))), recolor(b, extract(objs, lambda obj: color(obj) == a)))
 
0.25333333333333335, 3.7437608, def geaehdcjjdfcecaabcaefgbeibeccfjd(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  objs_no_bg = sfilter(objs, lambda obj: color(obj) != bg)
  sorted_objs = order(objs_no_bg, lambda obj: size(obj))
  a = color(sorted_objs[1])
  b = color(sorted_objs[-2])
  obj_a = extract(objs, lambda obj: color(obj) == a)
  obj_b = extract(objs, lambda obj: color(obj) == b)
  return paint(paint(cover(I, obj_a), recolor(b, obj_a)), recolor(a, obj_b))
 
0.2233333333333333, 8.451442, def hbegfeefdbgbehecjbehacjafdejdfce(I):
  p = palette(I) - {mostcommon(I)}
  objs = sorted([recolor(0, obj) for obj in objects(I, False, False, True)], key=lambda obj: size(obj))
  source_obj = objs[1]
  target_obj = objs[2]
  return paint(paint(I, recolor(color(target_obj), source_obj)), recolor(color(source_obj), target_obj))
 
0.20333333333333334, 5.529713, def afcbejbajehhefebijcbfabdadedjfab(I):
  objs = objects(I, T, F, T)
  def obj_size(obj):
    return size(obj)
  smallest_obj = argmin(objs, compfunc=obj_size)
  remaining_objs = objs - {smallest_obj}
  second_smallest_obj = argmin(remaining_objs, compfunc=obj_size)
  new_color = color(second_smallest_obj)
  O = paint(cover(I, smallest_obj), recolor(new_color, smallest_obj))
  return O
 
0.2866666666666666, 5.865015, def ababeceajicjeccfidjifhieeahcgded(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  objs = sfilter(objs, lambda obj: color(obj) != bg)
  obj_sizes = [(size(obj), color(obj)) for obj in objs]
  obj_sizes.sort()
  a = obj_sizes[1][1]
  b = obj_sizes[-2][1]
  new_grid = [[v if v not in [a,b] else {a:b, b:a}[v] for v in row] for row in I]
  return tuple(tuple(row) for row in new_grid)
 
0.21333333333333335, 5.6701326, def hdfccdedfafheecdacigacacfhecbcic(I):
  objs = objects(I, False, False, True)
  color_counts = {}
  for obj in objs:
    c = color(obj)
    if c != mostcommon(I):
      color_counts[c] = color_counts.get(c, 0) + size(obj)
  c1, c2 = sorted(color_counts, key=color_counts.get)[:2]
  O = paint(cover(I, recolor(0, ofcolor(I, c1))), recolor(c2, ofcolor(I, c1)))
  O = paint(O, recolor(c1, ofcolor(I, c2)))
  return O
 
0.20333333333333334, 3.7571049, def edhhagiedebiecefafdbcffjabidbbia(I):
  objs = objects(I, T, F, T)
  sizes = apply(size, objs)
  smallest_size = minimum(sizes)
  second_smallest_size = minimum(difference(sizes, initset(smallest_size)))
  smallest_obj = extract(objs, matcher(size, smallest_size))
  second_smallest_obj = extract(objs, matcher(size, second_smallest_size))
  new_color = color(smallest_obj)
  O = paint(cover(I, second_smallest_obj), recolor(new_color, second_smallest_obj))
  return O
 
0.21333333333333335, 5.749774, def dihiadedidafeefgiefecahgfjebeefe(I):
  objs = objects(I, T, F, T)
  smallest_obj = argmin(objs, size)
  remaining_objs = difference(objs, initset(smallest_obj))
  second_smallest_obj = argmin(remaining_objs, size)
  O = paint(cover(I, second_smallest_obj), recolor(color(smallest_obj), second_smallest_obj))
  return O
 
0.20333333333333334, 5.7357793, def abbabjhgbadjejgcjfegecadeagficid(I):
  objs = sorted(objects(I, False, False, True), key=size)
  objs = [obj for obj in objs if size(obj) > 1]  # Filter out single-cell objects
  if len(objs) >= 2: 
    obj1 = objs[0]
    obj2 = objs[1]
    O = paint(cover(I, obj1), recolor(color(obj2), toindices(obj1)))
    O = paint(cover(O, obj2), recolor(color(obj1), toindices(obj2)))
  else:
    O = I  # No transformation if less than two multi-cell objects
  return O
 
0.21, 5.7307944, def acgaccdcdfaaeggfbbgcbbejhdfgahfi(I):
  objs = objects(I, T, F, T)
  def obj_score(obj):
    return (size(obj), -color(obj)) # Prioritize smaller size, then larger color
  sorted_objs = order(objs, obj_score)
  smallest_obj = first(sorted_objs)
  second_smallest_obj = first(remove(smallest_obj, sorted_objs))
  O = paint(cover(I, smallest_obj), recolor(color(second_smallest_obj), smallest_obj))
  return O
 
0.21333333333333335, 5.8533444, def cbagacbhebebecdcjfgbecefdccajgdg(I):
  def obj_size_color(obj):
    return (size(obj), color(obj)) 
  objs = order(objects(I, T, F, T), obj_size_color)
  smallest = first(objs)
  second_smallest = first(remove(smallest, objs))
  O = paint(cover(I, smallest), recolor(color(second_smallest), smallest))
  return O
 
0.33666666666666667, 75.47546, def hdddeghehfbgebfjigaigbeeecgjhiaa(I):
  corner_obj = toobject(asindices(crop(I, ORIGIN, UNITY)), I)  # Get corner object
  largest_obj = argmax(objects(I, False, False, False), size)  # Get largest object
  corner_color = color(corner_obj)  # Get corner object color
  largest_color = color(largest_obj) # Get largest object color
  I = paint(cover(I, corner_obj), recolor(largest_color, corner_obj)) # Paint largest_color at corner_obj location
  I = paint(I, recolor(corner_color, largest_obj)) # Paint corner_color at largest_obj location
  return I
 
0.2733333333333333, 4.5061665, def egaabgbbhcdeedghjfbhcfaeffagdhjd(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  objs_no_bg = [obj for obj in objs if color(obj) != bg]
  objs_no_bg.sort(key=lambda obj: len(obj))
  second_smallest, second_largest = objs_no_bg[1], objs_no_bg[-2]
  I = paint(I, recolor(color(second_largest), second_smallest))
  I = paint(I, recolor(color(second_smallest), second_largest))
  return I
 
0.24333333333333337, 19.819511, def jcaabahdbdgfeabcjhifbdbbccabcdce(I):
  objs = sorted(objects(I, False, False, True), key=size, reverse=True)  # Sort by size, largest first
  obj1 = objs[0] if len(objs) > 0 else None
  obj2 = objs[1] if len(objs) > 1 else None
  if obj1 is not None and obj2 is not None:
    temp = paint(cover(I, obj1), recolor(color(obj1), toindices(obj2)))  # Swap using a temporary grid
    return paint(cover(temp, obj2), recolor(color(obj2), toindices(obj1))) 
  else:
    return I
 
