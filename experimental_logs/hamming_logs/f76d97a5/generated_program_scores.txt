19.333333333333332, 6.0213065, def hdebieacdicaecfejijjbgeagbbibibf(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True) # find all objects, excluding background
  largest_obj = argmax(objs, size) # find the largest object
  border_indices = delta(toindices(largest_obj)) # get the border indices
  filled_grid = fill(I, bg, border_indices) # fill border indices with background color
  O = paint(filled_grid, recolor(leastcolor(I), largest_obj)) # paint the largest object with the least common color
  return O
 
11.0, 22.215425, def ccabgcdaaehbeadfbaeebjdjjcficabf(I):
  obj = argmax(objects(I, False, False, True), size) # find largest object, excluding background
  indices = toindices(obj) # get indices of the object
  border =  box(indices) - indices # find border by subtracting object from its bounding box
  O = fill(I, ZERO, difference(asindices(I), border)) # fill everything except the border with 0
  return O
 
19.333333333333332, 5.615888, def cdbbjdjafeejeajbaidhfhdhbbdejeie(I):
  bg = mostcolor(I)
  objs = objects(I, F, F, T)
  obj = argmax(objs, size)
  outer =  outbox(toindices(obj))
  inner = inbox(toindices(obj))
  border = outer | inner
  O = paint(fill(I, bg, border), obj) 
  return O
 
18.0, 39.056145, def ggbhcjecehccefihjafdjcafjbidadgd(I):
  cross_color = leastcolor(I)  
  I = replace(I, cross_color, 0) 
  O = canvas(cross_color, shape(I))
  return O
 
8.666666666666666, 5.202963, def jghfgejhabfeeeifiehicegffcfejejb(I):
  cross_color = leastcolor(I)
  O = canvas(cross_color, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != cross_color:
        O = fill(O, 0, {(i, j)})
  return O
 
16.333333333333332, 38.585304, def gdbfdcgehjfgeiehaaehaecbbebeddia(I):
  objs = objects(I, False, False, False)
  cross_obj = argmin(objs, size)
  cross_color = color(cross_obj)
  O = canvas(cross_color, shape(I))
  for obj in objs - {cross_obj}:
    O = underpaint(O, recolor(0, obj))
  return O
 
3.0, 2.8200402, def jegafbhedbbbeacgiffhabefcgfffeee(I):
    cross_color = leastcolor(I)
    bg = mostcolor(I)
    I = replace(I, bg, 0) 
    I = replace(I, cross_color, bg)
    O = canvas(cross_color, shape(I))
    O = underpaint(O, asobject(I))
    return O
 
15.666666666666666, 22.145172, def gcibabcabfedechfbfjbcbibdbaejcda(I):
    # 1. Identify the background color.
    bg = mostcolor(I) 
    
    # 2. Find all objects in the grid (excluding the background).
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    
    # 3. Process each object individually.
    new_objs = set()
    for obj in objs:
        # 4. Find the indices forming the "border" of the object.
        border = box(toindices(obj)) 
        
        # 5. Shift the border inwards.
        shifted_border = shift(border, (-1, -1))  
        
        # 6. Create a new object by combining the shifted border and the original object.
        new_obj = toobject(shifted_border, I)
        new_objs.add(new_obj)
    
    # 7. Create a canvas filled with the background color.
    O = canvas(bg, shape(I))
    
    # 8. Paint the new objects onto the canvas.
    for obj in new_objs:
        O = paint(O, obj)
        
    return O
 
14.333333333333334, 36.78955, def eebaahfcbajjebcibehcbdaegbcedhdb(I):
    bg = mostcolor(I)
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    new_objs = set()
    for obj in objs:
        # Find the indices inside the border of the object.
        inner = delta(toindices(obj))
        new_obj = toobject(inner, I)
        new_objs.add(new_obj)
    O = canvas(bg, shape(I))
    for obj in new_objs:
        O = paint(O, obj)
    return O
 
17.333333333333332, 14.334921, def gcibfcgibeadebeajdfbdfigbfhafjaa(I):
    bg = mostcolor(I)
    h, w = len(I), len(I[0])
    # Shift each cell diagonally if it's not a background color
    O = tuple(tuple(I[i+1][j+1] if I[i][j] != bg and 0 <= i+1 < h and 0 <= j+1 < w else bg for j in range(w)) for i in range(h))
    return O
 
17.0, 13.3393, def hjeebdaacidaefhgahbcdjeaffdbdeda(I):
    bg = mostcolor(I)
    trimmed = crop(I, (1, 1), (len(I) - 2, len(I[0]) - 2))
    top = tuple(bg for _ in range(len(I[0])))
    bottom = tuple(bg for _ in range(len(I[0])))
    left = tuple((bg,) for _ in range(len(trimmed)))
    right = tuple((bg,) for _ in range(len(trimmed)))
    O = vconcat(vconcat((top,), hconcat(hconcat(left, trimmed), right)), (bottom,))
    return O
 
17.333333333333332, 6.1989512, def hhhabeicdaicejaeibagfcgfejabebff(I):
    objs = fgpartition(I)
    bg = mostcolor(I)
    new_objs = frozenset()
    for obj in objs:
      center_cell = centerofmass(obj)
      shifted_obj = shift(obj, subtract((1,1), center_cell))
      new_objs = combine(new_objs, shifted_obj)
    O = paint(canvas(bg, shape(I)), new_objs) 
    return O
 
16.666666666666668, 11.22379, def fegbfghacfggejeeiiefbbgfafchffei(I):
  objs = fgpartition(I)
  bg = mostcolor(I)
  new_grid = canvas(bg, shape(I))
  for obj in objs:
    indices = toindices(obj)
    for i, j in indices:
      if (i, j) == centerofmass(obj):
        new_grid = fill(new_grid, index(I, (i,j)), {(i - 1, j - 1)})
      else:
        new_grid = fill(new_grid, index(I, (i,j)), {(i + 1, j + 1)})
  O = new_grid
  return O
 
19.333333333333332, 8.293192, def igeabbidddiheeaaiehjbccefdjcefei(I):
    objs = fgpartition(I)
    bg = mostcolor(I)
    O = I
    for obj in objs:
        for d in [(1, 1), (-1, -1)]:
            shifted_obj = shift(obj, d)
            O = underpaint(O, shifted_obj)
    return O
 
19.666666666666668, 6.0192766, def fcjbcddcfhjgeggbjfdcaacecghjdigc(I):
  x1 = objects(I, T, F, T)  # Extract objects, no diagonals, without background
  x2 = apply(box, x1)       # Get the bounding box indices for each object
  x3 = merge(x2)             # Merge all bounding box indices
  x4 = toobject(x3, I)       # Create an object from the bounding box indices and grid values
  x5 = cover(I, x4)         # Cover the original grid with background color at bounding box locations
  O = paint(x5, x4)         # Paint the bounding box object onto the covered grid
  return O
 
14.666666666666666, 6.188231, def ffaaaaefhgdjejhaicfdddjgbhbfggff(I):
  x1 = objects(I, T, F, T) 
  x2 = apply(delta, x1)    # Get indices inside the bounding box but not part of the object 
  x3 = merge(x2)            
  O = fill(I, 0, x3)        # Directly fill the delta indices with '0'
  return O
 
19.666666666666668, 6.589008, def cccgaedcdiafeecjbaeccbebgbfcaffa(I):
  x1 = objects(I, T, F, T)
  x2 = apply(lambda p: toindices(p) - corners(p), x1) # Remove corner indices from each object
  x3 = merge(x2)
  O = fill(I, 0, x3)
  return O
 
13.333333333333334, 4.4297214, def adfbeeaadbgbeciaicfidgdcgfebebaj(I):
    x1 = asindices(I)
    x2 = objects(I, T, T, F)
    x3 = argmax(x2, size)
    x4 = toindices(x3)
    x5 = difference(x1, x4)
    x6 = fill(I, ZERO, x5)
    O = x6
    return O
 
7.333333333333333, 5.6156526, def bcefieafieededeejfcadbddbcfgebhe(I):
    x1 = asindices(I)
    x2 = objects(I, T, T, F)
    x3 = lambda obj: len(intersection(toindices(obj),  dneighbors(centerofmass(obj)))) > 0 
    x4 = extract(x2, x3) 
    x5 = toindices(x4)
    x6 = difference(x1, x5)
    x7 = fill(I, ZERO, x6)
    O = x7
    return O
 
7.666666666666667, 18.62401, def fdficcebcdjaedgcaajebffebbehgdgb(I):
    x1 = objects(I, T, T, F)
    x2 = lambda obj: len(obj) - sum(1 for _ in neighbors(centerofmass(obj)) if index(I, _) == mostcolor(I))
    x3 = argmin(x1, x2) 
    x4 = paint(canvas(ZERO, shape(I)), x3)
    O = x4
    return O
 
16.666666666666668, 6.2789817, def abeicfdafibbebcgiefiddijddcbehbf(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    ordered = order(objs, size)
    h, w = shape(I)
    O = canvas(bg, (h, w))
    offset = (0, 0)
    for obj in ordered:
      O = paint(O, shift(normalize(obj), offset))
      offset = (offset[0] + 1, offset[1] + 1) 
    return O
 
17.0, 6.2737927, def fhibhacfeggfeiibbbddjhaccdhfbgej(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  diag = {(i, i) for i in range(len(I))}
  O = canvas(bg, shape(I))
  for i, obj in enumerate(objs):
    O = paint(O, shift(normalize(obj), (i, i)))
  return O
 
17.0, 10.999482, def gijabjfchbcgeaffbfhhaibadjaaadhc(I):
    bg = mostcolor(I)
    objs = sorted(objects(I, True, False, True), key=size)
    O = canvas(bg, shape(I))
    for i, obj in enumerate(objs):
        O = paint(O, shift(obj, (i, i)))
    return O
 
15.333333333333334, 17.343508, def ffbacfebgdaaeejcjfbdacaccaghffea(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    O = canvas(bg, shape(I))
    for i, obj in enumerate(objs):
      for j, (v, (x, y)) in enumerate(obj):
        O = paint(O, {(v, (x + i + j, y + i + j))})
    return O
 
17.0, 9.640079, def ihbfcdbfbbadegdcaidegaddjgfbeifa(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  dilated_objs = mapply(lambda obj: merge(apply(lambda d: shift(obj, d), ((0,1),(0,-1),(1,0),(-1,0)))), objs)
  return paint(canvas(bg, shape(I)), dilated_objs) 
 
16.666666666666668, 9.330351, def gdfbajdbbgbceefaiigbfdfgfffddcbh(I):
    objs = fgpartition(I)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    for x in range(2):
        for obj in objs:
            O = underpaint(O, shift(obj, (1 - 2*x, 0)))
            O = underpaint(O, shift(obj, (0, 1 - 2*x)))
    return O
 
16.666666666666668, 9.206647, def hiffjacahcaeeejcbacdcfddeaacccdd(I):
    bg = mostcolor(I)
    objs = fgpartition(I)
    O = canvas(bg, shape(I))
    for obj in objs:
        for dx in range(-1, 2):
            for dy in range(-1, 2):
                if abs(dx) != abs(dy): # Avoid diagonal expansion
                    O = underpaint(O, shift(obj, (dx, dy)))
    return O
 
14.666666666666666, 6.056247, def gfecffedgeccecdcaghicbejafadcbjg(I):
  x1 = objects(I, T, F, T) # Identify all objects in the grid
  x2 = apply(backdrop, apply(toindices, x1)) # Get the bounding box of each object 
  x3 = merge(x2) # Merge all bounding box indices
  x4 = difference(x3, merge(apply(toindices, x1))) # Remove object indices to get the outline
  O = fill(I, 0, x4) # Fill outline indices with '0'
  return O
 
18.0, 7.6083527, def fhaiafcfjdjeegiejgjchbdaccfaeadb(I):
  x1 = objects(I, T, F, T) # Identify all objects
  x2 = apply(lambda obj: difference(outbox(obj), inbox(obj)), x1) # Calculate outline using outbox and inbox
  O = fill(I, 0, merge(x2)) # Fill outline with '0'
  return O
 
15.666666666666666, 11.185517, def dbdfdegfedcdebeejedbhhaiaaahibab(I):
  # Find the largest object
  x1 = objects(I, T, T, F)
  x2 = argmax(x1, size)
  
  # Get the object's color
  x3 = color(x2) 
  
  # Create a blank canvas
  x4 = canvas(ZERO, shape(I))
  
  # Paint the outline of the object
  O = paint(x4, recolor(x3, box(toindices(x2)))) 
  return O
 
13.333333333333334, 11.461078, def beeaeeadgjabeajhaeebfdadehefchjc(I):
  # Find the largest object
  x1 = objects(I, T, T, F)
  x2 = argmax(x1, size)
  
  # Extract color and indices of the object
  x3 = color(x2)
  x4 = toindices(x2)
  
  # Generate outline indices
  x5 = outbox(x4) | inbox(x4) 
  
  # Paint the outline and fill the rest with 0
  O = paint(fill(canvas(ZERO, shape(I)), x3, x5), recolor(x3, x4))
  return O
 
17.333333333333332, 18.082039, def dbfffeiebbdeeejjjdcbafdjdffefebb(I):
  # Find the largest object
  x1 = objects(I, T, T, F)
  x2 = lambda x: len(toindices(x))
  x3 = argmax(x1, x2)
  
  # Find its color
  x4 = color(x3)
  
  # Create a blank canvas
  x5 = canvas(ZERO, shape(I))
  
  # Paint the object onto the canvas
  x6 = paint(x5, x3)
  
  # Calculate and paint the outline
  O = paint(x6, recolor(x4, difference(box(toindices(x3)), toindices(x3)))) 
  return O
 
17.0, 8.275883, def hfdjcgfcecaaecgabajhiebebfdifaii(I):
  # Find the largest object and its color
  x1 = objects(I, T, T, F)
  x2 = argmax(x1, size)
  x3 = color(x2)
  
  # Create the output by directly modifying the input
  O = fill(replace(I, x3, ZERO), x3, box(toindices(x2)))
  return O
 
11.333333333333334, 11.786917, def babfbeefgagjeahjjggeaghiccedbhbi(I):
  """
  Directly modifies the input grid, replacing non-cross values with 0.
  """
  cross_color = mostcommon(I)
  h, w = len(I), len(I[0])
  
  for i in range(h):
    for j in range(w):
      if i != h // 2 and j != w // 2:
        I = fill(I, 0, {(i, j)})
        
  return I
 
16.666666666666668, 18.951103, def efadfjhdfdcdeaieacdeaihdjbhafedc(I):
  bg = mostcolor(I)
  obj = leastcommon(merge(I))
  objs = objects(I, True, False, True)
  target_obj = extract(objs, lambda o: color(o) == obj)
  shifted_obj = shift(target_obj, (1, 1))
  O = paint(canvas(bg, shape(I)), shifted_obj)
  return O
 
17.0, 10.695928, def fddbdbgahedfedebiffabicgbafebeeg(I):
  bg = mostcolor(I)
  fg = leastcolor(I)
  locs = ofcolor(I, fg)
  shifted_locs = shift(locs, (1, 1))
  O = paint(canvas(bg, shape(I)), recolor(fg, shifted_locs))
  return O
 
19.666666666666668, 6.0192766, def dejhfidffaahecjabacaafhiicdeifgb(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    for x, (i, j) in obj:
      if any((i+di, j+dj) not in toindices(obj) for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]):
        O = paint(O, {(x, (i, j))})
  return O
 
14.0, 38.354237, def agbhjhccfbafefjejfabcejccafecedh(I):
  bg = mostcolor(I)
  objs = fgpartition(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    outline = toindices(obj) & outbox(obj)
    O = paint(O, recolor(color(obj), outline))
  return O
 
11.333333333333334, 14.534619, def gbefbbcigcdhebbbigdfbbhgedaecifb(I):
  x1 = partition(I) # Partition the grid into objects
  x2 = apply(lambda obj: frozenset(i for v, i in obj if any(n in asindices(I) and index(I, n) != v for n in dneighbors(i))), x1)
  # Get indices of cells with different-valued neighbors
  O = fill(I, 0, merge(x2)) # Fill those indices with '0'
  return O
 
12.333333333333334, 9.024128, def ehbaebibheabehedacfbijfbfbbfffcd(I):
  x1 = apply(lambda r: tuple(0 if (j > 0 and r[j-1] != r[j]) or (j < len(r)-1 and r[j+1] != r[j]) else r[j] for j in range(len(r))), I) 
  # Horizontal outline detection
  x2 = apply(lambda c: tuple(0 if (i > 0 and c[i-1] != c[i]) or (i < len(c)-1 and c[i+1] != c[i]) else c[i] for i in range(len(c))), dmirror(I)) 
  # Vertical outline detection
  O = cellwise(x1, dmirror(x2), mostcolor(I)) # Combine horizontal and vertical outlines
  return O
 
18.0, 14.963595, def fieffhbebbdgedfiiaaaccaacgcdjibc(I):
    # Find the largest object
    obj = argmax(objects(I, T, F, T), size)
    
    # Get object color and grid dimensions
    color = mostcolor(obj)
    h, w = shape(I)
    
    # Create a canvas filled with the background color
    O = canvas(mostcolor(I), (h, w))
    
    # Paint the object at each edge
    O = paint(O, shift(obj, (0, 0)))  # Top edge
    O = paint(O, shift(obj, (h-1, 0)))  # Bottom edge
    O = paint(O, shift(obj, (0, w-1)))  # Right edge
    O = paint(O, shift(obj, (0, 0)))  # Left edge 
    return O
 
16.0, 24.944452, def bheagjdjedbaefjjjfcfbceiajajfifj(I):
    # Find largest object and its indices
    obj = argmax(objects(I, T, F, T), size)
    indices = toindices(obj)
    
    # Create a set of edge indices
    h, w = shape(I)
    edges = set((i, j) for i in range(h) for j in range(w) 
                 if i == 0 or i == h - 1 or j == 0 or j == w - 1)
    
    # Find the intersection between object and edge indices
    overlap = edges & indices
    
    # Create output by painting the object only at overlapping indices
    O = canvas(mostcolor(I), shape(I))
    O = paint(O, recolor(mostcolor(obj), overlap)) 
    return O
 
16.666666666666668, 17.63238, def idjdidabdbdfeebbbacbhgdfadbbgfdg(I):
  # Identify largest object and its color
  largest_obj = argmax(objects(I, T, F, T), size)
  obj_color = mostcolor(largest_obj)
  
  # Create a function to check if an index is on the edge
  h, w = shape(I)
  is_edge = lambda i, j: i == 0 or i == h-1 or j == 0 or j == w-1 

  # Create output grid by painting the object color only at edge locations
  O = canvas(mostcolor(I), shape(I))
  for i in range(h):
    for j in range(w):
      if is_edge(i, j) and (I[i][j] == obj_color or ((i, j)) in toindices(largest_obj)):
        O = fill(O, obj_color, {(i, j)})
  return O
 
16.333333333333332, 15.563509, def bhhdcigbbadgeaagiehfgjcggaehfdbg(I):
  # Get the largest object
  obj = argmax(objects(I, T, F, T), size)
  
  # Get the bounding box of the object
  bbox = backdrop(obj)
  
  # Create a set of indices for the four edges of the grid
  h, w = shape(I)
  top = {(0, j) for j in range(w)}
  bottom = {(h-1, j) for j in range(w)}
  left = {(i, 0) for i in range(h)}
  right = {(i, w-1) for i in range(h)}
  
  # Find the overlapping indices between the object's bounding box and each edge
  top_overlap = bbox & top
  bottom_overlap = bbox & bottom
  left_overlap = bbox & left
  right_overlap = bbox & right
  
  # Create a canvas filled with the background color
  O = canvas(mostcolor(I), (h, w))
  
  # Paint the object's color on the overlapping indices for each edge
  O = fill(O, mostcolor(obj), top_overlap)
  O = fill(O, mostcolor(obj), bottom_overlap)
  O = fill(O, mostcolor(obj), left_overlap)
  O = fill(O, mostcolor(obj), right_overlap)
  
  return O
 
16.333333333333332, 9.474349, def efabbafeefdhedifigdjceicddchdbdg(I):
  # Get the largest object
  obj = argmax(objects(I, T, F, T), size)
  
  # Create a canvas filled with the background color
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  
  # Iterate through each cell of the object
  for v, (i, j) in obj:
    # Calculate the new positions for the object on each edge
    top_pos = (0, j)
    bottom_pos = (h-1, j)
    left_pos = (i, 0)
    right_pos = (i, w-1)
    
    # Paint the object on each edge at the new positions
    O = paint(O, {(v, top_pos)})
    O = paint(O, {(v, bottom_pos)})
    O = paint(O, {(v, left_pos)})
    O = paint(O, {(v, right_pos)})
    
  return O
 
19.666666666666668, 6.0192766, def fafiacfiecdceadgjgfagdajedccbddc(I):
  """
  Identifies the object with the least frequent color and paints it on a canvas of the most frequent color.
  """
  bg_color = mostcolor(I) 
  object_color = leastcolor(I)
  O = canvas(bg_color, shape(I))
  object_indices = ofcolor(I, object_color)
  O = fill(O, object_color, object_indices)
  return O
 
16.666666666666668, 18.39476, def ffbfdebdieiiegghacfejjaadfccdbfi(I):
  """
  Uses object recognition to extract and paint the object.
  """
  objs = objects(I, True, True, False)
  target_obj = min(objs, key=size)
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I))
  O = paint(O, target_obj) 
  return O
 
15.666666666666666, 9.096185, def acjbdgfajacfebffbcebbbfdbafahbee(I):
  bg = mostcolor(I)  # Identify background color
  objs = fgpartition(I)  # Partition into foreground objects
  outlines = mapply(box, objs)  # Extract outlines of objects
  O = fill(I, bg, asindices(I))  # Create canvas filled with background color
  O = underpaint(O, recolor(leastcolor(I), outlines))  # Paint outlines with least frequent color
  return O
 
19.666666666666668, 6.0192766, def ifhgjiigedbaeghcacfddiaaffhcfddf(I):
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if any(index(I, n) != val for n in dneighbors((i, j))):
        O = fill(O, val, {(i, j)})
  return O
 
18.666666666666668, 17.840328, def caiaebgffiiiejafbgcbdcigecfeafca(I):
  cross =  frozenset({(1, 0), (0, 1), (1, 1), (1, 2), (2, 1)}) 
  fill_color = leastcolor(I)
  O = canvas(fill_color, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i,j) in shift(cross,(1,1)):
        O = fill(O, val, {(i, j)})
  return O
 
19.666666666666668, 6.9738145, def cdjheacheeffecccaigfcgaihfeddedh(I):
  h, w = len(I), len(I[0])
  fill_color = leastcolor(I)
  O = canvas(fill_color, (h, w))
  for i in range(h):
    for j in range(w):
      if i == h // 2 or j == w // 2: 
        O = fill(O, I[i][j], {(i, j)})
  return O
 
18.666666666666668, 5.7085385, def dfajibdbhcjgeccfjhdegabdjdfbgffd(I):
  """
  Identifies the object with the least common color and shifts it diagonally.
  """
  least_color = leastcolor(I)
  target_object = extract(objects(I, True, False, True), lambda obj: color(obj) == least_color)
  shifted_object = shift(target_object, (1, 1))  # Diagonal shift
  O = underpaint(fill(I, mostcolor(I), toindices(target_object)), shifted_object)
  return O
 
19.333333333333332, 8.096925, def dbdeaafejfahehacbfgcijgccdfafaeb(I):
  """
  Iterates through the grid and shifts individual cells of the target color.
  """
  least_color = leastcolor(I)
  h, w = len(I), len(I[0])
  O = tuple(tuple(least_color if i > 0 and j > 0 and I[i-1][j-1] == least_color else v for j, v in enumerate(row)) for i, row in enumerate(I))
  return O
 
7.333333333333333, 37.213856, def adfgeeagjdefeffcagibbeefbeficidg(I):
    bg = mostcolor(I)  
    objs = objects(I, T, F, T) 
    filtered_objs = colorfilter(objs, bg)
    merged_obj = merge(filtered_objs)
    O = fill(I, 0, asindices(I))
    O = paint(O, merged_obj)
    return O
 
18.333333333333332, 4.2672343, def eabcbbddabaiehfhbjbbecggaffgcdac(I):
    bg = mostcolor(I)
    indices = ofcolor(I, bg)
    O = fill(I, 0, asindices(I)) 
    O = fill(O, bg, indices) 
    return O
 
14.0, 38.354237, def hbageicjjhbbegfcbjfccdifbfdbhbgh(I):
  O = I # Initialize output grid
  for obj in objects(I, T, F, T): # Iterate over objects
    indices = toindices(obj) 
    inner_indices = frozenset(i for i in indices if all(n in indices for n in dneighbors(i)))
    # Find indices completely surrounded by the same object
    for i, j in difference(indices, inner_indices): # Iterate over outer indices
      O = fill(O, mostcolor(I), {(i, j)}) # Fill outer indices with background color
  return O
 
16.666666666666668, 18.901953, def fcbbbiiiiaceebabbabagddhhadcfaii(I):
  x1 = objects(I, T, F, T) # Identify all objects
  x2 = merge(apply(lambda obj: toindices(obj) - inbox(toindices(obj)), x1))
  # Get all indices of the objects minus their "inboxes" (one layer inside)
  O = fill(I, mostcolor(I), x2) # Fill these outer indices with background color
  return O
 
17.666666666666668, 10.600246, def bhejcacbadjfebfajhfdfgicfaecfcba(I):
  """
  Constructs the central cross directly using canvas and paint operations.
  """
  fill_color = leastcolor(I)
  h, w = shape(I)
  center_row = h // 2
  center_col = w // 2
  O = canvas(fill_color, (h, w))
  vertical_line = recolor(I[center_row][0], {(i, center_col) for i in range(h)})
  horizontal_line = recolor(I[0][center_col], {(center_row, j) for j in range(w)})
  O = paint(O, vertical_line)
  O = paint(O, horizontal_line)
  return O
 
38.333333333333336, 34.23625, def hbjfhdjbhdbheddajbafjfjibihcbifj(I):
  mc = mostcolor(I) 
  lc = leastcolor(I)
  objs = objects(I, T, F, T)
  central_obj = extract(objs, matcher(color, lc))
  shifted_obj = shift(central_obj, (1,1))
  canvas_dims = (height(I) + 2, width(I) + 2)
  O = paint(fill(canvas(mc, canvas_dims), lc, toindices(shifted_obj)), {(lc, (0, 0))}) 
  return O
 
38.666666666666664, 38.25113, def cgffadbdbcfbefadbaiedaffcagebdcc(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  O = paint(fill(canvas(mc, add(shape(I), (2,2))), lc, backdrop(shift(ofcolor(I, lc), (1,1)))), {(lc, (0, 0))})
  return O
 
38.333333333333336, 37.45017, def cdighidbedaeedabbcigechbbdchadeb(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  obj_indices = toindices(extract(objects(I, T, F, T), matcher(color, lc)))
  framed_indices =  backdrop(shift(obj_indices, (1,1)))
  O = paint(fill(canvas(mc, add(shape(I), (2, 2))), lc, framed_indices), {(lc, (0, 0))})
  return O
 
16.0, 14.767266, def fbcgdebabbfaeeedbcacjefeccdecdee(I):
  bg = mostcolor(I)
  obj = next(iter(objects(I, T, F, T)))
  O = fill(I, bg, asindices(I))
  O = paint(O, recolor(color(obj), box(obj)))
  return O
 
13.666666666666666, 7.0358057, def adbjaajibhfieajaababecfabiacighj(I):
  bg = mostcolor(I)
  obj = next(iter(objects(I, T, F, T)))
  outline = mapply(lambda loc: dneighbors(loc) | ineighbors(loc), toindices(obj)) - toindices(obj)
  O = fill(I, bg, asindices(I))
  O = paint(O, recolor(color(obj), outline))
  return O
 
14.333333333333334, 23.074495, def eeecjgibebcceecgiahdfdjehccgdabd(I):
  bg = mostcolor(I)
  obj = next(iter(objects(I, T, F, T)))
  O = fill(I, bg, asindices(I))
  O = paint(O, recolor(color(obj), delta(obj)))
  return O
 
16.666666666666668, 17.63238, def icbbadhceabdeebjaffjgiiabfbehecc(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if any(index(I, (i+di,j+dj)) != bg and index(I, (i+di,j+dj)) != I[i][j] for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]):
        O = paint(O, {(I[i][j], (i,j))})
  return O
 
17.333333333333332, 15.149175, def abdechejdccfeaghagfdhbidcbidaifc(I):
  bg = mostcolor(I)
  obj = next(iter(objects(I, T, F, T)))
  O = paint(canvas(bg, shape(I)), recolor(color(obj), toindices(obj)))
  for i, j in toindices(obj):
    if any(index(O, (i+di, j+dj)) == bg for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]):
      O = paint(O, {(color(obj), (i,j))})
  return O
 
12.666666666666666, 12.329359, def daffecjbdfciedbfbbgabbhhabaaecch(I):
    O = canvas(mostcolor(I), shape(I)) # Create an empty canvas
    for obj in objects(I, T, F, T): # Iterate over objects
        for cell in toindices(obj):
            neighbors_set = dneighbors(cell) # Get neighboring cells
            for n in neighbors_set:
                if n not in toindices(obj) and 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]):
                    O = fill(O, I[cell[0]][cell[1]], {n}) # Fill the neighbor with object color if it's not part of the object
    return O
 
14.333333333333334, 9.641716, def dhgaaihcdaebefcbjhagjfgfidabdecc(I):
  """
  Iterates through each cell and colors it based on whether it's part of the central cross or not.
  """
  cross_color = leastcolor(I)
  bg_color = mostcolor(I)
  h, w = shape(I)
  O = canvas(bg_color, (h, w))
  for i in range(h):
    for j in range(w):
      if i == h//2 or j == w//2:
        O = paint(O, {(cross_color, (i, j))})
  return O
 
18.0, 39.056145, def agbiddajdiabefjbabcbafbefffcjjgf(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  O = paint(fill(canvas(mc, shape(I)), lc, asindices(I)), recolor(lc, mapply(lambda obj: box(toindices(obj)), colorfilter(objects(I, False, False, False), lc))))
  return O
 
38.666666666666664, 29.04653, def cadddjaajbaeecjhabfcfacbdhcfddba(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  framed_grid = fill(canvas(mc, (height(I) + 2, width(I) + 2)), lc, 
                      {(i + 1, j + 1) for i in range(height(I)) for j in range(width(I)) if I[i][j] == lc})
  O = paint(framed_grid, {(lc, (0, 0))})
  return O
 
19.666666666666668, 8.13307, def fjihbefiacedeiccacdfdbdcdgdcjhdd(I):
    bg = mostcolor(I)
    objs = objects(I, F, F, T)
    O = I
    for obj in objs:
        if color(obj) != bg:
            O = paint(O, recolor(leastcolor(I), box(obj)))
        else:
            O = cover(O, obj)
    return O
 
16.0, 16.381317, def icccfaafaaifeeeajfcfdideeajijjde(I):
  bg_color = mostcolor(I)
  h, w = len(I), len(I[0])
  return tuple(
      tuple(
        I[i][j] if i == h // 2 or j == w // 2 else bg_color 
        for j in range(w)
      ) 
      for i in range(h)
  )
 
15.0, 22.351828, def cgieeffcdcfaecehjdjbeiheeghacacd(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  objs = objects(I, False, False, False)
  O = fill(canvas(mc, shape(I)), mc, asindices(I))  # Create a canvas filled with the most common color
  for obj in objs:
    if color(obj) == lc:  # If the object's color is the least common color
      O = paint(O, recolor(lc, box(toindices(obj))))  # Paint the object's outline onto the canvas
  return O
 
18.333333333333332, 13.884766, def eabbchdfebfjefcbjbfdbgaahdhiaibf(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  O = replace(I, lc, mc)  # Replace all instances of the least common color with the most common color
  for i, j in ofcolor(I, lc):  # Iterate over the locations of the least common color in the original grid
      for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]:  # Check adjacent cells in four directions
        if 0 <= i+di < height(I) and 0 <= j+dj < width(I) and I[i+di][j+dj] == lc:
          O = paint(O, {(lc, (i,j))})  # If an adjacent cell also had the least common color, paint the current cell on the output grid
          break  # Only paint the cell once
  return O 
 
15.666666666666666, 23.801975, def eeeebfbceijaeecbaccfgfdgjhdfibab(I):
    mc = mostcolor(I)
    lc = leastcolor(I)
    objs = objects(I, False, False, False)
    filtered_objs = colorfilter(objs, lc)
    shifted_objs = apply(lambda obj: shift(obj, (1,1)), filtered_objs)  # Shift each filtered object diagonally
    O = paint(fill(canvas(mc, shape(I)), mc, asindices(I)), merge(shifted_objs)) # Paint the shifted objects onto a canvas filled with the most common color
    O = paint(O, merge(apply(lambda obj: recolor(lc, box(toindices(obj))), filtered_objs)))  # Paint the outlines of the original objects onto the canvas
    return O
 
14.0, 38.354237, def bhhcgadagbaieehbideaedcefbeafhjg(I):
  mc = mostcolor(I)
  lc = leastcolor(I)
  O = fill(canvas(mc, shape(I)), mc, asindices(I))
  for obj in objects(I, False, False, False):
    if color(obj) == lc:
      for i, j in delta(toindices(obj)):
        if 0 <= i < height(I) and 0 <= j < width(I):  # Check for valid indices
          if index(I, (i, j)) == lc:
            O = paint(O, {(lc, (i, j))})  # Paint the cell if it's part of the outline
  return O
 
18.0, 5.5370436, def hebfebcigaddecbdbbiifdffbddfcacc(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  frame_cells = mapply(lambda obj: box(obj), objs)
  O = fill(I, bg, asindices(I))
  O = fill(O, 1, frame_cells)
  return O
 
17.333333333333332, 11.689145, def bjdgebfcfecheajbadaeehjjijjdcjfi(I):
  bg = mostcolor(I)
  objs = partition(I)
  frame = lambda obj: difference(backdrop(obj), inbox(obj))
  frame_cells = mapply(frame, objs)
  O = fill(I, bg, asindices(I))
  return paint(O, toobject(frame_cells, I))
 
18.0, 9.086117, def ebiedajhjcfgebabibafdhegggegfafe(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, T):
        for c in box(obj):
            if index(I, c) != mostcolor(I):
                O = fill(O, index(I, c), {c})
    return O
 
14.0, 20.844847, def hdfacegabahbeaeejfcidihjfbcdecef(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  frame = lambda obj: sfilter(backdrop(obj), lambda c: any(n in toindices(obj) for n in neighbors(c)) and c not in toindices(obj))
  frame_cells = mapply(frame, objs)
  return fill(canvas(bg, shape(I)), 1, frame_cells)
 
18.333333333333332, 4.2672343, def edjgiejccbacebhfjcahahajffcccfgd(I):
  """
  Identifies boundary cells of foreground objects and sets them to 0.
  
  - Uses `objects` to get foreground objects.
  - Employs a nested loop to iterate over objects and their boundary cells.
  - Utilizes `index` for efficient grid value retrieval. 
  """
  O = I # Start with the input grid
  for obj in objects(I, T, F, T): # For each foreground object
    for i, j in toindices(obj): # For each cell in the object
      for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]: # Check adjacent cells
        ni, nj = i + di, j + dj # Neighbor indices
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and index(I, (ni, nj)) != index(I, (i, j)): # Check within bounds and different value
          O = fill(O, 0, {(i, j)}) # Set boundary cell to 0
          break # Move to the next cell after finding a different neighbor
  return O
 
7.333333333333333, 37.213856, def hchabgfcabhgecadadgihchdbaaggfff(I):
  """
  Identifies boundary cells by comparing a cell's value with 
  the values of its reconstructed neighbors after padding the grid.
  
  - Uses padding to simplify boundary checks.
  - Leverages list comprehensions for concise code.
  """
  h, w = len(I), len(I[0])
  padded_I = [[0] * (w + 2) for _ in range(h + 2)] # Pad with 0s
  for i in range(h):
    for j in range(w):
      padded_I[i + 1][j + 1] = I[i][j]

  O = [[0] * w for _ in range(h)] # Initialize output grid
  for i in range(h):
    for j in range(w):
      neighbors = [padded_I[i + di][j + dj] for di in [0, 1, 2] for dj in [0, 1, 2] if not (di == 1 and dj == 1)]
      if any(n != I[i][j] for n in neighbors):
        O[i][j] = 0
      else:
        O[i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
14.666666666666666, 7.8011084, def bcfehdjdhdddedbeifcaabcdcfcfdbie(I):
  """
   Identifies boundary cells using a recursive flood fill approach.
  
  - Starts from a background cell and recursively explores connected regions.
  - Marks cells adjacent to different values as boundaries.
  """
  h, w = len(I), len(I[0])
  visited = set()
  O = [[I[i][j] for j in range(w)] for i in range(h)]

  def flood_fill(i, j):
    visited.add((i, j))
    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
      ni, nj = i + di, j + dj
      if 0 <= ni < h and 0 <= nj < w and (ni, nj) not in visited:
        if I[i][j] != I[ni][nj]:
          O[i][j] = 0
        else:
          flood_fill(ni, nj)
  
  for i in range(h):
    for j in range(w):
      if (i, j) not in visited:
        flood_fill(i, j)
  return tuple(tuple(row) for row in O)
 
17.666666666666668, 16.002039, def ifchfbhgbbdbeifbabjgeecabdbfbhef(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  O = canvas(bg, shape(I))
  for cell in toindices(largest_obj):
    if len(intersection(dneighbors(cell), toindices(largest_obj))) < 4:
      O = paint(O, recolor(color(largest_obj), toobject({cell}, I)))
  return O
 
12.333333333333334, 5.9231477, def addbefcbeajfeegfbdieebgbbffgbbhd(I):
    mc = mostcolor(I)
    lc = leastcolor(I)
    objs = partition(I) 
    filtered_objs = colorfilter(objs, lc)
    framed_objs = apply(lambda obj: recolor(lc, delta(toindices(obj))), filtered_objs)
    O = paint(fill(canvas(mc, shape(I)), mc, asindices(I)), merge(framed_objs))
    return O
 
15.333333333333334, 25.457832, def bdeccfhcefbcedahaaggdchiahhdadig(I):
    mc = mostcolor(I)
    lc = leastcolor(I)
    objs = objects(I, False, False, False)
    filtered_objs = colorfilter(objs, lc) 
    inner_boxes = apply(lambda obj: inbox(toindices(obj)), filtered_objs)
    O = fill(canvas(mc, shape(I)), lc, merge(apply(box, inner_boxes)))
    return O
 
8.333333333333334, 7.9031615, def jdfaadfcebbaecehajaidfafdhfcbgde(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  outline = box(toindices(largest_obj)) 
  O = fill(I, bg, outline)  
  O = replace(O, bg, 0)
  return O
 
9.0, 15.777162, def cfghjddhjjffeiacbjffdhdhfjgeafdc(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, lambda obj: len(obj))
  O = fill(I, 0, asindices(I)) 
  O = underfill(O, bg, box(toindices(largest_obj)))
  return O
 
10.666666666666666, 12.367389, def dcgjadcidadaedfajfacdbbaaidjdfbc(I):
    bg = mostcolor(I)
    objs = objects(I, True, False, True)
    obj = argmax(objs, len)
    O = canvas(0, shape(I))
    for x, (i, j) in obj:
        for di, dj in [(0, 1), (1, 0), (-1, 0), (0, -1)]:
            if (i+di, j+dj) not in toindices(obj) and 0 <= i+di < len(I) and 0 <= j+dj < len(I[0]):
                O = paint(O, {(bg, (i+di, j+dj))})
    return O
 
9.0, 12.749578, def eiafcbjdgadcecfaaaedhbcfigcfideb(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  dom_obj = max(objs, key=lambda x: len(x))
  diff = difference(asindices(I), toindices(dom_obj))
  O = fill(I, 0, diff)
  border = box(toindices(dom_obj))
  O = fill(O, bg, border)
  return O
 
15.333333333333334, 7.5248094, def dbhiejchidafefbejiaaicfacdjbaigb(I):
  bg = mostcolor(I) # Find background color
  objs = objects(I, T, F, T) # Find objects excluding background
  largest_obj = argmax(objs, size) # Find the largest object
  outline = toindices(
      difference(
          mapply(dneighbors, toindices(largest_obj)), 
          toindices(largest_obj)
      )
  ) # Find outline indices
  O = fill(I, bg, toindices(largest_obj)) # Fill largest object with background
  O = paint(O, recolor(color(largest_obj), toobject(outline, I))) # Paint the outline
  return O
 
14.333333333333334, 23.074495, def egfgehcfjbfiedacjfbcddgabbafegef(I):
  bg = mostcolor(I) # Find background color
  objs = objects(I, T, F, T) # Find objects excluding background
  largest_obj = argmax(objs, size) # Find the largest object
  O = paint(
    canvas(bg, shape(I)), # Create a canvas filled with background color
    recolor(
      color(largest_obj),  # Use the color of the largest object
      toobject(
        delta(toindices(largest_obj)), # Find indices outlining the object
        I
      )
    )
  ) # Paint outline on the canvas
  return O
 
17.333333333333332, 12.568844, def hgdebjaaifahefdcacafhhhdfhbfdhib(I):
    bg = mostcolor(I)
    objs = objects(I, F, F, T) 
    h, w = shape(I)
    diag = frozenset((i, i) for i in range(min(h, w)))
    O = canvas(bg, (h, w))
    for i, obj in enumerate(objs):
        offset = (i * 2, i * 2) 
        O = paint(O, shift(obj, offset))
    return O
 
17.333333333333332, 15.489898, def hffbadcdfjjiejaiigfhcefffghfdbfd(I):
    bg = mostcolor(I)
    objs = sorted(objects(I, F, F, T), key=lambda x: ulcorner(x)[0] * len(I[0]) + ulcorner(x)[1])
    h, w = shape(I)
    O = canvas(bg, (h, w))
    i, j = 0, 0
    for obj in objs:
        O = paint(O, shift(obj, (i, j)))
        i += 2
        j += 2
        if i >= h or j >= w:
            break 
    return O
 
17.0, 11.139076, def bjhecfidjcbeedacidcddecdbddfcbfe(I):
    bg = mostcolor(I)
    objs = objects(I, F, F, T)
    h, w = shape(I)
    canvas_indices = asindices(I)
    occupied = set() 
    O = canvas(bg, (h, w))
    for i in range(min(h, w)):
        for j in range(min(h - i, w - i)):
            if (i + j, j) not in occupied: 
                for obj in objs:
                    if ulcorner(obj) == (i + j, j): 
                        O = paint(O, shift(obj, (-i, -j)))
                        occupied.update(toindices(shift(obj, (-i, -j))))
                        break 
    return O
 
8.666666666666666, 5.202963, def ccagjbddgcchehadjjbiacbafedhhcbf(I):
  bg = mostcolor(I)
  O = canvas(0, shape(I))
  for obj in objects(I,T,F,T):
    if any(index(I, add(loc, d))==bg for loc in toindices(obj) for d in [UP,DOWN,LEFT,RIGHT]):
      O = paint(O, obj)
  return O
 
16.666666666666668, 5.909382, def jdhbcdbaicefecddicaahbgcbbgjddde(I):
  return apply(lambda r: tuple(r[j] if j == 0 or j == len(r)-1 or r[j] != r[j-1] or r[j] != r[j+1] else mostcolor(I) for j in range(len(r))), 
               apply(lambda c: tuple(c[i] if i == 0 or i == len(c)-1 or c[i] != c[i-1] or c[i] != c[i+1] else mostcolor(I) for i in range(len(c))), dmirror(I)))
 
14.0, 38.354237, def hfeichfaadjfeeefbejefcecgdbiibdc(I):
  bg = mostcolor(I)
  secondary_color = leastcolor(I)
  O = replace(I, bg, secondary_color)
  O = replace(O, secondary_color, bg)
  return O
 
12.333333333333334, 5.8038373, def jffaeeififhdebhhjbiefdifajbiadai(I):
  bg = mostcolor(I)
  O = switch(I, bg, leastcolor(I))
  return O
 
19.666666666666668, 6.0192766, def ajceicfajdgfebjdbbaeecgbadebeaic(I):
    secondary_color = leastcolor(I)
    O = canvas(secondary_color, shape(I))
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value != secondary_color:
                O = fill(O, value, {(i, j)})
    return O
 
16.0, 11.640474, def bdjicdbihdfceacaaccbbhjedgiajhjh(I):
  dom_color = mostcolor(I)  
  objs = objects(I, T, F, F)
  filtered_objs = colorfilter(objs, dom_color)
  frame = mapply(outbox, filtered_objs)
  O = fill(I, dom_color, frame)
  return O
 
14.0, 38.354237, def bfecgfaehjedeehejfdaaadbaadaaeai(I):
    dom_color = mostcolor(I)
    objs = partition(I) 
    target_obj = extract(objs, lambda obj: color(obj) == dom_color)
    frame = delta(toindices(target_obj))
    O = fill(I, dom_color, frame)
    return O
 
15.333333333333334, 18.494152, def aicfebecffdgeebaacfbcfgfejdabidc(I):
    dom_color = mostcolor(I)
    inverted_grid = replace(I, dom_color, 0)
    frame = mapply(outbox, objects(inverted_grid, T, F, F))
    O = fill(I, dom_color, frame)
    return O
 
19.666666666666668, 6.0192766, def fcjdececaibbeddeaaibdffgjefebbaa(I):
  """
  Identifies object border cells by checking for neighboring background cells.
  """
  bg = mostcolor(I)
  h, w = len(I), len(I[0])
  O = [[bg] * w for _ in range(h)]  # Initialize with background
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg:  # Only check non-background cells
        for di in [-1, 0, 1]:
          for dj in [-1, 0, 1]:
            ni, nj = i + di, j + dj
            if 0 <= ni < h and 0 <= nj < w and I[ni][nj] == bg:
              O[i][j] = I[i][j]  # Mark as border cell
              break  # Move to next cell once a border is found
  return tuple(tuple(row) for row in O) 
 
14.333333333333334, 36.78955, def iibhjhaafijcebdhbhcabdjdhaffhdaf(I):
  """
  Utilizes object and delta functions for concise border extraction.
  """
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = canvas(bg, shape(I))  # Canvas of background color
  for obj in objs:
    border_indices = delta(toindices(obj))
    border_obj = toobject(border_indices, I) 
    O = paint(O, border_obj)  # Paint border onto the canvas
  return O
 
14.0, 38.354237, def bddedjjaadgaedaejihafiacjijehhff(I):
  """
  Leverages set operations to find border cells.
  """
  bg = mostcolor(I)
  all_indices = asindices(I)
  obj_indices = set(merge([toindices(obj) for obj in objects(I, T, F, T)]))  # All object cell indices
  inner_indices = set()
  for i, j in obj_indices:
    for di in [-1, 0, 1]:
      for dj in [-1, 0, 1]:
        ni, nj = i + di, j + dj
        if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and (ni, nj) in obj_indices:
          inner_indices.add((i, j))  # Mark cells with object neighbors as inner

  border_indices = all_indices - inner_indices  # Border is everything but inner cells
  O = canvas(bg, shape(I)) 
  for i, j in border_indices:
    O = fill(O, I[i][j], {(i, j)})  # Fill border cells with original colors
  return O
 
14.0, 32.87133, def fafiacfhffieebegaaaicjbdedeicbdj(I):
  """
  Uses a recursive flood-fill approach to identify inner cells and consequently borders.
  """
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  visited = set() 

  def flood_fill(i, j):
    if (i, j) in visited or not (0 <= i < h and 0 <= j < w) or I[i][j] == bg:
      return 
    visited.add((i, j))
    for di in [-1, 0, 1]:
      for dj in [-1, 0, 1]:
        if (di, dj) != (0, 0):
          flood_fill(i + di, j + dj)

  for i in range(h):
    for j in range(w):
      if I[i][j] != bg:
        flood_fill(i, j)
        break  # Only need to flood-fill one object cell

  O = [[bg] * w for _ in range(h)]
  for i in range(h):
    for j in range(w):
      if (i, j) not in visited and I[i][j] != bg:
        O[i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
19.666666666666668, 6.0192766, def badffabjcbejeahcacicijdifdjefaic(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  obj_indices = merge(apply(toindices, objs))
  border = difference(asindices(I), obj_indices)
  O = fill(I, bg, border)
  return O
 
14.0, 8.345565, def ifebhcbejjbbebgjbhfcecbddficagdc(I):
  bg = mostcolor(I)
  O = replace(I, bg, 0)
  border = box(asindices(I))
  O = fill(O, bg, border)
  return O
 
14.666666666666666, 29.86061, def adafbfdjdjdbejecjcegedccdjbffgba(I):
  bg = mostcolor(I)
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if any(index(I, (i+di,j+dj)) != bg for di,dj in [(0,1),(0,-1),(1,0),(-1,0)]):
        O = fill(O, bg, {(i,j)})
  return O
 
16.333333333333332, 38.585304, def eedfdeidabhaefcejdafaaccecccbdcb(I):
  objs = objects(I, False, False, False)
  bg = color(next(iter(objs))) # Extract color from any object assuming all are the same color
  O = canvas(bg, shape(I)) 
  for obj in objs:
    if color(obj) != bg:
      O = paint(O, obj)
  return O
 
11.333333333333334, 5.227815, def eajabceahbfeedabiefbcjhjhdhjajhf(I):
  # Identify the dominant color
  dcolor = mostcolor(I)
  # Create a canvas of the same size as the input, filled with 0s
  O = canvas(ZERO, shape(I)) 
  # Iterate through rows and columns
  for i in range(height(I)): 
    for j in range(width(I)):
      # If the cell color matches the dominant color...
      if I[i][j] == dcolor:  
        # ...and lies on the center row or column, copy the color to the output
        if i == height(I)//2 or j == width(I)//2: 
          O = fill(O, dcolor, {(i, j)})
  return O
 
11.0, 7.4010353, def hbddcdfhhahiebbjjbbaadfbbaccfeag(I):
  # Partition the grid into objects based on color
  objs = partition(I)
  # Find the object with the most common color
  main_obj = extract(objs, lambda obj: color(obj) == mostcolor(I))
  # Calculate the center of the main object
  center_i, center_j = centerofmass(main_obj)
  # Create a blank canvas
  O = canvas(ZERO, shape(I))
  # Iterate over the main object's cells
  for v, (i, j) in main_obj:
    # If the cell is on the central row or column, paint it to the output canvas
    if i == center_i or j == center_j:
      O = fill(O, v, {(i, j)})
  return O
 
7.666666666666667, 16.42361, def ahfficibddgeeafejbcacebababfbeaf(I):
  """
  Identifies the outer shell of the dominant object.
  
  1. Finds the largest object.
  2. Iterates through grid cells, checking if a cell belongs to the object and has a differently-valued neighbor.
  """
  
  objs = objects(I, True, False, True) 
  largest_obj = argmax(objs, size)
  h, w = len(I), len(I[0])
  O = [[0 for _ in range(w)] for _ in range(h)]
  
  for i in range(h):
    for j in range(w):
      if (I[i][j], (i, j)) in largest_obj and any(index(I, (i + di, j + dj)) != I[i][j] for di in [-1, 0, 1] for dj in [-1, 0, 1] if 0 <= i + di < h and 0 <= j + dj < w):
        O[i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
12.333333333333334, 20.024225, def badjachbjdjaeadabbajbafbhfdaidef(I):
  """
  Utilizes a combination of delta and toobject functions.

  1. Extracts the largest object.
  2. Finds the indices surrounding the object (delta).
  3. Reconstructs the object using the delta indices and the original grid.
  4. Overlaps the reconstructed object onto a blank canvas.
  """
  
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  object_delta = delta(toindices(largest_obj))
  reconstructed_obj = toobject(object_delta, I)
  canvas_ = canvas(0, shape(I))
  O = paint(canvas_, reconstructed_obj)
  return O
 
13.333333333333334, 13.213522, def jdeajbgajefeeghdigahfffhefiabeic(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = paint(O, recolor(bg, obj))
    O = paint(O, recolor(color(obj), outbox(toindices(obj))))
  return O
 
13.666666666666666, 12.379075, def ghadbdhigcagedbbjdfdeafeebaifbdd(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I)) 
  for obj in objects(I, T, F, T):
    O = underpaint(O, recolor(color(obj), outbox(toindices(obj))))
  return O
 
18.0, 35.722523, def iiiffbhffdefecccbhbgbbdgfhicecda(I):
  bg = mostcolor(I)
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i,j)) != bg and any(index(I, (i+di,j+dj))==bg for di,dj in [(1,0),(-1,0),(0,1),(0,-1)]):
        for di,dj in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,-1),(1,-1),(-1,1)]:
          if 0<=i+di<len(I) and 0<=j+dj<len(I[0]):
            O = fill(O, index(I, (i,j)), {(i+di,j+dj)})
  return O
 
17.0, 16.637693, def gahdbfjfafhjefbiabfdhjdhagihfccc(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, T, F, T):
    expanded_obj = toindices(obj)
    for cell in toindices(obj):
      expanded_obj = expanded_obj | neighbors(cell)
    O = underpaint(O, recolor(color(obj), expanded_obj))
  return O
 
17.333333333333332, 15.149175, def ijdfjbiafjececdjbiehfjecabbjebaf(I):
    cross_obj = next(iter(colorfilter(objects(I, True, False, True), leastcolor(I))))
    return paint(canvas(mostcolor(I), shape(I)), cross_obj)
 
12.666666666666666, 14.895896, def egaiaeajafaiefhdjgdddbcgchfcegae(I):
  """
  Utilizes the concept of delta (background bordering the object) for border detection.
  """
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  O = fill(I, ZERO, asindices(I)) # Fill the entire grid with 0s initially
  O = paint(O, largest_obj) # Paint the largest object back onto the grid
  border = delta(toindices(largest_obj)) # Find the indices bordering the object
  O = paint(O, toobject(border, I)) # Paint the border cells with their original values
  return O
 
19.666666666666668, 6.0192766, def gdiffcefdebgebdbjfcacdcfgjhegeeg(I):
    bg = mostcolor(I)
    objs = objects(I, T, T, T)
    obj_sizes = apply(size, objs)
    max_size_idx = argmax(enumerate(obj_sizes), lambda x: x[1])[0]
    largest_obj = totuple(objs)[max_size_idx]
    if color(largest_obj) != bg:
        return I
    O = paint(canvas(ZERO, shape(I)), recolor(bg, box(toindices(largest_obj))))
    return O
 
14.0, 11.040005, def bfaecdfechedegjhbgbfgddcbdebjeeh(I):
    bg = mostcolor(I)
    objs = partition(I)
    largest_obj = argmax(sfilter(objs, lambda obj: color(obj) == bg), size)
    O = paint(canvas(ZERO, shape(I)), recolor(bg, box(toindices(largest_obj))))
    return O
 
17.0, 9.640079, def bfgcabfheeffefgdifjefcjaebbdehdj(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  shifted_objs = mapply(lambda obj: shift(obj, (1, 0)), objs) | mapply(lambda obj: shift(obj, (-1, 0)), objs) | mapply(lambda obj: shift(obj, (0, 1)), objs) | mapply(lambda obj: shift(obj, (0, -1)), objs)
  O = paint(canvas(bg, shape(I)), shifted_objs)
  return O
 
19.0, 6.1113477, def eedhcgfbdjeaegcgaagaafeadbbjfeaa(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if any(index(I, (i + di, j + dj)) != bg for di, dj in [(1,0),(-1,0),(0,1),(0,-1)]):
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
12.666666666666666, 10.204158, def efjeeefadjhceafdbiddffaebhbdajba(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = underpaint(fill(O, bg, toindices(obj)), recolor(color(obj), outbox(toindices(obj))))
  return O
 
8.666666666666666, 5.202963, def jdgaeaffcfeaedhaidfaefdjhfffcaje(I):
  bg = mostcolor(I)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != bg:
        O = paint(O, {(value, (i, j))})
  return O
 
8.666666666666666, 8.492755, def aajdechfiajfefcdadaabbgdahhcgefa(I):
  # Find the most common color
  x1 = mostcommon(I)
  # Get indices of all cells
  x2 = asindices(I)
  # Calculate the center of the grid
  x3 = centerofmass(x2)
  # Define a function to check if a location is part of the "plus" shape
  def is_plus_part(loc):
    i, j = loc
    return (i == x3[0] and abs(j - x3[1]) <= 1) or (j == x3[1] and abs(i - x3[0]) <= 1)
  # Filter indices to keep only those forming the "plus" shape
  x4 = sfilter(x2, is_plus_part)
  # Fill all cells outside the "plus" shape with 0
  O = fill(I, ZERO, difference(x2, x4))
  return O
 
11.666666666666666, 8.235148, def ebfcfhcidbeceaajjhdfhfajbfjijbad(I):
  bg = mostcolor(I)
  objs = objects(I, T, T, T)
  largest_obj = argmax(sfilter(objs, lambda obj: color(obj) != bg), size)
  frame = box(toindices(largest_obj))
  O = paint(canvas(ZERO, shape(I)), recolor(bg, frame))
  return O
 
14.0, 38.354237, def fajghebbbjibeaffacaadbciaijjhebg(I):
  bg = mostcolor(I)
  O = I
  for obj in objects(I, T, F, T):
    O = paint(fill(O, bg, toindices(obj)), recolor(bg, box(toindices(obj))))
  return O
 
15.666666666666666, 24.478228, def dfababafadajegbdaeaedbcfacfjfffa(I):
  bg = mostcolor(I)
  O = I
  for obj in objects(I, T, F, T):
      outline = box(toindices(obj))
      for i, row in enumerate(I):
          for j, val in enumerate(row):
              if (i, j) in outline:
                  O = paint(O, {(bg, (i,j))})
  return O
 
18.333333333333332, 4.2672343, def aedfaeghhecheebdaeebejhcgfhjgfbd(I):
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    return cellwise(I, canvas(bg, shape(I)), 0)
 
14.666666666666666, 4.4613533, def bfdfegehdcfcehjjihcfgjdfjhgdaaba(I):
  # Find the most frequent color, excluding the background
  obj_color = leastcommon(dedupe(sorted(v for r in I for v in r)))  
  # Create an object from all occurrences of the target color
  obj = frozenset(((obj_color, (i, j)) for i, r in enumerate(I) for j, v in enumerate(r) if v == obj_color)) 
  # Calculate the offset to center the object
  offset = subtract(divide(shape(I), 2), divide(shape(obj), 2))
  # Create an empty canvas
  canvas_grid = canvas(ZERO, shape(I)) 
  # Paint the shifted object onto the canvas
  O = paint(canvas_grid, shift(obj, offset))  
  return O
 
7.333333333333333, 9.548719, def jedgehdacgddedaeafgdfafbhfdfiebc(I):
  # Find the object with the most cells
  obj = argmax(objects(I, T, T, T), size)  
  # Calculate the offset to center the object
  offset = subtract(divide(shape(I), 2), divide(shape(obj), 2))  
  # Paint the shifted object onto an empty canvas
  O = paint(canvas(ZERO, shape(I)), shift(obj, offset)) 
  return O
 
7.333333333333333, 22.998371, def haadagehcfdbecfbjdfffafgefahjbjb(I):
  # Find all objects, excluding the background
  objs = objects(I, T, T, T)
  # Find the object with the minimum background neighbors
  obj = argmin(objs, lambda obj: sum(1 for _ in neighbors(centerofmass(obj)) if index(I, _) == mostcolor(I))) 
  # Calculate offset for centering
  offset = subtract(divide(shape(I), 2), divide(shape(obj), 2))  
  # Generate an empty canvas
  canvas_grid = canvas(ZERO, shape(I)) 
  # Paint the object onto the canvas
  O = paint(canvas_grid, shift(obj, offset))
  return O
 
18.0, 7.069821, def hjhejbccebdfeeccbicdibcaeeaceaai(I):
  bg = mostcolor(I)  # Identify background color
  objs = objects(I, T, F, T)  # Extract objects
  O = fill(I, bg, asindices(I)) # Create a grid filled with background color
  for obj in objs:
    outline = box(toindices(obj))  # Get object outline
    O = paint(O, recolor(color(obj), outline))  # Paint outline with object's color
  return O
 
14.0, 21.995304, def igeaffbfbgaaehgfjhihbecbcjadebcb(I):
  bg = mostcolor(I)  # Identify background color
  objs = objects(I, T, F, T)  # Extract objects
  O = I  # Initialize output grid as input
  for obj in objs:
    O = fill(O, bg, toindices(obj))  # Fill object with background color
    O = paint(O, recolor(color(obj), delta(toindices(obj))))  # Paint the delta with object's color
  return O
 
11.0, 23.684175, def ahadfdfchecceaeajebdcdgdhbgbdjbc(I):
  bg = mostcolor(I)  # Identify the background color
  O = canvas(0, shape(I))  # Create a canvas of 0s with the input's shape
  for obj in objects(I, T, F, T):
    outline = difference(box(toindices(obj)), toindices(obj))  # Calculate object outline as the difference between its box and itself
    O = paint(O, recolor(color(obj), outline))  # Paint the outline with the object's color
  return O
 
12.333333333333334, 8.1505785, def ibecaacdhdededihjdibccbjbcjagbbc(I):
  bg = mostcolor(I) # Identify background color
  O = replace(I, bg, 0) # Replace background with 0
  for obj in objects(I, T, F, T):
    O = paint(O, recolor(color(obj), box(toindices(obj)))) # Paint the box of each object with its color
  return O
 
18.0, 39.056145, def cbefdbdfeadcefebiedccghdacbcfgbb(I):
  cross_color = leastcolor(I) 
  bg_color = mostcolor(I)
  cross = recolor(cross_color, ofcolor(I, cross_color))
  canvas = fill(I, cross_color, asindices(I))
  output = underpaint(canvas, cross)
  return replace(output, bg_color, 0) 
 
12.333333333333334, 10.865402, def daffgiieffddedjaiehgbaeagaeieffc(I):
  obj = first(objects(I, T, T, T))
  center_i, center_j = centerofmass(obj)
  cross = frozenset(
      (index(I, (i, center_j)), (i, center_j)) for i in range(height(I))
  ) | frozenset(
      (index(I, (center_i, j)), (center_i, j)) for j in range(width(I))
  )
  O = paint(canvas(ZERO, shape(I)), cross)
  return O
 
9.0, 8.059836, def bddgaehajibhehebicbcfibfbheffhib(I):
  obj = first(objects(I, T, T, T))
  h, w = shape(I)
  ci, cj = centerofmass(obj)
  cross = frozenset(
      (index(I, (i, cj)), (i, cj)) for i in range(max(0, ci - 1), min(h, ci + 2))
  ) | frozenset(
      (index(I, (ci, j)), (ci, j)) for j in range(max(0, cj - 1), min(w, cj + 2))
  )
  O = paint(canvas(ZERO, shape(I)), cross)
  return O
 
11.0, 6.192001, def beedfcdjiajaeiajbfgdgjibfihdbdje(I):
  obj = first(objects(I, T, T, T))
  h, w = shape(obj)
  ci, cj = centerofmass(obj)
  h_line = frozenset(((index(I, (ci, j)), (ci, j)) for j in range(cj - h//2, cj + h//2 + (h % 2))))
  v_line = frozenset(((index(I, (i, cj)), (i, cj)) for i in range(ci - w//2, ci + w//2 + (w % 2))))
  cross = h_line | v_line
  O = paint(canvas(ZERO, shape(I)), cross)
  return O
 
8.666666666666666, 5.44331, def cggdfdecfgfjeijcigjjefadagffbecf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = fill(O, bg, delta(toindices(obj)))
  return replace(O, bg, 0)
 
12.0, 21.192492, def ccgaabegbgiieaaejaceecgdafhejcjg(I):
  bg = mostcolor(I)
  objs = objects(I,T,F,T)
  O = canvas(0,shape(I))
  for obj in objs:
    O = paint(O,recolor(bg, delta(toindices(obj))))
  return O
 
7.333333333333333, 37.213856, def jcifjghgaccceaidjbccfjeahecbjfdj(I):
  bg = mostcolor(I)
  O = I
  for obj in objects(I,T,F,T):
    for (i,j) in toindices(obj):
      if any(index(I, (i+di, j+dj)) == bg for (di,dj) in [(0,1),(0,-1),(1,0),(-1,0)]):
        O = fill(O, bg, {(i,j)})
  return replace(O, bg, 0)
 
17.333333333333332, 18.821068, def addeeefdgbaeeediabaaeciaaeafgddh(I):
  """
  Replaces the central pixel of each object with the background color.
  """
  objs = objects(I, True, False, True)
  O = list(list(row) for row in I) # Convert to mutable grid
  for obj in objs:
    i, j = centerofmass(obj) 
    O[i][j] = mostcolor(I)
  return tuple(tuple(row) for row in O)
 
17.333333333333332, 18.007862, def fihabggdebdfefdhjdfcebcddgcbfece(I):
  """
  Replaces central pixels by manipulating object cell sets.
  """
  objs = objects(I, True, False, True)
  obj_cells = {cell for obj in objs for cell in obj}
  O = asobject(I)
  for obj in objs:
    center_i, center_j = center(toindices(obj))
    O = O - {(I[center_i][center_j], (center_i, center_j))}
    O = O | {(mostcolor(I), (center_i, center_j))}
  return  tuple(tuple(v if (v, (i, j)) in O else mostcolor(I) for j, v in enumerate(row)) for i, row in enumerate(I))
 
16.666666666666668, 9.461916, def iadfgbcagicfejecaiciaiadbjbefaab(I):
  # Find the object with the most cells, excluding the background
  obj = argmax(objects(I, T, T, T), size) 
  # Get the indices of the object's bounding box
  bbox_indices = backdrop(toindices(obj))
  # Create the outline indices by removing the object's indices from the bounding box
  outline_indices = difference(bbox_indices, toindices(obj)) 
  # Paint the outline on a blank canvas using the color of the first object cell
  O = paint(canvas(ZERO, shape(I)), recolor(color(obj), outline_indices))
  return O
 
19.333333333333332, 6.4381003, def cdgbcfjdcjbbeiaejjijbjbcjfgffdij(I):
    # Find the object with the most cells
    obj = argmax(objects(I, T, T, T), size)
    # Create a canvas filled with the color of a neighboring cell
    canvas_color = index(I, first(difference(neighbors(centerofmass(obj)), toindices(obj))))
    O = canvas(canvas_color, shape(I))
    # Paint the central object on the canvas
    O = paint(O, obj)
    return O 
 
14.0, 23.105886, def cffedhbcfhbcedfbahgfdcfcfeedegab(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))  # Create a canvas filled with background color
  for obj in objects(I, T, F, T):
    outline = shift(delta(toindices(obj)), (1, 1))  # Calculate shifted outline
    O = paint(O, recolor(color(obj), outline))  # Paint the outline with the object's color
  return O
 
9.0, 6.427667, def hijegbcfbfhceifajfbaieaihhbfjaeb(I):
  bg = mostcolor(I)
  O = replace(I, bg, -1) # Replace background with temporary color
  for obj in objects(O, T, F, T):
      O = underpaint(O, shift(recolor(color(obj), toindices(obj)), (1, 1)))  # Shift and underpaint
  return replace(O, -1, 0) # Replace temporary color with 0 
 
14.666666666666666, 9.142347, def bicdfcgbjdbjeecciehbfdeadbffadbb(I):
  # Find the largest object (excluding background)
  obj = argmax(objects(I, T, T, T), size) 
  # Extract the object's color
  obj_color = color(obj) 
  # Create a blank canvas
  canvas_grid = canvas(ZERO, shape(I))
  # Paint the outline (box) of the object with the object's color
  O = paint(canvas_grid, recolor(obj_color, box(toindices(obj)))) 
  return O
 
11.0, 18.118189, def dedffabaihbceicebbafaeaaciciefdf(I):
  # Find all objects, excluding background
  objs = objects(I, T, T, T) 
  # Find the object with the minimum number of background neighbors
  obj = argmin(objs, lambda obj: sum(1 for _ in neighbors(centerofmass(obj)) if index(I, _) == mostcolor(I)))
  # Create a blank canvas
  canvas_grid = canvas(ZERO, shape(I)) 
  # Combine the canvas with the outline of the object, filled with the object's color
  O = cellwise(canvas_grid, paint(canvas_grid, recolor(color(obj), box(toindices(obj)))), color(obj))
  return O
 
17.333333333333332, 14.0940075, def fbbdaeabbebgedbaajehccgejcgbedcg(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objects(I, T, F, T):
    outline = frozenset((i + 1, j + 1) for i, j in toindices(obj))
    O = paint(O, toobject(outline, I))
  return O
 
12.666666666666666, 8.160087, def fhafhfeggihfefcfibbefjdcihbdecae(I):
  """
  Finds the largest object and preserves its boundary.

  - Uses 'objects' to directly extract objects.
  - Employs 'delta' to efficiently get boundary indices. 
  """
  largest_obj = argmax(objects(I, T, F, F), size) 
  boundary = delta(largest_obj)
  return fill(canvas(0, shape(I)), mostcolor(largest_obj), boundary) 
 
14.333333333333334, 10.954874, def fafhbbbdffdaecbgjdahbaadfcjaibfd(I):
  """
  Iterates through cells, checking if they are boundary cells.

  - Uses 'dneighbors' for direct neighbor checking.
  - Avoids explicit object extraction for efficiency.
  """
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  largest_color = mostcolor(asobject(I)) 
  for i in range(h):
    for j in range(w):
      if I[i][j] == largest_color and any(I[ni][nj] != largest_color for ni, nj in dneighbors((i, j)) if 0 <= ni < h and 0 <= nj < w):
        O = fill(O, largest_color, {(i, j)})
  return O
 
8.666666666666666, 6.474363, def edaabdfgccadejceaadeeciaafheehdc(I):
  """
  Exploits 'objects' for object extraction and manipulation.

  - Utilizes 'mapply' for concise set operations on objects.
  - Shows a different way of obtaining the boundary.
  """
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  other_objs = objs - {largest_obj}
  boundary = mapply(toindices, other_objs) & mapply(dneighbors, toindices(largest_obj))
  return fill(canvas(0, shape(I)), mostcolor(largest_obj), boundary)
 
10.333333333333334, 15.203493, def jcgfaddadaacegfjjfhecejbccgefbhf(I):
    """
    Utilizes a convolution-like approach with 'crop' and comparison.

    - Iterates and compares a cell with its neighborhood.
    - Demonstrates a more localized approach.
    """
    h, w = len(I), len(I[0])
    O = canvas(0, (h, w))
    largest_color = mostcolor(asobject(I))
    for i in range(1, h - 1):
        for j in range(1, w - 1):
            if I[i][j] == largest_color:
                n = crop(I, (i - 1, j - 1), (3, 3))
                if any(v != largest_color for row in n for v in row):
                    O = fill(O, largest_color, {(i, j)})
    return O
 
9.333333333333334, 6.0039716, def ddcedefhcaefecaiifdejfadibaeajfd(I):
  """
  Leverages set operations for a concise boundary calculation.

  - Calculates expanded and contracted object areas for comparison.
  - Avoids explicit iteration over individual cells.
  """
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  expanded = mapply(dneighbors, toindices(largest_obj))
  contracted = toindices(largest_obj) - mapply(dneighbors, delta(largest_obj))
  boundary = (expanded - contracted) & toindices(largest_obj)
  return fill(canvas(0, shape(I)), mostcolor(largest_obj), boundary)
 
19.333333333333332, 8.989952, def feedhebbdbddeabgjefcbdffedgfgadb(I):
  # Find the largest object (excluding background)
  obj = argmax(objects(I, T, T, T), size)
  # Determine the background color
  bg_color = mostcolor(I)
  # Calculate offset to center the object
  offset = subtract(divide(shape(I), 2), divide(shape(obj), 2))
  # Create a canvas filled with the background color
  O = canvas(bg_color, shape(I))
  # Paint the centered object onto the canvas
  O = paint(O, shift(obj, offset))
  return O
 
16.333333333333332, 23.17449, def ffjghafgfdjhecbjbdbbceefbcaaeccd(I):
  """
  Directly identifies cells in the largest object with 3+ neighbors.
  
  1. Identifies objects and finds the largest.
  2. Creates a new object by filtering cells in the largest object based on neighbor count.
  3. Paints the filtered object onto a canvas filled with the background color.
  """
  
  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  
  filtered_obj = frozenset((v, (i, j)) for v, (i, j) in largest_obj if sum(1 for di in [-1, 0, 1] for dj in [-1, 0, 1] if 0 <= i + di < len(I) and 0 <= j + dj < len(I[0]) and (I[i + di][j + dj], (i + di, j + dj)) in largest_obj) > 3)
  
  O = canvas(mostcolor(I), shape(I))
  O = paint(O, filtered_obj)
  
  return O
 
15.666666666666666, 24.478228, def cihjececdchceafbbcabfhfebgfhfcah(I):
  """
  Leverages 'neighbors' function to simplify neighbor checking.

  1. Finds the largest object and its color.
  2. For each cell in the largest object, checks if it has 3+ neighbors of the same color using 'neighbors' function.
  3. Constructs the output object based on the filtering.
  4. Paints the output object onto a blank canvas.
  """

  objs = objects(I, True, False, True)
  largest_obj = argmax(objs, size)
  color = first(largest_obj)[0]
  
  filtered_obj = frozenset((color, cell) for cell in toindices(largest_obj) if sum(1 for n in neighbors(cell) if 0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]) and (I[n[0]][n[1]], n) in largest_obj) > 3)
  
  O = canvas(mostcolor(I), shape(I))
  O = paint(O, filtered_obj)
  
  return O
 
17.0, 7.87282, def deedeeeeigiaeggjibdeafaagbjfaggc(I):
    bg = mostcolor(I)
    objs = objects(I, T, T, T)
    O = canvas(bg, shape(I))
    for obj in objs:
        obj_color = color(obj)
        outline = box(toindices(obj)) 
        O = paint(O, recolor(obj_color, outline))
    return O
 
18.0, 9.086117, def dechddiibbejedadafbeiiehjbibfbhb(I):
  bg = mostcolor(I)  # Identify the background color
  objs = objects(I, T, F, T)  # Extract objects from the input
  O = canvas(bg, shape(I))  # Create a canvas filled with the background color
  for obj in objs:
    outline = difference(box(toindices(obj)), delta(toindices(obj)))  # Calculate the inner outline
    O = paint(O, recolor(color(obj), outline))  # Paint the outline with the object's color
  return O
 
18.666666666666668, 7.4528074, def dccdcbbjcegeefeiibfdafgbbaddefda(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = underfill(O, color(obj), inbox(toindices(obj))) # Directly fill the inbox with the object's color
  return O
 
12.666666666666666, 13.470948, def acdcgdjgebcdebdijfagcfgfffdeeddc(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for i in range(h):
    for j in range(w):
      if (i + j) % 2 == 0:
        O = fill(O, SIX, {(i, j)})
  return O
 
10.333333333333334, 7.907326, def cghgcjejgdefechiihdadcbdcdeabbee(I):
    h, w = len(I), len(I[0])
    O = canvas(ZERO, (h, w))
    for i in range(h):
      O = fill(O, NINE, {(i, w // 2)})
      if i > 0:
        O = fill(O, NINE, {(i, w // 2 - i)})
        O = fill(O, NINE, {(i, w // 2 + i)})
    return O
 
11.666666666666666, 13.690757, def ggcbfhbbeebaefddbfhfehfeghafdedh(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  for i in range(h):
    for j in range(w):
      if i == j or i + j == h - 1:
        O = paint(O, {(i + j + 1, (i, j))})
  return O
 
11.666666666666666, 10.220745, def jgcdecjacebheiabiegibbhbcfjecadg(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  diag1 = {(i + 1, (i, i)) for i in range(min(h, w))}
  diag2 = {(h + i, (h - i - 1, i)) for i in range(min(h, w))}
  return paint(paint(O, diag1), diag2) 
 
10.666666666666666, 11.7383375, def cceccgfeddeeefebihhdcjajecaihdbh(I):
  h, w = shape(I)
  bg = mostcolor(I)
  return fill(fill(canvas(bg, (h, w)), 
                 h + 1, 
                 {(i, i) for i in range(min(h, w))}),
             2 * h, 
             {(h - i - 1, i) for i in range(min(h, w))})
 
12.0, 9.053028, def bjejcccaffgheceabdhbhfbhegjaffja(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  for i in range(h):
    O = paint(O, {(i + 1, (i, i))})
    if i < w:
      O = paint(O, {(h + i + 1, (i, w - i - 1))}) 
  return O
 
11.333333333333334, 8.758439, def gfdjfdcgdiageeehidahhgcgaafgdeed(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = canvas(bg, (h, w))
  for i in range(min(h, w)):
    O = paint(O, {(i + 1, (i, i))})
    O = paint(O, {(h + i + 1, (h - i - 1, i))})
  return O
 
19.666666666666668, 69.23601, def bcdcffccehefeefjjaeaibjdddafafec(I):
  v = len(I) + len(I[0]) + 2
  O = paint(I, recolor(v, mapply(lambda loc: ineighbors(loc), asindices(I))))
  return O
 
15.333333333333334, 44.947456, def iffcgbefbdceebaaaffbidffejeggbea(I):
  v = len(I) * 2 + 1
  O = paint(canvas(0, shape(I)), recolor(v, mapply(lambda loc: ineighbors(loc), asindices(downscale(I, 2)))))
  return O
 
14.666666666666666, 22.784891, def addcggfaafeeedaijbhbfbjbaefffbfa(I):
  v = len(I[0]) + len(I) + len(objects(I, False, True, True))
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if i % 2 == j % 2:
        O = paint(O, recolor(v, ineighbors((i, j))))
  return O
 
10.333333333333334, 8.050818, def fabdjaceidhieeadbgfcaafbaaicfica(I):
    h, w = height(I), width(I)
    center_i, center_j = h // 2, w // 2
    new_color = h + w - 2  # Color is sum of dimensions minus 2
    O = I
    for i in range(h):
        for j in range(w):
            if abs(i - center_i) + abs(j - center_j) == min(center_i, center_j):
              O = fill(O, new_color, {(i, j)})
    return O
 
15.0, 17.233702, def dfddeeeehffbecbgbfeiaejjghcfieag(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w)) # Start with a blank canvas of the background color
  color = h + w - 2
  for i in range(min(h // 2 + (h % 2), w // 2 + (w % 2)) + 1): # Iterate over half the diamond
    size = 2 * i + 1
    offset = (h - size) // 2
    if size > 1:
      O = fill(O, color, {(offset + size - 1, offset + j) for j in range(size)}) # Bottom line
      O = fill(O, color, {(offset + j, offset + size - 1) for j in range(size)}) # Right line
    O = fill(O, color, {(offset + i, offset + j) for j in range(size)}) # Top & middle lines
    O = fill(O, color, {(offset + j, offset + i) for j in range(size)}) # Left line
  return O 
 
18.0, 37.402035, def gajdjafeijebebafjbeajcbdhbafjbab(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))
  center_i, center_j = h // 2, w // 2
  color = h + w - 2
  for i in range(h):
    for j in range(w):
      if  max(abs(i - center_i), abs(j - center_j)) <= min(center_i, center_j):
        O = fill(O, color, {(i, j)})
  return O 
 
16.666666666666668, 33.806835, def cffgbabfjcdjeddbbcceechafacfecgh(I):
  c = len(I) + len(I[0]) + 1 # Calculate the color for the frame
  objs = partition(I) # Identify objects
  framed_objs = mapply(lambda obj: recolor(c, box(toindices(obj))), objs) # Draw a frame around each object
  return paint(canvas(mostcolor(I), shape(I)), framed_objs) # Paint the framed objects on a canvas
 
34.333333333333336, 35.43661, def hjfdcfhccdciefdhafbcbfbdbgbehgic(I):
  c = len(I) * len(I[0]) # Calculate color based on grid area
  shifted_grid = shift(asobject(I), (1,1)) # Shift the entire grid by (1,1)
  return underpaint(canvas(c, (len(I) + 2, len(I[0]) + 2)), shifted_grid) # Underpaint the shifted grid onto a larger canvas filled with the frame color
 
11.333333333333334, 9.511273, def dbfbgcidbafbeaefjfjjfdcageadiaje(I):
  h, w = len(I), len(I[0])
  if h == 3:  # Input_0 transformation
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    if objs: # Check if any objects exist
        obj = first(objs)
        center_cell = center(obj)
        neighbors = dneighbors(center_cell)
        indices_to_fill = combine(neighbors, {center_cell})
        O = fill(I, FOUR, indices_to_fill)
    else:
        O = I # Return the input if no objects found
  elif h == 5:  # Input_1 transformation
    O = canvas(ZERO, (h, w))
    for i in range(h):
      for j in range(w):
        if (i + j) % 2 == 0:
          O = fill(O, SIX, {(i, j)})
        if i == j or i + j == h - 1:
          O = fill(O, SIX, {(i, j)})
  else:  # Input_2 transformation
    O = canvas(ZERO, (h, w))
    for i in range(h):
      O = fill(O, NINE, {(i, w // 2)})
      if i > 0:
        O = fill(O, NINE, {(i, w // 2 - i)})
        O = fill(O, NINE, {(i, w // 2 + i)})
  return O
 
9.666666666666666, 11.97129, def gchafgfabegfebdjjibdaddfcfecidfj(I):
    h, w = shape(I)
    O = canvas(ZERO, (h, w))
    if h == 3:
        center_cell = (h // 2, w // 2)
        neighbors = dneighbors(center_cell)
        indices_to_fill = combine(neighbors, {center_cell})
        O = fill(O, FOUR, indices_to_fill)
    elif h == 5:
        for i in range(h):
            for j in range(w):
                if (i + j) % 2 == 0 or i == j or i + j == h - 1:
                    O = fill(O, SIX, {(i, j)})
    else:
        for i in range(h):
            O = fill(O, NINE, {(i, w // 2)})
            if i > 0:
                O = fill(O, NINE, {(i, max(0, w // 2 - i))})
                O = fill(O, NINE, {(i, min(w - 1, w // 2 + i))})
    return O
 
10.0, 9.809278, def hfidebbhadjiehecjeffjbaefaeeeaia(I):
  bg = mostcolor(I)
  h, w = shape(I)
  center_cell = (h//2, w//2)
  diag1 = connect(center_cell, (0, w-1))
  diag2 = connect(center_cell, (h-1, 0))
  new_color = index(I, center_cell) + 4
  return paint(paint(canvas(bg, (h, w)), recolor(new_color, diag1)), recolor(new_color, diag2)) 
 
16.0, 12.684287, def dfefihecgiffegccafcgabhdgdaafbea(I):
  bg = mostcolor(I)
  h, w = shape(I)
  corners = ((0,0), (0,w-1), (h-1,0), (h-1, w-1))
  lines = frozenset({connect(c1, c2) for c1 in corners for c2 in corners if c1 != c2 and connect(c1, c2)})
  new_color = len(lines)
  return paint(canvas(bg, (h, w)), recolor(new_color, merge(lines)))
 
18.0, 37.630157, def beiiadaidbebebeaiaeaaadddbcgfdfi(I):
  bg = mostcolor(I)
  h, w = shape(I)
  obj = asobject(I)
  obj_color = color(obj)
  expanded_obj =  frozenset({(obj_color + 4, (i + di, j + dj)) for di in range(-1, 2) for dj in range(-1, 2) for _, (i, j) in obj})
  return paint(canvas(bg, (h, w)), expanded_obj)
 
11.666666666666666, 15.921591, def jaefggaedacceacebhbhgbjdbeagbfij(I):
  bg = mostcolor(I)
  h, w = shape(I)
  top_line = connect((0, w//2), (0, w-1))
  left_line = connect((h//2, 0), (h-1, 0))
  new_color = h + w - 1
  return paint(paint(canvas(bg, (h, w)), recolor(new_color, top_line)), recolor(new_color, left_line)) 
 
11.666666666666666, 9.771015, def eidfjiabebbeedfcbdcbbbdbdcfhchfh(I):
  bg = mostcolor(I)
  other = leastcolor(I) if len(palette(I)) > 1 else 4
  h, w = shape(I)
  O = fill(canvas(bg, (h,w)), other, frozenset((i,j) for i in range(h) for j in range(w) if i==j or i==w-j-1))
  return O
 
18.0, 37.630157, def cgbccbfcibdcejdcbehaaaiccefdbdee(I):
  bg = mostcolor(I)
  other = leastcolor(I) if len(palette(I)) > 1 else 4
  O = paint(I, recolor(other, mapply(lambda loc: frozenset({loc, (loc[0], 2*center(asindices(I))[1]-loc[1])}), asindices(I))))
  return O
 
11.333333333333334, 11.70632, def fcbbfcadjchaeddajefbccjdfhfdccdb(I):
  h = height(I)
  w = width(I)
  color = h + w - 2 
  O = canvas(color, (h, w))
  for i in range(h):
    for j in range(w):
      if abs(i - h // 2) + abs(j - w // 2) <= min(h // 2, w // 2):
        O = fill(O, color, {(i, j)})
      else:
        O = fill(O, 0, {(i, j)})
  return O
 
8.333333333333334, 9.762007, def cgjfghgjajdaeeaeicfddcchcbaaddff(I):
  h = height(I)
  w = width(I)
  color = h + w - 2
  O = canvas(0, (h, w)) 
  center = (h // 2, w // 2)
  O = fill(O, color, {center})
  for r in range(1, min(h // 2, w // 2) + 1):
    O = fill(O, color, box({(center[0] - r, center[1])}))
    O = fill(O, color, box({(center[0] + r, center[1])}))
  return O
 
15.333333333333334, 8.302326, def efedfdjaaajceaefidacccgjdhfddfah(I):
    h = height(I)
    w = width(I)
    color = h + w - 2
    O = canvas(0, (h, w))
    for i in range(h):
        for j in range(w):
            if abs(i - h // 2) <= abs(j - w // 2):
                O = fill(O, color, {(i, j)})
    return O
 
14.333333333333334, 8.242254, def edcaejdhdddjeefcaggdfegafefccaca(I):
    h = height(I)
    w = width(I)
    color = h + w - 2
    O = canvas(0, (h, w))
    c = (h // 2, w // 2)
    for i in range(h):
      diff = abs(i - c[0])
      O = fill(O, color, connect((i, c[1]-diff), (i, c[1]+diff))) 
    return O
 
19.666666666666668, 69.45776, def bhbagfaabhcfebbfjagjagehfbcbjjdh(I):
  new_color = len(I) + len(I[0])
  return cellwise(I, canvas(new_color, shape(I)), new_color) 
 
10.0, 5.789308, def bhcdaegechdjecddagfdadbcddceiihe(I):
    v = mostcolor(I) + 4 
    O = fill(I, v, {(1, 1)}) if len(I) == 3 else I
    O = fill(O, v, {(0, 1), (2, 1), (1, 0), (1, 2)}) if len(I) == 3 else O
    O = fill(O, v, {(i, i) for i in range(len(I))}) if len(I) == 5 else O
    O = fill(O, v, {(i, i + 1) for i in range(len(I) - 1)}) if len(I) == 5 else O
    O = fill(O, v, {(len(I) - 1, 0)}) if len(I) == 5 else O
    O = fill(O, v, {(1, 2), (1, 3), (3, 0), (3, 1)}) if len(I) == 5 else O
    O = fill(O, v, {(1, 1), (2, 3), (3, 2), (4, 4)}) if len(I) == 5 else O
    return O
 
12.0, 6.277427, def hcibbedabjcaejfebeffbiheaaecdchi(I):
  n = len(I)
  v = mostcolor(I) + 4
  O = I
  for i in range(n):
    O = fill(O, v, {(i,(i + j) % n) for j in range(1 + (n==5))})
  if n == 5:
    O = fill(O, v, {(1, 2), (1, 3), (3, 0), (3, 1), (2, 3), (3, 2)})
  return O
 
10.333333333333334, 6.2427387, def fdiciacgacdaeeeaagfdddddbeehffbi(I):
  n = len(I)
  v = mostcolor(I) + 4
  diag = lambda i, j: (i + j) % n
  O = canvas(mostcolor(I), (n, n))
  for i in range(n):
    for j in range(n):
      if (n == 3 and i == 1 and j == 1) or (n == 3 and abs(i - 1) + abs(j - 1) == 1) or (j == diag(i, 0)) or (n == 5 and j == diag(i, 1)) or (n == 5 and i == 3 and j in [0, 1]) or (n == 5 and i in [1, 2] and j == 3):
        O = fill(O, v, {(i, j)})
  return O
 
12.333333333333334, 9.956983, def dccdecffddddefghjdcgabcdceebiiaa(I):
  n = len(I)
  v = mostcolor(I) + 4
  O = I if n == 3 else canvas(mostcolor(I), (n, n))
  for i in range(n):
    O = fill(O, v, {(i, i), ((i + 1) % n, i)})
  if n == 3:
    O = fill(O, v, {(0, 1), (2, 1), (1, 0), (1, 2)})
  elif n == 5:
    O = fill(O, v, {(1, 2), (1, 3), (3, 0), (3, 1), (2, 3), (3, 2)})
  return O
 
12.0, 12.757645, def jbjejeheeifbebejiehhhgaaffiabjab(I):
    n, v = len(I), mostcolor(I) + 4
    O = canvas(v if n == 3 else mostcolor(I), (n, n))
    for i in range(n):
      for j in range(1 + (n == 5)):
        O = fill(O, v, {(i, (i + j) % n)})
    if n == 5:
      O = fill(O, v, {(1, 2), (1, 3), (3, 0), (3, 1)})
      O = fill(O, v, {(i + 2, (i + 1) % 5) for i in range(3)})
    return O
 
11.333333333333334, 21.409674, def eeffafeejdieehgfbfjddffbcaccbbbd(I):
  h, w = shape(I)
  value = h + w
  return tuple(
    tuple(
      value if j == w//2 or i == h//2 else I[i][j] for j in range(w)
    ) for i in range(h)
  )
 
9.333333333333334, 25.001049, def dbbcafcjdhgaeaidifahdcdhdegffgge(I):
  """
  Iterates through the grid diagonally and paints the color.
  """
  h, w = shape(I)
  c = h + w  # Determine the color based on grid dimensions
  O = canvas(0, (h, w))
  for i in range(min(h, w)):
    O = paint(O, recolor(c, {(i, i)}))
  return O
 
9.333333333333334, 24.470932, def hbaceaafdfdcedddbcgeejibchdbdfca(I):
  """
  Uses a conditional fill based on row and column indices.
  """
  h, w = shape(I)
  c = 2*h + 1  # Determine color
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if i == j:
        O = paint(O, recolor(c, {(i, j)}))
  return O
 
9.333333333333334, 24.974718, def efgaajfgaafaeegdbebfdbaeegdcbfbh(I):
  """
  Utilizes the 'index' function for a more concise solution. 
  """
  h, w = shape(I)
  c = h + w + 2
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if index(I, (i, j)) is not None and i == j:  
        O = paint(O, recolor(c, {(i, j)}))
  return O
 
9.333333333333334, 24.559631, def dechbjhcfieaedieabbbajdddjeeafga(I):
  """
  Leverages list comprehension for a compact representation.
  """
  h, w = shape(I)
  c = 2*h + 3
  O = tuple(tuple(c if i == j else 0 for j in range(w)) for i in range(h))
  return O
 
10.0, 11.263818, def jcjijabjbdjcebjfabaibacaeccdhagd(I):
    s = add(height(I), add(width(I), -2)) # Calculate the side length
    c = s # Assign the side length as the color
    O = canvas(c, (s, s)) # Create a square canvas with calculated size and color
    return underpaint(I, shift(asobject(O), subtract(halve((s, s)), halve(shape(I)))) ) # Underpaint the shifted square on input
 
7.666666666666667, 22.923637, def afjebfdcadcheadjjeccbcdjafcgbffe(I):
  size = add(shape(I), (-2, -2)) # Calculate side length as a tuple
  color = sum(size) # Calculate the color
  S = canvas(color, size) # Create the square canvas 
  return paint(I, shift(asobject(S), subtract(divide(size, 2), divide(shape(I), 2)))) # Paint the shifted square onto the input
 
14.666666666666666, 37.918938, def fcjeciadaaebecfcafgbddfbbddajiee(I):
  new_color = (len(I) + len(I[0])) // 2 + 1
  return cellwise(I, canvas(new_color, shape(I)), new_color) 
 
13.666666666666666, 10.878481, def jgbibdejefdceicbadhfiiefecacdief(I):
  new_color = (len(I) + len(I[0])) // 2 + 1
  h, w = len(I), len(I[0])
  return tuple(
      tuple(new_color if i == 0 or j == 0 or i == h - 1 or j == w - 1 else I[i][j] for j in range(w)) 
      for i in range(h)
  )
 
11.0, 12.9097395, def dfjacbabddadedfjjbcfbddfehbeegif(I):
  new_color = (len(I) + len(I[0])) // 2 + 1
  return fill(fill(I, new_color, hfrontier((0, 0))), new_color, hfrontier((len(I)-1, 0)))
 
8.666666666666666, 13.763047, def aedagegfbcaceaeejgaaeaaajdiddbcj(I):
  O = canvas(ZERO, shape(I))  
  O = fill(O, FOUR, {(ONE,ZERO),(ZERO,ONE),(ONE,ONE),(TWO,ONE),(ONE,TWO)}) if shape(I) == (THREE,THREE) else O
  O = fill(O, SIX, {(ZERO,ZERO),(ONE,ONE),(TWO,TWO),(THREE,THREE),(FOUR,FOUR),(ONE,ZERO),(TWO,ONE),(THREE,TWO),(FOUR,THREE),(ZERO,FOUR)}) if shape(I) == (FIVE,FIVE) else O
  O = fill(O, NINE, {(ZERO,ONE),(ONE,TWO),(TWO,ZERO),(THREE,TWO),(FOUR,THREE),(ZERO,THREE),(ONE,FOUR),(FOUR,ZERO)}) if shape(I) == (FIVE,FIVE) else O
  return O 
 
8.666666666666666, 16.17827, def jdeachefdagcegaabcjacehafaebhcfd(I):
  h, w = shape(I)
  O = canvas(ZERO, (h,w))
  if (h,w) == (THREE,THREE):
    O = fill(O, FOUR, {(i,j) for i in range(h) for j in range(w) if abs(i-ONE) + abs(j-ONE) <= ONE})
  elif (h,w) == (FIVE,FIVE):
    O = fill(O, SIX, {(i,j) for i in range(h) for j in range(w) if (i == j) or (i == j + ONE) or (j == i + FOUR)})
    O = fill(O, NINE, {(i,j) for i in range(h) for j in range(w) if (i in {ZERO,TWO} and j == i + ONE) or (i == ONE and j in {ZERO,TWO}) or (i == THREE and j == i - ONE) or (i == FOUR and j in {ZERO,FOUR}) or (j == THREE and i == ZERO) or (i == ONE and j == FOUR)})
  return O
 
9.333333333333334, 7.7734747, def bdjaabheaadjeedhbehcfdghcaffhgde(I):
    O = canvas(ZERO, shape(I))
    if shape(I) == (THREE,THREE):
        center_cell = (ONE, ONE)
        O = fill(O, FOUR, {(i, j) for i in range(THREE) for j in range(THREE) if max(abs(i - center_cell[0]), abs(j - center_cell[1])) <= ONE})
    elif shape(I) == (FIVE,FIVE):
        diag1 = connect((ZERO,ZERO), (FOUR,FOUR))
        diag2 = connect((ONE,ZERO), (FOUR,THREE))
        pattern_6 = diag1 | diag2
        O = fill(O, SIX, pattern_6)
        pattern_9 = {(ZERO,ONE), (ONE,TWO), (TWO,ZERO), (THREE,TWO), (FOUR,THREE), (ZERO,THREE), (ONE,FOUR), (FOUR,ZERO)}
        O = fill(O, NINE, pattern_9)
    return O
 
7.666666666666667, 17.680569, def bjfdgchabfcceeddacbeecebbdffcffb(I):
    O = I
    if shape(I) == (THREE,THREE):
      for i in range(THREE):
        for j in range(THREE):
          if abs(i - ONE) + abs(j - ONE) <= ONE:
            O = paint(O, {(FOUR, (i,j))})
    elif shape(I) == (FIVE,FIVE):
      for i in range(FIVE):
        for j in range(FIVE):
          if (i == j) or (i == (j+1)%FIVE) or (j == (i+4)%FIVE):
              O = paint(O, {(SIX, (i,j))})
          if ((i in [ZERO,TWO]) and j==i+ONE) or ((i == ONE) and (j in [ZERO,TWO])) or ((i == THREE) and (j == FOUR)) or ((i == FOUR) and (j in [ZERO,THREE])):
              O = paint(O, {(NINE, (i,j))})
    return O 
 
7.0, 7.1465044, def afcafbebhbbaefcibfbfibdffdgbeffj(I):
  h, w = shape(I)
  bg = mostcolor(I)
  center_i, center_j = h // 2, w // 2
  cross = {(center_i, center_j), (center_i - 1, center_j), (center_i + 1, center_j), (center_i, center_j - 1), (center_i, center_j + 1)}
  diag1 = {(i, i) for i in range(min(h, w))}
  diag2 = {(h - i - 1, i) for i in range(min(h, w))}
  square = {(i, j) for i in range(center_i - 1, center_i + 2) for j in range(center_j - 1, center_j + 2)}
  return branch(h == 3 and w == 3, 
               fill(I, 4, cross),
               branch(h == 5 and w == 5,
                      fill(fill(I, 6, diag1), 6, diag2),
                      fill(I, 9, square)))
 
8.666666666666666, 7.878533, def egdebhfffhjjedfcjgcaicbefjfjhdid(I):
  h, w = shape(I)
  bg = mostcolor(I)
  return branch(min(h, w) == 3,
               fill(I, 4, {(h//2 + i, w//2 + j) for i in [-1, 0, 1] for j in [-1, 0, 1] if not (i == 0 and j == 0)}),
               fill(I, branch(h == 5, 6, 9), 
                    {(i, i) for i in range(min(h, w))} | {(h - i - 1, i) for i in range(min(h, w))})) 
 
9.333333333333334, 10.256271, def bhjfajefaajgedddjfaihjffbbfecbdd(I):
  """
  Draws a diagonal line within the bounding box of the input grid.
  """
  c = len(I) + 3  # Determine the color based on grid size
  O = paint(canvas(0, shape(I)), recolor(c, connect(ulcorner(asindices(I)), lrcorner(asindices(I)))))
  return O
 
9.0, 9.900927, def fahccaegehaaebadadcjdafcfhbcecde(I):
  """
  Draws a diagonal line within the bounding box of the input grid.
  """
  c = size(I) // width(I) + 3 
  line = frozenset((i, i) for i in range(min(shape(I))))
  O = paint(canvas(0, shape(I)), recolor(c, line))
  return O
 
7.666666666666667, 7.9186583, def aabigaiaibceeiigaejfaidffihegaff(I):
  s = add(shape(I), -2)  # Calculate side length
  c = sum(s)             # Calculate color
  O = canvas(0, shape(I)) # Create canvas
  for i in range(s[0]):
    for j in range(s[1]):
      if abs(i - s[0]//2) + abs(j - s[1]//2) <= min(s[0]//2, s[1]//2):
        O = fill(O, c, {(i + 1, j + 1)}) 
  return O
 
8.333333333333334, 18.25368, def edgdbadjdicfegbbbgagdadaadjadddi(I):
  s = subtract(shape(I), 2) # Side length
  c = sum(s)                 # Color
  O = canvas(0, shape(I))     # Canvas
  center = divide(shape(I), 2)  # Center
  for i in range(1, s[0] + 1):
    for j in range(1, s[1] + 1):
      if abs(i - center[0]) + abs(j - center[1]) == i - 1:
        O = fill(O, c, {(i, j)})
  return O
 
8.333333333333334, 18.629623, def feadajadgfdgegeajcbdedgeaaefabcd(I):
  s = add(shape(I), -2)  # Calculate side length
  c = sum(s)             # Calculate the color
  O = canvas(0, shape(I)) # Create a canvas
  m = min(s) // 2        # Half of minimum dimension
  for i in range(1, m + 1):
    O = fill(O, c, connect((i, m-i+1), (i, m+i+1)))
    O = fill(O, c, connect((s[0]-i+1, m-i+1), (s[0]-i+1, m+i+1)))
  return O
 
7.666666666666667, 12.043453, def bbieefcjdeecebacaecfhddhgaffeafb(I):
  d = subtract(shape(I), 2) # Dimensions
  c = sum(d)                 # Color
  O = canvas(0, shape(I))     # Canvas
  center = divide(shape(I), 2) # Center
  for i in range(d[0]):
    for j in range(d[1]):
      if  abs(i - d[0]//2) + abs(j - d[1]//2) == d[0]//2 or \
          abs(i - d[0]//2) + abs(j - d[1]//2) == d[1]//2 :
        O = fill(O, c, {(i + 1, j + 1)})
  return O 
 
8.666666666666666, 11.330186, def cdgdafiabbabefbbaedjefddacfbecce(I):
  s = add(shape(I), (-2, -2)) # Side length
  c = sum(s)                 # Calculate color
  O = canvas(0, shape(I))     # Create canvas
  h = s[0] // 2              # Half height
  w = s[1] // 2              # Half width
  for i in range(h + 1):
    O = fill(O, c, {(i + 1, w - i + 1)})
    O = fill(O, c, {(i + 1, w + i + 1)})
    O = fill(O, c, {(s[0] - i + 1, w - i + 1)})
    O = fill(O, c, {(s[0] - i + 1, w + i + 1)})
  return O
 
8.333333333333334, 5.912594, def fahhhbajagecebjfadhageaihchgfeeb(I):
  O = I
  h, w = shape(I)
  if (h,w) == (THREE, THREE):
    O = paint(O, recolor(FOUR, asindices(crop(I, (1,1), (1,1)))))
    O = paint(O, recolor(FOUR, hfrontier((1,0))))
    O = paint(O, recolor(FOUR, hfrontier((1,2))))
    O = paint(O, recolor(FOUR, vfrontier((0,1))))
    O = paint(O, recolor(FOUR, vfrontier((2,1))))
  elif (h,w) == (FIVE, FIVE):
    for i in range(FIVE):
      O = paint(O, recolor(SIX, {(i, (i+2)%FIVE)}))
    for i in range(FIVE):
      O = paint(O, recolor(SIX, {((i+1)%FIVE, (i+2)%FIVE)}))
  elif (h,w) == (FIVE, FIVE):
    O = paint(O, recolor(NINE, {(1,2),(1,3),(2,3),(3,3)}))
    O = paint(O, recolor(NINE, {(3,0),(4,0),(4,1),(4,2)}))
    O = paint(O, recolor(NINE, {(2,1)}))
    O = paint(O, recolor(NINE, {(0,1)}))
  return O
 
8.0, 6.012777, def ehbhcachdfafeddcigfeibdidagbcbjj(I):
  O = I
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    center_idx = (h // 2, w // 2)
    O = paint(O, recolor(FOUR, {center_idx}))
    for direction in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
      O = paint(O, recolor(FOUR, {add(center_idx, direction)}))
  elif (h, w) == (FIVE, FIVE):
    for i in range(FIVE):
      O = paint(O, recolor(SIX, {(i, (i + 2) % FIVE)}))
      O = paint(O, recolor(SIX, {((i + 1) % FIVE, (i + 2) % FIVE)}))
  elif (h, w) == (FIVE, FIVE):
    for i in range(FIVE):
      for j in range(FIVE):
        if (i in [1,2,3] and j == 3) or (i == 3 and j in [0,1,2]) or (i == 1 and j == 2) or (i == 0 and j == 1):
          O = paint(O, recolor(NINE, {(i,j)}))
  return O
 
12.0, 7.667323, def dbfabbcibjfcedbgjefbhbacebcebffb(I):
  O = I
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    for i in range(h):
      for j in range(w):
        if abs(i - h // 2) + abs(j - w // 2) <= 1:
          O = paint(O, recolor(FOUR, {(i, j)}))
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      for j in range(w):
        if (i - j) % FIVE in [2, 3]:
          O = paint(O, recolor(SIX, {(i, j)}))
  elif (h, w) == (FIVE, FIVE):
    O = paint(O, recolor(NINE, {(1,2),(1,3),(2,3),(3,3)}))
    O = paint(O, recolor(NINE, {(3,0),(4,0),(4,1),(4,2)}))
    O = paint(O, recolor(NINE, {(2,1)}))
    O = paint(O, recolor(NINE, {(0,1)}))
  return O
 
14.0, 8.150549, def ebfdichaddffebjcjibjicfccfahgdfc(I):
    O = I
    h, w = shape(I)
    if (h, w) == (THREE, THREE):
        O = fill(O, FOUR, backdrop(asindices(crop(O, (1, 1), (1, 1)))))
    elif (h, w) == (FIVE, FIVE):
        indices = set()
        for i in range(h):
            indices.add(((i + 2) % FIVE, i))
            indices.add(((i + 3) % FIVE, i))
        O = fill(O, SIX, frozenset(indices))
    elif (h, w) == (FIVE, FIVE):
        O = fill(O, NINE, frozenset({(1, 2), (1, 3), (2, 3), (3, 3), (3, 0), (4, 0), (4, 1), (4, 2), (2, 1), (0, 1)}))
    return O
 
7.666666666666667, 4.7068853, def jahdbejdebcaejbajccchdbgeegcjbcj(I):
  h, w = shape(I)
  center_i, center_j = h // 2, w // 2
  cross = {(center_i, center_j), (center_i - 1, center_j), (center_i + 1, center_j), (center_i, center_j - 1), (center_i, center_j + 1)}
  diag1 = {(i, i) for i in range(min(h, w) - 1)}
  diag2 = {(h - i - 2, i) for i in range(min(h, w) - 1)}
  vline1 = {(i, center_j - 1) for i in range(1, h - 1)}
  vline2 = {(i, center_j + 1) for i in range(1, h - 1)}
  return branch(h == 3 and w == 3, 
               fill(I, 4, cross),
               branch(h == 5 and w == 5,
                      fill(fill(fill(I, 6, diag1), 6, diag2), 6, {(0, 4), (4, 0)}),
                      fill(fill(I, 9, vline1), 9, vline2)))
 
6.666666666666667, 7.042115, def affbedjdcbgdebbaicadhfdbbidbdbab(I):
  h, w = shape(I)
  return branch(h == 3,
               fill(I, 4, {(1, 1), (0, 1), (2, 1), (1, 0), (1, 2)}),
               branch(w == 5,
                      fill(fill(I, 6, connect((0, 0), (3, 3))), 6, connect((4, 0), (1, 3))),
                      fill(fill(I, 9, {(1, 1), (2, 1), (3, 1), (1, 3), (2, 3)}), 9, {(0, 2), (4, 2)}))) 
 
7.333333333333333, 5.4349165, def aabfbgaeeeaeehhcaajacfafbddfbafc(I):
  h, w = shape(I)
  O = fill(I, 4, {(h // 2, w // 2), (h // 2 - 1, w // 2), (h // 2 + 1, w // 2), (h // 2, w // 2 - 1), (h // 2, w // 2 + 1)}) if h == 3 else I
  O = fill(fill(O, 6, connect((0, 0), (w - 2, w - 2))), 6, connect((h - 1, 0), (1, w - 2))) if w == 5 else O
  return fill(fill(O, 9, connect((1, w // 2 - 1), (h - 2, w // 2 - 1))), 9, connect((1, w // 2 + 1), (h - 2, w // 2 + 1))) if w == 5 else O
 
8.333333333333334, 8.382129, def aejdcffacfgeeejdiabcccjjbadbhhcc(I):
  """
  Calculates the new color based on half the perimeter and 
  uses 'paint' and 'recolor' for a concise solution.
  """
  h, w = shape(I)
  c = (h + w) - 2 
  cross = connect((1, w // 2), (h - 2, w // 2)) | connect((h // 2, 1), (h // 2, w - 2))
  O = paint(canvas(0, (h, w)), recolor(c, cross))
  return O
 
7.0, 8.974207, def jbeheddjagdaefihjaegjfccbbcfcdch(I):
  """
  Utilizes 'centerofmass' and 'dneighbors' to identify and recolor
  cells around the central point of the grid.
  """
  h, w = shape(I)
  c = (h + w) - 2 
  center = centerofmass(asindices(I))
  cross = dneighbors(center) 
  O = paint(canvas(0, (h, w)), recolor(c, cross)) 
  return O
 
10.0, 5.4500017, def ebbdjddecfebeggjbegfaacjaacjaaae(I):
  h, w = height(I), width(I)
  O = canvas(0, (h, w))
  # Diagonal line from top left to bottom right
  O = fill(O, h + w - 2, connect((0, 0), (h - 1, w - 1)))
  # Offset parallel diagonal line 
  if h > 2 and w > 2:
    O = fill(O, h + w - 2, connect((1, 0), (h - 1, w - 2)))
  return O
 
11.666666666666666, 8.534734, def fbgffaeedbffebefbfdijcdaagfcbcbe(I):
    h, w = height(I), width(I)
    O = canvas(0, (h, w))
    diag = connect((0, 0), (h - 1, w - 1))
    O = fill(O, h + w - 2, diag)
    if h > 2 and w > 2:
      O = fill(O, h + w - 2, hmirror(diag))
    return O
 
10.0, 5.2661343, def ibacgabhbicfedbfbbfcdcedebhbdccd(I):
  h, w = height(I), width(I)
  O = I
  for i in range(h):
    for j in range(w):
      if i == j or (i == j + 1 and i < h - 1):
        O = fill(O, h + w - 2, {(i, j)})
  return O
 
7.333333333333333, 5.48539, def feddfieeffhgeiecjbcacagbeagicccb(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR, {(ONE,ZERO),(ZERO,ONE),(ONE,ONE),(TWO,ONE),(ONE,TWO)})
  elif h == 5:
    if even(colorcount(I,ZERO)):
      O = fill(O, SIX, {(i,i) for i in range(h)})
      O = fill(O, SIX, {(h-i-1,i) for i in range(h)})
    else:
      O = fill(O, NINE, {(i//2,i) for i in range(h)})
      O = fill(O, NINE, {(h-i//2-1,i) for i in range(h)})
  return O
 
7.666666666666667, 6.1597223, def fiddbfdeeefjeicbibbjhgcdabbedggi(I):
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  if h == 3:
    center = (h // 2, w // 2)
    O = fill(O, FOUR, {(center[0] + i, center[1] + j) for i in range(-1, 2) for j in range(-1, 2) if abs(i) != abs(j)})
  elif h == 5:
    for i in range(h):
      if even(colorcount(I,ZERO)):
        O = fill(O, SIX, {(i, i)})
        O = fill(O, SIX, {(h-i-1, i)})
      else:
        O = fill(O, NINE, {(i // 2, i)})
        O = fill(O, NINE, {(h - i // 2 - 1, i)})
  return O
 
9.0, 10.508044, def bdiaeddbbgaaeafgjgffdafcbdajdbaf(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR,  delta(asindices(crop(O, (1,1), (1,1)))))
  elif h == 5:
    if even(colorcount(I,ZERO)):
      O = fill(O, SIX, connect((0,0), (h-1,h-1)))
      O = fill(O, SIX, connect((h-1,0), (0,h-1)))
    else:
      O = fill(O, NINE, {(i//2,i) for i in range(h)})
      O = fill(O, NINE, {(h-i//2-1,i) for i in range(h)})
  return O
 
10.0, 6.2496953, def bbedehfahdebeebjjeedfhgiegghdfaa(I):
  O = canvas(ZERO, shape(I))
  h, w = shape(I)
  if h == 3:
    O = fill(O, FOUR,  {(ONE,ZERO),(ZERO,ONE),(ONE,ONE),(TWO,ONE),(ONE,TWO)})
  elif h == 5:
    for i in range(h):
      for j in range(w):
        if even(colorcount(I,ZERO)) and  (i == j or i + j == h - 1):
          O = fill(O, SIX, {(i, j)})
        elif not even(colorcount(I,ZERO)) and (j == i // 2 or j == h - i // 2 - 1):
          O = fill(O, NINE, {(i, j)})
  return O
 
10.0, 8.725857, def idcecgafbacgehfebjedfhhedfchjiba(I):
  return branch(size(I) == 9,
               fill(I, 4, {(i // 3, i % 3) for i in [4, 1, 7, 3, 5]}),
               branch(palette(I) == {0},
                      fill(fill(I, 6, {(i, i) for i in range(len(I))}), 6, {(len(I) - i - 1, i) for i in range(len(I))}),
                      fill(fill(I, 9, {(i, 1) for i in range(1, len(I) - 1)}), 9, {(0, len(I[0]) - 2), (len(I) - 1, len(I[0]) - 2)})))
 
8.0, 9.486188, def bdbhejjgeecfeadaaaicdbjbedhjcbbg(I):
  """
  Constructs the transformed grid by directly painting the desired shapes.
  """
  h, w = shape(I)
  c = (h + w) - 2
  if h == 3: # Specific case for 3x3 grid
    O = paint(canvas(0, (h, w)), recolor(c, {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}))
  else: # General case for larger grids
    O = paint(canvas(0, (h, w)), recolor(c, {(0, 1), (1, 1), (h-2, 1), (h-1, 1), (h-1, 0), (h-1, w-2), (h-1, w-1)})) 
  return O
 
9.0, 9.822273, def bdehcdcabadeeicjigifigbjjeahdbeb(I):
  """
  This version leverages symmetry and loops for a more general approach.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))
  for i in range(1, h-1):
      O = paint(O, recolor(c, {(i, w // 2)}))
      O = paint(O, recolor(c, {(h - 1, i)}))
  return O
 
9.333333333333334, 6.627454, def iaffafdaggjeecfcjheafhdgfdecihdd(I):
  """
  This version employs 'dneighbors' and 'centerofmass' for dynamic positioning.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))
  center = centerofmass(asindices(I))
  cross = dneighbors(center)
  if h == 3:  # Special case for 3x3 grid
    O = paint(O, recolor(c, cross | {(center[0] - 1, center[1]), (center[0] + 1, center[1])}))
  else:  # General case for larger grids
    O = paint(O, recolor(c, {(i, center[1]) for i in range(h)}))
    O = paint(O, recolor(c, {(h - 1, j) for j in range(w)}))
  return O
 
9.0, 7.3174706, def edfaddcageffegdbjhebdggbciacebbd(I):
  """
  This version combines 'connect' and corner points for a geometric approach.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))
  if h == 3: # Specific case for 3x3 grid
    O = paint(O, recolor(c, connect((1, 0), (1, 2))))
    O = paint(O, recolor(c, connect((0, 1), (2, 1))))
  else: # General case for larger grids
    O = paint(O, recolor(c, connect((0, w // 2), (h - 2, w // 2))))
    O = paint(O, recolor(c, connect((h - 1, 0), (h - 1, w - 1))))
  return O
 
11.333333333333334, 21.409674, def iacgjibbdbfaefcgagadccecejebecgd(I):
  h, w = shape(I)
  c = halve(h + w + h + w) - (ONE if even(size(I)) else ZERO)
  O = fill(I, c, {(h // TWO, j) for j in range(w)}) # Fill middle row
  O = fill(O, c, {(i, w // TWO) for i in range(h)}) # Fill middle column
  return O
 
11.333333333333334, 10.293841, def bgacfhcibdbbegheiahfccffbbeahdde(I):
  d = subtract(shape(I), UNITY)
  color = sum(d) // TWO
  O = fill(I, color, {(d[0] // TWO, j) for j in range(d[1] + ONE)})
  O = fill(O, color, {(i, d[1] // TWO) for i in range(d[0] + ONE)})
  return O
 
10.666666666666666, 7.0359592, def dfcajfcafiecebidbacjejcbegefeddb(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR, {(i,i) for i in range(h)})
    O = fill(O, FOUR, {(h-i-1,i) for i in range(h)})
  elif h == 5:
    if colorcount(I, ZERO) == 25:
      O = fill(O, SIX, {(i,(i+2)%h) for i in range(h)})
      O = fill(O, SIX, {((i+1)%h,(i+2)%h) for i in range(h)})
    else:
      O = fill(O, NINE, {(i, (2*i)%h) for i in range(h)})
      O = fill(O, NINE, {(i, (2*i+2)%h) for i in range(h)})
  return O
 
10.0, 10.3992195, def eefiacjhfhabebccjbheijaddeacbcbe(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR, connect((0,0), (2,2)))
    O = fill(O, FOUR, connect((2,0), (0,2)))
  elif h == 5:
    value = SIX if colorcount(I, ZERO) == 25 else NINE
    O = fill(O, value, connect((0,2), (4,1)).union(connect((1,2), (4,3))))
    O = fill(O, value, connect((0,4), (3,1)).union(connect((1,4), (4,2))))
  return O
 
14.666666666666666, 8.290708, def gadaahdcjeiieeddafafjccbcdffafcj(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR, {(i, j) for i in range(h) for j in range(w) if i == j or i + j == h - 1})
  elif h == 5:
    value = SIX if set(merge(I)) == {ZERO} else NINE
    O = fill(O, value, {(i, j) for i in range(h) for j in range(w) if (j == (i + 2) % h) or (j == (i + 3) % h)})
  return O
 
8.666666666666666, 16.049011, def baaebfddddbaebebbibbegdabeabcfec(I):
  h, w = shape(I)
  O = I
  if h == 3:
    O = fill(O, 4, {(1, 1), (0, 1), (2, 1), (1, 0), (1, 2)})
  elif w == 5:
    O = fill(O, 6, connect((0, 0), (h - 1, w - 1)))
    O = fill(O, 6, connect((w - 1, 0), (1, h - 2)))
    O = fill(O, 9, {(j, 2) for j in range(h)})
    O = fill(O, 9, {(j, w - 2) for j in range(0, h, 2)}) 
  return O
 
9.0, 11.518372, def hdbeafcbeadaejhejagfadcgcbhchfeb(I):
  h, w = shape(I)
  if h == 3:
    return fill(I, 4, {(1, 1), (0, 1), (2, 1), (1, 0), (1, 2)})
  elif w == 5:
    O = canvas(0, (h, w))
    O = fill(O, 6, connect((0, 0), (h - 1, w - 1)))
    O = fill(O, 6, connect((w - 1, 0), (1, h - 2)))
    O = fill(O, 9, connect((2, 0), (2, h - 1)))
    return fill(O, 9, {(i, w - 2) for i in range(0, h, 2)})
  return I
 
9.666666666666666, 16.910564, def egjefbadidabeeicaiebdfdfdagifebh(I):
  """
  This version uses 'for' loops to iterate and recolor the grid.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))  # Start with a blank canvas
  for i in range(h // 2):  # Vertical line
    O = paint(O, recolor(c, {(i, 0)}))
  for j in range(w // 2, w):  # Horizontal line
    O = paint(O, recolor(c, {(h - 1, j)}))
  return O
 
14.0, 33.440403, def bgijbfeafcahecafbhfceadbaiaiaagf(I):
  """
  This version uses 'hsplit' and 'vsplit' to divide and conquer.
  """
  h, w = shape(I)
  c = (h + w) - 2
  top, bottom = vsplit(I, 2)
  left_top, right_top = hsplit(top, 2)
  left_bottom, right_bottom = hsplit(bottom, 2)
  line_v = paint(left_top, recolor(c, {(i, 0) for i in range(h // 2)}))
  line_h = paint(right_bottom, recolor(c, {(h - 1, i) for i in range(w // 2)}))
  O = vconcat(hconcat(line_v, right_top), hconcat(left_bottom, line_h))
  return O
 
11.333333333333334, 16.586483, def bbefagbccaeieafcjfcadchhegdjccgf(I):
  """
  This version uses 'shoot' function for a geometric approach.
  """
  h, w = shape(I)
  c = (h + w) - 2
  start_v = (0, 0) 
  start_h = (h-1, w // 2)
  v_line = shoot(start_v, DOWN)
  h_line = shoot(start_h, LEFT)
  O = paint(canvas(0, (h, w)), recolor(c, (v_line | h_line))) 
  return O
 
9.0, 9.246017, def ggbcgjdccbfeeabfaaeacjchhhhdacja(I):
  """ 
  Calculates the color based on grid size and fills a cross pattern 
  centered at the grid's center.
  """
  s = subtract(shape(I), TWO)  # Calculate dimensions minus 2
  c = sum(s)                  # Calculate color
  O = canvas(ZERO, shape(I))  # Initialize output grid
  center = divide(shape(I), TWO) # Find center coordinates
  
  # Fill the cross pattern
  for i in range(s[0] + ONE):
    for j in range(s[1] + ONE):
      if i == center[0] or j == center[1]: 
        O = fill(O, c, {(i, j)})
  return O
 
7.333333333333333, 36.732536, def bhcfhaabdhdeefbfaecidbaafbjibihf(I):
  """ 
  Uses conditional color filling based on grid size and index parity
  to create the cross pattern.
  """
  size = shape(I)
  color = sum(subtract(size, (TWO, TWO)))
  O = I
  center = divide(size, TWO)
  for i in range(size[0]):
    for j in range(size[1]):
      if (i == center[0] or j == center[1]) and (even(size[0]) or (not even(i) and not even(j))):
        O = fill(O, color, {(i, j)})
  return O
 
11.333333333333334, 9.344518, def cdjbacfehaeeefejicchdaaahagdfjji(I):
  """
  Leverages hfrontier and vfrontier to draw the cross directly,
  adjusting color based on grid size parity. 
  """
  s = halve(sum(shape(I))) # Calculate half the sum of dimensions
  c = decrement(s) if even(size(I)) else s # Adjust color for even-sized grids
  O = fill(I, c, {center(asindices(I))})  # Fill the center cell 
  O = fill(O, c, hfrontier(center(asindices(I)))) # Draw horizontal line
  O = fill(O, c, vfrontier(center(asindices(I)))) # Draw vertical line
  return O 
 
12.666666666666666, 8.836144, def hhbdcecdcjbeegjabgjgdbcbfbccefej(I):
  """
  Calculates color and uses nested loops to selectively fill cells 
  based on their distance from the center.
  """
  size = add(shape(I), (-ONE, -ONE)) # Calculate side length minus 1
  color = sum(size) // TWO # Calculate color
  center_cell = center(asindices(I)) # Find the center cell
  O = I
  for i in range(size[0]):
    for j in range(size[1]):
      if i == j or i+j == size[0] -1 or i == size[0] // 2 or j == size[1] // 2:
        O = fill(O, color, {add(center_cell, (i - size[0] // 2, j - size[1] // 2))})
  return O
 
17.0, 38.401917, def gfabddafjcacebdciibdfccffdgdcaea(I):
    fill_value = 2 * len(I[0]) + 2
    boundary_indices = difference(asindices(I), inbox(asindices(I)))
    return paint(canvas(mostcolor(I), shape(I)), recolor(fill_value, boundary_indices)) 
 
16.666666666666668, 33.760708, def bfbjadbddfbfehaibcjedcceaedbiadj(I):
    fill_value = 2 * len(I[0]) + 2
    boundary_cells =  frozenset(
        (i, j) for i in range(len(I)) for j in range(len(I[0])) 
        if i == 0 or i == len(I) - 1 or j == 0 or j == len(I[0]) - 1
    )
    return paint(canvas(mostcolor(I), shape(I)), recolor(fill_value, boundary_cells))
 
7.333333333333333, 9.828074, def edifibbbcddjeiffiafhfefffdgfaahd(I):
    h, w = shape(I)
    O = canvas(ZERO, (h, w))
    if h == 3:  # 3x3 grid transformation
        O = fill(O, FOUR, {(1, 0), (1, 1), (1, 2), (0, 1), (2, 1)})
    elif h == 5:  # 5x5 grid transformation
        for i in range(h):
            O = fill(O, SIX, {(i, (i + 1) % h)})
            O = fill(O, SIX, {(i, (i - 1) % h)})
    else:  # 5x5 grid transformation with shifted center
        O = fill(O, NINE, {(0, 1), (2, 1), (4, 1), (1, 2), (1, 3), (3, 0), (3, 1), (4, 3), (4, 4)})
    return O
 
10.333333333333334, 10.611205, def gbfheeedfidbeebbijaaedcfgcjhfbde(I):
  h, w = shape(I)
  O = I
  if h == 3:
    O = fill(O, FOUR, neighbors((1,1)).union({(1,1)}))
  elif h == 5:
    for i in range(h):
      O = fill(O, SIX, {(i, (2*i) % h)})
      O = fill(O, SIX, {(i, (2*i + 4) % h)})
  else:
    for i in range(h):
      for j in range(w):
        if (i == 1 and (j == 2 or j == 3)) or (i == 3 and j == 1) or ((i == 0 or i == 2 or i == 4) and (j == 1 or j == 3 or j == 4)):
          O = fill(O, NINE, {(i,j)})
  return O
 
13.333333333333334, 31.583464, def caaddcdeaeggebeeidcfadfajcbhidhd(I):
  O = canvas(ZERO, shape(I))
  h, w = shape(I)
  if h == 3:
    O = fill(O, FOUR, {(h//2, j) for j in range(w)}.union({(i, w//2) for i in range(h)}))
  elif h == 5:
    for d in range(-2, 3):
      O = fill(O, SIX, {(i, (i + d) % h) for i in range(h)})
  else:
    nine_indices = [(0, 1), (2, 1), (4, 1), (1, 2), (1, 3), (3, 0), (3, 1), (4, 3), (4, 4)]
    O = fill(O, NINE, set(nine_indices))
  return O
 
7.0, 7.4826097, def bedjeabdddefefdcbbbdcaebdieieegh(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  if h == 3:
    O = fill(O, FOUR, {(i,j) for i in range(h) for j in range(w) if abs(i - h//2) + abs(j - w//2) <= 1})
  elif h == 5:
    for i in range(h):
      for j in range(w):
        if abs(i-j) <= 1 or abs(i-j) == h-1:
          O = fill(O, SIX, {(i, j)})
  else:
    for i in range(h):
      for j in range(w):
        if (j == w // 2 and i != 1) or (i == 1 and (j == w // 2 + 1 or j == w // 2 + 2)) or (i == 3 and j == w // 2 - 1) or ((i == 0 or i == 2 or i == 4) and (j == w // 2 + 1 or j == w // 2 - 1)):
          O = fill(O, NINE, {(i, j)})
  return O
 
8.333333333333334, 7.5153446, def idechcjgdbaaedaijhdbhfjbbbjfabdd(I):
  O = I
  h, w = shape(I)
  if h == 3:
    O = fill(O, FOUR, {(i, j) for i in range(max(0, h//2 - 1), min(h, h//2 + 2)) for j in range(max(0, w//2 - 1), min(w, w//2 + 2))})
  elif h == 5:
    for i in range(h):
      for j in range(w):
        if (i-j)%h in [h-1, 0, 1]:
          O = fill(O, SIX, {(i, j)})
  else:
    for i in range(h):
      for j in range(w):
        if (j == w//2 and (i != 1)) or ((i == 1 or i == 3) and abs(j - w//2) == 1) or ((i == 0 or i == 2 or i == 4) and abs(j - w//2) == 2):
          O = fill(O, NINE, {(i, j)})
  return O
 
4.666666666666667, 4.068515, def edbecfbachgeehjeigaicbebcfefjfha(I):
  h, w = shape(I)
  return branch(h == 3,
               fill(I, 4, {(1, 1), (0, 1), (2, 1), (1, 0), (1, 2)}),
               branch(w == 5,
                      fill(fill(I, 6, connect((0, 0), (4, 4))), 6, connect((0, 1), (3, 4))),
                      fill(fill(I, 9, connect((w // 2, 0), (w // 2, h - 1))), 9, connect((w - 2, 1), (w - 2, h))))
               )
 
8.0, 13.696755, def ahihccicabdheiggiaedbadgbcdbifbf(I):
  h, w = shape(I)
  O = fill(I, 4, {(h // 2, w // 2), (h // 2 - 1, w // 2), (h // 2 + 1, w // 2), (h // 2, w // 2 - 1), (h // 2, w // 2 + 1)}) if h == 3 else I
  O = fill(fill(O, 6, connect((0, 0), (w - 1, h - 1))), 6, connect((0, 1), (w - 2, h - 1))) if w == 5 and h == 5 else O
  return fill(fill(O, 9, connect((w // 2, 0), (w // 2, h - 1))), 9, connect((w - 2, 1), (w - 2, h))) if w == 5 else O 
 
6.0, 8.425002, def habbgdihccbfejaebcdeeegibdifiedf(I):
  h, w = shape(I)
  return branch(h == 3, 
               fill(I, 4, {(i, j) for i in range(max(0, h // 2 - 1), min(h, h // 2 + 2)) for j in range(max(0, w // 2 - 1), min(w, w // 2 + 2))}),
               branch(w == 5,
                      fill(fill(I, 6, connect((0, 0), (w - 1, h - 1))), 6, connect((0, 1), (w - 2, h - 1))),
                      fill(fill(I, 9, connect((2, 0), (2, h - 1))), 9, connect((3, 1), (3, h))))
               )
 
5.0, 4.008967, def egdfbbbedjefegeijdaifcaccfeajbih(I):
  h, w = shape(I)
  if h == 3:
    center = (h // 2, w // 2)
    return fill(I, 4,  {(center[0] + i, center[1] + j) for i in [-1, 0, 1] for j in [-1, 0, 1] if abs(i) != abs(j)})
  elif w == 5:
    return branch(h == 5,
                 fill(fill(I, 6, connect((0, 0), (4, 4))), 6, connect((0, 1), (3, 4))),
                 fill(fill(I, 9, connect((2, 0), (2, h - 1))), 9, connect((3, 1), (3, h))))
  return I
 
9.666666666666666, 9.301274, def afeehdaeacchejidajbeeecadecbcefe(I):
  """
  This version uses loops to iterate over the grid.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))
  for i in range(h):
    if i == h // 2:
      O = fill(O, c, {(i, j) for j in range(w)})
    else:
      O = fill(O, c, {(i, w // 2)})
  return O 
 
8.666666666666666, 10.598944, def ddfibcccbfbfechjjabedfebcaadichh(I):
  """
  This version utilizes 'center' and 'connect' for line drawing.
  """
  h, w = shape(I)
  c = (h + w) - 2
  center_point = center(asindices(I))
  v_line = connect(center_point, (h - 1, center_point[1]))  
  h_line = connect(center_point, (center_point[0], w - 1))
  O = paint(canvas(0, (h, w)), recolor(c, v_line | h_line)) 
  return O
 
10.0, 9.112279, def dcfebhdcdbfeedfhjhadcghcbebbcdgi(I):
  """
  Draws diagonal lines from the center outwards using the sum of dimensions - 4.
  """
  h, w = shape(I)
  c = h + w - 4
  O = canvas(ZERO, (h, w))
  center_i, center_j = divide((h, w), TWO)
  for i in range(h):
    for j in range(w):
      if abs(i - center_i) == abs(j - center_j):
        O = fill(O, c, {(i, j)})
  return O
 
9.0, 5.170708, def ddbdfefdagccedfeaaecciedajeebfag(I):
  """
  Leverages symmetry to draw only one diagonal line and then mirrors it.
  """
  h, w = shape(I)
  c = h + w - 4
  O = canvas(ZERO, (h // 2 + h % 2, w // 2 + w % 2))
  center_i, center_j = divide((h, w), TWO)
  for i in range(h // 2 + h % 2):
    for j in range(w // 2 + w % 2):
      if i == j:
        O = fill(O, c, {(i, j)})
  O = hconcat(O, hmirror(O))
  if w % 2 == 1:
    O = tuple(row[:-1] for row in O)
  O = vconcat(O, vmirror(O))
  if h % 2 == 1:
    O = O[:-1]
  return O
 
9.333333333333334, 9.126232, def bhacfdeecabceeifaifidfbafbbhdgde(I):
  """
  Applies transformations to a single-cell object.
  """
  h, w = shape(I)
  c = h + w - 4
  O = canvas(ZERO, (h, w))
  center_i, center_j = divide((h, w), TWO)
  obj = {(c, (center_i, center_j))}
  for i in range(max(h, w)):
    O = paint(O, obj)
    obj = obj | shift(obj, (1, 1)) | shift(obj, (-1, 1))
  return O
 
19.666666666666668, 69.23601, def fcedfaghigcaegcbjchahbbfacjdeefd(I):
    fill_value = 2 * width(I) + 2
    h, w = shape(I)
    boundary_indices = combine(interval(0, w, 1), interval(h - 1, h, 1))
    boundary_cells_top_bottom = mapply(lambda i: product({i}, interval(0, w, 1)), boundary_indices)
    boundary_indices = combine(interval(0, h, 1), interval(w - 1, w, 1))
    boundary_cells_left_right = mapply(lambda j: product(interval(0, h, 1), {j}), boundary_indices)
    boundary_cells = combine(boundary_cells_top_bottom, boundary_cells_left_right)
    return paint(canvas(mostcolor(I), (h, w)), recolor(fill_value, boundary_cells)) 
 
8.0, 7.6977134, def dedbaddbbaedecchjjbfadcehaicdgaj(I):
  O = I
  h, w = shape(I)
  if (h, w) == (THREE, THREE): # For 3x3 grid
    center_idx = (h // 2, w // 2) 
    O = paint(O, recolor(FOUR, {center_idx})) # Paint the center
    for direction in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Paint in each direction
      O = paint(O, recolor(FOUR, {add(center_idx, direction)})) 
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      if i % 2 == 0:  # For even rows
        O = paint(O, recolor(NINE, {(i, 1)}))
        O = paint(O, recolor(NINE, {(i, 3)}))
      else:  # For odd rows
        O = paint(O, recolor(SIX, {(i, i)}))
        O = paint(O, recolor(SIX, {(h - i - 1, i)})) 
  return O
 
10.666666666666666, 8.16356, def cafdjecdihieeadhajaecebcabaabaaf(I):
  O = canvas(ZERO, shape(I)) # Initialize with zeros
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    O = fill(O, FOUR, {(i, j) for i in range(h) for j in range(w) if abs(i - 1) == abs(j - 1) or (i, j) == (1, 1)}) 
    # Fills '4' where i-1 equals j-1 or at the center
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      for j in range(w):
        if i % 2 == 0 and j % 2 == 1: # For every other row and column
          O = paint(O, recolor(NINE, {(i, j)}))
        elif i % 2 == 1: # For every other row
          O = paint(O, recolor(SIX, {(i, (i + 2) % h)})) 
  return O
 
8.0, 6.6456695, def bbeccggffahaeiidacjgacaefdeaebjb(I):
  O = I
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    O = paint(O, recolor(FOUR, {(i, j) for i in range(h) for j in range(w) if i == 1 or j == 1})) 
    # Paint '4' on the center row and column
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      if i % 2 == 0:
        O = paint(O, recolor(NINE, {(i, j) for j in range(1, w, 2)})) # For even rows, paint every other column with '9'
      else:
        O = paint(O, recolor(SIX, {(i, (i + j * 2) % h) for j in range(2)})) 
        # For odd rows, paint two '6's diagonally with an offset
  return O
 
8.666666666666666, 6.091654, def fefcfffbbaffeeafagaadjdbedffahdb(I):
  O = canvas(ZERO, shape(I)) # Start with a blank canvas of zeros
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    O = paint(O, recolor(FOUR, {(h // 2, w // 2)})) # Paint the center with '4'
    O = paint(O, recolor(FOUR, {(h // 2 + i, w // 2) for i in [-1, 1]}))  
    # Paint '4' above and below the center
    O = paint(O, recolor(FOUR, {(h // 2, w // 2 + j) for j in [-1, 1]})) 
    # Paint '4' to the left and right of the center
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      if even(i):
        O = paint(O, recolor(NINE, {(i, 1 + 2 * j) for j in range(w // 2)})) # Paint '9's on even rows with spacing
      else:
        O = paint(O, recolor(SIX, {(i, (i + 2) % h)})) # Paint '6' diagonally
        O = paint(O, recolor(SIX, {(h - 1 - i, (i + 2) % h)})) # Paint the mirroring '6' diagonally 
  return O
 
11.333333333333334, 6.8944254, def dadaaachjbibebgdaiddafhdadhbcbga(I):
  O = I
  h, w = shape(I)
  if (h, w) == (THREE, THREE):
    O = paint(O, recolor(FOUR, {(i, j) for i in range(h) for j in range(w) if (i == j) or (i + j == h - 1) or (i, j) == (h // 2, w // 2)}))
    # Fills '4' for diagonals, anti-diagonals, and the center
  elif (h, w) == (FIVE, FIVE):
    for i in range(h):
      O = paint(O, recolor(branch(even(i), NINE, SIX), {(i, (i + 2 * (i % 2)) % h)}))
      # Uses branch to choose between '9' and '6' based on row index
      O = paint(O, recolor(branch(even(i), NINE, SIX), {(i, (h - i - 1 + 2 * (i % 2)) % h)}))
      # Similar logic for the mirroring diagonal with '9' or '6' 
  return O
 
4.666666666666667, 4.7601967, def hicdcbfjedcfehbejcajiedjiificdib(I):
  h, w = shape(I)
  if h == 3:
    return fill(I, 4,  {(1, 1), (0, 1), (2, 1), (1, 0), (1, 2)}) 
  elif w == 5:
    return fill(fill(I, 6, connect((0, 0), (4, 4))), 6, connect((0, 1), (3, 4)) | {(h-1, 0)})
  else:
    return fill(fill(I, 9, connect((w // 2, 0), (w // 2, h - 1))), 9, connect((w - 2, 1), (w - 2, h-1)) | {(w-1, 0), (w-1, h-1)})
 
5.0, 4.7795033, def defddihjffdiebgejjbfcegjehfcccdc(I):
  h, w = shape(I)
  if h == 3:
    return fill(I, 4,  {(h//2 + i, w//2 + j) for i in [-1, 0, 1] for j in [-1, 0, 1] if abs(i) != abs(j)}) 
  elif w == 5:
    line1 = connect((0, 0), (4, 4))
    line2 = connect((0, 1), (3, 4)) | {(h-1, 0)}
    return fill(fill(I, 6, line1), 6, line2) 
  else:
    vert_line = connect((w // 2, 0), (w // 2, h - 1))
    horiz_points = {(w-1, 0), (w-1, h-1)}
    return fill(fill(I, 9, vert_line), 9, connect((w - 2, 1), (w - 2, h-1)) | horiz_points)
 
14.0, 10.171434, def afabfagfdhigeiedbbhddcebiggaahbc(I):
  """
  This version iterates through each cell and applies the transformation based on its position.
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w)) 
  for i in range(h):
    for j in range(w):
      if i == j or i + j == h - 1 or i == h // 2 or j == w // 2:
        O = fill(O, c, {(i, j)})
  return O
 
11.333333333333334, 9.626556, def ddfbgadaghfaeicajhfeeecabgdeedgj(I):
  """
  This version utilizes 'dneighbors' and 'centerofmass' to identify the cross, then expands it. 
  """
  h, w = shape(I)
  c = (h + w) - 2
  O = canvas(0, (h, w))
  center = centerofmass(asindices(I))
  O = fill(O, c, dneighbors(center))
  for i in range(1, min(h // 2 + 1, w // 2 + 1)):
    O = fill(O, c, {(center[0] + i, center[1] + i)})
    O = fill(O, c, {(center[0] - i, center[1] - i)})
    O = fill(O, c, {(center[0] + i, center[1] - i)})
    O = fill(O, c, {(center[0] - i, center[1] + i)})
  return O
 
12.0, 13.057233, def hfddddjcggdheddiaefbiajhaadfdfda(I):
  """
  Creates diagonal lines by iterating through grid indices
  and checking for specific row-column relationships.
  """
  h, w = shape(I)
  color = h + w - 4 
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if i == j or i + j == h - 1:
        O = fill(O, color, {(i, j)})
      if h > 3 and w > 3:
        if i + j == h - 3 or i == j + 2:
            O = fill(O, color, {(i, j)})
      if h > 4 and w > 4:
        if i + j == h - 5 or i == j + 4:
          O = fill(O, color, {(i, j)})
  return O
 
9.666666666666666, 8.685475, def hhicbbdebdffedigicjaecccacfgajac(I):
  """
  Utilizes shifting and combining objects to create the pattern.
  """
  h, w = shape(I)
  color = h + w - 4
  diag1 = recolor(color, connect((0, 0), (h - 1, w - 1))) 
  diag2 = shift(diag1, (1, -1))
  diag3 = shift(diag1, (2, -2))
  O = paint(canvas(0, (h, w)), diag1)
  if h > 3 and w > 3:
    O = paint(O, diag2)
  if h > 4 and w > 4:
    O = paint(O, diag3)
  return O 
 
10.0, 8.695235, def fefeeafgcgaeefgiighibhhcfchcafab(I):
  """
  Recursively draws diagonals for different grid sizes.
  """
  h, w = shape(I)
  color = h + w - 4
  def draw_diagonal(grid, offset):
    for i in range(min(h, w - offset)):
      grid = fill(grid, color, {(i, i + offset)})
    return grid
  O = canvas(0, (h, w))
  O = draw_diagonal(O, 0)
  if h > 3 and w > 3:
    O = draw_diagonal(O, 2)
  if h > 4 and w > 4:
    O = draw_diagonal(O, 4)
  return O 
 
12.666666666666666, 14.090932, def feifdjfhacfieijebcdbjiaiefegbddb(I):
  """
  Employs modulo operation to determine diagonal cell positions.
  """
  h, w = shape(I)
  color = h + w - 4
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if (i + j) % 2 == 0 or (i + j) % 4 == 0: 
        O = fill(O, color, {(i, j)})
  return O
 
9.666666666666666, 7.3288746, def caiddehcfdaaeefdagchaiacgbbcbeib(I):
  v = mostcolor(I) + 4 if len(I) == 3 else mostcolor(I) + 5
  O = fill(I, v, {(i, i) for i in range(len(I))})
  O = fill(O, v, {(len(I) - 1 - i, i) for i in range(len(I))}) if len(I) == 5 else O
  O = fill(O, v, {(1, 1), (2, 2)}) if len(I) == 3 else O 
  O = fill(O, v, {(0, 1), (2, 1), (1, 0), (1, 2)}) if len(I) == 3 else O
  return O 
 
8.666666666666666, 7.8552465, def ddbgddaabbfieafeiaedeccbfceajacc(I):
  O = I
  h, w = shape(I)
  v = 4 if (h, w) == (THREE, THREE) else 9
  if (h, w) == (THREE, THREE):
    O = paint(O, recolor(v, {(i, j) for i in range(h) for j in range(w) if abs(i - h // 2) + abs(j - w // 2) <= 1}))
  elif (h, w) == (FIVE, FIVE):
    O = paint(O, recolor(v, {(i, i) for i in range(h)}))
    O = paint(O, recolor(v, {(h - 1 - i, i) for i in range(h)}))
    if v == 9:
      O = paint(O, recolor(v, {(0, 1), (2, 0)}))
  return O
 
8.333333333333334, 5.114797, def ahdhbchbebfeeifeieajdeefceggeceg(I):
  O = I
  s = shape(I)
  v = 4 if s == (THREE, THREE) else 9 if s == (FIVE, FIVE) else 0
  if s == (THREE, THREE):
    for i in range(3):
      O = paint(O, recolor(v, {(1, i), (i, 1)}))
  elif s == (FIVE, FIVE):
    for i in range(5):
      O = paint(O, recolor(v, {(i, (i + 1) % 5)}))
      O = paint(O, recolor(v, {(4 - i, i)}))
    if v == 9:
      O = paint(O, recolor(v, {(0, 1), (2, 0)}))
  return O
 
9.666666666666666, 7.6391854, def bbfaehcddfaaedieibiabfefdiahechg(I):
  O = I
  if len(I) == 3:
    O = paint(O, recolor(4, {(1, 1)}))
    for i in range(3): O = paint(O, recolor(4, {(0, i),(2, i),(i, 0),(i, 2)}))
  else:
    O = paint(O, recolor(9, {(i, (i + 1) % 5) for i in range(5)}))
    O = paint(O, recolor(9, {(4 - i, i) for i in range(5)}))
    O = paint(O, recolor(9, {(0, 1), (2, 0)}))
  return O
 
7.333333333333333, 5.424106, def bfdabgfaffebehjaabcbgiihbceicdfd(I):
  h, w = shape(I)
  if h == 3: # 3x3 grid
    return paint(I, {(4, (i, j)) for i in range(h) for j in range(w) if i == j or i + j == h - 1})
  elif w == 5: # 5x5 grid
    return fill(fill(I, 6, connect((0, 0), (4, 4))), 6, connect((0, 1), (3, 4)) | {(h-1, 0)})
  else: # Assuming 5x5 grid for other cases
    line1 = connect((1, 0), (1, h - 1))
    line2 = connect((3, 0), (3, h - 1))
    return fill(fill(I, 9, line1), 9, line2 | connect(first(line1), first(line2)) | connect(last(line1), last(line2)))
 
11.333333333333334, 9.798715, def jecbebigcejfeaffbbbiibfaidcaadaf(I):
  """
  This version iterates through each cell and checks if it belongs to the diagonals or the center cross.
  """
  h, w = shape(I)
  c = {3: 4, 5: 6, 7: 9}[h]  # Conditional recoloring value based on grid size
  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if i == j or i == w - j - 1 or i == h // 2 or j == w // 2:
        O = paint(O, recolor(c, {(i, j)}))
  return O
 
9.666666666666666, 9.828235, def ahhbcdghfjebeibebcbeafhhbgdcefed(I):
  """
  Uses matrix transposition to efficiently create one diagonal.
  """
  h, w = shape(I)
  color = h + w - 4
  O = canvas(0, (h, w))
  for i in range(h):
    O = fill(O, color, {(i, i)})
  O = hmirror(O)
  return O
 
9.0, 10.344518, def iejfbaccbeidefdjafeabcbcibdjiffb(I):
  """
  Constructs diagonals using connect function and center calculation.
  """
  h, w = shape(I)
  color = h + w - 4
  O = canvas(0, (h, w))
  center = divide(shape(I), TWO)
  O = fill(O, color, connect((0, 0), center))
  O = fill(O, color, connect((0, w - 1), center))
  return O
 
16.0, 12.1304, def eaejdcfbcgdcecacbchabdiaagcgbdbf(I):
    fill_value = (2 * width(I) + 2) % 10
    return fill(canvas(fill_value, shape(I)), mostcolor(I),  asindices(trim(I)))
 
16.666666666666668, 10.270524, def dgbbiabhhejaehfaidabggcecafdfgfd(I):
  fill_value = (2 * width(I) + 2) % 10
  return paint(canvas(mostcolor(I), shape(I)), recolor(fill_value,  box(asindices(I))))
 
19.666666666666668, 37.21413, def fdcgffdececaeefiijjccgabdbbfabdc(I):
  fill_value = (2 * width(I) + 2) % 10
  return cellwise(canvas(fill_value, shape(I)), I, fill_value)
 
