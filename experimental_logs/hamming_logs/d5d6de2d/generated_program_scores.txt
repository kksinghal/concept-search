0.1811111111111111, 30.894295, def eehbcjjhddefeagajdciiffdcfhbcadd(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    O = fill(O, THREE, {(uppermost(obj), leftmost(obj)), (uppermost(obj), leftmost(obj) + 1), (uppermost(obj), leftmost(obj) + 2)})
  return O
 
0.06777777777777778, 13.6218815, def aaijcchcicbcedcgicaaeideeiefccjf(I):
  objs = fgpartition(I)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    if color(obj) == TWO:
      i, j = ulcorner(obj)
      O = paint(O, {(THREE, (i, j)), (THREE, (i, j+1)), (THREE, (i, j+2))})
  return O
 
0.2414814814814815, 34.96225, def cidfbcecebffeaceaddajbbfbbhbcahb(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        if j <= len(row) - 3:
          O = fill(O, THREE, {(i, j), (i, j+1), (i, j+2)})
        else:
          O = fill(O, THREE, {(i, j-(len(row)-3)), (i, j-(len(row)-3)+1), (i, j-(len(row)-3)+2)})
  return O
 
0.08222222222222221, 9.914422, def ibbfdfaajhidebafjabffeahfcjicdeg(I):
  objs = objects(I, True, False, True)
  O = canvas(ZERO, shape(I))
  for obj in objs:
    start = ulcorner(obj)
    O = underfill(O, THREE, {(start[0], start[1]), (start[0], start[1] + 1), (start[0], start[1] + 2)})
  return O
 
0.1796296296296296, 33.57754, def ddihadcfddjdecejbafddcfdaihhhbdc(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0]) - 2):
      if I[i][j] == TWO and I[i][j+1] == TWO and I[i][j+2] == TWO:
        O = fill(O, THREE, {(i, j), (i, j+1), (i, j+2)})
        break
  return O
 
0.2240740740740741, 32.85989, def deicadcbeabaejijbcbefhahbdghhjdh(I):
  # Find objects of digit '2', non-diagonal, without background
  objs = objects(I, T, F, T) 
  # Filter objects to only those with color '2'
  twos = colorfilter(objs, 2) 
  # Find the bounding box of all '2' objects combined
  patch = toindices(merge(twos)) 
  # Calculate starting position of the rectangle
  start_i = lowermost(patch) + 1
  start_j = leftmost(patch) + 1
  # Calculate height of the rectangle
  rect_height = height(patch) 
  # Draw the rectangle with '3'
  O = fill(I, 3, frozenset(
      (i,j) for i in range(start_i, start_i + rect_height) 
      for j in range(start_j, start_j + 2)))
  return O
 
0.08777777777777779, 5.7209573, def egebefabgbhfeegbifaiaefebabaaebd(I):
  # Find all indices of '2'
  indices = ofcolor(I, 2)
  # Calculate bounding box parameters
  start_row = lowermost(indices) + 1
  start_col = leftmost(indices) + 1
  rect_height = height(indices)
  # Create the rectangle object
  rect = frozenset({(3, (i,j)) for i in range(start_row, start_row + rect_height)
                  for j in range(start_col, start_col + 2)})
  # Paint the rectangle on a blank canvas the size of the input
  O = paint(canvas(0, shape(I)), rect)
  return O
 
0.08555555555555555, 8.913135, def eeccjfgddjieebfdbbebaicdffefhcdh(I):
  # Rotate the grid by 90 degrees
  rotated = rot90(I) 
  # Find all '2' objects in the rotated grid
  objs = objects(rotated, T, F, T)
  twos = colorfilter(objs, 2)
  patch = toindices(merge(twos))
  # Calculate bounding box parameters in the rotated space
  start_i = lowermost(patch) + 1
  start_j = leftmost(patch) + 1
  rect_height = height(patch)
  # Create the rectangle object in the rotated space
  rect = frozenset({(3, (i, j)) for i in range(start_i, start_i + rect_height) 
                  for j in range(start_j, start_j + 2)})
  # Rotate the canvas back to the original orientation and paint
  O = rot270(paint(canvas(0, shape(rotated)), rect)) 
  return O
 
0.08555555555555555, 12.486276, def bbiifdbbddfdebhdadfabdacadghhcad(I):
  # Transpose the grid
  transposed = dmirror(I)
  # Find all indices of '2' in the transposed grid
  indices = ofcolor(transposed, 2)
  # Calculate bounding box parameters in the transposed space
  start_row = lowermost(indices) + 1
  start_col = leftmost(indices) + 1
  rect_height = height(indices)
  # Create the rectangle object in the transposed space
  rect = frozenset({(3, (i, j)) for i in range(start_col, start_col + 2) 
                  for j in range(start_row, start_row + rect_height)})
  # Transpose back to the original orientation and paint
  O = dmirror(paint(canvas(0, shape(transposed)), rect))
  return O
 
0.12185185185185184, 13.663531, def abhdfghfhejeefbhaijcacbfcbbgahcc(I):
  # 1. Find the object and its bounding box
  obj = first(colorfilter(objects(I, T, F, F), 2))
  ul_i, ul_j = ulcorner(obj)
  # 2. Calculate new object's dimensions
  new_width = width(obj) // 2 if width(obj) > 1 else 1
  new_height = 2 if new_width > 1 else 1
  # 3. Create new object as indices within the bounding box
  new_obj_indices = frozenset((ul_i + new_height - i - 1, ul_j + j) for i in range(new_height) for j in range(new_width))
  # 4.  Paint the new object on the grid
  O = fill(cover(I, obj), 3, new_obj_indices)
  return O 
 
0.09370370370370369, 11.789672, def gddhbfgcbbccecbfajhechefdgbibhfe(I):
  objs = objects(I, True, False, True)
  O = canvas(mostcolor(I), shape(I))
  for i, obj in enumerate(objs):
    h = height(obj)
    O = paint(O, recolor(3, {(j, i) for j in range(h)}))
  return O
 
0.09851851851851852, 15.754943, def cjdfdaeceaeieegfifjabgdafeigbfce(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  i = 0
  for obj in objs:
    if color(obj) != mostcolor(I):
      h = height(obj)
      line = {(j, i) for j in range(h)}
      O = paint(O, recolor(3, line))
      i += 1
  return O
 
0.07814814814814815, 11.580083, def fajgafhaejajeihabbaaccaaacecahfb(I):
  objs = objects(I, True, False, True)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    start = (0, len(objs) - len({o for o in objs if leftmost(o) < leftmost(obj)}))
    O = paint(O, recolor(3, connect(start, (height(obj) - 1, start[1]))))
  return O
 
0.09370370370370369, 12.524548, def egaabfcafceaegjjadbiiibhiaaaedad(I):
  objs = sorted(objects(I, True, False, True), key=lambda obj: leftmost(obj))
  O = canvas(mostcolor(I), shape(I))
  for j, obj in enumerate(objs):
    O = underfill(O, 3, {(i, j) for i in range(height(obj))})
  return O
 
0.10925925925925926, 4.596416, def hdabjgeejdeeehchbcgeeefhdgicbegd(I):
  obj = objects(I, univalued=False, diagonal=False, without_bg=True)
  obj = first(obj)
  O = paint(canvas(0, shape(I)), recolor(3, toindices(obj)))
  return O
 
0.1796296296296296, 24.71688, def ghgdgadegefaegcebhddabfcebdfdcfa(I):
  obj = next(obj for obj in partition(I) if color(obj) != 0)
  O = paint(canvas(0, shape(I)), recolor(3, obj))
  return O
 
0.09851851851851852, 8.829109, def ibdbabbcdfcbebcejfaehebceddfaifa(I):
    O = canvas(ZERO, shape(I))
    for obj in fgpartition(I):
        if color(obj) == TWO:
            h = height(obj)
            j = leftmost(obj)
            for i in range(h):
                O = paint(O, {(THREE, (uppermost(obj) + i, j))})
    return O
 
0.14407407407407408, 25.770824, def gcdhaaeacbccefagbedgdbgaeehbdbac(I):
  O = canvas(ZERO, shape(I))
  for j in range(width(I)):
    twos = {i for i, r in enumerate(I) for v in r if v == TWO and r[j] == TWO}
    if twos:
      start_i = min(twos)
      for i in range(len(twos)):
        O = paint(O, {(THREE, (start_i + i, j))})
  return O
 
0.13962962962962963, 18.657553, def fdahjagccfjeeiddadhbfeidcdbeddjc(I):
  O = canvas(ZERO, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == TWO:
        bottom_i = next((k for k in range(i, len(I)) if I[k][j] != TWO), i) - 1
        if i == bottom_i:
          O = paint(O, {(THREE, (i, j))})
        else:
          O = paint(O, recolor(THREE, {(k, j) for k in range(i, bottom_i + 1)}))
  return O
 
0.5651851851851851, 26.591028, def bcfdccaadheeebcfbdgbbigedajjccbb(I):
  # Find all indices of '2' in the grid
  indices = ofcolor(I, 2)
  # If no '2' is found, return an empty grid
  if not indices:
    return canvas(0, shape(I))
  # Calculate the leftmost and rightmost column containing '2'
  start_j = leftmost(indices) + 1
  end_j = rightmost(indices) + 1
  # Draw a 2-column wide vertical line of '3's
  O = fill(I, 3, frozenset(
      (i, j) for i in range(len(I)) 
      for j in range(start_j, end_j + 1)))
  return O
 
0.29, 40.86202, def bejgccjfefcdeghjjbaeiedidbfghdba(I):
  # Find objects of digit '2', non-diagonal, without background
  objs = objects(I, T, F, T)
  # Filter objects to only those with color '2'
  twos = colorfilter(objs, 2)
  # Find the bounding box of all '2' objects combined
  patch = toindices(merge(twos))
  # If no '2' is found, return the original grid
  if not patch:
    return I
  # Calculate starting position of the line
  start_i = uppermost(patch) 
  start_j = rightmost(patch) + 1
  # Calculate height of the line
  line_height = height(patch) 
  # Draw the line with '3'
  O = fill(I, 3, frozenset(
      (i, start_j) for i in range(start_i, start_i + line_height)))
  # Draw the second line with '3'
  O = fill(O, 3, frozenset(
      (i, start_j + 1) for i in range(start_i, start_i + line_height)))
  return O
 
0.26777777777777784, 45.284416, def fbbaffadfcdiebebjadbibefdbcbcfhc(I):
    # Find the first row containing '2' from the bottom
    for i in range(len(I) - 1, -1, -1):
        if 2 in I[i]:
            start_row = i
            break
    else:
        # If no '2' is found, return the original grid
        return I
    # Find the first occurrence of '2' in that row
    first_two = I[start_row].index(2)
    # Calculate the starting position for the line of '3's
    start_j = first_two + 1
    # Draw two vertical lines of '3's next to the '2's
    O = fill(I, 3, frozenset((i, start_j) for i in range(len(I))))
    O = fill(O, 3, frozenset((i, start_j + 1) for i in range(len(I))))
    return O
 
0.47444444444444445, 21.864046, def gbjicafbgefbecbbajebfcgbehegfadj(I):
  # Create a blank canvas of the same size as the input
  O = canvas(0, shape(I))
  # Iterate through each row and column of the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If a '2' is found
      if I[i][j] == 2:
        # Paint a vertical line of '3's, two columns wide, to the right
        O = fill(O, 3, frozenset(((k, j + 1), (k, j + 2)) for k in range(len(I))))
  return O
 
0.1285185185185185, 14.808909, def eejfeaaeddbeedfaafedcbibbaajbdbf(I):
  # 1. Identify the object formed by '2's.
  obj = first(colorfilter(objects(I, T, F, F), 2))

  # 2. Calculate dimensions and position for the new object.
  new_width = width(obj) // 2 if width(obj) > 2 else 1
  new_height = 1 + (width(obj) > 2) 
  new_i = lowermost(obj) - new_height + 1
  new_j = leftmost(obj)

  # 3.  Generate the new object using nested comprehensions.
  new_obj = frozenset({(3, (i, j)) for i in range(new_height) for j in range(new_width)})

  # 4.  Overlay the new object onto a copy of the input, replacing the old object.
  O = paint(cover(I, obj), shift(new_obj, (new_i, new_j)))
  return O
 
0.12518518518518518, 14.585573, def cfeaahigaageeefdadaadjbfdjgccbbf(I):
  # 1. Find the object of '2's and its bounding box.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  ul_i, ul_j = ulcorner(obj)
  lr_i, lr_j = lrcorner(obj)

  # 2. Calculate the dimensions of the new object.
  new_height = (lr_i - ul_i + 1) // 2 if (lr_j - ul_j + 1) > 2 else 1
  new_width = (lr_j - ul_j + 1) // 2 if (lr_j - ul_j + 1) > 2 else 1

  # 3. Create a blank grid of the new object's size and fill it with '3's.
  new_obj = recolor(3, frozenset({(i, j) for i in range(new_height) for j in range(new_width)}))

  # 4. Place the new object on the grid.
  O = paint(cover(I, obj), shift(new_obj, (lr_i - new_height + 1, ul_j)))
  return O
 
0.13222222222222224, 13.980628, def dafadcjjbafcefhbifgaeabbbbefjcfc(I):
  obj = first(objects(I, True, False, True)) # Extract the uppermost object
  h = lowermost(obj) + 1 # Find the row index for the line
  O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  O = paint(O, recolor(3, hfrontier((h, 0)))) # Draw the horizontal line
  return O
 
0.26851851851851855, 46.735302, def hdfdedaaeichehfjbeedcbdgeaadbhci(I):
  line_row = uppermost(extract(objects(I, True, False, True), lambda x: True)) + height(extract(objects(I, True, False, True), lambda x: True)) # Find line row
  return tuple(tuple(3 if i == line_row else v for j, v in enumerate(r)) for i, r in enumerate(I)) # Modify rows directly
 
0.16814814814814816, 27.200327, def jfbfjbcebefheigbiaejdehbjbfeajcf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    center_loc = centerofmass(obj)
    O = fill(O, 3, {center_loc})
  return O
 
0.20851851851851852, 31.787067, def adgacaicbajfegbdacgcfifegbdcggch(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    offset = (2, 0) if height(obj) > width(obj) else (1, 0)
    start = add(llcorner(obj), offset)
    line = {(THREE, (start[0], start[1] + i)) for i in range(3)}
    O = paint(O, line)
  return O
 
0.07222222222222223, 13.027792, def fbcgbeefcfdgegehadaecgibfdbbffda(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, True, False, True):
    start_row = lowermost(obj) + (2 if portrait(obj) else 1)
    for i in range(3):
      O = fill(O, THREE, {(start_row, leftmost(obj) + i)})
  return O
 
0.3151851851851852, 38.97518, def ejjaajbajagdejjbacffafbfcfjceaec(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  if not twos:
    return I
  patch = toindices(merge(twos))
  start_i = uppermost(patch)
  start_j = rightmost(patch) + 1
  line_height = height(patch)
  line = frozenset((i, start_j + j) for i in range(start_i, start_i + line_height) for j in range(width(patch)))
  O = fill(I, 3, line)
  return O 
 
0.30407407407407405, 40.08589, def efficedeaaaceiegiabeeaaaaicejgch(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  if not twos:
    return I
  max_width = valmax(twos, compose(width, toindices))
  start_j = rightmost(toindices(merge(twos))) + 1
  line = frozenset((i, start_j + j) for obj in twos for i, j in toindices(obj) for j in range(max_width))
  O = fill(I, 3, line)
  return O
 
0.26185185185185184, 35.729225, def effbdhdiabbfebafaijeeedbahehbiae(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  if not twos:
    return I
  top_two = argmin(twos, compose(uppermost, toindices))
  line_height = height(top_two)
  start_i = uppermost(top_two)
  start_j = rightmost(toindices(merge(twos))) + 1
  line = frozenset((i, start_j + j) for i in range(start_i, start_i + line_height) for j in range(width(top_two)))
  O = fill(I, 3, line)
  return O 
 
0.3011111111111111, 39.61521, def dgegbfbccfbbejbhajggdfdabcafaehb(I):
  objs = objects(I, T, F, T)
  twos = colorfilter(objs, 2)
  if not twos:
    return I
  rightmost_col = rightmost(toindices(merge(twos)))
  line = frozenset((i, rightmost_col + j + 1) for obj in twos for i, _ in toindices(obj) for j in range(width(obj)))
  O = fill(I, 3, line)
  return O
 
0.12037037037037036, 12.485574, def bdbahjfeafdfeabajjbjehddcdbdafie(I):
  # 1. Find the '2'-object and calculate its lower-right corner.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  lr_corner = lrcorner(obj)

  # 2. Define new object's dimensions based on the '2'-object's width.
  new_width = lr_corner[1] // 2 - leftmost(obj) + 1
  new_height = 1 + (lr_corner[1] - leftmost(obj) > 1) 

  # 3. Create the new object directly with desired dimensions and color.
  new_obj = frozenset((3, (i, j)) for i in range(new_height) for j in range(new_width))

  # 4. Calculate the new object's position and paint it.
  new_i = lr_corner[0] - new_height + 1 
  new_j = leftmost(obj)
  O = paint(cover(I, obj), shift(new_obj, (new_i, new_j))) 

  return O
 
0.06629629629629631, 14.201829, def fffbaaiejdabejbebdhdbacbejjfbbif(I):
  obj = extract(objects(I, True, False, True), lambda x: True) # Extract the topmost object
  line_start = (lowermost(obj) + (1 if width(obj) == len(obj) else 2), leftmost(obj) + (1 if width(obj) != len(obj) else 0)) # Calculate line starting position
  line = {(line_start[0], j) for j in range(line_start[1], line_start[1] + width(obj))} # Create the line indices
  return paint(canvas(0, shape(I)), recolor(3, line)) # Paint the line on an empty canvas
 
0.06962962962962964, 15.907699, def becdgfdeahgfecaajicghbdafcfajfhg(I):
  obj = extract(fgpartition(I), lambda x: True)  # Extract the topmost object
  offset = (2, 0) if height(obj) > width(obj) else (1, 1) # Determine offset based on object shape
  line_start = add((lowermost(obj), leftmost(obj)), offset) # Calculate line starting position 
  line_indices = {(line_start[0], j) for j in range(line_start[1], line_start[1] + width(obj))} # Create the line indices
  return paint(canvas(0, shape(I)), recolor(3, line_indices)) # Paint the line
 
0.2351851851851852, 36.824768, def ahfbfahdciebebeaieedeegdfhdcdcca(I):
  objs = fgpartition(I) # Partition the input grid into objects, excluding background
  target_obj = min(objs, key=lambda o: uppermost(o)) # Find the topmost object
  line_row = lowermost(target_obj) + (1 if vline(target_obj) else 2) # Determine the row for the line
  return tuple(tuple(3 if i == line_row else c for c in row) for i, row in enumerate(I))  # Modify the grid to draw the line
 
0.2459259259259259, 50.71128, def ehfbadacbceaeeaaifgejcbacfijddha(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    if portrait(obj):
      center_j = leftmost(obj) + width(obj) // 2
      O = fill(O, 3, {(i, center_j) for i in range(height(I))})
    else:
      center_i = uppermost(obj) + height(obj) // 2
      O = fill(O, 3, {(center_i, j) for j in range(width(I))})
  return O
 
0.7018518518518518, 21.622347, def jcideeefcegdeegijacbhabbdcaeefdh(I):
  O = I
  for i in range(height(I)):
    row_obj = toobject({(i, j) for j in range(width(I))}, I)
    if len(palette(row_obj)) > 1:
      O = fill(O, 3, {(i, j) for j in range(width(I))})
  for j in range(width(I)):
    col_obj = toobject({(i, j) for i in range(height(I))}, I)
    if len(palette(col_obj)) > 1: 
      O = fill(O, 3, {(i, j) for i in range(height(I))})
  return O
 
0.2459259259259259, 51.130455, def bbaecgbcejafecfbaiegicefacijcheb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    upper = uppermost(obj)
    lower = lowermost(obj)
    left = leftmost(obj)
    right = rightmost(obj)
    if lower - upper > right - left:
      O = fill(O, 3, {(i, (left + right) // 2) for i in range(height(I))})
    else:
      O = fill(O, 3, {((upper + lower) // 2, j) for j in range(width(I))})
  return O
 
0.044814814814814814, 5.5893965, def achecfcifabceaddabchajfacfdaafic(I):
  O = canvas(0, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    center_line = connect((uppermost(obj), leftmost(obj) + width(obj) // 2),
                          (lowermost(obj), leftmost(obj) + width(obj) // 2)) if portrait(obj) else \
                    connect((uppermost(obj) + height(obj) // 2, leftmost(obj)),
                          (uppermost(obj) + height(obj) // 2, rightmost(obj)))
    O = paint(O, recolor(3, center_line)) 
  return O
 
0.21, 33.05873, def icgdddfjgajgeaibjaefgeihebaaefhc(I):
  def process_object(obj):
    offset = 2 if height(obj) > width(obj) else 1
    start_row = lowermost(obj) + offset
    return frozenset({(THREE, (start_row, leftmost(obj) + i)) for i in range(width(obj))})
  lines = mapply(process_object, objects(I, True, False, True))
  return paint(I, lines) 
 
0.21259259259259258, 35.68896, def cdgfjhfagbibeddcbdhadcedcbfjdicc(I):
  objs = objects(I, T, F, T)  # Find all objects in the grid
  twos = colorfilter(objs, 2)  # Filter for objects with color '2'
  if not twos:
    return I  # Return original grid if no '2' objects exist
  rightmost_two = argmax(twos, lambda obj: rightmost(toindices(obj)))  # Find the rightmost '2' object
  start_i, start_j = uppermost(rightmost_two), rightmost(rightmost_two) + 1  # Define starting point of the line
  line_height = height(rightmost_two)  # Define height of the line
  line = frozenset((i, start_j) for i in range(start_i, start_i + line_height))  # Generate indices for the line
  O = fill(I, 3, line)  # Fill the line with '3's on the grid
  return O
 
0.14703703703703705, 24.297829, def bbbgffacghbfejddacbcfceffjaeedhg(I):
  # 1. Find '2' object indices.
  indices = toindices(first(colorfilter(objects(I, T, F, F), 2)))

  # 2. Calculate new indices.
  new_indices = frozenset((i // 2, j // 2) for i, j in indices)

  # 3. Create new object.
  new_obj = recolor(3, new_indices)

  # 4. Paint the new object.
  O = paint(cover(I, indices), new_obj)
  return O
 
0.14185185185185187, 19.684443, def bcfceehdcdbiedaebhcbbccgiacbfibd(I):
  # 1. Find '2' object and its bounding box.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  bbox = backdrop(obj)

  # 2. Downscale bounding box.
  new_bbox = downscale(crop(I, ulcorner(bbox), shape(bbox)), 2)

  # 3. Recolor and paint.
  O = paint(cover(I, obj), recolor(3, asindices(new_bbox)))
  return O
 
0.12518518518518518, 16.550713, def djdfghciaiefeigfaeejabjeebchaaea(I):
  # 1. Find '2' object and its bounding box.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  bbox_indices = backdrop(obj)

  # 2. Filter bounding box indices.
  new_indices = frozenset((i, j) for i, j in bbox_indices if even(i) and even(j))

  # 3. Recolor and paint.
  O = paint(cover(I, obj), recolor(3, new_indices))
  return O
 
0.12185185185185184, 14.158326, def ccdeagadghageefejgaifcgcigacaefc(I):
  # 1. Find '2' object and split it horizontally.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  left_half = first(hsplit(subgrid(obj, I), 2))

  # 2. Upscale the left half and recolor.
  new_obj = recolor(3, upscale(left_half, 2))

  # 3. Position and paint new object.
  new_i = uppermost(obj)
  new_j = leftmost(obj)
  O = paint(cover(I, obj), shift(new_obj, (new_i, new_j)))
  return O
 
0.07888888888888888, 11.960658, def ijgfbfecehdeedbfbajbffbajdjhfihg(I):
  obj = extract(objects(I, True, False, True), lambda o: uppermost(o) == min(i for obj in objects(I, True, False, True) for i, j in toindices(obj)))
  start = (lowermost(obj) + 1, leftmost(obj) + (1 if width(obj) != len(obj) else 0))
  end = (start[0], start[1] + width(obj))
  line = connect(start, end)
  return paint(canvas(0, shape(I)), recolor(3, line))
 
0.07888888888888888, 11.298853, def bfdbbccccggeeahajedeicgbccgjibbd(I):
  objs = sorted(objects(I, True, False, True), key=lambda o: uppermost(o))
  obj = objs[0]
  line_start = (lowermost(obj) + 1, leftmost(obj) + (1 if width(obj) > height(obj) else 0))
  line_end = (line_start[0], line_start[1] + width(obj))
  line_indices = connect(line_start, line_end)
  return paint(canvas(0, shape(I)), recolor(3, line_indices))
 
0.07074074074074076, 11.882878, def bfahicdgbfjhedecjbdhghdadggfdfih(I):
  top_obj = min(objects(I, True, False, True), key=lambda o: uppermost(o))
  h, w = shape(top_obj)
  offset = (h + 1, 1 if w > h else 0)
  line_start = add(ulcorner(top_obj), offset)
  line_end = (line_start[0], line_start[1] + w - 1)
  line = connect(line_start, line_end)
  return paint(canvas(0, shape(I)), recolor(3, line))
 
0.07074074074074076, 13.68306, def hbcfceaeabiceddebcdheihcegfajadh(I):
  top_obj = min(objects(I, True, False, True), key=uppermost)
  bottom_left = (lowermost(top_obj) + 1, leftmost(top_obj) + (width(top_obj) > height(top_obj)))
  line_indices = {(bottom_left[0], j) for j in range(bottom_left[1], bottom_left[1] + width(top_obj))}
  return paint(canvas(0, shape(I)), recolor(3, line_indices)) 
 
0.03333333333333333, 8.925771, def ihhebebfbfdeeacbbiedfhfbhiadigaf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    if width(obj) > height(obj):
      O = fill(O, 3, {(center_i, j) for j in range(center_j - 1, center_j + 2)})
    else:
      O = fill(O, 3, {(i, center_j) for i in range(center_i - 1, center_i + 2)})
  return O
 
0.1388888888888889, 20.644506, def dhcejaeagcbeeegdicgbechaidbaddca(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
    canvas(0, shape(I)), 
    merge(
      apply(
        lambda obj: recolor(3, 
                           hfrontier(centerofmass(obj)) if width(obj) > height(obj) 
                           else vfrontier(centerofmass(obj))), 
        objs
      )
    )
  )
 
0.03333333333333333, 20.931984, def ihehfadgccbaegcfadbeacafccjfdcdc(I):
  return paint(
    canvas(0, shape(I)),
    merge(
      apply(
        lambda obj: recolor(
          3, 
          connect(
            (centerofmass(obj)[0], centerofmass(obj)[1] - (width(obj) > height(obj))),
            (centerofmass(obj)[0], centerofmass(obj)[1] + (width(obj) > height(obj)))
          )
        ),
        objects(I, univalued=True, diagonal=False, without_bg=True)
      )
    )
  )
 
0.21, 34.277386, def bhecbfdgbgebegidbcihaeabfabaecej(I):
  def underline(obj):
    return recolor(THREE, shift(
        {(i, leftmost(obj) + j) for j in range(width(obj)) for i in range(lowermost(obj) + 1, lowermost(obj) + 2)},
        (0, 0)))
  return paint(I, merge(apply(underline, objects(I, True, False, True))))
 
0.21666666666666667, 34.695763, def ajjegaciddcceaedjfdaddehcbcbcgda(I):
  for obj in objects(I, T, F, T):
    if color(obj) == 2:
      start_i = uppermost(obj)
      start_j = rightmost(obj) + 1
      line_width = width(obj)
      line = frozenset((start_i, j) for j in range(start_j, start_j + line_width))
      I = fill(I, 3, line)
  return I
 
0.20703703703703705, 34.319958, def dfbfjfeahbfdebhfagbbfcegecfddiff(I):
  return paint(I, merge({recolor(3, {(uppermost(obj), rightmost(obj) + j)}) for obj in objects(I, T, F, T) if color(obj) == 2 for j in range(width(obj))}))
 
0.2037037037037037, 32.866276, def abfdhihefaaeebcaahfeefbebebeagib(I):
  def draw_line(obj, I):
    if color(obj) != 2:
      return I
    start = (uppermost(obj), rightmost(obj) + 1)
    end = (start[0], start[1] + width(obj) - 1)
    return fill(I, 3, connect(start, end))
  return last(apply(rbind(draw_line, I), objects(I, T, F, T)))
 
0.1285185185185185, 15.2682495, def baidechdhfjeeicfaabhbegbgfcdbdea(I):
  # 1. Find the '2' object.
  obj = first(colorfilter(objects(I, T, F, F), 2))

  # 2. Calculate new dimensions.
  new_width = width(obj) // 2
  new_height = height(obj) // 2 + height(obj) % 2

  # 3. Create the new object using nested comprehensions.
  new_obj = frozenset({(3, (i, j)) for i in range(new_height) for j in range(new_width)})

  # 4. Calculate the new object's position.
  new_i = uppermost(obj)
  new_j = leftmost(obj)

  # 5. Paint the new object onto the input, replacing the original object.
  O = paint(cover(I, obj), shift(new_obj, (new_i, new_j)))
  return O
 
0.14148148148148146, 21.246672, def abcbeajccjceeaggbdaihacjbcdhbdec(I):
  # 1. Identify the '2' object.
  obj = first(colorfilter(objects(I, T, F, F), 2))

  # 2. Split the object horizontally and vertically.
  h_split = hsplit(subgrid(obj, I), 2)[0] 
  v_split = vsplit(h_split, 2)[0] 

  # 3.  Reconstruct the object with reduced size and color '3'.
  new_obj = recolor(3, asobject(vconcat(hconcat(v_split, v_split), v_split)))

  # 4. Paint the new object onto the input, replacing the original object.
  O = paint(cover(I, obj), shift(new_obj, ulcorner(obj)))
  return O
 
0.14666666666666667, 19.89679, def feahcagccajdeacbbaafeifafdiehbib(I):
  # 1. Identify the '2' object.
  obj = first(colorfilter(objects(I, T, F, F), 2))
  new_obj = frozenset()

  # 2.  Iterate through the object, adding every other cell to the new object.
  for i, j in toindices(obj):
    if (i + j) % 2 == 0:
        new_obj = insert((3, (i, j)), new_obj)

  # 3. Paint the new object onto the input, replacing the original object.
  O = paint(cover(I, obj), new_obj)
  return O
 
0.06629629629629631, 15.505656, def cddebfijejcbeiibjgefbdgfhfgheggh(I):
  obj = next(iter(objects(I, True, False, True))) # Take any object
  line_start = (uppermost(obj) + height(obj) + 1, leftmost(obj))
  line_end = (line_start[0], line_start[1] + width(obj) - 1)
  line = connect(line_start, line_end)
  return paint(canvas(0, shape(I)), recolor(3, line))
 
0.056296296296296296, 22.620834, def ihdcjfefedaaeadeichgdfaccbfehhbi(I):
  obj = sorted(objects(I, True, False, True), key=lambda o: -uppermost(o))[0] # Topmost object
  line_start = add(llcorner(obj), (1, 0))
  line = {(line_start[0], line_start[1] + i) for i in range(width(obj))}
  return paint(canvas(0, shape(I)), recolor(3, line))
 
0.06925925925925926, 16.136698, def gabhaibeegddedbcjeechbedbhafgcha(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, shape(I))
  for obj in objs:
    h = height(obj)
    w = width(obj)
    if h >= w:
      line = vfrontier(centerofmass(obj))
    else:
      line = hfrontier(centerofmass(obj))
    O = fill(O, 3, intersection(line, toindices(obj)))
  return O
 
0.044814814814814814, 6.2828918, def ecbajbgfffebeffhigccdciabeacjfge(I):
  O = canvas(0, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    indices = toindices(obj)
    h_line = {(i, centerofmass(indices)[1]) for i in range(uppermost(indices), lowermost(indices) + 1)}
    v_line = {(centerofmass(indices)[0], j) for j in range(leftmost(indices), rightmost(indices) + 1)}
    O = fill(O, 3, h_line if len(h_line & indices) >= len(v_line & indices) else v_line)
  return O
 
0.16, 36.849934, def ebjaeedaffihececibbdacabfcdjficd(I):
  O = I
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    h = height(obj)
    w = width(obj)
    c = centerofmass(obj)
    if h > w:
      O = fill(O, 3, {(i, c[1]) for i in range(c[0] - h//2, c[0] + (h+1)//2)})
    else:
      O = fill(O, 3, {(c[0], j) for j in range(c[1] - w//2, c[1] + (w+1)//2)})
  return O
 
0.06925925925925926, 16.187819, def ecegaciefhjeedddbbefefaceaabdgca(I):
  O = canvas(0, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    indices = toindices(obj)
    h = height(obj)
    w = width(obj)
    line = {(i, centerofmass(indices)[1]) for i in range(uppermost(indices), lowermost(indices) + 1)} if h > w else {(centerofmass(indices)[0], j) for j in range(leftmost(indices), rightmost(indices) + 1)}
    O = paint(O, recolor(3, intersection(line, indices)))
  return O
 
0.07370370370370372, 13.5501375, def fibdgaeegebfefecbicjccdbbedacdce(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, True, False, True):
      O = paint(O, recolor(THREE, {(lowermost(obj) + 1, j) for j in range(leftmost(obj), leftmost(obj) + width(obj))}))
    return O
 
0.3259259259259259, 45.535927, def abdegiffdibeeaadaehibhacccjaaecf(I):
  return paint(I, merge({recolor(3, {(i, j) for j in range(rightmost(obj) + 1, rightmost(obj) + width(obj) + 1)}) for obj in objects(I, T, F, T) if color(obj) == 2 for i in range(uppermost(obj), lowermost(obj) + 1)}))
 
0.1796296296296296, 24.396017, def gccebagdfagjedajabhegdbfafcaddff(I):
  def process_object(obj):
    width = rightmost(obj) - leftmost(obj) + 1
    return {(i, rightmost(obj) + j + 1) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(width)}
  return paint(I, recolor(3, merge(apply(process_object, colorfilter(objects(I, T, F, T), matcher(color, 2))))))
 
0.07407407407407407, 11.006878, def ehajdafabafeefhfbaaecdhbcbfcgcdg(I):
  # 1. Get the indices of all '2's.
  indices = ofcolor(I, 2)

  # 2. Create the new object's indices.
  new_indices = frozenset({(i, j) for i, j in indices if (j - min(j for _, j in indices)) < max(1, len(indices) // len({i for i, _ in indices}) // 2)})

  # 3. Replace '2's with '0's and paint the new object with '3's.
  O = paint(replace(I, 2, 0), recolor(3, new_indices))
  return O
 
0.13999999999999999, 17.94654, def bceebbcfiihceeggjaedjagfbhccjdfa(I):
  # 1. Identify the '2' object.
  obj = first(colorfilter(objects(I, T, F, F), 2))

  # 2. Calculate the middle column of the object.
  middle_col = leftmost(obj) + width(obj) // 2

  # 3. Remove the right half of the object.
  O = cover(I, frozenset((v, (i, j)) for v, (i, j) in obj if j >= middle_col))

  # 4. Recolor the remaining part to '3'.
  O = paint(O, recolor(3, toindices(first(colorfilter(objects(O, T, F, F), 2)))))
  return O
 
0.24333333333333332, 45.815697, def bbhdccjfcibbebdjaghchhdfbabdhggh(I):
  for i in range(len(I)):  # Iterate over rows
    if any(v != 0 for v in I[i]):  # Check for non-zero values in the row
      obj_top = i  # Store the row index of the topmost object
      break
  obj_width = len(I[obj_top]) - I[obj_top].count(0)  # Calculate object width
  line_row = obj_top + height(extract(objects(I, True, False, True), lambda x: True)) + 1  # Find line row
  return tuple(tuple(3 if i == line_row else v for v in r) for i, r in enumerate(I)) # Draw the line
 
0.14814814814814814, 12.171488, def fgdccjfaabcaeigbjbcbabehdehfjeci(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
    canvas(0, shape(I)),
    merge(
      apply(
        lambda obj: recolor(
          3, 
          frozenset(
            (i, j) 
            for i in range(uppermost(obj), lowermost(obj) + 1) 
            for j in range(
              max(0, centerofmass(obj)[1] - 1), 
              min(width(I), centerofmass(obj)[1] + 2)
            ) 
            if (i, j) in toindices(obj)
          )
        ), 
        objs
      )
    )
  )
 
0.04666666666666667, 8.338512, def cifabcddefdcegciibacghcfjeahieah(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
    canvas(0, shape(I)),
    merge(
      apply(
        lambda obj: recolor(
          3, 
          frozenset(
            (centerofmass(obj)[0], j) 
            for j in range(
              max(0, centerofmass(obj)[1] - 1),
              min(width(I), centerofmass(obj)[1] + 2)
            )
          )
        ),
        objs
      )
    )
  )
 
0.06296296296296297, 18.090097, def eidfgaagaajcecdbihjdgafeeegefdcd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
      canvas(0, shape(I)),
      merge(
          apply(
              lambda obj: toobject(
                  frozenset(
                      (centerofmass(obj)[0], j)
                      for j in range(
                          max(0, centerofmass(obj)[1] - 1),
                          min(width(I), centerofmass(obj)[1] + 2),
                      )
                  ),
                  I,
              ),
              objs,
          )
      )
  )
 
0.036666666666666674, 13.994705, def jjcbeffhgcajefbfbaeaajegadeacfdc(I):
  O = canvas(ZERO, shape(I))
  for obj in objects(I, True, False, True):
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    center_i = (uppermost(obj) + lowermost(obj)) // 2
    O = paint(O, recolor(THREE, {(center_i, center_j), (center_i, center_j + 1)}))
  return O 
 
0.043333333333333335, 13.663566, def abfejdfgjifeeaefacfciefdbiidffdc(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, True, False, True):
        c = centerofmass(obj)
        O = paint(O, recolor(THREE, {(c[0], c[1] - 1), (c[0], c[1])}))
    return O
 
0.1537037037037037, 39.049545, def hgdhecbaececeiadjfiejcegficegfib(I):
  def line_indices(obj):
    center_j = (leftmost(obj) + rightmost(obj)) // 2
    return frozenset((i, center_j - 1) for i in range(uppermost(obj), lowermost(obj) + 1)) | \
           frozenset((i, center_j) for i in range(uppermost(obj), lowermost(obj) + 1))
  return fill(I, 3, merge(apply(line_indices, sfilter(objects(I, T, F, T), lambda obj: color(obj) == 2))))
 
0.17814814814814814, 32.50935, def eacdjaicicicedbgjaifhagddadhdeef(I):
  def shifted_line(obj):
    return shift(recolor(3,  frozenset((i, 0) for i in range(height(obj)))), (uppermost(obj), (leftmost(obj) + rightmost(obj)) // 2 - 1))
  return paint(I, merge(apply(shifted_line, sfilter(objects(I, T, F, T), lambda o: color(o) == 2))))
 
0.13999999999999999, 18.057384, def caaddjdhihdbebaabebcdehddcfbfhae(I):
  # 1. Find the bounding box of the '2' object.
  obj_indices = toindices(first(colorfilter(objects(I, T, F, F), 2)))

  # 2. Determine new width based on original width.
  new_width = max(1, width(obj_indices) // 2) 

  # 3. Construct the new object directly from indices.
  new_obj = frozenset({(3, (i, j)) for i, j in obj_indices if j < leftmost(obj_indices) + new_width})

  # 4. Overlay the new object onto the input grid, replacing the old one.
  O = paint(cover(I, obj_indices), new_obj)
  return O
 
0.07444444444444444, 14.956416, def adjehgeeaabdeaehbcjacadbaacfidda(I):
  obj = min(fgpartition(I), key=lambda o: uppermost(o))  # Find topmost object
  line_start = (lowermost(obj) + 1, leftmost(obj)) # Line starting point
  line_end = (line_start[0], line_start[1] + width(obj)) # Line ending point
  line = connect(line_start, line_end) # Generate indices for the line
  return paint(canvas(0, shape(I)), recolor(3, line)) # Draw the line
 
0.048518518518518516, 8.454658, def dcjheaeidaefeeecjbhhgdeeaeafcbba(I):
  top_obj = min((next((j for j, c in enumerate(row) if c != 0), float('inf')), i) for i, row in enumerate(I)) # Find topmost object's starting position (column, row)
  obj_width = width(extract(objects(I, True, False, True), lambda o: ulcorner(o) == (top_obj[1], top_obj[0]))) # Calculate object width
  return paint(canvas(0, shape(I)), recolor(3, {(top_obj[1] + 1, j) for j in range(top_obj[0], top_obj[0] + obj_width)})) # Draw the line
 
0.07296296296296297, 10.879281, def gfhiaebifbgeebafacjbebadbdbcbhbf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, size)
  recolored_obj = recolor(3, largest_obj)
  bottom_center = (height(I) - height(recolored_obj), width(I) // 2 - width(recolored_obj) // 2) 
  return paint(canvas(0, shape(I)), shift(recolored_obj, bottom_center))
 
0.08296296296296296, 9.726502, def efiaffehabhbeebebbbddeebffhgggeb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, lambda obj: len(obj))
  return paint(
    canvas(0, shape(I)),
    shift(
      recolor(3, largest_obj),
      (height(I) - height(largest_obj), (width(I) - width(largest_obj)) // 2)
    )
  )
 
0.10333333333333333, 10.051423, def bfccadchhiffehgjijffefefbcdgceda(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  largest_obj = argmax(objs, lambda obj: -len(obj))  # Find smallest object
  return paint(
      canvas(0, shape(I)),
      shift(
          recolor(3, largest_obj),
          (0, (width(I) - width(largest_obj)) // 2)  # Place at top center
      )
  )
 
0.1303703703703704, 15.781274, def beffebdehidcedfgbebiiebbfjgeeibj(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  largest_obj = max(objs, key=lambda obj: (len(obj), -uppermost(obj))) # Largest and lowest object
  recolored_obj = recolor(3, largest_obj)
  canvas_width = width(I)
  obj_width = width(recolored_obj)
  x_offset = (canvas_width - obj_width) // 2
  return paint(
      canvas(0, (height(I), canvas_width)),
      shift(recolored_obj, (0, x_offset)) # Place at top center
  )
 
0.2003703703703704, 28.888357, def abcecfedggecedfcigfifafbahdfgegh(I):
  def draw_line(obj):
    start_i = lowermost(obj) - 1
    start_j = rightmost(obj) + 3
    return frozenset({(3, (start_i, j)) for j in range(start_j, start_j + width(obj))})
  
  target_object = argmin(objects(I, T, F, T), lambda obj: (uppermost(obj), leftmost(obj))) if objects(I, T, F, T) else frozenset()
  return paint(I, draw_line(target_object))
 
0.19444444444444445, 27.868174, def bjabfbfcdjbfecjbbihecfjadjbiaebc(I):
  for obj in objects(I, T, F, T):
    if color(obj) == 2:
      I = fill(I, 3, {(i, rightmost(obj) + 3 + j) for j in range(width(obj)) for i in range(lowermost(obj) - 1, lowermost(obj))})
      break  # Stop after processing the first '2' object
  return I
 
0.11, 17.938095, def aigbhieihjccejacbjfhidegdfaciace(I):
  top_row = next(i for i, row in enumerate(I) for c in row if c != 0) # Find topmost row
  obj_width = len(extract(objects(I, True, False, True), lambda o: uppermost(o) == top_row)) # Calculate object width
  line_row = top_row + (1 if obj_width > 3 else 2) # Determine line row based on width
  return fill(canvas(0, shape(I)), 3, {(line_row, j) for j in range(width(I))}) # Draw line
 
0.056296296296296296, 21.819033, def dbdcbbgfhfcfeibhabhfdabhaajceefe(I):
  obj = extract(objects(I, True, False, True), lambda x: True) # Extract an object
  line_row = uppermost(obj) - (1 if height(obj) < 4 else 2) # Determine line row based on height
  line = recolor(3, {(line_row, j) for j in range(leftmost(obj), rightmost(obj) + 1)}) # Create line object
  return paint(canvas(0, shape(I)), line) # Paint the line on a blank canvas
 
0.08333333333333333, 9.199624, def hicadbceeceeeaaabdfabdjcchaefdfc(I):
  obj_top = next(i for i, r in enumerate(I) if any(c != 0 for c in r)) # Find topmost object's row
  obj_bottom = next(i for i, r in enumerate(reversed(I)) if any(c != 0 for c in r)) # Find bottommost object's row (from top)
  line_row = obj_bottom - 2 if obj_top == obj_bottom else obj_bottom - 3 # Calculate line row based on top/bottom row relation
  return paint(canvas(0, shape(I)), recolor(3, {(line_row, j) for j in range(width(I))})) # Draw the line
 
0.19185185185185186, 37.64808, def gagccbjbefbaefhijebceebeaiefccbb(I):
  O = I
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  top_obj = True
  for obj in objs:
    center_j = leftmost(obj) + width(obj) // 2
    if top_obj:
      O = fill(O, 3, {(i, center_j) for i in range(height(I) // 2)})
      top_obj = False
    else:
      O = fill(O, 3, {(i, center_j) for i in range(height(I) // 2, height(I))})
  return O
 
0.06666666666666667, 9.864828, def defjcfjfabebeiihjebejdfdjcfaaaaa(I):
  O = canvas(0, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    center_j = leftmost(obj) + width(obj) // 2
    if uppermost(obj) < height(I) // 2:
      O = fill(O, 3, {(i, center_j) for i in range(height(I) // 2)})
    else:
      O = fill(O, 3, {(i, center_j) for i in range(height(I) // 2, height(I))})
  return O
 
0.17703703703703702, 39.589912, def diedaddcajjdefffbadgcjbcdiebidei(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  top_obj = extract(objs, lambda obj: uppermost(obj) < height(I) // 2)
  bottom_objs = objs - {top_obj}
  O = I
  if top_obj:
    O = fill(O, 3, {(i, leftmost(top_obj) + width(top_obj) // 2) for i in range(height(I) // 2)})
  for obj in bottom_objs:
    O = fill(O, 3, {(i, leftmost(obj) + width(obj) // 2) for i in range(height(I) // 2, height(I))})
  return O
 
0.09592592592592593, 6.7891045, def fbfddajbdffcecbhahedhbfdcgeaieae(I):
  def process_obj(obj):
    i, j = ulcorner(obj)
    h = height(obj)
    return frozenset({(i + k, j) for k in range(h)} | {(i + k, j + 2) for k in range(h)})
  top_obj = argmax(objects(I, True, True, True), lambda obj: -uppermost(obj))
  return fill(canvas(ZERO, shape(I)), THREE, process_obj(top_obj))
 
0.09592592592592593, 7.7623706, def deiagebgbiafeifjiaehhhfadbbadehf(I):
  obj = next(obj for obj in objects(I, True, True, True) if color(obj) == 2)
  i, j = ulcorner(obj)
  return fill(canvas(ZERO, shape(I)), THREE, connect((i, j), (i + height(obj) - 1, j)) | connect((i, j + 2), (i + height(obj) - 1, j + 2)))
 
0.23, 40.591904, def bbcecgedffehedabaegabbfaggbefeeh(I):
  objs = objects(I, True, False, True)
  twos = colorfilter(objs, 2)
  O = I
  for obj in twos:
    min_j = leftmost(obj)
    max_j = rightmost(obj)
    min_i = uppermost(obj)
    max_i = lowermost(obj)
    line = frozenset(((i, max_j + 1) for i in range(min_i, max_i + 1)))
    O = fill(O, 3, line)
  return O
 
0.29074074074074074, 52.156036, def cdeaifaffgefeffgaeabfjdcchjbchjb(I):
  transposed = rot90(I)
  O = transposed
  for i, row in enumerate(transposed):
    if 2 in row:
      start_j = min([j for j, val in enumerate(row) if val == 2]) - 1
      if start_j >= 0:
        line = frozenset(((k, start_j) for k in range(len(transposed))))
        O = fill(O, 3, line)
  return rot270(O)
 
0.4792592592592593, 36.342495, def fdfihfcbajddedchaihdccbaideegdfb(I):
    O = I
    for j in range(len(I[0])):
        for i in range(len(I)):
            if I[i][j] == 2:
                if j + 1 < len(I[0]):
                    O = fill(O, 3, frozenset(((k, j + 1) for k in range(len(I)))))
                break
    return O
 
0.1877777777777778, 21.657818, def fbfdddcdadccebihbcdhajfbgfabijdb(I):
  h, w = len(I), len(I[0])
  O = canvas(0, (h, w))
  for i in range(h):
    row = I[i]
    try:
      max_j = max([j for j, val in enumerate(row) if val == 2])
      line = frozenset(((k, max_j + 1) for k in range(h)))
      O = fill(O, 3, line)
    except:
      pass
  return O
 
0.10851851851851853, 13.220535, def fafcecbegfabeigfiedfbbdhadacgeid(I):
  # 1. Identify '2' object and calculate its center.
  obj_2 = first(colorfilter(objects(I, T, F, F), 2))
  center_2 = centerofmass(obj_2)

  # 2. Define function to generate a row for the new object.
  generate_row = lambda w: tuple(3 for _ in range(w))

  # 3. Determine new object's dimensions and create it row-by-row.
  new_width = width(obj_2) // 2 
  new_height = 3 if new_width > 1 else 1
  obj_3 = tuple(generate_row(new_width) for _ in range(new_height)) 

  # 4. Calculate the new object's top-left corner position.
  new_i = center_2[0] - (new_height // 2) - (1 if new_height == 3 else 0)
  new_j = center_2[1] - (new_width // 2)

  # 5. Paint the new object on the grid.
  O = paint(cover(I, obj_2), shift(asobject(obj_3), (new_i, new_j)))
  return O
 
0.06925925925925926, 16.523338, def bicigjfababeeabfbcdjejdjhabgcjbf(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
      canvas(0, shape(I)),
      merge(
          apply(
              lambda obj: toobject(
                  frozenset(
                      (i, centerofmass(obj)[1]) for i in range(uppermost(obj), lowermost(obj) + 1)
                  ),
                  I,
              ),
              objs
          )
      )
  )
 
0.06925925925925926, 6.304611, def aciaibcfcbgheabiifcffjefaaicfaeb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  return paint(
      canvas(0, shape(I)),
      merge(
        apply(
          lambda obj: recolor(
              color(obj),
              frozenset(
                  (i, centerofmass(obj)[1]) for i in range(uppermost(obj), lowermost(obj) + 1)
              )
          ),
          objs
        )
      )
  )
 
0.06925925925925926, 16.348804, def fbfbecafgicbeaddiaffedidibabicff(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    return paint(
        canvas(0, shape(I)),
        merge(
            [
                toobject(
                    frozenset((y, center(indices)[1]) for y in range(uppermost(indices), lowermost(indices) + 1)),
                    I,
                )
                for indices in [toindices(obj) for obj in objs]
            ]
        ),
    )
 
0.06925925925925926, 6.163387, def abgaeefadfhcehcgieaagcdgefedccdc(I):
    return paint(
        canvas(0, shape(I)),
        merge(
            [
                recolor(
                    color(obj),
                    frozenset(
                        (y, leftmost(obj) + width(obj) // 2)
                        for y in range(uppermost(obj), lowermost(obj) + 1)
                    ),
                )
                for obj in objects(I, univalued=True, diagonal=False, without_bg=True)
            ]
        ),
    )
 
0.0651851851851852, 7.290633, def bafdhhfefgbfebcbjdjfbbfhdjaiafac(I):
  def top_left_two(grid):
    for i, row in enumerate(grid):
      for j, val in enumerate(row):
        if val == 2:
          return (i, j)
  i, j = top_left_two(I)
  obj = next((obj for obj in objects(I, True, True, True) if (i, j) in toindices(obj)), None)
  h = height(obj) if obj else 0 
  O = canvas(ZERO, shape(I))
  for k in range(h):
    O = paint(O, {(THREE, (i + k, j + 2))})
  return O
 
0.06962962962962964, 11.713189, def deababgfehhfeabbbiafcbdbcdbhigce(I):
  obj = next((obj for obj in objects(I, True, True, True) if 2 in palette(obj)), None)
  if not obj:
    return I
  i, j = ulcorner(obj)
  h = height(obj)
  O = canvas(ZERO, shape(I))
  for k in range(h):
    O = paint(O, {(THREE, (i + k, j + 2))})
  return O
 
0.05962962962962964, 19.669886, def hfjecacabecgedfebdfdiaaeaffagjfj(I):
  for i, row in enumerate(I):
    if 2 in row:
      start_j = max([j for j, val in enumerate(row) if val == 2]) + 1
      return fill(fill(I, 3, frozenset(((i+2, start_j), (i+3, start_j)))), 0, frozenset(ofcolor(I, 2)))
  return I
 
0.05962962962962964, 18.028658, def ccghgddhaaddecfjachbgbebbffbgdcd(I):
  two_indices = ofcolor(I, 2)
  if two_indices:
    top_row = min(two_indices, key=lambda x: x[0])[0]
    rightmost_col = max(two_indices, key=lambda x: x[1])[1]
    line_start = (top_row + 2, rightmost_col + 1)
    return fill(fill(I, 3, frozenset((line_start, (line_start[0] + 1, line_start[1])))), 0, two_indices)
  return I
 
0.19592592592592592, 32.208984, def dfececcbfdafefabjdbffjbfedihjgbj(I):
    twos = ofcolor(I, 2)
    if twos:
        top_row = min([i for i, j in twos])
        rightmost_col = max([j for i, j in twos if i == top_row])
        return fill(I, 3, frozenset(((top_row + 2, rightmost_col + 1), (top_row + 3, rightmost_col + 1)))) 
    else:
        return I
 
0.19592592592592592, 30.43065, def bfdeaeecgcedefdabdgaedhjihbdafai(I):
  obj = extract(objects(I, False, False, True), lambda obj: color(obj) == 2)
  if obj:
    start_j = rightmost(obj) + 1
    start_i = uppermost(obj) + 2
    line = frozenset(((start_i, start_j), (start_i + 1, start_j)))
    return fill(I, 3, line)
  return I
 
0.1751851851851852, 27.61942, def abchcjcbfcifegdfiebajfchjaafciee(I):
  # 1. Identify and extract the '2' object.
  obj_2 = first(colorfilter(objects(I, T, F, F), 2))
  extracted_obj = subgrid(obj_2, I)

  # 2. Downscale the extracted object horizontally.
  downscaled_obj = downscale(extracted_obj, 2)

  # 3. Determine the height of the new object.
  new_height = 3 if width(downscaled_obj) > 1 else 1

  # 4. Create the final object by upscaling vertically and recoloring.
  final_obj = recolor(3, asobject(vupscale(downscaled_obj, new_height)))

  # 5. Replace the original object with the final object.
  O = paint(cover(I, obj_2), shift(final_obj, ulcorner(obj_2)))
  return O
 
0.12185185185185184, 13.376745, def aehhfffeefefebjaaehicebaaaahddfa(I):
  # 1. Find the '2' object and its bounding box.
  obj_2 = first(colorfilter(objects(I, T, F, F), 2))
  bbox = backdrop(obj_2)

  # 2. Calculate new dimensions based on the bounding box.
  new_width = (rightmost(bbox) - leftmost(bbox) + 1) // 2
  new_height = 3 if new_width > 1 else 1

  # 3. Create a blank canvas for the new object.
  new_obj = canvas(0, (new_height, new_width))

  # 4.  Recolor the canvas with '3' and position it.
  obj_3 = shift(recolor(3, asindices(new_obj)), (lowermost(bbox) - new_height + 1, leftmost(bbox)))

  # 5. Paint the new object onto the input, removing the original object.
  O = paint(cover(I, obj_2), obj_3)
  return O
 
0.043333333333333335, 29.34562, def geejaejhdebgecbjiejciceabfddihdb(I):
  O = canvas(0, shape(I))
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    line = hfrontier((0, centerofmass(obj)[1]))  # Create a full horizontal line
    O = fill(O, 3, intersection(line, toindices(obj)))  # Fill only the intersecting cells
  return O
 
0.1796296296296296, 29.329937, def ebcfcedifdjfeccijdchfjdagjafebef(I):
  O = I  # Start with the input grid
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    j = centerofmass(obj)[1]  # Get the column index of the center of mass
    O = fill(O, 3, {(i, j) for i in range(uppermost(obj), lowermost(obj) + 1) if (i, j) in toindices(obj)})  # Directly fill the object with '3's along the center column
  return O
 
0.1796296296296296, 27.52911, def ddjfefbhcefceffeabajaecfdbegcbeg(I):
  O = I  # Initialize output as input
  for obj in objects(I, univalued=True, diagonal=False, without_bg=True):
    y = centerofmass(obj)[1]  # Find y-coordinate of center of mass
    for x in range(leftmost(obj), rightmost(obj) + 1):
      if (x, y) in toindices(obj):
        O = fill(O, 3, {(x, y)})  # Fill cells along horizontal line within the object
  return O
 
0.08259259259259259, 8.293978, def ggcadfbieebjefccjebcdbiaecceddhd(I):
  obj_indices = toindices(first(colorfilter(objects(I, True, False, True), TWO))) # Get indices of the object
  new_indices = frozenset((i, j) for i, j in obj_indices if i < uppermost(obj_indices) + TWO) # Keep indices of only the top two rows
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, new_indices)) # Paint the new object on a blank canvas
  return O
 
0.07592592592592591, 6.0246797, def ejbacdibcgadeifejidddddacidebced(I):
  obj = first(colorfilter(objects(I, True, False, True), TWO))
  top_row_indices = frozenset((i, j) for i, j in toindices(obj) if i == uppermost(obj)) # Get indices of the top row
  bottom_row_indices = shift(top_row_indices, DOWN) # Get indices of the second row by shifting the top row indices down
  new_indices = top_row_indices | bottom_row_indices # Combine the indices of the top two rows
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, new_indices)) # Paint on a blank canvas
  return O
 
0.05962962962962964, 9.1916485, def facbhigjffffeigeibgjhefhfceedacd(I):
  # Find indices of all '2' cells.
  indices = ofcolor(I, 2)
  
  # Determine bounding box corners.
  top, left = ulcorner(indices)
  
  # Generate output grid.
  O = canvas(0, shape(I))
  O = fill(O, 3, frozenset({(top, left), (top, left + 1), (top + 1, left), (top + 1, left + 1)}))
  return O
 
0.06259259259259259, 9.231699, def dcafjeieeefaebfejefcajbdjecdbdge(I):
  # Extract '2' object and find its bounding box.
  obj = first(colorfilter(objects(I, T, T, T), 2))
  top, left = ulcorner(obj)

  # Generate output grid with filled square.
  O = paint(canvas(0, shape(I)), recolor(3, shift(frozenset({(0,0), (0,1), (1,0), (1,1)}), (top, left))))
  return O
 
0.07592592592592591, 6.0246797, def adecabfcfccaedgjjeigdfdcaccbdjcj(I):
    # 1. Find the non-background color
    obj_color = leastcolor(I) 
    
    # 2. Identify the object
    obj = first(objects(I, True, False, True)) 
    
    # 3. Calculate dimensions and upper-left corner
    height_obj = height(obj)
    width_obj = width(obj)
    corner = ulcorner(obj) 

    # 4. Create a patch for the top two rows of the object's bounding box
    fill_area = frozenset((i, j) for i in range(corner[0], min(corner[0] + 2, height_obj + corner[0])) for j in range(corner[1], corner[1] + width_obj))

    # 5. Fill the area with '3' on a blank canvas
    O = fill(canvas(0, shape(I)), 3, fill_area)
    return O 
 
0.08925925925925926, 13.575712, def cfahafcggddaebaeiebhdafdbcfdedba(I):
    # 1. Find the non-background object
    obj_color = leastcolor(I)
    obj = first(objects(I, True, False, True))

    # 2. Calculate upper-left corner and dimensions
    corner = ulcorner(obj)
    h = min(2, height(obj)) 
    w = width(obj)

    # 3. Crop the top two rows of the object
    cropped_obj = asobject(crop(I, corner, (h, w))) 

    # 4. Replace the object color with '3'
    recolored_obj = recolor(3, cropped_obj) 

    # 5. Paint onto a blank canvas
    O = paint(canvas(0, shape(I)), recolored_obj) 
    return O
 
0.01, 75.76088, def dcbecfjcgeccejfaibdgfdfjhbbajbhd(I):
    # 1. Find the non-background object
    obj_color = leastcolor(I)
    obj = first(objects(I, True, False, True))

    # 2. Get the object's indices and dimensions
    indices = toindices(obj)
    h, w = shape(indices)

    # 3. Filter indices to keep only those in the top two rows
    fill_indices = frozenset((i, j) for i, j in indices if i in (0, 1))

    # 4. Fill those indices with '3' on a blank canvas
    O = fill(canvas(0, (h, w)), 3, fill_indices)
    return O
 
0.08925925925925926, 10.44139, def bfecacegbfjhegabaabdcdechcffdcfc(I):
    # 1. Find the non-background object
    obj_color = leastcolor(I)
    obj = first(objects(I, True, False, True))

    # 2. Get object dimensions and upper-left corner
    h, w = shape(obj)
    row, col = ulcorner(obj)

    # 3. Create a grid filled with '3's for the top two rows of the object
    filled_grid = tuple(tuple(3 if j in range(col, col + w) and i in (0,1) else 0 for j in range(len(I[0]))) for i in range(len(I)))

    # 4. Return the filled grid as the output
    O = filled_grid 
    return O
 
0.22296296296296295, 26.820415, def fadfcacbdifceedgbhfjhcdfbijbfjfh(I):
  objs = objects(I, T, F, T)
  O = canvas(0, shape(I))
  for obj in objs:
    ul = ulcorner(obj)
    lr = lrcorner(obj)
    for i in range(lr[0]-ul[0]+1):
      for j in range(lr[1]-ul[1]+1):
        O = fill(O, 3, {(len(I)-1-i-ul[0], lr[1]-j)})
  return O
 
0.1796296296296296, 24.958426, def bfajacdhcieaeejbibeahdbdcfegjbbb(I):
  # Identify objects in the grid, excluding the background.
  x1 = objects(I, univalued=False, diagonal=True, without_bg=True)
  # Find the object with the maximum size.
  x2 = argmax(x1, size)
  # Recolor the largest object to 3.
  x3 = recolor(THREE, x2)
  # Paint the recolored object onto the original grid.
  O = paint(I, x3)
  return O
 
0.1796296296296296, 24.549358, def ddaaahedibfhecdajfajcfabjeceieec(I):
  # Get indices of all non-background cells.
  x1 = ofcolor(I, mostcolor(I))
  # Invert the indices to get the foreground cells.
  x2 = difference(asindices(I), x1) 
  # Create an object from the foreground indices.
  x3 = toobject(x2, I)
  # Find the largest object in the grid.
  x4 = argmax(objects(I, False, True, True), size)
  # Check if the largest object covers all foreground cells.
  x5 = equality(toindices(x4), x2)
  # Recolor the largest object to 3 if it covers all foreground.
  x6 = recolor(THREE, x4) if x5 else x4
  # Paint the (recolored) object back onto the original grid.
  O = paint(I, x6)
  return O
 
0.1796296296296296, 24.71688, def cfejiabfcgeaebedjhbefajdeebhdgic(I):
  # Find the largest object in the grid, excluding background.
  x1 = argmax(objects(I, univalued=False, diagonal=True, without_bg=True), size)
  # Get the color of the largest object.
  x2 = color(x1) 
  # Replace the color of the largest object with 3 in the entire grid.
  O = replace(I, x2, THREE)
  return O
 
0.8203703703703703, 25.12832, def eddgibjjbhiaeaedibceaagfcaeeedae(I):
  # Partition the grid into objects based on color.
  x1 = partition(I) 
  # Remove the background object from the set.
  x2 = difference(x1, {frozenset({(mostcolor(I), (i, j)) for i, r in enumerate(I) for j, v in enumerate(r)})})
  # Find the largest object (excluding background) based on size.
  x3 = argmax(x2, size)
  # Recolor the largest object to 3.
  x4 = recolor(THREE, x3)
  # Paint the recolored object onto a blank canvas with the input's dimensions.
  O = paint(canvas(mostcolor(I), shape(I)), x4)
  return O
 
0.14703703703703702, 22.192406, def adidjiaeaehbedjaagaehedbejfgceej(I):
  # Generate a blank canvas of the same size as the input.
  x1 = canvas(mostcolor(I), shape(I)) 
  # Find the largest object in the input, excluding the background.
  x2 = argmax(objects(I, False, True, True), size)
  # Paint the largest object, recolored to 3, onto the blank canvas.
  O = paint(x1, recolor(THREE, x2))
  return O
 
0.07592592592592591, 15.814102, def fcbdbdhhcbaceaefjiafjigbdabfffeb(I):
  # Find '2' objects and get their bounding box.
  twos = colorfilter(objects(I, T, T, T), 2)
  top = minimum(apply(uppermost, twos))
  left = minimum(apply(leftmost, twos))

  # Create a 2x2 square filled with 3s.
  square = canvas(3, (2, 2))

  # Paint the square onto the output canvas.
  O = canvas(0, shape(I))
  O = paint(O, asobject(crop(square, (0, 0), (2, 2))))
  return O
 
0.0462962962962963, 26.255064, def aejecdcebdiaefahadffcfcdbidfedad(I):
    # 1. Find the non-background object
    obj = first(objects(I, True, False, True))

    # 2. Determine the width of the object
    obj_width = width(obj)

    # 3. Calculate the upper-left corner of the new line
    corner = subtract(ulcorner(obj), (2, 0))

    # 4. Create a patch representing the new line
    fill_area = frozenset((corner[0], j) for j in range(corner[1], corner[1] + obj_width))

    # 5. Fill the area with '3's on an empty canvas
    O = fill(canvas(0, shape(I)), 3, fill_area)
    return O
 
0.09333333333333332, 15.201572, def aefebbjhgdbfedjfbeeffaefhdgjfhff(I):
  obj = next(iter(objects(I, T, F, T)))  # Get the non-background object
  box = backdrop(obj)                 # Get the bounding box of the object
  h, w = shape(box)                      # Get the height and width of the box
  shifted_box = shift(box, (len(I)-h, len(I[0])-w-leftmost(box))) # Shift the box to bottom-right
  return paint(canvas(0, shape(I)), recolor(3, hmirror(shifted_box))) # Mirror & paint the box
 
0.11925925925925927, 8.463423, def ahbgcebbehcaeebbidbgcgfecaaefaia(I):
  obj = first(objects(I, T, F, T)) # Extract the first non-background object
  x, y = lrcorner(obj)             # Get the lower-right corner coordinates of the object
  O = canvas(0, shape(I))           # Create an empty canvas with the input shape
  for i in range(height(obj)):       # Iterate through the height of the object
    for j in range(width(obj)):      # Iterate through the width of the object
      O = fill(O, 3, {(len(I)-1-i, x-j)}) # Fill the corresponding mirrored position with '3'
  return O                        # Return the modified output grid
 
0.05666666666666667, 24.12173, def effffecdfcebeijdaafdacfhdefejege(I):
  obj = extract(objects(I, T, F, T), identity)  # Extract the object
  h, w = height(obj), width(obj)               # Get object's height and width
  O = canvas(0, shape(I))                      # Create a blank canvas
  mirrored_box = hmirror(backdrop(obj))       # Get the mirrored bounding box
  O = paint(O, recolor(3, shift(mirrored_box, (len(I)-h, len(I[0])-w))))  # Shift and paint the box
  return O                                     # Return the output grid
 
0.10925925925925926, 11.617741, def ddjfbfbcdffiefcbiddeecfbcecdfbgd(I):
  obj = next(iter(objects(I, T, F, T)))
  O = canvas(0, shape(I))
  for i in range(height(obj)):
    for j in range(width(obj)):
      if index(I, (i+uppermost(obj), j+leftmost(obj))) != 0:  # Check if the cell is part of the object
        O = fill(O, 3, {(len(O)-1-i, len(O[0])-1-j)})         # Fill the mirrored position with '3'
  return O
 
0.16333333333333333, 35.571175, def hbhddgfhgcgiecadabedhfcfgdejhchb(I):
  # Identify objects, excluding background
  objs = objects(I, False, True, True)
  # Find the largest object
  largest_obj = argmax(objs, size)
  # Get the upper left corner of the object
  i, j = ulcorner(largest_obj)
  # Create a 3x2 patch at the corner
  patch = {(i, j), (i+1, j), (i+2, j), (i, j+1), (i+1, j+1), (i+2, j+1)}
  # Recolor the patch to 3
  recolored_patch = recolor(3, patch)
  # Paint the recolored patch onto the original grid
  O = paint(I, recolored_patch)
  return O
 
0.1796296296296296, 27.574718, def ijbbidaffabeecacjfeijbjddidfibaf(I):
  # Get indices of all non-background cells
  fg_indices = difference(asindices(I), ofcolor(I, mostcolor(I)))
  # Find the object containing the first foreground cell
  target_obj = extract(objects(I, False, True, True), lambda obj: any(index in toindices(obj) for index in fg_indices))
  # Get the upper left corner of the object's bounding box
  i, j = ulcorner(target_obj)
  # Create a 3x2 patch at the corner
  patch = product(interval(i, i+3, 1), interval(j, j+2, 1)) 
  # Recolor the patch within the object to 3
  recolored_obj = recolor(3, intersection(patch, toindices(target_obj)))
  # Paint the recolored object onto the original grid
  O = paint(I, recolored_obj)
  return O
 
0.1796296296296296, 29.815762, def ejefjbfgbdgfefbaacehcicjegggeead(I):
  # Find the largest object
  obj = argmax(objects(I, False, True, True), size)
  # Get the upper left and lower right corners
  ul = ulcorner(obj)
  lr = lrcorner(obj)
  # Calculate the height and width of the object
  h = lr[0] - ul[0] + 1
  w = lr[1] - ul[1] + 1
  # Define the target patch dimensions
  ph = min(h, 3)
  pw = min(w, 2)
  # Create the target patch at the upper left corner
  patch = product(interval(ul[0], ul[0]+ph, 1), interval(ul[1], ul[1]+pw, 1))
  # Recolor and paint the patch
  O = paint(I, recolor(3, intersection(patch, toindices(obj))))
  return O 
 
0.1725925925925926, 31.438818, def edfadbehfebcejeeicaaaedafbijddea(I):
  # Find the object with the least common color 
  obj = argmax(objects(I, False, True, True), lambda obj: -leastcolor(obj))
  # Shift the object to the origin
  normalized_obj = normalize(obj)
  # Recolor a fixed 3x2 patch at the origin to 3
  recolored_obj = recolor(3, {(0,0),(1,0),(2,0),(0,1),(1,1),(2,1)})
  # Shift the object back to its original position and paint
  O = paint(I, shift(recolored_obj, ulcorner(obj)))
  return O
 
0.2188888888888889, 31.930204, def afhhedcibifaedicbcabcgcbcbjaeecd(I):
  # Get the background color
  bg = mostcolor(I)
  # Create a 3x2 canvas filled with the background color
  canvas_3x2 = canvas(bg, (3, 2)) 
  # Find the largest object in the grid
  obj = argmax(objects(I, False, True, True), size) 
  # Get the upper left corner of the object
  ul = ulcorner(obj)
  # Crop the grid to the size of the object plus the canvas
  cropped_grid = crop(I, (max(0, ul[0]-3), max(0, ul[1]-2)), (min(len(I), ul[0]+3), min(len(I[0]), ul[1]+2)))
  # Overlay the canvas on the cropped grid
  overlayed_grid = cellwise(canvas_3x2, cropped_grid, bg)
  # Replace the background color in the overlayed grid with 3
  replaced_grid = replace(overlayed_grid, bg, 3)
  # Paint the modified area back onto the original grid
  O = paint(I, asobject(replaced_grid))
  return O
 
0.06629629629629631, 17.240772, def dhjhdcafabidecdcjabjabhcjbafhjba(I):
  obj = first(colorfilter(objects(I, True, False, True), TWO)) # Find the object composed of '2's.
  new_obj = recolor(THREE, frozenset((0, j) for j in range(width(obj))))  # Create the horizontal line of '3's.
  O = paint(canvas(ZERO, shape(I)), shift(new_obj, (uppermost(obj) + 3, leftmost(obj))))  # Paint the shifted object.
  return O
 
0.05962962962962964, 17.561327, def facefcefcbdgefefjdidcebbdcabdadh(I):
  # Find indices of all '2' cells.
  indices = ofcolor(I, 2)
  
  # Determine the top-left corner of the '2' objects.
  top, left = ulcorner(indices)

  # Generate the output grid with the same dimensions as the input.
  O = canvas(0, shape(I))
  
  # Draw a vertical line of '3's, 2 cells long.
  O = fill(O, 3, frozenset({(top, left), (top + 1, left)}))

  return O
 
0.09851851851851852, 8.829109, def fgifebfdffieeddfahfedcjdhabcjdbc(I):
  # Find the bounding box of all '2' cells.
  indices = ofcolor(I, 2)
  top, left = ulcorner(indices)
  bottom, right = lrcorner(indices)

  # Create the output grid.
  O = canvas(0, shape(I))

  # Draw a vertical line from the top-left corner, spanning the height of the bounding box.
  for i in range(top, bottom + 1):
    O = fill(O, 3, frozenset({(i, left)}))

  return O
 
0.06925925925925926, 16.372952, def ggebbcedchfieeceidiacfggchfddaae(I):
  obj = first(objects(I, True, False, True)) # Find the non-background object
  corner = ulcorner(obj) # Find the upper-left corner of the object
  line_start = (corner[0] - 2, corner[1])  # Calculate starting point of the line
  line_end = (corner[0] - 2, corner[1] + width(obj) - 1) # Calculate ending point of the line
  line1 = connect(line_start, line_end) # Create the first line of the horizontal line patch
  line2 = shift(line1, DOWN) # Create the second line of the horizontal line patch
  O = fill(canvas(0, shape(I)), 3, line1 | line2) # Fill the lines on an empty canvas
  return O
 
0.05962962962962964, 12.977982, def iahceeffhgdaeccbieacfdahbjhccgdb(I):
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset() # Safely get object
  line_width = width(obj)
  canvas_height = height(I) 
  line_start = (canvas_height - 3, canvas_height - 2) # Fixed vertical position
  O = canvas(0, shape(I)) # Create empty canvas
  for j in range(line_width):
    O = fill(O, 3, {(line_start[0], line_start[1] - j)}) 
  return O
 
0.043333333333333335, 29.34562, def defcabdijbjaebbebafeecfdjccgcidf(I):
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
  line = hline(obj)  
  O = canvas(0, shape(I))
  if line: 
    O = fill(O, 3, shift(hline(obj), (height(I) - 3, 0))) 
  return O 
 
0.06629629629629631, 14.440279, def iedfbicefbcbeicbicdhbebcafbfehdi(I):
    obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
    w = width(obj)
    O = canvas(0, shape(I))
    return fill(O, 3, {(len(I) - 3, j) for j in range(len(I[0]) - w, len(I[0]))})
 
0.06629629629629631, 13.319185, def defeegifacfdeiecjccfbhjfbeejjead(I):
    obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
    h, w = shape(I)
    x, y = lrcorner(obj) 
    return paint(canvas(0, (h, w)), 
                 recolor(3, 
                         {(h - 3, j) for j in range(y - width(obj) + 1, y + 1)})) 
 
0.22888888888888892, 32.233185, def aeccjcbbcedcejfgagjfehaahceaiche(I):
  # Find the largest object
  obj = argmax(objects(I, False, True, True), size)
  
  # Calculate new object dimensions and position
  obj_h = 3 if width(obj) >= 3 else 1
  obj_w = min(width(obj), 3)
  pos = (len(I) - obj_h - 1, (len(I[0]) - obj_w) // 2)
  
  # Create a canvas for the new object
  new_obj_canvas = canvas(0, (obj_h, obj_w))
  
  # Replace 0s in the canvas with 3s
  new_obj = replace(new_obj_canvas, 0, 3)
  
  # Paint the new object onto the original grid at the calculated position
  O = paint(I, asobject(crop(fill(I, 0, obj), pos, (obj_h, obj_w))))
  O = paint(O, asobject(crop(new_obj, (0, 0), (obj_h, obj_w)))) 
  return O
 
0.1225925925925926, 7.7036095, def bacdahbejhdfefagbcheebjaechagccg(I):
  # Find the largest object
  largest_obj = argmax(objects(I, False, True, True), size)
  
  # Erase the largest object
  I = paint(I, recolor(0, largest_obj))
  
  # Define the new object
  new_obj = {(3, (len(I)-2, (len(I[0])-3)//2)), 
              (3, (len(I)-2, (len(I[0])-3)//2 + 1)), 
              (3, (len(I)-1, (len(I[0])-3)//2)), 
              (3, (len(I)-1, (len(I[0])-3)//2 + 1))}
  
  # Conditionally add more cells to the new object
  if width(largest_obj) >= 3:
    new_obj.add((3, (len(I)-2, (len(I[0])-3)//2 + 2)))
    new_obj.add((3, (len(I)-1, (len(I[0])-3)//2 + 2)))
  if width(largest_obj) >= 5:
    new_obj.add((3, (len(I)-3, (len(I[0])-3)//2)))
    new_obj.add((3, (len(I)-3, (len(I[0])-3)//2 + 1)))
    new_obj.add((3, (len(I)-3, (len(I[0])-3)//2 + 2)))
  
  # Paint the new object onto the grid
  O = paint(I, frozenset(new_obj))
  return O
 
0.10185185185185186, 7.6073275, def aaacfjaajceceecajaeffgcgbebfecgd(I):
  # Find the largest object
  obj = argmax(objects(I, False, True, True), size)
  
  # Define a lambda function to create a line of a specific length
  create_line = lambda start, length, dir: frozenset((3, (start[0] + i * dir[0], start[1] + i * dir[1])) for i in range(length))
  
  # Calculate new object starting position and length
  start_pos = (len(I) - 2, (len(I[0]) - min(3, width(obj))) // 2)
  line_len = min(3, width(obj))
  
  # Create the horizontal line using the lambda function
  new_obj = create_line(start_pos, line_len, (0, 1))
  
  # Conditionally add a vertical line based on the largest object's width
  if width(obj) >= 3:
    new_obj = new_obj | create_line(start_pos, 2, (1, 0))
  
  # Erase the largest object and paint the new object
  O = paint(paint(I, recolor(0, obj)), new_obj)
  return O
 
0.11666666666666668, 9.577018, def dgfhbacfgcdaeaccjhhfhahaehffdcee(I):
  # Get the bounding box of the largest object
  obj = argmax(objects(I, False, True, True), size)
  ul = ulcorner(obj)
  lr = lrcorner(obj)

  # Calculate the height and width of the new object
  new_height = 3 if lr[1]-ul[1]+1 >= 3 else 1
  new_width = min(3, lr[1]-ul[1]+1)

  # Create a new grid with the desired dimensions
  O = canvas(0, (len(I), len(I[0])))

  # Paint the bottom part of the largest object onto the new grid
  for i in range(ul[0], lr[0] + 1):
    for j in range(ul[1], lr[1] + 1):
      if i >= len(I)-new_height:
        O = paint(O, {(I[i][j], (i, j))})

  # Paint the new object onto the grid
  for i in range(new_height):
    for j in range(new_width):
      O = paint(O, {(3, (len(I)-new_height+i, (len(I[0])-new_width)//2 + j))})

  return O
 
0.06629629629629631, 18.251314, def ahdfchecbabgeejejgbedjbbbdhedbdf(I):
  obj_two = first(colorfilter(objects(I, True, False, True), TWO)) # Find the highest object of 2s
  start_row = uppermost(obj_two) + 3  # Calculate the starting row for the line
  line_width = width(obj_two)  # Get the width of the 2s object
  new_indices = frozenset((start_row + i, leftmost(obj_two)) for i in range(line_width))  # Create indices for the vertical line
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, new_indices))  # Paint the line on a blank canvas
  return O
 
0.06296296296296297, 20.344107, def eaahedabagbfejhaiajjjheefafefija(I):
  obj_two = argmax(objects(I, True, False, True), lambda obj: uppermost(obj))  # Find the highest object of 2s
  line_start = (uppermost(obj_two) + 3, leftmost(obj_two))  # Define the starting point of the line
  line_indices = frozenset(add(line_start, (i, 0)) for i in range(width(obj_two)))  # Generate line indices using vector addition
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line_indices)) # Paint the line on a blank canvas
  return O
 
0.06962962962962964, 16.517319, def ciadcgabbefdeeebbhaeeedjbaccaiac(I):
  obj_two = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO) # Find the highest object of 2s
  line_start = (uppermost(obj_two) + 3, leftmost(obj_two)) # Define the starting point of the line
  line = connect(line_start, add(line_start, (height(obj_two) - 1, 0)))  # Generate line indices using the connect function
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))  # Paint the line on a blank canvas
  return O
 
0.08703703703703704, 8.979105, def aejbfchcicbfecicbdfghfdfdjecdahc(I):
  # Find all '2' objects
  twos = colorfilter(objects(I, T, T, T), 2)

  # Create the output grid.
  O = canvas(0, shape(I))

  # Iterate through each '2' object
  for obj in twos:
    # Get the top-left corner and width of the object.
    top, left = ulcorner(obj)
    width = rightmost(obj) - leftmost(obj) + 1

    # Draw a vertical line.
    for i in range(width):
      O = fill(O, 3, frozenset({(top + i, left)})) 

  return O
 
0.10666666666666667, 8.433033, def jbdcafdbbcddeajhiahdehfgcgdbifea(I):
  # Find indices of '2's.
  twos = ofcolor(I, 2)

  # Create the output grid.
  O = canvas(0, shape(I))

  # If no '2's are found, return the original input.
  if len(twos) == 0:
    return I

  # Get the leftmost column containing a '2'.
  left = minimum(j for i, j in twos)

  # Iterate through rows and draw vertical lines.
  for i, row in enumerate(I):
    if 2 in row:
      width = row.count(2)
      for j in range(width):
        O = fill(O, 3, frozenset({(i + j, left)}))
  return O
 
0.11444444444444445, 7.514097, def bddccgaaffadeeddjbcbjbdihdccbbfa(I):
  # Create the output grid.
  O = canvas(0, shape(I))

  # Iterate through rows and columns
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      # If a cell is '2'
      if val == 2: 
        # Find the rightmost '2' in the same row
        right = j
        while right < len(row) and row[right] == 2:
          right += 1
        # Draw the vertical line
        for k in range(right - j):
          O = fill(O, 3, frozenset({(i + k, j)}))
        break # Move to the next row after drawing the line
  return O 
 
0.13962962962962963, 18.657553, def jjjccejgafjdedbhbcecfbffhiiefbjj(I):
  # Transpose the grid 
  transposed = dmirror(I)

  # Process the transposed grid to find vertical lines of '2's
  processed = canvas(0, shape(transposed))
  for i, row in enumerate(transposed):
    start = None
    for j, val in enumerate(row):
      if val == 2 and start is None:
        start = j
      elif val != 2 and start is not None:
        for k in range(j - start):
          processed = fill(processed, 3, frozenset({(i, start + k)}))
        start = None

  # Transpose back to the original orientation
  O = dmirror(processed)
  return O
 
0.07666666666666667, 10.569782, def ecabeegeecehecajjfhfdedbgiahahig(I):
  obj_color = leastcolor(I) #Find the color of non-background object
  obj = first(objects(I, True, False, True)) # Find the non-background object
  corner = ulcorner(obj) # Find the upper-left corner of the object
  h = min(2, height(obj))  # Determine the height to crop (max 2 rows)
  w = width(obj) #Get the width of the object
  cropped_obj = asobject(crop(I, corner, (h, w))) # Crop the top 'h' rows of the object
  recolored_obj = recolor(3, cropped_obj) # Replace the object color with '3'
  O = paint(canvas(0, shape(I)), shift(recolored_obj, (2, 1))) # Paint the cropped object, shifted down by 2 and right by 1
  return O
 
0.08259259259259259, 6.3466463, def cbgfccahcifbeeaaicbgbeaabcddbhcf(I):
  obj = first(objects(I, True, False, True)) #Find the non-background object
  corner = ulcorner(obj) # Find the upper-left corner of the object
  cropped_indices = frozenset((i, j) for i in range(corner[0], corner[0] + 2) for j in range(corner[1], corner[1] + width(obj))) #Get indices for the top two rows of the object
  shifted_indices = shift(cropped_indices, (2, 1)) # Shift the indices two rows down and one column to the right
  O = fill(canvas(0, shape(I)), 3, shifted_indices) # Fill the shifted indices with '3' on a blank canvas 
  return O
 
0.054814814814814816, 21.448097, def figbggfcgffhecfajafaffcefedcbbbi(I):
  obj = first(objects(I, T, F, T))  # Extract the first non-background object.
  O = canvas(0, shape(I))          # Create a blank canvas with the same shape as the input.
  for i, r in enumerate(crop(I, ORIGIN, shape(obj))):  # Iterate through rows of the cropped object.
    for j, v in enumerate(r):                   # Iterate through values in each row.
      if v != mostcolor(I):                   # Check if the value is not background.
        O = fill(O, 3, {(len(O)-1-i, j)}) # Fill the corresponding mirrored position in the output grid.
  return O
 
0.10925925925925926, 12.115619, def badbfbcbbdgfefdaaiafffcbbfdbggaj(I):
  obj = first(objects(I, T, F, T))  # Extract the first non-background object.
  h, w = shape(obj)                # Get height and width of the object.
  O = canvas(0, shape(I))          # Create a blank canvas with the same shape as the input.
  for v, (i, j) in obj:            # Iterate through cells of the object.
    O = fill(O, 3, {(len(I)-1-(i-uppermost(obj)), j-leftmost(obj))}) # Fill the mirrored position with '3'.
  return O
 
0.08333333333333333, 14.699915, def cffhfcddceddeahfjgfeeaiafahhahjb(I):
  obj = first(objects(I, T, F, T)) # Extract the first non-background object.
  O = canvas(0, shape(I))           # Create a blank canvas with the same shape as the input.
  O = paint(O, recolor(3, shift(hmirror(obj), (height(I)-height(obj), 0)))) # Paint a mirrored and shifted object.
  return O
 
0.11, 8.140176, def biidcaebbbebeafdjdejijccbidefibd(I):
  # Find the largest object
  obj = argmax(objects(I, False, True, True), size)

  # Calculate new object position and size
  obj_width = width(obj)
  new_obj_height = 2 if obj_width >= 3 else 1
  new_obj_pos = (len(I) - new_obj_height - 1, (len(I[0]) - min(obj_width, 3)) // 2)

  # Create the new object (horizontal line with optional vertical extension)
  new_obj = {(3, (new_obj_pos[0], j)) for j in range(new_obj_pos[1], new_obj_pos[1] + min(obj_width, 3))}
  if obj_width >= 3:
    new_obj |= {(3, (new_obj_pos[0] + 1, new_obj_pos[1] + i)) for i in range(2)}

  # Erase the largest object and paint the new object
  O = paint(paint(I, recolor(0, obj)), frozenset(new_obj))
  return O
 
0.11148148148148147, 7.563401, def gabdbaifcdegejbhiicedbdeahaejcca(I):
  # Find largest object and its bounding box
  obj = argmax(objects(I, False, True, True), size)
  obj_box = backdrop(obj)

  # Calculate new object starting position 
  start_pos = (lowermost(obj_box), leftmost(obj_box) + (width(obj_box) - min(3, width(obj))) // 2)

  # Create new object using line function
  new_obj = connect(start_pos, (start_pos[0], start_pos[1] + min(3, width(obj)) - 1))
  if width(obj) >= 3:
    new_obj |= connect(start_pos, (start_pos[0] + 1, start_pos[1]))

  # Erase the portion of largest object above the new object
  erase_area = {(i, j) for i, j in obj_box if i < start_pos[0]}
  O = paint(I, recolor(0, erase_area))

  # Paint the new object
  O = paint(O, recolor(3, new_obj))
  return O
 
0.09999999999999999, 4.8816466, def eadgedjbfcaheeegachdbbfdeffbhddg(I):
  # Find largest object and its properties
  obj = argmax(objects(I, False, True, True), size)
  top_row = uppermost(obj)
  bottom_row = lowermost(obj)
  left_col = leftmost(obj)
  obj_width = width(obj)

  # Calculate new object position
  new_obj_row = bottom_row + 2
  new_obj_col = left_col + (obj_width - min(3, obj_width)) // 2

  # Create new object
  new_obj = {(new_obj_row, j) for j in range(new_obj_col, new_obj_col + min(3, obj_width))}
  if obj_width >= 3:
    new_obj |= {(new_obj_row + 1, new_obj_col), (new_obj_row + 1, new_obj_col + 1)}

  # Erase above the new object
  O = paint(I, recolor(0, {(i, j) for i, j in obj if i <= top_row + (new_obj_row - bottom_row)}))

  # Paint new object
  O = paint(O, recolor(3, new_obj))
  return O
 
0.11148148148148147, 7.13131, def dibhhacafbahedbbjjcacbbbegahafda(I):
  # Find largest object and its bounding box
  obj = argmax(objects(I, False, True, True), size)
  obj_ul = ulcorner(obj)
  obj_width = width(obj)

  # Calculate the new object's upper-left corner position
  new_obj_ul = (len(I) - (3 if obj_width >= 3 else 2), obj_ul[1] + (obj_width - min(3, obj_width)) // 2)

  # Create the new object
  new_obj = {(3, (new_obj_ul[0] + i, new_obj_ul[1] + j)) for i in range(1, (3 if obj_width >= 3 else 2)) for j in range(min(obj_width, 3))}

  # Erase the largest object
  O = paint(I, recolor(0, obj))

  # Paint the new object on the grid
  O = paint(O, frozenset(new_obj))
  return O
 
0.08851851851851851, 10.367986, def fgeeaajdcedaeddcbcecaggcddccjdda(I):
  indices = ofcolor(I, TWO)
  top_row = uppermost(indices)
  left_col = leftmost(indices)
  height = lowermost(indices) - top_row + 1
  line = frozenset((i, left_col) for i in range(top_row + 3, top_row + 3 + height))
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))
  return O
 
0.05962962962962964, 13.161107, def eagbdadhjgdjeaaijbbgahdcfdgbcgfj(I):
  obj = first(objects(I, True, False, True))
  line_start = add(ulcorner(obj), (2 + (height(obj) == 2) * 2, 0))
  line_end = add(line_start, (0, width(obj) - 1))
  line = connect(line_start, line_end)
  O = paint(canvas(0, shape(I)), recolor(3, line))
  return O
 
0.06629629629629631, 15.860716, def fhdbghahcjbcejhbahdeiehjejcdiceh(I):
  obj = extract(objects(I, T, F, T), identity)  # Extract the first non-background object.
  top_row = {(3, (uppermost(obj), j)) for j in range(leftmost(obj), rightmost(obj) + 1)}  # Create the top row filled with '3's.
  O = canvas(0, shape(I))  # Create an empty canvas.
  return paint(O, top_row)  # Paint the top row onto the canvas.
 
0.056296296296296296, 23.139832, def fjabjhhchcajedgdaejdadccdjgbjfca(I):
  O = canvas(0, shape(I))  # Create an empty canvas.
  for obj in objects(I, T, F, T):  # Iterate over each non-background object.
    for j in range(leftmost(obj), rightmost(obj) + 1):  # Iterate over the columns of the object.
      if I[uppermost(obj)][j] != 0:  # Check if the cell is part of the top row.
        O = paint(O, {(3, (uppermost(obj), 0))})  # Paint a '3' at the corresponding row on the left edge.
        break # Move to the next object after painting the first '3'
  return O 
 
0.09370370370370369, 15.773915, def dbhfeagcedjeehcdaddbcibeeiacfhab(I):
  O = canvas(0, shape(I))  # Create an empty canvas.
  for i in range(len(I)):  # Iterate over each row.
    for j in range(len(I[0])):  # Iterate over each column.
      if I[i][j] != 0:  # Check for a non-background cell.
        O = paint(O, {(3, (i, 0))})  # Paint a '3' at the corresponding row on the left edge.
        break  # Move to the next row
  return O
 
0.1037037037037037, 7.571286, def digcagbfebgiecfbagcifijdcaabaaac(I):
  # Find the largest object's bounding box
  obj = argmax(objects(I, False, True, True), size)
  bbox = backdrop(obj)
  # Calculate new object's width and starting column
  new_width = min(width(obj), 3)
  start_col = len(I[0]) - new_width - (2 if new_width == 3 else 1)
  # Create a horizontal line patch for the new object
  new_obj_patch = product(
      (len(I) - 2,),
      range(start_col, start_col + new_width)
  )
  # Paint the new object, overwriting anything in its path
  O = paint(I, recolor(3, new_obj_patch))
  # Erase everything in the bounding box above the new object
  O = paint(O, recolor(0, {(i, j) for i, j in bbox if i < len(I) - 2}))
  return O
 
0.061111111111111116, 17.244537, def iaehbdfbdgffeabjjadgifdbbbbjhdcb(I):
  # Find the rightmost column containing a non-background cell
  rightmost_col = max(j for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != mostcolor(I))
  # Calculate the starting column of the new object
  start_col = max(0, rightmost_col - 4 + (1 if rightmost_col >= len(I[0]) - 2 else 0))
  # Create a horizontal line patch for the new object
  new_obj_patch = product(
      (len(I) - 2,),
      range(start_col, min(start_col + 3, len(I[0])))
  )
  # Erase all non-background cells and paint the new object
  O = paint(canvas(0, shape(I)), recolor(3, new_obj_patch))
  return O
 
0.061111111111111116, 15.424644, def fbbefbhcbjafegcdbbfhjieejeacffgb(I):
  # Get the bottom three rows of the grid
  bottom_rows = I[len(I) - 3:]
  # Find the rightmost non-zero value in the bottom rows
  rightmost_col = max([j for i, row in enumerate(bottom_rows) for j, val in enumerate(row) if val != 0], default=0)
  # Determine the start column for the new object
  start_col = max(0, rightmost_col - 1 - (1 if rightmost_col >= len(I[0]) - 2 else 0))
  # Create the new object as a horizontal line
  new_obj = {(3, (len(I) - 2, j)) for j in range(start_col, min(start_col + 3, len(I[0])))}
  # Paint the new object onto a blank canvas of the same size as the input
  O = paint(canvas(0, shape(I)), new_obj)
  return O
 
0.06259259259259259, 16.13722, def eiaccefjgefeegccbcacibbcafdacddf(I):
  obj = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO)  # Find the highest object of 2s
  start_j = leftmost(obj) + width(obj) // 2 - (width(obj) % 2 == 0)  # Calculate the starting column index for replacement
  replace_indices = frozenset((i, j) for i, j in toindices(obj) if start_j <= j <= start_j + (width(obj) % 2 == 0))  # Get indices of the columns to be replaced
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, replace_indices))  # Paint the new object on a blank canvas
  return O
 
0.05962962962962964, 18.72065, def abebhchbcdajeajbjccadeddbebeahgf(I):
  obj_two = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO) # Find the highest object of 2s
  middle_col = width(obj_two) // 2 
  new_indices = frozenset((i, j) for i, j in toindices(obj_two) if abs(j - (leftmost(obj_two) + middle_col)) <= middle_col - 1)
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, new_indices)) 
  return O
 
0.08296296296296297, 6.0944386, def eeegficcccbbeicejigidbgehdecdbej(I):
  obj = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO)
  left_half = frozenset((v, (i, j)) for v, (i, j) in obj if j < leftmost(obj) + width(obj) // 2)
  right_half = frozenset((v, (i, j)) for v, (i, j) in obj if j >= leftmost(obj) + width(obj) // 2)
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, right_half))
  return O
 
0.08296296296296297, 9.469083, def dahaffeeabagegfjjaagdhidcifdbidc(I):
  obj = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO)
  middle =  width(obj) // 2
  new_indices = frozenset()
  for _, (i, j) in obj:
   if abs(j - (leftmost(obj) + middle - 1)) <= middle - (1- width(obj) % 2):
     new_indices = insert((THREE, (i, j)), new_indices)
   else:
     new_indices = insert((ZERO, (i, j)), new_indices)
  O = paint(canvas(ZERO, shape(I)), new_indices)
  return O
 
0.05148148148148148, 24.62063, def afbgddeddabbehbhjebfeicffibafjad(I):
  obj = first(objects(I, True, False, True))
  corner = ulcorner(obj)
  w = width(obj)
  slice_width = 3 if w > 3 else 1
  slice_start = 0 if w > 3 else w - 1
  target_area = {(3, (corner[0] + 2, corner[1] + 2 + slice_start + j)) for j in range(slice_width)}
  O = paint(canvas(0, shape(I)), frozenset(target_area))
  return O
 
0.048518518518518516, 23.582743, def cdgjdafhfcgcefibjcffdaeccfcifibd(I):
  obj = first(objects(I, True, False, True))
  x1 = ulcorner(obj)
  x2 = width(obj)
  x3 = branch(greater(x2, THREE), THREE, ONE)
  x4 = subtract(x2, x3)
  x5 = astuple(ONE, x3)
  x6 = crop(I, x1, x5)
  x7 = asobject(x6)
  x8 = recolor(THREE, x7)
  x9 = astuple(TWO, add(TWO, x4))
  O = paint(canvas(ZERO, shape(I)), shift(x8, x9))
  return O
 
0.053703703703703705, 11.49169, def dggbfcdjiiadedghjihbfjchdefgffbg(I):
  obj = first(objects(I, True, False, True))
  x1 = ulcorner(obj)
  x2 = width(obj)
  x3 = (ONE, x2) if x2 <= THREE else (ONE, THREE)
  x4 = crop(I, x1, x3)
  x5 = asobject(x4)
  x6 = recolor(THREE, x5)
  x7 = (TWO, TWO) if x2 <= THREE else (TWO, FIVE)
  O = paint(canvas(ZERO, shape(I)), shift(x6, x7))
  return O
 
0.08259259259259259, 11.175353, def jaagedbbeiibeeebjbfacdaadbahdcaf(I):
  obj = first(objects(I, T, F, T))
  O = canvas(0, shape(I))
  start_j = leftmost(obj)
  width = len(obj)
  O = fill(O, 3, {(len(I)-3, j) for j in range(start_j, start_j + width)})
  return O 
 
0.06074074074074074, 8.826612, def cfdebfeiecfceaaeicbegbfbeehbabfg(I):
  obj = argmax(objects(I, T, F, T), size)
  O = canvas(0, shape(I))
  center_j = centerofmass(obj)[1]
  half_width = width(obj) // 2
  O = fill(O, 3, {(len(I)-3, j) for j in range(center_j-half_width, center_j+half_width+width(obj)%2)})
  return O
 
0.06629629629629631, 14.31962, def edifcfcabaiieafcbdadgaicaeccjjdg(I):
  obj = next(obj for obj in objects(I, T, F, T) if color(obj) != 0)
  O = canvas(0, shape(I))
  offset = (len(I) - 3 - uppermost(obj), 0)
  line = shift(recolor(3, {(0, j) for j in range(width(obj))}), offset) 
  O = paint(O, line)
  return O
 
0.16296296296296295, 25.042124, def dedcaddjeibaefdcagaacdbgfdadeeff(I):
  obj = argmax(objects(I, False, True, True), size)
  w = min(width(obj), 3)
  O = paint(I, recolor(0, {(i, j) for i in range(uppermost(obj)) for j in range(len(I[0]))}))
  O = paint(O, recolor(3, {(uppermost(obj) - 2, len(I[0]) - w - (2 if w == 3 else 1) + j) for j in range(w)}))
  return O
 
0.05333333333333334, 22.717693, def cdefgbbdbjccejadjcgebhddahjbaefj(I):
  obj = argmax(objects(I, False, True, True), size)
  O = canvas(0, shape(I))
  new_obj = recolor(3, product((uppermost(obj) - 2,), range(len(I[0]) - min(width(obj), 3) - (2 if width(obj) == 3 else 1), len(I[0]) - (2 if width(obj) == 3 else 1))))
  O = paint(O, new_obj)
  return O
 
0.16296296296296295, 25.199244, def hjdgdfjedijeeaddbfdefjbfdebfacee(I):
  obj = argmax(objects(I, False, True, True), size)
  w = width(obj)
  O = I
  for i in range(uppermost(obj)):
    O = paint(O, recolor(0, {(i, j) for j in range(len(I[0]))}))
  O = paint(O, recolor(3, {(uppermost(obj) - 2, j) for j in range(len(I[0]) - min(w, 3) - (2 if w == 3 else 1), len(I[0]) - (2 if w == 3 else 1))}))
  return O
 
0.05962962962962964, 18.948215, def bhheiheiccdaeehejbcejbefcadeajbb(I):
  obj = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO)
  center_j = leftmost(obj) + width(obj) // 2 - (1 - width(obj) % 2)  
  new_obj = frozenset({(THREE, (i, center_j)) for v, (i, j) in obj if j == center_j})
  O = paint(canvas(ZERO, shape(I)), new_obj)
  return O
 
0.038518518518518514, 5.9962597, def jcghedfijedjeddebahcbcfaefdhabfd(I):
  obj = argmax(objects(I, True, False, True), lambda obj: color(obj) == TWO and len(obj)) 
  w = width(obj)
  line = frozenset((THREE, (i, leftmost(obj) + w // 2)) for i in range(uppermost(obj), lowermost(obj) + 1)) 
  O = paint(canvas(ZERO, shape(I)), line)
  return O
 
0.1362962962962963, 27.72293, def ahbhbdddjifaeeeaiecaegcffcdaefeg(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    if 2 in row:
      start = row.index(2)
      end = len(row) - row[::-1].index(2)
      for j in range(start, end):
        O = fill(O, 3, frozenset({(i, j)}))
  return O
 
0.10518518518518517, 12.798995, def badcbbddffehedeaifedefffbaddgecd(I):
  two_indices = {(i, j) for i, r in enumerate(I) for j, v in enumerate(r) if v == 2}
  O = canvas(0, shape(I))
  for i, j in two_indices:
    O = fill(O, 3, frozenset({(i, k) for k in range(j, width(I))}))
    break 
  return O
 
0.3451851851851852, 32.366962, def fjgaccidecbdeaadadfgiaajhggeghad(I):
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = paint(O, recolor(3, {(i, k) for k in range(j, len(row))}))
        break
  return O
 
0.3033333333333333, 31.841633, def gabacebadbjgejeijcdjacedagccebih(I):
  return tuple(
    tuple(
      3 if any(c == 2 for c in row[j:]) else 0
      for j in range(len(row))
    )
    for row in I
  )
 
0.06629629629629631, 14.094608, def acidafbfgdfheeecjcahcfcedjddebib(I):
  obj = first(objects(I, True, False, True))
  w = width(obj)
  bar_width = branch(greater(w, 3), 3, w)
  start_col = branch(greater(w, 3), 2, w-1)
  bar_indices = frozenset((uppermost(obj) + 2, j) for j in range(leftmost(obj) + start_col, leftmost(obj) + start_col + bar_width))
  O = paint(canvas(0, shape(I)), recolor(3, bar_indices)) 
  return O
 
0.06962962962962964, 14.114872, def edahgeajadbcegbdjacfcfdhadjbibdf(I):
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
  mid = width(obj) // 2  # Find the middle column of the object
  O = canvas(0, shape(I))
  if mid > 0:  # Only proceed if a midline exists
    for i in range(height(obj)):
      O = fill(O, 3, {(height(I) - 3 - i, mid)})  # Draw a vertical line
  return O
 
0.05814814814814815, 17.79528, def fcddfbejggfhefjebjjgbfgebdffjfce(I):
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
  start_j = leftmost(obj) + width(obj) // 2  # Get starting column
  O = canvas(0, shape(I))
  if width(obj) != width(I):  # Check if the object spans the whole width
    O = fill(O, 3, {(height(I) - 3, j) for j in range(start_j, start_j + width(obj) % 2 + 1)})  # Fill horizontally 
  return O
 
0.07222222222222223, 12.164772, def cjcjbecgidadedadbaggeggchgeeficb(I):
  # Find the largest object 
  obj = argmax(objects(I, False, True, True), size)

  # Get the lower left corner of the object
  bottom_row, left_col = llcorner(obj)

  # Calculate new object's dimensions
  new_width = min(width(obj), 3) 
  new_height = 2 if new_width == 3 else 1

  # Calculate the upper left corner of the new object
  new_row = bottom_row + 1
  new_col = left_col + (width(obj) - new_width) // 2

  # Create the new object
  new_obj = {(3, (i, j)) for i in range(new_row, new_row + new_height) 
                          for j in range(new_col, new_col + new_width)}

  # Paint the new object on a blank canvas
  O = paint(canvas(0, shape(I)), new_obj)
  return O
 
0.034444444444444444, 4.5233145, def acefbdcfbafbeceiibdeaabccbjfbddb(I):
  # Directly find the center and width of the largest object
  obj_center = centerofmass(argmax(objects(I, False, True, True), size))
  obj_width = width(argmax(objects(I, False, True, True), size))

  # Calculate the new object's position and dimensions
  new_width = min(obj_width, 3) 
  new_height = 2 if new_width == 3 else 1
  new_row = obj_center[0] + 1 - new_height // 2 
  new_col = obj_center[1] - new_width // 2 

  # Create new object on a blank canvas
  O = paint(canvas(0, shape(I)), recolor(3, {(i, j) for i in range(new_row, new_row + new_height)
                                                        for j in range(new_col, new_col + new_width)}))
  return O
 
0.06740740740740742, 14.158599, def bfdghafdffjbebejjhaafidfcechadab(I):
  # Find largest object and its bottom row
  obj = argmax(objects(I, False, True, True), size)
  bottom_row = lowermost(obj)

  # Create new object directly on a blank canvas
  O = canvas(0, shape(I))
  new_width = min(width(obj), 3)
  for j in range(new_width):
    O = fill(O, 3, {(bottom_row + 1, leftmost(obj) + j + (width(obj) - new_width) // 2)})
  if new_width == 3:
    for j in range(2):
      O = fill(O, 3, {(bottom_row + 2, leftmost(obj) + j + 1 + (width(obj) - new_width) // 2)})
  return O
 
0.0525925925925926, 10.773537, def gebhfefdjdbgeeafbejfagfcecdiccec(I):
  obj = next(obj for obj in objects(I, True, False, True) if color(obj) == TWO)
  line_x = leftmost(obj) + width(obj) // 2 - (width(obj) % 2 == 0)
  line = frozenset((i, line_x) for i in range(uppermost(obj), lowermost(obj) + 1))
  line = line | frozenset((i, line_x + 1) for i in range(uppermost(obj), lowermost(obj) + 1)) if width(obj) % 2 == 0 else line
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))
  return O
 
0.03518518518518519, 4.669267, def eaccifaddffhefeiahgaeehgffabbabg(I):
  obj = argmax(objects(I, True, False, True), lambda obj: colorcount(obj, TWO))
  center_x = leftmost(obj) + width(obj) // 2
  line = frozenset((i, center_x - 1 + (j % 2)) for j in range(2) for i in range(uppermost(obj), lowermost(obj) + 1)) if width(obj) % 2 == 0 else frozenset((i, center_x) for i in range(uppermost(obj), lowermost(obj) + 1))
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))
  return O
 
0.049629629629629635, 12.904767, def fbcfddeafaefegdcahbccafjccaaaeab(I):
  obj = next(o for o in objects(I, True, False, True) if color(o) == TWO)
  width_offset = 1 if width(obj) % 2 == 0 else 0
  line_start = (uppermost(obj), leftmost(obj) + width(obj) // 2 - width_offset)
  line_end = (lowermost(obj), line_start[1] + width_offset)
  line = connect(line_start, line_end)
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))
  return O
 
0.049629629629629635, 13.135756, def gfjccebaaeejefjfaagcadfajagjdeff(I):
  obj = first(colorfilter(objects(I, T, T, T), 2))
  center_i, center_j = centerofmass(obj)
  height_obj = height(obj)
  line = frozenset((i, center_j) for i in range(center_i - height_obj // 2, center_i + (height_obj + 1) // 2))
  O = paint(canvas(0, shape(I)), recolor(3, line))
  return O
 
0.038518518518518514, 7.4882655, def edhbdjjefdhfebedbigiefddbgbcbjdc(I):
  obj = argmax(objects(I, T, T, T), size)
  top_i, _ = ulcorner(obj)
  bottom_i = top_i + height(obj) - 1
  _, center_j = centerofmass(obj)
  line = frozenset((i, center_j) for i in range(top_i, bottom_i + 1))
  O = paint(canvas(0, shape(I)), recolor(3, line))
  return O
 
0.049629629629629635, 13.113817, def efabjdacbjaieiibbefacdhjfcdbbcij(I):
  obj = extract(objects(I, T, T, T), lambda obj: color(obj) == 2)
  ci, cj = center(obj)
  line_height = height(obj)
  start_i = ci - line_height // 2
  line = frozenset((start_i + i, cj) for i in range(line_height))
  O = paint(canvas(0, shape(I)), recolor(3, line))
  return O
 
0.07629629629629629, 9.909348, def ibcajfhebbbiefieiiedfaehebafccdc(I):
  twos = ofcolor(I, 2)
  min_i = uppermost(twos)
  max_i = lowermost(twos)
  _, center_j = centerofmass(twos)
  line = connect((min_i, center_j), (max_i, center_j))
  O = paint(canvas(0, shape(I)), recolor(3, line))
  return O
 
0.09222222222222222, 6.842401, def fiffgffabddfeadjbjeebfdfaiccbiag(I):
  obj = first(objects(I, True, False, True))  # Extract the non-background object
  start_j = ulcorner(obj)[1] + 2  # Calculate starting column for the bar
  bar_width = 3 if width(obj) > 3 else 2  # Determine bar width
  target_area = frozenset({(i, j) for i in range(ulcorner(obj)[0] + 2, ulcorner(obj)[0] + 5) for j in range(start_j, start_j + bar_width)}) 
  O = paint(canvas(0, shape(I)), recolor(3, target_area))  # Draw the bar
  return O
 
0.09222222222222222, 6.779717, def dccjiebabbbdehicafgaefdjbfbiecfe(I):
  obj = first(objects(I, True, False, True))
  bar_width = 2 + (width(obj) > 3) # Bar width is 2 or 3 based on object width
  offset = (2, 2) if width(obj) > 3 else (2, width(obj) - 1) # Offset for bar placement
  bar_start = add(ulcorner(obj), offset) # Calculate bar starting point
  bar_end = add(bar_start, (2, bar_width - 1)) # Calculate bar ending point
  target_area = backdrop(frozenset({bar_start, bar_end}))  # Generate indices within the bar's bounding box
  O = paint(canvas(0, shape(I)), recolor(3, target_area))
  return O
 
0.043333333333333335, 29.34562, def aeeaaecgbdciecgcibcjafdcaaadddef(I):
  obj = first(objects(I, True, False, True))
  bar_width = 2 + (width(obj) > 3)
  start_j =  ulcorner(obj)[1] + 2 if width(obj) > 3 else ulcorner(obj)[1] + width(obj) - 1
  target_area = connect((ulcorner(obj)[0] + 2, start_j), (ulcorner(obj)[0] + 4, start_j + bar_width - 1)) # Connect two points to form the bar
  O = paint(canvas(0, shape(I)), recolor(3, target_area))
  return O
 
0.07592592592592591, 8.549223, def cabhagjbhfcceceajfgadicbbeaaeefc(I):
    obj = first(objects(I, True, False, True))
    bar_start = (ulcorner(obj)[0] + 2, ulcorner(obj)[1] + 2 if width(obj) > 3 else ulcorner(obj)[1] + width(obj) - 1)
    bar_segments = ((0, 0), (1, 0), (2, 0), (0, 1), (1, 1), (2, 1)) if width(obj) > 3 else ((0, 0), (1, 0), (0, 1), (1, 1)) 
    target_area = frozenset(add(bar_start, segment) for segment in bar_segments)
    O = paint(canvas(0, shape(I)), recolor(3, target_area))
    return O
 
0.049629629629629635, 13.592002, def fijigcagbffaedaijafdbbfahciicfaf(I):
  obj = first(objects(I, T, F, T))      # Extract the first object
  O = canvas(0, shape(I))              # Create an empty canvas
  center_j = leftmost(obj) + width(obj) // 2  # Calculate the horizontal center
  O = fill(O, 3, {(i, center_j) for i in range(height(obj))}) # Draw the vertical line
  return O
 
0.0162962962962963, 61.210735, def caedcdcdaaiaeeagjdcaajdcbfehjabc(I):
  obj = next(iter(objects(I, T, F, T)))  # Extract the first object
  O = canvas(0, (height(obj), len(I[0])))  # Create a canvas with height of the object
  for i in range(height(obj)):             # Iterate through rows 
    O = fill(O, 3, {(i, leftmost(obj) + width(obj) // 2)}) # Fill center cell in each row
  return O
 
0.05851851851851852, 8.247008, def aiecfifjibcfefadbcfefbgfbdadhcja(I):
  obj = argmax(objects(I, T, F, T), size) # Extract the largest object
  h, w = shape(obj)                         # Get height and width of the object
  O = canvas(0, shape(I))                   # Create a blank canvas
  center = (0, leftmost(obj) + w // 2)       # Calculate the center coordinates
  O = fill(O, 3, connect(center, (h-1, center[1]))) # Draw the line
  return O
 
0.049629629629629635, 13.113817, def gcdhabjgacfdefhdidbhdcabfdcbjbia(I):
  obj = first(objects(I, T, F, T))      # Extract the first object
  O = canvas(0, shape(I))              # Create an empty canvas
  j = leftmost(obj) + width(obj) // 2  # Calculate the horizontal center
  line = {(i, j) for i in range(height(I))} # Generate indices for a full-height line
  O = fill(O, 3, intersection(line, backdrop(obj))) # Fill only the part within the object's bounding box
  return O
 
0.19407407407407407, 30.912935, def jiadcibaedgdeedibihjgfacfiejffdi(I):
  obj = argmax(objects(I, False, True, True), size)
  new_width = min(width(obj), 3)
  new_obj_patch = product(
      (lowermost(obj) + 1,),
      range(leftmost(obj) + (width(obj) - new_width) // 2, leftmost(obj) + (width(obj) - new_width) // 2 + new_width)
  )
  O = paint(I, recolor(3, new_obj_patch))
  return O
 
0.05777777777777778, 20.373543, def fadacddahfegefegjcgbbafbhbacdide(I):
  obj = argmax(objects(I, False, True, True), size)
  h = height(obj)
  O = paint(canvas(0, shape(I)), recolor(3, product((lowermost(obj) + 1,), range(leftmost(obj), leftmost(obj) + min(width(obj), 3)))))
  return O if h != 1 else I
 
0.09037037037037038, 8.879776, def dgfdgaccjcadeagdaaeafbdeeifefbdj(I):
  obj = argmax(objects(I, False, True, True), size)
  O = paint(cover(I, obj), recolor(3, {(lowermost(obj) + 1, j) for j in range(leftmost(obj), leftmost(obj) + min(width(obj), 3))}))
  return O 
 
0.1996296296296296, 30.63912, def haheeajcgaifeahhiddbeicacjbceadf(I):
  obj = argmax(objects(I, False, True, True), size)
  w = min(width(obj), 3)
  offset = (lowermost(obj) + 1 - uppermost(obj), leftmost(obj) + (width(obj) - w) // 2 - leftmost(obj))
  O = paint(I, recolor(3, shift(product((0,), range(w)), offset)))
  return O
 
0.07814814814814815, 12.200713, def ejeahgjfefdgeihfiadehbebahfcaade(I):
  obj_indices = ofcolor(I, TWO)
  offset = 3 if height(obj_indices) > 1 else 2
  line_indices = {(uppermost(obj_indices) + offset, j) for i, j in obj_indices}
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line_indices)) 
  return O
 
0.0725925925925926, 16.710573, def gdhjachhcabjecediidbahfegbdaeddd(I):
  obj = extract(objects(I, True, False, True), lambda o: color(o) == TWO)
  line = shift(normalize(obj), (3 if height(obj) > 1 else 2, -width(obj) // 2 + (width(obj) % 2 == 0)))
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line))
  return O
 
0.04518518518518519, 7.286515, def aefbaicddfjeeegibefdffbcbbibeacc(I):
  # Find the largest object of 2's.
  obj = argmax(objects(I, T, T, T), size)
  # Find the leftmost and rightmost columns of the object.
  left = leftmost(obj)
  right = rightmost(obj)
  # Find the row index of the center of mass.
  center_i, _ = centerofmass(obj)
  # Create a horizontal line of 3's.
  hline = frozenset((center_i, j) for j in range(left, right + 1))
  # Create an empty canvas and paint the line.
  O = paint(canvas(0, shape(I)), recolor(3, hline))
  return O
 
0.07148148148148149, 7.900243, def baagaeeeibjeefffjfdcabbfebabjbed(I):
  # Find all objects of 2's and select the largest.
  obj = argmax(colorfilter(partition(I), 2), size)
  # Find the row index of the center of mass.
  center_i, _ = centerofmass(obj)
  # Project the object onto the horizontal axis (collapses rows).
  projection = frozenset({j for _, (i, j) in obj})
  # Create a horizontal line at the center of mass.
  hline = frozenset((center_i, j) for j in projection)
  # Generate the output grid.
  O = paint(canvas(0, shape(I)), recolor(3, hline))
  return O
 
0.07740740740740741, 9.651183, def jjhdidcabceeeaafjdfbiageiabefabf(I):
  # Find the bounding box of the largest object of 2's.
  bbox = backdrop(argmax(colorfilter(partition(I), 2), size))
  # Find the row index of the center of mass of the bounding box.
  center_i, _ = centerofmass(bbox)
  # Extract the horizontal span of the bounding box.
  _, left = ulcorner(bbox)
  _, right = urcorner(bbox)
  # Create the horizontal line and paint it on an empty canvas.
  hline = frozenset((center_i, j) for j in range(left, right + 1))
  O = paint(canvas(0, shape(I)), recolor(3, hline))
  return O
 
0.07740740740740741, 8.060845, def afijgdiefigcehedbihdbhdeeibjbcgi(I):
  # Identify indices of all '2' cells.
  indices = ofcolor(I, 2)
  # Determine the minimum and maximum column indices.
  min_j = min(j for _, j in indices)
  max_j = max(j for _, j in indices)
  # Calculate the center of mass of all '2' cells.
  center_i, _ = centerofmass(indices)
  # Generate the horizontal line.
  hline = frozenset((center_i, j) for j in range(min_j, max_j + 1))
  # Paint the line on a blank canvas.
  O = paint(canvas(0, shape(I)), recolor(3, hline))
  return O
 
0.04518518518518519, 7.0823674, def bdjehgahdgfaedffbhbdfbefieiabfdc(I):
  obj = argmax(objects(I, True, False, True), size)  # Find the largest object
  line_start = add(ulcorner(obj), (2, 0))  # Calculate line start position
  line_end = add(line_start, (0, width(obj) - 1))  # Calculate line end position
  line = connect(line_start, line_end)  # Create the line indices
  O = paint(canvas(0, shape(I)), recolor(3, line))  # Draw the line on a blank canvas
  return O
 
0.05666666666666667, 21.34204, def afjdfddfcfcaeegdbeiacfccijafifib(I):
  objs = objects(I, True, False, True)  # Extract all objects
  largest_obj =  extract(objs, lambda obj: size(obj) == valmax(objs, size))  # Find the largest object
  line_start_row = uppermost(largest_obj) - 2  # Calculate line starting row
  line_width = width(largest_obj)  # Get the width of the largest object
  line = {(line_start_row, j) for j in range(leftmost(largest_obj), leftmost(largest_obj) + line_width)}  # Generate line indices
  O = paint(canvas(0, shape(I)), recolor(3, line))  # Draw the line on a blank canvas
  return O
 
0.07407407407407407, 14.987034, def ehdhbicibjgcefegbcdbchfccgecjicd(I):
  obj = argmax(objects(I, T, F, T), size)  # Extract the largest object
  O = canvas(0, shape(I))                    # Create a blank canvas
  line = hline(obj)                         # Check if the object is already a horizontal line
  start_row = uppermost(obj) if line else max(0, uppermost(obj)-1)  # Determine starting row for the line
  center_j = leftmost(obj) + width(obj) // 2  # Calculate horizontal center
  O = fill(O, 3, connect((start_row, center_j), (start_row, center_j + width(obj) - 1)))  # Draw the line
  return O 
 
0.03814814814814815, 43.08519, def djedejaabbbjeiebjebgebgbeddbjbbb(I):
  obj = argmax(objects(I, T, F, T), size) # Extract largest object
  h = height(obj)                           # Get object's height
  O = vsplit(canvas(0, shape(I)), h)[0]     # Create a canvas of height h
  w = width(obj)                          # Get object's width
  center = (0, leftmost(obj) + w // 2)       # Calculate the center coordinates
  O = fill(O, 3, connect(center, (h - 1, center[1]))) # Draw the line
  return vconcat(O, vsplit(canvas(0, shape(I)), h)[1]) # Concatenate the line with the remaining canvas
 
0.07407407407407407, 15.244482, def ccedfjfddfecedfiidgahchhaaaecfjj(I):
  obj = argmax(objects(I, T, F, T), size) # Extract largest object
  O = canvas(0, shape(I))                   # Create a blank canvas
  row_index = uppermost(obj) - 1 if uppermost(obj) > 0 else uppermost(obj) # Determine the row index
  for j in range(leftmost(obj), leftmost(obj) + width(obj)): # Iterate over columns
    O = fill(O, 3, {(row_index, j)})         # Fill the current cell with 3
  return O
 
0.06777777777777778, 15.196286, def hecceadeabagededaaeehejcbfecbida(I):
  # Find the rightmost non-background cell
  rightmost_col = max(j for i in range(len(I)) for j in range(len(I[0])) if I[i][j] != mostcolor(I))
  
  # Calculate starting row for the vertical line
  start_row = max(0, len(I) // 2 - 1)

  # Create a vertical line patch for the new object
  new_obj_patch = product(
      range(start_row, start_row + 3),
      (rightmost_col,)
  )

  # Erase all non-background cells and paint the new object
  O = paint(canvas(0, shape(I)), recolor(3, new_obj_patch))
  return O
 
0.061111111111111116, 19.625946, def daahbadfeadcefcdjgcfadddeeaaaach(I):
  # Find the bounding box of the rightmost object
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  rightmost_obj = argmax(objs, lambda obj: rightmost(obj))

  # Calculate the center of the rightmost object
  center_col = centerofmass(rightmost_obj)[1]

  # Create a vertical line patch centered on the object's column
  new_obj_patch = product(
      range(len(I) // 2 - 1, len(I) // 2 + 2),
      (center_col,)
  )

  # Erase all non-background cells and paint the new object
  O = paint(canvas(0, shape(I)), recolor(3, new_obj_patch))
  return O
 
0.061111111111111116, 19.985184, def ejddaeijjdhbecddjfbfajbgfgegdifc(I):
  # Rotate the input grid by 90 degrees
  rotated_grid = rot90(I)
  
  # Find the lowermost row containing a non-background cell in the rotated grid
  lowermost_row = max(i for i in range(len(rotated_grid)) if any(v != mostcolor(I) for v in rotated_grid[i]))

  # Calculate the starting column for the vertical line in the original grid
  start_col = max(0, lowermost_row - 2)

  # Create a vertical line patch for the new object
  new_obj_patch = product(
      range(len(I) // 2 - 1, len(I) // 2 + 2),
      (start_col,)
  )

  # Erase all non-background cells and paint the new object
  O = paint(canvas(0, shape(I)), recolor(3, new_obj_patch))
  return O
 
0.07777777777777778, 10.152532, def accbfccebhbdehebadbfaigdbffehjfe(I):
  obj = extract(objects(I, T, F, T), matcher(color, TWO)) # Find the '2' object
  line_start = add(lrcorner(obj), (2, 1)) # Start below and one unit right of the object
  line_end = add(line_start, (0, 2 * width(obj) - 1)) # End point for the line of '3's
  line = connect(line_start, line_end) # Generate indices for the line
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line)) # Paint the line on a blank canvas
  return O
 
0.08259259259259259, 7.957793, def iggjahddddbfebfjaegajdajecigeabb(I):
    obj = next((o for o in objects(I, True, False, True) if color(o) == TWO), ())
    start_row = uppermost(obj) + 2 # Row for the line of '3's
    start_col = leftmost(obj) # Starting column for the line of '3's
    line_width = 2 * width(obj) # Width of the line of '3's
    O = canvas(ZERO, shape(I)) # Create a blank canvas
    for i in range(line_width):
        O = paint(O, {(THREE, (start_row, start_col + i))}) # Paint each '3' individually
    return O
 
0.09407407407407409, 8.242539, def edbdedcfcfhaecddiadcecgdfbbfibbi(I):
  obj_indices = toindices(extract(objects(I, T, F, T), lambda o: color(o) == TWO))
  line_row = lowermost(obj_indices) + 2  
  line_start = (line_row, leftmost(obj_indices)) 
  line_end = (line_row, rightmost(obj_indices) * 2 + 1) 
  line_indices = connect(line_start, line_end)
  O = paint(canvas(ZERO, shape(I)), recolor(THREE, line_indices)) 
  return O
 
0.13296296296296298, 16.64239, def deaaeccbfdcbehafifddhbfadfcfdcha(I):
  objs = objects(I, True, False, True)
  shifted_objs = frozenset({shift(obj, (lowermost(obj) - uppermost(obj) + 1, 0)) for obj in objs if color(obj) == 2})
  O = paint(canvas(0, shape(I)), merge(shifted_objs))
  return O
 
0.043333333333333335, 29.34562, def bdgbjedaigcbecfgiedfgfdadecdjgcb(I):
  objs = partition(I)
  moved_objs = frozenset({recolor(0, obj) if color(obj) != 2 else toobject(shift(toindices(obj), (lowermost(obj) - uppermost(obj) + 1, 0)), I) for obj in objs})
  O = paint(canvas(0, shape(I)), merge(moved_objs))
  return O
 
0.13518518518518519, 16.283813, def dcfffccafcccediibdffccciadcebaid(I):
  shifted = []
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        shifted.append((val, (i + sum(1 for r in I[:i+1] if r[j] == 2), j))) 
  O = paint(canvas(0, shape(I)), frozenset(shifted))
  return O
 
0.11074074074074074, 8.767965, def fedjfidfbafbeeccbfchjhffcbhjacdf(I):
  obj = argmax(objects(I, T, F, T), size) # Find the largest object
  top_left = ulcorner(obj)  # Get the top-left corner of the object
  O = canvas(0, shape(I))  # Create an empty canvas
  line = frozenset({(i, top_left[1]) for i in range(top_left[0], len(I))}) # Generate indices for the vertical line
  return fill(O, 3, line) # Fill the line with '3' on the canvas 
 
0.13222222222222224, 10.7743025, def fjiefbdhfahdeiejidaiceaegaffdcaf(I):
  obj = argmax(objects(I, T, F, T), size) # Find the largest object
  start_row = uppermost(obj)  # Get the row index of the uppermost cell 
  O = canvas(0, shape(I)) # Create an empty canvas
  return fill(O, 3, vfrontier((start_row, leftmost(obj)))) # Fill the vertical frontier from starting row with '3'
 
0.08074074074074074, 9.360669, def eigebdeaajfaeecdbcbbcecdijajafde(I):
  obj = argmax(objects(I, T, F, T), size) # Find the largest object
  line = {(i, leftmost(obj)) for i in range(height(I))} # Generate indices for a vertical line across the whole grid
  O = paint(canvas(0, shape(I)), recolor(3, intersection(line, toindices(obj)))) # Only color the line segment that intersects the object
  return O
 
0.05777777777777778, 20.845823, def fejdceifbadheagcacbbifbeccbdgabc(I):
  obj = argmax(objects(I, False, True, True), size)  # Find largest object
  line_width = min(width(obj), 3)                 # Calculate line width
  start_j = leftmost(obj) + (width(obj) - line_width) // 2  # Center the line
  line_patch = product((lowermost(obj) + 1,), range(start_j, start_j + line_width))
  O = paint(canvas(0, shape(I)), recolor(3, line_patch))  # Draw the line
  return O
 
0.06777777777777778, 13.595025, def dfdebajhcgcdeigjifdaffcaeeiccehg(I):
  obj = max(objects(I, False, True, True), key=size) 
  w = min(width(obj), 3) 
  offset = (lowermost(obj) + 1 - uppermost(obj), (width(obj) - w) // 2)
  line = shift(product((0,), range(w)), offset)
  return paint(canvas(0, shape(I)), recolor(3, line))
 
0.06740740740740742, 33.072285, def fechcedcefidedcdiehdgfdeabafbbbe(I):
    factor = 3 if 2 in merge(I) else 5 
    O = upscale(I, factor)
    if 2 in merge(I):
        obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
        w = width(obj)
        return fill(O, 3, {(len(O) - 3, j) for j in range(len(O[0]) - w, len(O[0]))})
    else:
        return fill(O, 3, {(i, len(O[0]) // 2) for i in range(len(O) // 2 - 1, len(O) // 2 + 1)})
 
0.054814814814814816, 35.65404, def fdadhejbeegeefefacifbcaaefeijgfg(I):
  f = 3 if any(2 in r for r in I) else 5
  O = canvas(0, (len(I) * f, len(I[0]) * f))
  if any(2 in r for r in I):
    for i, r in enumerate(I):
      for j, v in enumerate(r):
        if v == 2:
          O = fill(O, 3, {(i * f + k, j * f + l) for k in range(3) for l in range(3)})
  else:
    for i in range(2 * f, 3 * f):
      O = fill(O, 3, {(i, len(O[0]) // 2)}) 
  return O
 
0.05925925925925926, 32.62127, def ccjcabiaeeiceieeagabeddjhbhfeeia(I):
  factor = 3 if any(2 in r for r in I) else 5
  O = upscale(I, factor)
  if any(2 in r for r in I):
    obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
    O = fill(O, 3, backdrop(shift(upscale(obj, factor), (factor, factor))))
  else:
    O = fill(O, 3, {(i, len(O[0]) // 2) for i in range(2 * factor, 3 * factor)})
  return O
 
0.06777777777777778, 33.06896, def dfidfdecagbfebddidebgbbbbcbfbaef(I):
  s = 3 if 2 in merge(I) else 5
  O = upscale(I, s)
  if 2 in merge(I):
    obj = first(objects(I, True, False, True)) if objects(I, True, False, True) else frozenset()
    O = fill(O, 3, {(a + (len(O) - 3), b + (len(O[0]) - 3)) for a in range(3) for b in range(width(obj))})
  else:
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)})
  return O
 
0.048148148148148155, 27.571354, def dceeccceebegeegfjchaffefihfgcfcd(I):
  objs = objects(I, True, False, True)
  target_color = 3
  upscale_factor = 5
  O = canvas(0, (height(I) * upscale_factor, width(I) * upscale_factor))
  for obj in objs:
    if color(obj) == 2:
      obj_height = height(obj)
      obj_width = width(obj)
      new_obj = recolor(target_color, {(i, j) for i in range(obj_height) for j in range(obj_width)})
      O = paint(O, shift(new_obj, (height(O) - obj_height, 0)))
  return O
 
0.048148148148148155, 26.980955, def abddjegdebcfebgcabfbfhbehcbgehbc(I):
  O = upscale(canvas(ZERO, shape(I)), 5)
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      O = paint(O, recolor(3, {(i, j) for i in range(height(obj)) for j in range(width(obj))}))
  return O
 
0.043333333333333335, 29.216093, def hfcfgbaacjcbeadcbadchgefidaaffdf(I):
  O = canvas(ZERO, multiply(shape(I), 5))
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      corner = (height(O) - height(obj), 0)
      O = paint(O, recolor(3, shift(backdrop({ulcorner(obj)}), corner)))
  return O
 
0.04296296296296296, 38.098095, def cijbacegidefeifaifdbadbahifacede(I):
  h, w = shape(I)
  O = canvas(0, (h * 5, w * (5 if h > w else 3)))
  for i in range(h):
    for j in range(w):
      if I[i][j] == 2:
        if h > w:
          O = fill(O, 3, {(i*5 + 3, j*5 + 4), (i*5 + 4, j*5 + 4)})
        else:
          O = fill(O, 3, {(i*5, j*3 + 1), (i*5, j*3 + 2), (i*5, j*3 + 3)})
  return O
 
0.07518518518518519, 47.660004, def edjeecdeebaaebfbijfifddjhccjdfad(I):
  O = upscale(I, 5 if portrait(I) else 3)
  if any(2 in row for row in I):
    obj = next(obj for obj in partition(I) if color(obj) == 2)
    if portrait(I):
      O = paint(O, recolor(3, shift(toindices(obj), (3, 4))))
      O = paint(O, recolor(3, shift(toindices(obj), (4, 4))))
    else:
      O = paint(O, recolor(3, shift(toindices(obj), (0, 1))))
      O = paint(O, recolor(3, shift(toindices(obj), (0, 2))))
      O = paint(O, recolor(3, shift(toindices(obj), (0, 3))))
  return O
 
0.032962962962962965, 49.364407, def ebfdfcegbfajeechbeedijcidedbabje(I):
  O = upscale(replace(I, 2, 0), 5 if portrait(I) else 3)
  if any(2 in row for row in I):
    for i, row in enumerate(I):
      for j, val in enumerate(row):
        if val == 2:
          if portrait(I):
            O = fill(O, 3, {(i*5 + 3, j*5 + 4), (i*5 + 4, j*5 + 4)})
          else:
            O = fill(O, 3, {(i*5, j*3 + 1), (i*5, j*3 + 2), (i*5, j*3 + 3)})
  return O
 
0.06037037037037037, 16.316761, def daacdbcceicbeddfjhbabdbbcaiedica(I):
  # Create a canvas of zeros with width as maximum of 10 and height as maximum of 10 or input height + 4
  O = canvas(ZERO, (max(len(I), 10), max(len(I[0]), 10))) 
  # Get the indices of the digit '2' in the input
  twos = ofcolor(I, TWO)
  # If there are '2's in the input
  if twos:
    # Determine the starting column for the line of '3's
    start_j = max(j for i, j in twos) + 1
    # Determine the ending column for the line of '3's
    end_j = len(O[0]) if len(I[0]) > 2 else start_j + 2
    # Create the line of '3's as a set of indices
    line = {(uppermost(twos) + 2, j) for j in range(start_j, end_j)}
    # Paint the line of '3's onto the canvas
    O = paint(O, recolor(THREE, line))
  else:
    # If there are no '2's, draw two vertical lines of '3's centrally
    center_j = len(O[0]) // 2
    O = paint(O, recolor(THREE, {(4, center_j - 1), (5, center_j - 1)}))
    O = paint(O, recolor(THREE, {(4, center_j), (5, center_j)}))
  return O
 
0.06222222222222223, 14.002392, def baacdbbgdebfeebcbejbddccaibcheha(I):
  # Determine the output grid size
  height_O = max(len(I) + 4, 10)
  width_O = max(len(I[0]), 10)
  # Create the output canvas
  O = canvas(ZERO, (height_O, width_O))
  # Find '2's in the input
  twos = ofcolor(I, TWO) 
  # If '2's exist, draw a horizontal line based on their position
  if twos:
    start_j = rightmost(twos) + 1
    line_width = width_O if width(I) > 2 else 3
    O = fill(O, THREE, {(uppermost(twos) + 2, j) for j in range(start_j, start_j + line_width)})
  # If no '2's, draw central vertical lines
  else:
    O = fill(O, THREE, {(4, width_O // 2 - 1), (5, width_O // 2 - 1), (4, width_O // 2), (5, width_O // 2)})
  return O
 
0.07074074074074076, 32.84505, def hjejggfhdehiegfhacbgbifhcgjiaibb(I):
  factor = 3 if 2 in merge(I) else 5
  O = upscale(I, factor)
  if 2 in merge(I):
    obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
    O = fill(O, 3, {(len(O) - 1, j) for j in range(len(O[0]) - width(obj), len(O[0]))}) 
  else:
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)})
  return O
 
0.03814814814814815, 38.923557, def jgggdfjcciedeibeigbabeccfiiecbef(I):
  O = canvas(0, multiply(shape(I), 3 if 2 in merge(I) else 5))
  if 2 in merge(I):
    obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
    for j in range(width(obj)):
      O = fill(O, 3, {(len(O) - 1, len(O[0]) - j - 1)})
  else:
    for i in range(len(O) // 2 - 1, len(O) // 2 + 2):
      O = fill(O, 3, {(i, len(O[0]) // 2)})
  return O
 
0.06259259259259259, 16.821869, def deegaebbbaabejaaiecddfdcbabcabdb(I):
  O = canvas(ZERO, multiply(shape(I), 5))  # Create upscaled canvas
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      factor = 2 if height(I) == 2 else 3  # Determine upscaling factor
      offset = (height(I) + 5, 0) if factor == 2 else (height(I) + 11, 0) # Determine downward shift
      upscaled_obj = upscale(obj, factor)  # Upscale the object
      O = paint(O, shift(upscaled_obj, offset))  # Paint the shifted object
  return O
 
0.07222222222222223, 14.469561, def cbcdhfhbdcededehbbachahjbdebbhfb(I):
  O = upscale(canvas(ZERO, shape(I)), 5) # Create upscaled canvas
  for obj in filter(lambda o: color(o) == 2, objects(I, True, False, True)):
    f = 3 - (height(I) % 2)  # Calculate upscaling factor
    O = paint(O, shift(upscale(obj, f), (height(O) - f * height(obj), 0))) # Upscale, shift, and paint
  return O
 
0.05296296296296296, 23.842098, def ebiaiecjbffaeccejcbaefdaghcfagdc(I):
  O = upscale(canvas(ZERO, shape(I)), 5)  # Create upscaled canvas
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      f = 2 + (len(I) > 2)  # Calculate upscaling factor
      O = paint(O, shift(upscale(obj, f), (height(O) - height(upscale(obj, f)), 0)))  # Upscale, shift, and paint
  return O
 
0.042222222222222223, 45.11122, def eecbbfdeadcjeaehjcfffbafhacabfbf(I):
  O = canvas(ZERO, (max(6, len(I) + 4), max(3, len(I[0]) * 3)))
  if len(ofcolor(I, 2)) > 0:
    j = rightmost(ofcolor(I, 2)) + 1
    O = fill(O, THREE, {(2 + len(I), j), (2 + len(I), j + 1), (2 + len(I), j + 2)})
  else:
    O = fill(O, THREE, {(4, 4), (5, 4), (4, 5), (5, 5)}) 
  return O
 
0.06222222222222223, 17.82097, def deebghabaeggedabjhebfbifjacdhced(I):
  output_height = max(len(I) + 4, 10)
  output_width = max(len(I[0]) * 3, 10)
  O = canvas(0, (output_height, output_width))
  twos = ofcolor(I, 2)
  if twos:
    target_row = len(I) + 2 
    target_col = rightmost(twos) + 1
    for i in range(3):
      O = fill(O, 3, {(target_row, target_col + i)})
  else:
    middle_col = output_width // 2 - 1
    O = fill(O, 3, {(4, middle_col), (5, middle_col), (4, middle_col + 1), (5, middle_col + 1)})
  return O
 
0.14055555555555557, 11.833845, def cbfhajfbbfcbeefhbgedchfcibhedfge(I):
  # Upscale based on object presence
  s = 5 if 2 in merge(I) else 10
  O = upscale(I, s) 
  # Object detection
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset()
  
  if obj:
    # Position the 3x3 square based on input object
    h, w = shape(obj)
    offset = ((len(O) - 3 * h) // 2, (len(O[0]) - 3 * w) // 2) 
    O = fill(O, 3, {(a + offset[0], b + offset[1]) for a in range(3 * h) for b in range(3 * w) if (a // h, b // w) == (1, 1)})
  else:
    # Draw two '3's at the center
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)}) 
  return O
 
0.15481481481481482, 12.926554, def bbeecdgdcbbgeiceigbcdeffhfbcfeae(I):
  # Upscale by 5
  O = upscale(I, 5)
  # Object detection and position calculation
  objs = objects(I, T, F, T)
  if objs:
    obj = first(objs)
    i, j = ulcorner(obj)
    # Fill based on object position
    if i == 0 and j == 1:
        O = fill(O, 3, {(a + 2, b + 7) for a in range(3) for b in range(3)})
    else:
        O = fill(O, 3, {(len(O) - 3 + a, len(O[0]) - 6 + b) for a in range(3) for b in range(3)})
  else:
    # Draw two '3's at the center
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)})
  return O
 
0.05574074074074074, 30.865051, def behbdaacfhabeiafjdafjjfadcbfbbed(I):
  # Upscaling factor based on object presence
  factor = 3 if any(v != 0 for row in I for v in row) else 10
  O = upscale(I, factor)
  # Object detection and size calculation
  obj = first(objects(O, T, F, T)) if objects(O, T, F, T) else frozenset()
  obj_size = len(obj)
  # Conditional Filling
  if obj_size == 2:
    O = fill(O, 3, {(len(O) - 3 + a, len(O[0]) - 6 + b) for a in range(3) for b in range(3)})
    O = fill(O, 3, {(2, len(O[0]) // 2)})
  elif obj_size == 0:
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)})
  else: 
    O = fill(O, 3, {(a + 2, b + 14) for a in range(3) for b in range(3)})
  return O
 
0.1298034769463341, 14.344711, def hefbbehdcajcegffjegehbgafgfefcde(I):
  # Determine scale factor based on input
  s = 15 if 2 in merge(I) else 10 
  O = upscale(I, s // len(I))
  # Object Detection
  obj = first(objects(I, T, F, T)) if objects(I, T, F, T) else frozenset() 
  
  if obj:
    # Calculate offset based on object presence and position
    offset = (2, 14) if s == 15 else ((len(O) - 3) // 2, (len(O[0]) - 3) // 2)
    if s != 15:
        O = fill(O, 3, {(2, len(O[0]) // 2)})
    O = fill(O, 3, {(a + offset[0], b + offset[1]) for a in range(3) for b in range(3)}) 
  else:
    # Draw two '3's at the center
    O = fill(O, 3, {(len(O) // 2 + i, len(O[0]) // 2) for i in range(-1, 2)})
  return O
 
0.008703703703703705, 19.693697, def afhaedbjdajaeiaajfecfidagbheaaai(I):
    # Detect object presence
    is_object = any(v != 0 for row in I for v in row)
    # Conditional upscaling 
    O = upscale(I, 15) if is_object else upscale(I, 10)
    # Calculate offset based on object presence
    offset_i = 2 if is_object else len(O) // 2 - 1
    offset_j = 14 if is_object else len(O[0]) // 2
    # Conditional filling based on object presence
    if is_object:
        O = fill(O, 3, {(a + offset_i, b + offset_j) for a in range(3) for b in range(3)})
    else:
        O = fill(O, 3, {(offset_i + i, offset_j) for i in range(2)})
    return O
 
0.048148148148148155, 27.310747, def jabgdcdecdfdeaefiabeiacjgdaicabh(I):
  objs = objects(I, True, False, True)
  O = canvas(0, (height(I) * 5, width(I) * (5 if len(objs) <= 1 else 15)))
  for i, obj in enumerate(objs):
    if color(obj) == 2:
      new_obj = recolor(3, {(i, j) for i in range(height(obj)*(1 if len(objs) <= 1 else 3)) for j in range(width(obj)*(1 if len(objs) <= 1 else 3))})
      O = paint(O, shift(new_obj, ((height(O)-height(new_obj))//(1+(len(objs)>1)), (width(O)-width(new_obj))//2)))
  return O
 
0.004814814814814814, 75.486275, def cfccicihefebejhfbbddjbfeeidfdbca(I):
    factor = 5 if colorcount(I, 2) <= 1 else 15
    O = canvas(0, (height(I) * (factor // 3), width(I) * factor)) 
    for obj in objects(I, True, False, True):
        if color(obj) == 2:
            O = paint(O, recolor(3, upscale(obj, 3 if factor == 15 else 1)))
    return O
 
0.048148148148148155, 25.210423, def daabgacbaccbefeeigcbhbejbbhfdidb(I):
  objs = objects(I, True, False, True)
  O = canvas(0, (10 if len(objs) <= 1 else 20, 15 if len(objs) > 1 else 10))
  for i, obj in enumerate(objs):
    if color(obj) == 2:
      O = paint(O, recolor(3, upscale(obj, 3 if len(objs) > 1 else 1)))
  return O
 
0.048148148148148155, 25.983047, def jfbaadfeecfbecdabbdeidfefbefciei(I):
    size_factor = 3 if colorcount(I, 2) > 1 else 1
    O = canvas(0, (height(I) * 5 * size_factor, width(I) * 5))
    for obj in objects(I, True, False, True):
        if color(obj) == 2:
            shifted_obj = shift(upscale(recolor(3, obj), size_factor), ((height(O) - height(obj) * size_factor) // 2, (width(O) - width(obj) * size_factor) // 2))
            O = paint(O, shifted_obj) 
    return O
 
0.18703703703703703, 10.236132, def cadehccfgbbfebejbdeaaachchjadfff(I):
  h, w = shape(I)
  factor = (5, 3) if h > w else (5, 5)
  O = canvas(0, (h * factor[0], w * factor[1]))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      O = fill(O, val, {(i * factor[0] + k, j * factor[1] + l) for k in range(factor[0]) for l in range(factor[1])})
      if val == 2:
        if h > w:
          O = fill(O, 3, {(h * factor[0] - 2 + k, w * factor[1] - 2 + l) for k in range(2) for l in range(2)})
        else:
          O = fill(O, 3, {(k, w * factor[1] - 3 + l) for k in range(3) for l in range(3)})
  return O
 
0.038518518518518514, 15.444965, def cjdgfbggacheejeeibbhaddhgaaefhcb(I):
  output_height = max(len(I) * 5, 10)  # Upscale height 5 times or minimum 10
  output_width = max(len(I[0]) * 3, 15) # Upscale width 3 times or minimum 15
  O = canvas(0, (output_height, output_width))
  twos = ofcolor(I, 2)
  if twos:
    shift_amount = rightmost(twos) * 3 # Shift based on rightmost '2'
  else:
    shift_amount = output_width // 2 - 1 # Center if no '2'
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        O = fill(O, 3, {(i * 5 + k, j * 3 + shift_amount) for k in range(5)})
  return O
 
0.03333333333333333, 29.530327, def eececjbihjcieddcabjcijebgiacbceb(I):
  objs = objects(I, False, False, False) # Get all objects from the input
  O = canvas(0, (max(len(I) * 5, 10), max(len(I[0]) * 3, 15))) # Create output canvas
  for obj in objs:
    if color(obj) == 2:
      if ofcolor(I, 2):
        offset = (0, 3 * rightmost(toindices(obj)) - width(O) // 2 + 1) # Calculate shift
      else:
        offset = (0, 0) # No shift if no '2'
      O = paint(O, recolor(3, shift(upscale(obj, 5), offset))) # Paint upscaled and shifted object
  return O
 
0.054814814814814816, 9.840405, def bdhfffeeahadehbbaecdddiefedjigci(I):
  O = canvas(ZERO, multiply(shape(I), (FIVE, FIVE)))
  O = fill(O, THREE, {(TWO,SEVEN)}) 
  if index(I, (ONE,ONE)) == TWO:
    O = fill(O, THREE, {(i, j) for i in range(SIX,NINE) for j in range(FIVE,EIGHT)})
  return O
 
0.09481481481481481, 11.740418, def ccebdffibgdbejggjjahjffeibdfbeec(I):
  s = shape(I)
  O = canvas(ZERO, multiply(s, (FIVE, FIVE)))
  O = fill(O, THREE, {(TWO, s[1]*FIVE - THREE)})
  if index(I, (ONE,ONE)) == TWO:
    O = fill(O, THREE, {(i, j) for i in range(s[0]*FIVE-THREE, s[0]*FIVE) for j in range(s[1]*FIVE-THREE, s[1]*FIVE)})
  return O
 
0.13185185185185186, 9.604088, def gjhagbcabfjaedabijccicdaechicjba(I):
  O = vupscale(hupscale(I, FIVE), FIVE)
  O = replace(O, TWO, THREE)
  O = fill(O, THREE, {(TWO,SEVEN)})
  return O
 
0.05148148148148148, 10.070941, def chcbcdcidhbfeajejaagiabcdeifjbcg(I):
  obj = objects(I, T, F, T)
  O = canvas(ZERO, (TEN, TEN)) if len(obj) == 0 else canvas(ZERO, (THREE * FIVE, THREE * FIVE))
  O = fill(O, THREE, {(TWO, SEVEN)})
  if obj:
    i, j = first(first(obj))[ONE]
    O = fill(O, THREE, {(r + i * FIVE, c + j * FIVE) for r in range(THREE) for c in range(THREE)})
  return O
 
0.11962962962962963, 8.4680195, def edbfjcchcjejeggbjcebdcjddeceeibf(I):
  O = canvas(ZERO, (height(I) * 5, width(I) * 5)) # Initialize a 5x upscaled canvas
  for obj in objects(I, True, False, True):
    upscale_factor = color(obj) * 2 + 1 # Determine upscaling factor based on color
    new_obj = upscale(recolor(THREE, obj), upscale_factor) # Upscale and recolor the object
    O = paint(O, shift(new_obj, (height(O) - height(new_obj), 0))) # Position the upscaled object at the bottom
  return O
 
0.1237037037037037, 29.154697, def fdebfiafdbdeebbbbcbihbgajcaicjee(I):
  O = I
  for v in palette(I) - {0}:
    O = paint(upscale(replace(O, v, 0), v * 2 + 1), upscale(recolor(3, {(i, j) for i, r in enumerate(I) for j, c in enumerate(r) if c == v}), v * 2 + 1))
  return O
 
0.15703703703703706, 13.753937, def decejbfiagaheccabecbaieefcbfbdji(I):
  factor = (5, 3) if portrait(I) else (5, 5)
  O = canvas(0, multiply(shape(I), factor))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      O = fill(O, val, {(i * factor[0] + k, j * factor[1] + l) for k in range(factor[0]) for l in range(factor[1])})
      if val == 2:
        ti, tj = (i, j) if portrait(I) else (i, j)  
        O = fill(O, 3, {(ti * factor[0] + k, tj * factor[1] - 2 + l) for k in range(3) for l in range(3)}) if portrait(I) else \
                      fill(O, 3, {(ti * factor[0] + k - 1, tj * factor[1] - 2 + l) for k in range(2) for l in range(2)})
  return O
 
0.09666666666666666, 15.148426, def geffbdfeicfgeaicbbghacdacbbhbdff(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  if objs:
    obj = argmax(objs, size)  # Pick the largest object
    factor = (FIVE, FIVE) if len(obj) == 1 else (FIVE, THREE)
    O = canvas(0, multiply(shape(I), factor))
    i, j = centerofmass(obj)
    offset = (i * factor[0] + TWO, (j * factor[1] + TWO) + FIVE * (j % 2) * (len(O[0]) // FIVE - 1))
    if len(obj) == 1:
      square = canvas(3, (THREE, THREE))
      O = paint(O, shift(asobject(square), offset))
    else:
      O = fill(O, 3, backdrop(crop(O, (offset[0], offset[1] - ONE), (THREE, ONE))))
  else:
    O = canvas(0, (TEN, TEN))
    O = fill(O, 3, vfrontier((TWO, FIVE)))
    O = fill(O, 3, vfrontier((TWO, EIGHT)))
  return O
 
0.01888888888888889, 14.804927, def baaicabbfbdjejbijdadceiaidfbcdfc(I):
  O = canvas(0, (10, max(width(I) * 15, 10))) # Create a canvas, width depends on input
  for j in range(width(I)):
    if I[1][j] == 2:  # Check for '2' in the second row of the input
      O = paint(O, recolor(3, {(2, j * 3), (3, j * 3), (4, j * 3)}))  # Paint '3's based on '2' position
  if not ofcolor(I, 2):  # If no '2' in the input
    O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)}))  # Paint '3's in the middle
  return O
 
0.04111111111111111, 11.546383, def fcifcegadddjebfcjdjcecbeedcihgeg(I):
  O = canvas(0, (10, 15 if any(2 in row for row in I) else 10))  # Canvas width based on presence of '2'
  if any(2 in row for row in I):  # Check if '2' exists in any row
    j = max(j for i in range(len(I)) for j in range(len(I[0])) if I[i][j] == 2)  # Find rightmost '2' column
    O = paint(O, recolor(3, {(2, j * 3), (3, j * 3), (4, j * 3)}))  # Paint '3's based on rightmost '2'
  else: 
    O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)}))  # Paint '3's in the middle
  return O
 
0.05814814814814815, 14.68574, def dgchddhgjfebefaejgdgabecdifefccd(I):
    objs = objects(I, False, False, False)
    O = canvas(0, (10, max(15 * any(color(obj) == 2 for obj in objs), 10)))  # Set width based on '2' presence
    for obj in objs:
        if color(obj) == 2:
            O = paint(O, recolor(3, upscale(obj, 5)))
            O = shift(O, (0, 3 * rightmost(toindices(obj)) - width(O) // 2 + 1))  # Align based on rightmost '2'
    if not any(color(obj) == 2 for obj in objs):  # If no '2' found
        O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)}))  # Default '3' placement
    return O
 
0.07222222222222223, 53.20214, def beacagfdbifgefifjffafcceachjbdca(I):
  # Check for '2' and determine scale
  has_two = 2 in merge(I)
  scale = 3 if has_two else 2
  # Upscale grid
  O = upscale(I, scale) 
  # Calculate center coordinates
  ci, cj = len(O) // 2 - 1, len(O[0]) // 2 - 1
  # Draw '3' based on '2' presence
  if has_two:
    # '2' exists: Larger '3' with offset
    O = fill(O, 3, {(ci + i, cj + j + 3) for i in range(3) for j in range(3)})
  else:
    # No '2': Smaller '3' at center
    O = fill(O, 3, {(ci + i, cj + j) for i in range(2) for j in range(2)})
  return O
 
0.1074074074074074, 8.270667, def eeffbcegdiffedbajdfecadafedaefhj(I):
  objs = objects(I, True, False, True) # Extract objects from input, excluding background
  O = canvas(ZERO, (15, width(I) * 5)) # Create output canvas with appropriate width
  offset = 0 # Initialize vertical offset for object placement
  for obj in sorted(objs, key=lambda obj: color(obj)): # Iterate through objects, sorted by color
    upscaled_obj = upscale(recolor(THREE, obj), 2 * color(obj) + 1) # Upscale and recolor object
    O = underpaint(O, shift(upscaled_obj, (offset, leftmost(obj) * 5))) # Place object with offset
    offset += height(upscaled_obj) # Update offset for next object
  return O
 
0.08074074074074074, 7.8510265, def fdedbacfbdfbeaabbjhfjbcbjjdddijc(I):
  O = canvas(ZERO, (15, width(I) * 5))
  for v in sorted(palette(I) - {0}):  # Iterate through colors, excluding background
    obj = extract(objects(I, True, False, True), lambda obj: color(obj) == v) # Extract object of specific color
    upscaled_obj = upscale(recolor(THREE, obj), 2 * v + 1) # Upscale and recolor object
    O = underpaint(O, shift(upscaled_obj, (v * 3, leftmost(obj) * 5))) # Place object with color-based offset
  return O
 
0.09407407407407409, 8.935706, def eaefdeafjecgebfcaijdbcgdbehccdbj(I):
  O = canvas(ZERO, (15, width(I) * 5))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0: # Ignore background cells
        obj = extract(objects(I, True, False, True), lambda obj: (i, j) in toindices(obj)) # Extract object containing current cell
        upscaled_obj = upscale(recolor(THREE, obj), 2 * v + 1) # Upscale and recolor
        O = underpaint(O, shift(upscaled_obj, (uppermost(obj) * 3, leftmost(obj) * 5))) # Position based on original object's location
  return O
 
0.043333333333333335, 32.77112, def agffgdabjicaefjdbggefbedejabcaic(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  factor = (FIVE, FIVE) if objs and len(first(objs)) == 1 else (FIVE, THREE)
  O = canvas(0, multiply(shape(I), factor))
  for obj in objs:
    i, j = centerofmass(obj)
    offset = (i * factor[0] + TWO, j * factor[1] + TWO + FIVE * (j % 2) * ((len(O[0]) // FIVE) - 1))
    if len(obj) == 1:
      for di in range(THREE):
        for dj in range(THREE):
          O = fill(O, THREE, {(offset[0] + di, offset[1] + dj)})
    else:
      O = fill(O, THREE, connect((offset[0], offset[1] - ONE), (offset[0] + TWO, offset[1] - ONE)))
  return O
 
0.06666666666666667, 12.514372, def affcdejcdeaaebefidbccadefadeeagb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  if objs:
    obj = first(objs)
    factor = (FIVE, FIVE) if len(obj) == 1 else (FIVE, THREE)
    O = canvas(0, multiply(shape(I), factor))
    i, j = centerofmass(obj)
    if len(obj) == 1:
      for di in range(-ONE, TWO):
        for dj in range(-ONE, TWO):
          O = fill(O, THREE, {(i * factor[0] + TWO + di, j * factor[1] + TWO + dj)})
    else:
      start = (i * factor[0] + ONE, j * factor[1] + ONE + FIVE * (j % 2) * ((len(O[0]) // FIVE) - 1))
      end = (start[0] + TWO, start[1])
      O = fill(O, THREE, connect(start, end))
  else:
    O = canvas(0, (TEN, TEN))
    O = fill(O, THREE, connect((TWO, FIVE), (THREE, FIVE)))
    O = fill(O, THREE, connect((TWO, EIGHT), (THREE, EIGHT)))
  return O
 
0.15037037037037038, 25.994446, def defbdideageieddfbdfcidiedadjcdbf(I):
  # Determine upscaling factor based on '2' presence
  factor = 5 if 2 in merge(I) else 5 // 2
  # Upscale the input grid
  O = upscale(I, factor)
  # Find the '2' object
  obj2 = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), frozenset())
  # Draw the '3' shape
  if obj2:
    # '2' present: Draw a 3x3 '3' shape relative to '2'
    i, j = ulcorner(obj2)
    O = fill(O, 3, {(i * factor + factor, j * factor + factor + k) for k in range(3) for l in range(3)})
  else:
    # '2' absent: Draw a 2x2 '3' shape at the center
    center_i, center_j = len(O) // 2, len(O[0]) // 2
    O = fill(O, 3, {(center_i - 1 + k, center_j - 1 + l) for k in range(2) for l in range(2)})
  return O
 
0.05000000000000001, 33.53715, def dedbfgfccdeieacebhfdceafbbbdcaad(I):
  # Determine upscaling factor based on '2' presence
  factor = 5 if 2 in merge(I) else 5 // 2
  # Create upscaled canvas
  O = canvas(0, multiply(shape(I), (factor, factor)))
  # Find '2' location
  loc2 = next(((i, j) for i, row in enumerate(I) for j, val in enumerate(row) if val == 2), (-1, -1))
  # Draw '3' shape based on '2' location
  if loc2 != (-1, -1):
    # '2' found: Draw large '3' around '2'
    O = fill(O, 3, {(loc2[0] * factor + i, loc2[1] * factor + j + factor) for i in range(3) for j in range(3)})
  else:
    # No '2': Draw small centered '3'
    center_i, center_j = len(O) // 2, len(O[0]) // 2
    O = fill(O, 3, {(center_i - 1 + i, center_j - 1 + j) for i in range(2) for j in range(2)})
  return O
 
0.07962962962962963, 47.671185, def bbadgghiiifjebehbbbdfbejcbcbcfda(I):
  objs = objects(I, True, False, True)
  target_objs = sfilter(objs, lambda obj: color(obj) == 2)  # Filter objects with color 2
  O = canvas(ZERO, (max([height(upscale(obj, 2 * color(obj) + 1)) for obj in target_objs] or [2]), width(I) * 5))  # Calculate height based on transformed objects or default to 2
  y = 0
  for obj in target_objs:
    upscaled_obj = upscale(recolor(THREE, obj), 2 * color(obj) + 1)
    O = underpaint(O, shift(upscaled_obj, (y, 0)))  # Place at the left (column 0)
    y += height(upscaled_obj)
  return O
 
0.08296296296296297, 47.60364, def jbjgijaceeefeadcifdejfceccificbc(I):
  objs = objects(I, True, False, True)
  target_obj = extract(objs, lambda obj: color(obj) == 2) if any(color(obj) == 2 for obj in objs) else None # Extract the object with color 2, if any
  if target_obj:
    upscaled_obj = upscale(recolor(THREE, target_obj), 2 * color(target_obj) + 1)
    O = canvas(ZERO, (height(upscaled_obj), width(I) * 5))
    O = underpaint(O, upscaled_obj)
  else:
    O = canvas(ZERO, (2, width(I) * 5))
    O = underpaint(O, recolor(THREE, {(1, width(O) // 2)}))
  return O
 
0.09518518518518519, 49.820744, def icjceeffchicedjjbcffjdfajdfgdecf(I):
  objs = objects(I, True, False, True)
  transformed_objs = [upscale(recolor(THREE, obj), 2 * color(obj) + 1) for obj in objs if color(obj) == 2]
  output_height = sum(height(obj) for obj in transformed_objs) if transformed_objs else 2
  O = canvas(ZERO, (output_height, width(I) * 5))
  y = 0
  for obj in transformed_objs:
    O = paint(O, shift(obj, (y, (width(O) - width(obj)) // 2))) # Center horizontally
    y += height(obj)
  return O
 
0.009629629629629629, 75.116936, def bdfcgdabgfcaefaijfcfjaaefecajfeg(I):
  O = canvas(ZERO, (2, width(I) * 5))  # Default canvas
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 2:
        O = underpaint(O, recolor(THREE, {(k, l * 5 + j * 5) for k in range(5) for l in range(5)}))
  return O
 
0.0862962962962963, 36.89527, def adadhceaedabefcaagbbfjiedcacgehc(I):
  objs = objects(I, True, False, True)
  max_height = max([height(obj) for obj in objs if color(obj) == 2] or [1]) * 5 # Calculate max height of relevant objects, default to 1
  O = canvas(ZERO, (max_height, width(I) * 5))
  for obj in objs:
    if color(obj) == 2:
      O = underpaint(O, upscale(recolor(THREE, obj), 5))
  return O
 
0.15814814814814815, 13.4023485, def idhfdicdggdeecjeadcjgdacggdhdbad(I):
  factor = (5, 3) if portrait(I) else (5, 5)
  O = canvas(0, multiply(shape(I), factor))
  for value, (i, j) in asobject(I):
    O = fill(O, value, {(i * factor[0] + k, j * factor[1] + l) for k in range(factor[0]) for l in range(factor[1])})
    if value == 2:
      corner_offset = (2, 2) if portrait(I) else (1, 1)
      block_start = subtract(multiply((i, j), factor), corner_offset)
      O = fill(O, 3, {(block_start[0] + k, block_start[1] + l) for k in range(3) for l in range(3)})
  return O
 
0.04148148148148148, 27.532177, def iccedfehcdbgeafcjchbccbiibiajaca(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  factor = (FIVE, FIVE) if objs and len(first(objs)) == 1 else (FIVE, THREE)
  O = canvas(0, multiply(shape(I), factor))
  if objs:
    obj = first(objs)
    i, j = centerofmass(obj)
    offset = (i * factor[0] + THREE, j * factor[1] + THREE)
    if len(obj) == 1:
      O = fill(O, THREE, backdrop(crop(O, offset, (THREE, TWO)))) 
    else:
      O = fill(O, THREE, backdrop(crop(O, offset, (THREE, THREE))))
  else:
    O = fill(O, THREE, connect((TWO, FIVE), (THREE, FIVE)))
    O = fill(O, THREE, connect((TWO, EIGHT), (THREE, EIGHT)))
  return O
 
0.05592592592592593, 18.384504, def egbffibbgfjbeegcbhecgfcgjdeggjhd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  factor = (FIVE, FIVE) if objs and size(first(objs)) == 1 else (FIVE, THREE)
  O = canvas(0, multiply(shape(I), factor))
  if objs:
    obj = first(objs)
    i, j = centerofmass(obj)
    if size(obj) == 1:
      O = fill(O, THREE, {(i * factor[0] + TWO, j * factor[1] + k) for k in range(THREE, FIVE)})
      O = fill(O, THREE, {(i * factor[0] + THREE, j * factor[1] + k) for k in range(THREE, FIVE)})
    else:
      O = fill(O, THREE, backdrop(crop(O, (i * factor[0] + THREE, j * factor[1] + THREE), (THREE, THREE))))
  else:
    O = fill(O, THREE, connect((TWO, FIVE), (THREE, FIVE)))
    O = fill(O, THREE, connect((TWO, EIGHT), (THREE, EIGHT)))
  return O
 
0.10259259259259261, 18.451563, def jhgahfdhgjfdefaabbfiafcddjicideh(I):
  has_two = bool(ofcolor(I, 2))  # Boolean flag for presence of '2'
  O = canvas(0, (10, 10 + has_two * 5))  # Conditional width based on flag
  if has_two:
    O = paint(O, recolor(3, shift(upscale(toobject(ofcolor(I, 2), I), 5), (0, 6))))  # Shift & paint
  else:
    O = paint(O, recolor(3, {(i, 5) for i in range(2, 5)}))  # Central line with range
  return O
 
0.06666666666666667, 32.761738, def feaffcchjdbcedgiijbeigjbfjcbiijf(I):
  factor = 5 if any(2 in row for row in I) else 2
  O = canvas(0, (len(I) * factor, len(I[0]) * factor))
  obj2 = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), None)
  if obj2:
    i, j = ulcorner(obj2)
    offset = (i * factor, (j + 1) * factor)
  else:
    offset = (len(O) // 2 - 1, len(O[0]) // 2 - 1)
  three_shape = recolor(3, {(i, j) for i in range(3) for j in range(3)})
  O = paint(O, shift(three_shape, offset))
  return O
 
0.048148148148148155, 27.386133, def acfdifceifeaececjdajdgagecfbefid(I):
  objs = objects(I, True, False, True)
  factor = 3 if len(objs) > 1 else 1
  O = canvas(0, (15 if len(objs) > 1 else 10, 20 if len(objs) > 1 else 10))
  for i, obj in enumerate(objs):
    if color(obj) == 2:
      scaled_obj = upscale(obj, factor)
      h_offset = (width(O) - width(scaled_obj)) // 2
      v_offset =  (height(O) - height(scaled_obj) - 1) if len(objs) <= 1 else 1
      O = paint(O, recolor(3, shift(scaled_obj, (v_offset, h_offset))))
  return O
 
0.07037037037037036, 14.070861, def idehgeefgfeaecffifbhdidagbfhcdic(I):
    factor_h, factor_w = (5, 3) if portrait(I) else (5, 5)
    h, w = len(I), len(I[0])
    O = canvas(0, (h * factor_h, w * factor_w))
    if 2 in palette(I):
        obj = extract(partition(I), lambda o: color(o) == 2)
        target_i, target_j = lrcorner(obj) if portrait(I) else urcorner(obj)
        block_start_i = target_i * factor_h - (2 if portrait(I) else 1)
        block_start_j = target_j * factor_w - (2 if portrait(I) else 1)
        for di in range(3):
            for dj in range(3):
                O = fill(O, 3, frozenset({(block_start_i + di, block_start_j + dj)}))
    return O
 
0.036666666666666674, 29.651903, def eigfajbbbhcdecdbihjcaieachcbafig(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  size_factor = (FIVE, FIVE) if objs and size(first(objs)) == ONE else (FIVE, THREE)
  O = canvas(ZERO, multiply(shape(I), size_factor))
  for obj in objs:
    center_i, center_j = centerofmass(obj)
    offset_i = center_i * size_factor[ZERO] + TWO
    offset_j = center_j * size_factor[ONE] + TWO + (FIVE * (center_j % TWO) * ((len(O[ZERO]) // FIVE) - ONE))
    if size(obj) == ONE:
      O = fill(O, THREE, connect((offset_i, offset_j), (offset_i, offset_j + ONE)))
      O = fill(O, THREE, connect((offset_i + ONE, offset_j), (offset_i + ONE, offset_j + ONE)))
    else:
      O = fill(O, THREE, backdrop(crop(O, (offset_i + ONE, offset_j + ONE), (THREE, THREE)))) 
  if not objs:
    O = fill(O, THREE, connect((TWO, FIVE), (THREE, FIVE)))
    O = fill(O, THREE, connect((TWO, EIGHT), (THREE, EIGHT))) 
  return O 
 
0.06037037037037037, 11.657803, def iiddbjejbgbfehafiafhfefdaefcedcf(I):
  is_single_object = len(objects(I, univalued=True, diagonal=False, without_bg=True)) == 1 and len(first(objects(I, univalued=True, diagonal=False, without_bg=True))) == 1
  O = canvas(0, (10, 10)) if is_single_object else canvas(0, (10, 15))
  if is_single_object:
    obj = first(objects(I, univalued=True, diagonal=False, without_bg=True))
    i, j = centerofmass(obj)
    O = fill(O, 3, {(2 + 5 * i, 3 + 5 * j), (2 + 5 * i, 4 + 5 * j), (3 + 5 * i, 3 + 5 * j), (3 + 5 * i, 4 + 5 * j)})
  else:
    objs = objects(I, univalued=True, diagonal=False, without_bg=True)
    if objs:
      obj = first(objs)
      i, j = centerofmass(obj)
      O = fill(O, 3, {(i * 5 + 3 + di, j * 3 + 3 + dj) for di in range(3) for dj in range(3)})
    else:
      O = fill(O, 3, {(2, 5), (3, 5), (2, 8), (3, 8)})
  return O
 
0.05740740740740741, 11.424225, def gbdbefciabfjeeiaighgajehbbfcbdae(I):
  obj_indices = ofcolor(I, 2)
  if obj_indices:
    O = canvas(0, (10, 15))
    obj = toobject(obj_indices, I)
    O = paint(O, recolor(3, upscale(obj, 5)))
    O = paint(O, recolor(0, {(i, j) for i in range(10) for j in range(rightmost(obj_indices) * 5)}))
  else:
    O = paint(canvas(0, (10, 10)), recolor(3, {(2, 4), (2, 5), (2, 6)}))
  return O
 
0.04148148148148148, 24.622307, def cgeecdaddbfbeeiiieacedehedhbafif(I):
  objs = objects(I, True, False, True)
  factor = 1 if len(objs) == 1 else 3
  O = canvas(0, (10, 10) if factor == 1 else (15, 15))
  for obj in objs:
    if color(obj) == 2:
      scaled_obj = upscale(obj, factor)
      O = paint(O, recolor(3, shift(scaled_obj, (2 if factor == 1 else 2, 2 if factor == 1 else 2))))
  return O
 
0.04518518518518519, 24.550121, def ahfcbahbfbehejaebihaabcbfhehbhef(I):
  obj = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), None)
  factor = 1 if not obj else (3 if len(objects(I, True, False, True)) > 1 else 1)
  O = canvas(0, (10, 10) if factor == 1 else (15, 15))
  if obj:
    O = paint(O, recolor(3, shift(upscale(obj, factor), (2, 2)))) 
  return O
 
0.06925925925925926, 7.702329, def edfaacabgabfecdaicidbeehidgiaibe(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  output_height = 10
  output_width = 10 if objs and len(first(objs)) == 1 else 15
  O = canvas(0, (output_height, output_width))
  if objs:
    obj = first(objs)
    i, j = centerofmass(obj)
    if len(obj) == 1:
      for dj in range(2):
        O = fill(O, 3, connect((2 + 5 * i + dj, 3 + 5 * j), (2 + 5 * i + dj, 4 + 5 * j)))
    else:
      for di in range(3):
        for dj in range(3):
          O = fill(O, 3, {(3 + 5 * i + di, 3 + 3 * j + dj)})
  else:
    for dj in range(2):
      O = fill(O, 3, connect((2 + dj, 5), (2 + dj, 8)))
  return O
 
0.06703703703703705, 9.895971, def digjfdiddhaeebabjfdfhhdadaccfddg(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, (10, 10) if objs and size(first(objs)) == 1 else (10, 15)) 
  if objs:
    obj = argmax(objs, size)
    i, j = centerofmass(obj)
    if size(obj) == 1:
      O = paint(O, shift(asobject(canvas(3, (1, 2))), (2 + 5 * i, 3 + 5 * j)))
      O = paint(O, shift(asobject(canvas(3, (1, 2))), (3 + 5 * i, 3 + 5 * j)))
    else:
      O = fill(O, 3, backdrop(crop(O, (3 + 5 * i, 3 + 3 * j), (3, 3))))
  else:
    O = paint(O, shift(asobject(canvas(3, (1, 3))), (2, 5)))
    O = paint(O, shift(asobject(canvas(3, (1, 3))), (2, 8)))
  return O
 
0.07592592592592591, 9.547718, def iffcafajfcbgefcjagbabhcdhaebcibd(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = canvas(0, (10,  15 if objs and len(first(objs)) != 1 else 10))
  if objs:
    obj = first(objs)
    i, j = centerofmass(obj)
    if len(obj) == 1:
      for x in range(2, 4):
          O = fill(O, 3, {(x + 5 * i, y + 5 * j) for y in range(3, 5)})
    else:
      O = fill(O, 3, {(x + 5 * i, y + 3 * j) for x in range(3, 6) for y in range(3, 6)})
  else:
    for x in range(2, 4):
      O = fill(O, 3, {(x, y) for y in range(5, 9)})
  return O
 
0.055, 7.2449856, def jafebgdjigccehcdabbcibfgbbcbbfdb(I):
  factor = 5 if any(2 in r for r in I) else 10
  O = canvas(0, (len(I) * factor, len(I[0]) * factor))
  if any(2 in r for r in I):
    obj2 = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), None)
    start_corner = multiply(ulcorner(toindices(obj2)), factor)
    square_indices = {(i, j) for i in range(start_corner[0], start_corner[0] + 3) for j in range(start_corner[1], start_corner[1] + 3)}
    O = fill(O, 3, square_indices)
  else:
    center_i, center_j = len(O) // 2, len(O[0]) // 2
    O = fill(O, 3, {(center_i, center_j - 1), (center_i, center_j)})
  return O
 
0.12537037037037038, 14.542616, def jbfbhaahaceaeaeibeegabegececbaef(I):
  s = 5 if any(2 in r for r in I) else 10
  O = upscale(I, s)
  if any(2 in r for r in I):
    obj2 = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), None)
    corner = ulcorner(toindices(obj2))
    O = fill(O, 3, {(corner[0] * s + i, corner[1] * s + j) for i in range(3) for j in range(3)})
  else:
    O = fill(O, 3, {(len(O) // 2, len(O[0]) // 2 - 1), (len(O) // 2, len(O[0]) // 2)})
  return O
 
0.17240740740740743, 10.046734, def dcejaidaeedcebdiidaeeegibegiacdb(I):
  factor = 5 if 2 in merge(I) else 10
  O = upscale(I, factor)
  if 2 in merge(I):
    obj2 = next((obj for obj in objects(I, True, False, True) if color(obj) == 2), None)
    offset_i, offset_j = multiply(ulcorner(toindices(obj2)), factor)
    for i in range(3):
      for j in range(3):
        O = fill(O, 3, {(offset_i - factor + i, offset_j - factor + j)})
  else:
    mid_i, mid_j = len(O) // 2, len(O[0]) // 2
    O = fill(O, 3, {(mid_i, mid_j - 1), (mid_i, mid_j)}) 
  return O
 
0.048148148148148155, 23.103268, def deffdehiedededebibideacdbhffcbaa(I):
  objs = objects(I, True, False, True)
  obj2 = extract(objs, lambda obj: color(obj) == 2) if any(color(obj) == 2 for obj in objs) else None
  O = canvas(0, (10, 10) if obj2 is not None else (10, 10)) 
  if obj2:
    factor = 3 if len(objs) > 1 else 1
    upscaled_obj = upscale(obj2, factor)
    O = paint(O, shift(upscaled_obj, (6, 5 - width(upscaled_obj) // 2)))
  else:
    O = paint(O, recolor(3, {(2, 4)}))
  return O
 
0.12259259259259259, 19.319368, def edhjhfgcffeeeebeacfgafidbdfbfecd(I):
  obj = toobject(ofcolor(I, 2), I) # Find the '2' object
  upscaled_obj = upscale(obj, 5) # Upscale the object
  O = canvas(0, (10 + 5 * height(obj), 10))  # Create canvas, expand height if '2' exists
  if obj: # If '2' exists
    O = paint(O, recolor(3, shift(upscaled_obj, (0, 5 - width(upscaled_obj) // 2)))) # Paint upscaled object, horizontally centered
  else: # If no '2'
    O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)})) # Paint the default object
  return O
 
0.10185185185185186, 20.850624, def ebifbfjffhidedaaaadaieadehhffbdg(I):
  O = canvas(0, (10 + 5 * (2 in merge(I)), 10)) # Conditional height in canvas creation
  target_position = (5, 5)  # Center position for objects
  if 2 in merge(I):
    obj = toobject(ofcolor(I, 2), I)
    upscaled_obj = recolor(3, upscale(obj, 5))
    O = paint(O, shift(upscaled_obj, subtract(target_position, centerofmass(upscaled_obj)))) # Place using center of mass
  else:
    O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)})) # Default object placement
  return O
 
0.04, 27.44641, def gcaacfdbafcceceabbfaadbbbbdicggf(I):
  objs = objects(I, True, False, True)
  obj2 = next((obj for obj in objs if color(obj) == 2), None) # Find '2' object
  O = canvas(0, (15 if obj2 and len(objs) > 1 else 10, 10)) # Canvas size logic
  if obj2:
    O = paint(O, shift(upscale(obj2, 3 if len(objs) > 1 else 1), (height(O) - height(obj2),  width(O) // 2 - width(obj2) // 2))) # Upscale, shift and paint
  else:
    O = paint(O, recolor(3, {(2,5)})) # Place '3' if no '2' object
  return O
 
0.15148148148148147, 23.104301, def hdigfbfadddgeacbadbafegffgheicfi(I):
  h, w = shape(I)
  factor = (5, 5) if 2 in palette(I) else (5, 2)
  O = canvas(0, (h * factor[0], w * factor[1]))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      O = fill(O, val, {(i * factor[0] + k, j * factor[1] + l) for k in range(factor[0]) for l in range(factor[1])})
  if 2 in palette(I):
    obj = extract(partition(I), matcher(color, 2))
    corner = lrcorner(obj) if portrait(I) else urcorner(obj)
    start_i = corner[0] * factor[0] - (2 if portrait(I) else 1)
    start_j = corner[1] * factor[1]  - (2 if portrait(I) else 1)
    O = fill(O, 3, {(start_i + i, start_j + j) for i in range(3) for j in range(3)})
  else:
    O = fill(O, 3, {(2 + i, 5 + j) for i in range(3) for j in range(3)})
  return O
 
0.06888888888888889, 9.494397, def cdchecedaffieiebiachddacahdebaja(I):
  O = canvas(0, (15, 10)) # Create a 15x10 canvas
  if ofcolor(I, 2): # Check if '2' exists in the input
    obj = toobject(ofcolor(I, 2), I) # Extract the '2' object
    upscaled_obj = upscale(obj, 3) # Upscale the object by 3
    O = paint(O, recolor(3, shift(upscaled_obj, (0, 7 - width(upscaled_obj) // 2)))) # Center and place at the top
  else:
    O = paint(O, recolor(3, {(2, 4), (2, 5), (2, 6)})) # Place the default object at the top center
  return O
 
0.06148148148148149, 9.884189, def dhbgegiefeciefedbjdhcfaficbdefcj(I):
  obj = toobject(ofcolor(I, 2), I) # Extract the '2' object
  h = 10 + 5 * height(obj) if obj else 10 # Adjust canvas height based on '2' object
  O = canvas(0, (15, h)) # Create canvas
  if obj:
    O = paint(O, recolor(3, shift(upscale(obj, 3), (0, (15 - width(upscale(obj, 3))) // 2)))) # Upscale, center, and paint
  else:
    O = paint(O, shift(recolor(3, {(2, 4), (2, 5), (2, 6)}), (0, 2))) # Place default object at the top center
  return O
 
0.07222222222222223, 8.985366, def fdcaadbjdhedefddjcbbcdaebhecedab(I):
  if colorcount(I, 2) > 0: # Check if color '2' exists
    obj = toobject(ofcolor(I, 2), I)
    O = paint(canvas(0, (15, max(10, 5 * height(obj)))), recolor(3, shift(upscale(obj, 3), (0, 7 - width(upscale(obj, 3)) // 2)))) 
  else:
    O = paint(canvas(0, (10, 10)), recolor(3, {(2, 4), (2, 5), (2, 6)}))
  return O
 
0.10333333333333333, 15.164538, def befeiceeebbdefcabdaijaicbabhbjfa(I):
  O = canvas(ZERO, multiply(shape(I), (FIVE, FIVE))) # Create scaled canvas
  for obj in objects(I, True, False, True): # Iterate over objects
    s = colorcount(obj, TWO) # Count '2's in object
    if s == ONE: # If single '2', create two rectangles
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (ONE, FOUR))))
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (SIX, FOUR))))
    else: # Else, create lines/squares
      O = paint(O, recolor(THREE, shift(upscale(obj, s), (THREE, FOUR))))
      O = paint(O, recolor(THREE, shift(upscale(obj, s), (FOUR, FOUR))))
  return O
 
0.10222222222222221, 14.435254, def gdjbjfcddigaefadbjfhaiaefjhaahaf(I):
  f = FIVE if len(I) == TWO else EIGHT # Factor for shifting
  O = canvas(ZERO, multiply(shape(I), (f, f))) # Scaled canvas
  for obj in objects(I, True, False, True):
    O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (ONE, FOUR)))) # Top object
    if colorcount(obj, TWO) == ONE: # Place bottom object if single '2'
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (f - TWO, FOUR))))
  return O
 
0.04814814814814814, 11.83536, def bdfehiajahjbeghbbeehibfgcdgfdhbf(I):
  has_two = any(2 in row for row in I)
  obj = next((o for o in objects(I, T, F, T) if color(o) == 2), frozenset())
  O = canvas(0, (15, 15)) if has_two else canvas(0, (10, 10))
  if has_two:
    O = fill(O, 3, shift(product(interval(3,6,1),interval(6,9,1)), (0, 3)))
  else:
    O = fill(O, 3, shift(toindices(obj), (2, 4)))
  return O
 
0.05703703703703703, 10.708067, def eagefbadggaaebbbjffdggfhbceaafgh(I):
    size = (15, 15) if 2 in set(I[i][j] for i in range(len(I)) for j in range(len(I[0]))) else (10, 10)
    grid = canvas(0, size)
    if size == (15, 15):
        grid = fill(grid, 3, {(i, j) for i in range(3, 6) for j in range(6, 9)})
    else:
        grid = fill(grid, 3, {(2, 4), (2, 5)})
    return grid
 
0.05296296296296296, 13.296209, def jgfggbeahdgaehbciabafbdjbababbfi(I):
  objs = objects(I, True, False, True)  # Extract objects
  scaled_objs = frozenset()
  for obj in objs:
    value = color(obj)  # Get object's digit value
    if value != 0: 
      height_factor = value 
      scaled_obj = upscale(obj, height_factor)  # Scale vertically
      scaled_obj = recolor(3, scaled_obj)  # Recolor to '3'
      scaled_objs = insert(scaled_obj, scaled_objs)
  O = paint(canvas(0, (10, 10)), merge(scaled_objs)) # Paint on a 10x10 canvas
  return O 
 
0.004814814814814814, 86.21282, def cbbbddfehdbjefjaaaddgdibdafbhfca(I):
  objs = partition(I)  # Partition the grid into objects
  scaled_objs = mapply(lambda obj: upscale(recolor(3, obj), color(obj)), sfilter(objs, lambda obj: color(obj) != 0)) 
  O = paint(canvas(0, shape(I) * 5), scaled_objs)  # Paint on a canvas 5 times larger
  return O
 
0.014444444444444446, 76.11193, def ahdgadgajjaaehchibhcebjfafecgfjg(I):
  scaled_grid = tuple(tuple(3 if I[i//3][j] != 0 else 0 for j in range(len(I[0]))) for i in range(len(I) * 3))
  O = crop(scaled_grid, (0, 0), (10, 10)) # Crop to 10x10
  return O
 
0.05296296296296296, 20.438938, def dbbahbdeaffiecebbbccfehcedechdef(I):
  objs = objects(I, True, False, True)
  O = canvas(0, (10, 10)) # Start with a 10x10 canvas
  for obj in objs:
    if color(obj) != 0:
      factor = color(obj)
      for i, j in toindices(obj):
        for k in range(factor):
          O = fill(O, 3, {(i*factor + k, j)})
  return O
 
0.37333333333333335, 13.315016, def djbeceajjjffeidebjbfeccaffbgdgcf(I):
    obj = next((obj for obj in objects(I, univalued=True, diagonal=False, without_bg=True) if len(obj) > 0), None)
    if obj is None:
        return canvas(0, (10, 10))
    w = width(obj)
    h = height(obj)
    factor = 5
    obj = upscale(obj, factor)
    O = canvas(0, (factor * h * 2, factor * w * 3))
    for i in range(2):
        for j in range(3):
            O = paint(O, shift(obj, (i * factor * h, j * factor * w)))
    return O
 
0.2911111111111111, 14.949198, def dgfccffgdbfieffejeedebadjafecbab(I):
  obj = next((obj for obj in objects(I, univalued=True, diagonal=False, without_bg=True)), frozenset())
  if len(obj) == 0:
    return canvas(0, (10, 10))
  factor = 5 if len(I) == 2 else 8
  O = canvas(0, (factor * 2 * height(obj), factor * 3 * width(obj)))
  for i in range(2):
    for j in range(3):
      O = underpaint(O, shift(upscale(obj, factor), (factor * i * height(obj), factor * j * width(obj))))
  return O
 
0.011644444444444445, 26.934052, def ieafehdajbfbecgcifaaabbehecdefjd(I):
  non_bg_objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  obj = next((obj for obj in non_bg_objs if len(obj) > 0), None)
  if obj is None:
    return canvas(0, (10, 10))
  factor = 5
  obj = upscale(obj, factor)
  O = canvas(0, (factor * height(obj) * 2, factor * width(obj) * 3))
  for i in range(2):
    for j in range(3):
      offset = (i * factor * height(obj), j * factor * width(obj))
      O = paint(O, shift(obj, offset))
  return O
 
0.06925925925925926, 16.524187, def dcdfbajjfeabedbejehcibgcdaccfgda(I):
  if 2 in merge(I):
    for i, row in enumerate(I):
      for j, val in enumerate(row):
        if val == 2:
          O = canvas(0, (TEN, TEN))
          return fill(O, 3, product(interval(i + 7, i + 10, ONE), interval(j + 7, j + 10, ONE)))
  else:
    O = canvas(0, (TEN, TEN))
    return fill(O, 3, product(interval(THREE, FIVE, ONE), interval(FOUR, FIVE, ONE)))
 
0.09333333333333334, 11.115881, def afacccgffjaaeffebficbjddgadfbedd(I):
  O = canvas(0, (TEN, TEN))
  if 2 in I[ONE]:
    O = canvas(0, (TEN, TEN))
    return fill(O, 3, product(interval(SEVEN, TEN, ONE), interval(SEVEN, TEN, ONE)))
  elif 2 in I[ZERO]:
    O = canvas(0, (FIFTEEN, FIFTEEN))
    return fill(O, 3, product(interval(TWO, FIVE, ONE), interval(TWO, FIVE, ONE)))
  else:
    O = canvas(0, (TEN, TEN))
    return fill(O, 3, product(interval(THREE, FIVE, ONE), interval(FOUR, FIVE, ONE)))
 
0.04148148148148148, 10.273767, def gefhegdedcggecbebdddeaibgadhbaaa(I):
  has_two = 2 in {c for row in I for c in row}
  dims = (15, 15) if has_two else (10, 10)
  O = canvas(0, dims)
  if has_two:
    O = fill(O, 3, {(i, j) for i in range(3, 6) for j in range((dims[1] - 3) // 2 + 3, (dims[1] - 3) // 2 + 6)})
  else:
    O = fill(O, 3, {(2, 5), (3, 5)})
  return O
 
0.0637037037037037, 10.5480385, def dbcefhccjaaceeabicfiffjbfefbjhfa(I):
  has_two = any(2 == v for r in I for v in r)
  canvas_size = (15, 15) if has_two else (10, 10)
  output = canvas(0, canvas_size)
  if has_two:
    output = fill(output, 3, shift(product(range(3), range(3)), (3, (canvas_size[1] // 2) - 1)))
  else:
    output = fill(output, 3, {(2, canvas_size[1] // 2 - 1), (3, canvas_size[1] // 2 - 1)})
  return output
 
0.023750000000000004, 20.65517, def ebcifdgddideejagbbccjcbfbfffagee(I):
  obj = next((obj for obj in objects(I, univalued=True, diagonal=False, without_bg=True) if len(obj) > 0), None)
  if obj is None:
    return canvas(0, (10, 10))
  factor = (5, 5) if len(I) == 2 else (3, 5)
  if len(I) == 2:
    O = tuple(tuple(3 if (i in range(5, 10) or i in range(15, 20)) and (j in range(10, 15) or j in range(20, 25) or j in range(30, 35)) else 0 for j in range(40)) for i in range(20))
  else:
    O = canvas(0, (15, 20))
    O = paint(O, shift(upscale(obj, factor), (2, 0)))
  return O
 
0.04, 8.44494, def dffabhjfdcgcedffjjdabjigbfdbgjea(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == TWO else canvas(0, (s + 13, s + 13))
  if 2 in merge(I):
    x1 = objects(I, T, F, T)
    x2 = sizefilter(x1, ONE)
    x3 = toindices(first(x2))
    offset = (FIVE, FOUR) if s == TWO else (ONE, ONE)
    O = fill(O, 3, shift(product(interval(0, THREE, ONE), interval(0, THREE, ONE)), add(offset, first(x3))))
  else:
    O = fill(O, 3, product(interval(2, FOUR, ONE), interval(FIVE, SIX, ONE)))
  return O 
 
0.05592592592592593, 15.828559, def dghaijcbdjeeehecjddafcbcceadbccg(I):
  s = maximum(shape(I))
  O = canvas(0, (s + 8, s + 8)) if s == TWO else canvas(0, (s + 13, s + 13))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        offset = (SEVEN, SEVEN) if s == TWO else (TWO, TWO)
        O = fill(O, 3, product(interval(i + offset[0], i + offset[0] + THREE, ONE), interval(j + offset[1], j + offset[1] + THREE, ONE)))
        return O
  return fill(O, 3, product(interval(TWO, FOUR, ONE), interval(FIVE, SIX, ONE)))
 
0.0462962962962963, 24.420038, def djbejefjceefeegcicbacdbdgicajjjj(I):
  O = canvas(ZERO, (TEN, TEN)) if len(I) == TWO else canvas(ZERO, (15, 15)) # Canvas size
  for obj in objects(I, True, False, True):
    top_pos = (TWO, FOUR) 
    bottom_pos = (SEVEN, FOUR)
    O = paint(O, recolor(THREE, shift(obj, top_pos))) # Top object
    if square(obj):
      O = paint(O, recolor(THREE, shift(obj, bottom_pos))) # Bottom object if square
  return O
 
0.054814814814814816, 9.890246, def efecjedcaeagegfibibighfbgagbajgd(I):
  has_two = any(2 in r for r in I)  # Check for '2' in input
  dims = (15, 15) if has_two else (10, 10)  # Set canvas size
  O = canvas(0, dims)  # Create empty canvas
  if has_two:
    O = fill(O, 3, shift(product(range(3), range(3)), (dims[0]-6, (dims[1]-3)//2)))  # Draw 3x3 square
  else:
    O = fill(O, 3, shift({(0, 0), (1, 0)}, (2, (dims[1]-1)//2)))  # Draw two vertical '3's
  return O
 
0.054814814814814816, 9.69201, def cfaagcfdfdceeecaiedaibjdabijebef(I):
  has_two = any(v == 2 for r in I for v in r)  # Check for '2'
  size = (15, 15) if has_two else (10, 10)  # Canvas size
  O = canvas(0, size)
  if has_two:
    O = fill(O, 3, shift(product(range(3), range(3)), (size[0] - 6, size[1] // 2 - 2)))
  else:
    O = fill(O, 3, {(2, size[1] // 2 - 1), (3, size[1] // 2 - 1)})
  return O
 
0.04407407407407407, 10.949109, def dcegfajceabbejbcjfdedbdeagdabaac(I):
  objs = objects(I, True, False, True)  # Extract non-background objects
  O = canvas(0, (10, 10))  # Start with a 10x10 canvas
  for obj in objs:
    factor = color(obj)
    if factor != 0:
      for i, j in toindices(obj):
        for k in range(factor):
          for l in range(factor):
            O = fill(O, 3, {(i * factor + k, j * factor + l)})  # Fill in a square of size 'factor'
  return O
 
0.022222222222222223, 13.011404, def afbgjifeeffdefcbjffafdebcahgijaj(I):
  def process_cell(i, j, val):
    if val == 0:
      return frozenset()
    return recolor(3, frozenset({(i * val + k, j * val + l) for k in range(val) for l in range(val)}))  # Scale and recolor individual cells
  
  scaled_cells = frozenset(process_cell(i, j, val) for i, row in enumerate(I) for j, val in enumerate(row))  # Process each cell
  O = paint(canvas(0, (height(I) * 10, width(I) * 5 if any(any(row) for row in I) else width(I) * 10)), merge(scaled_cells))  # Paint on canvas
  return O
 
0.0974074074074074, 13.951027, def aahgaiecaidcedecjeiefdihacddeece(I):
  O = canvas(ZERO, (TEN, TEN))  # Initialize 10x10 canvas
  for obj in objects(I, True, False, True): # Iterate over objects
    if color(obj) == TWO:  # Target objects with color '2'
      if colorcount(obj, TWO) == ONE: # Single '2' case
        O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (TWO, THREE)))) # First square
        O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (SIX, THREE)))) # Second square
      else: # Multiple '2's case
        O = paint(O, recolor(THREE, upscale(obj, THREE)))  # Scale by 3 and recolor to '3'
  return O
 
0.1437037037037037, 12.432504, def eicddgiecedbeejciihhaacbajbadfcb(I):
  O = upscale(I, FIVE) # Initial upscale by 5
  for obj in objects(I, True, False, True):
    if color(obj) == TWO:
      if colorcount(obj, TWO) == ONE:
        O = paint(O, recolor(THREE, shift(obj, (ONE, ONE))))
        O = paint(O, recolor(THREE, shift(obj, (FOUR, ONE))))
      else:
        O = paint(O, recolor(THREE, obj)) # Recolor without shifting
  return O
 
0.06814814814814815, 10.066781, def bhbcaedbhbdjehfaaehffhcfjcjbffeh(I):
  O = canvas(ZERO, multiply(shape(I), (FIVE, FIVE)))  # 5x scaled canvas
  for obj in objects(I, True, False, True):
    if color(obj) == TWO:
      factor = THREE if colorcount(obj, TWO) == ONE else FIVE  # Conditional scaling factor
      O = paint(O, recolor(THREE, upscale(obj, factor)))  # Scale and recolor
  return O
 
0.044444444444444446, 8.864906, def baaaicgejeieegfhieddegfcabaejcgd(I):
  size = (15, 15) if any(2 in r for r in I) else (10, 10)  # Determine grid size
  O = canvas(0, size)  # Create canvas
  if size == (15, 15):
    O = fill(O, 3, product(range(3), range(3, 6)))  # Fill 3x3 block for '2'
  else:
    O = fill(O, 3, {(2, 5), (3, 5)})  # Fill vertical line for no '2'
  return O
 
0.0690625, 10.063763, def dhefaaafdfffeceiiefffccbbbcfdccb(I):
  O = canvas(0, (10, 10))  # Start with 10x10 canvas
  if any(v == 2 for r in I for v in r):
    O = upscale(O, 2)  # Upscale to 20x20 if '2' is present
    O = trim(O)  # Trim to 18x18
    O = trim(rot90(O))  # Rotate and trim to 15x15
  O = fill(O, 3, product(range(min(3, len(O))), range(3, min(6, len(O[0])))))  # Fill pattern adjusting for size
  return O
 
0.20296296296296298, 15.418521, def agaeeeaadhfaeabbaehifefffedibdbd(I):
  obj = next((obj for obj in objects(I, univalued=True, diagonal=False, without_bg=True) if len(obj) > 0), None)
  if obj is None:
    return canvas(0, (10, 10))
  factor = (5, 5) if len(I) == 2 else (3, 5) 
  O = canvas(0, (len(I[0]) * factor[0], len(I) * factor[1]))
  if len(I) == 2:
    for i in range(3):
      O = paint(O, shift(upscale(obj, factor[0]), (0, i * factor[1] + 2))) 
  else:
    O = paint(O, shift(upscale(obj, factor[0]), (2, 2))) 
  return O
 
0.06333333333333334, 17.791008, def fedfjcdedcicejcejhcajbbibdffighb(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == TWO else canvas(0, (s + 13, s + 13))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        offset = (FIVE, FOUR) if s == TWO else (ONE, ONE)
        square = canvas(3, (THREE, THREE))
        return paint(O, shift(asobject(square), add(offset, (i, j))))
  return fill(O, 3, product(interval(TWO, FIVE, ONE), interval(FIVE, EIGHT, ONE))) 
 
0.11148148148148147, 13.994225, def fhdfciigjgdiebbbbhjhjaebiibadfab(I):
  twos = colorcount(I, TWO) # Count '2's
  O = canvas(ZERO, multiply(shape(I), (FIVE, FIVE)) if twos > ONE else (TEN, TEN)) # Canvas size based on '2' count
  if twos > ZERO:
    obj = extract(objects(I, True, False, True), lambda obj: color(obj) == TWO) # Extract the '2' object
    O = paint(O, recolor(THREE, upscale(obj, THREE))) # Upscale and paint
    if twos == ONE:
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (FOUR, ZERO)))) # Duplicate if single '2'
  return O
 
0.12407407407407407, 16.796497, def bcadiafdjffbejbaiffcjjfacedjgebc(I):
  if colorcount(I, TWO) == ONE:
    O = canvas(ZERO, (TEN, TEN))  
    for obj in objects(I, True, False, True):
      if color(obj) == TWO:
        O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (TWO, THREE))))
        O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (FOUR, ZERO)))) # Shift down for duplicate
  else:
    O = canvas(ZERO, multiply(shape(I), (FIVE, FIVE)))  
    for obj in objects(I, True, False, True):
      if color(obj) == TWO:
        O = paint(O, recolor(THREE, upscale(obj, THREE)))
  return O
 
0.04148148148148148, 24.651499, def cecjabeccfgbecaebfacecfbjeidedgd(I):
  has_two = 2 in palette(I)
  obj = extract(objects(I, T, F, T), lambda o: color(o) == 2) if has_two else frozenset()
  O = canvas(0, (10, 10))
  if has_two:
    O = paint(O, recolor(3, shift(obj, (6, 5))))
  return O
 
0.03777777777777778, 16.723127, def ecdccejfjfheeddcifhcabcaaegacdcc(I):
  def process_cell(i, j, val):
    if val == 0:
      return (3, (i, j)) # Recolor 0-valued cells to 3
    return (3, (i, j * val)) # Recolor to 3 and adjust horizontal position for scaling
  transformed_cells = frozenset(process_cell(i, j, val) for i, row in enumerate(I) for j, val in enumerate(row))
  canvas_width = width(I) * 5 if any(v != 0 for row in I for v in row) else width(I) * 10
  O = paint(canvas(0, (height(I) * 10, canvas_width)), transformed_cells)  # Paint on canvas
  return O
 
0.016111111111111114, 69.87073, def iggdeiacbedcefhgifcebbffdjedbfbj(I):
  transformed_grid = tuple(tuple(3 if v == 0 else 3 for _ in range(v if v != 0 else 1)) for row in I for v in row) # Scale and recolor grid directly
  canvas_width = len(transformed_grid[0]) if any(v != 0 for row in I for v in row) else len(I[0]) * 10
  O = paint(canvas(0, (len(I) * 10, canvas_width)), asobject(transformed_grid))
  return O
 
0.016111111111111114, 50.55791, def hbcicejcahbeefdgbajbaccahbegbbij(I):
  def process_row(row):
    new_row = tuple()
    for v in row:
      if v == 0:
        new_row += (3,)  # Recolor 0 to 3
      else:
        new_row += (3,) * v  # Repeat 3 by the value
    return new_row

  scaled_grid = tuple(process_row(row) for row in I)  # Apply scaling to each row
  canvas_width = len(scaled_grid[0]) if any(v != 0 for row in I for v in row) else len(I[0]) * 10
  O = paint(canvas(0, (len(I) * 10, canvas_width)), asobject(scaled_grid))
  return O
 
0.15481481481481482, 19.953373, def fgjadgfcdaefedcfafhecijbfdfffjih(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  f = 5 if height(I) == 2 else 3
  O = canvas(0, (width(I) * f, height(I) * f))
  for i, obj in enumerate(objs):
    offset = (0, 2 + 5 * i) if height(I) == 2 else (2, 2)
    O = paint(O, shift(upscale(obj, f), offset))
  return O
 
0.06666666666666667, 14.324759, def igajgdibgfbgeaejjbbcffhjgbaeibff(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        offset_i = 5 if s == 2 else 1
        offset_j = 5 if s == 2 else 1
        return fill(O, 3, product(interval(i + offset_i - 1, i + offset_i + 2, 1), interval(j + offset_j - 1, j + offset_j + 2, 1)))
  return fill(O, 3, product(interval(2, 5, 1), interval(5, 7, 1)))
 
0.06592592592592593, 11.364794, def cchhecaeaidcedbeifgbcdaeffbfehee(I):
  objs = objects(I, True, False, True)  # Identify all objects
  twos = colorfilter(objs, TWO)  # Filter for objects with color '2'
  O = canvas(ZERO, (15, 15) if twos else (10,10))  # Canvas size depends on presence of '2'
  for obj in twos:
    O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (2, 2))))  # Upscale, recolor, shift and paint
    if len(twos) == 1:
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (6, 2))))  # Duplicate if single '2' object
  return O 
 
0.1048148148148148, 13.973359, def iafjbidjcfaheaahigcfffacffbecaba(I):
  count = colorcount(I, TWO) # Count the occurrences of '2'
  O = canvas(ZERO, multiply(shape(I), (5, 5)) if count <= 1 else (15, 15))  # Dynamic canvas size
  if count > 0:
    obj = extract(objects(I, True, False, True), lambda obj: color(obj) == TWO)  # Extract the '2' object
    O = paint(O, recolor(THREE, shift(upscale(obj, THREE), astuple(TWO, multiply(count, TWO)))))  # Position based on count
    if count == 1:
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (6, 2))))  # Additional copy if single '2'
  return O
 
0.06814814814814815, 10.066781, def faaihehfbeedebeabfgbccehadcibhef(I):
  # Identify object based on a specific color (assuming it's color 2)
  obj = extract(objects(I, T, F, T), lambda o: color(o) == 2) if 2 in palette(I) else frozenset()

  # Define upscaling function with embedded conditional recoloring 
  def upscale_and_recolor(obj, factor):
    return recolor(3, upscale(obj, factor))

  # Apply upscaling and recoloring based on object's presence
  O = canvas(0, (max(10, len(I[0]) * 3), max(10, len(I) * 3)))  # Dynamic canvas size
  O = paint(O, upscale_and_recolor(obj, 3)) if obj else paint(O, upscale_and_recolor(obj, 1))
  return O
 
0.038518518518518514, 13.311205, def faecadcbgacdegceiffccefcfgggbfgd(I):
  # Get objects, excluding background
  objs = fgpartition(I)
  
  # Define a lambda function to conditionally upscale and recolor
  upscaler = lambda o: recolor(3, upscale(o, 3 if color(o) == 2 else 1))
  
  # Apply upscaling and recoloring to all objects on the canvas
  O = canvas(0, (15, 15))  # Assuming a 15x15 canvas
  O = paint(O, merge(apply(upscaler, objs)))
  return O 
 
0.043333333333333335, 29.216093, def jhcfgfhfhfaaedjbibdccaedaiibfeee(I):
  def process_cell(i, j, v):
    if v == 0:
      return {(0, (i * 10 + k, j * 5)) for k in range(10)}
    else:
      return {(3, (i * 10 + k, j * 5 + l)) for k in range(v) for l in range(3)}
  O = canvas(0, (10, width(I) * 5))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      O = paint(O, process_cell(i, j, v))
  return O
 
0.04, 29.300869, def fbddeecfjadbecbejcccgdhbhjaeedec(I):
  canvas_width = width(I) * 5 if any(v != 0 for row in I for v in row) else width(I) * 10
  O = canvas(0, (10, canvas_width))
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, recolor(3, frozenset((i * 10 + k, j * 5 + l) for k in range(v) for l in range(3))))
  return O
 
0.035555555555555556, 27.565144, def ddecccjcbbddegdbaedgcdbccfbejeeb(I):
  def transform(i, j, v):
    return frozenset(((3, (i * 10 + k, j * 5 + l)) for k in range(v) for l in range(3))) if v else (
      frozenset(((3, (4, 5)),)) if all(v == 0 for row in I for v in row) else frozenset()
    )
  transformed = frozenset(
    cell for i, row in enumerate(I) for j, v in enumerate(row) for cell in transform(i, j, v)
  )
  return paint(canvas(0, (10, 15)), transformed)
 
0.07481481481481482, 14.313759, def biabjfebfdjbedeajjjfcfccifgdaidc(I):
  obj_two = next((obj for obj in objects(I, True, False, True) if color(obj) == TWO), frozenset())
  if len(obj_two) == 0:
    return canvas(ZERO, (10, 10))
  canvas_size = (15, 15) if any(color(o) != TWO for o in objects(I, True, False, True)) else (10, 10)
  O = canvas(ZERO, canvas_size)
  O = paint(O, recolor(THREE, shift(upscale(obj_two, THREE), (TWO, FOUR) if canvas_size == (15, 15) else (TWO, TWO))))
  return O
 
0.08, 10.758175, def jccdfedjifafehefjaceediadfieccbi(I):
  # Check for non-background object
  obj = next((o for o in objects(I, T, F, T) if color(o) != 0), None)

  # Conditional upscaling and painting
  O = canvas(0, (10, 10))
  if obj:
    factor = 3 if 2 in palette(I) else 1
    O = paint(O, recolor(3, upscale(obj, factor)))
    O = move(O, recolor(3, upscale(obj, factor)), (2, 4))
  else:
    O = fill(O, 3, {(2, 5), (3, 5)}) 
  return O
 
0.061111111111111116, 8.671748, def ffafhffadbefedbcajejecgaffahdaab(I):
  def scale_and_reposition(obj):
    c = color(obj)
    i, j = ulcorner(obj)
    return recolor(3, {(i * 3 + k, j * 5 * c + l) for k in range(3) for l in range(3 * c)}) if c else (
      recolor(3, {(4, 5)}) if len(partition(I)) == 1 else obj
    )
  transformed_objs = frozenset(scale_and_reposition(obj) for obj in partition(I))
  O = paint(canvas(0, (10, 15 if any(palette(I) - {0}) else 10)), merge(transformed_objs))
  return O
 
0.1811111111111111, 32.906353, def eacgaaejajbieahaidhfbjeffbfbdfef(I):
  obj = next((obj for obj in objects(I, univalued=True, diagonal=False, without_bg=True) if obj), None) or canvas(0, (1, 1))
  f = 5 if height(I) == 2 else 3
  O = canvas(0, (width(I) * f, height(I) * f))
  if height(I) == 2:
    O = tuple(
      tuple(
        3 if (i >= 2 and i < 2 + f * height(obj) and j >= width(O) // 2 - width(obj) * f // 2 and j < width(O) // 2 + width(obj) * f // 2 and (i - 2) // f < height(obj) and (j - (width(O) // 2 - width(obj) * f // 2)) // f < width(obj)) or (i >= height(O) - f * height(obj) - 2 and i < height(O) - 2 and j >= width(O) // 2 - width(obj) * f // 2 and j < width(O) // 2 + width(obj) * f // 2 and (i - (height(O) - f * height(obj) - 2)) // f < height(obj) and (j - (width(O) // 2 - width(obj) * f // 2)) // f < width(obj)) else 0 for j in range(width(O))
      ) for i in range(height(O))
    )
  else:
    O = tuple(
      tuple(
        3 if i >= height(O) // 2 - height(obj) * f // 2 and i < height(O) // 2 + height(obj) * f // 2 and j >= width(O) // 2 - width(obj) * f // 2 and j < width(O) // 2 + width(obj) * f // 2 and (i - (height(O) // 2 - height(obj) * f // 2)) // f < height(obj) and (j - (width(O) // 2 - width(obj) * f // 2)) // f < width(obj) else 0 for j in range(width(O))
      ) for i in range(height(O))
    )
  return O
 
0.0788888888888889, 7.818353, def daccgfchfddeeicbiabcjhbeadecfebc(I):
  s = maximum(shape(I))  # Find the maximum dimension of the input grid
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))  # Create output canvas
  for i, j in product(range(s), range(s)): # Iterate over all cells
    if I[i][j] == 2:  # Find the '2' in the input
      offset = (1, -1) if s == 2 else (-1, -1)  # Calculate the offset based on grid size
      start_pos = add((i, j), offset)  # Calculate the top-left corner of the shape
      if s == 2:
        O = fill(O, 3, product(interval(start_pos[0], start_pos[0] + 3, 1), interval(start_pos[1], start_pos[1] + 2, 1))) # Draw the rectangle
      else:
        O = fill(O, 3, product(interval(start_pos[0], start_pos[0] + 3, 1), interval(start_pos[1], start_pos[1] + 3, 1))) # Draw the square
      return O  # Return the output grid
  return fill(O, 3, product(interval(3, 5, 1), interval(5, 7, 1)))  # Default case: draw the vertical line
 
0.05148148148148148, 23.495605, def gejbjdeefidgefcaiceffedigdjijccb(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  two_loc = [(i,j) for i, row in enumerate(I) for j, val in enumerate(row) if val == 2]  # Find all locations of '2'
  if two_loc:
    i, j = two_loc[0]  # Get the first location of '2'
    offset = (1, -1) if s == 2 else (-1, -1) 
    start_pos = add((i, j), offset)
    shape_size = (3, 2) if s == 2 else (3, 3)  # Define shape size based on grid size
    O = fill(O, 3, backdrop(shift(canvas(3, shape_size), start_pos)))  # Draw the shape using backdrop and shift
  else:
    O = fill(O, 3, backdrop(shift(canvas(3, (1, 2)), (3, 5))))  # Default case
  return O 
 
0.07222222222222223, 9.590075, def giabdcfgechaehcjaachbedafecbjegd(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  two_indices = ofcolor(I, 2)  # Get indices of '2's directly
  if two_indices:
    i, j = first(two_indices)
    offset = (1, -1) if s == 2 else (-1, -1)
    target_shape = canvas(3, (3, 2)) if s == 2 else canvas(3, (3, 3))  # Define target shape directly
    O = paint(O, shift(asobject(target_shape), add((i, j), offset)))  # Use 'paint' to draw the shifted object
  else:
    O = paint(O, shift(asobject(canvas(3, (1, 2))), (3, 5)))  # Default case
  return O
 
0.0788888888888889, 9.402718, def cicccdjeajiaebccjfgijddgjafaefcf(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        offset = (4, 0) if s == 2 else (i + 2, j + 1)  # Calculate top-left corner directly
        return fill(O, 3, product(interval(offset[0], offset[0] + 3, 1), interval(offset[1], offset[1] + (2 if s == 2 else 3), 1)))  # Combine shape drawing logic
  return fill(O, 3, product(interval(3, 5, 1), interval(5, 7, 1))) # Default case
 
0.044444444444444446, 10.896788, def efgaigiabadfeaceiaffaadggjdcbajd(I):
  # Determine grid size based on presence of '2'
  size = (15, 15) if 2 in palette(I) else (10, 10)

  # Create canvas
  O = canvas(0, size) 

  # Conditional filling based on grid size
  if size == (15, 15):
    O = fill(O, 3, product(range(3), range(3))) # Fill 3x3 block
  else:
    O = fill(O, 3, {(2, 5), (3, 5)}) # Fill vertical line
  return O
 
0.042222222222222223, 11.911487, def hccdafgiabdheacfjbdedffcefbbbcef(I):
  # Find non-background objects
  objs = objects(I, T, F, T) - colorfilter(objects(I, T, F, T), 0)

  # Upscale factor
  factor = 3 if 2 in palette(I) else 1

  # Create canvas and paint
  O = canvas(0, (15, 15) if factor == 3 else (10, 10))
  for obj in objs:
    O = paint(O, recolor(3, upscale(obj, factor)))
  return O
 
0.0537037037037037, 19.392138, def cddacbebaabeeeidbadgjdbdjdchhaab(I):
  def transform_obj(obj):
    c = color(obj)
    if c == 2:
      return recolor(3, shift(obj, (7, 0)))
    elif c == 0 and len(partition(I)) == 1:
      return recolor(3, {(0, 5)})
    else:
      return recolor(3, obj)
  transformed_objs = frozenset(transform_obj(obj) for obj in partition(I))
  O = paint(canvas(0, (10, 15 if any(palette(I) - {0}) else 10)), merge(transformed_objs))
  return O
 
0.0788888888888889, 10.542811, def dafeiaabgjcfedefbagcdacaicbeebib(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  two_locs = ofcolor(I, 2) 
  if two_locs:
    i, j = first(two_locs)
    O = paint(O, shift(asobject(canvas(3, (3, 3))), (i - 1, j - 1))) if s > 2 else paint(O, shift(asobject(canvas(3, (3, 2))), (i + 1, j - 1)))
  else:
    O = paint(O, shift(asobject(canvas(3, (1, 2))), (4, 5))) 
  return O 
 
0.05148148148148148, 23.127174, def ceaaabecgecfeccjiadiffeedbdafeeh(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        offset = (1, -1) if s == 2 else (-1, -1)
        O = fill(O, 3, backdrop(shift(canvas(3, (3, 2)) if s == 2 else canvas(3, (3, 3)), add((i, j), offset))))
        return O  # Exit after drawing the square
  O = fill(O, 3, backdrop(shift(canvas(3, (1, 2)), (4, 5))))
  return O
 
0.09814814814814815, 16.018734, def cghgcefjhdjgeghaieicbahgffehiece(I):
  objs = objects(I, True, False, True)
  obj = next((obj for obj in objs if color(obj) == TWO), frozenset())
  canvas_size = (15, 15) if len(objs) > ONE else (10, 10)
  O = canvas(ZERO, canvas_size)
  if len(obj) > 0:
    O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (TWO, TWO))))
    if canvas_size == (10, 10):
      O = paint(O, recolor(THREE, shift(upscale(obj, THREE), (SIX, FIVE))))
  else:
    O = paint(O, recolor(THREE, {(TWO, FIVE),(THREE, FIVE)}))
  return O
 
0.05111111111111111, 11.038391, def ddbiffjfibfbedcajheaefhaeedfeafd(I):
  # Extract non-background objects 
  objs = fgpartition(I) 

  # Upscale factor based on object color
  upscale_factor = lambda obj: 3 if color(obj) == 2 else 1  

  # Create a blank canvas based on upscale factor
  canvas_size = (15, 15) if any(upscale_factor(obj) == 3 for obj in objs) else (10, 10)
  O = canvas(0, canvas_size)

  # Process each object
  for obj in objs:
    # Determine upscale factor and upscale the object
    factor = upscale_factor(obj)
    upscaled_obj = upscale(obj, factor)

    # Calculate painting position based on object size and canvas size
    if factor == 3:
        pos = (2, 2) 
    else:
        pos = (2, canvas_size[1] // 2 - width(upscaled_obj) // 2)

    # Paint the object onto the canvas
    O = paint(O, shift(upscaled_obj, pos))

  return O
 
0.04888888888888889, 13.642098, def bdcebgggbdefeaaaidhacdafdijdddbc(I):
  objs = partition(I)  # Partition the grid into objects
  def transform(obj):
    if len(obj) == 0:  # Handle the case of no object (all 0s)
      return {(3, (2, 5))}
    v, (i, j) = first(obj)  # Extract value and a representative cell
    return recolor(3, frozenset({(i * 5 + k, j * 5 + l) for k in range(v) for l in range(3 if v == 2 else v)}))  # Scale and recolor
  
  transformed_objs = frozenset(transform(obj) for obj in objs)  # Process each object
  O = paint(canvas(0, (10, 15 if any(v != 0 for row in I for v in row) else 10)), merge(transformed_objs))  # Paint on canvas
  return O
 
0.08, 10.761126, def hehibcadchcjebbejaeccgbhecbgfdid(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  two_indices = ofcolor(I, 2)
  if two_indices:
    i, j = first(two_indices)
    start = (i + (5 if s == 2 else -1) - 1, j + (6 if s == 2 else 1) - 1)
    O = fill(O, 3, product(interval(start[0], start[0] + 3, 1), interval(start[1], start[1] + 3, 1)))
  else:
    O = fill(O, 3, product(interval(3, 5, 1), interval(5, 7, 1)))
  return O
 
0.07333333333333332, 8.601894, def fcdaaiebgicbecdeibbfhahiebighfae(I):
  s = maximum(shape(I))
  O = canvas(0, (10, 10)) if s == 2 else canvas(0, (s + 13, s + 13))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        offset_i = 5 if s == 2 else -1
        offset_j = 6 if s == 2 else 1
        for k in range(-1, 2):
          for l in range(-1, 2):
            if 0 <= i + offset_i + k < len(O) and 0 <= j + offset_j + l < len(O[0]):
              O = fill(O, 3, {(i + offset_i + k, j + offset_j + l)})
        return O
  return fill(O, 3, {(3, 5), (3, 6)})
 
