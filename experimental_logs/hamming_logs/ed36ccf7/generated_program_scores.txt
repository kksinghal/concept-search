4.0, 6.7423005, def faidehdjhjeeebbgifdfhbgjafbhcbdg(I):
    # Identify the largest object
    objs = objects(I, T, F, T)
    largest_obj = argmax(objs, size)
    
    # Determine the shift direction
    h, w = len(I), len(I[0])
    center_i, center_j = centerofmass(largest_obj)
    direction = (-1, 0) if center_i < h // 2 else (1, 0) if center_i > h // 2 else (0, -1) if center_j < w // 2 else (0, 1)
    
    # Shift the largest object
    shifted_obj = shift(largest_obj, direction)
    
    # Paint the shifted object onto a blank canvas
    O = paint(cover(I, largest_obj), shifted_obj)
    return O
 
4.75, 5.3525534, def affeccdacgcgefieijahcbfjhjbdcicc(I):
    # Partition into objects
    objs = partition(I)
    
    # Find the largest object
    largest_obj = argmax(objs, lambda obj: colorcount(I, color(obj)))
    
    # Calculate shift based on object's bounding box
    upper, left = ulcorner(largest_obj)
    lower, right = lrcorner(largest_obj)
    direction = (-1, 0) if upper <= len(I) // 2 else (1, 0) if lower >= len(I) // 2 else (0, -1) if left <= len(I[0]) // 2 else (0, 1)
    
    # Move the object
    O = move(I, largest_obj, direction)
    return O
 
3.75, 8.043275, def fbfhcjeejcehejccbgccgabfedbbfefc(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Find the dominant quadrant of the largest object
  h, w = len(I), len(I[0])
  quadrants = (
    len(toindices(largest_obj & frozenset((i, j) for i in range(h//2) for j in range(w//2)))),  # Top-left
    len(toindices(largest_obj & frozenset((i, j) for i in range(h//2) for j in range(w//2, w)))),  # Top-right
    len(toindices(largest_obj & frozenset((i, j) for i in range(h//2, h) for j in range(w//2)))),  # Bottom-left
    len(toindices(largest_obj & frozenset((i, j) for i in range(h//2, h) for j in range(w//2, w))))  # Bottom-right
  )
  dominant_quadrant = argmax(enumerate(quadrants), last)[0]
  
  # Determine the shift direction based on the dominant quadrant
  direction = {0: (-1, -1), 1: (-1, 1), 2: (1, -1), 3: (1, 1)}[dominant_quadrant]
  
  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
4.0, 8.284732, def cfiabdedeaaaehfebffgbfaiagajaeji(I):
  # Get objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Find the furthest corner from the grid's center
  h, w = len(I), len(I[0])
  center_i, center_j = h // 2, w // 2
  corners = [ulcorner(largest_obj), urcorner(largest_obj), llcorner(largest_obj), lrcorner(largest_obj)]
  furthest_corner = argmax(corners, lambda corner: abs(corner[0] - center_i) + abs(corner[1] - center_j))
  
  # Calculate the direction towards the furthest corner
  direction = (sign(furthest_corner[0] - center_i), sign(furthest_corner[1] - center_j))
  
  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
6.0, 25.38004, def dacfaccdfcdaeababbecjhbhbbhdieci(I):
  left = lefthalf(I)
  right = righthalf(I)
  return hconcat(vmirror(left), right)
 
15.75, 73.9974, def cejbafidcdgeefcjjeecfaefagdjadca(I):
  return hconcat(vsplit(I, 2)[1], vsplit(I, 2)[0]) 
 
16.5, 74.442795, def affdfhdfbdbfedcgaffabcbgfajedbcg(I):
  return rot270(hconcat(vmirror(rot90(I))[:1], rot90(I)[:1]))
 
4.5, 3.7471373, def jfeeiaefebfceaccifjgadeaadadefac(I):
  objs = objects(I, False, False, False)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    left_obj = sfilter(obj, lambda cell: cell[1][1] < width(I) // 2)
    right_obj = sfilter(obj, lambda cell: cell[1][1] >= width(I) // 2)
    O = paint(O, shift(vmirror(left_obj), (0, width(right_obj))))
    O = paint(O, shift(right_obj, (0, -width(right_obj))))
  return O
 
4.5, 3.7681067, def bedecebcebfeeffcbbbfcdccahbicedg(I):
    bg = mostcolor(I)
    obj_color = leastcolor(I) if leastcolor(I) != bg else other(palette(I), bg)
    obj = first(colorfilter(objects(I, T, F, F), obj_color))
    direction = position(obj, asobject(I))
    shifted_obj = shift(obj, direction)
    O = paint(fill(I, bg, shifted_obj), shifted_obj)
    return O
 
3.5, 8.577013, def fhbhfffejdbceejjbfhcbeajjdabjfja(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  obj = argmax(objs, size)
  direction = position(obj, asobject(I))
  shifted_obj = shift(obj, direction)
  O = paint(fill(I, bg, asobject(I)), shifted_obj) 
  return O
 
3.5, 3.4196513, def ggbjficahfdhedddigacaffahagjjbcc(I):
  bg = mostcolor(I)
  parts = fgpartition(I)
  largest_part = argmax(parts, size)
  direction = position(largest_part, asobject(I))
  shifted_part = shift(largest_part, direction)
  O = paint(fill(I, bg, asobject(I)), shifted_part)
  return O
 
3.75, 5.7189903, def bejbeibceieheeicaejdjdjddfdcgejf(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      new_i, new_j = i - 1, j + 1
      if 0 <= new_i < h and 0 <= new_j < w:
        O = fill(O, I[i][j], {(new_i, new_j)})
  return O
 
4.25, 2.5635302, def cacbbaebbegcecefjibcjddedjdbeabd(I):
    x1 = objects(I, F, F, T)  
    x2 = argmin(x1, size)  
    x3 = ulcorner(x2)
    x4 = cover(I, x2)
    x5 = branch(equality(x3, ORIGIN), shift(x2, RIGHT), 
                branch(equality(x3, (2, 0)), shift(x2, DOWN), 
                      branch(equality(x3, (0, 2)), hmirror(shift(x2, DOWN)),
                            shift(x2, (1, 1)))))
    O = paint(x4, x5)
    return O 
 
4.25, 3.1696606, def eceaeedfjcibedabjbaajeacccdeaceh(I):
    x1 = objects(I, F, F, T)
    x2 = argmin(x1, size)
    x3 = ulcorner(x2)
    x4 = cover(I, x2)
    x5 = [(0, 1), (2, 0), (0, 2), (1, 1)]
    x6 = [RIGHT, DOWN, DOWN, (1, 1)]
    x7 = dict(zip(x5, x6))
    x8 = x7.get(x3, ORIGIN)
    x9 = shift(x2, x8)
    x10 = branch(equality(x3, (0, 2)), hmirror(x9), x9)
    O = paint(x4, x10)
    return O
 
5.0, 3.025494, def eebedgafjbiiefdcjcccbegedfceadai(I):
    x1 = objects(I, F, F, T)
    x2 = argmin(x1, size)
    x3 = ulcorner(x2)
    x4 = {ORIGIN: RIGHT, (2, 0): DOWN, (0, 2): DOWN, (1, 1): (1, 1)}
    x5 = x4.get(x3, ORIGIN)
    x6 = branch(equality(x3, (0, 2)), hmirror(x2), x2)
    x7 = shift(x6, x5)
    O = paint(cover(I, x2), x7)
    return O
 
4.5, 3.333767, def ibigidcfhadeedcdiacbbdcbjbicdbjb(I):
  h = len(I)
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val != mostcolor(I):
        if i < h // 2:
          O = paint(O, {(val, (j, h - i - 1))}) 
        else:
          O = paint(O, {(val, (i, j))})
  return O
 
6.0, 25.38004, def ajccefdieabdeaafbgejbeceebfjfeaf(I):
  return hconcat(vmirror(lefthalf(I)), righthalf(I))
 
4.5, 4.4560285, def dciaadgibdhdebhiacjabcjgcdaggbeb(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)
  
  # Calculate distances to edges
  h, w = len(I), len(I[0])
  top_distance = uppermost(largest_obj)
  bottom_distance = h - 1 - lowermost(largest_obj)
  left_distance = leftmost(largest_obj)
  right_distance = w - 1 - rightmost(largest_obj)
  
  # Determine the direction to the closest edge
  min_distance = min(top_distance, bottom_distance, left_distance, right_distance)
  direction = (
      (-1, 0) if min_distance == top_distance else 
      (1, 0) if min_distance == bottom_distance else 
      (0, -1) if min_distance == left_distance else 
      (0, 1)
  )
  
  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
3.5, 3.9224591, def ffibjfbeidfdeihcigbefdbbfeegfbeh(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the bounding box of the largest object
  ul = ulcorner(largest_obj)
  lr = lrcorner(largest_obj)

  # Calculate distances to edges
  h, w = len(I), len(I[0])
  distances = [ul[0], h - 1 - lr[0], ul[1], w - 1 - lr[1]]
  
  # Find the index of the minimum distance
  min_index = argmin(list(range(4)), lambda i: distances[i])

  # Define the shift direction based on the minimum distance index
  direction = [(0, -1), (0, 1), (-1, 0), (1, 0)][min_index]
  
  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
3.5, 2.5219982, def dechbhbeajbgegafbebahdcbeecdjcai(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Find the closest edge to the object's center of mass
  h, w = len(I), len(I[0])
  ci, cj = centerofmass(largest_obj)
  distances = [ci, h - 1 - ci, cj, w - 1 - cj]
  min_distance_index = argmin(list(range(4)), lambda i: distances[i])

  # Define shift direction based on the closest edge
  direction = [(0, -1), (0, 1), (-1, 0), (1, 0)][min_distance_index]

  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
3.75, 6.8511043, def eddcefgaicaeecabbcadbigcdfgbbcid(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, lambda obj: width(obj) * height(obj))

  # Calculate the center of mass of the largest object
  center_i, center_j = centerofmass(largest_obj)
  
  # Define shift directions for each quadrant
  h, w = len(I), len(I[0])
  directions = {
      0: (-1, -1),  # Top-left
      1: (-1, 1),   # Top-right
      2: (1, -1),   # Bottom-left
      3: (1, 1)    # Bottom-right
  }
  
  # Determine the quadrant of the center of mass
  quadrant = (
      0 if center_i < h // 2 and center_j < w // 2 else
      1 if center_i < h // 2 and center_j >= w // 2 else
      2 if center_i >= h // 2 and center_j < w // 2 else
      3
  )
  
  # Move the object towards the edge of its quadrant
  O = move(I, largest_obj, directions[quadrant])
  return O
 
6.0, 24.870588, def cbjhefeigiheeddeafaahjjbcfgabfee(I):
    left = lefthalf(I)
    right = righthalf(I)
    top = tophalf(I)
    bottom = bottomhalf(I)
    return hconcat(hmirror(right), hmirror(left))
 
4.5, 2.5092158, def ehdfjgbeiecaeabbjeffejjeffjjbcji(I):
  return vmirror(hmirror(I))
 
4.0, 8.747463, def bdhgadffjbadejbbbdhffeeadijebbed(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, F)
    largest = argmax(objs, size)
    return paint(
        fill(I, bg, asobject(I)),
        shift(largest, (int(len(occurrences(I, largest)) > 1), position(largest, asobject(I))[1])) if vmatching(largest, asobject(I))
        else shift(largest, (position(largest, asobject(I))[0], int(len(occurrences(I, largest)) > 1)))
    )
 
4.0, 2.6900733, def ceifjaahfhehehegadidgiahfegcigjh(I):
    # Identify the smallest object
    x1 = objects(I, F, F, T) 
    x2 = argmin(x1, size) 
    
    # Determine shift direction and magnitude based on initial position
    x3 = ulcorner(x2)
    x4 = branch(
        equality(x3, (0, 0)), (0, 1),  # Top-left corner: Shift Right
        branch(
            equality(x3, (2, 0)), (1, 0),  # Bottom-left corner: Shift Down
            branch(
                equality(x3, (0, 2)), (1, 0),  # Top-right corner: Shift Down
                (1, -1)  # Center: Shift Down-Left (other cases can be added)
            )
        )
    )
    
    # Shift the object
    x5 = shift(x2, x4) 
    
    # Paint the shifted object back onto the covered grid
    O = paint(cover(I, x2), x5)  
    return O
 
3.0, 3.7823458, def afjbchgecbbaeacajffgebbeecccibhc(I):
  # Find the least common color (assuming it represents the object to be moved)
  x1 = leastcolor(I)  

  # Find indices of the object
  x2 = ofcolor(I, x1)  

  # Determine shift direction based on the object's current center position
  x3 = centerofmass(x2)
  x4 = branch(
      equality(x3[1], 1), (0, 1),  # Center column: Shift Right
      branch(
          equality(x3[0], 1), (1, 0),  # Center row: Shift Down
          (1, -1)   # Other: Shift Down-Left (add more cases as needed)
      )
  )

  # Shift the object indices
  x5 = shift(x2, x4)  

  # Fill the original object's position with the most common color
  x6 = fill(I, mostcolor(I), x2) 

  # Paint the shifted object back onto the grid using its original color
  O = fill(x6, x1, x5)
  return O
 
4.5, 3.6553988, def aaidficjbfhfeiceadcacbffifiajfgc(I):
  # Identify objects in the grid
  x1 = objects(I, F, F, T)  

  # Find the smallest object 
  x2 = argmin(x1, size)

  # Check if the object is a horizontal line
  x3 = hline(x2)

  # Apply a conditional shift based on object properties 
  x4 = branch(x3, shift(x2, (1, 0)), shift(x2, (0, 1))) 

  # Paint the shifted object back onto the covered grid
  O = paint(cover(I, x2), x4)
  return O
 
4.5, 3.158601, def jdfibbjjdaaiejadaeebdhjacddcaecb(I):
  # Identify objects in the grid, excluding the background
  x1 = objects(I, F, F, T)  

  # Target location for the shift
  target_loc = (2, 2)  # Example: Bottom-right corner

  # Find the object closest to the target location 
  x2 = argmin(x1, lambda obj: manhattan(obj, {target_loc}))

  # Calculate the shift required to move the object to the target
  x3 = gravitate(x2, {target_loc}) 

  # Shift the object
  x4 = shift(x2, x3)

  # Paint the shifted object onto the grid
  O = paint(cover(I, x2), x4)
  return O
 
5.0, 25.477114, def jgffiaecjajbeadbifagiecbejeecaea(I):
  # Divide the grid horizontally into two halves
  top_half = tophalf(I)  
  bottom_half = bottomhalf(I)

  # Swap the positions of the two halves
  O = vconcat(bottom_half, top_half)
  return O
 
4.0, 2.8473196, def jhfdhdgcfhdaebdfibcddejbgjcggaac(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  transformed_objs = frozenset()
  for obj in objs:
    if centerofmass(obj)[1] < len(I[0]) // 2:
      transformed_objs = transformed_objs | {hmirror(toobject(obj, I))}
    else:
      transformed_objs = transformed_objs | {obj}
  O = paint(canvas(mostcolor(I), shape(I)), merge(transformed_objs))
  return O
 
4.25, 4.8778305, def fabbabieeeeeedehjefgefceaehaebef(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w // 2):
      O = paint(O, {(I[i][j], (i, w - j - 1))})
    for j in range(w // 2, w):
      O = paint(O, {(I[i][j], (i, j))})
  return O
 
5.5, 25.224203, def aacaacgcdfgdeefaijfhfecefdabafaa(I):
  left = hmirror(lefthalf(I))
  right = righthalf(I)
  return hconcat(left, right)
 
4.5, 4.164897, def ehghffbgfcfdefefbcegbgjgcfjfgdab(I):
  w = len(I[0])
  return tuple(tuple(I[i][j] if j >= w // 2 else I[i][w - j - 1] for j in range(w)) for i in range(len(I)))
 
4.5, 2.8923204, def hbadacdhdffgeefbjcbejchgaieifibi(I):
    # Identify objects, excluding background
    objs = objects(I, T, F, T) 
    
    # Find the largest object
    largest_obj = argmax(objs, size)
    
    # Calculate center of mass for the largest object
    center_i, center_j = centerofmass(largest_obj)
    
    # Determine shift direction based on center relative to grid center
    h, w = len(I), len(I[0])
    shift_i = 1 if center_i < h // 2 else -1 if center_i > h // 2 else 0
    shift_j = 1 if center_j < w // 2 else -1 if center_j > w // 2 else 0
    
    # Move the object
    O = move(I, largest_obj, (shift_i, shift_j))
    return O
 
4.25, 6.636207, def bcdedfaeccfaedicacbddgfebcgebbfd(I):
  # Identify distinct objects, excluding background
  objs = objects(I, T, F, T)

  # Find the object with the most common color (largest object)
  largest_obj = argmax(objs, lambda obj: colorcount(I, color(obj)))

  # Calculate shift direction based on object's center of mass
  h, w = len(I), len(I[0])
  center_i, center_j = centerofmass(largest_obj)
  shift_i = (center_i > h // 2) - (center_i < h // 2) 
  shift_j = (center_j > w // 2) - (center_j < w // 2)

  # Move the largest object
  O = move(I, largest_obj, (shift_i, shift_j))
  return O
 
4.75, 2.9268854, def dahgbccaeaggefeijagffcegdabfbggf(I):
    # Find the largest object without explicitly identifying all objects
    largest_obj = argmax(partition(I), size)

    # Determine shift direction based on center of mass
    h, w = shape(I)
    ci, cj = centerofmass(largest_obj)
    di = 1 if ci * 2 < h else -1 if ci * 2 > h else 0
    dj = 1 if cj * 2 < w else -1 if cj * 2 > w else 0

    # Move the largest object
    O = move(I, largest_obj, (di, dj))
    return O
 
3.25, 4.1402755, def ecfjeaddadjdegebbgiebfadcgcccfbb(I):
  # Identify objects
  objs = objects(I, T, F, T)
  
  # Find the largest object
  largest_obj = argmax(objs, size)
  
  # Calculate the center of the largest object
  center_i, center_j = center(toindices(largest_obj))
  
  # Determine the shift based on object's center
  h, w = len(I), len(I[0])
  shift_i = (-1) ** (center_i < h // 2)
  shift_j = (-1) ** (center_j < w // 2)
  
  # Move the object 
  O = move(I, largest_obj, (shift_i, shift_j))
  return O
 
3.25, 15.624077, def fdigdeediefceecajfagfdicecaijghb(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))
  tl = asobject(crop(I, ORIGIN, (h // 2, w // 2)))
  tr = asobject(crop(I, (0, w // 2), (h // 2, w - w // 2)))
  bl = asobject(crop(I, (h // 2, 0), (h - h // 2, w // 2)))
  br = asobject(crop(I, (h // 2, w // 2), (h - h // 2, w - w // 2)))
  O = paint(O, shift(br, (-h // 2, -w // 2)))
  O = paint(O, shift(tr, (-h // 2, w // 2)))
  O = paint(O, shift(bl, (h // 2, -w // 2)))
  O = paint(O, shift(tl, (h // 2, w // 2)))
  return O
 
4.5, 3.742856, def ibgijgbijafeedaebdcjdcciadbhcaaa(I):
  # Find the least common color 
  x1 = leastcolor(I)  
  # Find indices of the object
  x2 = ofcolor(I, x1)
  # Calculate the shift based on object's center
  x3 = centerofmass(x2)
  x4 = branch(
      equality(x3, (1, 1)), (1, 1), # Center: Shift to bottom-right
      branch(
          equality(x3[1], 1), (len(I) - 1, 0), # Center column: Shift to bottom-left
          (0, len(I[0]) - 1)  # Other: Shift to top-right 
      )
  )
  # Shift the object
  x5 = shift(x2, x4)
  # Fill the original and paint the new position
  O = fill(fill(I, mostcolor(I), x2), x1, x5) 
  return O
 
3.5, 8.451012, def baciahaiceadeddebdebiagcefaidhhd(I):
  # Identify the object by its color
  c = leastcolor(I)
  # Define a function to calculate the target position based on object's bounding box
  def target_position(obj):
    return (lowermost(obj), rightmost(obj))  
  # Find the object and its target position
  obj = toobject(ofcolor(I, c), I)
  target = target_position(obj)
  # Move the object by painting and covering
  O = paint(cover(I, obj), recolor(c, (target,)))
  return O
 
3.75, 3.9742928, def egegdahddhjcefdjbhjbiheegfhejdhf(I):
  # Get object color
  c = leastcolor(I)
  # Find the object
  obj = toobject(ofcolor(I, c), I)
  # Define corner movements
  moves = {
      ulcorner(obj): lrcorner(obj),
      (1, 1): (len(I) - 1, len(I[0]) - 1),
      (1, 0): (len(I) - 1, 0)
  }
  # Determine the shift
  shift_amount = subtract(moves.get(ulcorner(obj), ulcorner(obj)), ulcorner(obj))
  # Move the object
  O = paint(cover(I, obj), shift(obj, shift_amount))
  return O
 
4.0, 11.932065, def ccbiafgabigdeahcafjeffffehaacdhf(I):
  # Find the object color and indices
  c = leastcolor(I)
  indices = ofcolor(I, c)
  # Calculate the shift based on initial position
  i, j = ulcorner(indices)
  shift_i = (len(I) - 1 - i) if j != 0 else (len(I) - 1)
  shift_j = (len(I[0]) - 1 - j) if i != 1 else 0
  # Shift the indices
  new_indices = shift(indices, (shift_i, shift_j))
  # Update the grid
  O = fill(fill(I, mostcolor(I), indices), c, new_indices)
  return O
 
4.25, 4.5446253, def ebaefeefgeiaebbbbeedcjfccgjffejd(grid):
  h, w = len(grid), len(grid[0])
  output_grid = canvas(mostcolor(grid), (h, w))
  for i in range(h):
    for j in range(w):
      value = grid[i][j]
      if value == 9:
        new_j = (j + 1) % w
        output_grid = paint(output_grid, {(value, (i, new_j))})
      elif value == 6:
        new_i = (i + 1) % h
        output_grid = paint(output_grid, {(value, (new_i, j))})
      elif value == 2:
        new_j = (j - 1) % w
        output_grid = paint(output_grid, {(value, (i, new_j))})
      else:
        output_grid = paint(output_grid, {(value, (i, j))})
  return output_grid 
 
4.5, 3.254184, def chefgcejfbbhebbaajecgeiffjhdbeba(grid):
  objs = objects(grid, univalued=True, diagonal=False, without_bg=False)
  output_grid = canvas(mostcolor(grid), shape(grid))
  for obj in objs:
    value = color(obj)
    if value == 9:
      new_obj = shift(obj, (0, 1))
      output_grid = paint(output_grid, {(grid[i][(j + 1) % len(grid[0])], (i, (j + 1) % len(grid[0]))) for v, (i, j) in new_obj})
    elif value == 6:
      new_obj = shift(obj, (1, 0))
      output_grid = paint(output_grid, {(grid[(i + 1) % len(grid)][j], ((i + 1) % len(grid), j)) for v, (i, j) in new_obj})
    elif value == 2:
      new_obj = shift(obj, (0, -1))
      output_grid = paint(output_grid, {(grid[i][(j - 1) % len(grid[0])], (i, (j - 1) % len(grid[0]))) for v, (i, j) in new_obj})
    else:
      output_grid = paint(output_grid, obj)
  return output_grid
 
3.5, 3.707451, def eejfjbdbaadfefdibchbibjejabfeaia(I):
  # Find largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Find center of mass of the largest object
  center_i, center_j = centerofmass(largest_obj)

  # Determine shift direction 
  h, w = len(I), len(I[0])
  shift_direction = (
      1 if center_i < h // 2 else -1, 
      1 if center_j < w // 2 else -1
  )

  # Move the object
  O = move(I, largest_obj, shift_direction)
  return O
 
2.75, 3.4086685, def cfehbajfafadeiihjccddjbadaefjiig(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)
  
  # Calculate center of the object's bounding box
  center_i, center_j = center(largest_obj) 

  # Determine shift direction
  h, w = len(I), len(I[0])
  shift_direction = (
      1 if center_i <= h // 2 else -1,
      1 if center_j <= w // 2 else -1
  )

  # Move the largest object
  O = move(I, largest_obj, shift_direction)
  return O 
 
3.5, 3.4418385, def ddahfdbicgbiebfejeedeeccbhcebdhd(I):
  # Identify all objects and find the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the center coordinates of the grid
  h, w = len(I), len(I[0])
  grid_center_i, grid_center_j = h // 2, w // 2

  # Calculate the center coordinates of the largest object
  obj_center_i, obj_center_j = centerofmass(largest_obj)

  # Determine the shift direction based on the relative position of centers
  shift_direction = (
      -1 if obj_center_i > grid_center_i else 1, 
      -1 if obj_center_j > grid_center_j else 1
  )

  # Move the largest object in the determined direction
  O = move(I, largest_obj, shift_direction)
  return O
 
14.5, 22.411224, def dabidjbffheaefjdifdbiheefbacdbgd(I):
  return vconcat(hconcat(hmirror(lefthalf(I)), righthalf(I)),
                   hconcat(vmirror(lefthalf(I)), hmirror(vmirror(righthalf(I)))))
 
4.0, 7.800457, def cbfjfadaaceceabjiceaifcdhedfchcb(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  
  # Calculate the offset based on the number of occurrences
  offset = (1, 0) if len(occurrences(I, target_obj)) > 1 else (0, 0)
  
  # Shift the target object
  shifted_obj = shift(target_obj, offset)
  
  # Construct the output grid
  O = paint(fill(I, bg, asobject(I)), shifted_obj)
  return O
 
3.5, 7.7190194, def cbdcdffajfafebiebdfcafdgdfcfaeee(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  small_objs = sfilter(objs, lambda obj: size(obj) == 1)
  target_obj = argmax(objs, size)
  
  if len(small_objs) == 2:
    # Move small objects to the right of the largest object
    shifted_objs = shift(combine(small_objs), (0, width(target_obj)))
    O = paint(paint(fill(I, bg, asobject(I)), target_obj), shifted_objs)
  else:
    # Shift the largest object to the right
    shifted_obj = shift(target_obj, (1, 0))
    O = paint(fill(I, bg, asobject(I)), shifted_obj)
  return O 
 
4.0, 7.3370323, def gcaefedgaabgeicbbageeceechadaaea(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  
  # Calculate horizontal shift based on object repetition 
  h_shift = 1 if len(occurrences(I, target_obj)) > 1 else 0
  
  # Calculate vertical shift based on object's vertical position
  v_shift = -1 if uppermost(target_obj) < len(I) // 2 else 1
  
  # Shift the target object
  shifted_obj = shift(target_obj, (v_shift, h_shift))
  
  # Construct the output grid
  O = paint(fill(I, bg, asobject(I)), shifted_obj)
  return O
 
4.5, 3.254184, def fgebjfgdcbcbeffaafgadbcdbebediff(I):
  # Find target object directly
  target_obj = argmin(objects(I, False, False, False), lambda obj: colorcount(I, color(obj)))
  # Calculate target corner based on initial position
  target_corner = (
      len(I) - height(target_obj),
      (len(I[0]) - width(target_obj)) if leftmost(target_obj) > 0 else 0
  ) 
  # Move the object using a single shift operation
  O = paint(
      cover(I, target_obj), 
      shift(target_obj, subtract(target_corner, ulcorner(target_obj)))
  )
  return O
 
4.75, 3.8322625, def abejegihhgadedhhjeagbiefcchbigde(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
          {
              9: grid[i][(j + 1) % w],
              6: grid[(i + 1) % h][j],
              2: grid[i][(j - 1) % w],
          }.get(cell, cell)
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
3.5, 16.450521, def bajdfbabgieaecbeaafabehbgfcbbacf(grid):
  h, w = len(grid), len(grid[0])
  output = canvas(mostcolor(grid), (h, w))
  for value in (9, 6, 2):
    for i, j in ofcolor(grid, value):
      if value == 9:
        output = paint(output, {(value, (i, (j + 1) % w))})
      elif value == 6:
        output = paint(output, {(value, ((i + 1) % h, j))})
      else:
        output = paint(output, {(value, (i, (j - 1) % w))})
  return output
 
3.5, 11.915608, def debaebebefbeeciabdbhdheabceehacd(I):
  objs = objects(I, T, F, T) # Identify objects
  O = I # Initialize output grid
  for obj in objs:
    color_val = color(obj) # Get object's color
    shifted_obj = shift(obj, (-2,0)) # Shift object upwards by two units
    O = paint(cover(O, obj), shifted_obj) # Update output grid 
  return O
 
4.0, 3.6617146, def igdcgjdcahbdeeaeafbjbfhchaicedfc(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    if uppermost(obj) > 0: # If object is not already at the top
      O = paint(cover(O, obj), shift(obj, (-1, 0))) # Shift upwards by one unit
  return O
 
4.25, 3.6910758, def feaeiiijhfcdeieeiffdacaajcghbfeb(I):
  objs = fgpartition(I) # Identify objects without considering background
  O = I
  for obj in objs:
    c = color(obj) 
    for x, (i, j) in obj: # Iterate through individual cells of the object
      if i > 0 and I[i-1][j] == mostcolor(I): # If cell can be moved up
        O = paint(cover(O, obj), shift(obj, (-1, 0))) # Shift object upwards 
        break # Move to the next object after shifting
  return O
 
4.0, 3.2921796, def egfcjdififjdefjiaifhddeaejjfecch(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    leftmost_col = leftmost(obj)
    if leftmost_col > 0:
      for i in range(height(obj)): # Iterate through object's height
        O = paint(cover(O, obj), shift(obj, (0, -leftmost_col))) # Shift object to the leftmost column
  return O
 
3.5, 7.610974, def dgfjdcfababbeghdjjdiebccigfhcfdc(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  
  # Calculate center of mass for the object and the grid
  obj_center = centerofmass(target_obj)
  grid_center = centerofmass(asobject(I))
  
  # Determine the target corner based on object's position
  target_corner = (0 if obj_center[0] <= grid_center[0] else len(I) - height(target_obj),
                   0 if obj_center[1] <= grid_center[1] else len(I[0]) - width(target_obj))
  
  # Calculate the shift required to move the object
  shift_amount = subtract(target_corner, ulcorner(target_obj))
  
  # Shift the target object
  shifted_obj = shift(target_obj, shift_amount)
  
  # Construct the output grid
  O = paint(fill(I, bg, asobject(I)), shifted_obj)
  return O 
 
4.0, 3.257662, def jfebhacfaafhebfdjddccgccifbbcada(I):
  # Find the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the center of the largest object
  center_i, center_j = center(toindices(largest_obj))

  # Determine the shift based on the object's center
  h, w = len(I), len(I[0])
  shift_i =  h - 1 - lowermost(largest_obj) if center_i < h // 2 else -uppermost(largest_obj) 
  shift_j =  w - 1 - rightmost(largest_obj) if center_j < w // 2 else -leftmost(largest_obj)

  # Move the object
  O = move(I, largest_obj, (shift_i, shift_j))
  return O
 
4.5, 3.254184, def fgbcfbcgdfadehbaidigffigdcaehacj(I):
  # Find the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the target corner coordinates
  h, w = len(I), len(I[0])
  target_i = 0 if uppermost(largest_obj) < h // 2 else h - height(largest_obj)
  target_j = 0 if leftmost(largest_obj) < w // 2 else w - width(largest_obj)

  # Calculate the shift vector
  shift_i = target_i - uppermost(largest_obj)
  shift_j = target_j - leftmost(largest_obj)

  # Move the object
  O = move(I, largest_obj, (shift_i, shift_j))
  return O
 
4.0, 3.050863, def dhjaebfdjafaeabfjgaefdgfabccehfc(I):
  # Find the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Normalize the object to the origin
  normalized_obj = normalize(largest_obj)

  # Calculate the target corner coordinates
  h, w = len(I), len(I[0])
  target_i = (h - height(largest_obj)) if centerofmass(largest_obj)[0] < h // 2 else 0
  target_j = (w - width(largest_obj)) if centerofmass(largest_obj)[1] < w // 2 else 0

  # Shift the normalized object to the target corner
  shifted_obj = shift(normalized_obj, (target_i, target_j))

  # Paint the shifted object back onto the original grid
  O = paint(cover(I, largest_obj), shifted_obj)
  return O
 
4.5, 2.9182591, def higefdcefaccecfabdbedcbcbeejfdei(I):
  # Find the largest object
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the object's center
  obj_center = centerofmass(largest_obj)

  # Determine the target corner index based on the object's center
  h, w = len(I), len(I[0])
  corner_index = (obj_center[0] < h // 2) * 2 + (obj_center[1] < w // 2)

  # Define a list of corner functions
  corner_functions = [ulcorner, urcorner, llcorner, lrcorner]

  # Get the target corner using the calculated index
  target_corner = corner_functions[corner_index](largest_obj)

  # Calculate the shift vector
  shift_vector = subtract(target_corner, ulcorner(largest_obj))

  # Move the object
  O = move(I, largest_obj, shift_vector)
  return O
 
4.5, 4.180936, def ajdegjdhgadfejfeaceaejagfhifchjb(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      new_i = (i - 1) % h  # Wrap around vertically
      new_j = (j + 1) % w  # Wrap around horizontally
      if I[i][j] != mostcolor(I): # Only move non-background digits
        O = fill(O, I[i][j], {(new_i, new_j)})
  return O
 
5.5, 24.753698, def gbedcajfidddehhcacadfabfiejjfhbc(I):
  h, w = len(I), len(I[0])
  top, bottom = vsplit(I, 2)[0], vsplit(I, 2)[-1] # Split grid horizontally
  left, right = hsplit(I, 2)[0], hsplit(I, 2)[-1] # Split grid vertically
  if h > 1:
    O = vconcat(bottom, top) # Swap top and bottom halves
  if w > 1:
    O = hconcat(right, left) # Swap left and right halves
  return O
 
3.25, 2.8233345, def echbfbdbfdaceadibcibjdbafddjcacj(I):
  objs = fgpartition(I)
  shifted_objs = set()
  for obj in objs:
    x1 = box(obj)
    x2 = rbind(difference, x1)
    x3 = chain(positive, size, x2)
    if x3(vfrontier(ulcorner(obj))): # Check for vertical frontier intersection
      shifted_obj = shift(obj, (0, -1)) # Shift left
    elif x3(hfrontier(ulcorner(obj))): # Check for horizontal frontier intersection
      shifted_obj = shift(obj, (1, 0)) # Shift down
    else:
      shifted_obj = obj  # No shift
    shifted_objs.add(shifted_obj)
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
3.25, 2.8233345, def dejjgacfdidcebfejffaaebfcdejejie(I):
  obj = first(objects(I, False, False, False)) # Get the first object
  direction = branch(
      equality(leftmost(obj), 0), LEFT,  # Left edge: shift right
      branch(
          equality(uppermost(obj), 0), UP,  # Top edge: shift down
          branch(
              equality(rightmost(obj), len(I[0]) - 1), RIGHT, # Right edge: shift left
              DOWN # Otherwise: shift up
          )
      )
  )
  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
4.25, 4.84184, def ieffiddjeaifefdbbidddfcicjjfcbaf(I):
  obj = first(objects(I, False, False, False))
  center_i, center_j = centerofmass(obj)
  direction = branch(
      center_j < len(I[0]) // 2, RIGHT,  # Left half: shift right
      branch(
          center_i < len(I) // 2, DOWN,   # Top half: shift down
          branch(
              center_j > len(I[0]) // 2, LEFT, # Right half: shift left
              UP                               # Otherwise: shift up
          )
      )
  )
  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
3.0, 2.9416885, def abjffcgbcdhdeicfigaefjaigjibgjbd(I):
  obj = first(objects(I, False, False, False))
  bg = mostcolor(I)
  shifted_grid = paint(canvas(bg, shape(I)), shift(obj, (0, 1)))  # Attempt shift right
  O = branch(
      equality(I, cover(shifted_grid, obj)),  # If shift right successful
      shifted_grid,
      paint(canvas(bg, shape(I)), shift(obj, (1, 0))) # Else, shift down
  )
  return O
 
4.25, 3.3949645, def hbbbegbffjhiecgaiaaccacaifcedhfc(I):
  obj = first(objects(I, False, False, False))
  directions = ((0, 1), (1, 0), (0, -1), (-1, 0)) # Right, Down, Left, Up
  for direction in directions:
    shifted_obj = shift(obj, direction)
    new_grid = paint(cover(I, obj), shifted_obj)
    if len(objects(new_grid, False, False, False)) == 1:  # Valid shift if only one object remains
      return new_grid
  return I  # Return original if no valid shift found
 
3.75, 6.847293, def gedaafhfaadfeaeaidebdbibcfchjjdb(grid):
  h, w = len(grid), len(grid[0])
  for value, direction in [(9, LEFT), (6, DOWN), (2, RIGHT)]:
    for i, j in ofcolor(grid, value):
      new_i = (i + direction[0]) % h
      new_j = (j + direction[1]) % w
      grid = paint(cover(grid, {(value, (i, j))}), {(value, (new_i, new_j))})
  return grid
 
8.0, 45.960762, def cfedfjbbdhfbehgdbdhfdaabbdgijgeh(I):
  top = vsplit(I, 2)[0]
  bottom = vsplit(I, 2)[1]
  left_top = hsplit(top, 2)[0]
  right_top = hsplit(top, 2)[1]
  left_bottom = hsplit(bottom, 2)[0]
  right_bottom = hsplit(bottom, 2)[1]
  return vconcat(hconcat(left_top, left_bottom), hconcat(right_bottom, right_top))
 
3.25, 3.2118728, def jebgdbigbeabedcgidcajgbjcfbiefee(I):
  objs = fgpartition(I)
  shifted_objs = frozenset()
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
      -1 if uppermost(obj) != 0 else 0,  # Shift up if not in top row
      1 if leftmost(obj) == w - 1 else -1 # Shift right if in rightmost column, else left
    )
    shifted_objs = shifted_objs.union(frozenset({shift(obj, shift_amount)}))
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
4.0, 8.079947, def ageidcfbfijaecjfiecicfadebgecehg(I):
  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        new_i = i - 1 if i != 0 else i
        new_j = j + 1 if j == w - 1 else j - 1
        O = paint(O, {(I[i][j], (new_i, new_j))})
  return O
 
4.0, 3.3481727, def facbeaebdieaeabhbgcgbadgbjcceede(grid):
  objs = objects(grid, univalued=True, diagonal=False, without_bg=False)
  transformed_objs = frozenset()
  for obj in objs:
    if color(obj) == 9:
      transformed_objs = transformed_objs | {shift(obj, (0, -1))}
    elif color(obj) == 6:
      transformed_objs = transformed_objs | {shift(obj, (-1, 0))}
    elif color(obj) == 2:
      transformed_objs = transformed_objs | {shift(obj, (0, 1))}
    else:
      transformed_objs = transformed_objs | {obj}
  O = paint(canvas(mostcolor(grid), shape(grid)), merge(transformed_objs))
  return O
 
3.5, 2.5129204, def djchbajedafeeejeihfebafjcdfhfcfg(grid):
  for digit, direction in [(9, (0, -1)), (6, (-1, 0)), (2, (0, 1))]:
    if (digit == 9 and digit in merge(grid)) or \
       (digit == 6 and digit in grid[-1]) or \
       (digit == 2 and digit in merge(tuple(grid[i][:1] for i in range(len(grid))))):
      grid = paint(canvas(mostcolor(grid), shape(grid)), shift(asobject(grid), direction))
  return grid
 
4.5, 2.8340456, def daeeaaagbeddedcdaaabddbecfhfacgg(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (val == 9 or val == 2) and j == 0: # Leftmost column condition for 9 and 2
        O = paint(cover(O, {(val, (i, j))}), {(val, (i - 1, j))}) # Upward shift
      elif val == 6 and j == len(row) - 1: # Rightmost column condition for 6
        O = paint(cover(O, {(val, (i, j))}), {(val, (i + 1, j))}) # Downward shift
  return O 
 
3.5, 16.450521, def gfiidcfjgieaecbjjciechghiecaehjh(I):
  O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for obj in objects(I, T, F, T):
    c = color(obj)
    if c == 9:
        O = paint(O, shift(obj, (-1,0))) # Paint shifted object upwards
    elif c == 6:
        O = paint(O, shift(obj, (1, len(I[0])-1-rightmost(obj)))) # Rightmost column down
    elif c == 2:
        O = paint(O, shift(obj, (1, -leftmost(obj)))) # Leftmost column down
  return O 
 
4.0, 3.3852632, def bbccafadbedeefagbaibeagjcedbffaa(I):
  h, w = height(I), width(I)
  O = canvas(mostcolor(I), (h, w))
  tl = asobject(crop(I, ORIGIN, (h // 2, w // 2)))
  tr = asobject(crop(I, (0, w // 2), (h // 2, w - w // 2)))
  bl = asobject(crop(I, (h // 2, 0), (h - h // 2, w // 2)))
  br = asobject(crop(I, (h // 2, w // 2), (h - h // 2, w - w // 2)))
  O = paint(O, shift(bl, (0, 0))) # BL to TL
  O = paint(O, shift(br, (0, w // 2))) # BR to TR
  O = paint(O, shift(tl, (h // 2, 0))) # TL to BL
  O = paint(O, shift(tr, (h // 2, w // 2))) # TR to BR
  return O
 
4.25, 5.7506886, def fchcdabfejaeedceaebcbagccibdaacd(I):
    bg = mostcolor(I)
    objs = objects(I, T, F, F)
    target_obj = argmax(objs, size)
    direction = position(asobject(I), target_obj)
    shifted_bg = shift(asindices(I), direction)
    O = paint(fill(I, bg, shifted_bg), target_obj)
    return O
 
4.5, 3.254184, def edcdifeceiaceheejjegcecefacjiahb(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  shifted_indices = difference(asindices(I), backdrop(target_obj))
  shifted_bg = apply(lambda ind: add(ind, position(asobject(I), target_obj)), shifted_indices)
  O = paint(fill(I, bg, shifted_bg), target_obj)
  return O
 
4.25, 3.956308, def jccefbddaffeegbjajeeajedabeidbjf(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  direction = position(asobject(I), target_obj)
  O = paint(fill(I, bg, apply(lambda idx: add(idx, direction), delta(target_obj))), target_obj)
  return O
 
4.25, 3.902093, def bjacahehaadgegjjjdeecbdjbcfifcgj(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  c = center(target_obj)
  shifted_bg = frozenset((i + (1 if c[0] > 1 else -1) if j == c[1] else i, j + (1 if c[1] > 1 else -1) if i == c[0] else j) for i, j in asindices(I))
  O = paint(fill(I, bg, shifted_bg), target_obj)
  return O
 
4.5, 2.9616847, def ieaidaffcgacefjcacdagdffejbdcefd(grid):
  for value, direction in [(9, (1, 0)), (6, (0, 1)), (2, (-1, 0))]:  
    grid = paint(cover(grid, recolor(mostcolor(grid), ofcolor(grid, value))),
                  shift(recolor(value, ofcolor(grid, value)), direction))
  return grid
 
4.25, 3.6096945, def facdfbefiebdecidbbaccfgaiabjafaf(grid):
  h, w = len(grid), len(grid[0])
  return tuple(
      tuple(
          grid[(i + (1 if cell == 9 else -1 if cell == 2 else 0)) % h]
              [(j + (1 if cell == 6 else 0)) % w] 
          for j, cell in enumerate(row)
      )
      for i, row in enumerate(grid)
  )
 
3.25, 2.4692116, def bgacaicjfjhgeaeiafiebcacafbffadd(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate the difference between the object's center of mass and the grid's center
  h, w = len(I), len(I[0])
  ci, cj = centerofmass(largest_obj)
  center_diff = (ci - h // 2, cj - w // 2)

  # Determine the move direction based on the quadrant of the difference
  direction = (
      (0, -1) if center_diff[1] > abs(center_diff[0]) else 
      (0, 1) if -center_diff[1] > abs(center_diff[0]) else
      (-1, 0) if center_diff[0] > abs(center_diff[1]) else
      (1, 0) 
  )

  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
4.0, 5.4391356, def iadaaifdadedeecbaaafiabdccedfcfc(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Calculate distances from the object's center of mass to each edge
  h, w = len(I), len(I[0])
  ci, cj = centerofmass(largest_obj)
  distances = [(ci, UP), (h - 1 - ci, DOWN), (cj, LEFT), (w - 1 - cj, RIGHT)]

  # Find the closest edge with a preference for vertical movement
  min_distance = min(distances)
  closest_edge = next((d[1] for d in distances if d[0] == min_distance[0]), DOWN)

  # Move the object
  O = move(I, largest_obj, closest_edge)
  return O
 
3.75, 4.598171, def chcdafajddgbecadacfcbfaadfjebdhh(I):
  # Identify objects and the largest one
  objs = objects(I, T, F, T)
  largest_obj = argmax(objs, size)

  # Determine if the object is mostly on the left or right half of the grid
  h = len(I[0]) // 2
  left_count = sum(1 for _, (i, j) in largest_obj if j < h)
  right_count = len(largest_obj) - left_count

  # Define shift direction based on object's majority position
  direction = LEFT if left_count >= right_count else RIGHT

  # Move the object
  O = move(I, largest_obj, direction)
  return O
 
4.0, 3.0553088, def dbgbedfdjddheffjiabdfeeehcadjajj(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  transformed_objs = frozenset()
  for obj in objs:
    c = color(obj)
    if c == mostcolor(I):
        transformed_objs = transformed_objs.union({obj})
    else:
        h_mirrored = hmirror(obj)
        v_mirrored = vmirror(obj)
        transformed_objs = transformed_objs.union({
            frozenset((v, (i,j)) for v,(i,j) in h_mirrored if j <= rightmost(obj)),
            frozenset((v, (i,j)) for v,(i,j) in v_mirrored if i <= lowermost(obj))
        })
  O = canvas(mostcolor(I), shape(I))
  for obj in transformed_objs:
    O = paint(O, obj)
  return O
 
4.75, 4.9928756, def ffjfgaadebheeicfbdhbbdcfiaddedac(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] != mostcolor(I):
        O = paint(O, {(I[i][j], (i, j))})
        O = paint(O, {(I[i][j], (i, width(I) - j - 1))})
        O = paint(O, {(I[i][j], (height(I) - i - 1, j))})
  return O
 
4.0, 5.7617393, def ihbbjiajdedeejafaebhadbjhcjabgcc(I):
  h, w = height(I), width(I)
  O = [[mostcolor(I) for _ in range(w)] for _ in range(h)]
  for i in range(h // 2 + h % 2):
    for j in range(w // 2 + w % 2):
      if I[i][j] != mostcolor(I):
        O[i][j] = I[i][j]
        O[i][w - j - 1] = I[i][j]
        O[h - i - 1][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
7.0, 46.541954, def gcfbfciegedaebchabdfjgbdihbcdhfa(I):
  O = hconcat(lefthalf(I), hmirror(lefthalf(I)))
  return vconcat(tophalf(O), vmirror(tophalf(O)))
 
6.5, 27.303234, def ebebccdbbfgbeiefafdddfjacebbaagc(I):
  return rot180(hconcat(lefthalf(rot180(I)), hmirror(lefthalf(rot180(I)))))
 
3.5, 10.123281, def iegeabaabchieefaicbdeeeecfhhaade(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_obj = argmax(objs, size)
  move_direction =  (
    1 if center(target_obj)[1] < len(I[0]) // 2 else -1, 
    1 if center(target_obj)[0] < len(I) // 2 else -1
  )
  shifted_obj = shift(target_obj, move_direction)
  O = paint(fill(I, bg, asindices(I)), shifted_obj)
  return O
 
3.5, 8.759491, def hecejchceejdeceiichbdgdaedgbbjia(I):
  # Find the least common color
  c = leastcolor(I)
  # Find the object with the least common color
  obj = toobject(ofcolor(I, c), I)
  # Define target position based on original object's position
  target = lrcorner(obj) if uppermost(obj) == 0 else ulcorner(obj)
  # Move the object
  O = paint(cover(I, obj), recolor(c, (target,)))
  return O
 
3.5, 7.9264507, def aacgcgfdfbfcedbhafccbghggcfjedgh(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  # Calculate target position using conditional logic
  target = (
    (len(I)-1, len(I[0])-1) if uppermost(obj) == 0 else
    (0, len(I[0])-1) if uppermost(obj) != 0 and leftmost(obj) == 0 else 
    (len(I)-1, 0)
  )
  O = paint(cover(I, obj), recolor(c, (target,)))
  return O
 
4.75, 2.8220701, def dfcbabafifddecdaidjabcffbbcjbebh(grid):
  objs = objects(grid, univalued=True, diagonal=False, without_bg=False)
  return paint(canvas(mostcolor(grid), shape(grid)),
              merge({shift(obj, 
                           (0, 1) if color(obj) == 9 else
                           (0, 1) if color(obj) == 6 else
                           (1, 0) if color(obj) == 9 else
                           (1, 0) if color(obj) == 2 else
                           (0, 0))
                    for obj in objs}))
 
4.25, 3.1696606, def dahbdcdcfaejeabhaefhdaiebjbeafed(grid):
  out = canvas(mostcolor(grid), shape(grid))
  for obj in objects(grid, univalued=True, diagonal=False, without_bg=False):
    color_obj = color(obj)
    direction = (0, 1) if color_obj in (9, 6) else (1, 0) if color_obj in (9, 2) else (0, 0)
    out = paint(out, shift(obj, direction))
  return out
 
6.25, 8.583097, def ecabceagedaaeeaaaicdcigccbfdiebg(grid):
  grid = replace(grid, 9, -1) # Temporarily mark '9' for movement
  grid = replace(grid, 6, -2) # Temporarily mark '6' for movement
  grid = replace(grid, 2, -3) # Temporarily mark '2' for movement
  h, w = len(grid), len(grid[0])
  out = canvas(mostcolor(grid), (h, w))
  for i in range(h):
    for j in range(w):
      color_ij = grid[i][j]
      new_i, new_j = i, j
      if color_ij == -1: 
        new_j = j + 1 if j < w - 1 else j
        new_i = i + 1 if i < h - 1 else i
      elif color_ij == -2:
        new_j = j + 1 if j < w - 1 else j
      elif color_ij == -3:
        new_i = i + 1 if i < h - 1 else i
      if 0 <= new_i < h and 0 <= new_j < w:
        out = paint(out, {(9 if color_ij == -1 else 6 if color_ij == -2 else 2 if color_ij == -3 else color_ij , (new_i, new_j))})
  return out
 
4.25, 3.4880152, def djbacfddeaehecedbjccejgggcfhcffa(grid):
  for color_to_move, direction in [(9, (0, 1)), (6, (0, 1)), (2, (1, 0)), (9, (1, 0))]:
    grid = paint(cover(grid, recolor(mostcolor(grid), ofcolor(grid, color_to_move))), 
                  shift(recolor(color_to_move, ofcolor(grid, color_to_move)), direction))
  return grid 
 
3.0, 3.6852436, def fbebafcefbdjedfbbcecfdhfcbcdhfhf(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    h, w = shape(obj)
    ci, cj = center(obj)
    hi = (height(I) - 1) // 2
    wj = (width(I) - 1) // 2
    ni = ci if ci <= hi else max(0, ci - h)
    nj = cj if cj <= wj else max(0, cj - w)
    O = paint(O, shift(obj, (ni - ci, nj - cj)))
  return O
 
3.5, 3.5654593, def debajedfadfeeeeeachdafabbgcejgdf(I):
    objs = sorted(objects(I, T, F, T), key=size, reverse=True)
    bg = mostcolor(I)
    O = canvas(bg, shape(I))
    for i, obj in enumerate(objs):
        if i == 0:
            target = (0, 0)
        elif i == 1:
            target = (height(I) - height(obj), 0)
        else:
            target = (0, width(I) - width(obj))
        O = paint(O, shift(obj, subtract(target, ulcorner(obj))))
    return O
 
4.5, 5.4620786, def cdbebcdafifieaihjfcacaffcaejaccb(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    O = move(O, obj, gravitate(obj, ((0,0), (0,1))))
    O = move(O, obj, gravitate(obj, ((height(O) - 1, 0), (height(O) - 1, 1))))
  return O
 
4.5, 6.149076, def acdaaefadgjcecddaeecfbbfdajhdefa(I):
  mc = mostcolor(I)
  shifted = shift(ofcolor(I, mc), (-1, 0)) # Shift upwards
  O = paint(canvas(0, shape(I)), recolor(mc, shifted))
  return cellwise(O, I, 0) # Retain original non-shifted colors
 
4.75, 4.487924, def abbeaedefiacediaahbeaagiaacfchcd(I):
  mc = mostcolor(I)
  O = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == mc and i > 0: # Shift only if not in top row
        O = paint(O, {(mc, (i-1, j))})
      else:
        O = paint(O, {(val, (i, j))})
  return O
 
4.0, 11.5832815, def djjibbdaafacebbcjghhbceahidfeadj(I):
  mc = mostcolor(I)
  shifted_obj = shift(recolor(mc, asindices(I)), (-1, 0)) # Shift all indices upwards
  O = paint(canvas(0, shape(I)), shifted_obj)
  return cellwise(O, I, mc) # Overwrite shifted positions with original values
 
4.75, 5.3525534, def egcddabfjceeeabgbcffbiaeejeahbcb(I):
  mc = mostcolor(I)
  O = I
  for i in range(1, len(I)): # Start from second row
    for j in range(len(I[0])):
      if O[i][j] == mc:
        O = paint(cover(O, {(mc, (i, j))}), {(mc, (i-1, j))}) # Shift and cover previous position
  return O
 
3.75, 4.9649243, def hbfffefhfbaiebjfibifdifibiidedbe(I):
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  target_color = leastcolor(I) if len(palette(I)) > 1 else bg
  target_obj = extract(objs, matcher(color, target_color))
  direction = position(asobject(I), target_obj)
  shifted_obj = shift(target_obj, direction)
  O = paint(fill(I, bg, toindices(target_obj)), shifted_obj)
  return O
 
3.75, 3.6234062, def icdcddfaeefieeddjijbeafffbcbgiad(I):
  O = I
  for c in palette(I) - {mostcolor(I)}:
    obj = extract(objects(I, T, F, F), matcher(color, c))
    center_obj = center(obj)
    center_grid = (len(I) // 2, len(I[0]) // 2)
    direction = (sign(center_obj[0] - center_grid[0]), sign(center_obj[1] - center_grid[1]))
    O = paint(fill(O, mostcolor(I), toindices(obj)), shift(obj, direction))
  return O
 
3.5, 2.9632115, def heeajcebdacfeafgbddeigehajdahcia(I):
  O = I
  for obj in objects(I, T, F, T):
    if bordering(obj, I):
      direction = (sign(len(I) // 2 - center(obj)[0]), sign(len(I[0]) // 2 - center(obj)[1]))
      O = paint(fill(O, mostcolor(I), toindices(obj)), shift(obj, direction))
  return O
 
2.75, 3.5095346, def fgdjabcfdfcdejgaifiibhbaddcdbebd(I):
  c = leastcolor(I)  # Get the least common color
  obj = toobject(ofcolor(I, c), I)  # Get the object
  
  # Determine shift direction based on object's position
  direction = branch(
      uppermost(obj) == 0,
      DOWN,  # Shift down if at the top
      branch(
          leftmost(obj) == 0,
          RIGHT,  # Shift right if at the left edge
          LEFT   # Otherwise shift left
      )
  )
  
  shifted_obj = shift(obj, direction)  # Shift the object
  O = paint(cover(I, obj), shifted_obj)  # Update the grid
  return O
 
3.75, 2.2361803, def bgifahfhbgddeddcjaefeegagagedbjd(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  
  # Calculate center of mass for shift direction
  center_j = centerofmass(obj)[1]
  grid_center_j = len(I[0]) // 2
  
  direction = branch(center_j < grid_center_j, RIGHT, LEFT)  
  
  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
4.75, 3.6048563, def dcddcihbjdgbecadjagcdeacejjdciji(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)

  # Utilize gravitate function for shift direction and magnitude
  h, w = len(I), len(I[0])
  target = {(h // 2, w // 2)} # Target is the center of the grid
  
  direction = gravitate(toindices(obj), target)  

  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
6.0, 19.443592, def djcfecdhjeaceeffahfedifdhcbgbdde(I):
  bg = mostcolor(I)
  h = height(I)
  for j in range(width(I) - 1, -1, -1):
    column = tuple(I[i][j] for i in range(h))
    if all(v == bg for v in column):
      shifted = hconcat(crop(I, (0, j), (h, 1)), crop(I, (0, 0), (h, j)))
      return shifted
  return I
 
5.25, 19.20636, def efegefcffaeheaheahjjgfcffcfjehaa(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=False)
  bg = mostcolor(I)
  bg_obj = extract(objs, lambda obj: color(obj) == bg)
  column = astuple(uppermost(bg_obj), rightmost(bg_obj))
  h, w = shape(I)
  shifted = hconcat(crop(I, (0, column[1]), (h, 1)), crop(I, (0, 0), (h, column[1]))) if column[1] != w - 1 else I
  return shifted
 
2.5, 2.124111, def afgaeidahcjaegeejfefbdedaaaffdea(I):
    c = leastcolor(I)
    obj = toobject(ofcolor(I, c), I)
    h, w = len(I), len(I[0])
    center_i, center_j = centerofmass(obj)
    direction = branch(
        center_i < h // 2 and center_j < w // 2, # Top-left quadrant
        DOWN,
        branch(
            center_i < h // 2 and center_j >= w // 2, # Top-right quadrant
            RIGHT,
            LEFT  # Bottom half
        )
    )
    O = paint(cover(I, obj), shift(obj, direction))
    return O
 
3.0, 4.567604, def eiabeafajedbejfjbjaefjccfcebiafh(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  direction = (
    branch(uppermost(obj) == 0, 1, 0), # Vertical movement
    branch(leftmost(obj) == 0 and uppermost(obj) != 0, 1, -1) # Horizontal movement
  )
  return paint(cover(I, obj), shift(obj, direction))
 
3.25, 3.5737395, def ibacbhjdgecgeacjibdcjajaaaddgceb(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  return paint(
      cover(I, indices), 
      shift(
          toobject(indices, I), 
          (
              1 if any(i == 0 for i, _ in indices) else 0, # Downward shift
              1 if any(j == 0 for _, j in indices) and any(i != 0 for i, _ in indices) else -1 # Rightward or leftward shift 
          )
      )
  ) 
 
2.5, 3.3389266, def cgdibcdgaejbehidajghfeibbdcagbdi(I):
  obj = first(objects(I, False, False, True)) 
  bg = mostcolor(I)
  ulx, uly = ulcorner(obj)
  lrx, lry = lrcorner(obj)
  direction = (-1, 0) if lrx - ulx < lry - uly else (0, 1) if lrx - ulx > lry - uly else (1, 0)
  shifted_obj = shift(obj, direction) 
  O = paint(cover(I, obj), shifted_obj)  
  return O
 
2.75, 2.850982, def fachffdfdbehefidaibebdageegeidgc(I):
  obj = first(objects(I, False, False, True))
  bg = mostcolor(I)
  h, w = shape(I)
  shifted_obj = shift(obj, (1, 0))  
  cond = any(0 <= i < h and 0 <= j < w and I[i][j] != bg for _, (i, j) in shifted_obj)
  O = branch(cond, shifted_obj, shift(obj, (0, 1))) 
  O = paint(cover(I, obj), O) 
  return O
 
3.75, 5.102312, def dehiaaebefcfeedejiefbcibdabcdfad(I):
  # Identify the least common color (target object color)
  target_color = leastcolor(I)  
  
  # Get objects of the target color
  objs = colorfilter(objects(I, T, F, T), target_color) 

  # Initialize output grid with background color
  O = canvas(mostcolor(I), shape(I))

  for obj in objs:
    # Calculate target position based on object's center
    ci, cj = center(obj)
    target_i = height(I) - height(obj) if ci > height(I) // 2 else 0
    target_j = width(I) - width(obj) if cj > width(I) // 2 else 0
    
    # Shift and paint object onto output grid
    O = paint(O, shift(obj, (target_i - ci, target_j - cj)))

  return O
 
4.5, 5.021864, def bdefegcafecbefefaabjebbeafhfebbe(I):
  # Identify target color 
  target_color = leastcolor(I)

  # Create output grid with objects moved to corners 
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == target_color:
        # Calculate target position
        target_i = height(I) - 1 if i > height(I) // 2 else 0
        target_j = width(I) - 1 if j > width(I) // 2 else 0
        O = paint(O, {(val, (target_i, target_j))})
  return O
 
3.0, 3.6183066, def fibhfbbiahbjehebjegafddfccfjcdfe(I):
  objs = fgpartition(I)
  shifted_objs = frozenset()
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
      1 if uppermost(obj) == 0 else -1,
      -1 if leftmost(obj) == w - 1 else 1
    )
    shifted_objs = shifted_objs.union(frozenset({shift(obj, shift_amount)}))
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
2.75, 3.621873, def faadcbheabebedcfieecehbecjfbdgfb(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
      -1 if uppermost(obj) != 0 else 1, 
      1 if leftmost(obj) == w - 1 else -1
    )
    O = paint(O, shift(obj, shift_amount))
  return O
 
3.5, 5.639319, def fhicdbdajechedcfjgfcgbcbbfhchfii(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        new_i = (i - 1) if i != 0 else (i + 1)
        new_j = (j + 1) if j == (w - 1) else (j - 1)
        O = fill(O, I[i][j], {(new_i, new_j)})
  return O
 
5.75, 2.6538503, def ifdchegjbbfjeeidaeagafcbaiacdcbh(I):
  x1 = switch(I, ZERO, NINE)
  O = dmirror(x1)
  return O
 
4.25, 2.1800058, def decefebbjigaebedjicaejdidededihd(I):
    O = branch(
        equality(mostcolor(I), SIX),
        switch(I, ZERO, SIX),
        branch(
            equality(mostcolor(I), NINE),
            switch(dmirror(I), ZERO, NINE),
            branch(
                equality(mostcolor(I), TWO),
                switch(hmirror(I), astuple(0, 2), astuple(2, 0)),
                I
            )
        )
    )
    return O
 
3.75, 6.8511043, def jfdcdbaeffaheahbbeaefdbjghdaaieg(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)
  
  # Calculate center of mass of the object
  center_i, center_j = centerofmass(smallest_obj)

  # Determine shift direction based on quadrant
  h, w = len(I), len(I[0])
  shift_direction = (
      -1 if center_i < h // 2 else 1,
      -1 if center_j < w // 2 else 1
  )

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 3.5654593, def fbcbhddbiihjehgebeiciggfhfchddab(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)
  
  # Get the upper-left corner of the object
  corner_i, corner_j = ulcorner(smallest_obj) 

  # Determine shift direction to top-left
  shift_direction = (-corner_i, -corner_j)

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.25, 2.8233345, def fcffgbfhfafdehhbihcdgehegifejcha(I):
  # Find the smallest object
  objs = objects(I, T, F, T)
  smallest_obj = argmin(objs, size)

  # Find the largest object 
  largest_obj = argmax(objs, size)

  # Calculate the relative position of the smallest object to the largest
  rel_pos = position(smallest_obj, largest_obj)

  # Determine shift direction
  shift_direction = (sign(rel_pos[0]), sign(rel_pos[1]))

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 1.9166573, def ecjcbbbadedgeecibehcbcebjdhfadde(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)

  # Calculate the bounding box of the smallest object
  bbox = backdrop(smallest_obj)

  # Find the corner closest to the object's center of mass
  com = centerofmass(smallest_obj)
  closest_corner = argmin(corners(bbox), lambda c: manhattan(initset(c), initset(com)))

  # Determine the shift direction towards the closest corner
  shift_direction = subtract(closest_corner, com)

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 3.106159, def hcffaihgfagdeaebbccbfdehaheecejg(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)
  
  # Get the coordinates of any cell in the smallest object
  cell_i, cell_j = first(toindices(smallest_obj))

  # Determine shift direction towards the top-left corner
  shift_direction = (-cell_i, -cell_j)

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 3.5654593, def egdbebfaheefeifaahbedhdifcebfegd(I):
  obj = first(objects(I, False, False, True))
  bg = mostcolor(I)
  ulx, uly = ulcorner(obj)
  O = paint(cover(I, obj), shift(obj, (-ulx, -uly)))
  return O
 
4.0, 3.721064, def eadggiaebeiheceaibeiaedidhgahcff(I):
  obj = first(objects(I, False, False, True))
  O = paint(I, normalize(obj))
  return O
 
4.5, 4.177249, def cfadbeadfdfceafeiajceefacaaaegcg(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  for obj in objs:
    ci, cj = center(obj)
    obj = hmirror(obj) if ci > height(I) // 2 else obj
    obj = vmirror(obj) if cj > width(I) // 2 else obj
    O = paint(O, obj)
  return O
 
4.25, 6.5739923, def ecfbgabcjdgaecfhbbiabejjeifciacj(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      source_i = i if i <= h // 2 else h - i - 1
      source_j = j if j <= w // 2 else w - j - 1
      O = paint(O, {(I[source_i][source_j], (i, j))})
  return O
 
3.5, 16.450521, def ebcgifhfehbfeddajdefgdccacifgfeh(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  def transform_cell(i, j):
    target_i = i if i <= h // 2 else h - i - 1
    target_j = j if j <= w // 2 else w - j - 1
    return paint(O, {(I[target_i][target_j], (i, j))})
  return last(prapply(transform_cell, *pair(astuple(0, h), astuple(0, w))))
 
3.5, 3.5654593, def idffdafbhdheebegjdfedejeacfgacdc(I):
  objs = fgpartition(I)
  shifted_objs = frozenset()
  for obj in objs:
    shift_amount = (-1, 0) if uppermost(obj) != 0 else (0, -1) if leftmost(obj) != 0 else (0, 0)
    shifted_objs = shifted_objs.union(frozenset({shift(obj, shift_amount)}))
  return paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
 
4.5, 4.088639, def gbeaihfgecddebfijfcceidgffbjgaai(I):
  h, w = shape(I)
  return tuple(tuple(I[i-1][j] if i > 0 and I[i-1][j] != mostcolor(I)
                 else I[i][j-1] if j > 0 and I[i][j-1] != mostcolor(I)
                 else mostcolor(I)
                 for j in range(w))
            for i in range(h))
 
4.5, 3.254184, def jbghcfbccacdefcijdecdcfjiahjagdh(I):
  return vconcat(
    hconcat(lefthalf(I), 
            crop(I, (0, 1), (len(I)//2, len(I[0])-1))), 
    hconcat(crop(I, (len(I)//2, 0), (len(I)-len(I)//2, 1)),
            crop(I, (len(I)//2, 1), (len(I)-len(I)//2, len(I[0])-1))))
 
4.25, 3.0082421, def fijjbfdcceafeiahajffijahjgdddfcf(I):
  return tuple(
      tuple(
          I[max(0, i - (1 if j != 0 else 0))][max(0, j - (1 if i == 0 else 0))]
          for j in range(len(I[0]))
      )
      for i in range(len(I))
  )
 
4.75, 3.9920309, def aefjcfgaheccecdbiieccebhdbdeabga(I):
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    transformed_objs = set()
    for obj in objs:
        color_val = color(obj)
        ul = ulcorner(obj)
        if color_val == 0 and ul == (0, 0): # Top-left corner object
            transformed_objs.add(recolor(9, hmirror(obj)))
        elif color_val == 6 and ul[0] == 0: # Top object with color 6
            transformed_objs.add(paint(hmirror(obj), {(6, (1, 1)), (6, (1, 2))}))
        elif color_val == 2 and ul == (1, 1): # Bottom-right corner object with color 2
            transformed_objs.add(vmirror(obj))
        else: 
            transformed_objs.add(hmirror(obj)) 
    O = paint(canvas(mostcolor(I), shape(I)), merge(transformed_objs))
    return O 
 
4.0, 8.284732, def ccaeehaacadbecaabbifadfgcbdcigbd(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, T), size)

  # Calculate center of the object's bounding box
  center_i, center_j = center(largest_obj)

  # Determine the shift direction based on the center position
  h, w = len(I), len(I[0])
  shift_direction = (
      -1 if center_i <= h // 2 else 1, 
      -1 if center_j <= w // 2 else 1
  )

  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 3.4418385, def dffedabibeaaedjdbefcfjecddaebaaf(I):
  # Find the least common color
  target_color = leastcommon(sum(I, ()))

  # Find the object with the least common color
  target_obj = extract(objects(I, T, F, T), lambda obj: color(obj) == target_color)

  # Determine the shift direction based on grid dimensions
  h, w = len(I), len(I[0])
  shift_direction = (
      -1 if h > w else 1,
      -1 if w > h else 1
  )

  # Move the target object
  O = move(I, target_obj, shift_direction)
  return O
 
3.75, 8.043275, def eefdafffgabbegajagdddaijebcdddai(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)

  # Calculate the center of mass of the object
  obj_center = centerofmass(smallest_obj)

  # Calculate the center of the grid
  grid_center = (len(I) // 2, len(I[0]) // 2)

  # Calculate the relative position of the object's center to the grid's center
  shift_direction = (
      1 if obj_center[0] > grid_center[0] else -1,
      1 if obj_center[1] > grid_center[1] else -1
  )

  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
4.25, 4.84184, def giefcedgcibbedajjbhechfcjdafffaa(I):
    objs = objects(I, False, False, True)
    bg = mostcolor(I)
    shifted_objs = frozenset({shift(obj, (-1,0)) for obj in objs})
    wrapped_objs = frozenset({frozenset({(v, (i, len(I[0])-1)) if j == -1 else (v, (i,j)) for v, (i, j) in obj}) for obj in shifted_objs})
    O = paint(canvas(bg, shape(I)), merge(wrapped_objs))
    return O
 
4.5, 2.9523618, def eajeiecfbgjdeaefadicgedadeehejeb(I):
    h, w = len(I), len(I[0])
    O = tuple(tuple(I[i][(j+w-1)%w] for j in range(w)) for i in range(h))
    return O
 
4.25, 7.1190557, def ahcdddebecdeeaecjigbafaaebhcdiia(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  O = paint(canvas(bg, shape(I)), merge({branch(
        leftmost(obj) == 0,
        shift(obj, (0, len(I[0]) - 1)),  
        shift(obj, (-1, 0))
    ) for obj in objs}))
  return O
 
4.25, 6.995281, def dajidbaagechejiebdifbiaidcjcefbb(I):
    bg = mostcolor(I)
    shifted_grid = paint(canvas(bg, shape(I)), shift(asobject(I), (-1, 0)))
    wrapped_grid = cellwise(shifted_grid, I, bg)
    O = wrapped_grid
    return O
 
4.25, 4.1457024, def cbjcffadfdcdebjeibefgehdbacceccd(I):
  h, w = shape(I)
  bg = mostcolor(I)
  shifted = rot90(I) if portrait(I) else rot270(I)
  wrapped = tuple(
    tuple(v if v != bg else r[(j-1)%w] for j, v in enumerate(r))
    for r in shifted
  )
  O = rot270(wrapped) if portrait(I) else rot90(wrapped)
  return O
 
5.25, 3.6305618, def ceeaecajihifejegiedacecdafedecfe(I):
  h, w = shape(I)
  bg = mostcolor(I)
  O = tuple(
    tuple(
      I[i][(j-1)%w] if I[i][j] == bg else I[i][j] 
      for j in range(w)
    )
    for i in range(h)
  ) if not portrait(I) else tuple(
    tuple(
      I[(i-1)%h][j] if I[i][j] == bg else I[i][j] 
      for j in range(w)
    )
    for i in range(h)
  )
  return O
 
3.25, 4.0747733, def bcaffcbcffgaecbgijcgfefehcaeccec(I):
  return paint(canvas(mostcolor(I), shape(I)),
               merge(apply(lambda obj: shift(obj, 
                                                (-1 if uppermost(obj) != 0 else 0, 
                                                 1 if rightmost(obj) == len(I[0]) - 1 else -1)),
                           fgpartition(I))))
 
3.5, 2.7898853, def dfdcabfagefhejfdjhcddicdffjehbdb(grid):
  h = height(grid)
  w = width(grid)
  bg = mostcolor(grid)
  if h > w:
    line = toobject(vfrontier((w-1,0)), grid)
    return paint(paint(grid, recolor(bg, vfrontier((0,0)))), shift(line, (-w+1,0)))
  else:
    line = toobject(hfrontier((0,w-1)), grid)
    return paint(paint(grid, recolor(bg, hfrontier((h-1,0)))), shift(line, (0,-w+1)))
 
4.5, 3.4957588, def fdcbhffcbbcfedcdibcabehfadbeecac(I):
  # Find the least common color
  target_color = leastcolor(I)

  # Modify the grid directly by replacing the target color and its shifted instances
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == target_color:
        # Shift up and left, handling boundary cases
        new_i, new_j = max(i-1, 0), max(j-1, 0)
        O = paint(cover(O, {(target_color, (new_i, new_j))}), {(target_color, (i, j))})
  return O
 
3.5, 3.9807186, def fjedbfdfdbddefjdicceabcibfcibjic(I):
  # Create a new grid by shifting relevant cells
  O = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if colorcount(I, value) == colorcount(I, leastcolor(I)):
        # Shift cell up and left, handling boundaries
        new_i, new_j = max(i-1, 0), max(j-1, 0)
        O = paint(O, {(value, (new_i, new_j))})
      else:
        O = paint(O, {(value, (i, j))})
  return O
 
4.0, 3.4981136, def cbagbbecjeibeaabjhbfadbfhdbefjga(I):
    objs = objects(I, False, False, True)
    bg = mostcolor(I)
    shifted_objs = frozenset({shift(obj, (-1,0)) for obj in objs})
    wrapped_objs = frozenset({frozenset({(v, (len(I)-1, j)) if i == -1 else (v, (i,j)) for v, (i, j) in obj}) for obj in shifted_objs})
    O = paint(canvas(bg, shape(I)), merge(wrapped_objs))
    return O
 
3.0, 2.4049468, def fefgfffeebdieejijddfjaffejecbjgf(I):
  h = len(I)
  O = tuple(tuple(I[(i-1)%h][j] for j in range(len(I[0]))) for i in range(h))
  return O
 
4.75, 25.267824, def ccaahcaadbbdebfebdfgacdbdbjebbef(I):
  return rot90(hconcat(righthalf(I), lefthalf(I)))
 
4.75, 5.4035716, def dfhbdehjjadaededadbacbcbfedaaddb(I):
  objs = fgpartition(I)
  shifted_objs = frozenset()
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
        -1 if uppermost(obj) == 0 else 0,
        -w + 1 if rightmost(obj) == w - 1 else 0
    )
    shifted_objs = shifted_objs.union(frozenset({shift(obj, shift_amount)}))
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
4.5, 4.180936, def ddfdhacgcfbfedhaaefgaffcedgcbcdd(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        new_i = (i - 1) % h
        new_j = (j - w + 1) % w
        O = fill(O, I[i][j], {(new_i, new_j)})
  return O
 
4.5, 3.9358594, def cecafaechfgeecdcigabdabffiafaggh(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    for v, (i, j) in obj:
      new_i = (i - 1) % h if uppermost(obj) == 0 else i
      new_j = (j - w + 1) % w if rightmost(obj) == w - 1 else j
      O = fill(O, v, {(new_i, new_j)})
  return O
 
3.5, 8.23611, def gchbehdacjegecefiejfiddebbabhjbb(I):
  h, w = shape(I)
  return  tuple(
            tuple(
                I[(i - 1) % h][(j - w + 1) % w] if I[i][j] != mostcolor(I) else mostcolor(I)
                for j in range(w)
            )
            for i in range(h)
        )
 
4.75, 3.3171806, def dcbfhjcgfbbeecehibaaiecdeigbebic(grid):
  return tuple(tuple(r[(j+1)%len(r)] if r[(j+1)%len(r)] != mostcolor(grid) else r[j] for j in range(len(r))) for r in grid)
 
4.0, 3.0676029, def fcagjfgjdcefebdciadfagfbifaehgha(grid):
  return tuple(tuple(v for v in (r[1:] + r[:1])) if any(c != mostcolor(grid) for c in r) else r for r in grid) 
 
3.75, 7.8751144, def deejgcegcfcdeabbibicjcfcbjabbfgf(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  h, w = len(I), len(I[0])
  return paint(
      cover(I, indices), 
      shift(
          toobject(indices, I), 
          (
              -1 if any(i == 0 for i, _ in indices) else (1 if all(i == h-1 for i, _ in indices) else 0), 
              -1 if any(j == 0 for _, j in indices) else (1 if all(j == w-1 for _, j in indices) else 0)
          )
      )
  )
 
4.0, 4.6185393, def efgdddefahefebdcadbbdacgbgdfddfb(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  return branch(
      uppermost(obj) == 0, 
      paint(cover(I, obj), shift(obj, (-1, 0))),  # Shift up
      branch(
          leftmost(obj) == 0,
          paint(cover(I, obj), shift(obj, (0, -1))),  # Shift left
          branch(
              lowermost(obj) == len(I)-1,
              paint(cover(I, obj), shift(obj, (1, 0))),  # Shift down
              paint(cover(I, obj), shift(obj, (0, 1)))   # Shift right
          )
      )
  )
 
4.25, 6.636207, def bfaijcaijiabeffdibehcfcfdaabcfei(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = shape(I)
  return paint(
      cover(I, obj), 
      shift(obj, (sign(lowermost(obj) - h + 1), sign(rightmost(obj) - w + 1)))
  )
 
4.0, 3.017272, def eafbfddgdcbaeedejhebbcacddcbfcie(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  h, w = len(I), len(I[0])
  vertical_shift = max(1 - 2 * any(i == 0 for i, _ in indices), -1) if any(i == h-1 for i, _ in indices) else 0
  horizontal_shift = max(1 - 2 * any(j == 0 for _, j in indices), -1) if any(j == w-1 for _, j in indices) else 0
  return paint(cover(I, indices), shift(toobject(indices, I), (vertical_shift, horizontal_shift)))
 
4.0, 3.0676029, def ijajahabiiciedfeibhajebedjadhfbj(I):
    obj = first(objects(I, False, False, True))
    bg = mostcolor(I)
    left_border = frozenset((i, 0) for i in range(height(I)))
    wrapped =  frozenset({(v, (i, j-1)) for v, (i, j) in obj if (i,j) not in left_border} | 
                         {(v, (i, width(I)-1)) for v, (i, j) in obj if (i,j) in left_border})
    O = paint(fill(I, bg, obj), wrapped)
    return O
 
3.25, 2.8233345, def jeechecjeifbeeieafaahgbacchjcdic(I):
  obj = first(objects(I, False, False, True))
  bg = mostcolor(I)
  shifted_grid = paint(canvas(bg, shape(I)), shift(obj, (0, -1)))
  O = branch(
      equality(size(objects(shifted_grid, False, False, True)), 1), # Check if the object remained intact after shifting
      shifted_grid,
      paint(canvas(bg, shape(I)), frozenset({(v, (i, width(I)-1)) for v, (i, j) in obj if j==0} | 
                                          {(v, (i, j-1)) for v, (i, j) in obj if j!=0}))
  )
  return O
 
4.75, 3.3591158, def hefbfcgfjceiecfeaiaiaihaegccbiea(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      new_j = (j - 1 if even(j) else j + 1) % w
      O = paint(O, {(I[i][j], (i, new_j))})
  return O
 
5.0, 3.5342386, def iffjhfjcgdcgeidbafabjgfdcfedbheb(I):
  h, w = shape(I)
  return tuple(tuple(I[i][(j - 1 if even(j) else j + 1) % w] for j in range(w)) for i in range(h))
 
3.0, 2.5498328, def jcihbicfbghieaidibdgedfbjicfeaei(I):
  return paint(canvas(mostcolor(I), shape(I)),
               merge(apply(lambda obj: shift(obj, 
                                                (bordering(obj, I) and uppermost(obj) == 0,
                                                 -1 if rightmost(obj) == len(I[0]) - 1 else 1)),
                           fgpartition(I))))
 
3.0, 4.0110745, def gbefbcdecjcdecebiadcbafdjfdbaeff(I):
  return paint(canvas(mostcolor(I), shape(I)),
               merge(apply(lambda obj: branch(rightmost(obj) == len(I[0]) - 1, 
                                              shift(obj, (-1, -1)), 
                                              shift(obj, (bordering(obj, I) and uppermost(obj) == 0, 1))),
                           fgpartition(I))))
 
3.0, 3.241762, def bdajbffgbdbjejidajjiaecaehbhjiif(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    O = paint(O, shift(obj, 
                      (1 if uppermost(obj) == 0 else -1 if rightmost(obj) == w - 1 else 0, 
                       -1 if rightmost(obj) == w - 1 else 1)))
  return O
 
4.5, 2.9523618, def hcbabcafehbjeheibffdifidjfhjdfff(grid):
  return tuple(tuple(v for v in (r[-1:] + r[:-1])) if any(c != mostcommon(grid) for c in r) else r for r in grid)
 
8.25, 81.52617, def iddhaegdaajaeadfbbaeceedeiebaajb(grid):
  return tuple(hconcat(r[-1:], r[:-1]) if any(c != mostcommon(grid) for c in r) else r for r in grid)
 
4.25, 6.284623, def ccgffdbfadafedebaafibajbfhbchfga(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  direction = (
    branch(uppermost(obj) == 0, -1, branch(lowermost(obj) == len(I), 1, 0)),
    branch(leftmost(obj) == 0, 1, branch(rightmost(obj) == len(I[0]), -1, 0))
  )
  return paint(cover(I, obj), shift(obj, direction))
 
4.5, 4.481251, def bdfdfbjdbedcedieajefgdhjccfhgcag(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  center_i, center_j = centerofmass(obj)
  direction = (
    -1 if center_i < h // 2 else 1 if center_i > h // 2 else 0, 
    1 if center_j < w // 2 else -1 if center_j > w // 2 else 0
  )
  return paint(cover(I, obj), shift(obj, direction))
 
4.25, 5.2232237, def fbedabebeaceejfiicdeeicbcahfdcee(I):
  c = leastcolor(I)
  locs = ofcolor(I, c)
  direction = (
    branch(any(i == 0 for i, j in locs), -1, branch(any(i == len(I) - 1 for i, j in locs), 1, 0)),
    branch(any(j == 0 for i, j in locs), 1, branch(any(j == len(I[0]) - 1 for i, j in locs), -1, 0))
  )
  return paint(fill(I, mostcolor(I), locs), shift(toobject(locs, I), direction))
 
4.75, 4.3230557, def ahfbggfbeediehcaiahgccdcdbejfdie(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = shape(obj)
  direction = (
    -1 if uppermost(obj) < h // 2 else 1 if uppermost(obj) > h // 2 else 0,
    1 if leftmost(obj) < w // 2 else -1 if leftmost(obj) > w // 2 else 0
  )
  return paint(cover(I, obj), shift(obj, direction))
 
4.5, 2.7755044, def hgeaacjeddcieacbijcieghijhjhfebd(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  O = paint(canvas(bg, shape(I)), merge({branch(
        either(leftmost(obj) == 0, rightmost(obj) == len(I[0]) - 1),
        branch(
          leftmost(obj) == 0,
          shift(obj, (0, len(I[0]) - 1 - rightmost(obj))),
          shift(obj, (0, -leftmost(obj)))
        ),
        branch(
          uppermost(obj) == 0,
          shift(obj, (len(I) - 1 - lowermost(obj), 0)),
          shift(obj, (-uppermost(obj), 0))
        )
    ) for obj in objs}))
  return O
 
4.0, 2.7088802, def cdiefeeeffeaeddcjcebefcjcheaafde(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  h, w = shape(I)
  O = paint(canvas(bg, (h, w)), merge(
      {shift(obj, (branch(leftmost(obj) == 0, h - 1 - lowermost(obj), -uppermost(obj)),
                      branch(leftmost(obj) == 0, w - 1 - rightmost(obj), -leftmost(obj)))) 
       for obj in objs}
  ))
  return O
 
4.5, 4.1389017, def cdeccihaddefebafaffcdeeifddabfif(I):
  h, w = shape(I)
  return tuple(
      tuple(I[i - 1][j] if i > 0 and j < w // 2 else I[i][j] for j in range(w)) 
      for i in range(h)
  )
 
4.25, 10.79956, def fefefjdjbeaiebbfjbeaeajeabecgecc(I):
  h, w = shape(I)
  target_color = I[0][0] # Assuming the top-left color is the target
  O = canvas(mostcolor(I), (h, w))
  for i, row in enumerate(I):
      if target_color in row:
          O = paint(O, {(v, (i-1, j)) for j, v in enumerate(row) if v == target_color})
      else:
          O = paint(O, {(v, (i, j)) for j, v in enumerate(row)})
  return O
 
3.5, 5.395747, def diidaebgebageceebdgceafihbageejb(I):
  return paint(
      canvas(mostcolor(I), shape(I)),
      merge(
          apply(
              lambda obj: shift(obj, (0, -1)) if rightmost(obj) < width(I) - 1 else shift(obj, (-1, 0)),
              fgpartition(I)
          )
      )
  )
 
5.0, 3.8791199, def fdfdedfajafeeaafibcaffjfddcgfbec(I):
    h, w = len(I), len(I[0])
    if I[0][0] == I[h-1][0]: # Check if top-left and bottom-left corners have the same color
        corner = (0, 0)
        mirrored_corner = (h - 1, 0)
    else:
        corner = (0, w - 1)
        mirrored_corner = (h - 1, w - 1)
    O = paint(fill(I, 0, {corner}), recolor(I[corner[0]][corner[1]], {mirrored_corner}))
    return O
 
4.25, 4.074463, def dbjceaeefebbejegidfadegcbjbdcbbh(I):
    if I[0][0] != mostcolor(I): # Check if the top-left corner is not the background color
        O = paint(fill(I, 0, {(0, 0)}), recolor(I[0][0], {(len(I) - 1, 0)}))
    else:
        O = paint(fill(I, 0, {(0, len(I[0]) - 1)}), recolor(I[0][len(I[0]) - 1], {(len(I) - 1, len(I[0]) - 1)}))
    return O
 
3.75, 3.5809305, def ecgbeageabibefcejgcfjidiaeadaebi(I):
    if I[0][0] == I[1][0]:  # Check if the top two elements in the first column are the same
        O = paint(fill(I, 0, {(0, 0)}), recolor(I[0][0], {(len(I) - 1, 0)}))
    else:
        O = paint(fill(I, 0, {(0, len(I[0]) - 1)}), recolor(I[0][len(I[0]) - 1], {(len(I) - 1, len(I[0]) - 1)}))
    return O
 
4.75, 3.6752877, def jddfaifccjdcedagaagfhadfaefebdif(I):
    target_color = I[0][0] if I[0][0] != I[1][1] else I[0][len(I[0])-1] # Identify color based on diagonal comparison
    if colorcount(I, target_color) == 1: # If color appears once, mirror top-left
        O = paint(fill(I, 0, {(0, 0)}), recolor(target_color, {(len(I) - 1, 0)})) 
    else: # Otherwise, mirror top-right
        O = paint(fill(I, 0, {(0, len(I[0]) - 1)}), recolor(target_color, {(len(I) - 1, len(I[0]) - 1)}))
    return O
 
2.75, 2.203071, def bbiaaiefidefecaaifbggdebdcgfcfah(I):
  largest_obj = argmax(objects(I, T, F, T), size)
  bottom_edge = len(I) - 1
  shift_direction = (
      (0, -1) if lowermost(largest_obj) == bottom_edge else (1, 0)
  )
  return move(I, largest_obj, shift_direction)
 
4.5, 3.5706527, def eaadjbafbgffedffbfbcadecbidgbgic(I):
  def shift_to_bottom_left(obj):
    return shift(obj, (len(I) - 1 - lowermost(obj), -leftmost(obj)))
  largest_obj = argmax(objects(I, T, F, T), size)
  return paint(I, shift_to_bottom_left(largest_obj))
 
3.5, 2.7770953, def abbjcffagbabebefiiaffedfdgceedcb(I):
  largest_obj = argmax(objects(I, T, F, T), size)
  h_shift = len(I) - 1 - lowermost(largest_obj)
  w_shift = -leftmost(largest_obj)
  return paint(cover(I, largest_obj), shift(largest_obj, (h_shift, w_shift)))
 
4.25, 3.5463002, def didcfddbggbfeeefacifadbjibfagcbe(I):
  def distance_to_bottom_left(obj):
    return (len(I) - 1 - lowermost(obj)) + leftmost(obj)
  sorted_objs = order(objects(I, T, F, T), distance_to_bottom_left)
  return paint(I, shift(first(sorted_objs), (len(I) - 1, 0)))
 
4.5, 3.254184, def addcbhjfgjeaejgdaffdcdeehjhccbbe(I):
  obj = argmax(objects(I, False, False, False), size)  # Find the largest object
  bg = mostcolor(I)
  left_shifted = paint(canvas(bg, shape(I)), shift(obj, (0, -1)))
  up_shifted = paint(canvas(bg, shape(I)), shift(obj, (-1, 0)))
  O = branch(
      leftmost(obj) == 0, # If object touches left border
      branch(uppermost(obj) == 0, I, up_shifted),  # If also touches top, no shift
      branch(equality(I, cover(left_shifted, obj)), left_shifted, up_shifted) # Else try left, else up
  )
  return O
 
3.75, 3.8785129, def daijhfjhaccdefcgbjbfdgjbdffiifac(I):
  obj_color = leastcolor(I)  # Assuming the object has the least common color
  bg = mostcolor(I)
  filled_grid = fill(I, bg, shift(ofcolor(I, obj_color), (0, -1))) # Try left fill
  left_shifted = branch(
      equality(I, filled_grid), # Check if left fill was successful
      filled_grid, 
      fill(I, bg, shift(ofcolor(I, obj_color), (-1, 0))) # Else, fill up
  )
  O = replace(left_shifted, obj_color, obj_color) # Restore the object color
  return O
 
3.5, 16.450521, def bbdcgcecieeieichafjiaebefajdjfhe(I):
  obj = argmax(objects(I, False, False, False), size)
  bg = mostcolor(I)
  target = branch(
      leftmost(obj) > 0,
      {(0, 0)},  # Target left edge
      branch(uppermost(obj) > 0, {(0, 0)},  {(0, 1)}) # Target top edge or its neighbor
  )
  shift_amount = gravitate(obj, target)
  O = paint(canvas(bg, shape(I)), shift(obj, shift_amount))
  return O
 
3.25, 10.431042, def fhbabcedbjcjecifbbhgbhjaiddfhidb(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    if I[0][j] != mostcolor(I):
      direction = -1 if j < w // 2 else 1 
      O = paint(O, shift(toobject(hfrontier((0, j)), I), (direction, 0)))
  return O
 
4.25, 6.8507247, def daaahdcjcgdcebddjbeeheeiechfcbfc(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for j in range(w):
    column = tuple(I[i][j] for i in range(h))
    if column[0] != mostcolor(I):
      O = paint(O, shift(toobject(hfrontier((0,j)),I), (h - 1 if j < w // 2 else 0, 0)))
  return O
 
5.0, 3.1925468, def fghicjbaadbeejegacceeebjddaaddbd(I):
  objs = objects(I, False, False, False)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    for x in obj:
      if x[1][0] == 0:
        O = paint(O, shift(obj, (-1 if x[1][1] < len(I[0]) // 2 else 1, 0)))
        break
  return O
 
4.0, 4.6185393, def dfdehedbjfcdeibjacceceedjdaagahd(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    O = paint(
      O, 
      shift(obj, (-1, 0)) if uppermost(obj) == 0 else shift(obj, (0, -1))
    )
  return O
 
4.5, 7.870294, def dhjfacacbibfebeejdibfcebieddadfj(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    i_shift = -1 if uppermost(obj) == 0 else 0
    j_shift = -1 if rightmost(obj) < width(I) - 1 else 0
    O = paint(O, shift(obj, (i_shift, j_shift)))
  return O
 
4.5, 3.0646513, def eciadddbcddceaceajbejedaafjcbccj(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  shift_i = branch(uppermost(obj) <= h // 2, h - height(obj) - uppermost(obj), -uppermost(obj))
  shift_j = branch(leftmost(obj) <= w // 2, w - width(obj) - leftmost(obj), -leftmost(obj))
  O = paint(cover(I, obj), shift(obj, (shift_i, shift_j)))
  return O
 
4.5, 3.061064, def gbfbffbfgbejeaaaaafdfffdgfabgjcc(I):
  obj = argmax(objects(I, False, False, True), size) # Find the largest object
  bg = mostcolor(I) # Identify the background color
  h, w = shape(I) # Get grid dimensions
  ulx, uly = ulcorner(obj) # Find the upper-left corner of the object

  # Determine shift direction based on object's position
  if ulx == 0:
    direction = (0, 1) # Shift right if touching left edge
  elif uly == 0:
    direction = (1, 0) # Shift down if touching top edge
  else:
    direction = (-1, 0) # Shift left otherwise

  shifted_obj = shift(obj, direction) # Shift the object
  O = paint(cover(I, obj), shifted_obj) # Paint the shifted object onto a clean background
  return O
 
4.5, 3.158601, def ddhbiaaadeajegfajebdeddigbjdejgb(I):
  obj = argmax(objects(I, False, False, True), size)
  bg = mostcolor(I)
  h, w = shape(I)

  # Define potential shift directions
  directions = [(0, 1), (1, 0), (-1, 0)] 

  # Find the first valid shift direction
  direction = next((d for d in directions if all(0 <= i + d[0] < h and 0 <= j + d[1] < w for _, (i, j) in obj)), (0, 0))  

  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
4.25, 3.3949645, def ddhbagbejhcdebdjjidbcacfbdigedha(I):
  obj = argmax(objects(I, False, False, True), size)
  bg = mostcolor(I)

  # Calculate shift direction based on center of mass
  cm = centerofmass(obj)
  h, w = shape(I)
  direction = (-1, 0) if cm[1] > w // 2 else (0, 1) if cm[0] <= h // 2 else (1, 0)

  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
3.0, 2.4559731, def dbbeaiefjbabedahjefbabjcghibbeca(I):
  obj = argmax(objects(I, False, False, True), size)
  bg = mostcolor(I)
  h, w = shape(I)
  ulx, uly = ulcorner(obj)

  # Prioritize shifting left, then check other directions
  if ulx > 0:
    direction = (-1, 0)
  elif uly > 0:
    direction = (0, 1) if uly > 0 and all(0 <= j + 1 < w for _, (_, j) in obj) else (1, 0)
  else:
    direction = (1, 0) if all(0 <= i + 1 < h for _, (i, _) in obj) else (0, 1)

  shifted_obj = shift(obj, direction)
  O = paint(cover(I, obj), shifted_obj)
  return O
 
4.5, 3.03089, def eeccbbhdajjieeafbjfeiaceehhcffja(I):
  objs = objects(I, T, F, T) # Identify objects
  bg = mostcolor(I) # Identify background color
  O = canvas(bg, shape(I)) # Create output canvas
  for obj in objs:
    h, w = shape(I) # Get grid dimensions
    ci, cj = center(obj) # Get object center
    ni = ci + (1 if ci < h // 2 else 0) # Calculate new row index
    nj = cj + (1 if cj < w // 2 else 0) # Calculate new column index
    O = paint(O, shift(obj, (ni - ci, nj - cj))) # Shift and paint object
  return O
 
3.5, 6.9722447, def cdajbcdeeabbebgdaaagibaaaafdfhce(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I): # If not background
        ni = i + (1 if i < h // 2 else 0)
        nj = j + (1 if j < w // 2 else 0)
        O = fill(O, I[i][j], {(ni, nj)}) # Fill new position with original color
  return O
 
3.75, 3.8971584, def jcgfeafjeddbecjbjfddbbafbfhchfed(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in objects(I, T, F, T):
    offset = (1 if uppermost(obj) < h // 2 else 0, 1 if leftmost(obj) < w // 2 else 0)
    O = paint(O, shift(obj, offset)) # Shift and paint object
  return O
 
4.25, 6.284623, def ejadhbjigcdieahdiafihcegiehidacc(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in fgpartition(I):
    O = paint(O, shift(obj, (
      -1 if uppermost(obj) < h // 2 else 0,
      1 if rightmost(obj) >= w // 2 else 0
    )))
  return O
 
4.25, 5.9601846, def jhieaaefbbfheahgiaeegfhbedjcecag(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for obj in objects(I, univalued=False, diagonal=False, without_bg=True):
    O = paint(O, shift(obj, (
      -1 if any(i == 0 for i, j in toindices(obj)) else 0,
      1 if any(j == w - 1 for i, j in toindices(obj)) else 0
    )))
  return O 
 
4.75, 4.730262, def giaebddihbffeedbbfcefagfecheebjd(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in fgpartition(I):
    ul = ulcorner(obj)
    O = paint(O, shift(obj, (
      -1 if ul[0] < len(I) // 2 else 0,
      1 if ul[1] >= len(I[0]) // 2 else 0
    )))
  return O
 
4.25, 3.759771, def fccfeadbabcaefcaadhjdeeaideaefga(grid):
  color_to_mirror = leastcolor(grid)
  corner = ulcorner(ofcolor(grid, color_to_mirror)) if colorcount(grid, color_to_mirror) == 1 else urcorner(ofcolor(grid, color_to_mirror))
  mirrored_corner = (corner[0] + height(grid) - 1 - 2 * corner[0], corner[1] + width(grid) - 1 - 2 * corner[1])
  return paint(grid, recolor(color_to_mirror, {mirrored_corner}))
 
4.5, 3.254184, def ibeccejieaafebjeajbffhafbififfcg(grid):
  color_to_mirror = leastcolor(grid)
  if colorcount(grid, color_to_mirror) == 1:
    corner = ulcorner(ofcolor(grid, color_to_mirror))
    mirrored_corner = (2 * height(grid) - 1 - corner[0], 2 * width(grid) - 1 - corner[1])
  else:
    corner = urcorner(ofcolor(grid, color_to_mirror))
    mirrored_corner = (2 * height(grid) - 1 - corner[0], 2 * width(grid) - 1 - corner[1])
  return paint(grid, recolor(color_to_mirror, {mirrored_corner}))
 
4.0, 2.9791095, def fcbdbbfecaejeejeiacbjeecjhfbebcb(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)
  
  # Calculate the bounding box of the smallest object
  bbox = backdrop(smallest_obj)
  
  # Calculate target position based on object size
  target_i = uppermost(bbox) if size(smallest_obj) == 1 else uppermost(bbox) + height(bbox) // 2
  target_j = leftmost(bbox) if len({j for i, j in toindices(smallest_obj)}) == 1 else leftmost(bbox) + width(bbox) // 2
  target = (target_i, target_j)
  
  # Determine the shift direction towards the target
  shift_direction = subtract(target, centerofmass(smallest_obj))
  
  # Move the smallest object
  O = move(I, smallest_obj, shift_direction)
  return O
 
3.5, 2.9632115, def cbchbacibabjeacjbagjdgejcddegebb(I):
  # Find the smallest object
  smallest_obj = argmin(objects(I, T, F, T), size)

  # Calculate the necessary shift
  shift_amount = astuple(
      -uppermost(smallest_obj) if size(smallest_obj) == 1 else -(uppermost(smallest_obj) + height(smallest_obj) // 2 - 1),
      -leftmost(smallest_obj) if len({j for i, j in toindices(smallest_obj)}) == 1 else -(leftmost(smallest_obj) + width(smallest_obj) // 2 - 1)
  )

  # Shift the object
  shifted_obj = shift(smallest_obj, shift_amount)

  # Paint the object onto a blank canvas
  O = paint(canvas(mostcolor(I), shape(I)), shifted_obj)
  return O
 
4.75, 4.730262, def gaeciaecgifjedbbbfbjedcddcfaahbb(I):
  # Find the smallest object and its bounding box
  obj = argmin(objects(I, T, F, T), size)
  bbox = backdrop(obj)

  # Calculate target location based on object size
  target = ulcorner(bbox) if size(obj) == 1 else (
      uppermost(bbox) + height(bbox) // 2,
      leftmost(bbox) if width(obj) == 1 else leftmost(bbox) + width(bbox) // 2
  )

  # Use gravitate function to calculate shift amount
  shift_amount = gravitate(obj, {target})

  # Move the object and paint it on a blank canvas
  return paint(canvas(mostcolor(I), shape(I)), shift(obj, shift_amount))
 
3.5, 3.4187973, def dbejbcbhaggjebiabeajidebaacfcjed(I):
  # Find the smallest object and its bounding box corners
  obj = argmin(objects(I, T, F, T), size)
  ul, lr = ulcorner(obj), lrcorner(obj)

  # Calculate shift amount based on object size and shape
  shift_amount = (
      -ul[0] if size(obj) == 1 else -ul[0] - (height(obj) - 1) // 2,
      -ul[1] if lr[1] == ul[1] else -ul[1] - (width(obj) - 1) // 2
  )

  # Move the object and paint it on a blank canvas
  return paint(canvas(mostcolor(I), shape(I)), shift(obj, shift_amount))
 
3.5, 3.4418385, def defejddgcaffejafjdeidcadcebfddda(I):
  obj = argmax(objects(I, False, False, False), size)
  bg = mostcolor(I)
  target_corner = branch(
      both(leftmost(obj) > 0, uppermost(obj) > 0),  # Top Left
      (0, 0), 
      branch(
          leftmost(obj) > 0, # Top Border
          (0, 0), 
          branch(
              uppermost(obj) > 0, # Left Border
              (0, 0),
              (1, 1)  # Already at corner - Target next diagonal
          )
      )
  )
  O = paint(canvas(bg, shape(I)), shift(obj, subtract(target_corner, ulcorner(obj))))
  return O
 
3.5, 2.9632115, def ffhhcfdcaacieccbiebefjacicijbcai(I):
  objs = objects(I, T, F, T)
  bg = mostcolor(I)
  O = canvas(bg, shape(I))
  h, w = shape(I)
  for obj in objs:
    ci, cj = center(obj)
    vertical_shift = (h // 2 - ci) // abs(h // 2 - ci) if h // 2 != ci else 0
    horizontal_shift = (w // 2 - cj) // abs(w // 2 - cj) if w // 2 != cj else 0
    O = paint(O, shift(obj, (vertical_shift, horizontal_shift)))
  return O
 
3.75, 6.8511043, def ibceceiecgdgedacaijcfefcbfbeccef(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
      1 if lowermost(obj) == h - 1 else -1,
      1 if rightmost(obj) == w - 1 else -1
    )
    O = paint(O, shift(obj, shift_amount))
  return O
 
3.75, 4.265354, def dfhbiahifieeebigjaaajjfjdabbchaa(I):
  h, w = shape(I)
  return tuple(
    tuple(
      I[(i + (1 if i == 0 else -1)) % h][(j + (1 if j == w - 1 else -1)) % w]
      for j in range(w)
    )
    for i in range(h)
  )
 
5.0, 3.5857115, def ehhbaddbafecejjhiifbebdefeeihbea(grid):
  color_to_mirror = leastcolor(grid)
  mirrored_color_indices = {(i, width(grid) - 1 - j) for (i, j) in ofcolor(grid, color_to_mirror)}
  return paint(grid, recolor(color_to_mirror, mirrored_color_indices))
 
4.5, 2.5092158, def aeeahfbgfhidehdjicjdfjjjhdeefhji(grid):
  return vmirror(hmirror(grid))
 
4.5, 3.061064, def aaddehhcdcjceaegaidhbjbcbaebdcjf(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  direction = (1, 0) if uppermost(obj) != 0 else (0, 1)
  return paint(cover(I, obj), shift(obj, direction))
 
3.0, 2.9416885, def eegdififejbeeaecjafffddejfcajcif(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h = len(I)
  return paint(
      cover(I, obj),
      shift(obj, (1, 0)) if any(i != h - 1 for i, _ in toindices(obj)) else shift(obj, (0, 1))
  )
 
4.75, 4.6274896, def dfcgdfhfbccaecbiifdhebdahiificgg(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  h, w = shape(I)
  O = paint(canvas(bg, (h, w)), merge(
      {shift(obj, (0, w - 1 - 2 * leftmost(obj))) for obj in objs if bordering(obj, I)}
  ))
  return O
 
5.25, 4.285961, def hbiicgfiaeibedbcjdffgfiefcgaccge(I):
  objs = objects(I, False, False, True)
  bg = mostcolor(I)
  h, w = shape(I)
  reflected_objs = {branch(bordering(obj, I), hmirror(obj), obj) for obj in objs}
  shifted_objs = {shift(obj, (0, w - 1 - 2 * leftmost(obj))) for obj in reflected_objs}
  O = paint(canvas(bg, (h, w)), merge(shifted_objs))
  return O
 
5.25, 3.998823, def bbjhcgfffbiceabeadaabdbiadbjhfcf(I):
    objs = objects(I, False, False, True)
    bg = mostcolor(I)
    h, w = shape(I)
    O = canvas(bg, (h, w))
    for obj in objs:
        if leftmost(obj) == 0 or rightmost(obj) == w - 1:
            O = paint(O, shift(hmirror(obj), (0, w - 1 - 2 * leftmost(obj))))
        O = paint(O, shift(obj, (0, w - 1 - 2 * leftmost(obj))))
    return O
 
3.0, 13.042913, def chcadcafcchgebfgiajfhjhfddbggfbd(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        shift_i = (h // 2 - i) // max(abs(h // 2 - i), 1)
        shift_j = (w // 2 - j) // max(abs(w // 2 - j), 1)
        new_i = i + shift_i
        new_j = j + shift_j
        if 0 <= new_i < h and 0 <= new_j < w:
          O = paint(O, {(I[i][j], (new_i, new_j))})
  return O
 
4.25, 9.3747425, def iicdhbcajcaceacfaicdbbiecefebjbe(I):
  h, w = shape(I)
  def conditional_shift(i, j):
    return (i + sign(h // 2 - i), j + sign(w // 2 - j))
  shifted_indices = prapply(conditional_shift, *pair(astuple(0, h), astuple(0, w)))
  return paint(canvas(mostcolor(I), (h, w)),
               {(I[i][j], (new_i, new_j)) for (i, j), (new_i, new_j) in zip(asindices(I), shifted_indices) 
                if 0 <= new_i < h and 0 <= new_j < w})
 
4.0, 8.284732, def hhhfghfffbbbejaabcjhhecehghbbbga(I):
  objs = fgpartition(I)
  O = canvas(mostcolor(I), shape(I))
  for obj in objs:
    h, w = shape(I)
    shift_amount = (
      -1 if uppermost(obj) == 0 else (1 if lowermost(obj) == h - 1 else 0),
      -1 if leftmost(obj) == 0 else (1 if rightmost(obj) == w - 1 else 0)
    )
    O = paint(O, shift(obj, shift_amount))
  return O
 
2.75, 13.189908, def iecdecdhijibeagfaejdhjbaiabafchj(I):
  h, w = shape(I)
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != mostcolor(I):
        new_i = i + (-1 if i == 0 else (1 if i == h - 1 else 0))
        new_j = j + (-1 if j == 0 else (1 if j == w - 1 else 0))
        O = fill(O, I[i][j], {(new_i, new_j)})
  return O
 
3.0, 6.786921, def bdehefaahbcgedicjjcadiejgiiheadb(I):
  c = leastcolor(I)  # Identify the least frequent color (object)
  obj = toobject(ofcolor(I, c), I)  # Get the object formed by the least frequent color
  bottom_edge = lowermost(obj) == len(I) - 1  # Check if the object touches the bottom edge
  right_edge = rightmost(obj) == len(I[0]) - 1  # Check if the object touches the right edge
  shift_direction = (1, 0) if bottom_edge and not right_edge else (0, -1)  # Shift down if at bottom edge, else shift left
  return paint(cover(I, obj), shift(obj, shift_direction))  # Move the object 
 
3.5, 4.033446, def daaebhaedddgefihiiddhfabacgcbfdb(I):
  O = [list(row) for row in I]  # Convert to mutable list of lists for modification
  for i, row in enumerate(O):
    for j, val in enumerate(row):
      if val == leastcolor(I):  # Find cells with the least frequent color
        if i < len(I) - 1 and O[i+1][j] == mostcolor(I):  # If not at the bottom edge and the cell below is background
          O[i+1][j] = val  # Move the value down
          O[i][j] = mostcolor(I)  # Replace the original cell with background color
        elif j > 0 and O[i][j-1] == mostcolor(I): # If not at the left edge and the cell to the left is background
          O[i][j-1] = val  # Move the value left
          O[i][j] = mostcolor(I) # Replace the original cell with background color 
  return tuple(tuple(row) for row in O)  # Convert back to immutable tuples
 
3.0, 6.7918124, def jhhbifcicabgejdbieaebfacagbfaejb(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  bbox = backdrop(obj)
  down_shift = shift(bbox, (1, 0))
  left_shift = shift(bbox, (0, -1))
  if not any(index(I, cell) for cell in down_shift - bbox):
      return paint(cover(I, obj), shift(obj, (1, 0)))
  elif not any(index(I, cell) for cell in left_shift - bbox):
      return paint(cover(I, obj), shift(obj, (0, -1)))
  else:
      return I
 
3.0, 3.6852436, def bjcagdeeebieebgbagdjebeceffjchce(I):
  min_color = leastcolor(I)
  obj = toobject(ofcolor(I, min_color), I)
  bg = mostcolor(I)
  target = toobject(ofcolor(I, bg), I)
  
  # Calculate gravitational pull direction
  gx, gy = gravitate(obj, target)

  return paint(cover(I, obj), shift(obj, (gx, gy)))
 
2.5, 3.466291, def bdiidibdfceaedgaabacajcidbdfdceb(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h = len(I)
  w = len(I[0])
  down_possible = lowermost(obj) < h - 1 and index(I, (lowermost(obj) + 1, centerofmass(obj)[1])) == mostcolor(I)
  left_possible = leftmost(obj) > 0 and index(I, (centerofmass(obj)[0], leftmost(obj) - 1)) == mostcolor(I)
  
  if down_possible:
    return paint(cover(I, obj), shift(obj, (1, 0)))
  elif left_possible:
    return paint(cover(I, obj), shift(obj, (0, -1)))
  else:
    return I
 
1.75, 3.7094138, def cieaaddgeddjeefhjhhijeedeacdaafc(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  is_top_connected = any(j == 0 for i, j in toindices(obj))
  is_bottom_connected = any(j == w - 1 for i, j in toindices(obj))
  direction = branch(
      is_top_connected,
      DOWN,
      branch(
          is_bottom_connected,
          LEFT,
          RIGHT
      )
  )
  O = paint(cover(I, obj), shift(obj, direction))
  return O
 
2.75, 4.0182247, def iecdjhajcbhcedbbiabbcddcebaichga(I):
  O = tuple(tuple(I[i][(j+1)%len(I[0])] if i == 0 else I[i][j] for j in range(len(I[0]))) for i in range(len(I)))
  repl = I[0][0] if I[0][0] != 0 else 0
  O = tuple(tuple(repl if j == 0 else v for j, v in enumerate(row)) for row in O)
  return O
 
3.0, 3.4722736, def fabbhhadecbeeidfjebddfibdfaiaegf(I):
  repl = I[0][0] if I[0][0] != 0 else 0
  shifted_row = tuple(I[0][(j+1)%len(I[0])] for j in range(len(I[0])))
  O = (tuple(repl if j == 0 else v for j, v in enumerate(shifted_row)),) + I[1:]
  return O
 
2.75, 3.49689, def dbiihffeghajegcfagcbbdaedbbcieab(I):
  repl = I[0][0] if I[0][0] != 0 else 0
  O = ((repl,) + I[0][1:],)
  for i in range(1, len(I)):
    O = O + ((repl,) + I[i][1:],)
  return O
 
3.0, 3.886769, def daecddcfcaaaegidideaddeehfhceegd(I):
  least_color = leastcolor(I)
  obj = first(colorfilter(objects(I, True, False, True), least_color))
  ulx, _ = ulcorner(obj)
  _, uly = ulcorner(obj)
  shift_direction = (-1, 0) if ulx > 0 else (0, -1) if uly > 0 else (0, 0)
  return move(I, obj, shift_direction)
 
3.25, 7.4055867, def cfbjfcebfiihejgfibfdbjfieeecffgg(I):
  least_common_obj =  argmin(objects(I, True, False, True), size)
  if uppermost(least_common_obj) != 0 and leftmost(least_common_obj) != 0:
    return I 
  shift_direction = (-1, 0) if uppermost(least_common_obj) > 0 else (0, -1)
  return move(I, least_common_obj, shift_direction) 
 
3.0, 3.6852436, def jicbceiecchbegajbeahecaeccajijac(I):
  least_color_indices = ofcolor(I, leastcolor(I)) 
  if uppermost(least_color_indices) == 0 or leftmost(least_color_indices) == 0:
    return I
  shift_direction = (-1, 0) if uppermost(least_color_indices) > 0 else (0, -1)
  shifted_indices = shift(least_color_indices, shift_direction)
  return paint(fill(I, mostcolor(I), least_color_indices), recolor(leastcolor(I), shifted_indices))
 
3.0, 8.717392, def fejeccbjibceeaeiiiacfjbfegjefaia(I):
  c = leastcolor(I) 
  obj = toobject(ofcolor(I, c), I)
  top_cell = argmin(obj, lambda x: x[1]) 
  O = paint(cover(I, obj), shift({top_cell}, DOWN)) 
  return O
 
3.0, 4.6986556, def dgcehedcdbeeeeccjgejbffbbegfddei(I):
  c = leastcolor(I)
  locs = ofcolor(I, c)
  target = argmin(locs, lambda x: (x[0], -x[1])) 
  O = paint(fill(I, mostcolor(I), {target}), recolor(c, {add(target, DOWN)}))
  return O
 
2.5, 5.456412, def ehgjhafeifaeegbbbcifffbjjfgdjccg(I):
  c = leastcolor(I)
  obj_indices = ofcolor(I, c)
  target_index = min(obj_indices) 
  offset = DOWN if target_index[1] != len(I[0]) - 1 else (1, -1) 
  O = paint(fill(I, mostcolor(I), {target_index}), recolor(c, {add(target_index, offset)}))
  return O
 
3.5, 8.535162, def aicacacbhchaeefdaafjefcjcicbhjea(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  target = ulcorner(obj) if ulcorner(obj)[1] < len(I[0]) - 1 else (ulcorner(obj)[0] + 1, ulcorner(obj)[1] - 1)
  O = paint(cover(I, obj), recolor(c, {target}))
  return O
 
3.5, 4.1216016, def babafbhebbaiegicbjfhgdjabhhafcff(I):
  c = leastcolor(I)
  obj_indices = ofcolor(I, c)
  if len(obj_indices) == 1: 
    return rot90(I)
  target = min(obj_indices)
  O = paint(fill(I, mostcolor(I), {target}), recolor(c, {add(target, DOWN)})) 
  return O
 
3.5, 16.450521, def jiddcbfiffideihbbdffbfbefedceded(I):
  objs = objects(I, False, False, False)
  obj = argmin(objs, size)
  bg = mostcolor(I)
  return branch(
      any(bordering(shift(obj, (i, 0)), I) for i in range(height(I))),
      paint(canvas(bg, shape(I)), shift(obj, (gravitate(obj, {(0, len(I[0]) - 1)})))),
      paint(canvas(bg, shape(I)), shift(obj, (gravitate(obj, {(len(I) - 1, 0)}))))
  )
 
3.75, 4.1455965, def feejddcdgacdeihfjdijefedaiehdiba(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)

  # Apply shifts sequentially
  O = cover(I, obj)  
  O = branch(uppermost(obj) == 0, paint(O, shift(obj, DOWN)), O)
  O = branch(leftmost(obj) == 0, paint(O, shift(obj, RIGHT)), O)
  O = branch(
      uppermost(obj) != 0 and leftmost(obj) != 0, 
      paint(
          O, 
          toobject(product(range(uppermost(obj), height(obj) + uppermost(obj)), {0}), I)
      ), 
      O
  )
  return O
 
2.25, 2.835834, def abhafbddfhceedbjiecieahiaadddcef(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h = height(obj)

  O = branch(
      uppermost(obj) == 0,
      paint(I, shift(obj, DOWN)),
      branch(
          leftmost(obj) == 0,
          paint(I, shift(obj, RIGHT)),
          paint(
              cover(I, obj),
              frozenset((c, (i, 0)) for i in range(uppermost(obj), uppermost(obj) + h))
          )
      )
  )
  return O
 
3.0, 10.588714, def gcbddgecahccebedbfcfcbacfdicdbae(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  h, w = len(I), len(I[0])

  top_row_shift = any(j == 0 for i, j in indices)
  left_edge_shift = any(i == 0 for i, j in indices) and not top_row_shift

  new_indices = branch(
      top_row_shift,
      frozenset((i + 1, j) for i, j in indices),
      branch(
          left_edge_shift,
          frozenset((i, j + 1) for i, j in indices),
          frozenset((i, 0) for i in range(uppermost(indices), uppermost(indices) + height(toobject(indices, I))))
      )
  )
  
  O = paint(
      cover(I, toobject(indices, I)),
      toobject(new_indices, I)
  )
  return O
 
3.0, 3.341601, def ebbbehfdgdcbebfaiaicdbfidgibiffd(I):
    O = rot90(I)
    repl = O[0][0] if O[0][0] != 0 else 0
    O = (tuple(repl if j == 0 else v for j, v in enumerate(O[0])),) + O[1:]
    O = rot270(O)
    O = tuple(tuple(v if i != 1 or j != 1 else 0 for j, v in enumerate(row)) for i, row in enumerate(O))
    return O
 
5.25, 3.8641877, def caidbaccfcibegbhicfaebjafghjiaei(I):
    O = tuple(tuple(row[(j-1)%len(row)] if i == 1 else row[j] for j, v in enumerate(row)) for i, row in enumerate(I))
    O = tuple(tuple(O[1][j] if i == 0 else v for j, v in enumerate(row)) for i, row in enumerate(O))
    O = tuple(tuple(0 if i == 1 and j != 0 else v for j, v in enumerate(row)) for i, row in enumerate(O))
    return O
 
4.75, 3.6338956, def aaddffijdfiiebfbieajjfaebecfefdi(I):
  O = hmirror(I)
  O = tuple(tuple(O[i][(j+1)%len(row)] if i == 2 else v for j, v in enumerate(row)) for i, row in enumerate(O))
  O = hmirror(O)
  O = (O[1], O[0], O[2])
  O = tuple(tuple(0 if (i == 1 and j > 0) or (i == 2 and j > 0) else v for j, v in enumerate(row)) for i, row in enumerate(O))
  return O
 
4.0, 5.854369, def iffgeajcihahegdhbfhdhhfeffhbhddh(I):
  obj = first(objects(I, False, False, True))
  h = height(obj)
  w = width(obj)
  shift_direction = (1, 0) if h > w else (0, 1)
  return move(I, obj, shift_direction) 
 
4.25, 5.535441, def dhfffbecdcfjefafibfechafaecfdjfc(I):
  obj = first(objects(I, False, False, True))
  ulx, uly = ulcorner(obj)
  lrx, lry = lrcorner(obj)
  shift_direction = (1, 0) if lrx - ulx < lry - uly else (0, 1) 
  return move(I, obj, shift_direction)
 
2.25, 3.826315, def febhffbbhfdbecjbbhdbbgfeiaaedacc(I):
  obj = first(objects(I, False, False, True))
  bg = mostcolor(I)
  shift_direction = (1, 0) if any(index(I, add(loc, (1, 0))) == bg for loc in toindices(obj)) else (0, 1)
  return move(I, obj, shift_direction)
 
3.75, 4.308047, def dfeabgichiebeiffjhedfegbhahfceca(I):
  c = leastcolor(I)
  obj = first(colorfilter(objects(I, False, False, True), c))
  h, w = shape(I)
  target_index = branch(
      h == 3,
      branch(w == 3, (1, 0), (0, 1)), 
      (h - 2, w - 2)
  )
  offset = branch(
      h == 3,
      branch(w == 3, DOWN, RIGHT),
      DOWN_LEFT
  )
  O = paint(fill(I, mostcolor(I), {target_index}), recolor(c, {add(target_index, offset)}))
  return O
 
2.25, 3.826315, def hiicgafdbgabeaebjeaaffifaeididbb(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  shift_direction = branch(h == 3 and w == 3, DOWN, RIGHT) 
  shifted_obj = shift(obj, shift_direction)
  O = paint(cover(I, obj), shifted_obj) 
  return O
 
3.0, 3.6852436, def fdagfdibggaeeceiifdiihdhfeaddgfa(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  target_indices = branch(
      h == 3,
      {ulcorner(obj)},
      {(h - 2, j) for j in range(w)}
  )
  O = paint(fill(I, mostcolor(I), target_indices), obj)
  return O
 
3.5, 4.936861, def ffagdhgeiecceebcbcdabchigaahacic(I):
  c = leastcolor(I)
  obj = first(colorfilter(objects(I, False, False, True), c))
  bg = mostcolor(I)
  h, w = shape(I)
  corner = branch(h == 3, ulcorner(obj), lrcorner(obj))
  direction = branch(h == 3, DOWN, LEFT)
  extension = shoot(corner, direction)
  O = paint(I, recolor(c, intersection(extension, {
      (i, j) for i in range(h) for j in range(w) if I[i][j] == bg
  })))
  return O
 
3.25, 9.029532, def fhjccaicbhddeebdjagbfgeabichabjf(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  center_i, center_j = centerofmass(obj)
  direction = branch(
      center_i >= h // 2,  # Bottom half
      DOWN,
      branch(
          center_j >= w // 2, # Right half
          RIGHT,
          branch(
              center_i < center_j,  # Closer to top or left edge
              DOWN,
              LEFT
          )
      )
  )
  O = paint(cover(I, obj), shift(obj, direction))
  return O
 
2.5, 3.3538828, def effbcgdbecbbeabijbbhcbcfjhhdgbdf(I):
    c = leastcolor(I)
    obj = toobject(ofcolor(I, c), I)
    h, w = height(I), width(I)
    up_dist = uppermost(obj)
    down_dist = h - 1 - lowermost(obj)
    left_dist = leftmost(obj)
    right_dist = w - 1 - rightmost(obj)

    direction = branch(
        down_dist >= up_dist and down_dist >= left_dist and down_dist >= right_dist,
        DOWN,
        branch(
            right_dist >= up_dist and right_dist >= left_dist,
            RIGHT,
            branch(
                up_dist <= left_dist,
                DOWN,
                LEFT
            )
        )
    )
    
    O = paint(cover(I, obj), shift(obj, direction))
    return O
 
4.25, 8.641932, def dhdcdejhbiadehgaidigdfaabebfbfaa(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  
  top_dist = uppermost(obj)
  bottom_dist = h - 1 - lowermost(obj)
  left_dist = leftmost(obj)
  right_dist = w - 1 - rightmost(obj)
  
  direction = branch(
      top_dist <= bottom_dist,
      branch(
          top_dist <= left_dist and top_dist <= right_dist, 
          UP,
          branch(
              left_dist <= right_dist, 
              LEFT,
              RIGHT
          )
      ),
      branch(
          bottom_dist <= left_dist and bottom_dist <= right_dist, 
          DOWN,
          branch(
              left_dist <= right_dist, 
              LEFT,
              RIGHT
          )
      )
  )
  
  O = paint(cover(I, obj), shift(obj, direction))
  return O
 
3.75, 8.943607, def afjfdcaaebgheebbjefidadcjdedcccf(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  ci, cj = centerofmass(obj)

  vert_direction = branch(
      ci < h // 2, 
      UP, 
      DOWN
  )
  
  horiz_direction = branch(
      cj < w // 2, 
      LEFT, 
      RIGHT
  )
  
  direction = branch(
      abs(ci - h // 2) <= abs(cj - w // 2),
      vert_direction,
      horiz_direction
  )

  O = paint(cover(I, obj), shift(obj, direction))
  return O
 
3.0, 4.1052103, def ggbehfgcffbaegfdaagcgbaajbjabied(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  O = I
  for obj in objs:
    O = underfill(O, 0, box(obj))
  return O
 
3.25, 9.720991, def gjaajjdbbacceijaibaebhjdaeegecfe(I):
  obj = argmax(objects(I, False, False, True), size)
  bg = mostcolor(I)
  O = paint(canvas(bg, shape(I)), recolor(I[0][0], toindices(obj)))
  return O
 
4.75, 9.466357, def dffgeadeacciebfcjiicajafjdfaebca(I):
  obj = argmax(objects(I, False, False, True), size)
  h, w = shape(I)
  O = paint(canvas(I[0][0], (h, w)),  {(I[i][j], (i, j)) for i, j in toindices(obj) if I[i][j] != I[0][0]})
  return O
 
3.0, 8.6892605, def gdaddfghieedegdfbajgiffddegbcfgc(I):
  obj = argmax(objects(I, False, False, True), size)
  bg = mostcolor(I)
  ulx, uly = ulcorner(obj)
  O = paint(cover(I, obj), {(I[ulx][uly], (i, uly)) for i, j in toindices(obj)})
  return O
 
4.0, 3.6428497, def bcahdbcfcfhdefafahgdigbbdadafded(I):
  objs = objects(I, False, False, True) 
  min_obj = argmin(objs, size)
  bg = mostcolor(I)
  h, w = shape(I)

  down_shifted = shift(min_obj, DOWN)
  can_move_down = all(0 <= i < h and 0 <= j < w and I[i][j] == bg for _, (i, j) in down_shifted)

  if can_move_down:
    O = paint(cover(I, min_obj), down_shifted)
  else:
    right_shifted = shift(min_obj, (0, w - width(min_obj)))
    O = paint(cover(I, min_obj), right_shifted) 

  return O
 
4.25, 5.3197136, def fbcifcbjddabebicaeddfabeidcededf(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)
  target_col = w - width(min_obj) 
  
  O = paint(
      cover(I, min_obj), 
      frozenset({(v, (i, target_col + j)) for v, (i, j) in min_obj})
  )
  return O
 
3.0, 3.3809822, def abdeiddicfdcegbdbfbecdccbadfbgga(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)

  target_row = h - height(min_obj)
  shifted_obj = frozenset({(v, (target_row + i, j)) for v, (i, j) in min_obj})

  O = paint(cover(I, min_obj), shifted_obj)
  return O
 
2.5, 3.444446, def acdhgffbccjdefifjdaibbbaafgaciii(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, lambda o: (size(o), -leftmost(o)))
  bg = mostcolor(I)
  h, w = shape(I)

  if leftmost(min_obj) > 0 and I[uppermost(min_obj)][leftmost(min_obj) - 1] == bg:
    O = paint(cover(I, min_obj), shift(min_obj, (0, -1))) 
  else:
    O = paint(cover(I, min_obj), shift(min_obj, (h - height(min_obj), 0))) 

  return O
 
3.0, 3.3809822, def ddficdbfiaceeaacigceeffijidaddic(I):
  objs = sorted(objects(I, True, False, True), key=size)
  for obj in objs:
    while True:
      if lowermost(obj) < len(I) - 1 and index(I, (lowermost(obj) + 1, centerofmass(obj)[1])) == mostcolor(I):
        I = paint(cover(I, obj), shift(obj, DOWN))
        obj = shift(obj, DOWN)
      else: 
        break
  return I
 
2.75, 4.2872562, def bdhejefhicaiebbbbeebahfbffhdffbj(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  O = cover(I, obj)
  O = branch(uppermost(obj) == 0 and leftmost(obj) < w // 2, 
             paint(O, shift(obj, DOWN)), 
             O)
  O = branch(leftmost(obj) == 0, 
             paint(O, shift(obj, (0,2))),
             O)
  return O
 
1.75, 3.6150684, def iiagaafdidhcecffibcfcfhbfcifegac(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  O = cover(I, obj)
  shift_amount = branch(uppermost(obj) == 0 and leftmost(obj) < w // 2, 
                      DOWN,
                      branch(leftmost(obj) == 0, 
                            (0,2), 
                            (0,0))) 
  O = paint(O, shift(obj, shift_amount))
  return O
 
2.0, 5.725732, def cacgbjbbbfbbeaifaacicdafhcjiaief(I):
  c = leastcolor(I)
  objs = objects(I, True, False, False)
  obj = extract(objs, lambda o: color(o)==c)
  h, w = len(I), len(I[0])
  O = cover(I, obj)
  if uppermost(obj) == 0 and leftmost(obj) < w // 2:
    O = paint(O, shift(obj, DOWN))
  elif leftmost(obj) == 0:
    O = paint(O, shift(obj, (0,2)))
  return O
 
4.0, 5.386608, def cghijjedifgcefciaaeajihgdcefdegc(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  O = paint(cover(I, obj), shift(obj, (branch(leftmost(obj)==0, 0, branch(uppermost(obj)==0 and leftmost(obj) < w // 2, 1, 0)), branch(leftmost(obj)==0, 2, 0))))
  return O
 
3.0, 8.103198, def eeiiiffeacagedcabfjaaafbajejfedg(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = shape(I)
  target = branch(h == 3, (1, 0), (h - 2, w - 2)) 
  O = paint(cover(I, obj), recolor(c, {target}))
  return O
 
3.0, 8.104003, def cfccafebfdbgehbajedddfbdaadfbggg(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  corner = branch(len(I) == 3, ulcorner(obj), lrcorner(obj))
  direction = branch(len(I) == 3, DOWN, (-1, -1))
  target = add(corner, direction)
  O = paint(cover(I, obj), recolor(c, {target}))
  return O
 
4.0, 5.462564, def dbcfeacbbhfaeeaiaadcfcbdeeaejgcg(I):
  c = leastcolor(I)
  objs = objects(I, True, False, False)
  obj = first(sfilter(objs, lambda obj: color(obj) == c))
  indices = toindices(obj)
  h, w = len(I), len(I[0])
  shifted_indices = frozenset()
  for i, (row, col) in enumerate(sorted(indices)):
    direction = (0, 1) if even(i) else (1, 0)  
    new_row = row + direction[0]
    new_col = col + direction[1]
    if new_row < h and new_col < w:  # Check if within bounds
        shifted_indices = shifted_indices | {(new_row, new_col)}
    else:
        shifted_indices = shifted_indices | {(row, col)}  # Stay in place if out of bounds
  return paint(cover(I, obj), recolor(c, shifted_indices))
 
4.5, 5.5343056, def fibdeabfjjecefeebaficbaijiddicbe(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  h, w = len(I), len(I[0])
  new_I = canvas(mostcolor(I), (h, w))
  for i, (row, col) in enumerate(sorted(indices)):
    shift_right = even(i) and col + 1 < w
    shift_down = not shift_right and row + 1 < h
    new_I = branch(
        shift_right, 
        fill(new_I, c, {(row, col + 1)}), 
        branch(
            shift_down,
            fill(new_I, c, {(row + 1, col)}),
            fill(new_I, c, {(row, col)})
        )
    )
  return new_I
 
2.5, 3.2247746, def ebcccfefhfafegdgaeegdceafgdggbbe(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)

  O = branch(
      any(j == 0 for i, j in toindices(obj)),
      paint(I, shift(obj, DOWN)),
      paint(
          cover(I, obj),
          frozenset((c, (i, 0)) for i in range(uppermost(obj), uppermost(obj) + height(obj)))
      )
  )
  return O
 
3.5, 3.5192795, def dgfaabcabaegeceiaehffgdjebdfieaf(I):
  repl = I[0][0]  
  O = fill(I, repl,  {(i, 1) for i in range(len(I))})
  return O
 
2.0, 3.308705, def abdeddidiaeceagfbjicafibfhfbefce(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  top_row = {(i, j) for _, (i, j) in obj if i == uppermost(obj)}
  target_row = h // 2 - (h % 2 == 0)
  O = fill(I, mostcolor(I), top_row) 
  O = paint(O, shift(obj, (target_row - uppermost(obj), 0)))
  return O
 
4.0, 8.493712, def baeeaejfcehaefehacdfgcbgedcgfaee(I):
  c = leastcolor(I) 
  obj = toobject(ofcolor(I, c), I)
  bottom_indices = {(i, j) for i, j in toindices(obj) if i == len(I)-1}
  return move(I, obj, (0, 1)) if bottom_indices else move(I, obj, (-1, 0))
 
3.0, 4.1052103, def deabeffececcebdfbifigbdbcabecefe(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  return paint(I, {(c, (i - 1, j)) if i != len(I)-1 else (c, (i, j + 1)) for i, j in indices})
 
3.0, 4.374294, def gecfbcjbjicgegjfiaebjfebccdeehha(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  O = I
  for i, j in indices:
    if i == 0 and j < len(I[0]) // 2:
      O = paint(cover(O, {(c, (i, j))}), {(c, (i + 1, j))})
    elif j == 0 and i == len(I) - 1 and (i, j + 2) in asindices(I):
      O = paint(cover(O, {(c, (i, j))}), {(c, (i, j + 2))})
    elif j == 0 and (i, j + 2) in asindices(I):
      O = paint(cover(O, {(c, (i, j))}), {(c, (i, j + 2))}) 
  return O
 
2.25, 3.643773, def bjbceahiehgcefaiadgaccefficcjjde(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  h, w = len(I), len(I[0])
  O = I
  if any(j < w // 2 for _, (i, j) in obj if i == 0): 
    O = paint(O, shift(obj, DOWN))
  elif leftmost(obj) == 0:
    if (h-1, w-1) in toindices(obj):
      obj = toobject(toindices(obj)-{(h-1,w-1)}, I)
    O = paint(cover(O, obj), shift(obj, (0, 2)))
  return O  
 
2.75, 2.8298247, def dechjdafgbcjeidabebffffbaagfbdaf(I):
  corner_digit = I[0][0]
  O = list(list(row) for row in I)  # Create a mutable copy
  if corner_digit == 0: # Input_0
    O[1][0] = corner_digit
  elif corner_digit == 6: # Input_1
    for i in range(1, len(O)):
      O[i][1] = O[i][2] = corner_digit
  elif corner_digit == 9: # Input_2
    O[0], O[2] = O[2], O[0] # Swap rows
    for i in range(0,2,2): # Replace first two elements of first and third rows
      O[i][0] = O[i][1] = corner_digit
  elif corner_digit == 2: # Input_3
    O[2][1] = O[2][2] = corner_digit 
    O[0][2] = 2
  return tuple(tuple(row) for row in O)
 
2.75, 6.0295887, def fjhjaecadeaaeebajcaffdhibgadfdaa(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  target_row = h // 2 - (h % 2 == 0)
  if uppermost(obj) != target_row:
    top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
    O = paint(cover(I, top_row), shift(top_row, (target_row - uppermost(obj), 0)))
  else:
    right_col = {(v, (i, j)) for v, (i, j) in obj if j == rightmost(obj)}
    O = paint(cover(I, right_col), shift(right_col, (0, -1)))
  return O
 
2.5, 7.8942065, def jdcfaejbffjdeebjbabdfadeagbdbddf(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  if height(obj) > 1:
    target_row = h // 2 - (h % 2 == 0)
    top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
    O = paint(cover(I, top_row), shift(top_row, (target_row - uppermost(obj), 0)))
  else:
    right_col = {(v, (i, j)) for v, (i, j) in obj if j == rightmost(obj)}
    O = paint(cover(I, right_col), shift(right_col, (0, -1))) 
  return O
 
3.25, 6.75668, def cfdbffcieafaebedjcafcbcfddaafjci(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  top_left = ulcorner(obj)
  O = I
  for v, (i, j) in obj:
    new_i = h // 2 - (h % 2 == 0) if i == top_left[0] else i
    new_j = top_left[1] if j == rightmost(obj) else j
    O = paint(cover(O, {(i, j)}), {(v, (new_i, new_j))})
  return O
 
2.0, 2.795635, def aiejbdcecghdeecfjfgjidffbdeadffg(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  target_row = h // 2 - (h % 2 == 0)
  O = paint(cover(I, obj), shift(obj, (target_row - uppermost(obj), 0))) 
  if rightmost(obj) == w - 1:
    O = paint(cover(O, obj), shift(obj, (0, -1))) 
  return O
 
2.5, 4.7807937, def bfdhabcefbifeaacihiciacebjgefibd(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  if h == width(obj) and uppermost(obj) == 0:
    return I
  else:
    target_row = h // 2 - (h % 2 == 0)
    top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
    O = paint(cover(I, top_row), shift(top_row, (target_row - uppermost(obj), 0)))
    if rightmost(obj) == w - 1:
      O = paint(cover(O, obj), shift(obj, (0, -1))) 
    return O
 
5.25, 3.938911, def cdadbjdccbcdeeeaaehcdfeiabdcgbia(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  return paint(
      cover(I, obj),
      frozenset(
          (c, (i - 1, j)) if i != 0 else (c, (i, (j + 1) % width(I)))
          for _, (i, j) in obj
      )
  )
 
2.75, 7.7320695, def cbdidhfcecaceifjjcbibffcbhhecdfj(I):
  c = leastcolor(I)
  indices = ofcolor(I, c)
  O = I
  h, w = len(I), len(I[0])
  for i, j in indices:
    if i == 0 and j < w // 2:
      O = paint(cover(O, {(c, (i, j))}), {(c, (i + 1, j))})
    elif (i == 0 and j >= w // 2) or j == 0:
      O = paint(cover(O, {(c, (i, j))}), {(c, (i, j + 2))})
  return O
 
2.75, 12.177366, def ddjdhcjgfijgebaficbcbageeddedged(I):
  c = leastcolor(I)
  O = I
  h, w = len(I), len(I[0])
  for i, row in enumerate(I):
    for j, v in enumerate(row):
      if v == c:
        if i == 0:
          O = paint(cover(O, {(c, (i, j))}), {(c, (i + (j < w // 2), j + 2 * (j >= w // 2)))})
        elif j == 0:
          O = paint(cover(O, {(c, (i, j))}), {(c, (i + 2, j))})
  return O
 
3.0, 4.1680894, def dehfgfadgjeaefadbfcabacijafcfjab(I):
  corner_digit = I[0][0]
  O = fill(I, corner_digit, {(i, 1) for i in range(len(I))}) # From Program_B, but filling the middle column
  if corner_digit == 0: 
    O = fill(O, corner_digit, {(1, 0)}) # Fill cell below top-left corner
  elif corner_digit == 6: 
    pass # No additional changes needed 
  elif corner_digit == 9:
    O = rot180(O) # Rotate 180 degrees instead of swapping rows
    O = fill(O, corner_digit, {(0, 0), (0, 1), (1, 0), (1, 1)}) # Fill top-left 2x2 area
  elif corner_digit == 2:
    O = fill(O, corner_digit, {(0, 0), (0, 2), (2, 0), (2, 2)}) # Fill top and bottom rows, left and rightmost cells
  return O
 
2.25, 3.962325, def ijbhacejeabfeacfiagechaaggeccedf(I):
  corner_digit = I[0][0]
  O = I # Directly work on the input grid
  if corner_digit == 0: 
    O = fill(O, corner_digit, {(1, 0)})
  elif corner_digit == 6:
    O = tuple(tuple(corner_digit if j == 1 else v for j, v in enumerate(row)) for row in O) # Fill middle column
  elif corner_digit == 9:
    O = rot180(O)
    O = fill(O, corner_digit, product(range(2), range(2))) # Using product for 2x2 area
  elif corner_digit == 2:
    O = fill(O, corner_digit, {(0, j) for j in range(3)} | {(2, 0), (2, 2)}) # Using set union for target cells
  return O
 
3.25, 4.545734, def cfcafdjbaidhebacbcfdabibcdfhehjc(I):
  objs = objects(I, False, False, True)  # Find all objects, excluding background
  obj = argmin(objs, size)  # Get the smallest object
  h, w = len(I), len(I[0])  # Get grid dimensions
  if width(obj) > height(obj):  # If wider than tall
    O = paint(I, shift(obj, (1, 0))) # Shift one row down
  elif width(obj) < height(obj):  # If taller than wide
    O = paint(I, shift(obj, (0, w - width(obj))))  # Shift to rightmost column
  else:  # If square
    O = paint(I, shift(obj, (-1, 0)))  # Shift one row up
  return O
 
2.75, 3.242861, def fbebfbhcdddjedggicdbdhdhgccfdgbf(I):
  objs = objects(I, False, False, True)
  obj = argmin(objs, size)
  h, w = len(I), len(I[0])
  O = paint(I, shift(obj, ((width(obj) <= height(obj)) - (width(obj) < height(obj)), (width(obj) < height(obj)) * (w - width(obj)))))
  return O
 
2.75, 2.884606, def bbhicedjhcdfeigiabjahjeebgiacefi(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)
  
  if size(min_obj) == 1:
    target_row = h // 2  # Middle row
    shifted_obj = frozenset({(v, (target_row, j)) for v, (i, j) in min_obj})
    O = paint(fill(I, mostcolor(I), {(target_row, j) for j in range(w)}), shifted_obj)
  else:
    corner = ulcorner(min_obj)
    target_indices = {(h - 1 - corner[0], corner[1])}
    O = paint(I, recolor(first(min_obj)[0], target_indices))
  return O
 
3.0, 4.2931027, def fadcgecccdfheeejiceafgfigdjfiffc(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)

  if size(min_obj) == 1:
    O = paint(fill(I, mostcolor(I), {(h // 2, j) for j in range(w)}), min_obj)
  else:
    corner = ulcorner(min_obj)
    opposite_corner = (h - 1 - corner[0], w - 1 - corner[1])
    O = paint(I, recolor(first(min_obj)[0], {opposite_corner}))
  return O
 
3.75, 3.8864167, def hffibhdfbeifecebjabibhgcadahidab(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)

  if size(min_obj) == 1:
    target_row = h - uppermost(min_obj) - 1
    shifted_obj = frozenset({(v, (target_row, j)) for v, (i, j) in min_obj})
    O = paint(cover(I, min_obj), shifted_obj)
  else:
    O = paint(I, recolor(first(min_obj)[0], {(h-1, 0)}))
  return O
 
3.5, 3.1628232, def cfbdjcfjehecedgfbebhbddabcehagbf(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)

  if size(min_obj) == 1:
    O = paint(I, recolor(first(min_obj)[0], {(h//2, j) for j in range(w)}))
  else:
    O = I 
  return O
 
3.25, 3.607913, def fdcccfgcebbfejaaicfdfadadbeedghh(I):
  objs = objects(I, False, False, True)
  min_obj = argmin(objs, size)
  h, w = shape(I)

  if size(min_obj) == 1:
    target_indices = {(i, w - 1 - j) for v, (i, j) in min_obj}
    O = paint(I, recolor(first(min_obj)[0], target_indices))
  else:
    corner = ulcorner(min_obj)
    target_loc = (h - 1 - corner[0], corner[1])
    O = paint(I, recolor(first(min_obj)[0], {target_loc}))
  return O
 
3.75, 3.6951137, def cadffheaaaebeeccbbfcggcfdfbbaebh(I):
  c = leastcolor(I)
  return paint(
      I, 
      frozenset(
          (mostcolor(I), (i, j)) if v == c and i != 0 else (c, ((i - 1) % len(I), j)) if v == c else (v, (i, j))
          for i, r in enumerate(I) for j, v in enumerate(r) 
      )
  )
 
3.5, 16.450521, def aiebeedddfbieefhaeedbagaeehffege(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  target = branch(
      any(i == 0 for i, j in toindices(obj)),
      (lowermost(obj) + 1, leftmost(obj)),
      (uppermost(obj), leftmost(obj) - 1)
  )
  O = paint(cover(I, obj), toobject({target}, I))
  return O
 
2.5, 3.2850404, def fdiahgiijdieeibibcdjbfdadcdbajcg(I):
  c = leastcolor(I)
  obj = toobject(ofcolor(I, c), I)
  direction = (1, -1) if any(i == 0 for i, j in toindices(obj)) else (-1, 1)
  moved_obj = {(v, (i + direction[0], j + direction[1])) for v, (i, j) in obj}
  O = paint(I, moved_obj)
  return O
 
3.0, 4.1052103, def efbdebdddgccehfdacfjahfefhjhecii(I):
  obj = first(objects(I, False, False, True))
  return paint(I, recolor(color(obj), backdrop(obj)))
 
2.75, 3.948541, def hbggdacdhfchegacajacieaeahefadah(I):
  obj = first(objects(I, False, False, True))
  bg = mostcolor(I)
  center_obj = center(obj)
  O = paint(cover(I, obj), shift(obj, (1, 0))) if center_obj[0] < 1 else paint(fill(I, bg, {(center_obj[0], center_obj[1] + 1)}), shift(obj, (1, 0)))
  return O
 
2.75, 8.43126, def fhcjffbeebgiecjcidiecdbaidhfibbc(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  bg = mostcolor(I)
  O = paint(cover(I, obj), shift(obj, (1 if uppermost(obj) != h // 2 - (h % 2 == 0) else 0, 0)))
  if rightmost(obj) == w - 1:
    O = paint(O, {(bg, (uppermost(obj), rightmost(obj) - 1)), (bg, (uppermost(obj) + 1, rightmost(obj)))})
  else:
    O = paint(O, {(bg, (uppermost(obj), rightmost(obj) + 1)), (bg, (uppermost(obj) + 1, rightmost(obj)))}) 
  return O
 
2.5, 2.063166, def iihhajafcgjbedgabcefcafecagebfcc(I):
  corner_digit = I[0][0]
  if corner_digit == 0:
    O = fill(I, corner_digit,  {(i, 1) for i in range(len(I))})  # Fill middle column with corner digit
  elif corner_digit == 6:
    O = fill(I, 0, {(i, 1) for i in range(len(I))})  # Fill middle column with zeros
  elif corner_digit == 9:
    O = rot180(I) # Rotate 180 degrees
  elif corner_digit == 2:
    O = fill(I, I[2][1], {(0, 1)}) # Move bottom middle digit to top
    O = fill(O, corner_digit,  {(i, 1) for i in range(2, len(I))}) # Shift remaining middle column digits down
  return O
 
2.25, 2.1287858, def fgcbghdfdjaaecgbiefeefdcgehabgib(I):
  corner_digit = I[0][0]
  O = tuple(list(row) for row in I)  # Convert tuple to list for in-place modification
  for i in range(len(I)):
    if corner_digit == 0:
      O[i][1] = corner_digit
    elif corner_digit == 6:
      O[i][1] = 0
    elif corner_digit == 2:
      O[i][1] = I[(i-1)%len(I)][1]  # Shift down with wrap-around
  if corner_digit == 9:
    O = rot180(O)  # Rotate if corner digit is 9
  return tuple(tuple(row) for row in O)  # Convert back to tuple
 
3.5, 5.821962, def caehehecfeidedefafdgcicedcjhdfgg(I):
  obj = first(objects(I, False, False, True))  # Identify the object to be moved
  h, w = shape(I)  # Get grid dimensions
  if h == 3 and w == 3:
    if I[0][0] != I[1][0]:  # Condition for top-left corner movement
      direction = DOWN
    elif I[1][1] != I[1][2]:  # Condition for middle-column movement
      direction = RIGHT
    else:
      direction = UP  # Condition for bottom corner movement
  else:
    direction = RIGHT 
  shifted_obj = shift(obj, direction)  # Shift the object
  O = paint(cover(I, obj), shifted_obj)  # Paint the shifted object back onto the grid
  return O
 
3.5, 7.8727226, def jcdafifcihcdedaciidfbfhchhiaefbc(I):
  c = leastcolor(I)  # Find the least common color
  obj = toobject(ofcolor(I, c), I)  # Get the object with that color
  h, w = shape(I)
  if h == 3 and w == 3:
    if colorcount(I, c) == 1:  # Single cell object movement
      corner = ulcorner(obj)
      direction = DOWN
    elif colorcount(I, c) == 5:  # Five cell object movement
      corner = (1, 1)
      direction = RIGHT
    else:
      corner = lrcorner(obj)
      direction = (-1, -1)
  else:
    corner = ulcorner(obj)
    direction = RIGHT
  target = add(corner, direction)  # Calculate the target location
  O = paint(cover(I, obj), recolor(c, {target}))  # Move the object by recoloring
  return O
 
4.25, 4.7598357, def jcajifcbaacgedaajefdjcbbfcbjddfi(I):
  objs = objects(I, False, False, True)  # Get all objects
  obj = argmin(objs, size)  # Find the smallest object
  h, w = shape(I)
  if h == 3 and w == 3:
    if len(obj) == 1:  # Single cell movement
      direction = DOWN
    elif len(obj) == 5:  # Five cell movement
      direction = RIGHT
    else:
      direction = UP
  else:
    direction = RIGHT
  shifted_obj = shift(obj, direction)  # Shift the object
  O = paint(cover(I, obj), shifted_obj)  # Paint the shifted object
  return O
 
2.5, 7.4621425, def cbfeachebfeiegajbfjdfaajfidjdehb(I):
  obj = first(objects(I, False, False, True))  # Get the first object
  h, w = shape(I)
  center_obj = centerofmass(obj)  # Calculate the object's center of mass
  if h == 3 and w == 3:
    if center_obj == (0, 0):  # Top-left object
      direction = DOWN
    elif center_obj == (1, 1):  # Center object
      direction = RIGHT
    else:
      direction = (-1, -1)  # Bottom-right object
  else:
    direction = RIGHT
  shifted_obj = shift(obj, direction)  # Shift the object
  O = paint(cover(I, obj), shifted_obj)  # Paint the shifted object
  return O
 
3.0, 5.4718146, def edfbhbegfbjaebcajbagccfbdffbbagj(I):
  c = leastcolor(I)  # Find the least common color
  obj = toobject(ofcolor(I, c), I)  # Get the object with that color
  h, w = shape(I)
  if h == 3 and w == 3:
    if I[0][1] == I[2][1]:  # Check if the middle column has the same color
      direction = RIGHT
    elif I[0][0] == c:  # Check if the top-left corner has the least common color
      direction = DOWN
    else:
      direction = UP
  else:
    direction = RIGHT
  shifted_obj = shift(obj, direction)  # Shift the object
  O = paint(cover(I, obj), shifted_obj)  # Paint the shifted object
  return O
 
3.0, 5.7630763, def ccehebcffcdceegbiecjcddccfedeadf(I):
  obj = toobject(ofcolor(I, leastcolor(I)), I)  # Identify the object with the least common color
  bg = mostcolor(I)  # Identify the background color
  if lowermost(obj) == len(I) - 1: # If the object touches the bottom edge
    return paint(cover(I, obj), shift(obj, (1, 0))) # Shift the object down
  elif rightmost(obj) == len(I[0]) - 1: # If the object touches the right edge
    recolored_obj = toobject(
        frozenset((i, j) for i, j in toindices(obj) if j != rightmost(obj)), # Select all columns except the rightmost
        I
    )
    return paint(cover(I, obj), recolor(bg, recolored_obj)) # Recolor selected portion to background color
  else:
    return I  # No change if the object doesn't touch the bottom or right edge
 
3.0, 5.8326073, def bjbedcefbbfheeiebeajdjdacjdjiacf(I):
  target_color = leastcolor(I)
  bg = mostcolor(I)
  new_grid = canvas(bg, shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == target_color:
        if i == len(I) - 1:  # Bottom edge
          new_grid = fill(new_grid, val, {(i + 1, j)})
        elif j == len(row) - 1:  # Right edge
          new_grid = fill(new_grid, bg, {(i, j)})
        else:
          new_grid = fill(new_grid, val, {(i, j)})
      else:
        new_grid = fill(new_grid, val, {(i, j)})
  return new_grid
 
3.5, 3.7219293, def achcdgaadefjehjfiedbeaeehficbaec(I):
    # Identify the least common color
    c = leastcolor(I)
    # Create an object from the cells with the least common color
    obj = toobject(ofcolor(I, c), I)

    # Define a function to conditionally shift the object
    def conditional_shift(obj, condition, direction):
        return branch(condition, shift(obj, direction), obj)
    
    # Apply conditional shifts based on the object's position
    obj = conditional_shift(obj, size(obj) == 1 and uppermost(obj) < 2, DOWN)
    obj = conditional_shift(obj, size(obj) > 1 and leftmost(obj) == 1, (-1, -1))
    obj = conditional_shift(obj, size(obj) == 3 and leftmost(obj) == 1, (1, 1))

    # Paint the shifted object onto a blank canvas of the same size
    O = paint(canvas(mostcolor(I), shape(I)), obj)
    return O
 
2.5, 2.3418689, def beefeiifbfcjebfiiieifbebacbaabje(I):
  corner_digit = I[0][0]
  if corner_digit == 0: 
    I = fill(I, corner_digit, {(1,1)})  # Fill middle of second row with corner digit
  elif corner_digit == 6:
    I = fill(I, 0, {(i, 1) for i in range(len(I))})  # Fill middle column with zeros
  elif corner_digit == 9:
    I = rot180(I)  # Rotate by 180 degrees
  elif corner_digit == 2:
    I = dmirror(I)  # Mirror along the main diagonal
  return I
 
3.5, 3.5760007, def gfhedfbbbdcheccdbegdedhjcgieffee(grid):
  return fill(grid, grid[0][0], {(1,1)}) 
 
3.25, 5.9340754, def fgcfgcgfefdaegcbbjbggbjeifddadcf(I):
  obj = first(objects(I, False, False, True))
  top_row = {(v, (i, j)) for v, (i, j) in obj if i == uppermost(obj)}
  left_col = {(v, (i, j)) for v, (i, j) in obj if j == leftmost(obj)}
  O = paint(cover(I, top_row), shift(top_row, (1, 0)))
  O = paint(cover(O, left_col), shift(left_col, (0, 1)))
  return O
 
3.0, 4.568712, def cfibdfffafhfedgbiibebadhbhieifea(I):
  obj = first(objects(I, False, False, True))
  O = I
  for v, (i, j) in obj:
    if i == uppermost(obj):
      O = paint(cover(O, {(v, (i, j))}), {(v, (i+1, j))})
    if j == leftmost(obj):
      O = paint(cover(O, {(v, (i, j))}), {(v, (i, j+1))})
  return O
 
3.0, 3.3369093, def ciaeiaeeagabejefijafefefacebacfj(I):
  obj = first(objects(I, False, False, True))
  shifted_top_row = {(v, (i + 1, j)) for v, (i, j) in obj if i == uppermost(obj)}
  shifted_left_col = {(v, (i, j + 1)) for v, (i, j) in obj if j == leftmost(obj)}
  O = paint(I, shifted_top_row)
  O = paint(O, shifted_left_col)
  return O
 
3.25, 6.6146955, def aebhiijdfabcehaijbecgfcbbbbhfffi(I):
  obj = first(objects(I, False, False, True))
  h, w = shape(I)
  O = paint(cover(I, obj), shift(obj, (1, 0)))
  O = paint(cover(O, obj), shift(obj, (0, 1)))
  O = fill(O, mostcolor(I), {(i, 0) for i in range(h)})
  O = fill(O, mostcolor(I), {(0, j) for j in range(w)})
  return O
 
