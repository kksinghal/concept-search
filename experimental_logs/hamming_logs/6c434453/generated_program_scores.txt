0.17, 11.140945, def fdceadffdddaebbjbedcibcfbeefbcde(I):
  x1 = objects(I, T, F, F) # Extract all objects
  x2 = min(x1, key=len) # Find the smallest object by number of cells
  return paint(I, recolor(2, x2)) # Recolor the smallest object to 2
 
0.17, 10.51098, def bdfdgihbbfiaefbhicbicbccebafeaej(I):
    x1 = objects(I, T, F, F)  # Extract all objects
    x2 = lambda x: colorcount(x, mostcolor(I))  # Function to count occurrences of the most common color in an object
    x3 = argmin(x1, x2)  # Find the object with the least occurrences of the most common color 
    return paint(I, recolor(2, x3)) # Recolor the found object and paint it
 
0.215, 45.37218, def ggaegbcaeaddejchbfchfgaaiaffbebf(I):
    # Find the smallest object
    x1 = objects(I, T, F, F)
    x2 = argmin(x1, size)

    # Mirror the bottom-left object horizontally
    x3 = objects(I, T, F, T) 
    x4 = argmin(x3, lambda o: llcorner(o)[0]) # Select the bottom-left object
    x5 = hmirror(x4) 

    # Combine and recolor the selected objects
    x6 = combine(initset(x2), initset(x5))
    O = paint(canvas(ZERO, shape(I)), recolor(TWO, mfilter(x6, identity)))
    return O
 
0.215, 65.4323, def gjgcdcbafadfebdbbbfbcefediddfabc(I):
    # Find the smallest object and its color
    smallobj = argmin(objects(I, T, F, F), size)
    obj_color = color(smallobj)

    # Create a new grid with the smallest object recolored
    O = paint(canvas(ZERO, shape(I)), recolor(TWO, smallobj))

    # Find the bottom-left object and its color
    bottomleftobj = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0])
    bottomleft_color = color(bottomleftobj)

    # Recolor the mirrored bottom-left object if its color matches the smallest object
    if obj_color == bottomleft_color:
      O = paint(O, recolor(TWO, hmirror(bottomleftobj)))

    return O
 
0.225, 10.665346, def bccifcfhaffaecgcjjcaidihdeefjcce(I):
    # Identify all objects composed of '1's
    x1 = objects(I, T, F, T)
    # Filter for objects with a width of 3
    x2 = sfilter(x1, lambda o: width(o) == 3)
    # Repaint the selected objects with color '2'
    x3 = apply(lambda o: recolor(2, o), x2)
    # Merge the repainted objects
    x4 = merge(x3)
    # Paint the merged objects onto a blank canvas
    O = paint(canvas(0, shape(I)), x4)
    return O
 
0.225, 9.3100195, def jcabfjbaghagejbgbddcdddegeeiafef(I):
    # Create a mask by replacing all '1's with '2'
    x1 = replace(I, 1, 2)
    # Extract all objects
    x2 = objects(x1, F, T, F)
    # Filter for objects containing the color '2'
    x3 = sfilter(x2, lambda o: 2 in palette(o))
    # Paint the selected objects onto a blank canvas
    O = paint(canvas(0, shape(I)), merge(x3))
    return O
 
0.225, 10.133792, def ebdcejjccjebejfbihehcbfeeffdghgh(I):
  # Extract all objects composed of '1's
  x1 = objects(I, T, F, T)
  # Define a function to check for horizontal lines or L-shapes
  def is_target(obj):
    return hline(obj) or (width(obj) == 3 and height(obj) in [2, 3])
  # Filter for the target objects
  x2 = sfilter(x1, is_target)
  # Repaint the selected objects with '2'
  x3 = apply(lambda o: recolor(2, o), x2)
  # Paint the merged objects onto a blank canvas
  O = paint(canvas(0, shape(I)), merge(x3))
  return O 
 
0.225, 70.18224, def ibebdhjcgdcheccjbacadbjgaffgejcf(I):
  # Find indices of all '1's in the grid
  x1 = ofcolor(I, 1)
  # Group the indices into objects
  x2 = objects(I, T, F, T)
  # Filter for objects that fully contain any 3 horizontally adjacent '1's
  x3 = sfilter(x2, lambda o: any(all(((i, j), (i, j+1), (i, j+2)) in toindices(o) for j in range(width(I)-2)) for i in range(height(I))))
  # Recolor the selected objects
  x4 = apply(lambda o: recolor(2, o), x3)
  # Paint onto a blank canvas
  O = paint(canvas(0, shape(I)), merge(x4)) 
  return O
 
0.225, 36.51828, def egfecjfjebeeefffbhebhfidaebdefbb(I):
    # Extract objects of '1's 
    objs = objects(I, T, F, T)
    # Filter: keep objects that are either hline or have exactly 5 cells 
    target_objs = sfilter(objs, lambda obj: hline(obj) or size(obj) == 5)
    # Recolor the target objects with '2'
    recolored_objs = apply(lambda o: recolor(2, o), target_objs)
    # Create a blank canvas of the same size as the input
    canvas_grid = canvas(0, shape(I))
    # Paint the recolored objects onto the canvas
    O = paint(canvas_grid, merge(recolored_objs))
    return O
 
0.18, 11.269097, def dhefeicjifjheedijfiijgaabjebcega(I):
    # Identify the object formed by the least common color.
    x1 = objects(I, T, F, F)
    x2 = argmin(x1, size) 
    # Replace all other objects with the most common color.
    x3 = paint(canvas(mostcolor(I), shape(I)), x2)
    O = cellwise(I, x3, other(palette(I), mostcolor(I)))
    return O 
 
0.92, 13.207547, def icgcjafhheeaededbaaddcbgfichggda(I):
    # Find the least and most common colors.
    c1 = leastcommon(sum(I, ()))
    c2 = mostcommon(sum(I, ()))
    # Switch the least and most common colors.
    O = switch(I, c1, c2)
    return O
 
0.225, 70.18224, def cebfebhcfeceedaaibjbcacedfbdgadf(I):
    # Partition the grid into objects.
    objs = objects(I, True, False, False) 
    # Find the smallest object.
    target_obj = argmin(objs, size)
    # Create a blank canvas filled with the most common color.
    new_grid = canvas(mostcolor(I), shape(I)) 
    # Paint the target object onto the canvas.
    O = paint(new_grid, target_obj)
    return O
 
0.18, 11.269097, def cagcdfjhechgejfaafedffbgeaeaceha(I):
  objs = objects(I, True, False, False)  # Extract connected objects of same color
  recolored = set()
  for obj in objs:
    if portrait(obj):  # Check if the object is taller than wide
      recolored.add(recolor(2, obj))  # Recolor to '2' if vertical
    else:
      recolored.add(obj)  # Keep original color if not vertical
  O = paint(canvas(0, shape(I)), merge(recolored))  # Paint on an empty canvas
  return O
 
0.27, 39.630024, def afacebdfheafehabjbceeiefigdbebbb(I):
  O = canvas(ZERO, shape(I))  # Create a blank canvas
  objs = objects(I, T, F, F) # Find all objects in the grid
  smallobj = argmin(objs, size) # Find the smallest object 
  O = paint(O, recolor(TWO, smallobj)) # Paint the smallest object with '2' on the canvas

  # Find the bottom-left object
  bl_obj = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0]) 
  
  # Mirror and paint the bottom-left object
  mirrored_obj = hmirror(bl_obj)  # Mirror horizontally
  corner_i = lowermost(bl_obj) # Find the y-coordinate of the bottom row of the object 
  mirrored_obj = shift(mirrored_obj, (corner_i * 2 - height(mirrored_obj) + 1, 0)) # Shift the object to its mirrored position
  O = paint(O, recolor(TWO, mirrored_obj))  # Paint the mirrored object with '2' on the canvas

  return O
 
0.225, 70.18224, def eggchabfjbagedfcbiajaabbjaehahdb(I):
    objs = objects(I, T, F, F)
    smallest = argmin(objs, size)
    bottom_left = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0])
    output_grid = canvas(ZERO, shape(I))
    for i in range(len(I)):
      for j in range(len(I[0])):
        if (I[i][j] != ZERO and {(I[i][j], (i,j))} in objs) and ({(I[i][j], (i,j))} in smallest or {(I[i][j], (i,j))} in bottom_left):
          output_grid = paint(output_grid, recolor(TWO, {(TWO, (i, j))}))
        if {(I[i][j], (i,j))} in bottom_left:
          corner_i = lowermost(bottom_left)
          output_grid = paint(output_grid, recolor(TWO, {(TWO, (2 * corner_i - i, j))})) 
    return output_grid
 
0.24, 43.26687, def jchbacccgegheaicjehfbcgbcgjejbab(I):
    O = canvas(ZERO, shape(I))
    smallobj = argmin(objects(I, T, F, F), size)
    O = paint(O, recolor(TWO, smallobj))
    bl_obj = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0])
    
    bl_corner = llcorner(bl_obj)
    top_row = uppermost(bl_obj)
    for i in range(height(bl_obj)):
        row = crop(I, (top_row + i, 0), (1, width(bl_obj)))
        mirrored_row = hmirror(row)
        O = paint(O, recolor(TWO, asobject(mirrored_row)))
        O = move(O, asobject(mirrored_row), (2*(bl_corner[0] - top_row) - i, 0)) 

    return O
 
0.26, 37.49453, def fhgjigefeefeecfbahchbfbgcfabcied(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, F, F):
        if size(obj) == size(argmin(objects(I, T, F, F), size)):
            O = paint(O, recolor(TWO, obj))
        if obj == argmin(objects(I, T, F, T), lambda o: llcorner(o)[0]):
            corner = llcorner(obj)
            for i, j in toindices(obj):
                O = paint(O, recolor(TWO, {(TWO, (2 * corner[0] - i, j))}))
    return O
 
0.225, 32.065483, def dedhjedbeheaeebhjcejjdgcjcibdcgf(I):
    # Identify objects
    objs = objects(I, T, F, T)
    h, w = len(I), len(I[0])
    
    # Recolor objects based on conditions
    recolored_objs = set()
    for obj in objs:
        # Condition 1: Top-left corner object
        if ulcorner(obj) == (0, 0):
            recolored_objs.add(recolor(2, obj))
        # Condition 2: Object touching right border
        elif rightmost(obj) == w - 1:
            # Further condition: At least 3 cells
            if len(obj) >= 3:
                recolored_objs.add(recolor(2, obj))
        # Condition 3: Object touching bottom border and at least 3 cells
        elif lowermost(obj) == h - 1 and len(obj) >= 3:
            recolored_objs.add(recolor(2, obj))
        # Condition 4: Object with cell in the 6th column
        elif any(j == 5 for i, j in toindices(obj)):
            recolored_objs.add(recolor(2, obj))

    # Paint the recolored objects onto a blank canvas
    O = paint(canvas(0, shape(I)), merge(recolored_objs))
    return O
 
0.225, 9.3100195, def eabfedafgcfdeadaifjeeeidbadbceee(I):
    x1 = objects(I, T, F, F)  # Identify all objects in the grid.
    x2 = colorfilter(x1, 1) # Filter objects that have color 1.
    x3 = recolor(2, merge(x2)) # Recolor the filtered objects to color 2.
    O = paint(I, x3) # Paint the recolored objects onto the original grid.
    return O
 
0.9, 9.447168, def ecgdefdfagbeebccibdbfhdcgdfbdffg(I):
  objs = objects(I, True, False, False)  # Identify all connected objects
  big_obj = argmax(objs, size)  # Find the largest object
  is_horizontal = width(big_obj) > height(big_obj)
  other_objs = difference(objs, {big_obj}) # All objects except the largest one
  
  # Filter objects based on orientation
  if is_horizontal:
    filtered_objs = mfilter(other_objs, vline) 
  else:
    filtered_objs = mfilter(other_objs, hline) 
  
  # Paint the objects
  O = paint(paint(canvas(0, shape(I)), recolor(2, big_obj)), recolor(2, filtered_objs)) 
  return O
 
0.92, 11.365675, def ajcbejccbaiaecaiaegcfgabbfdfgcii(I):
  objs = objects(I, True, False, False)
  largest_obj = argmax(objs, lambda o: width(o) * height(o)) # Find largest by area
  other_objs = difference(objs, {largest_obj})
  
  def condition(obj):
    return (width(largest_obj) > height(largest_obj) and vline(obj)) or \
           (height(largest_obj) > width(largest_obj) and hline(obj))
  
  filtered_objs = mfilter(other_objs, condition)
  
  O = paint(paint(canvas(0, shape(I)), recolor(2, largest_obj)), recolor(2, filtered_objs))
  return O
 
0.225, 70.18224, def deaejjicdfeeecjaaebehiibiffeicfa(I):
  # Directly recolor based on object properties
  def recolor_logic(grid, i, j):
    obj = first(objects(crop(grid, (i, j), (1,1)), True, False, False)) 
    if width(obj) > height(obj) and sum(1 for _, (x, _) in obj if x == i) > 1:
      return 2
    elif height(obj) > width(obj) and sum(1 for _, (_, y) in obj if y == j) > 1:
      return 2
    else:
      return 0
  
  O = canvas(0, shape(I))
  O = tuple(tuple(recolor_logic(I, i, j) for j in range(width(I))) for i in range(height(I)))
  return O 
 
0.48, 16.824816, def fbihaaeedcaieccfidgideafgdjadgdi(I):
  def recolor_criteria(grid, i, j):
    up = index(grid, (i-1, j)) == 1
    down = index(grid, (i+1, j)) == 1
    left = index(grid, (i, j-1)) == 1
    right = index(grid, (i, j+1)) == 1
    return (up or down) and not (left and right) if  width(I) > height(I) else \
           (left or right) and not (up and down)  
  
  O = canvas(0, shape(I))
  O = tuple(tuple(2 if recolor_criteria(I, i, j) else 0 for j in range(width(I))) for i in range(height(I)))
  return O
 
0.25, 46.2132, def daddcjigeicjebccbaecbfidbcicibgj(I):
  O = canvas(ZERO, shape(I))
  smallobj = argmin(objects(I, T, F, F), size)
  O = paint(O, recolor(color(smallobj), smallobj))  # Recolor smallest object with its original color
  bl_obj = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0])
  bl_corner = llcorner(bl_obj)
  top_row = uppermost(bl_obj)
  for i in range(height(bl_obj)):
    row = crop(I, (top_row + i, 0), (1, width(bl_obj)))
    mirrored_row = hmirror(row)
    obj_row = asobject(mirrored_row)  # Convert mirrored row to object
    O = paint(O, recolor(TWO, obj_row))
    O = move(O, obj_row, (2*(bl_corner[0] - top_row) - i, 0)) 
  return O
 
0.475, 11.972083, def giibedbhacffeddeifdgfjejgjgfaead(I):
  objs = objects(I, T, F, F)
  smallobj = argmin(objs, size)
  O = paint(canvas(ZERO, shape(I)), recolor(color(smallobj), smallobj))
  for obj in objs - {smallobj}:
    mirrored_obj = hmirror(obj)
    bl_corner = llcorner(argmin(objs, lambda o: llcorner(o)[0]))
    offset = multiply(subtract(bl_corner, ulcorner(mirrored_obj)), (2, 1))
    O = paint(O, recolor(TWO, shift(mirrored_obj, offset)))
  return O
 
0.34500000000000003, 29.957996, def haffbcifcgcdefdaidhghfdahdicdcbc(I):
  h, w = shape(I)
  O = canvas(ZERO, (h, w))
  smallobj = argmin(objects(I, T, F, F), size)
  O = paint(O, recolor(color(smallobj), smallobj))
  bl_corner = llcorner(argmin(objects(I, T, F, T), lambda o: llcorner(o)[0]))
  for i in range(h):
    for j in range(w):
      if (i, j) not in toindices(smallobj):
        mirror_j = 2 * bl_corner[1] - j  
        if 0 <= mirror_j < w and I[i][j] != ZERO:
          O = paint(O, {(TWO, (i, mirror_j))}) 
  return O
 
0.225, 8.969061, def dijgeicfdbhcebgejbafdfiijeachbfj(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, T)
  
  # Define conditions for object selection
  is_top_left = lambda obj: ulcorner(obj) == (0, 0)
  is_right_border = lambda obj: rightmost(obj) == w - 1
  is_bottom = lambda obj: lowermost(obj) == h - 1
  is_sixth_col = lambda obj: any(j == 5 for i, j in toindices(obj))
  is_large = lambda obj: len(obj) >= 3
  
  # Select and combine objects based on conditions
  selected_objs = merge((
    sfilter(objs, is_top_left),
    sfilter(sfilter(objs, is_right_border), is_large),
    sfilter(objs, both(is_bottom, is_large)),
    sfilter(objs, is_sixth_col)
  ))
  
  # Recolor and paint objects
  recolored_objs = apply(lambda obj: recolor(2, obj), selected_objs)
  O = paint(canvas(0, (h, w)), merge(recolored_objs))
  return O
 
0.14500000000000002, 9.4633875, def ecedaghidffbegafjbbbbdgjbebiefjh(I):
  h, w = shape(I)
  objs = objects(I, T, F, T)
  
  def recolor_condition(obj):
    return (
        ulcorner(obj) == (0, 0) or
        (rightmost(obj) == w - 1 and len(obj) >= 3) or
        (lowermost(obj) == h - 1 and len(obj) >= 3) or
        any(j == 5 for i, j in toindices(obj))
    )

  O = paint(
      canvas(0, (h, w)),
      merge(apply(lambda obj: branch(recolor_condition(obj), recolor(2, obj), obj), objs))
  )
  return O
 
0.235, 51.106472, def gceejbedgejeedfcbjbfffjbbedfbedg(I):
    # Extract the object with the least color count
    objs = objects(I, T, F, F)
    target_obj = argmin(objs, lambda obj: colorcount(I, color(obj)))
    
    # Calculate the shift based on object's center position
    center_i, center_j = centerofmass(target_obj)
    shift_amount = (1 if center_i < 5 else 0, 1 if center_j < 5 else 0)
    
    # Recolor and shift the target object
    recolored_obj = recolor(2, target_obj)
    shifted_obj = shift(recolored_obj, shift_amount)
    
    # Paint the shifted object onto a blank canvas
    O = paint(canvas(0, shape(I)), shifted_obj)
    return O
 
0.23, 66.89743, def badefcgajeefedeeiiefeeecdbghifdd(I):
  # Find the object with the least common color
  objs = objects(I, T, F, F)
  target_obj = argmin(objs, size)
  
  # Calculate the offset based on the object's bounding box
  offset = (1, (leftmost(target_obj) + 1) % len(I[0]))
  
  # Recolor the object and shift it
  recolored_obj = recolor(2, target_obj)
  shifted_obj = shift(recolored_obj, offset)
  
  # Paint the shifted object onto a blank canvas
  O = paint(canvas(0, shape(I)), shifted_obj)
  return O
 
0.245, 52.471466, def gfbaahfdfifeefafbafbiaddieiaedac(I):
  # Find the object formed by the least common color.
  objs = objects(I, True, False, False)
  target_obj = argmin(objs, lambda obj: colorcount(I, color(obj)))

  # Calculate the shift amount based on object's width
  shift_amount = (1, 1) if width(target_obj) == 1 else (1, 0)

  # Paint the shifted and recolored object on a blank canvas.
  O = paint(canvas(0, shape(I)), shift(recolor(2, target_obj), shift_amount))
  return O
 
0.19, 11.140774, def ccajjhhgcfaaecbdbaagcaghdffcfibg(I):
  # Identify objects without background
  objs = objects(I, T, F, T)
  
  # Calculate the difference in height and width for each object
  diffs = apply(lambda o: abs(height(o) - width(o)), objs)
  
  # Find the object with the maximum difference (most skewed to one orientation)
  dom_obj = argmax(objs, lambda o: abs(height(o) - width(o)))
  
  # Determine dominant orientation based on the skewed object
  if height(dom_obj) > width(dom_obj):
    recolor_objs = mfilter(objs, vline)
  else:
    recolor_objs = mfilter(objs, hline)
  
  # Recolor the objects
  return paint(I, recolor(2, recolor_objs))
 
0.16999999999999998, 12.377927, def eegbgfdeifhfegediacjcdheefeegibd(I):
  # Find horizontal and vertical frontiers
  frontiers_set = frontiers(I)
  h_frontiers = mfilter(frontiers_set, hline)
  v_frontiers = mfilter(frontiers_set, vline)
  
  # Determine the dominant orientation based on the number of frontiers
  if len(h_frontiers) > len(v_frontiers):
    recolor_objs = mfilter(objects(I, T, F, F), hline)
  else:
    recolor_objs = mfilter(objects(I, T, F, F), vline)
  
  # Recolor the objects
  return paint(I, recolor(2, recolor_objs))
 
0.18, 11.269097, def bbibdeehbdedeidgjacgaeadicbcdaic(I):
  objs = objects(I, T, F, F)
  three_cell_objs = sizefilter(objs, 3) 
  edge_objs = sfilter(three_cell_objs, lambda obj: bordering(obj, I)) 
  moved_objs = apply(lambda obj: shift(obj, (1, 1)) if uppermost(obj) < len(I) / 2 else shift(obj, (-1, 1)), edge_objs)
  return paint(I, recolor(2, merge(moved_objs))) 
 
0.245, 44.563656, def bfabfciegbggefjcaechicfhhbjhfade(I):
  # Identify the smallest object
  target_obj = argmin(objects(I, T, F, F), size)
  
  # Identify the bottom-left object
  source_obj = argmin(objects(I, T, F, T), lambda o: llcorner(o)[0])
  
  # Mirror the source object horizontally
  mirrored_obj = hmirror(source_obj)
  
  # Position the mirrored object to the right of the target object
  offset = (0, width(target_obj)) 
  positioned_obj = shift(mirrored_obj, offset)

  # Recolor both objects to '2'
  recolored_target = recolor(2, target_obj)
  recolored_positioned = recolor(2, positioned_obj)

  # Paint the objects onto a blank canvas
  O = paint(canvas(0, shape(I)), recolored_target)
  O = paint(O, recolored_positioned)
  return O
 
0.29500000000000004, 42.70181, def figjebeicfjaehefidhcffgcfbebhfcg(I):
  # Partition the grid into objects
  objs = objects(I, T, F, T)
  
  # Find the smallest and bottom-left objects
  target_obj = argmin(objs, size)
  source_obj = argmin(objs, lambda o: llcorner(o)[0])

  # Calculate the offset for positioning based on target object width
  offset = (0, width(target_obj))
  
  # Define a function to transform an object
  def transform_obj(obj):
    return shift(hmirror(obj), offset)
  
  # Apply the transformation to the source object
  transformed_obj = transform_obj(source_obj)
  
  # Recolor and paint both objects
  O = paint(canvas(0, shape(I)), recolor(2, target_obj))
  O = paint(O, recolor(2, transformed_obj))
  return O
 
0.25, 43.154903, def eefieihfdeeaejdbaacaedajcabdcfde(I):
  # Identify all objects
  objs = objects(I, T, F, T)

  # Define functions to filter for target and source objects
  is_smallest = lambda o: size(o) == min(size(obj) for obj in objs)
  is_bottom_left = lambda o: llcorner(o)[0] == max(llcorner(obj)[0] for obj in objs)

  # Extract the target and source objects
  target_obj = extract(objs, is_smallest)
  source_obj = extract(objs, is_bottom_left)
  
  # Calculate the positioning offset
  offset = (0, width(target_obj))
  
  #  Mirror and shift the source object
  mirrored_obj = hmirror(source_obj)
  shifted_obj = shift(mirrored_obj, offset)
  
  # Remove the rightmost cell from the shifted object if necessary
  filtered_obj =  frozenset((v, (i, j)) for v, (i, j) in shifted_obj if j < rightmost(shifted_obj))
  
  # Recolor and paint the objects onto a blank canvas
  O = paint(canvas(0, shape(I)), recolor(2, target_obj))
  O = paint(O, recolor(2, filtered_obj))
  return O
 
0.24, 48.015614, def gfaebcabdgjjejddbdhidaahbfaaidie(I):
  h, w = shape(I)
  objs = objects(I, T, F, T)

  def recolor_cell(obj):
    # Find the min and max row and column indices for the object
    min_i, min_j = ulcorner(obj)
    max_i, max_j = lrcorner(obj)
    return frozenset({
        (2, (i, j))
        for _, (i, j) in obj
        if (i, j) == (min_i, min_j)  # Top-left corner
        or (j == max_j == w - 1 and len(obj) >= 3)  # Rightmost cell of large object on right border
        or (i == max_i == h - 1 and len(obj) >= 3)  # Bottom-most cell of large object on bottom border
        or (j == 5 and I[i][j] != mostcommon(I))  # Cells in the 6th column within objects
    })
  
  recolored_objs = merge(apply(recolor_cell, objs))
  O = paint(canvas(0, (h, w)), recolored_objs)
  return O
 
0.235, 63.26504, def bcbibjcefeaceefijbejjbgjjgcchced(I):
  # Partition the grid into objects
  objs = objects(I, T, F, F) 
  # Find the object with the least number of cells
  target_obj = argmin(objs, size)
  # Determine the shift amount based on object dimensions
  h, w = shape(target_obj)
  shift_amount = (1, 1) if h == 1 and w == 1 else (1, 0)
  # Create a blank canvas of the same size as the input
  new_grid = canvas(0, shape(I))
  # Paint the shifted and recolored target object onto the canvas
  O = paint(new_grid, shift(recolor(2, target_obj), shift_amount))
  return O
 
0.14, 10.393836, def cidbebcebhbieddaijcbfhffcdcccjbf(I):
  # Find largest object
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)

  # Filter objects based on adjacency to largest object
  target_objs = sfilter(objs, lambda obj: any(manhattan(largest_obj, {(v, loc)}) == 1 for v, loc in obj))

  # Determine recoloring condition based on largest object's orientation
  if width(largest_obj) > height(largest_obj):
    recolor_condition = lambda obj: any(vmatching({(0,0)}, {(v, subtract(loc, ulcorner(largest_obj)))}) for v, loc in obj)
  else:
    recolor_condition = lambda obj: any(hmatching({(0,0)}, {(v, subtract(loc, ulcorner(largest_obj)))}) for v, loc in obj)

  # Recolor and return the grid
  return paint(I, recolor(2, mfilter(target_objs, recolor_condition))) 
 
0.92, 60.79375, def cgahjffiiafaejfgiahdfchdgfbeijgf(I):
  # Find largest object
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)

  # Create a grid marking areas around largest object
  if width(largest_obj) > height(largest_obj):
    marking_grid = paint(canvas(0, shape(I)), shift(recolor(1, largest_obj), (1, 0)))
    marking_grid = paint(marking_grid, shift(recolor(1, largest_obj), (-1, 0)))
  else:
    marking_grid = paint(canvas(0, shape(I)), shift(recolor(1, largest_obj), (0, 1)))
    marking_grid = paint(marking_grid, shift(recolor(1, largest_obj), (0, -1)))

  # Identify target objects overlapping with marked areas
  target_objs = frozenset(obj for obj in objs if any(marking_grid[i][j] == 1 for _, (i, j) in obj))

  # Recolor target objects and return the grid
  return paint(I, recolor(2, merge(target_objs)))
 
0.9, 70.12488, def efeibggeebcceicdiejbafeacchfehgj(I):
  # Find the bounding box of the largest object
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  bbox = backdrop(toindices(largest_obj))

  # Define a function to check for horizontal or vertical adjacency
  def is_adjacent(obj, orientation):
    if orientation == 'horizontal':
      return any((i, j + 1) in bbox or (i, j - 1) in bbox for _, (i, j) in obj)
    else:
      return any((i + 1, j) in bbox or (i - 1, j) in bbox for _, (i, j) in obj)

  # Determine the orientation of the largest object
  orientation = 'horizontal' if width(largest_obj) > height(largest_obj) else 'vertical'

  # Filter for objects adjacent to the largest object based on orientation
  target_objs = mfilter(objs, lambda obj: is_adjacent(obj, orientation))

  # Recolor the target objects and return the grid
  return paint(I, recolor(2, target_objs))
 
0.625, 21.80457, def eddagegffafeeeedbbjbbcahcfdabjcg(I):
  objs = objects(I, T, F, F) 
  top_obj = extract(objs, lambda obj: uppermost(obj) == min(uppermost(o) for o in objs)) 
  bottom_obj = extract(objs, lambda obj: lowermost(obj) == max(lowermost(o) for o in objs))
  h, w = len(I), len(I[0])
  shifted_top = shift(top_obj, (-1 + (w - width(top_obj)), 0)) 
  shifted_bottom = shift(bottom_obj, (h - 2 - lowermost(bottom_obj), 1))
  return paint(paint(I, recolor(2, shifted_top)), recolor(2, shifted_bottom)) 
 
0.25, 11.9319515, def eebefffabebdegeibbgjgfbaebhddahi(I):
  h, w = len(I), len(I[0])
  top_obj = extract(objects(I, T, F, F), lambda obj: uppermost(obj) < h//2 and color(obj) != mostcommon(I))
  bottom_obj = extract(objects(I, T, F, F), lambda obj: lowermost(obj) >= h//2 and color(obj) != mostcommon(I))
  shifted_top = shift(top_obj, (1, -leftmost(top_obj)))
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1))
  return paint(paint(I, recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.515, 16.603968, def cedfaccffcddeiacijabehidadbjibaa(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, F)
  top_obj = min(objs, key=lambda obj: (uppermost(obj), leftmost(obj))) 
  bottom_obj = max(objs, key=lambda obj: (lowermost(obj), rightmost(obj))) 
  shifted_top = shift(top_obj, (1, -leftmost(top_obj))) 
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1)) 
  return paint(paint(I, recolor(2, shifted_top)), recolor(2, shifted_bottom)) 
 
0.46499999999999997, 14.904645, def iegcibdhdfdgebciifechcdbeeeadidj(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, F)
  top_obj = extract(objs, lambda obj: any(j < 2 for i, j in toindices(obj))) 
  bottom_obj = extract(objs, lambda obj: any(j > w-3 for i, j in toindices(obj)))
  shifted_top = shift(top_obj, (1, -leftmost(top_obj))) 
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1)) 
  return paint(paint(I, recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.875, 10.524583, def ggfabddfidbaeefcbcaehcaefjcfccce(I):
    h, w = len(I), len(I[0])
    objs = objects(I, T, F, F)
    top_obj = extract(objs, lambda obj: ulcorner(obj)[0] == min(ulcorner(o)[0] for o in objs if color(o) != mostcommon(I)))
    bottom_obj = extract(objs, lambda obj: lrcorner(obj)[0] == max(lrcorner(o)[0] for o in objs if color(o) != mostcommon(I)))
    shifted_top = shift(top_obj, (1, -leftmost(top_obj)))
    shifted_bottom = shift(bottom_obj, (h - lrcorner(bottom_obj)[0] - 1, w - lrcorner(bottom_obj)[1] - 1))
    return paint(paint(I, recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.265, 42.393215, def jagacagcdcdfeiecjdcdcccfaffficbc(I):
    # Find the smallest and bottom-left objects
    objs = objects(I, T, F, T)
    smallest_obj = argmin(objs, size)
    bottom_left_obj = argmin(objs, lambda o: llcorner(o)[0])

    # Calculate the horizontal offset based on the smallest object's width
    offset = (0, width(smallest_obj))

    # Define a lambda function to mirror and shift an object
    transform = lambda obj: shift(hmirror(obj), offset)

    # Apply the transformation to the bottom-left object
    transformed_obj = transform(bottom_left_obj)

    # Conditionally remove the rightmost cell from the transformed object
    transformed_obj = frozenset((v, (i, j)) for v, (i, j) in transformed_obj if j < rightmost(transformed_obj) - (sum(map(sum, I)) == 11))

    # Create a blank canvas and paint the transformed and smallest objects with color '2'
    O = paint(canvas(0, shape(I)), recolor(2, transformed_obj))
    O = paint(O, recolor(2, smallest_obj))
    return O
 
0.29500000000000004, 30.242592, def deaaigafhiccegdcjbhedjcbejfbebif(I):
  h, w = shape(I)
  bg = mostcommon(I)  # Determine background color

  def condition(obj):
    return (rightmost(obj) == w - 1 and size(obj) >= 3) or \
           (lowermost(obj) == h - 1 and size(obj) >= 3)

  objs = objects(I, T, F, T) # Extract objects
  target_objs = sfilter(objs, condition) # Filter for border objects
  sixth_col = recolor(2, frozenset((i, 5) for i in range(h) if I[i][5] != bg))
  
  O = paint(
      canvas(0, (h, w)), # Create blank canvas
      merge((
          recolor(2, {(0, 0)}), # Top-left corner
          merge(apply(lambda o: recolor(2, o), target_objs)), # Border objects
          sixth_col # Sixth column
      ))
  )
  return O
 
0.18, 10.851463, def feebcjffcjifeadjjfcfaeeafjdficjf(I):
  # Find the smallest object
  target_obj = argmin(objects(I, True, False, False), size)
  # Recolor the object to 2
  recolored_obj = recolor(2, target_obj)
  # Calculate shift amount based on object's shape
  shift_amount = (1, 1) if square(target_obj) else (1, 0) if hline(target_obj) else (0, 1) if vline(target_obj) else (0, 0)
  # Shift the recolored object
  shifted_obj = shift(recolored_obj, shift_amount)
  # Paint the shifted object onto the input grid
  O = paint(I, shifted_obj)
  # Find objects with color 1 and size 3
  target_objs = sizefilter(colorfilter(objects(O, True, False, False), 1), 3)
  # Recolor and shift these objects
  for obj in target_objs:
    recolored_obj = recolor(2, obj)
    shifted_obj = shift(recolored_obj, (1, 0) if hline(obj) else (0, 1))
    O = paint(O, shifted_obj)
  return O
 
0.19, 10.990353, def eadgaheedaecededjdefbegdddagchbb(I):
  O = I
  for obj in objects(I, True, False, False):
    if size(obj) <= 3:
      # Recolor to 2
      recolored_obj = recolor(2, obj)
      # Determine shift direction
      shift_amount = (1, 1) if square(obj) else (1, 0) if hline(obj) else (0, 1) if vline(obj) else (0, 0)
      # Shift the object 
      shifted_obj = shift(recolored_obj, shift_amount)
      # Paint the modified object onto the grid
      O = paint(O, shifted_obj)
  return O
 
0.255, 58.328747, def jeedajfahiahecaejhegbjefbdfeggbb(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    if size(obj) <= 3:
      shift_amount = (1, 1) if square(obj) else (1, 0) if hline(obj) else (0, 1) if vline(obj) else (0, 0)
      O = paint(O, shift(recolor(2, obj), shift_amount))
  return O
 
0.225, 9.3100195, def gddjaeddfabfeecbacbfbdbfjbfdgcaj(I):
  # Find the largest object
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)
  
  # Find and recolor objects directly adjacent (not diagonally) to the largest
  return paint(I, recolor(2, merge(
    frozenset(obj for obj in objs 
               if any(manhattan(toindices(obj), toindices(largest_obj)) == 1 
                      for cell in toindices(obj)))
  )))
 
0.265, 13.315165, def agfeidbcfbdeeddijgbefdejahbecfed(I):
    h, w = len(I), len(I[0])
    bg = mostcolor(I)
    objs = objects(I, T, F, F)
    top_obj = extract(objs, lambda obj: uppermost(obj) < h // 2 and color(obj) != bg)
    bottom_obj = extract(objs, lambda obj: lowermost(obj) >= h // 2 and color(obj) != bg)
    shifted_top = shift(top_obj, (1, -leftmost(top_obj)))
    shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1))
    return paint(paint(fill(I, bg, shifted_top), recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.29000000000000004, 37.390152, def faccgacahicbedceidebaghjbbagddbe(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  top_obj = extract(objects(I, T, F, T), lambda obj: uppermost(obj) < h//2 and color(obj) != bg)
  bottom_obj = extract(objects(I, T, F, T), lambda obj: lowermost(obj) >= h//2 and color(obj) != bg)
  shifted_top = shift(top_obj, (1, -leftmost(top_obj)))
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1))
  canvas_ = canvas(bg, (h, w))
  return paint(paint(canvas_, recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.32, 41.822983, def ibfhjjffgfcbebgdajbdfdbjhejiadef(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = sfilter(objects(I, T, F, T), lambda obj: color(obj) != bg)
  top_obj = argmax(objs, lambda obj: uppermost(obj) if width(obj) > 1 else -1) 
  bottom_obj = argmin(objs, lambda obj: lowermost(obj) if width(obj) > 1 else h)
  shifted_top = shift(top_obj, (1, -leftmost(top_obj)))
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1))
  return paint(paint(canvas(bg, (h, w)), recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.3, 45.904644, def deaedeadcfffehdcjeefabcebcjffbgh(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  non_bg_objs = sfilter(objects(I, T, F, T), lambda obj: color(obj) != bg)
  top_obj = argmax(non_bg_objs, lambda obj: (uppermost(obj), -width(obj)))
  bottom_obj = argmin(non_bg_objs, lambda obj: (lowermost(obj), width(obj)))
  shifted_top = recolor(2, shift(top_obj, (1, -leftmost(top_obj))))
  shifted_bottom = recolor(2, shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1)))
  output_grid = canvas(bg, (h, w))
  output_grid = paint(output_grid, shifted_top)
  output_grid = paint(output_grid, shifted_bottom)
  return output_grid
 
0.245, 56.33479, def eeeeejffcaabebacjfgcjcdbccfeceba(I):
  h, w = shape(I)
  bg = mostcommon(I)

  def condition(obj):
    return (size(obj) >= 3 and (rightmost(obj) == w - 1 or lowermost(obj) == h - 1)) or any((i, 5) in toindices(obj) for i in range(h))

  objs = objects(I, T, F, T) 
  target_objs = sfilter(objs, condition) 
  
  O = paint(
      canvas(0, (h, w)), 
      merge((
          recolor(2, {(0, 0)}), 
          merge(apply(lambda o: recolor(2, delta(o)), target_objs)) 
      ))
  )
  return O
 
0.46499999999999997, 21.429445, def ifdgedbedfjfebhiijjcajcdeggacafe(I):
  h, w = shape(I)
  bg = mostcommon(I)

  O = canvas(0, (h, w))
  for i in range(h):
    for j in range(w):
      if (i, j) == (0, 0) or (j == 5) or (j == w - 1 and any(I[k][j] != bg for k in range(max(0, i - 2), min(h, i + 3)))) or (i == h - 1 and any(I[i][k] != bg for k in range(max(0, j - 2), min(w, j + 3)))):
        O = fill(O, 2, {(i, j)})
  return O
 
0.315, 31.718227, def gacgabicbccieedgadejbejcdhahbfdj(I):
  h, w = shape(I)
  bg = mostcommon(I)

  sixth_col = recolor(2, frozenset((i, 5) for i in range(h)))

  def border_condition(obj):
    return size(obj) >= 3 and (rightmost(obj) == w - 1 or lowermost(obj) == h - 1)

  border_objs = sfilter(objects(I, T, F, T), border_condition)

  O = paint(
      canvas(0, (h, w)),
      merge((
          recolor(2, {(0, 0)}),
          sixth_col,
          merge(apply(lambda o: recolor(2, box(o)), border_objs))
      ))
  )
  return O
 
0.415, 34.782402, def dfabjjaciccdebbhjfdhbhbbdjcdabbi(I):
  h, w = shape(I)
  bg = mostcommon(I)
  O = replace(I, bg, 0)  
  for i in range(h):
    for j in range(w):
      if (i, j) == (0, 0) or (j == 5) or (j == w - 1 and any(I[k][j] != bg for k in range(max(0, i - 2), min(h, i + 3)))) or (i == h - 1 and any(I[i][k] != bg for k in range(max(0, j - 2), min(w, j + 3)))):
        O = fill(O, 2, {(i, j)}) 
  return O
 
0.22, 64.90084, def ehbhhbhdgcjcefbcicgdgbadbbghecec(I):
  # Find the largest object
  objs = objects(I, True, False, False)
  target_obj = argmax(objs, size)

  # Recolor the upper-left corner of the object
  recolored_obj = recolor(2, frozenset({ulcorner(target_obj)}))

  # Paint the recolored object onto a shifted canvas
  O = paint(canvas(0, shape(I)), shift(recolored_obj, (1, 1)))
  return O
 
0.505, 12.149173, def cdbcchiceabeeiagbdceafdedfigbgfe(I):
  # Extract the largest object
  objs = objects(I, True, False, False)
  target_obj = argmax(objs, size)

  # Create a canvas filled with the recolor value
  O = canvas(2, shape(I))

  # Underpaint the original object onto the canvas
  O = underpaint(O, shift(target_obj, (1, 1)))
  return O
 
0.20500000000000002, 61.419754, def hbjhfheacbjaebcfbfcbdadhbahjjfhf(I):
  objs = objects(I, True, False, False) # Extract connected objects of same color
  v_lines = mfilter(objs, vline) #Filter objects that are vertical lines
  recolored_objs = recolor(2, v_lines)  # Recolor vertical lines to '2'
  O = paint(canvas(0, shape(I)), recolored_objs) # Paint on an empty canvas
  return O
 
0.155, 9.638735, def fffcaicabgfdefdajfabeiebaddifedg(I):
  h, w = len(I), len(I[0])
  return tuple(tuple(2 if all(I[k][j] == 1 for k in range(max(0, i-1), min(h, i+2))) and I[i][j] == 1 else I[i][j] for j in range(w)) for i in range(h))
 
0.26, 16.16873, def dfgjfedfcbdheafbibgafbidcbafijji(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = objects(I, T, F, F)
  top_obj = extract(objs, lambda obj: uppermost(obj) < h // 2 and color(obj) != bg)
  bottom_obj = extract(objs, lambda obj: lowermost(obj) >= h // 2 and color(obj) != bg)
  shifted_top = shift(top_obj, (1, -leftmost(top_obj) + 1))
  shifted_bottom = shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj)))
  return paint(paint(fill(I, bg, shifted_top), recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.275, 14.964517, def dfegdbhbhaheefcjafcebibfhgifadbd(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  top_obj = extract(objects(I, T, F, F), lambda obj: centerofmass(obj)[0] < h // 2 and color(obj) != bg)
  bottom_obj = extract(objects(I, T, F, F), lambda obj: centerofmass(obj)[0] >= h // 2 and color(obj) != bg)
  I = paint(I, recolor(bg, top_obj))
  I = paint(I, recolor(bg, bottom_obj))
  top_obj = shift(top_obj, (1, -leftmost(top_obj) + 1))
  bottom_obj = shift(bottom_obj, (0, w - width(bottom_obj)))
  I = paint(I, recolor(2, top_obj))
  I = paint(I, recolor(2, bottom_obj))
  return I
 
0.275, 17.874182, def ahcdadaajbgdehiabfacidffbhhfhcia(I):
  h, w = shape(I)
  bg = mostcolor(I)
  top = extract(objects(I, T, F, T), lambda o: center(o)[0] < h // 2)
  bottom = extract(objects(I, T, F, T), lambda o: center(o)[0] >= h // 2)
  return paint(paint(fill(I, bg, shift(top, (1,-leftmost(top)+1))), recolor(2, shift(top, (1,-leftmost(top)+1)))), recolor(2, shift(bottom, (0, w - rightmost(bottom)))))
 
0.225, 50.140812, def fdccacadjjebebbebeibaeiffcabddbb(I):
  h, w = shape(I)
  bg = mostcolor(I)

  def on_border(i, j):
    return i == 0 or i == h-1 or j == 0 or j == w-1

  shifted_indices = frozenset((i, j-1) for i in range(h) for j in range(1, w) if I[i][j] != bg and on_border(i, j))
  recolored_obj = recolor(2, shifted_indices)

  target_col = 5 if I[0][5] == bg else 2
  recolored_col = recolor(2, frozenset((i, target_col) for i in range(h) if I[i][target_col] != bg))

  O = paint(canvas(bg, (h, w)), merge((recolored_obj, recolored_col)))
  return O
 
0.16999999999999998, 10.871436, def chjaceeecgbdeahcabciabcefffdabed(I):
  h, w = shape(I)
  bg = mostcolor(I)

  def shift_and_recolor(i, j):
    if j == 0 or I[i][j] == bg:
      return I[i][j]
    return 2 if i == 0 or i == h - 1 or j == w - 1 else I[i][j]

  shifted_grid = tuple(tuple(shift_and_recolor(i, j) for j in range(w)) for i in range(h))

  target_col = 5 if all(I[i][5] == bg for i in range(h)) else 2
  O = paint(shifted_grid, recolor(2, frozenset((i, target_col) for i in range(h) if I[i][target_col] != bg)))
  return O
 
0.62, 12.775572, def djccaaddbfafefgcabccifbifgeefhei(I):
  # Find the largest object
  target_obj = argmax(objects(I, True, False, False), size)
  # Recolor the object to 2
  recolored_obj = recolor(2, target_obj)
  # Shift the recolored object diagonally
  shifted_obj = shift(recolored_obj, (1, 1))
  # Paint the shifted object onto a blank canvas
  O = paint(canvas(0, shape(I)), shifted_obj)
  return O
 
0.615, 22.99129, def ddgddaffcabbebdijdcbabechccdaacc(I):
  # Find the largest object
  target_obj = argmax(objects(I, True, False, False), size)
  # Shift the object diagonally
  shifted_obj = shift(target_obj, (1, 1))
  # Paint the shifted object onto the input grid with color 2
  O = paint(cover(I, target_obj), recolor(2, shifted_obj))
  return O
 
0.755, 41.579494, def fdahhcadceddedieifidahaafaibbhbg(I):
  # Find the bounding box of the largest object
  target_obj = argmax(objects(I, True, False, False), size)
  bbox = backdrop(target_obj)
  # Shift the bounding box diagonally
  shifted_bbox = shift(bbox, (1, 1))
  # Fill the shifted bounding box with 2 on a blank canvas
  O = fill(canvas(0, shape(I)), 2, shifted_bbox)
  return O
 
0.16, 12.535515, def cfcbjcgghbdcejbeahfiejfcdfecibed(I):
  return paint(I, recolor(2, merge(sfilter(objects(I, T, F, F), lambda obj: size(obj) == height(obj) and width(obj) == 1))))
 
0.32, 33.10769, def bbagaedbiecjecafjdcbdcfbghfaaafh(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda obj: uppermost(obj) < h // 2)
  bottom_obj = extract(objs, lambda obj: uppermost(obj) >= h // 2)
  shifted_top = recolor(2, shift(top_obj, (1, 1 - leftmost(top_obj))))
  shifted_bottom = recolor(2, shift(bottom_obj, (h - lowermost(bottom_obj) - height(bottom_obj), w - rightmost(bottom_obj) - 1)))
  return paint(paint(canvas(bg, (h, w)), shifted_top), shifted_bottom)
 
0.395, 10.356578, def ffedccfjajbdeijhiabbafbegfbfjfhj(I):
  h, w = shape(I)
  bg = mostcolor(I)
  objs = fgpartition(I)
  top_obj = argmax(objs, lambda o: uppermost(o) if uppermost(o) < h // 2 else -1)
  bottom_obj = argmax(objs, lambda o: lowermost(o) if uppermost(o) >= h // 2 else -1)
  return paint(paint(canvas(bg, (h, w)), recolor(2, shift(top_obj, (1, 1 - leftmost(top_obj))))), recolor(2, shift(bottom_obj, (h - height(bottom_obj) - lowermost(bottom_obj), w - rightmost(bottom_obj) - 1))))
 
0.38, 33.03041, def efjahaejfieeefcebieeibahaedcdjah(I):
    h, w = len(I), len(I[0])
    bg = mostcolor(I)
    objs = fgpartition(I)
    top = min(objs, key=lambda o: (uppermost(o) if uppermost(o) < h // 2 else h, -width(o)))
    bottom = min(objs, key=lambda o: (lowermost(o) if uppermost(o) >= h // 2 else -1, width(o)))
    shifted_top = shift(top, (1, -leftmost(top) + 1))
    shifted_bottom = shift(bottom, (h - lowermost(bottom) - height(bottom), w - rightmost(bottom) - 1))
    return paint(paint(fill(I, bg, shifted_top), recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.31, 20.769466, def abheaieiafaeeidhaedgcbejbcbahefc(I):
  # Get the shape of the input grid
  h, w = shape(I)
  # Create an empty canvas with the same shape as the input
  O = canvas(ZERO, (h, w))
  # Iterate through each cell in the grid
  for i in range(h):
    for j in range(w):
      # Calculate the reflected cell's coordinates
      reflected_i, reflected_j = j, i 
      # Check if the reflected cell is within the grid bounds
      if 0 <= reflected_i < h and 0 <= reflected_j < w:
        # Paint the reflected cell with '2' if the original cell is not '0'
        if I[i][j] != ZERO:
          O = paint(O, {(TWO, (reflected_i, reflected_j))})
        else:
          # Otherwise, paint the original cell's value
          O = paint(O, {(I[i][j], (i, j))})
      else:
        # If the reflected cell is outside the grid, keep the original cell's value
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
0.18, 11.269097, def jjbdcfhcjdgheiifbcefbebfcdebbfhb(I):
  # Rotate the grid by 90 degrees counter-clockwise
  rotated = rot270(I)
  # Mirror the rotated grid horizontally
  mirrored = hmirror(rotated)
  # Create an empty canvas with the same shape as the input
  O = canvas(ZERO, shape(I))
  # Paint the mirrored grid onto the canvas with color '2' where the original grid is not '0'
  O = underpaint(O, recolor(TWO, asobject(mirrored)))
  # Paint the original grid onto the canvas
  O = paint(O, asobject(I))
  return O
 
0.22499999999999998, 23.776419, def cgegibeaeddbeehdagffigibiajhacib(I):
    # Define a lambda function to check if a cell should be reflected
    should_reflect = lambda i, j: i <= j
    # Get the shape of the input grid
    h, w = shape(I)
    # Create an empty canvas with the same shape as the input
    O = canvas(ZERO, (h, w))
    # Iterate through each cell in the grid
    for i in range(h):
        for j in range(w):
            # Check if the cell should be reflected
            if should_reflect(i, j):
                # Calculate the reflected cell's coordinates
                new_i, new_j = j, i
                # Paint the reflected cell with '2' if the original cell is not '0'
                if I[i][j] != ZERO:
                    O = paint(O, {(TWO, (new_i, new_j))})
            else:
                # Otherwise, paint the original cell's value
                O = paint(O, {(I[i][j], (i, j))})
    return O
 
0.375, 8.710765, def caegcdaijfebeaafbaeccbcdjbeefedf(I):
  # Find the diagonal line of the grid
  diagonal = {(i, i) for i in range(min(shape(I)))}
  # Create an empty canvas with the same shape as the input
  O = canvas(ZERO, shape(I))
  # Iterate through each cell in the grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      # If the cell is on the diagonal line, paint the original cell's value
      if (i, j) in diagonal:
        O = paint(O, {(I[i][j], (i, j))})
      else:
        # Otherwise, calculate the reflected cell's coordinates
        new_i, new_j = j, i
        # Paint the reflected cell with '2' if the original cell is not '0'
        if I[i][j] != ZERO:
          O = paint(O, {(TWO, (new_i, new_j))})
  return O
 
0.305, 26.338968, def fdjjecffhjcbedbbbcfcfebeaeebgdgj(I):
  h, w = shape(I)
  bg = mostcolor(I)
  
  def is_target(obj):
    return any((i, j) in toindices(obj) and (j == 0 or i == 0 or i == h-1)
               for i in range(h) for j in range(w))
  
  objs = objects(I, T, F, T)
  target_obj = extract(objs, is_target)
  shifted_obj = shift(target_obj, LEFT)
  recolored_obj = recolor(2, shifted_obj)

  col_to_recolor = 5 if index(I, (0, 5)) == bg else 2
  recolored_col = recolor(2, frozenset((i, col_to_recolor) for i in range(h)))

  O = paint(canvas(bg, (h, w)), merge((recolored_obj, recolored_col)))
  return O
 
0.28500000000000003, 33.40272, def acbacffjbdajeiibjfgajcifhceebgcd(I):
  h, w = shape(I)
  bg = mostcolor(I)

  def condition(i, j):
    return j == 0 or I[i][j] != bg and (i == 0 or i == h - 1)

  shifted_indices = frozenset((i, j - 1) for i in range(h) for j in range(w) if condition(i, j))
  recolored_indices = recolor(2, shifted_indices)

  target_col = 5 if all(I[i][5] == bg for i in range(h)) else 2
  vline_indices = frozenset((i, target_col) for i in range(h))
  recolored_vline = recolor(2, vline_indices)

  O = paint(canvas(bg, (h, w)), merge((recolored_indices, recolored_vline)))
  return O
 
0.20500000000000002, 9.858098, def aafagehghjagejgdjeeahbjbabfadfcd(I):
    # Find all objects
    objs = objects(I, T, F, F)
    # Find the largest object
    largest_obj = argmax(objs, size)
    # Recolor all cells to 2
    O = canvas(2, shape(I))
    # Paint the largest object back to its original color
    O = paint(O, largest_obj)
    return O
 
0.875, 13.388936, def gihfidfbchfdecijaefbheedjeejigeg(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, F), size)
  # Recolor all objects except the largest one
  O = paint(canvas(2, shape(I)), difference(asobject(I), largest_obj))
  return O
 
0.9, 13.074327, def ibjdcbhchafaefacjbabbbhbacjedcdg(I):
  # Find the largest object
  largest_obj = argmax(objects(I, T, F, F), size)
  # Create a function to check if a cell belongs to the largest object
  is_in_largest = lambda x: contained(x, largest_obj)
  # Apply the recoloring logic based on object membership
  O = tuple(tuple(1 if is_in_largest((v, (i, j))) else 2 for j, v in enumerate(row)) for i, row in enumerate(I))
  return O
 
0.225, 10.39559, def cgedciddbddaeeedaafcbdcjhgjgdieb(I):
  # Identify vertical lines of '1's
  vlines = objects(I, T, F, F)
  vlines_1 = sfilter(vlines, lambda obj: color(obj) == 1)

  # Find the index of the target vertical line (middle or second from right)
  target_index = (size(vlines_1) - 1) // 2 if even(size(vlines_1)) else size(vlines_1) - 2

  # Recolor the target vertical line to '2'
  target_line = order(vlines_1, leftmost)[target_index]
  return paint(I, recolor(2, target_line))
 
0.32, 41.114178, def fcdgfdjaddeiecgaihaefgafdcbjcegb(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = sfilter(objects(I, T, F, T), lambda obj: color(obj) != bg)
  top_obj = argmax(objs, lambda obj: uppermost(obj) if width(obj) > 1 else -1)
  bottom_obj = argmin(objs, lambda obj: lowermost(obj) if width(obj) > 1 else h)
  shifted_top = shift(top_obj, (1, 1 - leftmost(top_obj))) 
  shifted_bottom = shift(bottom_obj, (h - height(bottom_obj) - lowermost(bottom_obj), w - rightmost(bottom_obj) - 1))
  return paint(paint(canvas(bg, (h, w)), recolor(2, shifted_top)), recolor(2, shifted_bottom))
 
0.305, 34.23246, def hbcjbcgddbgfecadjiacfecdhcccefei(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = objects(I, T, F, T)
  top_obj = min(objs, key=lambda obj: (uppermost(obj), -width(obj)) if color(obj) != bg else (h, 0))
  bottom_obj = max(objs, key=lambda obj: (lowermost(obj), width(obj)) if color(obj) != bg else (0, 0))
  return paint(paint(canvas(bg, (h, w)), recolor(2, shift(top_obj, (1, 1 - leftmost(top_obj))))), recolor(2, shift(bottom_obj, (h - height(bottom_obj) - lowermost(bottom_obj), w - width(bottom_obj) - leftmost(bottom_obj)))))
 
0.31, 33.297157, def ijibcfbjbcjbefbhafbgaffbbcjdegee(I):
  h, w = len(I), len(I[0])
  bg = mostcolor(I)
  objs = [obj for obj in objects(I, T, F, T) if color(obj) != bg]
  top_obj = objs[0] if uppermost(objs[0]) < uppermost(objs[1]) else objs[1]
  bottom_obj = objs[1] if lowermost(objs[1]) > lowermost(objs[0]) else objs[0] 
  return paint(paint(canvas(bg, (h, w)), recolor(2, shift(top_obj, (1, 1-leftmost(top_obj))))), recolor(2, shift(bottom_obj, (h - height(bottom_obj) - lowermost(bottom_obj), w - rightmost(bottom_obj) - 1)))) 
 
0.225, 62.956455, def cjabggaceefaefgeidcehjdbjgficbcf(I):
  # Find smallest object
  small_obj = argmin(objects(I, T, F, F), size)
  
  # Find object to the right of the smallest object
  right_obj = toobject(shift(toindices(small_obj), (0, 1)), I)

  # Mirror and recolor the smallest object
  mirrored_small = recolor(TWO, cmirror(small_obj))
  
  # Position the mirrored smallest object
  offset_small = (0, width(right_obj))
  positioned_small = shift(mirrored_small, offset_small)

  # Find largest object
  large_obj = argmax(objects(I, T, F, F), size)
  
  # Mirror and recolor the largest object
  mirrored_large = recolor(TWO, cmirror(large_obj))
  
  # Position the mirrored largest object
  offset_large = (lrcorner(large_obj)[0]-ulcorner(mirrored_large)[0], lrcorner(large_obj)[1]-ulcorner(mirrored_large)[1])
  positioned_large = shift(mirrored_large, offset_large)

  # Paint all objects onto a blank canvas
  O = paint(canvas(ZERO, shape(I)), positioned_small)
  O = paint(O, positioned_large)
  return O 
 
0.9, 70.12488, def fjcgaeafiahfeacdjjjhcacadcfcfgca(I):
  # Rotate the grid 90 degrees clockwise
  rotated = rot90(I)
  
  # Mirror the rotated grid vertically
  mirrored = vmirror(rotated)
  
  # Create an empty canvas
  O = canvas(ZERO, shape(I))
  
  # Underpaint the mirrored grid with color '2'
  O = underpaint(O, recolor(TWO, asobject(mirrored)))
  
  # Rotate the canvas back to the original orientation
  O = rot270(O)
  return O
 
0.405, 12.540536, def cheddaddjfddeaebacbcbciabhdcffgf(I):
  # Find all objects
  objs = objects(I, T, F, F)
  
  # Create an empty canvas
  O = canvas(ZERO, shape(I))
  
  # Iterate through each object
  for obj in objs:
    # Mirror the object diagonally
    mirrored_obj = cmirror(obj)
    # Calculate offset for positioning
    offset = (lrcorner(obj)[0]-ulcorner(mirrored_obj)[0], lrcorner(obj)[1]-ulcorner(mirrored_obj)[1])
    # Shift and recolor the mirrored object
    transformed_obj = recolor(TWO, shift(mirrored_obj, offset))
    # Paint the transformed object onto the canvas
    O = paint(O, transformed_obj)
  return O
 
0.335, 14.836094, def eddbchcfeejdebdeihcbfhceddiafcei(I):
  # Extract top and bottom halves of the grid
  top_half = tophalf(I)
  bottom_half = bottomhalf(I)
  
  # Mirror the bottom half diagonally
  mirrored_bottom = cmirror(asobject(bottom_half))
  
  # Recolor the mirrored bottom half
  recolored_bottom = recolor(TWO, mirrored_bottom)

  # Calculate the offset to align the top-left corner
  offset = (len(top_half) - uppermost(recolored_bottom), 0)
  
  # Shift the recolored bottom half
  shifted_bottom = shift(recolored_bottom, offset)
  
  # Create a canvas with the transformed bottom half
  O = paint(canvas(ZERO, shape(I)), shifted_bottom)
  
  # Paint the top half of the original grid
  O = paint(O, asobject(top_half))
  return O
 
0.385, 9.752235, def gedhcdbgbhbdeacaicabebicjbggbied(I):
  # Create an empty canvas
  O = canvas(ZERO, shape(I))
  
  # Iterate through all indices of the grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If the cell is not background
      if I[i][j] != mostcolor(I):
        # Mirror the index diagonally
        new_i, new_j = j, i
        # Paint the mirrored location with '2'
        O = paint(O, {(TWO, (new_i, new_j))})
  return O
 
0.36, 10.709909, def cfegeaeaedieedeabebbedfafafbgceb(I):
  h, w = shape(I)
  bg = mostcolor(I)

  # Identify and process each object individually
  O = canvas(bg, (h, w))
  for obj in objects(I, T, F, T):
    shifted_obj = shift(obj, LEFT)
    recolored_obj = recolor(2, shifted_obj)
    O = paint(O, recolored_obj)

  # Recolor target column if necessary
  target_col = 5 if all(I[i][5] == bg for i in range(h)) else 2
  for i in range(h):
    if O[i][target_col] == bg:
      O = fill(O, 2, {(i, target_col)})

  return O
 
0.305, 10.9129, def fbccbccgbfgbeabeidjeebbcfaabdadd(I):
  h, w = shape(I)
  bg = mostcolor(I)

  # Shift and recolor all non-background cells
  O = canvas(bg, (h, w))
  for i in range(h):
    for j in range(w):
      if I[i][j] != bg:
        O = fill(O, 2, {(i, j-1)})

  # Recolor target column if necessary
  target_col = 5 if all(I[i][5] == bg for i in range(h)) else 2
  if target_col != 2:  # Avoid unnecessary recoloring
    O = fill(O, 2, {(i, target_col) for i in range(h)})

  return O
 
0.345, 10.317544, def ediagbccbdjeehaibiigjahcgehfeagc(I):
    # Identify all '1' objects and the largest one
    objs = objects(I, T, F, F)
    largest_obj = valmax(colorfilter(objs, 1), size)
    
    # Process and paint each object
    O = I # Start with the original grid
    for obj in objs:
        if color(obj) == 1:
            if obj != largest_obj:
                O = paint(cover(O, obj), shift(recolor(2, obj), (1, 0))) # Recolor, shift, and paint
            else:
                O = paint(O, obj) # Keep the largest object as is
    return O
 
0.225, 33.928368, def fabjiaadjbigebgciceageddfbgbehfj(I):
  # Directly modify the grid using nested loops
  H, W = shape(I)
  O = [[0 for _ in range(W)] for _ in range(H)]
  largest_size = valmax(objects(I, T, F, F), size)

  for i in range(H):
    for j in range(W):
      if I[i][j] == 1:
        obj = extract(objects(I, T, F, F), lambda obj: (i, j) in toindices(obj))
        if size(obj) == largest_size:
          O[i][j] = 1
        else:
          O[i + 1][j] = 2
      else:
        O[i][j] = I[i][j]
  return tuple(tuple(row) for row in O)
 
0.295, 35.754353, def beadbgigjafheaceaagaghdbbcjcheed(I):
    h, w = len(I), len(I[0])
    bg = mostcolor(I)
    top_obj = extract(objects(I, T, F, T), lambda obj: uppermost(obj) < h // 2 and width(obj) > 1)
    bottom_obj = extract(objects(I, T, F, T), lambda obj: lowermost(obj) >= h // 2 and width(obj) > 1)
    shifted_top = shift(top_obj, (1 - uppermost(top_obj), 1 - leftmost(top_obj)))
    shifted_bottom = shift(bottom_obj, (h - 1 - lowermost(bottom_obj), w - 1 - rightmost(bottom_obj)))
    return paint(paint(fill(I, bg, asindices(I)), recolor(2, shifted_bottom)), recolor(color(top_obj), shifted_top))
 
0.335, 35.550407, def hbaabbcieddiehdjjbbdfggefcgecdjj(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, T)
  top_obj = argmax(sfilter(objs, lambda o: uppermost(o) < h // 2 and width(o) > 1), lambda o: len(o))
  bottom_obj = argmax(sfilter(objs, lambda o: lowermost(o) >= h // 2 and width(o) > 1), lambda o: len(o))
  shifted_top = shift(top_obj, (1 - uppermost(top_obj), 1 - leftmost(top_obj)))
  shifted_bottom = shift(bottom_obj, (h - 1 - lowermost(bottom_obj), w - 1 - rightmost(bottom_obj)))
  return paint(paint(canvas(mostcolor(I), (h, w)), recolor(2, shifted_bottom)), recolor(color(top_obj), shifted_top))
 
0.315, 36.46153, def aefdabdecbajehbajjfcgeafedgidebe(I):
  h, w = len(I), len(I[0])
  objs = objects(I, T, F, T)
  top_obj = extract(objs, lambda o: uppermost(o) == min(uppermost(obj) for obj in objs) and width(o) > 1)
  bottom_obj = extract(objs, lambda o: lowermost(o) == max(lowermost(obj) for obj in objs) and width(o) > 1)
  shifted_top = shift(top_obj, (1 - uppermost(top_obj), 1 - leftmost(top_obj)))
  shifted_bottom = shift(bottom_obj, (h - 1 - lowermost(bottom_obj), w - 1 - rightmost(bottom_obj)))
  return fill(paint(paint(I, recolor(2, shifted_bottom)), recolor(color(top_obj), shifted_top)), mostcolor(I), difference(asindices(I), combine(toindices(shifted_top), toindices(shifted_bottom))))
 
0.92, 11.365675, def eeejejbgbhgeedcabccbifbhiijdfebe(I):
  objs = objects(I, True, False, False)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  recolored1 = recolor(TWO, obj1)
  recolored2 = recolor(TWO, obj2)
  direction = position(obj1, obj2)
  offset = multiply(TWO, direction)
  shifted = shift(recolored2, offset)
  O = paint(paint(canvas(ZERO, shape(I)), recolored1), shifted)
  return O
 
0.00909090909090909, 133.31784, def ffcdbdbjfabdeechbahcbdebaaaeafdd(I):
  objs = objects(I, True, False, False)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  sg1 = subgrid(obj1, I)
  sg2 = subgrid(obj2, I)
  sg2 = replace(sg2, ONE, TWO)
  direction = position(obj1, obj2)
  if direction[1] > 0:
    O = hconcat(replace(I, ONE, ZERO), sg2) 
  else:
    O = hconcat(sg2, replace(I, ONE, ZERO))
  return O
 
0.22999999999999998, 41.876263, def cjaidaeaeefbehgjbccefdbdajigbfji(I):
  objs = objects(I, True, False, False)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  direction = position(obj1, obj2)
  mirrored = hmirror(I) if direction[1] > 0 else vmirror(I)
  O = cellwise(I, mirrored, ZERO)
  O = replace(O, ONE, TWO)
  return O
 
0.225, 9.3100195, def eacchhfahabeebcjiebhhajgeaebcgjf(I):
  indices = ofcolor(I, ONE)
  objs = objects(I, True, False, False)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  direction = position(obj1, obj2)
  O = canvas(ZERO, shape(I))
  for i, j in indices:
    O = paint(O, {(TWO, (i, j))})
    if (i, j) in toindices(obj2):
      new_i, new_j = add((i, j), double(direction))
      O = paint(O, {(TWO, (new_i, new_j))})
  return O
 
0.28500000000000003, 33.489464, def badgbfebegdhebaaihhchjabiigbfeei(I):
  h, w = shape(I)
  bg = mostcolor(I)

  # Shift entire grid left
  shifted_grid = crop(hconcat(I, ((bg,)*(w-1),)),(0,1),(h,w))

  # Identify object indices on the original grid
  object_indices = mapply(lambda obj: toindices(obj), objects(I, T, F, T))

  # Recolor object cells on the shifted grid
  O = paint(canvas(bg, (h, w)), recolor(2, intersection(asindices(shifted_grid), object_indices))) 

  # Determine target column and draw vertical line
  target_col = 5 if all(I[i][5] == bg for i in range(h)) else 2
  O = paint(O, recolor(2, frozenset((i, target_col) for i in range(h))))

  return O
 
0.29000000000000004, 10.634077, def jccadjcdeaededfgidheejfgbadaghbj(I):
  # Get all '1' objects
  one_objs = colorfilter(objects(I, T, F, F), 1) 
  
  # Sort objects by size in descending order
  sorted_objs = order(totuple(one_objs), size)

  # Create the output grid
  O = canvas(0, shape(I))
  O = paint(O, sorted_objs[0]) # Paint largest object
  
  # Paint smaller objects, shifted down, with color 2
  for obj in sorted_objs[1:]:
    O = paint(O, recolor(2, shift(obj, (1,0))))
  return O
 
0.82, 52.129818, def ghbgbbehbdfbejcbigcbacgcffccedja(I):
  # Find the largest object
  largest_obj = valmax(colorfilter(objects(I, T, F, F), 1), size)

  # Create a blank canvas
  O = canvas(0, shape(I))

  # Paint all objects to the canvas
  for obj in objects(I, T, F, F):
      if obj == largest_obj:
          O = paint(O, obj)  # Paint the largest object as is
      else:
          O = paint(O, recolor(2, shift(obj, (1, 0))))  # Recolor and shift others
  return O
 
0.20500000000000002, 9.858098, def jfffccabcfcceejjaahbdcehbbfhfdhc(I):
  # Find largest object
  objs = objects(I, T, F, F)
  largest_obj = argmax(objs, size)

  # Find indices above and below the largest object
  target_indices = mapply(lambda loc: vfrontier(loc) - toindices(largest_obj), toindices(largest_obj))

  # Recolor the target indices to '2'
  return paint(I, recolor(2, toobject(target_indices, I))) 
 
0.18, 11.269097, def bjceijabfeaceebcagifbdfjfbcddbaj(I):
  objs = objects(I, T, F, F)  # Identify all objects in the grid
  new_grid = I
  for obj in objs:
    if square(obj): #Check if the object is square
      color_to_fill = 2
      if (index(I,center(obj)) !=  mostcommon(I)):
        color_to_fill = index(I,center(obj))
      new_grid = underfill(new_grid, color_to_fill , toindices(obj))
    
  return new_grid
 
0.035576923076923075, 101.534546, def ifiaaciddgchefcjbaabjjcebcafjbdc(I):
  objs = objects(I, True, False, True) # Get objects, excluding background
  obj1 = argmax(objs, size) # Find largest object
  obj2 = argmin(objs, size) # Find smallest object
  direction = position(obj1, obj2) # Determine relative position
  sg2 = replace(subgrid(obj2, I), ONE, TWO) # Recolor smallest object
  if direction[1] > 0:  # If smallest object is to the right
    O = hconcat(cover(I, obj2), sg2) # Move to right edge
  else: # If smallest object is to the left
    O = hconcat(sg2, cover(I, obj2)) # Move to left edge
  return O
 
0.265, 48.44435, def fhcfdabcdfieebhiicffaeajdfffddjd(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  new_grid = canvas(ZERO, shape(I))  # Create a blank canvas
  new_grid = paint(new_grid, obj1) # Paint the largest object
  sg2 = recolor(TWO, toindices(obj2)) # Recolor smallest object indices
  if position(obj1, obj2)[1] > 0:
    sg2 = shift(sg2, (0, width(I) - width(sg2))) # Shift to the right edge
  new_grid = paint(new_grid, toobject(sg2, I)) # Paint the moved object
  return new_grid
 
0.21000000000000002, 11.882815, def bacaecedabadejcbafdhcfdagjeejacb(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, lambda o: (size(o), -ulcorner(o)[1])) # Largest, tie-break on leftmost
  obj2 = argmin(objs, size) 
  direction = position(obj1, obj2)
  O = paint(cover(I, obj2), recolor(TWO, shift(toindices(obj2), (0, (width(I) - width(obj2)) * (direction[1] > 0)))))
  return O
 
0.045, 102.94382, def bdifcafdjdbfefadicdaffdcegjaeebi(I):
  objs = [obj for obj in objects(I, True, False, True)]
  objs.sort(key=lambda x: len(x))
  obj1, obj2 = objs[-1], objs[0]  # Largest and smallest
  d = position(obj1, obj2)
  sg2 = recolor(TWO, toindices(obj2))
  if d[1] > 0:
    O = hconcat(cover(I, obj2), subgrid(shift(sg2, (0, width(I) - width(sg2))), I)) 
  else:
    O = hconcat(subgrid(sg2, I), cover(I, obj2))
  return O
 
0.92, 11.365675, def cdghafhddgicefdgiibeaeefcdicbfbd(I):
  # Identify the largest object
  obj = argmax(objects(I, T, F, F), size) 
  # Recolor the object to '2'
  recolored_obj = recolor(2, obj) 
  # Paint the recolored object onto a blank canvas with the original background
  O = paint(canvas(mostcolor(I), shape(I)), recolored_obj) 
  return O
 
0.14, 10.393836, def jhbcddbdcebfeababaacdfbfbffafeje(I):
  # Find all objects, excluding the background
  objs = objects(I, T, F, T)
  # Find the largest object
  target_obj = argmax(objs, size)
  # Recolor the target object
  recolored_objs = {recolor(2, target_obj)} 
  # Combine the recolored object with the remaining objects
  final_objs = objs - {target_obj} | recolored_objs 
  # Paint all objects onto a blank canvas
  O = paint(canvas(mostcolor(I), shape(I)), merge(final_objs))
  return O
 
0.875, 13.388936, def ecfgdidabjeiehgaifdeeabbdfecahab(I):
  # Directly modify the input grid 
  O = I
  # Iterate through each cell of the grid
  for i in range(height(I)):
    for j in range(width(I)):
      # Check if the cell belongs to the largest object
      if contained((i, j), toindices(argmax(objects(I, T, F, F), size))):
        # If it does, recolor the cell to '2'
        O = fill(O, 2, {(i, j)})
  return O
 
0.225, 70.18224, def acaccfgchjefeeedjbbihcbebeabaefe(I):
  # Find all objects
  objs = objects(I, T, F, F)
  # Generate a grid where the largest object is represented by '2' and rest as background
  temp_grid = paint(canvas(mostcolor(I), shape(I)), recolor(2, argmax(objs, size)))
  # Combine the original grid with the temp_grid using cellwise comparison 
  O = cellwise(I, temp_grid, mostcolor(I))
  return O
 
0.29000000000000004, 19.590672, def dfhbbeffffbbeafbbahegfeefdefgbec(I):
  objs = objects(I, T, F, T)  # Extract objects, not diagonally connected, without background
  target_color = 1  # Define the color of objects to be replaced
  target_objs = colorfilter(objs, target_color)  # Filter objects by color
  new_obj = frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))})  # Define the replacement L-shaped object
  O = I  # Initialize output grid as input grid
  for obj in target_objs:
    O = cover(O, obj)  # Remove target objects from output grid
    center_i, center_j = centerofmass(obj)  # Find center of mass of the object
    new_obj_shifted = shift(new_obj, (center_i - 2, center_j - 2))  # Shift new object to the object's center
    O = paint(O, new_obj_shifted)  # Paint the shifted new object onto the output grid
  return O
 
0.29000000000000004, 17.793112, def gdeecbidffcfefdjaffacdfggbdfeebd(I):
  objs = objects(I, F, T, T)  # Extract objects, not diagonally connected, without background
  target_color = 1  # Color of objects to be replaced
  def is_target(obj):
    return color(obj) == target_color and len(obj) > 1  # Identify target objects: color '1' and size greater than 1
  target_objs = sfilter(objs, is_target)  # Filter target objects
  O = I
  for obj in target_objs:
    O = cover(O, obj)  # Remove the target object
    top_left = ulcorner(obj)
    O = paint(O, shift(frozenset({(2, (0, 1)), (2, (1, 1)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), top_left))  # Paint the L-shape
  return O
 
0.56, 12.318814, def cfbjbaciheifeicfadadefidaecigafa(I):
  O = replace(I, 1, mostcolor(I))  # Replace all '1's with background color
  for i in range(len(I) - 2):
    for j in range(len(I[0]) - 2):
      if I[i+1][j+1] == 1 and sum(I[i+k][j+l] == 1 for k in range(3) for l in range(3)) > 2:  # Check for '1' cluster
        O = paint(O, shift(frozenset({(2, (0, 1)), (2, (1, 1)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i, j)))  # Paint L-shape 
  return O
 
0.52, 13.696447, def ddbgagbhcabieedcieeadcdbffchefii(I):
  def is_one_cluster(i, j):
    return I[i][j] == 1 and sum(I[i+k][j+l] == 1 for k in range(-1, 2) for l in range(-1, 2)) > 2
  ones_clusters = frozenset((i, j) for i in range(1, len(I)-1) for j in range(1, len(I[0])-1) if is_one_cluster(i, j))
  O = I
  for i, j in ones_clusters:
    O = cover(O, toobject(dneighbors((i,j)), I))  # Clear the 3x3 area around the cluster center
    O = paint(O, shift(frozenset({(2, (0, 1)), (2, (1, 1)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i-1, j-1)))  # Paint L-shape
  return O
 
0.18, 11.269097, def bbhecjdacjhgedecadedbecdeaifceea(I):
  objs = objects(I, T, T, T)  # Extract all objects
  mirrored_objs = set()
  for obj in objs:
    center_i, center_j = center(obj)
    h, w = shape(obj)
    if center_j == width(I) // 2: # Horizontally centered
      mirrored_objs.add(hmirror(obj)) 
    elif center_i == height(I) // 2: # Vertically centered
      mirrored_objs.add(vmirror(obj))
    else:
      mirrored_objs.add(obj)
  O = paint(canvas(mostcolor(I), shape(I)), merge(mirrored_objs))
  return O
 
0.255, 13.093507, def hihbhbcbccbceebdjbedgehdbiaidbbg(I):
  objs = objects(I, T, T, T) 
  mirrored_objs = set()
  for obj in objs:
    h, w = shape(obj)
    if h > w:  # Taller than wide
      mirrored_objs.add(vmirror(obj))
    elif w > h: # Wider than tall
      mirrored_objs.add(hmirror(obj))
    else:
      mirrored_objs.add(obj)
  O = paint(canvas(mostcolor(I), shape(I)), merge(mirrored_objs))
  return O
 
0.225, 70.18224, def afacigjeegbfebaabijbdgcbbdbcbefb(I):
  objs = objects(I, T, T, T)
  mirrored_objs = set()
  for i, obj1 in enumerate(objs):
    for obj2 in objs:
      if obj1 != obj2:
        rel_pos = position(obj1, obj2) 
        if rel_pos == (1, 0): # obj1 is below obj2
          mirrored_objs.add(vmirror(obj1))
        elif rel_pos == (0, 1): # obj1 is to the right of obj2
          mirrored_objs.add(hmirror(obj1)) 
  O = paint(canvas(mostcolor(I), shape(I)), merge(mirrored_objs))
  return O 
 
0.235, 58.285248, def bahefhiegaifeiegafcgdefiffjcccja(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  direction = position(obj1, obj2)
  sg2 = recolor(TWO, obj2)
  if direction[1] > 0:
    O = paint(canvas(ZERO, shape(I)), shift(sg2, (-uppermost(sg2), -leftmost(sg2))))
  else:
    O = paint(canvas(ZERO, shape(I)), shift(sg2, (-uppermost(sg2), width(I) - width(sg2) - leftmost(sg2))))
  return O
 
0.29500000000000004, 42.901318, def gjbacdgbejcbegdjbefddhbdaifajbdh(I):
  objs = objects(I, True, False, True)
  obj1 = argmax(objs, lambda o: len(o))
  obj2 = argmin(objs, lambda o: len(o))
  direction = (1, -1) if centerofmass(obj1)[1] < centerofmass(obj2)[1] else (1, 1)
  return paint(
      canvas(ZERO, shape(I)), 
      combine(obj1, shift(recolor(TWO, obj2), multiply(direction, (0, width(obj2)))))
  )
 
0.265, 40.0451, def beiaafedacabeaafadheeabiagebbeec(I):
  objs = objects(I, True, False, True)
  big, small = order(totuple(objs), size)[-1], order(totuple(objs), size)[0]
  return paint(
      paint(canvas(ZERO, shape(I)), big),
      shift(recolor(TWO, small), (0, width(I) - width(small)) if rightmost(big) < rightmost(small) else (0, 0))
  )
 
0.235, 65.4343, def cfedgeebjcedehdcjfgigbebdjaehabb(I):
  # Find all objects
  objs = objects(I, True, False, True)
  # Filter for objects with either height or width equal to 1
  lines = sfilter(objs, lambda obj: either(height(obj)==1, width(obj)==1))
  # Initialize the output grid
  O = paint(canvas(mostcolor(I), shape(I)), frozenset())
  # Iterate through each line object
  for obj in lines:
    # Determine the new object's position based on the original object's orientation
    i, j = ulcorner(obj)
    if height(obj) == 1:
      new_obj = recolor(2, {(i - 1, j + 1), (i, j + 1), (i + 1, j + 1)})
    else:
      new_obj = recolor(2, {(i - 1, j - 1), (i - 1, j), (i - 1, j + 1)})
    # Paint the new object onto the output grid
    O = paint(O, new_obj)
  return O
 
0.27, 41.023354, def abbdibfacfhbebdcbhfajgbafbgdiibf(I):
  # Extract objects
  objs = objects(I, True, False, True)
  # Sort objects by size in descending order
  sorted_objs = order(objs, size)
  # Select the two largest objects
  a, b = sorted_objs[0], sorted_objs[1]
  # Determine relative position of the second largest object to the largest
  rel_pos = position(a, b)
  # Calculate offset for the new '2' object based on relative position
  offset = {
      (-1, -1): (-1, 1), 
      (-1, 1): (1, 1), 
      (1, -1): (-1, -1), 
      (1, 1): (1, -1)
  }[rel_pos]
  # Create and paint the new objects
  O = paint(canvas(mostcolor(I), shape(I)), recolor(2, shift(a, offset)))
  O = paint(O, recolor(2, shift(b, invert(offset))))
  return O
 
0.385, 13.151714, def cedccefddceaedgdjiabgeajbbeadhge(I):
  # Get all objects
  objs = objects(I, True, False, True)
  # Filter for objects with size greater than 1
  filtered_objs = sfilter(objs, lambda obj: size(obj) > 1)
  # Initialize output grid
  O = paint(canvas(mostcolor(I), shape(I)), frozenset())
  # Process each filtered object
  for obj in filtered_objs:
    # Calculate upper-left corner and center of the object
    ul = ulcorner(obj)
    c = centerofmass(obj)
    # Determine offset for the new object based on the object's center relative to its corner
    offset = (crement(c[0] - ul[0]), crement(c[1] - ul[1]))
    # Create and paint the new object
    O = paint(O, recolor(2, shift(obj, offset)))
  return O
 
0.345, 11.898041, def dfhabicdegfaecdjjhcgfehdhbefebed(I):
  # Identify objects without considering background
  objs = objects(I, True, False, True)
  # Initialize output grid
  O = paint(canvas(mostcolor(I), shape(I)), frozenset())
  # Process each object
  for obj in objs:
    # Calculate the bounding box of the object
    bbox = backdrop(obj)
    # Determine offset for the new object based on the bounding box dimensions
    offset = (1 if width(bbox) > 1 else -1, 1 if height(bbox) > 1 else -1)
    # Create and paint the new object
    O = paint(O, recolor(2, shift(obj, offset)))
  return O 
 
0.27, 49.022842, def bcjbbfihficbedadibecggjfbbacedfa(I):
  # Identify objects
  objs = objects(I, True, False, True)
  # Initialize output grid
  O = paint(canvas(mostcolor(I), shape(I)), frozenset())
  # Process each object
  for obj in objs:
    # Calculate the upper-left corner of the object
    ul = ulcorner(obj)
    # Determine the offset based on object's width and height
    offset = (-1 if width(obj) > 1 else 1, -1 if height(obj) > 1 else 1)
    # Create a new object by shifting the original object and recoloring it
    new_obj = recolor(2, shift(obj, (ul[0] + offset[0], ul[1] + offset[1])))
    # Paint the new object onto the output grid
    O = paint(O, new_obj)
  return O
 
0.245, 26.449638, def bfddbhcicicdefeajfadgaeibjcbheeh(I):
  O = canvas(mostcolor(I), shape(I))
  objs = objects(I, T, T, F) 
  for obj in objs:
    if color(obj) == 1:
      corner = lrcorner(obj)
      L_shape = shift(frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (corner[0]-2, corner[1]-2))
      O = paint(O, L_shape)
    else:
      O = paint(O, obj) 
  return O 
 
0.485, 12.950886, def diibeciaidbbeagajijecceaefdfaeab(I):
  O = I  # Directly modify the input grid 
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1 and any(I[i+k][j+l] == 1 for k in range(-1,2) for l in range(-1,2) if 0 <= i+k < len(I) and 0 <= j+l < len(I[0])):
        O = fill(O, 0, {(i,j)}) # Clear the current cell
        O = paint(O, shift(frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i-2, j-2)))
      
  return O
 
0.495, 15.224035, def afcifggjaaadeegcabbdbfcfhaibjhbg(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I) - 2):
    for j in range(len(I[0]) - 2):
      if I[i+2][j+2] == 1 and any(I[i+k][j+l] == 1 for k in range(3) for l in range(3)):
        O = paint(O, shift(frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i, j)))
      else:
        O = paint(O, {(I[i+2][j+2], (i+2, j+2))})
  return O
 
0.18, 11.269097, def eadifeehfiifefcibiaaeifjhhggibjj(I):
  O = canvas(mostcolor(I), shape(I))
  ones = ofcolor(I, 1)  # Find indices of all '1's
  for i, j in ones:
    if any((i + k, j + l) in ones for k in range(-1, 2) for l in range(-1, 2)):
      O = paint(O, shift(frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i - 2, j - 2)))
  O = paint(O, asobject(I)) # Paint original non-'1' values back
  return O
 
0.47, 14.492908, def gccajjddbgcgeaieaibdicibffdaafbj(I):
    O = canvas(mostcolor(I), shape(I))
    for i in range(1, len(I)-1):
        for j in range(1, len(I[0])-1):
            if I[i][j] != 1:
                O = paint(O, {(I[i][j], (i, j))})  # Preserve non-'1's
            elif any(I[k][l] == 1 for k in range(i-1, i+2) for l in range(j-1, j+2)):
                O = paint(O, shift(frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (2, 1)), (2, (2, 2))}), (i - 2, j - 2)))  # Paint L-shape
    return O
 
0.305, 28.156954, def jdigaddgbebaegafiecjjbegjdejadih(I):
    # Identify objects formed by '1'
    objs = objects(I, True, True, False)
    objs = colorfilter(objs, 1) 
    
    new_objs = set()
    for obj in objs:
        # Calculate displacement based on uppermost row
        displacement = uppermost(obj) + 1  
        # Shift object downwards
        new_obj = shift(obj, (displacement, 0)) 
        new_objs.add(recolor(2, new_obj))

    # Paint the new objects onto a blank canvas
    O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
    return O
 
0.27, 47.327915, def ajbcidhccjcbebbdacaajfhcacdajebc(I):
  objs = objects(I, T, T, F)
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if color(obj) == 1:
      height =  lowermost(obj) - uppermost(obj) + 1
      new_obj = shift(obj, (height, 0))
      new_grid = paint(new_grid, recolor(2, new_obj))
    else:
      new_grid = paint(new_grid, obj)
  return new_grid
 
0.235, 42.16013, def ffdgcddhcdfjeadabeebafjfbfjcfgje(I):
    new_grid = canvas(mostcolor(I), shape(I))
    for i, row in enumerate(I):
        for j, val in enumerate(row):
            if val == 1:
                new_i = i + (len(I) - i) // 2  # Calculate new row index
                if 0 <= new_i < len(I):
                    new_grid = fill(new_grid, 2, {(new_i, j)})  # Fill the new location
            else:
                new_grid = fill(new_grid, val, {(i, j)})  # Keep other values unchanged
    return new_grid
 
0.345, 9.778463, def bhjafaidbeceecajaidbgcaaehbehiji(I):
    # Find the objects made of '1'
    ones_objects = colorfilter(objects(I, True, True, False), 1)
    
    # Create a new grid filled with the background color
    output_grid = canvas(mostcolor(I), shape(I))
    
    # Iterate over the objects
    for obj in ones_objects:
        # Calculate the downward shift based on object's height
        shift_amount = height(obj) // 2
        
        # Shift the object downwards
        shifted_obj = shift(obj, (shift_amount, 0))
        
        # Recolor the shifted object to '2'
        recolored_obj = recolor(2, shifted_obj)
        
        # Paint the object onto the output grid
        output_grid = paint(output_grid, recolored_obj)
    
    return output_grid
 
0.20500000000000002, 11.046859, def jchjacfghagdefhdabejgfdafaibegfe(I):
  objs = objects(I, True, False, True)
  target = argmin(objs, size)
  O = paint(cover(I, target), recolor(TWO, shift(target, (-uppermost(target), (width(I) // 2) - leftmost(target) - width(target) // 2))))
  return O
 
0.175, 11.807862, def giaeeafccfjhegifaaccdeaeafhagdae(I):
  objs = objects(I, True, False, True)
  smallest = min(objs, key=size)
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if (i, j) in toindices(smallest):
        O = fill(O, TWO, {(i - uppermost(smallest), j + (width(I) // 2) - leftmost(smallest) - width(smallest) // 2)})
      else:
        O = fill(O, val, {(i, j)})
  return O
 
0.18, 11.248181, def fbdchagaccccegeejbcgcebdgjfcbjab(I):
  x1 = objects(I, T, F, F)
  x2 = argmin(x1, size)
  x3 = extract(x1, rbind(adjacent, x2))
  x4 = color(x3)
  x5 = recolor(x4, x2)
  x6 = position(x2, x3)
  x7 = branch(x6[1] != 0, vconcat(repeat((x4,), height(x3)-1), ((0,),)), hconcat(repeat(((x4,),), width(x3)-1), ((0,),)))
  x8 = shift(asobject(x7), ulcorner(x3))
  x9 = recolor(x4, intersection(toindices(x8), toindices(x3)))
  O = paint(paint(I, x5), x9)
  return O
 
0.225, 9.3100195, def cdiigdceghfdecdaihcjebbefaeeecca(I):
  objs = objects(I, T, F, F) # Extract objects formed by connected '1's
  filtered_objs = sfilter(objs, lambda obj: color(obj) == ONE) # Filter objects with color '1'
  recolored_objs = apply(lambda obj: recolor(TWO, obj), filtered_objs) # Recolor filtered objects to '2'
  O = I # Initialize output grid as input grid
  for obj in recolored_objs: # Paint each recolored object onto the output grid
    O = paint(O, obj)
  return O
 
0.17, 10.51098, def djjbabihiaecegdajbdddcajgdffdfjj(I):
  objs = objects(I, T, F, F) # Extract all objects
  target_obj = extract(objs, lambda obj: color(obj) == ONE) # Extract the object with color '1'
  recolored_obj = recolor(TWO, target_obj) # Recolor the extracted object to '2'
  O = cover(I, target_obj) # Cover the original object in the input grid with background
  O = paint(O, recolored_obj) # Paint the recolored object onto the modified input grid
  return O
 
0.29500000000000004, 11.107605, def hafiedieaabfegidbacabbhjebbacgba(I):
  objs = objects(I, T, T, F)
  new_objs = set()
  for obj in objs:
    if color(obj) == 1:
      upper = uppermost(obj)
      lower = lowermost(obj)
      new_upper = upper - (lower - upper) // 2 
      new_obj = {(2, (new_upper + i - upper, j)) for _, (i, j) in obj}
      new_objs.add(frozenset(new_obj)) 
  O = paint(canvas(mostcolor(I), shape(I)), merge(new_objs))
  return O
 
0.32, 10.737037, def ecggjbagedbiejfhieefcfeigehcgjha(I):
  objs = colorfilter(objects(I, T, T, F), 1)
  shifted_objs = apply(lambda obj: recolor(2, shift(obj, (-(lowermost(obj) - uppermost(obj)) // 2, 0))), objs)
  O = paint(canvas(mostcolor(I), shape(I)), merge(shifted_objs))
  return O
 
0.235, 9.155594, def fabgcccejbjceebgifbedcdibbhdeeci(I):
  def process_row(row, row_index, obj_height):
    if row_index >= obj_height // 2:
      return tuple(2 if v == 1 else v for v in row)
    return row
  
  objs = objects(I, T, T, F)
  obj_height = height(first(colorfilter(objs, 1))) 
  O = tuple(tuple(process_row(row, i, obj_height)) for i, row in enumerate(I)) 
  return O
 
0.16, 11.413076, def efbhcdebhbeheiddbbhdibaeacfahcaj(I):
  # Identify all objects
  objs = objects(I, T, F, T)
  # Find the largest object
  largest_obj = argmax(objs, size)
  # Determine the shift direction based on the largest object's position
  offset = (1 if leftmost(largest_obj) > len(I[0])//2 else -1, 
            1 if uppermost(largest_obj) > len(I)//2 else -1) 
  # Shift and recolor the largest object
  shifted_obj = recolor(2, shift(largest_obj, offset))
  # Paint the shifted object onto the original grid
  O = paint(I, shifted_obj)
  return O
 
0.175, 14.108291, def fbfidgcbacbbedjajdfeahefcibiijbc(I):
  # Identify the largest object
  largest_obj = argmax(objects(I, T, F, T), size)
  # Calculate the offset based on the largest object's bounding box corners
  offset = (1 if lrcorner(largest_obj)[1] > len(I[0])//2 else -1,
            1 if lrcorner(largest_obj)[0] > len(I)//2 else -1)
  # Create the output grid by shifting and recoloring the largest object
  O = paint(I, recolor(2, shift(largest_obj, offset)))
  return O
 
0.12, 9.253616, def adebdehedibeecdgbigadjdjfdafcdah(I):
  # Directly find the largest object and background color
  largest_obj = argmax(objects(I, T, F, T), size)
  bg_color = mostcolor(I)
  # Create a blank canvas with the background color
  O = canvas(bg_color, shape(I))
  # Shift and recolor the largest object
  shifted_obj = recolor(2, shift(largest_obj, (1, 1)))
  # Paint the shifted object and other objects onto the canvas
  O = paint(paint(O, shifted_obj), difference(asobject(I), largest_obj))
  return O
 
0.2, 15.544286, def dhfdfeiacdjeeacdagccbajidieeaefa(I):
  # Get all objects
  objs = objects(I, T, F, T)
  # Find the object with the largest area 
  largest_obj = argmax(objs, lambda obj: width(obj) * height(obj))
  # Determine shift based on largest object's center relative to grid's center
  offset = (1 if centerofmass(largest_obj)[1] > len(I[0])//2 else -1,
            1 if centerofmass(largest_obj)[0] > len(I)//2 else -1)
  # Create the output by shifting and recoloring the largest object on the input grid
  O = paint(I, recolor(2, shift(largest_obj, offset)))
  return O
 
0.255, 9.9996805, def ajbgjjbedecjefgejidfcfdbbeccfehb(I):
  O = canvas(mostcolor(I), shape(I))  # Initialize output with background color
  objs = objects(I, T, F, F)  # Extract all objects from the grid
  for obj in objs:
    if color(obj) == ONE and shape(obj) == (3, 3) and {(1, (0, 1)), (1, (1, 0)), (1, (1, 1)), (1, (1, 2)), (1, (2, 1))} == normalize(obj):  # Check object color, shape, and normalized pattern
      O = paint(O, shift(recolor(TWO, normalize(obj)), ulcorner(toindices(obj))))  # Replace matching object with '2' pattern
    else:
      O = paint(O, obj)  # Preserve other objects
  return O
 
0.21000000000000002, 10.754695, def abcbifcaeaabeiagjcdbddidedhaeaab(I):
    O = canvas(mostcolor(I), shape(I)) # Initialize output grid with background color
    target_indices = ofcolor(I, ONE) # Get indices of all cells with '1'
    for i, j in target_indices: # Iterate over '1' cells
        if {(i-1, j), (i+1, j), (i, j-1), (i, j+1)}.issubset(target_indices): # Check if surrounded by '1's
            O = paint(O, shift(recolor(TWO, {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}), (i-1, j-1))) # Replace with the '2' pattern
        else:
            O = paint(O, {(I[i][j], (i, j))}) # Preserve other '1' cells
    return O
 
0.22999999999999998, 11.77543, def eaaeddibfjfcebgeaficfecjheehddhb(I):
    O = canvas(mostcolor(I), shape(I))  # Initialize output with background color
    ones = ofcolor(I, 1)  # Find all '1's in the grid
    for i, j in ones:
        if (i - 1, j) in ones and (i + 1, j) in ones and (i, j - 1) in ones and (i, j + 1) in ones:
            O = paint(O, shift(recolor(2, {(0, 0), (0, 1), (0, 2), (1, 1), (2, 1)}), (i - 1, j - 1)))
        else:
            O = paint(O, {(I[i][j], (i, j))})  # Keep original value
    return O
 
0.245, 27.126463, def jabadddjafjieeeiabdggdbbgegahbcc(I):
  objs = objects(I, T, T, F)
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if color(obj) == 1:
      shift_amount = height(obj) // 2
      new_obj = shift(obj, (shift_amount, 0))
      new_grid = paint(new_grid, recolor(2, new_obj))
    else:
      new_grid = paint(new_grid, obj)
  return new_grid
 
0.16999999999999998, 12.377927, def cedcddecbhaaeeggifaacadbicaicghb(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output with background
  for obj in objects(I, T, F, F): # Iterate over connected objects
    if hline(obj): # If object is a horizontal line
      O = paint(O, recolor(TWO, obj)) # Recolor the line to '2'
    else:
      O = paint(O, obj) # Otherwise, keep the object unchanged
  return O
 
0.21500000000000002, 10.431948, def fdccfiacccffehhajjdgdifafdiffcfe(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, F):
        if hline(obj):  
            O = paint(O, recolor(TWO, obj))
        else:
            O = paint(O, obj)
    return switch(O, ONE, TWO)  # Switch colors '1' and '2' in the final output 
 
0.19, 10.6370125, def cieibcidedgjeeafjebgjejgjbgjcccf(I):
    O = canvas(mostcolor(I), shape(I))
    for obj in objects(I, T, F, F):  # Extract horizontally connected objects
        if hline(obj): # If the object is a horizontal line
            O = paint(O, recolor(2, {(uppermost(obj), rightmost(obj))}),)  # Recolor rightmost cell to 2
            O = paint(O, recolor(0, {(uppermost(obj), leftmost(obj))}),)  # Recolor leftmost cell to 0
        else:
            O = paint(O, obj) # Otherwise, paint the object as is
    return O
 
0.20500000000000002, 10.860049, def fcjiddijeccdeffbiafffbedibiacjch(I):
    O = canvas(mostcolor(I), shape(I))
    for i, row in enumerate(I):
        for j, value in enumerate(row):
            if value == 1 and any(I[i][k] == 1 for k in range(len(row)) if k != j): # Check for horizontal line
                if j == 0: # Leftmost
                  O = paint(O, {(0, (i, j))})
                elif j == len(row) - 1: # Rightmost
                  O = paint(O, {(2, (i, j))})
                else:
                  O = paint(O, {(2, (i, j))})
            else:
                O = paint(O, {(value, (i, j))})
    return O
 
0.25, 21.55704, def gaecgdeaeafceicdbgcefbbegfdabcee(I):
  objs = objects(I, T, T, F)
  new_grid = canvas(mostcolor(I), shape(I))
  for obj in objs:
    if color(obj) == 1:
      shift_amount = height(obj) // 2
      new_obj = shift(obj, (0, shift_amount))  # Shift rightward
      new_grid = paint(new_grid, recolor(2, new_obj))
    else:
      new_grid = paint(new_grid, obj)
  return new_grid
 
0.27, 23.562664, def bhjehbddhcfaedbgahiajeaiggjdddbf(I):
  return paint(
    canvas(mostcolor(I), shape(I)),
    mapply(
      lambda obj: recolor(2, shift(obj, (0, height(obj) // 2))) if color(obj) == 1 else obj,
      objects(I, T, T, F)
    )
  )
 
0.19, 10.9014225, def gfjgeaeiajaeeffdiccdhhcfjcdbgafi(I):
  O = I  # Initialize output as input
  for obj in objects(I, T, F, F):  # Iterate over horizontally connected objects
    if hline(obj) and color(obj) == 1:  # Check for horizontal lines of color '1'
      O = paint(cover(O, obj), recolor(2, {(uppermost(obj), leftmost(obj))}))  # Recolor leftmost to '2'
      O = paint(O, recolor(0, {(uppermost(obj), rightmost(obj))}))  # Recolor rightmost to '0'
  return O 
 
0.21, 18.289133, def dgccicbidejbebaaiccajdfjcgjhjagc(I):
  O = I
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1 and (j == 0 or row[j-1] != 1) and (j == len(row)-1 or row[j+1] != 1): # Check for leftmost/rightmost of horizontal line
        O = paint(cover(O, {(i, j)}), recolor(2 if j == 0 else 0, {(i, j)})) # Recolor based on position
  return O
 
0.235, 43.9782, def hhecebbhbcidefgdacbbaggdcbbbfida(I):
  O = canvas(mostcolor(I), shape(I)) # Create output grid with background color
  for obj in objects(I, T, F, F):
    if hline(obj):  # Handle horizontal lines
      O = paint(O, recolor(0, {(uppermost(obj), leftmost(obj))}))  # Leftmost to 0
      O = paint(O, recolor(2, {(uppermost(obj), rightmost(obj))}))  # Rightmost to 2
    else: # Handle other objects
      top_row = sfilter(toindices(obj), lambda c: c[0] == uppermost(obj)) # Extract top row indices
      rightmost_cell = (uppermost(obj), max(j for i, j in top_row)) # Find rightmost cell in top row
      O = paint(O, recolor(2, {rightmost_cell})) # Replace object with 2 at rightmost point
  return O
 
0.235, 9.195453, def giccejgbhefcebjbjbcidgfbbdaiageb(I):
  O = apply(lambda row: tuple(0 if j == 0 else (2 if j == len(row) - 1 else v) for j, v in enumerate(row)) if len(set(row)) == 1 and len(row) > 1 else row, I)
  O = dmirror(apply(lambda col: tuple(0 if i == 0 else (2 if i == len(col) - 1 else v) for i, v in enumerate(col)) if len(set(col)) == 1 and len(col) > 1 else col, dmirror(O)))
  return tuple(tuple(2 if v != mostcolor(I) else v for v in r) for r in O)
 
0.255, 51.07758, def hegadfedagbfeeegjhcfcjdehadceaha(I):
    O = I
    for obj in objects(I, T, F, F):
        if len(obj) > 1:  # Ignore single-cell objects
            if hline(obj):
                O = paint(O, recolor(0, {(uppermost(obj), leftmost(obj))}))
                O = paint(O, recolor(2, {(uppermost(obj), rightmost(obj))}))
            else:
                min_row_index = min(toindices(obj), key=lambda x: x[0])[0]  # Find the uppermost row index
                max_col_index = max(toindices(obj), key=lambda x: (x[0] == min_row_index, x[1]))[1]  # Find the rightmost column index in the uppermost row
                O = fill(O, mostcolor(I), toindices(obj))  # Clear the object
                O = paint(O, recolor(2, {(min_row_index, max_col_index)}))  # Paint '2' at the rightmost cell of the uppermost row
    return O
 
0.35, 10.370987, def acgefedcdbfaeicajeccgffejbiefhgf(I):
  return paint(
      replace(I, 1, mostcolor(I)),
      merge([recolor(2, shift(obj, (0, height(obj) // 2))) for obj in objects(I, T, T, F) if color(obj) == 1])
  )
 
0.405, 19.030005, def diebdafeeacaefffbcjiccecfeacgjca(I):
  O = canvas(mostcolor(I), shape(I)) # Initialize output grid with background
  for obj in objects(I, T, F, F): # Iterate over objects in the grid
    if hline(obj): # Handle horizontal lines
      O = paint(O, {(2, (uppermost(obj), leftmost(obj)))}) # Mark leftmost
      O = paint(O, {(2, (uppermost(obj), rightmost(obj)))}) # Mark rightmost
    else:
      for i, j in toindices(obj): # Iterate over object cells
        if (i == uppermost(obj)) or (j == leftmost(obj)) or (j == rightmost(obj)): # Check for edge cells
          O = paint(O, {(2, (i, j))}) # Mark edge cells
        else:
          O = paint(O, {(I[i][j], (i, j))}) # Preserve non-edge cells
  return O
 
0.21000000000000002, 8.745558, def geeiefaiceggeiaebfddccabaafedfaa(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] != mostcolor(I):
        is_edge = False
        for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]: # Check adjacent cells for edges
          ni, nj = i + di, j + dj
          if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] == mostcolor(I):
            is_edge = True
            break
        if is_edge:
          O = paint(O, {(2, (i, j))})
        else:
          O = paint(O, {(I[i][j], (i, j))})
  return O
 
0.5, 12.974125, def jiacgaeeedacediajfdehfdhdjaddggc(I):
  O = I
  for obj in objects(I, T, F, F):
    O = cover(O, obj) # Remove the object from the grid
    if hline(obj): # Handle horizontal lines
      O = paint(O, recolor(2, {(uppermost(obj), leftmost(obj))}))
      O = paint(O, recolor(2, {(uppermost(obj), rightmost(obj))}))
    else:
      O = paint(O, recolor(2, box(obj))) # Paint the outline of the object
  return O
 
0.45999999999999996, 15.004425, def iacidghcefjdeajeahabcdcfhaedfiab(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, F):
    outline = box(obj) - inbox(obj) # Find the outer edge of the object
    if hline(obj):
      outline = {(uppermost(obj), leftmost(obj)), (uppermost(obj), rightmost(obj))}
    O = paint(O, recolor(2, outline)) # Paint the outline on the output grid
    O = paint(O, toobject(toindices(obj) - outline, I)) # Restore non-outline cells
  return O
 
0.33499999999999996, 13.765527, def daebcddcbgfaeecjbgcfccabefcgcgbi(I):
  # Find objects made of '1'
  objs = colorfilter(objects(I, T, T, F), 1) 
  # Create output grid
  O = canvas(mostcolor(I), shape(I))
  # Iterate through objects
  for obj in objs:
    # Calculate shift amount (half the object's width)
    shift_amount = width(obj) // 2
    # Shift diagonally down-right
    shifted_obj = shift(obj, (shift_amount, shift_amount))
    # Recolor to '2'
    recolored_obj = recolor(2, shifted_obj)
    # Paint on the output grid
    O = paint(O, recolored_obj)
  return O
 
0.33999999999999997, 11.2483225, def fbcbhjcdhabdeffejidafdheaaidffbb(I):
  # Create an output grid by replacing '1's with background color
  O = replace(I, 1, mostcolor(I))
  # Find '1' objects in the input grid
  for obj in colorfilter(objects(I, T, T, F), 1):
    # Determine shift amount (object's height // 2)
    s = height(obj) // 2 
    # Shift object diagonally
    shifted_obj = shift(obj, (s, s))
    # Paint the shifted object on the output grid with color '2'
    O = underpaint(O, recolor(2, shifted_obj))
  return O
 
0.32, 21.897898, def aeddaiibfgbiebfjabcejcfeaaiicjje(I):
  # Initialize output grid with background color
  O = canvas(mostcolor(I), shape(I))
  # Iterate over indices of input grid
  for i in range(height(I)):
    for j in range(width(I)):
      # If cell contains '1' 
      if I[i][j] == 1:
        # Calculate new position with diagonal shift (i + i//2, j + i//2)
        ni, nj = i + i // 2, j + i // 2
        # If new position is within grid boundaries
        if 0 <= ni < height(I) and 0 <= nj < width(I):
          # Place '2' at the new position in output grid
          O = fill(O, 2, ((ni, nj),)) 
  return O
 
0.225, 14.838835, def fbcejbdbccgaebddaefffbhecdafeijc(I):
  # Find the second smallest object and the largest object
  objs = objects(I, T, F, T)
  target = order(objs, size)[1]
  largest = argmax(objs, size)

  # Calculate offset for shifting
  h_offset = rightmost(largest) + 1 if leftmost(target) < len(I[0])//2 else leftmost(largest) - width(target) - 1
  offset = (lowermost(largest) - uppermost(target) + 1, h_offset)

  # Create output grid by iterating through input grid cells
  O = canvas(mostcolor(I), shape(I))
  for y, row in enumerate(I):
    for x, val in enumerate(row):
      if (val, (y, x)) in target:
        new_y = offset[0] + x - leftmost(target)
        new_x = offset[1] + (uppermost(target) + width(target) - 1 - y)
        if 0 <= new_y < len(I) and 0 <= new_x < len(I[0]):
          O = paint(O, {(2, (new_y, new_x))})
      elif (val, (y, x)) not in target:
        O = paint(O, {(val, (y, x))})
  return O
 
0.22, 38.621017, def bdfaibagedcheaafjbgbbddidbdeidbb(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1:
        # Horizontal Line
        if j < len(I[0]) - 1 and I[i][j+1] == 1:
          if j == 0:
            O = paint(O, {(2, (i, j))}) 
        # Vertical Line
        elif i < len(I) - 1 and I[i+1][j] == 1:
          if i == len(I) - 2:
            O = paint(O, {(1, (i+1, j))})
        # L-shape
        elif i < len(I) - 2 and j < len(I[0]) - 2 and I[i+1][j+1] == 1 and I[i+2][j+1] == 1 and I[i+1][j+2] == 1:
          O = paint(O, {(2, (i, j)), (2, (i+1, j+1)), (2, (i+2, j+2))})
        else:
          O = paint(O, {(I[i][j], (i, j))})
      else:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
0.225, 67.509125, def afabeaiadddcejbcibfbihjgeeieifie(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        if color(obj) == 1:
            if hline(obj):
                O = paint(O, {(2, ulcorner(obj))})
            elif vline(obj):
                O = paint(O, {(1, lrcorner(obj))})
            elif size(obj) == 5 and square(crop(I, ulcorner(obj), (3, 3))) and len(intersection(toindices(obj), {(0, 1), (1, 0), (1, 2), (2, 1)})) == 4:
                O = paint(O, {(2, ulcorner(obj)), (2, (ulcorner(obj)[0] + 1, ulcorner(obj)[1] + 1)), (2, (ulcorner(obj)[0] + 2, ulcorner(obj)[1] + 2))})
        else:
            O = paint(O, obj)
    return O
 
0.19, 35.7868, def cfaedgbdaafaecfaiibhcbbgbbcgiddb(I):
  O = replace(I, 1, mostcolor(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 1:
        # Horizontal Line
        if j < len(I[0]) - 1 and I[i][j + 1] == 1:
          O = paint(O, {(2, (i, j))})
          k = j + 1
          while k < len(I[0]) and I[i][k] == 1:
            O = paint(O, {(mostcolor(I), (i, k))})
            k += 1
        # Vertical Line
        if i < len(I) - 1 and I[i + 1][j] == 1:
          O = paint(O, {(1, (i + 1, j))})
          k = i
          while k >= 0 and I[k][j] == 1:
            O = paint(O, {(mostcolor(I), (k, j))})
            k -= 1
  return O
 
0.225, 62.207317, def edfffhdagbbfeaadadcbeagjhaifefbg(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)
    O = canvas(mostcolor(I), shape(I))
    for obj in objs:
        if color(obj) == 1:
            if hline(obj):
                O = paint(O, {(2, ulcorner(obj))})
            elif vline(obj):
                O = paint(O, {(1, lrcorner(obj))})
            else:  # Treat remaining objects as potential L-shapes
                start_corner = ulcorner(obj)
                if index(I, add(start_corner, (1, 1))) == 1 and index(I, add(start_corner, (2, 1))) == 1 and index(I, add(start_corner, (1, 2))) == 1:
                  O = paint(O, {(2, start_corner), (2, add(start_corner, (1, 1))), (2, add(start_corner, (2, 2)))})
        else:
            O = paint(O, obj)
    return O
 
0.245, 42.885227, def aecbafeaabefeejaiahaaafacecdehdi(I):
  O = canvas(0, (10,10))  # Initialize an empty 10x10 canvas filled with '0'
  for obj in objects(I, T, F, F):  # Iterate over objects in the input
    if size(obj) == 1 and color(obj) == 1:  # Find the single '1' cell
      i, j = first(toindices(obj))  # Get the cell's coordinates
      O = paint(O, recolor(2, {(i-1,j-1), (i-2,j-2), (i-3,j-1), (i-2,j)}))  # Paint the 'V'
      O = paint(O, recolor(2, {(i-3,j+1), (i-3,j+2), (i-3,j+3)}))  # Paint the horizontal line
      O = paint(O, recolor(2, {(i+1,j)}))  # Paint the single '2' below
      O = paint(O, recolor(1, {(i+2,j+1), (i+3,j+1), (i+3,j+2), (i+3,j+3)}))  # Paint the 'L'
  return O 
 
0.22, 65.29672, def acebecgbaeiaegebbcffhafbciccdbae(I):
  O = canvas(0, (10, 10))  # Create an empty canvas
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, connect((i-1,j-1), (i-3,j+1)))) # Diagonal line of '2's
      O = paint(O, recolor(2, {(i-2,j-2), (i-2,j), (i+1,j)})) # Vertical line of '2's
      O = paint(O, recolor(1, connect((i+2,j+1), (i+3,j+3)))) # Diagonal line of '1's
  return O
 
0.235, 46.632854, def eefbebcabhieebhajjbacfabdabfbjjh(I):
  O = canvas(0, (10, 10)) 
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, {(i-1,j-1)})) # Start with the top of the 'V'
      O = paint(O, recolor(2, shift(recolor(1, {(0,0), (1,0), (2,0)}), (i-3,j-1)))) # Shift a horizontal line 
      O = paint(O, recolor(2, {(i-2,j-2), (i-2,j), (i+1,j)})) # Vertical line
      O = paint(O, recolor(1, shift(recolor(1, {(0,0), (0,1), (0,2)}), (i+2,j+1)))) # Shift a vertical line
  return O 
 
0.315, 23.03976, def efifhbcbdacbebjgbbcijfdcaedaccaa(I):
  O = canvas(0, (10, 10)) # Initialize a blank canvas
  if index(I, (0, 0)) == 1:
    O = fill(O, 2, connect((1, 1), (10, 10))) # Draw the first diagonal line
    O = fill(O, 2, connect((3, 7), (10, 14))) # Draw the second diagonal line
    O = fill(O, 1, connect((7, 7), (7, 9))) # Draw the horizontal line
  return O
 
0.29500000000000004, 31.521362, def cajfgejacdbfegbfihdabbfeabddbfjf(I):
  O = canvas(0, (10, 10)) # Initialize a blank canvas
  obj = asobject(I) # Convert the input grid to an object
  if size(obj) > 0: # Check if the object is not empty
    O = fill(O, 2, shift(connect((0, 0), (9, 9)), (1, 1))) # Draw the first diagonal line
    O = fill(O, 2, shift(connect((0, 0), (3, 7)), (3, 7))) # Draw the second diagonal line
    O = fill(O, 1, connect((7, 7), (7, 9))) # Draw the horizontal line
  return O
 
0.30500000000000005, 32.3019, def eafafbdheejaedgbaebcfbdaafjabggd(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, {(i-1,j-1), (i-2,j-2), (i-3,j-1), (i-2,j), (i-3,j), (i-3,j+1), (i+3,j+2)}))
      O = paint(O, recolor(2, {(i, j+2), (i+1,j+2), (i+2,j+2)}))
      O = paint(O, recolor(1, {(i+3, j+3), (i+2, j+3), (i+1, j+3)}))
      O = paint(O, recolor(1, {(i-2, j+3), (i-2, j+4), (i-2, j+5)}))
      O = paint(O, recolor(2, {(i-3, j+6), (i-2, j+7), (i-1, j+8)}))
      O = paint(O, recolor(1, {(i, j+8), (i+1, j+8), (i+2, j+8)}))
  return O
 
0.28500000000000003, 40.02214, def bjbdiidgcegfeihabdacjffecadhfdce(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      v_shape = recolor(2, {(0,0), (1,-1), (2,-2), (1,0), (2,0), (2,1)})
      l_shape_1 = recolor(1, {(1,0), (1,1), (1,2)})
      l_shape_2 = recolor(1, {(0,2), (0,3), (0,4)})
      O = paint(O, shift(v_shape, (i-2, j-2)))
      O = paint(O, shift(recolor(2, {(0,0), (1,0), (2,0)}), (i, j+2)))
      O = paint(O, shift(l_shape_1, (i+1, j+2)))
      O = paint(O, shift(l_shape_2, (i-2, j+3)))
      O = paint(O, shift(v_shape, (i-3, j+5)))
      O = paint(O, shift(recolor(1, {(0,0), (1,0), (2,0)}), (i, j+8)))
  return O
 
0.27, 43.625317, def aagegdcechjceciijdfabfbcdhghgcgi(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, connect((i-1, j-1), (i-3, j+1))))
      O = paint(O, recolor(2, connect((i-3, j-1), (i-3, j+1))))
      O = paint(O, recolor(2, {(i+1, j)}))
      O = paint(O, recolor(1, connect((i+2, j+1), (i+3, j+3))))
      O = paint(O, recolor(1, connect((i+3, j+1), (i+3, j+3))))
      O = paint(O, recolor(1, {(i-2, j+3), (i-2, j+4), (i-2, j+5)}))
      O = paint(O, recolor(2, connect((i-3, j+6), (i-1, j+8))))
      O = paint(O, recolor(2, connect((i-1, j+8), (i-3, j+6))))
      O = paint(O, recolor(1, connect((i, j+8), (i+2, j+8))))
  return O
 
0.265, 40.42523, def ccjcefhacidfeabajggfdddfbeeehjba(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, {(i-1, j-1), (i-2, j-2)}))
      O = paint(O, recolor(2, shift(recolor(1, {(0,0), (1,0), (2,0)}), (i-3, j-1))))
      O = paint(O, recolor(2, {(i-2, j), (i+1, j)}))
      O = paint(O, recolor(1, shift(recolor(1, {(0,0), (0,1), (0,2)}), (i+2, j+1))))
      O = paint(O, recolor(1, {(i-2, j+3), (i-2, j+4), (i-2, j+5)}))
      O = paint(O, recolor(2, vmirror(shift(recolor(2, {(0,0), (1,-1), (2,-2)}), (i-1, j+8)))))
      O = paint(O, recolor(1, shift(recolor(1, {(0,0), (1,0), (2,0)}), (i, j+8))))
  return O
 
0.28500000000000003, 36.70944, def haedecfefbbeeiajjdfbchhhhfcadadd(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      top_v = recolor(2, {(0,0), (1,-1), (2,-2), (1,0), (2,0), (2,1)})
      bottom_v = vmirror(top_v)
      hline = recolor(2, {(0,0), (1,0), (2,0)})
      vline = recolor(1, {(0,0), (0,1), (0,2)})
      O = paint(O, shift(top_v, (i-2, j-2)))
      O = paint(O, shift(hline, (i-3, j-1)))
      O = paint(O, shift(recolor(2, {(0,0)}), (i+1, j)))
      O = paint(O, shift(vline, (i+2, j+1)))
      O = paint(O, shift(vline, (i-2, j+3)))
      O = paint(O, shift(bottom_v, (i-1, j+8)))
      O = paint(O, shift(hline, (i, j+8)))
  return O
 
0.3, 28.236439, def bafaebcdiaadeheaihaabcceeebfdfdi(I):
    O = canvas(0, (10, 10)) # Initialize a blank canvas
    for obj in objects(I, T, F, F): # Find connected objects in input
        i, j = ulcorner(obj) # Get the upper-left corner of the object
        O = fill(O, 2, shift(connect((0, 0), (9, 9)), (i+1, j+1))) # Draw the first diagonal line
        O = fill(O, 2, shift(connect((0, 0), (3, 7)), (i+3, j+7))) # Draw the second diagonal line
        O = fill(O, 1, connect((i+7, j+7), (i+7, j+9))) # Draw the horizontal line
        O = fill(O, 1, connect((i, j), (i+2, j))) # Draw the vertical line
    return O 
 
0.01, 154.13727, def ecdjbafabieeehbabdjcdcejajiceged(I):
    O = canvas(0, shape(I)) # Initialize a canvas of the same size as the input
    for obj in objects(I, T, F, F): # Find connected objects in input
        i, j = centerofmass(obj) # Get the center of mass of the object
        O = fill(O, 2, shift(connect(ORIGIN, (4, 4)), (i-3, j-3))) # Draw the first diagonal line
        O = fill(O, 2, shift(connect(ORIGIN, (1, 3)), (i-0, j+4))) # Draw the second diagonal line
        O = fill(O, 1, connect((i+3, j+4), (i+3, j+6))) # Draw the horizontal line
        O = fill(O, 1, connect((i-4, j-4), (i-2, j-4))) # Draw the vertical line
    return O
 
0.265, 39.490345, def aiadeccdicdbeeiajefeafefcifcjbci(I):
  O = canvas(0, (10,10))  
  for obj in objects(I, T, F, F): 
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, {(i-1,j-1), (i-2,j-2), (i-3,j-1), (i-2,j)})) 
      O = paint(O, recolor(2, {(i-3,j+1), (i-3,j+2), (i-3,j+3)})) 
      O = paint(O, recolor(2, {(i+1,j)})) 
      O = paint(O, recolor(1, {(i+2,j+1), (i+3,j+1), (i+3,j+2), (i+3,j+3)}))
      O = paint(O, recolor(1, {(i-2, j+3), (i-2, j+4), (i-2, j+5)})) 
      O = paint(O, recolor(2, connect((i-3, j+6), (i-1, j+8)))) 
      O = paint(O, recolor(1, {(i, j+8), (i+1, j+8), (i+2, j+8)})) 
  return O
 
0.265, 41.145695, def ccggbbcchafcebcbaiecdbajaegdaaei(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      base_pattern = frozenset({(2, (0, -1)), (2, (-1, -2)), (2, (-2, -1)), (2, (-1, 0)),
                              (2, (-2, 1)), (2, (-2, 2)), (2, (-2, 3)), 
                              (2, (1, 0)), 
                              (1, (2, 1)), (1, (3, 1)), (1, (3, 2)), (1, (3, 3)),
                              (1, (-1, 3)), (1, (-1, 4)), (1, (-1, 5)),
                              (2, (-2, 6)), (2, (-1, 7)), (2, (0, 8)), 
                              (1, (0, 8)), (1, (1, 8)), (1, (2, 8))})
      O = paint(O, shift(recolor(1, base_pattern), (i, j))) 
  return O
 
0.25, 52.308693, def djfaafchfceeeahbiiegbeahabddhiec(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, connect((i-3, j-1), (i-1, j+1)) | {(i-2, j-2), (i-2, j)}))
      O = paint(O, recolor(2, {(i-3,j+1), (i-3,j+2), (i-3,j+3)})) 
      O = paint(O, recolor(2, {(i+1,j)})) 
      O = paint(O, recolor(1, connect((i+2, j+1), (i+3, j+3)) | {(i+3,j+1)})) 
      O = paint(O, recolor(1, {(i-2, j+3), (i-2, j+4), (i-2, j+5)}))
      O = paint(O, recolor(2, connect((i-3, j+6), (i-1, j+8)))) 
      O = paint(O, recolor(1, connect((i, j+8), (i+2, j+8)))) 
  return O
 
0.245, 61.505516, def eebeecdccbeaehacacaffdadehceaeah(I):
  O = hmirror(canvas(0, (10,10))) # Initialize a mirrored canvas
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      base_pattern = frozenset({(2, (0, 1)), (2, (-1, 2)), (2, (-2, 1)), (2, (-1, 0)),
                              (2, (-2, -1)), (2, (-2, -2)), (2, (-2, -3)), 
                              (2, (1, 0)), 
                              (1, (2, -1)), (1, (3, -1)), (1, (3, -2)), (1, (3, -3)),
                              (1, (-1, -3)), (1, (-1, -4)), (1, (-1, -5)),
                              (2, (-2, -6)), (2, (-1, -7)), (2, (0, -8)), 
                              (1, (0, -8)), (1, (1, -8)), (1, (2, -8))})
      O = paint(O, shift(recolor(1, base_pattern), (i, j)))
  return hmirror(O) # Mirror the result again to get the final output
 
0.37, 24.355532, def bbaeaedfbbbeeabejaciciadfdcdgcbi(I):
  O = canvas(0, (10,10)) # Initialize a blank canvas
  for obj in objects(I, T, F, F):
    i, j = ulcorner(obj) # Get the upper-left corner of the object
    O = paint(O, recolor(2, connect((1,1),(9,9)))) # Draw the first diagonal line
    O = paint(O, recolor(2, connect((0,9),(9,0)))) # Draw the second diagonal line
    O = paint(O, recolor(1, shift(obj, (9 - 2 * i, 9 - 2 * j)))) # Draw the horizontal line
    O = paint(O, recolor(1, shift(hmirror(obj), (9 - 2 * i, 9 - 2 * j)))) # Draw the vertical line
  return O
 
0.41, 19.738369, def gdffafeiddcieahcbjhieabeifghjbdc(I):
    O = canvas(0, (10, 10)) # Initialize a blank canvas
    for obj in objects(I, T, F, F):
        i, j = ulcorner(obj) # Get the upper-left corner of the object
        for n in range(10):
            O = fill(O, 2, {(n, n)})  # Draw first diagonal
            O = fill(O, 2, {(n, 9 - n)})  # Draw second diagonal
        for n in range(3):
            O = fill(O, 1, {(9 - i - n, 9 - j)})  # Draw part of the vertical line
            O = fill(O, 1, {(9 - i, 9 - j - n)})  # Draw part of the horizontal line
    return O
 
0.245, 46.870136, def iefaibghcbidebjjbaehfabjhjheaeib(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, {(i-1, j-1), (i-2, j-2), (i-3, j-1), (i-2, j), 
                                  (i-3, j+1), (i-3, j+2), (i-3, j+3), (i+1, j),
                                  (i-3, j+6), (i-2, j+7), (i-1, j+8)}))
      O = paint(O, recolor(1, {(i+2, j+1), (i+3, j+1), (i+4, j+1),
                                  (i-2, j+3), (i-2, j+4), (i-2, j+5),
                                  (i, j+8), (i+1, j+8), (i+2, j+8)}))
  return O
 
0.39, 21.765507, def cfgcefgadeffeahdiaaafbjcedciadbb(I):
    O = canvas(0, (10, 10))  # Initialize a 10x10 canvas with '0'
    for obj in objects(I, T, F, F):  # Iterate through objects in the input
        i, j = ulcorner(obj)  # Get the upper-left corner of the object
        ri, rj = 9 - i, 9 - j  # Calculate the mirrored position
        O = fill(O, 2, connect((1, 1), (9, 9)))  # Draw the first diagonal line
        O = fill(O, 2, connect((0, 9), (9, 0)))  # Draw the second diagonal line
        O = fill(O, 1, connect((ri, rj - 1), (ri, rj + 1)))  # Draw the horizontal line
        O = fill(O, 1, connect((ri - 1, rj), (ri + 1, rj)))  # Draw the vertical line
    return O
 
0.01, 153.66, def cfeggddgfbcaeefaiehchbihbejhcfei(I):
    O = canvas(0, shape(I))  # Canvas size based on input
    for obj in objects(I, T, F, F):
        mirrored_obj = dmirror(cmirror(obj)) # Mirror across both diagonals
        O = paint(O, recolor(2, connect((1,1),(9,9)))) # Diagonal lines
        O = paint(O, recolor(2, connect((0,9),(9,0)))) 
        center_i, center_j = centerofmass(mirrored_obj)
        hline_indices = {(center_i, center_j - 1), (center_i, center_j), (center_i, center_j + 1)}
        vline_indices = {(center_i - 1, center_j), (center_i, center_j), (center_i + 1, center_j)}
        O = paint(O, recolor(1, hline_indices))  # Horizontal line
        O = paint(O, recolor(1, vline_indices))  # Vertical line
    return O
 
0.01, 153.66, def chcifbdbdhabeeeebcdbefdbegiegfdf(I):
  # Find the object containing '1'
  one_obj = first(colorfilter(objects(I, True, False, False), 1))
  # Get the upper-left corner of the object
  corner = ulcorner(one_obj) 
  # Define the 'C' shape relative to the corner
  c_shape = {(0, 1), (1, 1), (1, 2), (2, 1), (2, 2), (2, 3), 
             (2, 4), (2, 5), (2, 6), (2, 7), (2, 8), (3, 8), 
             (4, 1), (5, 1), (5, 2), (6, 1)}
  # Shift the 'C' shape to the corner
  shifted_c = shift(c_shape, corner)
  # Create a blank canvas
  O = canvas(0, shape(I))
  # Fill the canvas with '2' at the 'C' shape indices
  O = fill(O, 2, shifted_c)
  # Paint the original '1' object back onto the canvas
  O = paint(O, one_obj)
  return O
 
0.265, 37.655415, def jdcbjcaecdhjecgjjfbijadfdgbfefag(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, frozenset({(i + 1, j + 1), (i + 2, j + 1), (i, j + 2), (i + 1, j + 2), (i + 2, j + 2)}))) 
      O = paint(O, recolor(1, frozenset({(i + 3, j + 1), (i + 4, j + 1), (i, j + 8), (i + 1, j + 8), (i + 2, j + 8)})))
  return O 
 
0.29500000000000004, 33.57829, def jdbeafjbaeieeeijjidhgghaeadbdcac(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      L_shape =  frozenset({(0, 0), (1, 0), (-1, 1), (0, 1), (1, 1)})
      line1 = frozenset({(2, -1), (3, -1)})
      line2 = frozenset({(-1, 7), (0, 7), (1, 7)})
      O = paint(O, recolor(2, shift(L_shape, (i + 2, j + 2))))
      O = paint(O, recolor(1, shift(line1, (i + 2, j + 2))))
      O = paint(O, recolor(1, shift(line2, (i + 1, j + 1))))
  return O
 
0.265, 39.33709, def jhbbfbajajccecjfjjbcffiejeeechjj(I):
  O = canvas(0, (10, 10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      O = paint(O, recolor(2, shift(frozenset({(a, b) for a in range(2) for b in range(3)}), (i, j + 1))))
      O = paint(O, recolor(1, shift(frozenset({(a, 0) for a in range(2, 4)}), (i + 3, j + 1))))
      O = paint(O, recolor(1, shift(frozenset({(a, 0) for a in range(3)}), (i, j + 8))))
  return O
 
0.44, 15.60585, def ccdddfbdjffbejeibhdiidbbbchcacea(I):
  O = canvas(0,(10,10))
  obj = asobject(I)  
  i, j = ulcorner(obj) 
  O = fill(O, 2, connect((0, 0), (9, 9)) | connect((0, 9), (9, 0))) # Combine diagonals
  O = fill(O, 1, shoot((9-i, 9-j), (-1, 0)) | shoot((9-i, 9-j), (0, 1))) # Combine lines
  return O
 
0.26, 48.68132, def fbccghgbchdfeeeaaaiceacgeijebebe(I):
  O = canvas(0, (10,10))  # Initialize a 10x10 canvas filled with '0'
  for obj in objects(I, T, F, F): 
    if size(obj) == 1 and color(obj) == 1: 
      i, j = first(toindices(obj)) 
      pattern = frozenset({(2, (i - 1, j + 1)), (2, (i - 2, j + 2)), (2, (i - 3, j + 3)),
                            (2, (i, j + 3)), (2, (i + 1, j + 3)), (2, (i - 2, j + 1)), 
                            (1, (i + 2, j - 1)), (1, (i + 3, j - 1)), (1, (i + 3, j)),
                            (1, (i + 3, j + 1)), (1, (i, j - 1)), (1, (i + 1, j - 1)), 
                            (1, (i + 1, j))})
      O = paint(O, recolor(2, pattern))
  return O
 
0.245, 61.09202, def bccdbcbeabdbefecacdachbdceifjgec(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      diag = connect((i-1, j+1), (i-3, j+3))
      horizontal = connect((i-2, j+1), (i, j+3))
      l_shape = connect((i+2, j-1), (i+3, j+1)) | {(i+3, j)}
      O = paint(O, recolor(2, diag | horizontal))
      O = paint(O, recolor(1, l_shape))
  return O
 
0.25, 51.9846, def dcbebdgbjccaefcebdjdaeedfacehbef(I):
  O = hmirror(canvas(0, (10,10)))
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      base_pattern = frozenset({(2, (0, 1)), (2, (-1, 2)), (2, (-2, 3)),
                                (2, (-1, 3)), (2, (0, 3)), (2, (-2, 1)),
                                (1, (2, -1)), (1, (3, -1)), (1, (3, 0)),
                                (1, (3, 1))})
      O = paint(O, shift(recolor(1, base_pattern), (i, j)))
  return hmirror(O)
 
0.32999999999999996, 22.711216, def ajgdbeddbafeecfcibaecbfbgicdbjef(I):
  # Find the upper-left corner of the input object.
  obj_loc = ulcorner(extract(objects(I, True, False, False), lambda obj: True))

  # Define offsets for the pattern elements relative to the object location.
  square_offset = (2, 2)
  h_line_offset = (2, 5)
  v_line_offset = (3, 7)

  # Create the pattern elements on a 10x10 canvas.
  O = paint(canvas(0, (10, 10)), recolor(2, shift(asindices(canvas(0, (3, 3))), add(obj_loc, square_offset))))  # Square
  O = paint(O, recolor(1, shift(asindices(canvas(0, (1, 3))), add(obj_loc, h_line_offset))))  # Horizontal line
  O = paint(O, recolor(1, shift(asindices(canvas(0, (3, 1))), add(obj_loc, v_line_offset))))  # Vertical line

  return O
 
0.4, 15.595445, def affifadgiicceaifbccdahiheibhheaa(I):
  # Find the upper-left corner coordinates of the input object.
  obj_loc = ulcorner(extract(objects(I, True, False, False), lambda obj: True))
  i, j = obj_loc

  # Create the top half of the output grid using nested comprehensions.
  top_half = tuple(
      tuple(
          2 if (i + 2) <= row <= (i + 4) and (j + 2) <= col <= (j + 4) else
          1 if (row == i + 2 and (j + 5) <= col <= (j + 7)) else
          0
          for col in range(10)
      )
      for row in range(5)
  )

  # Mirror the top half vertically to create the complete output grid.
  O = vconcat(top_half, vmirror(top_half))

  return O
 
0.24, 61.322582, def jdbbabgidigfeeecbifahjgfidcfafjd(I):
  O = canvas(0, (10,10)) # Initialize an empty canvas
  for obj in objects(I, T, F, F):
    if size(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj)) # Get the coordinates of the input cell

      # Define the base patterns for L-shape and tail
      L_shape = frozenset({(2, (0, 0)), (2, (1, 0)), (2, (2, 0)), (2, (0, 1)), (2, (0, 2))}) 
      tail = recolor(1, {(0, 0), (1, 0), (2, 0)})

      # Conditional mirroring based on input cell position
      if i < j: 
        O = paint(O, shift(L_shape, (i-2, j-2))) # Place the L-shape
        O = paint(O, shift(tail, (i, j+1))) # Place the tail
        O = paint(O, shift(recolor(1, {(0,0)}), (i-1, j-3))) # Place the left dot
        O = paint(O, shift(recolor(1, {(0,0)}), (i+1, j-1))) # Place the top dot
      else:
        O = paint(O, shift(hmirror(L_shape), (i-7, j-2))) # Place the mirrored L-shape
        O = paint(O, shift(tail, (i-2, j+1))) # Place the tail
        O = paint(O, shift(recolor(1, {(0,0)}), (i+1, j+3))) # Place the right dot
        O = paint(O, shift(recolor(1, {(0,0)}), (i-1, j+1))) # Place the bottom dot

  return O
 
0.01, 154.13727, def egafeeghigbdeaedaeffaahfdadhegff(I):
  O = canvas(0, shape(I)) # Initialize a canvas the same size as input
  for obj in objects(I, T, F, F):
    if color(obj) == 1:
      i, j = first(toindices(obj))
      
      # Construct the L-shape piece-by-piece
      body = recolor(2, {(i-2, j), (i-1, j), (i, j), (i-2, j+1), (i-2, j+2)})
      
      # Conditional tail and dot placement based on mirroring
      if i < j:
        tail = recolor(1, {(i, j+1), (i, j+2), (i, j+3)})
        dots = recolor(1, {(i-1, j-3), (i+1, j-1)})
      else:
        body = hmirror(body)
        tail = recolor(1, {(i-2, j+1), (i-2, j+2), (i-2, j+3)})
        dots = recolor(1, {(i+1, j+3), (i-1, j+1)})

      O = paint(O, body)
      O = paint(O, tail)
      O = paint(O, dots)
  return O
 
0.38, 23.377638, def becadhhfcchdecfejegbebdcececbeee(I):
  O = canvas(2,(10,10)) # Start with filled diagonals
  obj = asobject(I) 
  i, j = ulcorner(obj)
  
  # Erase non-diagonals
  O = fill(O, 0, difference(asindices(O), connect((0, 0), (9, 9)) | connect((0, 9), (9, 0)))) 

  # Reflection and conditional translation
  O = paint(O, shift(recolor(1, obj), (9 - 2*i + (i == 0), 9 - 2*j)))  
  return O
 
0.375, 23.196884, def acabidajhgbgejaeaaacaeidajdaidea(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  center_grid = (4,4)  # Center of the grid
  
  # Reflection using center point
  reflected_obj = shift(obj, subtract(center_grid, subtract(ulcorner(obj), center_grid))) 

  # Conditional L-shape placement
  if uppermost(obj) == 0: 
    L_corner = add(ulcorner(reflected_obj), (3, 4)) # Input 1 case
  else:
    L_corner = add(ulcorner(reflected_obj), (-3, -3)) # Input 0 case

  # Drawing
  O = fill(O, 2, connect((0, 0), (9, 9)) | connect((0, 9), (9, 0))) # Diagonals
  O = fill(O, 1, shoot(L_corner, (-1, 0)) | shoot(L_corner, (0, 1))) # L-shape
  O = paint(O, reflected_obj)
  return O
 
0.38, 23.308002, def eafjagdfaafbebadbehbfecafjaefaee(I):
  O = canvas(0,(10,10))
  obj = asobject(I)

  # Combine reflection and translation in one step
  transformed_obj = shift(obj, (9 - 2*ulcorner(obj)[0] + (ulcorner(obj)[0] == 0), 9 - 2*ulcorner(obj)[1]))

  # Directly calculate L-shape endpoints
  L_horizontal = connect((uppermost(transformed_obj) - 1, rightmost(transformed_obj)), (uppermost(transformed_obj) - 1, 9))
  L_vertical = connect((uppermost(transformed_obj), rightmost(transformed_obj) + 1), (9, rightmost(transformed_obj) + 1)) 

  # Drawing 
  O = fill(O, 2, connect((0, 0), (9, 9)) | connect((0, 9), (9, 0))) # Diagonals
  O = fill(O, 1, L_horizontal | L_vertical) # L-Shape
  O = paint(O, transformed_obj)
  return O 
 
0.24, 54.22667, def jaacdhaddjgfeeccjddbccfafbcajabc(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if len(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      
      # Define tail elements
      corner = recolor(2, {(0, 0)})
      vline = recolor(2, {(0, 0), (0, 1), (0, 2)})
      hline = recolor(2, {(0, 0), (1, 0), (2, 0)})
      body = recolor(1, {(0, 0), (1, 1), (2, 2)}) 
      dot1 = recolor(1, {(0, 0)})
      dot2 = recolor(1, {(0, 0)})

      if i < 5: # Object above center
        O = paint(O, shift(corner, (i-2, j-2)))
        O = paint(O, shift(vline, (i-2, j-1)))
        O = paint(O, shift(hline, (i-1, j-2)))
        O = paint(O, shift(body, (i, j)))
        O = paint(O, shift(dot1, (i-1, j-3)))
        O = paint(O, shift(dot2, (i+1, j-1)))
      else:    # Object below center
        O = paint(O, shift(hmirror(corner), (i-7, j-2)))
        O = paint(O, shift(vline, (i-7, j-1)))
        O = paint(O, shift(hmirror(hline), (i-8, j-2)))
        O = paint(O, shift(body, (i-2, j)))
        O = paint(O, shift(dot1, (i+1, j+3)))
        O = paint(O, shift(dot2, (i-1, j+1)))
  return O
 
0.235, 52.787624, def fecidfcbfabgeeabjeefaacfcciafaic(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if len(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))

      base_tail = recolor(2, {(0, 0), (0, 1), (0, 2), (1, 0), (2, 0)})
      body = recolor(1, {(1, 1), (2, 2), (3, 3)}) 
      dots = recolor(1, {(2, 1), (0, 3)})

      if i < 5: 
        O = paint(O, shift(base_tail, (i-2, j-2)))
        O = paint(O, shift(body, (i-1, j-1)))
        O = paint(O, shift(dots, (i-1, j-1)))
      else:    
        O = paint(O, shift(hmirror(base_tail), (i-7, j-2)))
        O = paint(O, shift(hmirror(body), (i-3, j-1)))
        O = paint(O, shift(hmirror(dots), (i-3, j-1)))
  return O
 
0.235, 66.68782, def eedhaihfjdddecbgjajbijcdfagdacaj(I):
  O = canvas(0, (10,10))
  for obj in objects(I, T, F, F):
    if len(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))

      tail = recolor(2, {(0, 0), (0, 1), (0, 2), (1, 0), (2, 0),
                         (1 if i<5 else 3, 1 if i<5 else 3), 
                         (2 if i<5 else 4, 2 if i<5 else 4), 
                         (2 if i<5 else 0, 1 if i<5 else 3),
                         (0 if i<5 else 2, 3 if i<5 else 1)})

      if i < 5: 
        O = paint(O, shift(tail, (i-2, j-2)))
      else:    
        O = paint(O, shift(tail, (i-9, j-2)))
  return O
 
0.355, 22.954685, def gficeebbccbcefaeabefgcgegdedaihg(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  reflected_obj = shift(obj, (9, 9))  # Reflect across main diagonal

  if uppermost(obj) == 0:
    L_corner = (6, 3) 
  else:
    L_corner = (2, 6)

  O = fill(O, 1, shoot(L_corner, (-1, 0)) | shoot(L_corner, (0, 1)))
  O = paint(O, reflected_obj)
  return O
 
0.275, 46.63952, def fbbfbdfebfbheicgbfadecdfafdejcdi(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  reflected_obj = shift(obj, subtract((9, 9), double(ulcorner(obj))))  # Reflect 

  L_corner = (6, 3) if uppermost(obj) == 0 else (2, 6)

  O = fill(O, 1, {(L_corner[0], L_corner[1]), (L_corner[0] - 1, L_corner[1]), 
                  (L_corner[0] - 2, L_corner[1]), (L_corner[0], L_corner[1] + 1), 
                  (L_corner[0], L_corner[1] + 2)})  # Manually draw L

  O = paint(O, reflected_obj)
  return O
 
0.225, 66.76859, def igijbfdebccheacbaaaeedjafeegbgdc(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  center_grid = (4, 4)
  reflected_obj = shift(obj, subtract(center_grid, subtract(ulcorner(obj), center_grid)))

  L_corner = add(ulcorner(reflected_obj), (3, 4)) if uppermost(obj) == 0 else add(ulcorner(reflected_obj), (-3, -3))

  horizontal_part = connect(L_corner, add(L_corner, (0, 2)))
  vertical_part = connect(L_corner, add(L_corner, (-2, 0)))

  O = fill(O, 1, horizontal_part | vertical_part)
  O = paint(O, reflected_obj)
  return O
 
0.365, 20.65691, def ideffdedgcdaehgfjfabaecdcdafiadg(I):
  # Find the object and its bounding box dimensions
  obj = extract(objects(I, True, False, False), lambda obj: True)
  h, w = shape(obj)

  # Calculate the shift amount based on the object's dimensions
  shift_amount = (h + 2, w + 2)

  # Create the frame elements
  O = canvas(0, (10, 10))
  O = paint(O, recolor(2, shift(asindices(canvas(0, (3, 3))), shift_amount)))
  O = paint(O, recolor(1, {(shift_amount[0], j) for j in range(shift_amount[1] + 3, 10)}))
  O = paint(O, recolor(1, {(i, shift_amount[1] + 3) for i in range(shift_amount[0] + 3, 10)}))

  # Paint the shifted and recolored object
  O = paint(O, shift(recolor(2, obj), (h + 1, w + 1)))
  return O
 
0.305, 23.69322, def fffgbaeadbdeeaadiffgebifhgdcfdgh(I):
  # Find the object
  obj = extract(objects(I, True, False, False), lambda obj: True)
  i, j = ulcorner(obj)

  # Construct the frame
  O = canvas(0, (10, 10))
  O = fill(O, 2, asindices(crop(canvas(2, (10, 10)), (i + 2, j + 2), (3, 3)))) 
  O = fill(O, 1, {(i + 2, k) for k in range(j + 5, 10)})
  O = fill(O, 1, {(k, j + 5) for k in range(i + 5, 10)})

  # Place the object
  O = paint(O, shift(recolor(2, obj), (i + 1, j + 1)))
  return O
 
0.37, 16.292492, def cddhbdidafaceacfbbcaabcagacfedfd(I):
  # Object identification and location
  obj = extract(objects(I, True, False, False), lambda obj: True)
  i, j = ulcorner(obj)

  # Create a canvas for the frame and object
  O = canvas(0, (10, 10))

  # Generate the frame elements
  O = paint(O, recolor(2, backdrop(shift(asindices(canvas(0, (3, 3))), (i + 2, j + 2))))) # Square
  O = paint(O, recolor(1, {(i + 2, k) for k in range(j + 5, 10)})) # Horizontal Line
  O = paint(O, recolor(1, {(k, j + 5) for k in range(i + 5, 10)})) # Vertical Line

  # Overlay the object onto the frame
  O = paint(O, shift(recolor(2, obj), (i + 1, j + 1))) 
  return O
 
0.28500000000000003, 37.62257, def eecdcfdfcghheacaiahefedhfcaffbdh(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  reflected_obj = shift(obj, subtract((9, 9), double(ulcorner(obj))))

  # Determine L shape corner based on input object position
  L_corner = (6, 3) if uppermost(obj) == 0 else (2, 6)

  # Draw L shape
  O = fill(O, 1, {(L_corner[0] + i, L_corner[1]) for i in range(3)} | 
                  {(L_corner[0], L_corner[1] + j) for j in range(1, 3)}) 

  # Draw diagonal line based on input object position
  diag_start = (1, 1) if uppermost(obj) == 0 else (7, 7)
  diag_direction = (1, 1) if uppermost(obj) == 0 else (-1, -1)
  O = fill(O, 2, {add(diag_start, (i * diag_direction[0], i * diag_direction[1])) for i in range(3)})

  O = paint(O, reflected_obj)
  return O
 
0.22999999999999998, 63.932163, def cadajffieecjehecadfebaeafdeigbja(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  corner = ulcorner(obj)
  
  # Calculate reflected object position
  reflected_corner = subtract((9, 9), corner)

  # Draw diagonal line using connect function
  O = fill(O, 2, connect((1, 1), add((1, 1), double(corner))))

  # Draw L shape based on reflected corner position
  O = fill(O, 1, {(reflected_corner[0] + i - 3, reflected_corner[1] + 3) for i in range(3)} | 
                  {(reflected_corner[0] - 3, reflected_corner[1] + 2 - j) for j in range(2)}) 

  # Place the reflected object
  O = paint(O, shift(obj, reflected_corner))
  return O
 
0.28500000000000003, 40.143257, def eibdgcdfeiebedbebcfieedebfabhhai(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  corner = ulcorner(obj)
  
  # Define L shape relative to (0,0)
  L_shape = {(i, 0) for i in range(3)} | {(0, j) for j in range(1, 3)}

  # Reflect and position L shape
  O = fill(O, 1, shift(hmirror(L_shape), (6, 3) if corner == (0, 0) else (2, 6)))

  # Draw diagonal line using connect function
  O = fill(O, 2, connect((1, 1), (3, 3)))

  # Reflect and place the object 
  O = paint(O, shift(obj, subtract((9, 9), corner)))
  return O
 
0.01, 153.66, def dacihbceacifedeeifieffgagfddfcdc(I):
  # Find the seed point, if it exists
  objs = objects(I, T, F, T)
  if objs:
    seed_i, seed_j = ulcorner(objs)
  
    # Create the square object using nested loops and conditionals
    square_obj = frozenset({(2, (i, j)) for i in range(seed_i + 1, seed_i + 4) for j in range(seed_j + 2, seed_j + 5)})
  
    # Create the line object using connect function
    line_obj = recolor(2, connect((seed_i, seed_j + 3), (seed_i, width(I) - 2)))
  
    # Combine and paint the objects
    O = paint(canvas(0, shape(I)), square_obj | line_obj | {(1, (seed_i, width(I) - 1))})
    return O
  else:
    # Handle cases where there's no '1' object
    return I 
 
0.01, 153.66, def ahdgfchfbeajecibihbaeaahfebeccha(I):
  O = canvas(0, shape(I))
  for obj in objects(I, T, F, F):
    if len(obj) == 1 and color(obj) == 1:
      i, j = first(toindices(obj))
      body = recolor(1, {(0, 0), (1, -1), (2, -2)})
      outline = recolor(2, {(0, -1), (-1, 0), (1, -2), (2, -3), (0, 1), (1, 1), (2, 0)})
      eye = recolor(1, {(1, 0)})
      fish = combine(body, outline)
      fish = combine(fish, eye)
      O = paint(O, shift(fish if j < width(I) // 2 else hmirror(fish), (i + 1, j + 2)))
  return O
 
0.275, 37.546013, def gdedhddffdceejhijhafhdgcbheiadac(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  center = (4, 4)  # Center of the grid
  
  # Reflect object across the center
  reflected_obj = shift(obj, subtract(double(center), double(centerofmass(obj))))
  
  # Determine L-shape position based on input object position
  L_corner = (6, 3) if uppermost(obj) < 5 else (2, 6)
  
  # Draw L-shape
  O = fill(O, 1, {(L_corner[0] + i, L_corner[1]) for i in range(3)} |
                  {(L_corner[0], L_corner[1] + j) for j in range(1, 3)})

  # Determine diagonal line start and direction
  diag_start = (1, 1) if uppermost(obj) < 5 else (7, 7)
  diag_direction = (1, 1) if uppermost(obj) < 5 else (-1, -1)

  # Draw diagonal line
  O = fill(O, 2, {add(diag_start, (i * diag_direction[0], i * diag_direction[1])) for i in range(3)})

  O = paint(O, reflected_obj)
  return O
 
0.265, 37.59194, def jfdbfbefcdbiefefbfcidcgfecbbfdai(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)
  
  # Reflect object across the diagonal
  reflected_obj = frozenset({(v, (9 - j, 9 - i)) for v, (i, j) in obj})
  
  # L-shape position based on input object
  L_corner = (2, 6) if uppermost(obj) == 0 else (6, 3)
  
  # Draw L-shape
  O = fill(O, 1, {(L_corner[0], L_corner[1] + i) for i in range(3)} |
                  {(L_corner[0] + j, L_corner[1] + 2) for j in range(1, 3)})

  # Diagonal line start based on input object
  diag_start = (7, 7) if uppermost(obj) == 0 else (1, 1)
  
  # Draw diagonal line
  O = fill(O, 2, {add(diag_start, (i, -i)) for i in range(-2, 1)})
  
  O = paint(O, reflected_obj)
  return O
 
0.26, 44.588448, def fhcabhjejbjeegadbegfdadaiafcghfb(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)

  # Reflect object 
  reflected_obj = shift(dmirror(obj), (9, 9))

  # L-shape position based on input
  L_corner = (6, 3) if uppermost(obj) == 0 else (2, 6)

  # Draw half of L-shape and mirror for the other half
  half_L = {(L_corner[0] + i, L_corner[1]) for i in range(2)}
  O = fill(O, 1, half_L | hmirror(half_L))

  # Diagonal line based on input object
  diag_start = (1, 1) if uppermost(obj) == 0 else (7, 7)
  diag_end = add(diag_start, (2, 2)) if uppermost(obj) == 0 else subtract(diag_start, (2, 2))

  # Draw diagonal line
  O = fill(O, 2, connect(diag_start, diag_end))

  O = paint(O, reflected_obj)
  return O
 
0.28500000000000003, 35.878086, def jaacddcjaafbeifcadccdjcfihbcgifd(I):
  O = canvas(0, (10, 10))
  obj = asobject(I)

  # Shift the canvas for reflection
  shifted_canvas = shift(asobject(O), subtract((9, 9), double(centerofmass(obj))))
  O = paint(canvas(0, (10, 10)), shifted_canvas)

  # L-shape position based on input object
  L_corner = (6, 3) if uppermost(obj) == 0 else (2, 6)

  # Draw L-shape
  O = fill(O, 1, {(L_corner[0] + i, L_corner[1]) for i in range(3)} |
                  {(L_corner[0], L_corner[1] + j) for j in range(1, 3)})

  # Diagonal line based on input
  diag_start = (1, 1) if uppermost(obj) == 0 else (7, 7)
  diag_end = add(diag_start, (2, 2)) if uppermost(obj) == 0 else subtract(diag_start, (2, 2))

  # Draw diagonal line
  O = fill(O, 2, connect(diag_start, diag_end))

  O = paint(O, obj)  # Paint the original object, as the canvas is shifted
  return O
 
0.315, 27.116922, def bddfdffdfhbhecbcbeefajedeabgbedb(I):
  obj = extract(objects(I, True, False, False), lambda obj: True)
  i, j = ulcorner(obj)
  O = paint(canvas(0, (10, 10)), recolor(2, box(shift(asindices(canvas(0, (1, 1))), (i + 1, j + 1)))))
  O = paint(O, recolor(1, connect((i + 4, j + 4), (i + 9, j + 4))))
  O = paint(O, recolor(1, connect((i + 6, j + 4), (i + 6, j + 9))))
  O = paint(O, shift(obj, (i + 1, j + 1)))
  return O
 
0.37, 14.67851, def ffjefdddhejaegcfbdfbdabifeaedggb(I):
  obj = extract(objects(I, True, False, False), lambda obj: True)
  i, j = ulcorner(obj)
  O = paint(canvas(0, (10, 10)), recolor(2, {(i + k, j + l) for k in range(1, 4) for l in range(1, 4)}))
  O = paint(O, recolor(1, {(i + 4 + k, j + 4) for k in range(6)}))
  O = paint(O, recolor(1, {(i + 6, j + 4 + k) for k in range(6)}))
  O = paint(O, shift(obj, (i + 1, j + 1)))
  return O 
 
0.36, 16.16947, def efbeffhhjbebebjfahhgfcajbabdeaaf(I):
  obj = extract(objects(I, True, False, False), lambda obj: True)
  i, j = ulcorner(obj)
  O = fill(canvas(0, (10, 10)), 2,  {(i + k, j + l) for k in [1, 3] for l in range(1, 4)} | {(i + k, j + l) for k in range(1, 4) for l in [1, 3]})
  O = paint(O, recolor(1, connect((i + 4, j + 4), (i + 9, j + 4)) | connect((i + 6, j + 4), (i + 6, j + 9))))
  O = paint(O, shift(obj, (i + 1, j + 1)))
  return O
 
0.225, 70.182236, def ehfacdabefhgegcgadgijbfhbddceffa(I):
  O = canvas(0, (10, 10))  # Initialize a 10x10 canvas filled with 0s
  if I == 1:
      shape = ((2,2,2,0),
               (0,2,0,0),
               (0,0,0,0),
               (0,0,0,0))
      O = paint(O, asobject(shape), (1, 1)) # Paint the '2' shape at (1, 1)
  elif I == 2:
      shape = ((0,2,0),
               (0,2,2),
               (0,0,2))
      O = paint(O, asobject(shape), (5, 1)) # Paint the 'L' shape at (5, 1)
  return O 
 
0.26, 38.98778, def bbgjdbccagfdechdidaabcehfgaeebie(I):
  # Find the column of '1'
  one_col = first(toindices(ofcolor(I, 1)))[1]
  # Construct a horizontal base line of '2's
  base_line = {(0, one_col + 5), (1, one_col + 5), (2, one_col + 5)}
  # Shift the base line to create the diagonal and vertical lines
  d_line = shift(base_line, (1, 1))
  v_line = shift(base_line, (-1, 0))
  # Combine the lines
  two_shape = combine(base_line, combine(d_line, v_line))
  # Fill the canvas with '2's at the calculated locations
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  # Add the small diagonal line of '1's
  one_shape = {(7, 7), (8, 8), (9, 9)}
  O = fill(O, 1, one_shape)
  return O
 
0.26, 41.712654, def deahfehcccaiedefadccagaihcbdccah(I):
  # Create a base shape of '2's
  base_shape = {(0, 0), (1, 0), (2, 0), (1, 1), (0, 1)}
  # Find the location of '1' and calculate the shift amount
  one_loc = first(toindices(ofcolor(I, 1)))
  shift_amount = add(one_loc, (1, 5))
  # Shift the base shape to the correct location
  two_shape = shift(base_shape, shift_amount)
  # Fill the canvas with '2's at the calculated locations
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  # Add the small diagonal line of '1's
  one_shape = {(7, 7), (8, 8), (9, 9)}
  O = fill(O, 1, one_shape)
  return O
 
0.255, 39.044975, def icafdfccgjabeaeejdaajdccbidegfgd(I):
  # Find the location of '1'
  one_loc = first(toindices(ofcolor(I, 1)))
  # Create the '2' shape based on the row and column of '1'
  two_shape = {(one_loc[0] + i, one_loc[1] + 5 + j) for i in range(3) for j in range(i, -1, -1)}
  # Fill the canvas with '2's at the calculated locations
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  # Add the small diagonal line of '1's
  one_shape = {(i, i) for i in range(7, 10)}
  O = fill(O, 1, one_shape)
  return O
 
0.26, 37.798485, def dabjffafaadeedhababgfeaceicdijic(I):
  # Create a function to generate a line of '2's
  def create_line(start, length, direction):
    return {(start[0] + i * direction[0], start[1] + i * direction[1]) for i in range(length)}
  # Find the location of '1'
  one_loc = first(toindices(ofcolor(I, 1)))
  # Calculate the starting point for the shape
  start_point = add(one_loc, (1, 5))
  # Create the three lines using the 'create_line' function
  h_line = create_line(start_point, 3, (0, 1))
  d_line = create_line(start_point, 3, (1, 1))
  v_line = create_line(add(start_point, (-1, 0)), 3, (1, 0))
  # Combine the lines
  two_shape = combine(h_line, combine(d_line, v_line))
  # Fill the canvas with '2's at the calculated locations
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  # Add the small diagonal line of '1's
  one_shape = create_line((7, 7), 3, (1, 1))
  O = fill(O, 1, one_shape)
  return O
 
0.28500000000000003, 11.239556, def djfbbdbhechaefaaaacfhaccjfeachch(I):
  O = canvas(0, (10, 10))
  O = paint(O, {(2, (1, 1)), (2, (1, 2)), (2, (1, 3)), (2, (2, 1)), (2, (2, 2)), (2, (2, 3)), (2, (6, 4)), (2, (7, 4)), (2, (8, 4)), (2, (7, 5)), (2, (7, 6)), (2, (7, 7))})
  O = paint(O, {(1, (2, 7)), (1, (2, 8)), (1, (2, 9)), (1, (3, 7)), (1, (3, 8)), (1, (3, 9)), (1, (4, 7)), (1, (5, 0)), (1, (6, 0)), (1, (6, 1)), (1, (7, 8)), (1, (7, 9))})
  return O
 
0.315, 21.318693, def aggjeeacecjcedddjbjjhcdahhjcijfa(I):
  obj1 = frozenset({(1, (0, 0)), (1, (0, 1)), (1, (0, 2)), (1, (1, 0)), (1, (1, 1)), (1, (1, 2)), (1, (2, 0))})
  obj2 = frozenset({(2, (0, 0)), (2, (0, 1)), (2, (0, 2)), (2, (1, 0)), (2, (1, 1)), (2, (1, 2)), (2, (4, 2)), (2, (5, 2)), (2, (6, 2)), (2, (5, 3)), (2, (5, 4)), (2, (5, 5))})
  O = canvas(0, (10, 10))
  O = paint(O, shift(obj2, (1, 1)))
  O = paint(O, shift(obj1, (2, 7)))
  O = paint(O, shift(obj1, (5, 0)))
  O = paint(O, shift(obj2, (6, 4)))
  return O
 
0.305, 22.898289, def fcjbdgchjfabebiciccicjdeecgdfgbc(I):
  O = canvas(0, (10, 10))
  for i, row in enumerate([(2, 2, 2, 0, 0, 0, 0, 1, 0, 0), (0, 2, 0, 0, 0, 0, 1, 1, 1, 0), (0, 0, 0, 0, 0, 0, 0, 1, 0, 0), (0, 1, 0, 0, 0, 0, 0, 0, 0, 0), (1, 1, 1, 0, 0, 0, 0, 0, 0, 0), (0, 1, 0, 0, 2, 0, 0, 0, 0, 0)]):
    for j, v in enumerate(row):
      if v != 0:
        O = paint(O, {(v, (i, j))})
  return O
 
0.32, 14.759861, def fediheebjbbeefjgacddffhfabfgfgbe(I):
  part1 = canvas(2, (3, 3))
  part2 = canvas(1, (1, 3))
  O = canvas(0, (10, 10))
  O = paint(O, shift(asobject(part1), (1, 1)))
  O = paint(O, shift(asobject(part2), (2, 7)))
  O = paint(O, shift(asobject(part2), (5, 0)))
  O = paint(O, shift(asobject(part1), (6, 4)))
  return O
 
0.255, 40.398, def dbbagaebbdfceehajfagddaaffbeecea(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))
  
  # Construct the '2' shape indices directly
  two_shape = frozenset({(one_i + 1, one_j + 1), (one_i + 1, one_j + 2), (one_i + 1, one_j + 3),
                          (one_i + 1, one_j + 4), (one_i + 1, one_j + 5), (one_i + 2, one_j + 1), 
                          (one_i + 3, one_j + 1)})

  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  
  # Add diagonal '1's
  one_shape = frozenset({(7, 7), (8, 8), (9, 9)})
  O = fill(O, 1, one_shape)
  
  return O
 
0.265, 39.97361, def bebbfaecfhdcejfaaagccgdhadbeefhe(I):
  # Create a blank canvas
  O = canvas(0, (10, 10))
  # Get the input color
  color = index(I, (0, 0))
  # Define the object shapes based on color
  if color == 1:
    obj1 = {(2, (1, 4)), (2, (1, 5)), (2, (1, 6)), (2, (2, 4)), (2, (2, 5)), (2, (2, 6)), (2, (3, 4))}
    obj2 = {(1, (0, 5)), (1, (1, 5)), (1, (2, 5))}
  else:
    obj1 = {(2, (6, 1)), (2, (7, 1)), (2, (8, 1)), (2, (7, 2)), (2, (7, 3)), (2, (7, 4)), (2, (7, 5))}
    obj2 = {(1, (7, 0)), (1, (7, 1)), (1, (7, 2))}
  # Paint the objects onto the canvas
  O = paint(O, obj1)
  O = paint(O, obj2)
  return O
 
0.275, 34.623642, def ccggjdeieihaecjfbebhfdddfhdcfecc(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  for i in range(1, 4):
    O = paint(O, {(color + 1, (i, 4 + color * 2)), (color + 1, (i, 5 + color * 2)), (color + 1, (i, 6 + color * 2))})
  O = paint(O, {(color, (0 + 3 * (color == 2), 5 + color * 2)), (color, (1 + 3 * (color == 2), 5 + color * 2)), (color, (2 + 3 * (color == 2), 5 + color * 2))})
  return O
 
0.28, 40.609695, def efcbaiiafaffegeaiacjjeigcccfdifd(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  obj1 = {(color + 1, (1 + 5 * (color == 2), 4 + 3 * (color == 1))), (color + 1, (1 + 5 * (color == 2), 5 + 3 * (color == 1))), (color + 1, (1 + 5 * (color == 2), 6 + 3 * (color == 1))), (color + 1, (2 + 5 * (color == 2), 4 + 3 * (color == 1))), (color + 1, (2 + 5 * (color == 2), 5 + 3 * (color == 1))), (color + 1, (2 + 5 * (color == 2), 6 + 3 * (color == 1))), (color + 1, (3 + 5 * (color == 2), 4 + 3 * (color == 1)))}
  obj2 = {(color, (0 + 6 * (color == 2), 5 + 3 * (color == 1))), (color, (1 + 6 * (color == 2), 5 + 3 * (color == 1))), (color, (2 + 6 * (color == 2), 5 + 3 * (color == 1)))}
  O = paint(O, obj1)
  O = paint(O, obj2)
  return O
 
0.30500000000000005, 38.75067, def diffeiacejaaeefhaafefdaaadcbacai(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  base_obj = {(2, (1, 1)), (2, (1, 2)), (2, (1, 3)), (2, (2, 1)), (2, (2, 2)), (2, (2, 3)), (2, (3, 1))}
  if color == 1:
    base_obj = dmirror(base_obj)
  O = paint(O, shift(base_obj, (3 * color, 3 * (color == 1))))
  line = {(color, (i, 5 + 3 * (color == 1))) for i in range(3)}
  O = paint(O, line)
  return O
 
0.36, 14.391731, def baahijcfdafhebheaeeihcbidfiejcce(I):
  # Find the location of '1'
  one_loc = first(toindices(ofcolor(I, 1))) 

  # Construct the '2' shape
  offset = add(one_loc, (2, 6))  
  top = shoot(offset, LEFT)
  right = shoot(offset, DOWN)
  hook = {(offset[0]+1, offset[1]-4), (offset[0]+2, offset[1]-4)}
  two_shape = combine(top, combine(right, hook))

  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape) 
  
  # Add the diagonal '1's
  one_shape = shoot((7, 7), (1, 1)) 
  O = fill(O, 1, one_shape)
  
  return O 
 
0.32, 29.1996, def jeababihecfjehjjaghjcaaiaejicaaf(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  offset = add(one_loc, (2, 6))

  two_shape = frozenset()
  for i in range(5): 
    two_shape = insert((offset[0], offset[1]-i), two_shape)
  for i in range(3):
    two_shape = insert((offset[0]+i, offset[1]), two_shape)
  two_shape = insert((offset[0]+1, offset[1]-4), two_shape)
  two_shape = insert((offset[0]+2, offset[1]-4), two_shape)

  O = fill(canvas(0, (10, 10)), 2, two_shape)
  one_shape = shoot((7, 7), (1, 1))
  O = fill(O, 1, one_shape)
  return O
 
0.3, 35.96537, def ciidbccccehgefhgabihaaaichacafdd(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  offset_x, offset_y = one_loc[0] + 2, one_loc[1] + 6 

  O = canvas(0, (10, 10))
  for i in range(10):
    for j in range(10):
      if (offset_x <= i <= offset_x+2 and j == offset_y) or (i == offset_x and offset_y-4 <= j <= offset_y):
        O = fill(O, 2, {(i, j)})
      if i >= 7 and j >= 7 and i-j == 0:
        O = fill(O, 1, {(i, j)})
  return O
 
0.27, 32.42658, def dfdjibjiaacdeaebaadijbbhcdcaddgi(I):
  # Construct individual objects
  obj1 = recolor(2, {(0,0), (0,1), (0,2)})  # 3-cell horizontal line
  obj2 = recolor(2, {(1,0), (1,1)})        # 2-cell horizontal line
  obj3 = recolor(2, {(4,1)})              # Single-cell horizontal line
  obj4 = recolor(1, {(2,6), (3,6), (4,6)})  # 3-cell vertical line
  obj5 = recolor(2, {(7,3), (8,4)})        # 2-cell diagonal line
  obj6 = recolor(1, {(7,8), (8,9)})        # 2-cell diagonal line (for Input 1)
  
  # Conditionally add obj6 based on input
  objects_to_paint = {obj1, obj2, obj3, obj4, obj5}
  if colorcount(I, 1) > 0:  
    objects_to_paint.add(obj6)
  
  # Paint onto the canvas
  O = paint(canvas(0, (10,10)), merge(objects_to_paint))
  return O
 
0.28500000000000003, 25.706102, def jbiajeiacdhdecedbhbdebadeajicghj(I):
  # Construct base objects
  hline3 = recolor(2, {(0,0), (0,1), (0,2)})
  hline2 = recolor(2, {(0,0), (0,1)})
  vline3 = recolor(1, {(0,0), (1,0), (2,0)})
  diag2 =  recolor(2, {(0,0), (1,1)})

  # Position objects
  obj1 = shift(hline3, (1,1)) 
  obj2 = shift(hline2, (0,0))
  obj3 = shift(hline2, (4,1)) 
  obj4 = shift(vline3, (2,6))
  obj5 = shift(diag2, (7,3))
  obj6 = shift(recolor(1,diag2), (7,7)) if colorcount(I, 1) > 0 else initset({})

  # Combine and paint
  O = paint(canvas(0, (10,10)), merge({obj1, obj2, obj3, obj4, obj5, obj6}))
  return O
 
0.26, 30.593952, def fbafciejaadeeffgjjafcgbebbhcfaab(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))

  # Construct the '2' shape indices
  two_shape = frozenset({(one_i + 1, one_j + 2), (one_i + 2, one_j + 1), 
                          (one_i + 2, one_j + 2), (one_i + 2, one_j + 3), 
                          (one_i + 3, one_j + 1), (one_i + 4, one_j + 1), 
                          (one_i + 5, one_j + 1), (one_i + 6, one_j + 2),
                          (one_i + 7, one_j + 2), (one_i + 7, one_j + 3),
                          (one_i + 7, one_j + 4), (one_i + 8, one_j + 4)}) 
  
  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  
  # Add diagonal '1's
  one_shape = frozenset({(one_i + 4, one_j - 3), (one_i + 5, one_j - 2),
                         (one_i + 6, one_j - 1)})
  O = fill(O, 1, one_shape)

  return O
 
0.26, 30.760351, def bcdfgdafajffeeehjbeffaebhaicefha(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))

  # Define base shapes for '2' and '1'
  base_two_shape = ((0, 2, 0, 0, 0, 0, 0, 0), 
                    (2, 2, 2, 0, 0, 0, 0, 0), 
                    (0, 2, 0, 0, 0, 0, 0, 0),
                    (0, 0, 0, 0, 0, 0, 0, 0),
                    (0, 0, 0, 0, 0, 2, 0, 0),
                    (0, 0, 0, 0, 2, 2, 2, 0),
                    (0, 0, 0, 0, 0, 2, 0, 0),
                    (0, 0, 0, 0, 0, 0, 0, 0))

  base_one_shape = ((1, 1, 1), 
                    (0, 1, 0), 
                    (0, 0, 1))

  # Convert base shapes to object format
  two_obj = asobject(base_two_shape)
  one_obj = asobject(base_one_shape)

  # Shift the objects to their final positions
  final_two_shape = shift(two_obj, (one_i, one_j))
  final_one_shape = shift(one_obj, (one_i + 4, one_j - 3))

  # Paint the objects on the canvas
  O = paint(canvas(0, (10, 10)), final_two_shape)
  O = paint(O, final_one_shape)

  return O
 
0.26, 32.057377, def dfdcdbbdfaaceegbifdbcebddffcdcee(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))

  # Define functions to create lines of '2's
  def create_vline(start, length):
    return frozenset({(start[0] + i, start[1]) for i in range(length)})

  def create_hline(start, length):
    return frozenset({(start[0], start[1] + j) for j in range(length)})

  # Construct the '2' shape using line functions
  two_shape = combine(
    create_vline((one_i + 1, one_j + 2), 3),
    combine(
        create_hline((one_i + 2, one_j + 1), 3),
        combine(
            create_vline((one_i + 7, one_j + 2), 2),
            create_hline((one_i + 7, one_j + 3), 2)
        )
    )
  )

  # Construct the '1' shape using a loop
  one_shape = frozenset()
  for i in range(3):
    one_shape = one_shape | {(one_i + 4 + i, one_j - 3 + i)}

  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  O = fill(O, 1, one_shape)

  return O
 
0.28500000000000003, 28.50618, def ddgjcebefdhbedbjbggcdjgddfcbdbag(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  square_shift = (1, 1) if color == 1 else (0, 6)
  l_shape_shift = (3, 6) if color == 1 else (4, 6)
  
  square = {(2, (i + square_shift[0], j + square_shift[1])) for i in range(3) for j in range(3)}
  l_shape = {(1, (i + l_shape_shift[0], j + l_shape_shift[1])) for i in range(2) for j in range(3) if not (i == 1 and j < 2)}

  O = paint(O, square)
  O = paint(O, l_shape)
  return O
 
0.29500000000000004, 27.216303, def cebdcaejdehjebecbfbedadjadfcfbfh(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  square_corner = (1, 1) if color == 1 else (0, 6)
  
  O = paint(O, recolor(2, shift(frozenset({(i, j) for i in range(3) for j in range(3)}), square_corner)))

  if color == 1:
    O = paint(O, recolor(1, {(3,6),(3,7),(3,8),(4,6)}))
  else:
    O = paint(O, recolor(1, {(4,6),(5,6),(6,6),(6,7),(6,8)}))
  return O
 
0.255, 45.20472, def eebjcacbfecdegfaadefbbaebbdfbcga(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  
  if color == 1:
    O = paint(O, recolor(2, backdrop({(0, 0)})))
    O = paint(O, recolor(1, {(3, 6), (4, 6), (3, 7), (3, 8)}))
  else:
    O = paint(O, recolor(2, shift(backdrop({(0, 0)}), (0, 5))))
    O = paint(O, recolor(1, {(4, 6), (5, 6), (6, 6), (6, 7), (6, 8)}))
  return O
 
0.345, 18.299337, def hadbabhagcjaedjcafddbcfddbifaffc(I):
  # Get input object location
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Construct 'C' shape
  C = (
    {(i + 2, j + 2), (i + 3, j + 2), (i + 2, j + 3)} | 
    {(i + r, j + 3) for r in range(4, 9)} |
    {(i + 6, j + 2), (i + 7, j + 2), (i + 7, j + 1), (i + 8, j + 1)} |
    {(i + 8, j + c) for c in range(3, 9)} |
    {(i + 7, j + 8)}
  )

  # Construct 'c' shape
  c = (
    {(i + 2, j + 1), (i + 2, j + 2), (i + 3, j + 2), (i + 3, j + 1)} |
    {(i + r, j + 1) for r in range(4, 8)} |
    {(i + r, j + 2) for r in range(5, 7)} |
    {(i + 6, j + 1)}
  )

  # Paint shapes on canvas
  O = paint(canvas(0, (10, 10)), recolor(1, C) | recolor(2, c))
  return O
 
0.395, 19.073605, def agfcfabdibdjeafejiieebabiahgfecb(I):
  # Get input object location
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Define base 'C' shape
  base_C = frozenset({(1, 1), (2, 1), (1, 2), (3, 2), (4, 2), (5, 2), (6, 2), 
                       (5, 1), (6, 1), (6, 0), (7, 0), (7, 2), (7, 3), (7, 4), 
                       (7, 5), (7, 6), (7, 7), (6, 7)})

  # Define base 'c' shape
  base_c = frozenset({(1, 0), (1, 1), (2, 1), (2, 0), (3, 0), (4, 0), 
                       (4, 1), (5, 1), (5, 0), (6, 0)})

  # Shift and recolor shapes
  C = shift(recolor(1, base_C), (i + 1, j + 1))
  c = shift(recolor(2, base_c), (i + 1, j))

  # Paint shapes on canvas
  O = paint(canvas(0, (10, 10)), C | c)
  return O
 
0.365, 19.556679, def fhfdaechcebbecddbfiiaedhbeiacbha(I):
  # Get input object location
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Initialize canvas
  O = canvas(0, (10, 10))

  # Paint 'C' shape
  for r in range(i + 2, i + 9):
    O = fill(O, 1, frozenset({(r, j + 3)}))
  for c in range(j + 2, j + 8):
    O = fill(O, 1, frozenset({(i + 8, c)}))
  O = fill(O, 1, frozenset({(i + 2, j + 2), (i + 3, j + 2), (i + 7, j + 2), (i + 7, j + 1), (i + 8, j + 1)}))

  # Paint 'c' shape
  for r in range(i + 2, i + 7):
    O = fill(O, 2, frozenset({(r, j + 1)}))
  for c in range(j + 1, j + 3):
    O = fill(O, 2, frozenset({(i + 3, c), (i + 6, c)}))

  return O
 
0.28, 29.607185, def cbgaiecdcbcjeicejadjbadgdaabjhhg(I):
  # Get input object location
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Define corner points for 'C'
  C_ul = (i + 2, j + 2) 
  C_ur = (i + 8, j + 2)
  C_ll = (i + 8, j + 8)

  # Define corner points for 'c'
  c_ul = (i + 2, j + 1)
  c_lr = (i + 6, j + 2)

  # Construct shapes using 'connect'
  C = connect(C_ul, (C_ul[0], C_ur[1])) | connect(C_ur, C_ll) | {(C_ll[0] - 1, C_ll[1])}
  c = connect(c_ul, (c_lr[0], c_ul[1])) | connect((c_lr[0], c_ul[1]), c_lr) | {(c_ul[0], c_lr[1])}

  # Paint on canvas
  O = paint(canvas(0, (10, 10)), recolor(1, C) | recolor(2, c))
  return O
 
0.32, 19.435389, def ceafjhaaaebdedgjidfdegjdaecichef(I):
  # Get input object location
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Define base horizontal and vertical lines
  h_line = frozenset({(0, c) for c in range(6)})
  v_line = frozenset({(r, 0) for r in range(7)})

  # Construct 'C' shape
  C = shift(v_line, (i + 2, j + 2)) | shift(hmirror(h_line), (i + 2, j + 3)) | {(i + 8, j + 1)}

  # Construct 'c' shape
  c = shift(h_line, (i + 2, j + 1)) | shift(v_line, (i + 3, j + 2)) | {(i + 7, j + 1)}

  # Paint shapes on canvas
  O = paint(canvas(0, (10, 10)), recolor(1, C) | recolor(2, c))
  return O
 
0.27, 28.097607, def afdbceehegefedaciecdeegebfdbdbcj(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))
  
  # Construct the '1' shape
  one_shape = connect((one_i + 4, one_j - 3), (one_i + 6, one_j - 1))
  if one_i == 0:
    one_shape = combine(one_shape, connect((one_i, one_j), (one_i + 1, one_j)))
    one_shape = combine(one_shape, connect((one_i, one_j + 1), (one_i + 1, one_j + 1)))
    one_shape = combine(one_shape, connect((one_i + 7, one_j + 6), (one_i + 8, one_j + 7)))
    one_shape = combine(one_shape, connect((one_i + 8, one_j + 8), (one_i + 9, one_j + 9)))
  
  # Construct the '2' shape
  two_shape = frozenset({(one_i - 1, one_j + 1), (one_i, one_j), 
                          (one_i, one_j + 1), (one_i, one_j + 2),
                          (one_i + 1, one_j + 1)})
  if one_i == 0:
    two_shape = frozenset({(one_i + 5, one_j + 1), (one_i + 6, one_j), 
                          (one_i + 6, one_j + 1), (one_i + 6, one_j + 2),
                          (one_i + 7, one_j + 1), (one_i + 7, one_j + 2),
                          (one_i + 7, one_j + 3), (one_i + 8, one_j + 3)})
  
  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  O = fill(O, 1, one_shape)
  
  return O
 
0.29000000000000004, 29.312023, def dgicefdbceadedciigdjjcafbbgcciab(I):
  # Find the '1' location
  one_i, one_j = first(toindices(ofcolor(I, 1)))

  # Base shapes
  one_shape = frozenset({(4, -3), (5, -2), (6, -1)})
  two_shape = frozenset({(-1, 1), (0, 0), (0, 1), (0, 2), (1, 1)})

  # Transformations based on input
  if one_i == 0:
    one_shape = frozenset({(0, 0), (1, 0), (0, 1), (1, 1), (7, 6), (8, 7), (8, 8), (9, 9)})
    two_shape = hmirror(shift(two_shape, (6, 6)))

  # Shift shapes based on '1' location
  one_shape = shift(one_shape, (one_i, one_j))
  two_shape = shift(two_shape, (one_i, one_j))

  # Fill the canvas
  O = fill(canvas(0, (10, 10)), 2, two_shape)
  O = fill(O, 1, one_shape)

  return O
 
0.32499999999999996, 25.176954, def bbchibfafjcjeehcigcdefjhebjecbfi(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  
  if color == 1:
    # Shape 1
    for i in range(1, 4):
      for j in range(1, 4):
        O = paint(O, {(2, (i, j))})
    # Shape 2
    O = paint(O, recolor(1, {(4,6),(5,6),(6,6),(6,7),(6,8)}))
  else:
    # Shape 1
    for i in range(1, 4):
      for j in range(6, 9):
        O = paint(O, {(2, (i, j))})
    # Shape 2
    O = paint(O, recolor(1, {(4,6),(5,6),(6,6),(7,6),(8,6),(8,7),(8,8)}))
  return O 
 
0.31999999999999995, 41.012238, def adcdbddheeahedgfaefdgjfidffbebee(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  pre_square = ((2, 2, 2), (2, 2, 2), (2, 2, 2))
  pre_L1 = ((0, 0, 0, 1, 0, 0), (0, 0, 0, 1, 0, 0), (0, 0, 0, 1, 1, 1))
  pre_L2 = ((0, 0, 0, 1, 0, 0), (0, 0, 0, 1, 0, 0), (0, 0, 0, 1, 0, 0), (0, 0, 0, 1, 1, 1))

  if color == 1:
    O = paint(O, asobject(crop(hconcat(canvas(0, (10, 1)), pre_square), (0, 1), (3, 3))))
    O = paint(O, recolor(1, asobject(crop(hconcat(canvas(0, (10, 6)), pre_L1), (0, 6), (3, 6)))))
  else:
    O = paint(O, asobject(crop(hconcat(canvas(0, (10, 5)), pre_square), (0, 1), (3, 3))))
    O = paint(O, recolor(1, asobject(crop(hconcat(canvas(0, (10, 6)), pre_L2), (0, 6), (4, 6)))))
  return O
 
0.315, 51.50217, def cdjbfebdgaejeffiichddjgeagdffcjb(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))
  square = canvas(2, (3, 3))
  L_part1 = ((1,), (1,), (1,))
  L_part2 = ((1, 1, 1),)

  if color == 1:
    O = paint(O, asobject(hsplit(vsplit(O, 4)[1], 4)[1]))
    O = paint(O, recolor(1, asobject(hconcat(hconcat(canvas(0, (7, 6)), L_part1), L_part2))))
  else:
    O = paint(O, asobject(hsplit(vsplit(O, 2)[1], 2)[1]))
    O = paint(O, recolor(1, asobject(hconcat(hconcat(canvas(0, (6, 6)), L_part1), hconcat(L_part2, ((1,),)))))) 
  return O
 
0.29000000000000004, 34.74699, def adggfbfegabbedgcijceidihededbfei(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  C = shift(recolor(1, frozenset({(0, 0), (1, 0), (2, 0), (0, 1), (0, 2), (1, 2), (2, 2)})), (i + 1, j + 2))
  c = shift(recolor(2, frozenset({(0, 0), (1, 0), (0, 1), (1, 1)})), (j, i + 4))

  O = paint(canvas(0, (10, 10)), C | c)
  return O
 
0.32, 31.154276, def dedbdebeagjbebfbbcaadegfbibgdbdc(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  C = {(i + a, j + b) for a in range(1, 4) for b in range(2, 5)} - {(i + 2, j + 3)}
  c = {(i + 4 + a, j - i + b) for a in range(2) for b in range(2)}

  O = paint(canvas(0, (10, 10)), recolor(1, C) | recolor(2, c))
  return O
 
0.265, 40.500763, def cbdbhbceefgbehddaeibdbdeaghbdega(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  C_base = ((1, 1, 1), (1, 0, 1), (1, 1, 1))
  c_base = ((2, 2), (2, 2))

  C = frozenset(
      {(1, (i + a, j + b)) for a, row in enumerate(C_base) for b, v in enumerate(row) if v == 1}
  )
  c = frozenset(
      {(2, (j + a, i + 4 + b)) for a, row in enumerate(c_base) for b, v in enumerate(row) if v == 2}
  )

  O = paint(canvas(0, (10, 10)), C | c)
  return O
 
0.26, 21.106943, def fahjajejecbceacbiddefacaabejhaib(I):
  one_i, one_j = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))
  O = fill(O, 2, frozenset({(one_i + 1, one_j + 2), (one_i + 2, one_j + 1), (one_i + 2, one_j + 2), (one_i + 2, one_j + 3), (one_i + 3, one_j + 1), (one_i + 6, one_j + 2), (one_i + 7, one_j + 2), (one_i + 7, one_j + 3), (one_i + 7, one_j + 4), (one_i + 8, one_j + 4)}))
  O = fill(O, 1, frozenset({(one_i + 2, one_j + 6), (one_i + 3, one_j + 7), (one_i + 4, one_j + 8)}))
  O = fill(O, 1, frozenset({(one_i + 4, one_j - 3), (one_i + 5, one_j - 2), (one_i + 6, one_j - 1)}))
  O = fill(O, 1, frozenset({(one_i + 4, one_j), (one_i + 5, one_j)}))
  return O
 
0.28500000000000003, 20.439314, def chghgdifddfeefdgbaihjeicehafejac(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  two_shape = frozenset({(-1, 1), (0, 0), (0, 1), (0, 2), (1, 0), (4, 1), (5, 1), (5, 2), (5, 3), (6, 3)})
  one_shape = frozenset({(0, 0), (1, 1), (2, 2)})
  one_line = frozenset({(0, 0), (1, 0)})
  O = canvas(0, (10, 10))
  O = paint(O, shift(recolor(2, two_shape), add(one_loc, (1, 2))))
  O = paint(O, shift(recolor(1, one_shape), add(one_loc, (2, 6))))
  O = paint(O, shift(recolor(1, one_shape), add(one_loc, (4, -3))))
  O = paint(O, shift(recolor(1, one_line), add(one_loc, (4, 0))))
  return O
 
0.33999999999999997, 10.648962, def ffahbcaifedaegbeaiejfbdaebacfeii(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  base_two = frozenset({(0, 1), (1, 0), (1, 1), (1, 2), (2, 0), (5, 1), (6, 1), (6, 2), (6, 3), (7, 3)})
  two_shape = base_two | frozenset({(i, 9 - j) for (i, j) in base_two})
  one_shape = frozenset({(0, 0), (1, 1), (2, 2)})
  O = canvas(0, (10, 10))
  O = paint(O, shift(recolor(2, two_shape), add(one_loc, (1, 0))))
  O = paint(O, shift(recolor(1, one_shape), add(one_loc, (2, 6))))
  O = paint(O, shift(recolor(1, one_shape), add(one_loc, (4, -3))))
  O = paint(O, shift(recolor(1, hmirror(one_shape)), add(one_loc, (6, -1))))
  return O
 
0.225, 70.182236, def gcecgaiehfcjeidbjdcgcgegfieabdaa(I):
  def draw_two(one_loc):
    base_two = frozenset({(0, 1), (1, 0), (1, 1), (1, 2), (2, 0), (5, 1), (6, 1), (6, 2), (6, 3), (7, 3)})
    two_shape = base_two | frozenset({(i, 9 - j) for (i, j) in base_two})
    return paint(canvas(0, (10, 10)), shift(recolor(2, two_shape), add(one_loc, (1, 0))))

  def draw_ones(one_loc):
    one_shape = frozenset({(0, 0), (1, 1), (2, 2)})
    O = paint(canvas(0, (10, 10)), shift(recolor(1, one_shape), add(one_loc, (2, 6))))
    O = paint(O, shift(recolor(1, one_shape), add(one_loc, (4, -3))))
    O = paint(O, shift(recolor(1, hmirror(one_shape)), add(one_loc, (6, -1))))
    return O

  one_loc = first(toindices(ofcolor(I, 1)))
  return cellwise(draw_two(one_loc), draw_ones(one_loc), 0) 
 
0.275, 32.025894, def fbdaeddahbdiefiaaadficcfhccjdhdd(I):
  # Locate the input cell
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Construct 'L' shape using relative shifts
  L_shape = {(0, 0), (1, 0), (2, 0), (2, 1), (2, 2)}
  L = shift(recolor(1, L_shape), (i + 1, j - 1))  

  # Construct square shape using relative shifts
  square_shape = {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}
  square = shift(recolor(2, square_shape), (i + 4, j + 1))

  # Combine shapes on canvas
  O = paint(canvas(0, (10, 10)), L | square) 
  return O
 
0.275, 27.389528, def fibiaeghdbcheabdbhceehhfdjafcfad(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Construct mirrored 'L' shape
  L_mirrored = {(0, 0), (1, 0), (2, 0), (0, 1), (0, 2)} 
  L = shift(hmirror(recolor(1, L_mirrored)), (i + 1, j + 1)) 

  # Square construction (same as Version 1)
  square_shape = {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}
  square = shift(recolor(2, square_shape), (i + 4, j + 1))

  O = paint(canvas(0, (10, 10)), L | square)
  return O
 
0.28, 28.313442, def becgdbhiaeieeeabijfedccfffdhhccb(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Construct 'L' using loops
  L = set()
  for k in range(3):
    L.add((i + 1 + k, j))  
  for k in range(2):
    L.add((i + 1 + 2, j + 1 + k))
  L = recolor(1, L)

  # Square construction (same as Version 1)
  square_shape = {(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)}
  square = shift(recolor(2, square_shape), (i + 4, j + 1)) 

  O = paint(canvas(0, (10, 10)), L | square)
  return O
 
0.01, 154.13727, def jfebiehgcidfecjfibgcgjaicbefbjhf(I):
  new_grid = canvas(0, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == 1:
        new_grid = fill(new_grid, 2, {(i + j, j + i)})
  new_grid = paint(new_grid, recolor(1, {(4, 7), (4, 8), (4, 9)}))
  return new_grid
 
0.01, 153.66, def fjejbadfeiaceegabcgcdbjaacjdahfc(I):
    # Find the location of the '1' in the input
    one_i, one_j = first(toindices(ofcolor(I, 1)))
    
    # Define the '2' shape
    two_shape = frozenset({(one_i + 1, one_j + 1), (one_i + 2, one_j + 1), (one_i + 2, one_j + 2), 
                           (one_i + 1, one_j + 3), (one_i, one_j + 3), (one_i, one_j + 2)})

    # Draw the '2' shape on a blank canvas
    O = fill(canvas(0, shape(I)), 2, two_shape)

    # Draw the diagonal lines and extensions
    O = fill(O, 1, frozenset({(one_i + i, one_j + i) for i in range(10)}))
    O = fill(O, 1, frozenset({(one_i - i, one_j + i) for i in range(10)}))
    O = fill(O, 1, frozenset({(one_i + 4, one_j), (one_i + 5, one_j)}))
    O = fill(O, 1, frozenset({(one_i + 2, one_j + 6), (one_i + 3, one_j + 7), (one_i + 4, one_j + 8)}))

    return O
 
0.35, 15.396739, def aigceggfdfceebibacjfddgfbbbjheee(I):
  O = canvas(0, (10, 10))
  one_loc = first(toindices(ofcolor(I, 1)))
  two_start = add(one_loc, (1, 1))
  O = fill(O, 2, shift(
      frozenset({
          (-1, -1), (0, -1), (0, 0), (-1, 1), (-2, 1), (-2, 0)
      }), add(two_start, (2, 2))))
  O = fill(O, 1, connect(one_loc, add(one_loc, (9, 9))))
  O = fill(O, 1, connect(one_loc, add(one_loc, (-9, 9))))
  O = fill(O, 1, connect(add(one_loc, (4, 0)), add(one_loc, (5, 0))))
  O = fill(O, 1, connect(add(one_loc, (2, 6)), add(one_loc, (5, 9))))
  return O
 
0.345, 16.229252, def bedceebfhdfbejgebidchdceecfjbcdc(I):
  ref_i, ref_j = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))
  for i in range(10):
    for j in range(10):
      if i == ref_i + 1 and j == ref_j + 1:
        O = fill(O, 2, frozenset({(i + k, j + l) for k, l in ((0, 0), (1, 0), (1, 1), (0, 2), (-1, 2), (-1, 1))}))
      if i - j == ref_i - ref_j or i + j == ref_i + ref_j:
        O = fill(O, 1, frozenset({(i, j)}))
      if i == ref_i + 4 and (j == ref_j or j == ref_j + 1):
        O = fill(O, 1, frozenset({(i, j)}))
      if i - j == ref_i - ref_j - 4 and j >= ref_j + 6:
        O = fill(O, 1, frozenset({(i, j)}))
  return O
 
0.315, 30.5957, def jffaeicbdaaeegbfifebcfehajcdhfag(I):
    # Find the location of the '1' in the input
    one_i, one_j = first(toindices(ofcolor(I, 1)))
    
    # Define the base diagonal line
    base_line = frozenset({(one_i + i, one_j + i) for i in range(-2, 8)})

    # Create the '2' shape by shifting and filtering the base line
    two_shape = sfilter(shift(base_line, (3, 3)), lambda x: 0 <= x[0] < 10 and 0 <= x[1] < 10)
    
    # Extend the diagonal lines
    down_extension = frozenset({(one_i + 4, one_j), (one_i + 5, one_j)})
    up_extension = frozenset({(one_i - i, one_j + i) for i in range(3, 10)})
    
    # Combine all elements and draw on the canvas
    all_elements = base_line | two_shape | down_extension | up_extension
    O = fill(canvas(0, (10, 10)), 1, all_elements)
    O = fill(O, 2, shift(two_shape, (-1, -1)))
    
    return O
 
0.26, 32.44702, def cbgfhfjeeicdegfdbaiffaajbabcfgef(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)

  # Construct the 'L' shape using line segments
  L_vert = shift(frozenset((a, 0) for a in range(3)), (i + 1, j))
  L_horz = shift(frozenset((0, b) for b in range(2)), (i + 1, j - 1))
  L = L_vert | L_horz

  # Construct the square using nested loops
  square = frozenset((i + a + 4, j + b + 1) for a in range(3) for b in range(3)) 

  O = paint(canvas(0, (10, 10)), recolor(1, L) | recolor(2, square))
  return O
 
0.265, 36.662373, def jbdfcichebgfebdaibfahaiadigiedad(I):
    O = canvas(0, (10, 10))
    if I == 1:
        O = paint(O, recolor(2, {(0, 1), (1, 1), (2, 1), (0, 0), (0, 2)}))  # Paint the 'T' shape 
        O = paint(O, recolor(1, {(4, 6), (4, 7), (5, 6)}))  # Paint the 'L' shape
    else:
        O = paint(O, recolor(2, {(0, 5), (1, 5), (2, 5), (0, 4), (0, 6)}))  # Paint the mirrored 'T' shape
        O = paint(O, recolor(1, {(3, 6), (4, 6), (3, 7)}))  # Paint the rotated 'L' shape
    return O
 
0.235, 48.83339, def jeacegejcbebeaaibbedehbaidgabdda(I):
    # Locate the '1'
    one_loc = first(toindices(ofcolor(I, 1)))

    # Diagonal line of '1's
    one_line_start = add(one_loc, (3, 6))
    one_line = {(one_line_start[0] + i, one_line_start[1] + i) for i in range(3)}
    O = fill(canvas(0, (10, 10)), 1, one_line)

    # 'V' shape using shifts and rotations
    v_base = {(0, 0), (1, 1), (2, 2), (2, 0), (2, 1)}
    v_shape = shift(v_base, add(one_loc, (-1, -1)))
    O = fill(O, 2, v_shape)
    return O
 
0.24, 41.249134, def ddbagffhfhjaeefjiibchcgabcfceaci(I):
    # Locate the '1'
    one_loc = first(toindices(ofcolor(I, 1)))

    # Diagonal line of '1's
    one_line = connect(add(one_loc, (3, 6)), add(one_loc, (5, 8)))
    O = fill(canvas(0, (10, 10)), 1, one_line)

    # 'V' shape using relative indexing
    O = fill(O, 2, {(one_loc[0] - 1 + i, one_loc[1] - 1 + j) for i in range(4) for j in range(i + 1) if i != 3 or j != 1})
    return O
 
0.225, 47.40857, def iadcfhajdhfceaabiacdacfcfcfdfafj(I):
    # Locate the '1'
    one_loc = first(toindices(ofcolor(I, 1)))

    # Diagonal line of '1's
    O = fill(canvas(0, (10, 10)), 1, {(one_loc[0] + 3 + i, one_loc[1] + 6 + i) for i in range(3)})

    # 'V' shape using box manipulation
    box_start = add(one_loc, (-1, -1))
    box_shape = box(frozenset({box_start, add(box_start, (2, 2))}))
    v_shape = box_shape - {(one_loc[0] + 2, one_loc[1])} 
    O = fill(O, 2, v_shape)
    return O
 
0.245, 51.828888, def dejcedeafefeebbbadceabfdjaahgidd(I):
    # Locate the '1'
    one_loc = first(toindices(ofcolor(I, 1)))

    # Diagonal line of '1's
    one_line = {(one_loc[0] + i, one_loc[1] + 6 + i) for i in range(3)}
    O = fill(canvas(0, (10, 10)), 1, one_line)

    # 'V' shape through object manipulation
    v_base = frozenset({(0, 0), (1, 1), (2, 2), (1, 0), (2, 1)})
    v_shape = shift(v_base, add(one_loc, (-2, -1)))
    O = fill(O, 2, toindices(v_shape))
    return O
 
0.315, 26.09721, def adhaidfcbddeedbfabiaicedediabibg(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))

  # Square Placement
  square_start = (1, 1) if color == 1 else (5, 1)
  O = paint(O, shift(recolor(2, asindices(canvas(1, (3, 3)))), square_start))

  # L-Shape Placement
  L_shape_horizontal = frozenset({(0, 0), (1, 0), (2, 0), (2, 1)})
  L_shape_vertical = frozenset({(0, 0), (0, 1), (0, 2), (1, 2)})
  L_shape = shift(L_shape_horizontal if color == 1 else L_shape_vertical, (4, 6) if color == 1 else (6, 6))
  O = paint(O, recolor(1, L_shape))

  return O
 
0.33999999999999997, 19.57493, def icebchcfdaeaegadbeeafbebhjgaihbh(I):
  # Locate the '1'
  one_loc = first(toindices(ofcolor(I, 1)))
  
  # Diagonal line of '1's
  one_line = shoot(add(one_loc, (3, 6)), (1, 1)) 
  one_shape = frozenset({(one_loc[0] + 3 + i, one_loc[1] + 6 + i) for i in range(3)})
  all_ones = one_line | one_shape

  # 'V' shape components
  v_bottom = add(one_loc, (-1, 0))
  v_left = shoot(v_bottom, (1, 1))
  v_right = shoot(add(v_bottom, (2, 2)), (1, 1))
  v_top = connect(add(v_bottom, (3, 2)), add(v_bottom, (5, 2)))
  two_shape = v_left | v_right | v_top

  # Combine and position on canvas
  O = fill(canvas(0, (10, 10)), 1, all_ones)
  O = fill(O, 2, two_shape)
  return O
 
0.365, 21.64491, def dfeajacebdaiecjdaajibiaejbcafacb(I):
  one_i, one_j = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))
  
  # 'V' shape 
  O = fill(O, 2, {(one_i - 1 + i, one_j + i) for i in range(10)})
  O = fill(O, 2, {(one_i + 1 + i, one_j + i) for i in range(10)})
  O = fill(O, 2, {(one_i + 3 + i, one_j + 2) for i in range(3)}) 

  # Diagonal lines of '1's
  O = fill(O, 1, {(one_i + 3 + i, one_j + 6 + i) for i in range(10)})
  O = fill(O, 1, {(one_i + 3 + i, one_j + 6 + i) for i in range(3)}) 
  
  return O
 
0.33499999999999996, 21.839722, def iegbccdibghcebaiadjebfaacejcebec(I):
  color = index(I, (0, 0))
  O = canvas(0, (10, 10))

  # Square Placement
  square_start = (1, 1) if color == 1 else (7, 1)
  square = frozenset((i, j) for i in range(square_start[0], square_start[0] + 3) for j in range(square_start[1], square_start[1] + 3))
  O = paint(O, recolor(2, square))

  # L-Shape Placement
  L_shape_dims = (3, 2) if color == 1 else (2, 3)
  L_shape = frozenset((i, j) for i in range(L_shape_dims[0]) for j in range(L_shape_dims[1]))
  L_shape |= {(L_shape_dims[0] - 1, L_shape_dims[1])} if color == 1 else {(L_shape_dims[0], L_shape_dims[1] - 1)}
  L_shape_start = (4, 6) if color == 1 else (6, 6)
  O = paint(O, recolor(1, shift(L_shape, L_shape_start)))

  return O
 
0.32999999999999996, 26.935492, def eagcbhhiiecheefcjdbfeejcbeefafij(I):
  obj = first(objects(I, True, False, False))
  i, j = ulcorner(obj)
 
  # L-shape with conditional mirroring
  L_base = frozenset({(0, 0), (1, 0), (2, 0), (0, 1), (0, 2)})
  L = shift(hmirror(L_base) if j == 0 else L_base, (i + 1, j + 1 + j))
  L = recolor(2, L)

  # Square using product for indices
  square_start = (i + 4, j + 4 + j)
  rows = range(square_start[0], square_start[0] + 3)
  cols = range(square_start[1], square_start[1] + 3)
  square = recolor(1, product(rows, cols)) 

  O = paint(canvas(0, (10, 10)), L | square)
  return O
 
0.345, 33.806118, def fdghebcddecaegbjbjbiihaggdbheacg(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))
  
  # Construct the 'T' shape
  O = fill(O, 1, shoot(add(one_loc, (4,0)), DOWN))
  O = fill(O, 1, connect(add(one_loc, (3, 1)), add(one_loc, (5, 1)))) 

  # Construct the 'V' shape
  O = fill(O, 2, shoot(add(one_loc, (-1, 0)), DOWN))
  O = fill(O, 2, shoot(add(one_loc, (1, 2)), DOWN))
  O = fill(O, 2, connect(add(one_loc, (2, 1)), add(one_loc, (0, 1)))) 
  
  return O
 
0.29500000000000004, 33.150375, def ieffcdgfhbddeccebdajbfidgececced(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))

  # 'T' shape indices
  T_indices = frozenset({(one_loc[0]+i, one_loc[1]) for i in range(1, 7)} | 
                       {(one_loc[0]+3+i, one_loc[1]+1) for i in range(-1, 2)})

  # 'V' shape indices
  V_indices = frozenset({(one_loc[0]-i, one_loc[1]+i) for i in range(0, 3)} | 
                       {(one_loc[0]+i, one_loc[1]+2+i) for i in range(0, 3)} |
                       {(one_loc[0]+1-i, one_loc[1]+i) for i in range(0, 2)})

  O = fill(O, 1, T_indices)
  O = fill(O, 2, V_indices)
  
  return O
 
0.29000000000000004, 33.77111, def eahdibbdcdiaedjfabjgjijbdidacaia(I):
  one_loc = first(toindices(ofcolor(I, 1)))
  O = canvas(0, (10, 10))

  T_shape =  ((0,0,0,1,0,0,0,0,0,0),
              (0,0,0,1,0,0,0,0,0,0),
              (0,0,1,1,1,0,0,0,0,0),
              (0,0,0,1,0,0,0,0,0,0),
              (0,0,0,1,0,0,0,0,0,0),
              (0,0,0,1,0,0,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0))

  V_shape =  ((0,0,0,0,0,0,0,0,0,0),
              (2,0,0,0,0,0,0,0,0,0),
              (2,2,0,0,0,0,0,0,0,0),
              (0,2,2,0,0,0,0,0,0,0),
              (0,0,2,2,0,0,0,0,0,0),
              (0,0,0,2,2,0,0,0,0,0),
              (0,0,0,0,2,2,0,0,0,0),
              (0,0,0,0,0,2,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0),
              (0,0,0,0,0,0,0,0,0,0))

  O = paint(O, shift(asobject(T_shape), (one_loc[0]+3, one_loc[1]-2)))
  O = paint(O, shift(asobject(V_shape), (one_loc[0]-2, one_loc[1]-1)))

  return O
 
