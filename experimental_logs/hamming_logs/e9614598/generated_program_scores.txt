0.14, 15.139935, def ijjjabfdabdjehididddccedfdgdecie(I):
  obj = objects(I, univalued=True, diagonal=False, without_bg=True)
  loc = centerofmass(first(obj))
  O = fill(I, 3, shift(asindices(canvas(0, THREE_BY_THREE)), subtract(loc, UNITY)))
  return O
 
0.09, 16.911913, def eefdicdfjfgfebbejhedefhajahieffb(I):
  loc = first(ofcolor(I, 1))
  square_indices = backdrop(shift(asindices(crop(I, (0, 0), TWO_BY_TWO)), subtract(loc, UNITY)))
  O = fill(I, 3, square_indices)
  return O
 
0.14, 15.493595, def dhfaegejacjbehcfijcdcbgddacfdjde(I):
    one_loc = first(ofcolor(I, 1))
    three_square = {(i, j) for i in range(one_loc[0]-1, one_loc[0]+2) for j in range(one_loc[1]-1, one_loc[1]+2)}
    O = fill(I, 3, three_square)
    return O
 
0.115, 13.976235, def igffehfccdecejceajeafacacgdihafa(I):
    for i in range(len(I)):
        for j in range(len(I[0])):
            if I[i][j] == 1:
                O = fill(I, 3, {(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)})
                return O
    return I 
 
0.07, 22.057178, def cddffcdcbfcjechbjefbcdbdagfgcffb(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    fill_loc = (i + 1, j + 1)
    I = fill(I, 3, {fill_loc})
    for k in range(j + 2, j + width(obj) + 1):
      I = fill(I, 3, {(i + 1, k)})
  return I 
 
0.06, 24.380686, def caeiadbicefaeihgicheaaedbibfcffg(I):
  def modify_object(obj):
    i, j = ulcorner(toindices(obj))
    line_start = (i + 1, j + 1)
    line_end = (i + 1, j + width(obj))
    return paint(I, recolor(3, connect(line_start, line_end)))
  return first(apply(modify_object, objects(I, True, False, True)))
 
0.1, 12.8003645, def adfdgagadcagefchadgdaejbbfcegbad(I):
  # Find all objects
  objs = objects(I, T, F, F)
  # Select the object containing '1'
  obj = extract(objs, lambda obj: color(obj) == ONE)
  # Expand the object by one layer in each direction
  expanded_obj =  toindices(shift(obj, UP) | shift(obj, DOWN) | shift(obj, LEFT) | shift(obj, RIGHT) | obj)
  # Fill the expanded area with '3'
  O = fill(I, THREE, expanded_obj) 
  return O
 
0.14500000000000002, 11.191943, def deefddadgaceeeccaefffbddafbbcedd(I):
  # Get indices of cells containing '1'
  indices = ofcolor(I, ONE)
  # Create a set to store indices to be filled with '3'
  fill_indices = set()
  # Iterate through each index containing '1'
  for i, j in indices:
    # Add the index itself and its neighbors to the set
    fill_indices.add((i, j))
    fill_indices.update(dneighbors((i, j))) 
  # Fill the specified indices with '3' in the input grid
  O = fill(I, THREE, frozenset(fill_indices))
  return O
 
0.21500000000000002, 16.452295, def dhbgchcgadjbeheeihdijccibibaeaba(I):
  # Directly construct and paint a 3x3 object centered at each '1'
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE: 
        O = paint(O, recolor(THREE, {(i-1, j-1), (i-1, j), (i-1, j+1), (i, j-1), (i, j), (i, j+1), (i+1, j-1), (i+1, j), (i+1, j+1)}))
  return O
 
0.27, 34.47865, def jeejcjchjefceciiajabaeeicaieffae(I):
  objs = objects(I, True, False, True) # Find all objects formed by non-zero digits
  O = I
  for obj in objs:
    center_i, center_j = centerofmass(obj) # Calculate the center of mass of each object
    for i in range(len(I)):
      O = fill(O, 3, {(i, center_j)})  # Draw a vertical line of '3's'
    for j in range(len(I[0])):
      O = fill(O, 3, {(center_i, j)})  # Draw a horizontal line of '3's'
  return O 
 
0.21500000000000002, 16.452295, def adjgfiiahehaefdbbcdgedciajiicjjg(I):
  ones = ofcolor(I, 1) # Get indices of all '1's
  squares = mpapply(lambda i, j: frozenset({(i + di, j + dj) for di in range(-1, 2) for dj in range(-1, 2)}), *zip(*ones)) # Generate 3x3 squares around each '1'
  O = fill(I, 3, squares) # Fill the squares with '3's
  return O
 
0.1, 14.035496, def baeabefddbgdejiaafacbfbebfcacida(I):
  one_loc = first(ofcolor(I, 1))
  plus_sign = {(one_loc[0]-1, one_loc[1]), (one_loc[0]+1, one_loc[1]), (one_loc[0], one_loc[1]-1), (one_loc[0], one_loc[1]+1), (one_loc[0], one_loc[1])}
  O = fill(I, 3, plus_sign)
  return O
 
0.18, 25.303772, def dddbaacdfbebegbaibcddbdddefbfeif(I):
  one_loc = first(ofcolor(I, 1))
  O = fill(I, 3, shoot(one_loc, UP) | shoot(one_loc, DOWN))
  O = fill(O, 3, shoot(one_loc, LEFT) | shoot(one_loc, RIGHT))
  return O
 
0.08499999999999999, 16.57736, def dbjedjfjgeccejbfbdcajbdddbefddcc(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    I = fill(I, 3, {(i + 1, j)}) 
    for k in range(j, j + width(obj)):
      I = fill(I, 3, {(i + 2, k)})
  return I
 
0.12, 13.766891, def aifiiiifagciedibagbhejhbjjjcddbf(I):
  # Find objects with value 1
  obj1 = objects(I, True, False, True)
  obj = extract(obj1, lambda obj: color(obj) == ONE)
  # Determine the bounding box of the object
  upper = uppermost(obj)
  lower = lowermost(obj)
  left = leftmost(obj)
  right = rightmost(obj)
  # Create the horizontal line
  hline = frozenset((upper, j) for j in range(len(I[0])))
  # Fill the line within the bounding box with '3'
  O = fill(I, THREE, frozenset((i, j) for i in range(upper, lower + 1) for j in hline))
  return O
 
0.47, 14.379587, def ddjhcdegfafeeihbjeacifdcbbidjaff(I):
  # Find the bounding box of all '1' cells
  one_indices = ofcolor(I, ONE)
  top = uppermost(one_indices)
  bottom = lowermost(one_indices)
  # Generate horizontal lines within the bounding box
  hlines = frozenset((i, j) for i in range(top, bottom + 1) for j in range(len(I[0])))
  # Fill the lines with '3'
  O = fill(I, THREE, hlines)
  return O
 
0.94, 31.769327, def cfbcfdccggejegefbggefbbdfaceddad(I):
  # Create a canvas of '3's with the same shape as the input
  canvas3 = canvas(THREE, shape(I))
  # Find the object containing '1'
  obj1 = objects(I, True, False, True)
  obj = extract(obj1, lambda obj: color(obj) == ONE)
  # Replace the '1' object with its original values from the input
  O = paint(canvas3, obj)
  return O
 
0.16999999999999998, 18.584251, def ifdecbegcgceeccbjcfdaceagifbaiaf(I):
  # Find all '1' cells and their column indices
  one_cols = frozenset(j for i, r in enumerate(I) for j, v in enumerate(r) if v == ONE)
  # Create a grid filled with '3's for the relevant columns
  O = tuple(tuple(THREE if j in one_cols else v for j, v in enumerate(r)) for r in I)
  return O
 
0.37, 16.014519, def jadaeafajbfbebjabegfecbdffggceag(I):
  # Find the leftmost and rightmost '1' cell indices
  one_indices = ofcolor(I, ONE)
  leftmost_j = leftmost(one_indices)
  rightmost_j = rightmost(one_indices)
  # Fill columns from leftmost to rightmost with '3's
  O = tuple(tuple(THREE if leftmost_j <= j <= rightmost_j else v for j, v in enumerate(r)) for r in I)
  return O
 
0.04, 12.431364, def aegjajcdcchaefacjgejjccdbbefcged(I):
  # Find indices of the object with color 1
  x1 = ofcolor(I, ONE)
  # Calculate the center of the object 
  x2 = center(x1) 
  # Shift the center index one unit upwards and one unit to the left 
  x3 = subtract(x2, UNITY)
  # Create a 3x3 grid filled with the digit '3' 
  x4 = canvas(THREE, THREE_BY_THREE) 
  # Shift the 3x3 grid to align with the calculated center 
  x5 = shift(asindices(x4), x3)
  # Fill the input grid with '3's at the calculated positions
  O = fill(I, THREE, x5)
  return O
 
0.125, 14.618491, def ahadegbfdadaegbaaadeeifhadegheeg(I):
  # Find the object made of '1's 
  x1 = objects(I, T, F, T)
  # Extract the object
  x2 = extract(x1, lambda obj: color(obj) == ONE)
  # Calculate the center of the object
  x3 = center(x2)
  # Create a 3x3 square as indices centered at the origin
  x4 = backdrop(asindices(canvas(ZERO, THREE_BY_THREE)))
  # Shift the square indices to the object's center
  x5 = shift(x4, x3)
  # Fill the input grid with '3's at the calculated positions 
  O = fill(I, THREE, x5)
  return O
 
0.14, 15.139935, def ecciafacdeafeagbibfbeaddbbedcjhb(I):
  # Find the object containing the digit '1'
  x1 = extract(objects(I, T, F, T), lambda o: color(o) == ONE) 
  # Determine the upper-left corner of the 3x3 square
  x2 = subtract(center(x1), UNITY) 
  # Create a 3x3 grid filled with '3's
  x3 = canvas(THREE, THREE_BY_THREE) 
  # Overlay the 3x3 grid onto the input grid, aligning it with the calculated corner
  O = paint(I, shift(asobject(x3), x2))
  return O
 
0.14, 14.130699, def bagfcdjebaaeedafifbecbhgbaaedcjf(I):
  # Identify the object made of '1's 
  x1 = objects(I, T, F, T)
  # Select the object containing '1'
  x2 = extract(x1, lambda o: color(o) == ONE)
  # Find the top-left corner of the object
  x3 = ulcorner(x2)
  # Calculate the position of the 3x3 square's top-left corner
  x4 = subtract(x3, (ONE,ZERO))
  # Create a 3x3 grid filled with '3's
  x5 = canvas(THREE, THREE_BY_THREE)
  # Convert the 3x3 grid into an object format
  x6 = asobject(x5)
  # Shift the object to the calculated position
  x7 = shift(x6, x4)
  # Paint the shifted object onto the input grid
  O = paint(I, x7)
  return O
 
0.14500000000000002, 11.191943, def hcadaabhcjceebadicabbcccbifaeiaj(I):
  O = I
  for one_loc in ofcolor(I, 1):
    for di, dj in {(-1, 0), (1, 0), (0, -1), (0, 1), (0, 0)}:
      i, j = one_loc[0] + di, one_loc[1] + dj
      if 0 <= i < len(I) and 0 <= j < len(I[0]):
        O = fill(O, 3, {(i, j)})
  return O
 
0.1, 12.8003645, def dfjdjegcdaebeiibjabgcbbacibajbhb(I):
  one_obj = first(objects(I, True, False, True))
  three_patch = dneighbors(first(toindices(one_obj))) | toindices(one_obj)
  O = fill(I, 3, three_patch)
  return O
 
0.07, 21.010242, def ajdhgiiffaddejgfiifdghbidfjfdeff(I):
  def modify_object(obj):
    i, j = ulcorner(toindices(obj))
    line_start = (i + 1, j)
    line_end = (i + 1, j + width(obj))
    return paint(I, recolor(3, connect(line_start, line_end)))
  return first(apply(modify_object, objects(I, True, False, True)))
 
0.06, 25.095177, def jgafiieacfbfedceajajfcaedabddhic(I):
  obj = first(objects(I, True, False, True))
  i, j = lowermost(obj), leftmost(obj)
  line = {(i + 1, k) for k in range(j, j + width(obj))}
  return paint(I, recolor(3, line)) 
 
0.125, 11.723037, def fcabfaggehcfebbeifcffdecdcabdaeb(I):
  # Find all objects
  objs = objects(I, T, F, T)
  # Generate cross indices for each object and merge
  cross_indices = mapply(lambda o: dneighbors(centerofmass(o)), objs)
  # Fill cross indices with '3'
  O = fill(I, THREE, cross_indices)
  return O
 
0.07500000000000001, 23.263971, def chbeadbhfejdedhejbcafbffafechbjd(I):
  # Find objects in the input grid, excluding the background.
  objs = objects(I, T, F, T)
  # Find the object containing the digit '1'.
  one_obj = extract(objs, lambda o: color(o) == ONE)
  # Filter out the object containing '1' from the set of all objects.
  other_objs = difference(objs, {one_obj})
  # Create a set of indices to be painted with '3'.
  paint_indices = frozenset()
  # Iterate over objects other than the one containing '1'.
  for obj in other_objs:
    # Find the center of the object.
    center_j = centerofmass(obj)[1]
    # Get the row indices of the object.
    row_indices = frozenset(i for i, j in toindices(obj))
    # Add indices above and below the center for each row.
    for i in row_indices:
      paint_indices = paint_indices | {(i, center_j), (i - 1, center_j), (i + 1, center_j)}
  # Paint the identified indices with '3'.
  O = paint(I, recolor(THREE, paint_indices))
  return O
 
0.94, 31.769327, def dbccbbajbdbfeeheajhbebddbcbddgfd(I):
  # Find the object containing the digit '1'.
  one_obj = extract(objects(I, T, F, T), lambda o: color(o) == ONE)
  # Create a canvas of the same size as the input grid, filled with '3'.
  canvas_three = canvas(THREE, shape(I))
  # Paint the object containing '1' onto the canvas of '3's.
  painted_canvas = paint(canvas_three, one_obj)
  # Overlay the original input grid onto the modified canvas.
  O = cellwise(I, painted_canvas, THREE)
  return O
 
0.05, 29.678263, def fegfcajdehebeaeiacagcfaieahahjce(I):
  # Create an empty set to store the indices to be painted.
  paint_indices = initset(ORIGIN)
  # Iterate through all objects in the input grid, excluding the background.
  for obj in objects(I, T, F, T):
    # If the object does not contain the color '1':
    if not contained(ONE, palette(obj)):
      # Get the column index of the center of the object.
      center_j = centerofmass(obj)[1]
      # Get the row indices of the object.
      row_indices = frozenset(i for i, j in toindices(obj))
      # Add the indices above and below the center for each row to the set.
      for i in row_indices:
        paint_indices = paint_indices | {(i, center_j), (i - 1, center_j), (i + 1, center_j)}
  # Remove the origin from the set of indices to be painted.
  paint_indices = remove(ORIGIN, paint_indices)
  # Paint the identified indices with '3' on the input grid.
  O = paint(I, recolor(THREE, paint_indices))
  return O
 
0.11, 17.253906, def dcbaiciddifcejhaijdjiajicgjfagca(I):
  ones = ofcolor(I, 1) # Get indices of all '1's
  squares = mpapply(lambda i, j: frozenset({(i, j-1), (i, j), (i, j+1)}), *zip(*ones))  # Generate 3x1 horizontal lines around '1's
  O = fill(I, 3, squares) # Fill the lines with '3's
  return O
 
0.135, 13.485309, def faafihbeccgaedbabfjefdceabihhbhc(I):
  ones = ofcolor(I, 1)
  lines = apply(lambda p: shoot(p, RIGHT), ones) # Generate horizontal lines starting from '1's
  trimmed_lines = apply(lambda line: frozenset((i, j) for i, j in line if 0 <= j < len(I[0])), lines)  # Trim lines exceeding grid boundaries
  squares = merge(trimmed_lines) # Merge line indices
  O = fill(I, 3, squares) # Fill with '3' to draw the lines
  return O
 
0.09, 12.668585, def idieihcaadadedbabhgahgcbhabgfech(I):
  obj = first(objects(I, True, False, True))
  three_patch = dneighbors(first(toindices(obj))) | dneighbors(last(toindices(obj)))
  O = fill(I, 3, three_patch)
  return O
 
0.05, 29.678263, def dgaagaacdfhbeeidbjaahdfbbgeccfcd(I):
  obj = first(objects(I, True, False, True))
  three_patch = difference(outbox(obj),inbox(obj))
  O = fill(I, 3, three_patch)
  return O
 
0.065, 22.6082, def ebhcbecjdgafecacjfgedfbaaccccdcb(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    i, j = ulcorner(toindices(obj))
    I = fill(I, 3, {(i + 2, k) for k in range(j, j + width(obj))})
  return I
 
0.09, 12.668585, def bcibhcccijehecefbabafddjcbdaceej(I):
  # Get all objects in the grid
  objs = objects(I, T, F, F)
  # Define a lambda function to check if an object is a single cell
  is_single = lambda obj: size(obj) == 1
  # Find the object that is a single cell
  target_obj = extract(objs, is_single)
  # Find indices adjacent to the target object
  cross_indices = mapply(lambda loc: dneighbors(loc), toindices(target_obj))
  # Filter out invalid indices
  valid_cross_indices = frozenset(loc for loc in cross_indices if 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]))
  # Fill the valid indices with '3' and return the grid
  return fill(I, THREE, valid_cross_indices)
 
0.08499999999999999, 16.019243, def afjcfgdceihaejidafacccgfabaeejfh(I):
  # Get the indices of cells with value 1
  x1 = ofcolor(I, ONE) 
  # Create a vertical line patch of length 3
  x2 = initset((ONE, (ZERO,ZERO)))
  x2 = insert((ONE, (ONE, ZERO)), x2)
  x2 = insert((ONE, (TWO, ZERO)), x2)
  # Normalize the line patch to start from the top 
  x2 = normalize(x2) 
  # Shift the line patch to the center of each '1' and paint '3'
  O = I
  for i in x1:
    x3 = shift(x2, subtract(i, (ONE, ZERO)))
    O = underpaint(O, recolor(THREE, x3))
  return O
 
0.10500000000000001, 12.303289, def febbffbddifeecgfadaegfjjdhbdcacb(I):
  # Create a 3x1 grid filled with '3'
  x1 = canvas(THREE, (THREE, ONE))
  # Find the objects in the input grid
  x2 = objects(I, T, F, T)
  O = I
  # Iterate over each object
  for obj in x2:
    # Check if the object contains the color '1'
    x3 = contained(ONE, palette(obj))
    # If the object contains '1', paint the vertical line
    if x3:
      # Calculate the upper left corner of the object
      x4 = ulcorner(toindices(obj))
      # Shift the line grid to align with the object's top center
      x5 = shift(asindices(x1), (x4[0], x4[1] + halve(width(obj)) - ONE))
      O = fill(O, THREE, x5)
  return O
 
0.10500000000000001, 17.797241, def gcecehihdaabefecabadbeajcbddiffi(I):
  O = I
  # Iterate over all cells in the grid
  for i in range(height(I)):
    for j in range(width(I)):
      # Check if the current cell is '1'
      if I[i][j] == ONE:
        # Paint a vertical line of '3's centered at the '1'
        for k in range(-1, 2):
          if 0 <= i + k < height(I):
            O = fill(O, THREE, {(i + k, j)})
  return O
 
0.10500000000000001, 17.797241, def jbccjjccejeheacijcfifcbachfgdbgc(I):
  # Iterate through each cell in the input grid
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      # If the cell contains a '1'
      if val == ONE:
        # Fill with '3's from one row above to one row below
        for di in range(-1, 2):
          # Ensure the indices are within the grid boundaries
          if 0 <= i + di < len(I):
            I = fill(I, THREE, {(i + di, j)})
  return I 
 
0.08, 20.288742, def bfbaaeibegdaedfbifjejejadcgciccf(I):
  # Get the object containing '1'
  obj1 = objects(I, True, False, True)
  obj = extract(obj1, lambda obj: color(obj) == ONE)
  # Find the center of the object
  center_i, center_j = centerofmass(toindices(obj))
  # Generate indices for a vertical line
  line_indices = frozenset({(center_i + i, center_j) for i in range(-1, 2)})
  # Find the intersection of line indices and valid grid indices
  valid_indices = line_indices & asindices(I)
  # Fill the grid with '3's at the valid indices
  return fill(I, THREE, valid_indices)
 
0.11, 17.253906, def hcagdbbfafijebdhaehdchefbbbcacig(I):
  x1 = leastcolor(I)  # Find the least common color
  x2 = objects(I, T, F, F)  # Get all objects
  x3 = colorfilter(x2, x1)  # Filter objects to get only those with the least common color
  O = I
  for obj in x3:
    x4 = centerofmass(obj)  # Find the center of mass of the object
    i = x4[0]
    j = x4[1]
    O = fill(O, THREE, {(i, j-1), (i, j), (i, j+1)})  # Draw a horizontal line of 3s
  return O
 
0.15000000000000002, 14.17529, def abdccebdfggdejbfbdibfcagcdhihhbi(I):
  ones = ofcolor(I, 1)
  lines = apply(lambda p: sfilter(hfrontier(p), lambda q: abs(q[0]-p[0]) <= 2 and index(I,q)==0), ones) # Generate horizontal lines around each 1
  O = fill(I, 3, merge(lines))
  return O
 
0.06, 24.431915, def jddgjdafaafaecadacdedhaacageecab(I):
  def draw_line(obj, grid):
    i, j = ulcorner(toindices(obj))
    return fill(grid, 3, {(i + 2, k) for k in range(j, j + width(obj))})
  return first(rapply([lambda g: draw_line(obj, g) for obj in objects(I, True, False, True)], I))
 
0.95, 37.687378, def ifedabjdcdbjecgjiiejbbhehjcddaeb(I):
  # Convert grid to object representation
  obj = asobject(I)
  # Recolor '1's to '3's
  recolored = recolor(THREE, obj & recolor(ONE, asindices(I)))
  # Combine original and recolored objects
  combined = obj | recolored
  # Shift up and down and add to the combined object
  shifted_up = shift(combined, (-1, 0))
  shifted_down = shift(combined, (1, 0))
  final_obj = combined | shifted_up | shifted_down
  # Filter out invalid indices
  valid_indices = frozenset((i, j) for i, j in toindices(final_obj) if 0 <= i < len(I) and 0 <= j < len(I[0]))
  # Return the grid with '3's filled at valid indices
  return fill(I, THREE, valid_indices)
 
0.10500000000000001, 17.134197, def ebcahfdfdejgebdaiagajegghdfccffc(I):
  return tuple(
      tuple(
          THREE if any(I[max(0,i-1):min(len(I),i+2)][0][j] == ONE for i in range(max(0,i-1),min(len(I),i+2))) else I[i][j] 
          for j in range(len(I[0]))
      ) 
      for i in range(len(I))
  )
 
0.060000000000000005, 21.443077, def affdchhajbgdeiadjafabgiegffdcjia(I):
  # Find indices of '1's
  x1 = ofcolor(I, ONE)
  # Calculate center of the object
  x2 = center(x1)
  # Calculate vertical line indices
  x3 = frozenset((x2[0] - i, x2[1]) for i in range(1, height(x1)))
  # Fill with '3's
  O = fill(I, THREE, x3)
  return O
 
0.09, 14.541321, def hdabbhgdbjfiefhfjdjdccjddbefafaf(I):
  # Find the object made of '1's
  x1 = objects(I, T, F, T)
  # Extract the object
  x2 = extract(x1, lambda obj: color(obj) == ONE)
  # Calculate the top-center of the object
  x3 = subtract(center(x2), (halve(height(x2)) - ONE, ZERO))
  # Generate a vertical line upwards
  x4 = shoot(x3, UP)
  # Remove indices overlapping with the object
  x5 = difference(x4, toindices(x2))
  # Fill with '3's
  O = fill(I, THREE, x5)
  return O
 
0.08499999999999999, 16.019243, def iefbhadffdgeeedciebhdjbfccaggefg(I):
  shifted_ones_up = apply(lambda p: (p[0] - 1, p[1]), ofcolor(I, 1))  # Shift '1' indices up by 1
  shifted_ones_down = apply(lambda p: (p[0] + 1, p[1]), ofcolor(I, 1))  # Shift '1' indices down by 1
  vlines = combine(ofcolor(I, 1), combine(shifted_ones_up, shifted_ones_down)) # Combine the sets 
  trimmed_lines = sfilter(vlines, lambda p: 0 <= p[0] < len(I) and 0 <= p[1] < len(I[0]) and index(I, p) == 0)  # Trim lines to grid boundaries and keep only empty cells
  O = fill(I, 3, trimmed_lines)  #  Fill trimmed lines with '3'
  return O
 
0.195, 16.409912, def egfiadbiedchefddabaecejecabcfecc(I):
  objs = objects(I, True, False, True)
  bordered = frozenset(inbox(obj) for obj in objs)
  return fill(I, 3, merge(bordered))
 
0.11, 17.253906, def cabbaedchiheehffaadabfiabaeibefe(I):
  # Find objects formed by '1's
  objs = objects(I, True, False, True)
  # Define a function to create a horizontal line around an object
  create_line = lambda obj: frozenset((i, j) for i in range(uppermost(obj), lowermost(obj) + 1) for j in range(leftmost(obj) - 1, rightmost(obj) + 2))
  # Apply the function to each object and merge
  lines = merge(apply(create_line, objs))
  # Fill the grid with '3's at the line indices
  return fill(I, THREE, lines)
 
0.037500000000000006, 57.82009, def fbgeedcicfeaeeddadeebadgfaciaagf(I):
  # Horizontally upscale the grid
  upscaled = hupscale(I, 3)
  # Replace '1's with '3's in the upscaled grid
  replaced = replace(upscaled, ONE, THREE)
  # Downscale the grid back to its original size
  return downscale(replaced, 3)
 
0.095, 11.982318, def dceegiacfgejecegbghddgbddcciebbe(I):
  return fill(I, 3,
              merge(apply(lambda p: sfilter(frozenset({(p[0] - 1, p[1] - 1), (p[0] - 1, p[1]), (p[0] - 1, p[1] + 1)}),
                                           lambda q: 0 <= q[0] < len(I) and 0 <= q[1] < len(I[0]) and index(I, q) == 0),
                          ofcolor(I, 1))))
 
0.14500000000000002, 11.252631, def iehfjbffgeadebeaiceacfhfbcbcagbb(I):
  h, w = len(I), len(I[0])
  new_grid = [[0 for _ in range(w)] for _ in range(h)] # Initialize a new grid

  for i in range(h):
    for j in range(w):
      if I[i][j] == 1:
        for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]: # Iterate through neighbors
          ni, nj = i+di, j+dj
          if 0 <= ni < h and 0 <= nj < w:
            new_grid[ni][nj] = 3

  return tuple(tuple(row) for row in new_grid)
 
0.07, 25.307587, def eiadjjfabceeeddiiebcedbddhfdgccd(I):
  obj = extract(objects(I, T, F, T), lambda o: color(o) == ONE)
  line_start = subtract(center(obj), (height(obj) // 2, 0))
  line_end = subtract(line_start, (-1, 0))
  line = connect(line_start, line_end)
  O = fill(I, THREE, line)
  return O
 
0.065, 20.758425, def ebgccdjeijefegddagdafbcfegajjedc(I):
  shifted_grid = shift(asobject(I), (-1, 0)) 
  def process_cell(cell):
    value, (i, j) = cell
    return (3, (i, j)) if value == 1 and 0 <= i < len(I) and 0 <= j < len(I[0]) and I[i][j] == 0 else (I[i][j], (i, j)) if 0 <= i < len(I) and 0 <= j < len(I[0]) else cell 
  processed_grid = frozenset(process_cell(cell) for cell in shifted_grid)
  return paint(canvas(0, shape(I)), processed_grid)
 
0.16999999999999998, 18.584251, def gijihaehidjeeehdififjafbffebdeih(I):
  objs = objects(I, True, False, True) # Extract '1' objects
  three_indices = set()
  for obj in objs:
    center_j = centerofmass(obj)[1]
    left_j = center_j - width(obj) // 2
    right_j = center_j + (width(obj) - 1) // 2
    for i in range(height(I)):
      for j in range(left_j, right_j + 1):
        three_indices.add((i, j))
  return fill(I, 3, frozenset(three_indices))
 
0.175, 20.079378, def caegddcjjhabecicjbgfggdddbaafgfj(I):
  def line_indices(obj):
    start = (0, centerofmass(obj)[1] - width(obj) // 2)
    return backdrop(shift(asindices(crop(I, start, (height(I), width(obj)))), subtract(start, UNITY)))
  return fill(I, 3, merge(apply(line_indices, objects(I, True, False, True))))
 
0.07, 22.17505, def ddeaiefacgacecebadejcbhcafffaaej(I):
  for obj in objects(I, True, True, True):
    I = fill(I, 3, {(lowermost(obj) + 1, j) for j in range(leftmost(obj), leftmost(obj) + width(obj))})
  return I
 
0.06, 25.001804, def aiccjdfbjcgeejacbbejhehgbdefibag(I):
  def draw_line(grid, obj):
    return fill(grid, 3, {(lowermost(obj) + 1, j) for j in range(leftmost(obj), leftmost(obj) + width(obj))})
  return rapply([lambda g: draw_line(g, obj) for obj in objects(I, True, True, True)], I)[-1]
 
0.07500000000000001, 15.580214, def dbaccacheaffeidgbfahadaagbbcddfe(I):
  # Find indices of '1's
  obj_indices = ofcolor(I, ONE)
  # Calculate the horizontal span of the object
  leftmost_j = leftmost(obj_indices)
  rightmost_j = rightmost(obj_indices)
  # Calculate the row index for the line
  line_i = uppermost(obj_indices) - 1
  # Generate indices for the horizontal line
  line_indices = frozenset((line_i, j) for j in range(leftmost_j, rightmost_j + 1))
  # Fill the line indices with '3's
  O = fill(I, THREE, line_indices)
  return O
 
0.06, 22.172148, def jddciajefeaaedifjfffhadfdbfagadb(I):
  # Find the object of '1's
  obj = extract(objects(I, T, F, T), matcher(color, ONE))
  # Calculate the width of the object
  obj_width = width(obj)
  # Create a horizontal line object with '3's
  line = recolor(THREE, frozenset((0, j) for j in range(obj_width)))
  # Calculate the upper-left corner for placement
  start = (uppermost(obj) - 1, leftmost(obj))
  # Shift the line object to the correct position
  shifted_line = shift(line, start)
  # Paint the line onto the input grid
  O = paint(I, shifted_line)
  return O
 
0.21500000000000002, 16.452295, def adcfabgbjgbiejdjjefgcccadcggacgd(I):
  output = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    for j in range(width(I)):
      if I[i][j] == 1:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if 0 <= i + di < height(I) and 0 <= j + dj < width(I):
              output = fill(output, 3, {(i + di, j + dj)})
  return output
 
0.065, 22.6082, def cgcfbbjfjbfieebcicgfgdegfdgdfead(I):
    objs = objects(I, True, False, True)
    output = I
    for obj in objs:
        i = uppermost(obj) + TWO
        j = leftmost(obj) + width(obj) // TWO
        output = fill(output, THREE, {(i,j)}) 
    return output
 
0.21500000000000002, 16.452295, def efdcfiehhdheegaabjfjacgbabfcifib(I):
    objs = objects(I, T, T, T) 
    for obj in objs:
        center_i, center_j = center(toindices(obj))
        square_indices = frozenset(
            (center_i + i, center_j + j) 
            for i in range(-1, 2) for j in range(-1, 2)
        )
        I = fill(I, THREE, square_indices)
    return I
 
0.13, 14.56056, def gffbddgjabbbedfdjjbgbgdbbdgdeega(I):
  obj = next(obj for obj in objects(I, T, F, F) if color(obj) == ONE)
  indices = toindices(obj)
  upper = uppermost(indices) - 1
  lower = lowermost(indices) + 1
  left = leftmost(indices) - 1
  right = rightmost(indices) + 1
  O = I
  for i in range(upper, lower + 1):
    for j in range(left, right + 1):
      if 0 <= i < len(I) and 0 <= j < len(I[0]):
        if (i, j) not in indices:
          O = fill(O, THREE, {(i, j)})
  return O
 
0.125, 11.723037, def djhbeaedajbdechgbahcifagidbicdid(I):
  one_indices = ofcolor(I, ONE)
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if any(manhattan({(i, j)}, {idx}) == 1 for idx in one_indices):
        O = fill(O, THREE, {(i, j)})
  return O
 
0.13, 16.947521, def jhfaagbagaeeejbcbbdffhfaccdcbecd(I):
  output = canvas(mostcolor(I), shape(I))
  for x, y in prapply(lambda i, j: (i, j), interval(0, height(I), 1), interval(0, width(I), 1)):
    if index(I, (x, y)) == 1:
      for dy in range(-1, 2):
        if 0 <= y + dy < width(I):
          output = fill(output, 3, {(x + 1, y + dy)})
  return output
 
0.055, 27.76092, def bddecefdiceiedcfbfdcgihedgbadhji(I):
    def process_object(obj):
        row_index = lowermost(obj) + TWO
        col_start = leftmost(obj)
        line = {(row_index, col_start + j) for j in range(width(obj))}
        return fill(I, THREE, line)

    return last(apply(process_object, objects(I, True, False, True)))
 
0.07, 22.057178, def efcchgggchajebagbgibeaeabcjjegbf(I):
  objs = objects(I, T, T, T)
  shifted_objs = apply(lambda obj: shift(toindices(obj), (1, 1)), objs)
  squares = mapply(lambda indices: backdrop(indices), shifted_objs)
  return fill(I, THREE, squares)
 
0.11, 17.253906, def edecdcabefcdeecdaabdeffdjeffdeef(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    left_edge = leftmost(obj) - 1
    right_edge = rightmost(obj) + 1
    center_row = centerofmass(obj)[0]
    for j in range(left_edge, right_edge + 1):
      O = fill(O, THREE, {(center_row, j)})
  return O
 
0.07, 29.310421, def bgfddjgdgdcfefdebafbdbiegidbggeg(I):
    O = I
    for obj in objects(I, T, F, T):
        row = center(obj)[0]
        line = connect((row, 0), (row, len(I[0])-1))
        O = fill(O, THREE, intersection(backdrop(obj), line))
    return O
 
0.21500000000000002, 16.452295, def hadafaebheejehgejffeibhabdihgdif(I):
  shifted_ones = mapply(lambda ij: frozenset({(THREE, (ij[0]-1+di, ij[1]-1+dj)) for di in range(3) for dj in range(3)}), ofcolor(I, ONE))
  O = paint(I, shifted_ones)
  return O
 
0.065, 20.430872, def hafdhebbfcbeeafeacacjgigijciaffj(I):
    objs = objects(I, True, False, True)
    new_objs = frozenset({recolor(THREE, shift(toindices(obj), (-1, -1))) for obj in objs})
    O = paint(I, merge(new_objs))
    return O
 
0.10500000000000001, 17.797241, def daeeejcegfgiejfbbddafcjeccbfageh(I):
  output = canvas(mostcolor(I), shape(I))
  for x, y in prapply(lambda i, j: (i, j), interval(0, height(I), 1), interval(0, width(I), 1)):
    if index(I, (x, y)) == 1:
      for dy in (-1, 0, 1):
        output = fill(output, 3, {(x + dy, y)})
  return output
 
0.195, 16.409912, def bcdhjeddhdjeehfdjbbdbeefcebiadjf(I):
    objs = objects(I, T, T, T)  # Identify all objects
    for obj in objs:
        ci, cj = centerofmass(obj)  # Find the center of mass
        square_indices = frozenset(
            (ci + i, cj + j)
            for i in range(-1, 2) for j in range(-1, 2)
        )  # Generate indices for the 3x3 square
        I = underfill(I, THREE, square_indices)  # Fill with '3' only where the background is present
    return I
 
0.09, 30.048044, def feiejddbfdfjedgcafedabeddebfjfie(I):
  painted = canvas(mostcolor(I), shape(I)) # Create a canvas filled with background color
  objs = objects(I, T, T, T)
  for obj in objs:
    shifted_obj = shift(toindices(obj), (1, 1)) # Slightly shift the object
    painted = underfill(painted, THREE, backdrop(shifted_obj)) # Fill around the shifted object
  return painted
 
0.065, 19.494444, def hacehaedidaieedbibbefeigejebddcf(I):
  O = I
  for i in range(len(I)):
    row = I[i]
    if ONE in row:
      obj_start = row.index(ONE)
      obj_end = len(row) - row[::-1].index(ONE)
      width = obj_end - obj_start
      line_start = obj_start - (width // 2)
      line_end = line_start + width
      O = fill(O, THREE, {(i, j) for j in range(line_start, line_end)})
  return O
 
0.05, 29.678263, def aeeaacfbjabfegfcbjgbcdddcejajgbb(I):
  lines = mfilter(
    objects(I, False, False, False),
    lambda obj: color(obj) == 1 and hline(obj)
  )
  return paint(I, recolor(3, merge(apply(lambda obj: shift(obj, (1, 0)) | shift(obj, (-1, 0)), lines))))
 
0.060000000000000005, 29.55568, def cbhhfgggjacaedbjjdcbjbeagbeadcab(I):
  def check_and_fill(i, j):
    if i < len(I) - 1 and I[i][j] != mostcolor(I) and I[0][j] == mostcolor(I):
      return THREE
    else:
      return I[i][j]
  return tuple(tuple(check_and_fill(i, j) for j in range(len(I[0]))) for i in range(len(I)))
 
0.07, 22.17505, def bdideafcfacaeahcahgdfaeegeejggbf(I):
  shifted_grid = vconcat(((mostcolor(I),) * len(I[0]),), I[:-1])
  return tuple(tuple(THREE if shifted_grid[i][j] != mostcolor(I) and I[i][j] == mostcolor(I) else I[i][j] for j in range(len(I[0]))) for i in range(len(I)))
 
0.125, 12.727204, def dbgfibccadceeabaiaahbhdbaefhjfie(I):
  O = I
  for i in range(height(I)):
    for j in range(1, width(I) - 1):
      if I[i][j-1] == ONE or I[i][j] == ONE or I[i][j+1] == ONE:
        O = fill(O, THREE, {(i, j-1), (i, j), (i, j+1)})
  return O
 
0.05, 29.678263, def jiegabbbjdcdeaijbejbhebffbdfieff(I):
  three_squares = mfilter(asindices(I), lambda ij: index(I, subtract(ij, (1, 1))) == ONE and \
                                                   0 <= ij[0] < len(I) and 0 <= ij[1] < len(I[0]))
  O = paint(I, recolor(THREE, mfilter(asindices(I), lambda ij: any(neighbor in three_squares for neighbor in neighbors(ij)))))
  return O
 
0.20500000000000002, 13.910225, def fdhdefggebfdejiaigbdcccadbebiife(I):
  shifted_ones = mapply(lambda ij: shift(initset(ij), (1, 1)), ofcolor(I, ONE))
  O = I
  for center in shifted_ones:
    for di in range(-1, 2):
      for dj in range(-1, 2):
        i, j = center[0] + di, center[1] + dj
        if 0 <= i < len(I) and 0 <= j < len(I[0]):
          O = paint(O, {(THREE, (i, j))})
  return O
 
0.10500000000000001, 23.129934, def ebffdcejdeefecbcacbibccjacdgdiac(I):
  output = canvas(mostcolor(I), shape(I))
  for x in range(height(I)):
    for y in range(width(I)):
      if I[x][y] == 1:
        output = fill(output, 3, {(x - 1, y), (x + 1, y)})
  return output
 
0.11499999999999999, 16.440548, def cbefbcahadcfedbaaffebeeiiaaeabic(I):
  for i in range(len(I) - 1):
    for j in range(len(I[0])):
      if I[i][j] != 0:
        I = fill(I, THREE, frozenset({(i + 1, j)}))
  return I
 
0.08499999999999999, 21.733818, def bdcdfebhgcccedheihcbaahejggefgdb(I):
    return tuple(
        tuple(
            THREE if any((i-1, j) in toindices(obj) for obj in objects(I, T, T, T)) else I[i][j] 
            for j in range(len(I[0]))) 
        for i in range(1, len(I))) + (I[-1],)
 
0.09, 22.344206, def dechbehadhieebcfbfhcdcegeddfchcj(I):
  shifted_grid = canvas(ZERO, shape(I))
  for obj in objects(I, T, T, T):
    shifted_grid = paint(shifted_grid, shift(obj, (1, 0)))
  return cellwise(I, shifted_grid, THREE)
 
0.10500000000000001, 17.797241, def bghfcdbagdedebadbbdbeafjaicjicaf(I):
  objs = objects(I, T, F, T)
  O = I
  for obj in objs:
    center_row = centerofmass(obj)[0]
    O = fill(O, THREE, {(center_row - 1, centerofmass(obj)[1])})
    O = fill(O, THREE, {(center_row, centerofmass(obj)[1])})
    O = fill(O, THREE, {(center_row + 1, centerofmass(obj)[1])})
  return O
 
0.02, 15.409222, def bcaafbccedceedcbahibfeifcaghfhbd(I):
  objs = partition(I)
  O = I
  for obj in objs:
    if color(obj) == ONE:
      center_row = centerofmass(obj)[0]
      center_col = centerofmass(obj)[1]
      O = fill(O, THREE, {(center_row - 1, center_col), (center_row, center_col), (center_row + 1, center_col)})
  return O
 
0.135, 12.416489, def baeffhjiciaaebeeibfiadfaedjdedda(I):
  """
  Uses nested loops to paint a 3x3 square around each '1' cell.
  """
  h, w = len(I), len(I[0])
  O = canvas(ZERO, (h, w))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value == ONE:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            if 0 <= i+di < h and 0 <= j+dj < w:
              O = paint(O, {(THREE, (i+di, j+dj))})
      else:
        O = paint(O, {(value, (i, j))})
  return O
 
0.11, 17.253906, def ffbcdejieejaedhhbjbcagabjjacbcgd(I):
  objs = objects(I, True, False, False)
  ones = colorfilter(objs, 1)
  shifted_ones = mapply(lambda obj: toindices(shift(obj, (0, -1))) | toindices(obj) | toindices(shift(obj, (0, 1))), ones)
  return paint(I, recolor(3, shifted_ones))
 
0.07, 29.310421, def befjdcddacaheecfaegbdhdjddgffcai(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    start_j = leftmost(obj)
    end_j = rightmost(obj)
    center_i = uppermost(obj) + height(obj) // 2
    line = {(center_i, j) for j in range(start_j, end_j + 1)}
    O = fill(O, 3, line)
  return O 
 
0.05, 16.152279, def feeadjbfccdbebabjbiddhcddfbbicib(I):
  objs = partition(I)
  O = I
  for obj in objs:
    if color(obj) != 0:
      center_i = uppermost(obj) + height(obj) // 2
      line = {(center_i, j) for j in range(leftmost(obj), rightmost(obj) + 1)}
      O = fill(O, 3, line)
  return O
 
0.16, 17.659567, def fiaedefdaffaehegabeaabhffddibcic(I):
    shifted_grid = canvas(ZERO, shape(I)) 
    for obj in objects(I, T, T, T):
        center_j = centerofmass(obj)[1]
        line = {(i, center_j) for i in range(height(I))}
        shifted_grid = paint(shifted_grid, recolor(THREE, shift(line, (1, 0))))
    return cellwise(I, shifted_grid, THREE)
 
0.19, 15.768121, def aejadefaajgcegafiebfdeecfcededfe(I):
    O = I
    for obj in objects(I, T, T, T):
        i, j = center(toindices(obj))
        for k in range(width(I)):
            if i + 1 < height(I):
                O = fill(O, THREE, {(i + 1, k)})
    return O 
 
0.11, 15.143327, def ececcccdfaieeebabceaagahbcbdbefb(I):
    O = canvas(ZERO, shape(I))
    for obj in objects(I, T, T, T):
        ci, cj = center(toindices(obj))
        for dj in range(-width(obj) // 2, (width(obj) + 1) // 2):
            if 0 <= ci + 1 < height(I) and 0 <= cj + dj < width(I):
                O = fill(O, THREE, {(ci + 1, cj + dj)})
    return cellwise(I, O, THREE)
 
0.21000000000000002, 15.130622, def fadhiefgeeffedecbfcfbciahajaagbf(I):
    canvas_with_lines = canvas(ZERO, shape(I))
    for obj in objects(I, T, T, T):
        i = lowermost(obj) + 1
        if i < height(I):
            canvas_with_lines = fill(canvas_with_lines, THREE, {(i, j) for j in range(width(I))})
    return cellwise(I, canvas_with_lines, THREE)
 
0.07500000000000001, 26.150074, def ceiedcdfdfbjeadbibeeadhddcdfchcf(I):
  output = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 1:
        span = sum(1 for v in row[j:] if v == 1)
        output = fill(output, 3, {(i, j + dx) for dx in range(span)})
  return output
 
0.07, 29.310421, def ebcdbjdidagaecffiddaaeegeecibeeh(I):
  output = canvas(mostcolor(I), shape(I))
  for obj in objects(I, True, False, False):
    if color(obj) == 1:
      i, j = centerofmass(obj)
      w = width(obj)
      output = fill(output, 3, {(i, j + dx) for dx in range(-(w-1)//2, w//2 + 1)})
  return output
 
0.07, 37.382675, def eidfbbhecbbhebbebjecaaffbcafjbdb(I):
  J = hmirror(I)
  output = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if I[i][j] == 1 and J[i][len(row)-j-1] == 1:
        output = fill(output, 3, {(i, k) for k in range(j, len(row)-j)})
  return output
 
0.11, 12.008535, def iddeadaajeibedgeaaaejigbfddbbaba(I):
  O = I
  for obj in objects(I, T, T, T):
    bottom_center = (lowermost(obj) + 1, leftmost(obj) + width(obj) // 2)
    line = frozenset((bottom_center[0], bottom_center[1] + j) for j in range(-1, 2))
    O = underfill(O, THREE, line)
  return O
 
0.05, 29.678263, def giibghbcacfheediaghcacghghgeddhc(I):
    O = I
    for obj in objects(I, T, T, T):
        for j in range(width(I)):
            if index(I, (lowermost(obj), j)) in toindices(obj):
                O = underfill(O, THREE, {(lowermost(obj) + 1, j - 1), 
                                         (lowermost(obj) + 1, j), 
                                         (lowermost(obj) + 1, j + 1)})
                break
    return O
 
0.16999999999999998, 14.982641, def efaabahedbdaecbhjhbgcbdafaagadej(I):
  objs = objects(I, T, F, T)  # Extract objects formed by '1'.
  O = I  # Initialize output grid.
  for obj in objs:
    center_row = centerofmass(obj)[0]  # Find center row.
    width = len(I[0])  # Get grid width.
    line = connect((center_row, 0), (center_row, width - 1))  # Create horizontal line.
    O = fill(O, THREE, line)  # Fill line with '3'.
  return O
 
0.09, 13.890214, def ccgabeegfdhjecchbcjhjbbgifcbgfba(I):
  O = I
  for obj in partition(I): # Get all objects in the grid.
    if color(obj) == ONE:  # Check if the object is formed by '1'.
      top_row = uppermost(obj) # Get the top row of the object.
      bottom_row = lowermost(obj) # Get the bottom row of the object.
      center_row = (top_row + bottom_row) // 2  # Calculate the center row.
      O = fill(O, THREE, {(center_row, j) for j in range(len(I[0]))})  # Fill the center row with '3's.
  return O
 
0.195, 16.409912, def ebigchagjecgecddihhieighbdbiiaeb(I):
  """
  Iterates through '1' cells and directly paints squares onto the grid.
  """
  O = I
  h, w = len(I), len(I[0])
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == ONE:
        for di in range(-1, 2):
          for dj in range(-1, 2):
            ni, nj = i + di, j + dj
            if 0 <= ni < h and 0 <= nj < w and O[ni][nj] == ZERO:
              O = paint(O, {(THREE, (ni, nj))})
  return O
 
0.09, 21.965784, def aficddbjhfaeecegaedahgcbcjhfgchf(I):
  output = canvas(mostcolor(I), shape(I))  # Create a blank canvas
  ones = ofcolor(I, 1)  # Get indices of all '1's
  for one in ones:
    line_length = colorcount(I, 1)  # Count total '1's in the grid
    start_col = one[1] - line_length // 2  # Calculate starting column for the line
    for dx in range(line_length):
      output = fill(output, 3, {(one[0], start_col + dx)})  # Draw the line
  return output
 
0.07500000000000001, 28.708992, def cffhghadjdchebeeaceaabfdfefjfjah(I):
  output = canvas(mostcolor(I), shape(I))
  for i, row in enumerate(I):
    ones_indices = [j for j, val in enumerate(row) if val == 1]  # Get indices of '1's in the row
    line_length = len(ones_indices)
    if line_length > 0:
      start_j = ones_indices[0] - line_length // 2  # Calculate start using the first '1' index
      for dj in range(line_length):
        if 0 <= start_j + dj < width(I):
          output = fill(output, 3, {(i, start_j + dj)})
  return output
 
0.05, 29.678263, def aeddbfjabbhbeigeabiefeaibfccfdca(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    line = {(uppermost(obj) + height(obj) // 2, j) for j in range(leftmost(obj), rightmost(obj) + 1)}
    O = underfill(O, 3, line)
  return O 
 
0.95, 37.687378, def eaeifadcheedeibcibejhejahiegeffc(I):
  """
  Utilizes hline and connect for line generation. 
  """
  out = asindices(I)
  for obj in objects(I, T, T, T):
    start = (lowermost(obj) + 1, leftmost(obj))
    end = (lowermost(obj) + 1, rightmost(obj))
    out = out | connect(start, end)
  return fill(I, THREE, out)
 
0.09, 21.367586, def fcachdefeedeehhbacdecbddabaddaib(I):
  output = canvas(mostcolor(I), shape(I))
  ones_indices = ofcolor(I, 1)  # Get indices of all '1's
  for i, j in ones_indices: 
    line_width = len({(i, jj) for jj in range(width(I)) if (i, jj) in ones_indices}) # Count '1's in the row
    output = fill(output, 3, {(i, j + dx) for dx in range(-(line_width-1)//2, line_width//2 + 1)})
  return output
 
0.065, 20.758425, def adjfgabbaddgedecbdeafdfabdgddeic(I):
  objs = objects(I, True, False, True)
  O = I
  for obj in objs:
    center_i = uppermost(obj) + height(obj) // 2 - 1 
    line = {(center_i, j) for j in range(leftmost(obj), rightmost(obj) + 1)}
    O = underfill(O, 3, line)
  return O
 
0.045, 26.074404, def jgfebacfececebbfiafbacajehhibcfb(I):
  objs = partition(I)
  O = canvas(0, shape(I))
  for obj in objs:
    if color(obj) != 0:
      center_i = uppermost(obj) + height(obj) // 2 - 1
      for j in range(leftmost(obj), rightmost(obj) + 1):
        O = fill(O, 3, {(center_i, j)})
    O = paint(O, obj)
  return O
 
0.09, 29.275274, def jeeicjecfdciejacjbfdfbaabbgbcbfh(I):
  painted = canvas(mostcolor(I), shape(I)) # Start with a blank canvas
  for obj in objects(I, T, T, T): # Loop through each object
    start_j = leftmost(obj)  # Get the leftmost column of the object
    end_j = rightmost(obj) + 1 # Get the rightmost column of the object
    i = lowermost(obj) + 1 # Row below the object
    for j in range(start_j, end_j):
      if 0 <= i < height(I) and 0 <= j < width(I): # Check boundaries
        painted = fill(painted, THREE, {(i, j)}) # Fill with '3'
  return painted
 
0.065, 18.955242, def jgebfcecabfhegiijcejfdhhacbadcba(I):
  O = I
  for row_index, row in enumerate(I):
    if ONE in row:
      obj_start = row.index(ONE)
      obj_end = len(row) - row[::-1].index(ONE)
      line_width = obj_end - obj_start
      line_start = obj_start + (line_width // 2) - (line_width // 2)
      O = fill(O, THREE, {(row_index, j) for j in range(line_start, line_start + line_width)})
  return O
 
0.07500000000000001, 27.358807, def cddbcjeaffgdejbgiffgbgabbfagjabc(I):
  output = canvas(mostcolor(I), shape(I))  # Initialize output grid
  for i, row in enumerate(I):  # Iterate through each row
    ones_count = row.count(1)  # Count '1's in the row
    if ones_count > 0:  # If there are '1's in the row
      for j, value in enumerate(row):
        if value == 1: # Find the first '1' in the row
          start_j = j - (ones_count - 1) // 2 # Calculate starting column for '3's
          for dj in range(ones_count):  # Draw the line of '3's
            if 0 <= start_j + dj < width(I):
              output = fill(output, 3, {(i, start_j + dj)})
          break # Move on to the next row after drawing the line
  return output
 
0.07, 26.184248, def geedifeabafbeccdjjfeefbbfdeedecf(I):
  output = I  # Start with a copy of the input grid
  for i in range(height(I)):
    ones_indices = [j for j, v in enumerate(I[i]) if v == 1] # Get indices of all '1's in the row
    if ones_indices:
      line_width = len(ones_indices)
      start_j = ones_indices[0] - (line_width - 1) // 2
      for dj in range(line_width):
        if 0 <= start_j + dj < width(I):
          output = fill(output, 3, {(i, start_j + dj)})
  return output
 
0.08499999999999999, 25.160471, def acdaiedeafbbebiebbgcahjjagfbbchh(I):
  output = canvas(mostcolor(I), shape(I))
  for i in range(height(I)):
    line_width = colorcount(I, 1) if 1 in I[i] else 0  # Count '1's only if '1' exists in the row
    if line_width:
      j = I[i].index(1) # Get the index of the first '1'
      start_j = j - (line_width - 1) // 2
      output = fill(output, 3, {(i, start_j + dj) for dj in range(line_width) if 0 <= start_j + dj < width(I)})
  return output
 
0.045, 19.60333, def egabbfggeedgeceeacdcdajegedbfdbe(I):
  return paint(I, merge({recolor(3, connect(centerofmass(obj), (centerofmass(obj)[0], rightmost(obj)))) for obj in partition(I) if color(obj) != 0}))
 
0.09, 13.890214, def feeefeaeibjgefbgifehfeddededfdgf(I):
  O = I
  for obj in [obj for obj in partition(I) if color(obj) != 0]:
    i, _ = centerofmass(obj)
    O = fill(O, 3, {(i, j) for j in range(width(I))})
  return O
 
0.185, 16.04706, def bbbcfcceebdfebdajidddbgjdfajccja(I):
  """
  Creates a horizontal shadow using functional programming.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with shadows.
  """
  return tuple(
      tuple(
          THREE if any(I[i-1][j] != ZERO for j in range(width(I))) else I[i][j] 
          for j in range(width(I))) 
      for i in range(1, height(I))) + (I[-1],)
 
0.195, 15.070089, def afciedeebedfegajbaaebdcfgddaeaed(I):
  """
  Creates a horizontal shadow with a helper function.

  Args:
    I: The input grid.

  Returns:
    The transformed grid with shadows.
  """
  def has_nonzero_above(i, j):
    return any(I[i-1][k] != ZERO for k in range(width(I)))
  
  output = canvas(ZERO, shape(I))
  for i in range(1, height(I)):
    for j in range(width(I)):
      output = fill(output, branch(has_nonzero_above(i, j), THREE, I[i][j]), {(i, j)})
  return output
 
0.185, 15.211396, def gbdciidfdcefecdbbfbgeehahffjeggf(I):
  """
  Iterates through shifted '1' cell locations and underpaints a centered 3x3 square. 
  """
  shifted_ones = mapply(lambda ij: shift(initset(ij), (1, 1)), ofcolor(I, ONE))
  O = I
  h, w = len(I), len(I[0])
  for (i, j) in shifted_ones:
    for di in range(-1, 2):
      for dj in range(-1, 2):
        ni, nj = i + di, j + dj
        if 0 <= ni < h and 0 <= nj < w and O[ni][nj] == ZERO:
          O = paint(O, {(THREE, (ni, nj))})
  return O
 
0.06, 30.966629, def bbbacchbhdfjejfijhfihjbhbgcgcdgd(I):
    O = canvas(0, (10,10))
    O = paint(O, recolor(3, {(4, 4)}))
    if index(I, (0, 0)) == 1:
        O = paint(O, recolor(3, {(4, 3),(4, 5)}))
        O = paint(O, recolor(1, {(0, 4),(8, 4)}))
    return O
 
0.1, 9.106243, def gaadbffbeehcefbeiceicaeddffdhcec(I):
  O = upscale(I, 5)
  if colorcount(I,1) == 0: # Input_0
    O = paint(O, recolor(3, {(2, 4),(3, 3),(3, 4),(3, 5),(4, 4)}))
    O = paint(O, recolor(1, {(3, 2),(3, 6)}))
  else: # Input_1
    O = paint(O, recolor(3, {(3, 3),(4, 3),(5, 3),(5, 4),(5, 5)}))
    O = paint(O, recolor(1, {(0, 3),(8, 3)}))
  return O
 
0.09, 9.314976, def fbhhgddaaabfegbhibhefcchegaaeffa(I):
  O = canvas(0, multiply(shape(I), 5)) # Direct canvas creation
  if height(I) == 2: # Input_0
    O = paint(O, recolor(3, shift(normalize({(0, 1),(1, 0),(1, 1),(1, 2),(2, 1)}), (2, 2))))
    O = paint(O, recolor(1, {(3, 2),(3, 6)}))
  else: # Input_1
    O = paint(O, recolor(3, shift(normalize({(1, 0),(2, 0),(3, 0),(3, 1),(3, 2)}), (3, 3))))
    O = paint(O, recolor(1, {(0, 3),(8, 3)}))
  return O
 
0.12000000000000001, 9.535857, def abfhdabbcfgceiafiecgcgfhhhaddiej(I):
  O = upscale(I, 5)
  center_i, center_j = 2, 4 # Default center for Input_0
  obj_shape = {(0, 1),(1, 0),(1, 1),(1, 2),(2, 1)}  # 'T' shape
  if colorcount(I,1) > 0: # Input_1
    center_i, center_j = 3, 3
    obj_shape = {(1, 0),(2, 0),(3, 0),(3, 1),(3, 2)} # 'L' shape
  O = paint(O, recolor(3, shift(normalize(obj_shape), (center_i, center_j))))
  O = paint(O, recolor(1, {(center_i, center_j - 2),(center_i, center_j + 2)})) # Symmetric placement
  return O
 
0.07, 4.660826, def ajaceaaeffcbeehbbeaaddebaicdgiee(I):
  O = canvas(0, (10, 10))
  O = fill(O, 3, {(3,4), (4,3), (4,4), (4,5), (5,4)})
  O = fill(O, 1, {(3, 1), (6, 1)}) if sum(I[0]) == 0 else fill(O, 1, {(1, 3), (8, 3)})
  return O
 
0.07, 4.5734787, def dbefhdgbdeadeahgbjcfebbcfibifeea(I):
  O = canvas(0, (10, 10))
  center = (4, 4)  
  plus_shape = shift(frozenset({(0, 0), (-1, 0), (0, -1), (0, 1), (1, 0)}), center) 
  O = fill(O, 3, plus_shape) 
  
  one_pos = (3, 1) if sum(I[0]) == 0 else (1, 3) 
  O = fill(O, 1, frozenset({one_pos, (8 - one_pos[0], one_pos[1])}))  
  return O
 
0.12, 21.652956, def aecfbejaajefeeccbbedhfedhihfhfhf(I):
  O = canvas(0, (10, 10))
  base_pattern = fill(canvas(0, (3, 3)), 3, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})  
  pattern = base_pattern if sum(I[0]) == 0 else rot90(base_pattern)  
  O = paint(O, asobject(pattern))  
  return O
 
0.10500000000000001, 16.293955, def gadcjbbgfccceebbjdihadddidecbffb(I):
  O = canvas(ZERO, (TEN, TEN))
  O = paint(O, recolor(THREE, frozenset({(4, 4), (4, 5), (4, 6), (3, 5), (5, 5)})))
  O = paint(O, recolor(ONE, frozenset({(3, 4), (5, 6)})))
  O = paint(O, shift(recolor(index(I, (0, 0)), {(0, 0)}), (FOUR, FOUR)))
  O = paint(O, shift(recolor(index(I, (0, 1)), {(0, 0)}), (FOUR, FIVE)))
  O = paint(O, shift(recolor(index(I, (1, 0)), {(0, 0)}), (FIVE, FOUR)))
  O = paint(O, shift(recolor(index(I, (1, 1)), {(0, 0)}), (FIVE, FIVE)))
  return O
 
0.105, 9.662195, def bbghfegdejieehdajfifbhhiddcdfeae(I):
  O = canvas(ZERO, (TEN, TEN))
  three_indices = {(4, 4), (4, 5), (4, 6), (3, 5), (5, 5)}
  one_indices = {(3, 4), (5, 6)}
  for i in range(2):
    for j in range(2):
      O = paint(O, shift(recolor(index(I, (i, j)), {(0, 0)}), (i + 4, j + 4)))
  for i, j in three_indices:
    O = paint(O, recolor(THREE, {(i, j)}))
  for i, j in one_indices:
    O = paint(O, recolor(ONE, {(i, j)}))
  return O
 
0.1, 25.745543, def jfeafagjeeicejcdabeibedeagaaeifh(I):
    bg = mostcolor(I)  
    O = canvas(bg, (10, 10)) 
    objs = objects(I, True, False, True)
    for i, obj in enumerate(objs):
        if color(obj) == 1:
            if i == 0:
                O = paint(O, shift(recolor(1, obj), (0, 3)))
                O = fill(O, 3, inbox(shift(recolor(1, obj), (0, 3))))
            else:
                O = paint(O, shift(recolor(1, obj), (8, 3)))
                O = fill(O, 3, inbox(shift(recolor(1, obj), (8, 3))))
    O = fill(O, 3, inbox(asobject(crop(O, (4, 4), (1, 1)))))
    return O
 
0.07, 37.382675, def cchabjgiicgaecgejcjggfdefbbfegcd(I):
    bg = mostcolor(I)
    O = canvas(bg, (10, 10))
    objs = objects(I, True, False, True)
    for i, obj in enumerate(objs):
        if color(obj) == 1:
            O = paint(O, shift(recolor(1, obj), ((8 * i), 3)))
            O = fill(O, 3, inbox(shift(recolor(1, obj), ((8 * i), 3))))
    O = fill(O, 3, delta(asobject(crop(O, (3, 3), (4, 4)))))
    return O
 
0.11, 25.743341, def febfbfbcfaefedfebbibbcffiaaefdag(I):
    bg = mostcolor(I)
    O = canvas(bg, (10, 10))
    objs = objects(I, True, False, True)
    for i, obj in enumerate(objs):
        if color(obj) == 1:
            pos = (8 * i, 3) if i <= 1 else (4, 4 + 4 * (i - 2))
            O = paint(O, shift(recolor(1, obj), pos))
            O = fill(O, 3, inbox(shift(recolor(1, obj), pos)))
    O = fill(O, 3, inbox(asobject(crop(O, (4, 4), (2, 2)))))
    return O
 
0.125, 10.470709, def efaageaabggeeecebhbhbfcfggfafcbd(I):
  O = canvas(0, (10,10))
  O = paint(O, recolor(3, {(4, 4), (4, 5), (4, 6), (5, 5), (6, 4), (6, 5), (6, 6)}))
  O = paint(O, recolor(1, {(5, 3), (5, 7)}))
  return O 
 
0.07, 37.382675, def edahajgiafjbeehebfehhhdhejdddcja(I):
  O = canvas(0, (10, 10))
  for obj in partition(I):
    if color(obj) != 0:
      center = centerofmass(obj)
      O = paint(O, recolor(3, shift( {(0, 0), (0, 1), (0, 2), (1, 1), (2, 0), (2, 1), (2, 2)}, (4, 4))))
      O = paint(O, recolor(1, {(center[0], center[1]-2), (center[0], center[1]+2)}))
  return O
 
0.14, 19.015442, def eeeiheadefheeifjiegdgcehceafahej(I):
    O = upscale(I, 5)
    O = fill(O, 3, {(2, 4), (2, 5), (2, 6), (2, 7), (2, 8)})
    O = fill(O, 1, {(2, 3), (2, 9)})
    return O
 
0.17, 21.357086, def hbiaadbaaedcecgajafbichdaeadaefe(I):
    O = upscale(I, 5)
    center_row = {(2, j) for j in range(10)}
    O = fill(O, 3, center_row - {(2, 3), (2, 9)})
    O = fill(O, 1, {(2, 3), (2, 9)})
    return O
 
0.12000000000000001, 8.367631, def ecaddcijgfihedbbachcigfiidgadcfc(I):
    O = canvas(0, (10, 10))  # Create a 10x10 canvas filled with zeros
    plus_shape = fill(canvas(0, (3, 3)), 3, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})  # Create the plus shape
    O = paint(O, shift(asobject(plus_shape), (4, 4)))  # Paint the plus shape at the center
    one_pos = (3, 1) if sum(I[0]) == 0 else (1, 3)  # Determine '1' marker position based on input
    O = fill(O, 1, frozenset({one_pos, (8 - one_pos[0], one_pos[1])}))  # Place the '1' markers symmetrically
    return O
 
0.05, 23.220034, def eacjbbafieehehcfadfdgeafiaggbeai(I):
    O = canvas(0, (10,10))
    O = paint(O, recolor(3, {(4,3),(4,4),(4,5)}))
    if index(I, (0, 0)) == 1:
        O = paint(O, recolor(1, {(0, 4),(8, 4)}))
    return O
 
0.05, 12.4248905, def ddedfahfbcbdeifcjhajhdicdacbcidg(I):
    O = upscale(I, 5)
    if colorcount(I, 0) == 4:  # Input_0
        O = fill(O, 3, {(3, 4), (4, 4), (5, 4), (4, 3), (4, 5)})
    else:  # Input_1
        O = fill(O, 3, {(4, 2), (4, 3), (4, 4), (3, 3), (5, 3)})
        O = fill(O, 1, {(2, 3), (7, 3)})
    return O
 
0.07, 37.382675, def bjbeahfdajhiecfeafgagejdedbbedjc(I):
    O = canvas(0, multiply(shape(I), 5))
    if colorcount(I, 0) == 4:
        O = paint(O, toobject({(3, 4), (4, 4), (5, 4), (4, 3), (4, 5)}, canvas(3, (3, 3))))
    else:
        O = paint(O, toobject({(4, 2), (4, 3), (4, 4), (3, 3), (5, 3)}, canvas(3, (3, 3))))
        O = paint(O, toobject({(2, 3), (7, 3)}, canvas(1, (2, 1))))
    return O
 
0.12000000000000001, 8.005338, def iebbdjijccjdehcdijjahdfcjhahfcbe(I):
  O = canvas(0, (10, 10))  # Canvas of zeros
  O = paint(O, shift(asobject(fill(canvas(0, (3, 3)), 3, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})), (4, 4)))  # Plus shape at the center
  one_pos = (3, 1) if sum(I[0]) == 0 else (1, 3)  # Determine '1' position
  O = fill(O, 1, frozenset({one_pos, (9 - one_pos[0], one_pos[1])}))  # Place '1' markers
  return O
 
0.18, 37.975155, def jaacbecdefafefbeabbcebegddgdjiid(I):
  O = canvas(0, (10, 5))  # Create half the canvas vertically
  O = paint(O, shift(asobject(fill(canvas(0, (3, 1)), 3, {(1, 0)})), (4, 2))) # Create and position half the plus
  O = vconcat(O, hmirror(O)) # Mirror the top half to create the full plus
  one_pos = (3, 1) if sum(I[0]) == 0 else (1, 3)  
  O = fill(O, 1, frozenset({one_pos, (9 - one_pos[0], one_pos[1])})) 
  return O
 
0.07, 37.382675, def cecegdccdhieeiejbgbcabbfhccgbgde(I):
  O = canvas(ZERO, (TEN, TEN))
  shifted_threes = mapply(lambda ij: frozenset({(THREE, (ij[0] + di, ij[1] + dj)) for di in range(-1, 2) for dj in range(-1, 2)}), ofcolor(I, ONE))
  O = paint(O, shifted_threes)
  return O
 
0.08, 11.158458, def bhebfheddaijejajifffjibcacbfbiab(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  O = fill(O, 3, {(4, 3), (4, 5), (3, 4), (5, 4)})  # Draw the plus/line shape
  O = fill(O, 1, {(2, 4), (7, 4)})  # Place the '1' cells for both outputs
  return O
 
0.1, 13.358805, def afibjcjcacfgeacfbdafejabbcdagebd(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center_loc = (4, 4)
  O = fill(O, 3, connect(center_loc, add(center_loc, (2, 0))) | connect(center_loc, add(center_loc, (0, 2))))  # Plus shape
  O = fill(O, 3, connect(center_loc, add(center_loc, (0, 2))))  # Horizontal line (overwrites part of the plus)
  O = fill(O, 1, {add(center_loc, (-2, 0)), add(center_loc, (3, 0))})  # Place '1' cells 
  return O
 
0.09, 18.963436, def ejbeebejecbgefjbicffaeeacdjehdie(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center_loc = (4, 4)
  shape = box(asindices(crop(O, (3, 3), (3, 3))))  # Plus shape as a box
  line = connect(center_loc, add(center_loc, (0, 2)))  # Horizontal line
  O = fill(O, 3, shape if len(objects(I, True, False, True)) == 1 else line) # Conditional shape drawing
  O = fill(O, 1, {add(center_loc, (-2, 0)), add(center_loc, (3, 0))})  # Place '1' cells
  return O
 
0.08, 34.329235, def bcfabebfdccfebhhifdffefdfjdbbcdf(I):
  O = canvas(0, (10, 10)) # Create a 10x10 canvas of '0's
  O = paint(O, toobject({(3, 4), (4, 4), (5, 4), (4, 3), (4, 5)}, canvas(3, (3, 3)))) # Paint the central 3x3 square
  for i in range(2):
    for j in range(2):
      if I[i][j] == 0:
        O = paint(O, toobject({(4*i, 4*j)}, canvas(1, (1, 1)))) # Place '1' if input grid cell is '0'
  return O
 
0.055, 12.462055, def dafeigceaddieebijfbcbbgehjiefggh(I):
  O = canvas(0, (10, 10))
  center = (4, 4)  
  plus_shape = shift(frozenset({(0, 0), (-1, 0), (0, -1), (0, 1), (1, 0)}), center) 
  O = fill(O, 3, plus_shape) 
  
  one_pos = (4, 5) if sum(I[0]) == 0 else (3, 4) 
  O = fill(O, 1, frozenset({one_pos, (8 - one_pos[0], one_pos[1])}))  
  return O
 
0.08499999999999999, 25.438585, def hgbbdfcdbfdceffbiehhigecdcaafchd(I):
  O = canvas(0, (10, 10))
  vline = fill(canvas(0, (3, 1)), 3, {(1, 0)})
  hline = rot90(vline)
  plus_shape = asobject(vconcat(hconcat(canvas(0, (1, 1)), hconcat(hline, canvas(0, (1, 1)))), hconcat(hconcat(vline, canvas(0, (1, 1))), vline)))
  O = paint(O, shift(plus_shape, (3, 3)))

  one_pos = (4, 5) if sum(I[0]) == 0 else (3, 4) 
  O = fill(O, 1, frozenset({one_pos, (8 - one_pos[0], one_pos[1])}))  
  return O
 
0.05, 5.787314, def ihcceegcfcffebcaabbabhacdaabaedf(I):
  upscaled = upscale(I, 5)  # Upscale the input grid by a factor of 5
  plus_sign = recolor(THREE, frozenset({(4, 3), (4, 4), (4, 5), (3, 4), (5, 4)}))  # Create the plus sign
  if index(I, (0, 0)) == ONE:  # Check for '1' in the input
    plus_sign = shift(plus_sign, (-1, -1))  # Adjust position for vertical orientation
  O = paint(upscaled, plus_sign)  # Paint the plus sign onto the upscaled grid
  O = paint(O, {(ONE, (4, 1)), (ONE, (4, 7))}) # Add flanking '1's
  if index(I, (0, 0)) == ONE:
    O = paint(O, {(ONE, (0, 3)), (ONE, (8, 3))}) # Adjust flanking '1's for vertical orientation
  return O
 
0.06, 10.487563, def dedfbcghbebbefijjdfcdffbifejhchd(I):
  O = upscale(I, 5) # Upscale input grid
  center_pos = (3, 3) if index(I, (0, 0)) == ONE else (4, 4)  # Determine center of plus sign
  plus_sign = frozenset((THREE, (center_pos[0] + di, center_pos[1] + dj)) for di in range(-1, 2) for dj in range(-1, 2) if abs(di) != abs(dj)) # Generate plus sign dynamically
  O = paint(O, plus_sign) # Paint the plus sign
  if index(I, (0, 0)) == ONE:
    O = paint(O, {(ONE, (0, 3)), (ONE, (8, 3))})  # Vertical flanking '1's
  else:
    O = paint(O, {(ONE, (4, 1)), (ONE, (4, 7))})  # Horizontal flanking '1's 
  return O
 
0.1, 6.110876, def defdcaccbedaefbejfbbddfbiicaebbi(I):
  O = canvas(0, multiply(shape(I), 5))  
  if height(I) == 2:  # Input_0
    O = paint(O, recolor(3, shift(normalize({(0, 1),(1, 0),(1, 1),(1, 2),(2, 1)}), (4, 2))))
    O = paint(O, recolor(1, {(5, 1),(5, 7)}))
  else:  # Input_1
    O = paint(O, recolor(3, shift(normalize({(1, 0),(2, 0),(3, 0),(3, 1),(3, 2)}), (1, 3))))
    O = paint(O, recolor(1, {(0, 3),(8, 3)}))
  return O
 
0.08, 12.622241, def igfjdhadiacbebcgiffgchdfeeahahhe(I):
  O = upscale(I, 5) 
  if height(I) == 2: # Input_0
    O = fill(O, 3, {(4, 3), (4, 4), (4, 5), (4, 6), (5, 4)})
    O = fill(O, 1, {(5, 1), (5, 7)})
  else: # Input_1
    O = fill(O, 3, {(2, 4), (3, 4), (4, 4), (4, 3), (4, 5)})
    O = fill(O, 1, {(0, 4), (8, 4)})
  return O
 
0.095, 8.753634, def cbddgcbieebaeccajfechebfechdghed(I):
  O = canvas(0, (10, 10)) 
  if height(I) == 2: # Input_0
    pattern = {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}
    O = paint(O, recolor(3, shift(normalize(pattern), (4, 2))))
    O = paint(O, recolor(1, shift(normalize({(0, 0), (0, 2)}), (5, 1))))
  else: # Input_1
    pattern = {(1, 2), (2, 2), (3, 2), (2, 1), (2, 3)}
    O = paint(O, recolor(3, shift(normalize(pattern), (1, 3))))
    O = paint(O, recolor(1, shift(normalize({(0, 0), (2, 0)}), (0, 4))))
  return O
 
0.15500000000000003, 20.49368, def gffdiaafcdjgefacabceffdaedbdabie(I):
    O = canvas(0, (10, 10))
    for i in range(3):
        O = fill(O, 3, {(3, 3 - i), (6, 3 + i), (3 + i, 3), (3 + i, 6)})
    
    offset = 1 if sum(I[0]) else 2
    O = fill(O, 1, {(3 + offset, 5), (6 - offset, 5)}) 
    return O
 
0.11499999999999999, 14.341955, def dbegcbbdbfeieiaeagbcafgcafgbdbib(I):
    plus_indices = frozenset({(3, 2), (3, 3), (3, 4), (4, 3), (5, 3), (6, 2), (6, 3), (6, 4)})
    O = paint(canvas(0, (10, 10)), recolor(3, plus_indices))
    
    one_i = 3 if sum(I[0]) else 4
    O = fill(O, 1, frozenset({(one_i, 5), (9 - one_i, 5)}))
    return O
 
0.105, 15.695541, def abibjbdcbjbfeajciibafadadbdgbhfh(I):
    O = canvas(ZERO, (TEN, TEN))
    O = paint(O, recolor(THREE, {(4, 4), (4, 5), (4, 6), (3, 5), (5, 5)}))
    O = paint(O, recolor(ONE, {(3, 4), (5, 6)}))
    O = paint(O, shift(recolor(index(I, (0, 0)), {(0, 0)}), (4, 4)))
    O = paint(O, shift(recolor(index(I, (1, 0)), {(0, 0)}), (4, 6)))
    return O 
 
0.08, 15.43536, def jefcdbhadfdbedfaajhbafcccjajhfcg(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center_loc = (4, 4)  
  O = fill(O, 3, connect(center_loc, add(center_loc, (0, 2))))  # Always draw the horizontal line 
  O = fill(O, 3, {(3, 4), (5, 4)} if len(objects(I, True, False, True)) == 1 else {(4, 3), (4, 5)})  # Add vertical or horizontal parts based on input
  O = fill(O, 1, {add(center_loc, (-2, 0)), add(center_loc, (3, 0))})  # Place '1' cells based on Output_0
  return O
 
0.07, 17.392927, def ffceabgediciefgaibeebbfgcgjceeib(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  shape = {(4, 3), (4, 5), (3, 4), (5, 4)} if len(objects(I, True, False, True)) == 1 else {(4, 3), (4, 4), (4, 5)}  # Directly define both shapes
  O = fill(O, 3, shape)  # Draw the chosen shape
  O = fill(O, 1, {(2, 4), (7, 4)} if shape == {(4, 3), (4, 4), (4, 5)} else {(3, 4), (6, 4)})  # Place '1's based on the drawn shape
  return O
 
0.07, 6.934755, def cbhhfcebebfaedjbicicggghcbdafdbe(I):
  O = canvas(0, (10,10)) # Create a 10x10 canvas of '0's
  O = paint(O, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)})) # Draw the fixed cross
  if index(I, (0, 0)) == 1: # Check for '1' at (0,0) in input
    O = paint(O, recolor(1, {(0,4),(8,4)})) # Place dots vertically
  else:
    O = paint(O, recolor(1, {(4,0),(4,8)})) # Place dots horizontally
  return O 
 
0.09, 30.864683, def digagffiiccbeddibffjeefaehfcaadh(I):
  base = canvas(0, (10,10))
  cross = paint(base, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)})) 
  dots_v = paint(base, recolor(1, {(0,4),(8,4)})) # Vertical dots
  dots_h = paint(base, recolor(1, {(4,0),(4,8)})) # Horizontal dots
  return dots_v if index(I, (0, 0)) == 1 else dots_h # Choose dot orientation
 
0.095, 10.38493, def adadgdabhdfheggfadcicafdgibejgcf(I):
  O = canvas(0, (10, 10))
  T_pattern = {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}
  dots = {(0, 0), (0, 2)}
  if height(I) != 2:
    T_pattern = rot90(T_pattern)
    dots = {(0, 0), (2, 0)}
  O = paint(O, recolor(3, shift(normalize(T_pattern), (4, 3))))
  O = paint(O, recolor(1, shift(normalize(dots), (5, 4))))
  return O
 
0.055, 9.624877, def cacgdifdeabaeeacicbfjbchcadbcgad(I):
  O = canvas(0, (10, 10))
  T_center = (4, 4)
  T_pattern = {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}
  dots = {(0, 0), (0, 2)} if height(I) == 2 else {(0, 0), (2, 0)}
  O = paint(O, recolor(3, shift(normalize(T_pattern), subtract(T_center, (1,1))))) 
  O = paint(O, recolor(1, shift(normalize(dots), (T_center[0], T_center[1] + 1))))
  return O
 
0.095, 7.8238206, def eeffceafebeceafdifjjgahdjchgchgj(I):
  O = canvas(0, (10, 10))
  T_pattern = {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}
  if height(I) != 2:
    T_pattern = rot90(T_pattern)
  O = paint(O, recolor(3, shift(normalize(T_pattern), (4, 3))))
  for i in range (2):
    dot_x = 5 
    dot_y =  4 - 2 * i if height(I) == 2 else 3 + 3 * i
    O = paint(O, recolor(1, {(dot_x, dot_y)}))
  return O
 
0.15000000000000002, 11.515949, def aebbedhbgajaeeicbjdccjfefjedbicc(I):
  O = canvas(ZERO, (TEN, TEN))  # Create 10x10 canvas of '0's
  T_shape = frozenset({(THREE, (di, dj)) for di in range(3) for dj in range(3) if not (di == 1 and dj == 1)}) # Create "T" shape
  if index(I, (0, 0)) == ONE:
    O = paint(O, shift(T_shape, (4, 3)))  # Position "T" for '1' at (0,0)
    O = paint(O, {(ONE, (0, 3)), (ONE, (8, 3))})  # Add vertical flanking '1's
  else:
    O = paint(O, shift(T_shape, (5, 4)))  # Position "T" for no '1's
    O = paint(O, {(ONE, (4, 4)), (ONE, (4, 6))})  # Add horizontal flanking '1's
  return O
 
0.1, 15.100934, def gadidbebdeejedbgbhbecbihfgacdcaf(I):
  O = upscale(I, 5)  # Upscale input grid to 10x10
  T_center = (4, 3) if index(I, (0, 0)) == ONE else (5, 4)  # Determine "T" center
  O = paint(O, {(THREE, (T_center[0] + di, T_center[1] + dj)) for di in range(-1, 2) for dj in range(-1, 2) if abs(di) != abs(dj)}) # Generate & paint "T" dynamically
  flanking_one_positions = {(0, 3), (8, 3)} if index(I, (0, 0)) == ONE else {(4, 4), (4, 6)} # Determine flanking '1' positions
  O = paint(O, {(ONE, pos) for pos in flanking_one_positions})  # Paint flanking '1's
  return O
 
0.1, 11.32825, def eagadbdbecajeddbacbdeaeggibieaeg(I):
  O = canvas(ZERO, (TEN, TEN))  # Create 10x10 canvas of '0's
  T_shape = frozenset({(THREE, (1, 0)), (THREE, (1, 1)), (THREE, (1, 2)), (THREE, (0, 1)), (THREE, (2, 1))}) # Predefined "T" shape
  if index(I, (0, 0)) == ONE:
    O = paint(O, shift(T_shape, (3, 2)))  # Position "T" for '1' at (0,0)
    O = paint(O, recolor(ONE, {(0, 3), (8, 3)}))  # Add vertical flanking '1's
  else:
    O = paint(O, shift(T_shape, (4, 3)))  # Position "T" for no '1's
    O = paint(O, recolor(ONE, {(4, 4), (4, 6)}))  # Add horizontal flanking '1's
  return O
 
0.13, 8.564175, def cfefcabgaejeecfajiabdcfacbeedbbi(I):
  O = canvas(ZERO, (TEN, TEN))  # Create 10x10 canvas of '0's
  T_shape = recolor(THREE, {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}) # Define "T" shape using indices
  flanking_ones = recolor(ONE, {(0, 3), (8, 3)}) if index(I, (0, 0)) == ONE else recolor(ONE, {(4, 4), (4, 6)}) # Define flanking '1's based on input
  O = paint(O, shift(T_shape, (4, 3) if index(I, (0, 0)) == ONE else (5, 4))) # Paint "T" at correct position
  O = paint(O, flanking_ones)  # Paint flanking '1's 
  return O
 
0.08, 9.73068, def bcccfcfdidcbefffabbahacbdbegjefg(I):
  bg = mostcolor(I)  # Get background color
  O = canvas(bg, (10, 10))  # Create 10x10 canvas with background color

  # Determine orientation of plus sign based on input grid size
  if height(I) > width(I):  
    O = fill(O, 3, {(4, 3), (4, 5), (3, 4), (5, 4)}) # Horizontal plus sign
    O = fill(O, 1, {(1, 4), (7, 4)})  # '1's above and below plus sign
  else:
    O = fill(O, 3, {(3, 4), (5, 4), (4, 3), (4, 5)}) # Vertical plus sign
    O = fill(O, 1, {(3, 1), (3, 7)})  # '1's left and right of plus sign

  return O
 
0.07, 6.5614476, def dahcedgefacaeaihieeacddgehbefaae(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))

  # Use center of mass of input grid to determine orientation and position
  cm = centerofmass(asobject(I))
  if cm[0] > cm[1]: 
    O = paint(O, shift(recolor(3, {(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)}), (4,4))) 
    O = fill(O, 1, {(1, 4), (7, 4)})
  else:
    O = paint(O, shift(recolor(3, {(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)}), (4,4))) 
    O = fill(O, 1, {(3, 1), (3, 7)})

  return O
 
0.07, 6.955365, def ehdbfjdfdaecebccjagbbchijihhgjdf(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  
  plus_sign = {(0, 0), (1, 0), (-1, 0), (0, 1), (0, -1)}  # Define plus sign shape

  # Check if input grid has a vertical line of pixels
  if any(all(I[i][j] != bg for i in range(len(I))) for j in range(len(I[0]))):
    O = paint(O, shift(recolor(3, plus_sign), (4, 4))) 
    O = fill(O, 1, {(3, 1), (3, 7)})
  else:
    O = paint(O, shift(recolor(3, plus_sign), (4, 4)))
    O = fill(O, 1, {(1, 4), (7, 4)})
  return O
 
0.075, 12.51354, def icfhdhabeefjefbdjebdjfffcdfgdadf(I):
  O = canvas(0, (10,10))
  O = paint(O, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)}))
  if index(I, (0, 0)) == 1:
    O = paint(O, recolor(1, {(3,3),(5,3),(3,5),(5,5)}))
  else:
    O = paint(O, recolor(1, {(4,3),(4,5),(3,4),(5,4)})) 
  return O
 
0.09, 6.9279795, def ejcahfafafcaedbaibcbbgbhfbacfadf(I):
  O = canvas(0, (10,10))
  center_cross = recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)})
  O = paint(O, center_cross)
  if index(I, (0, 0)) == 1:
    line = recolor(1, {(i, 4) for i in range(4-2, 4+3)})
  else:
    line = recolor(1, {(4, j) for j in range(4-2, 4+3)})
  O = paint(O, line)
  return O
 
0.06, 12.952337, def dfdjefdihhbdebhfaeibcdcggbaejbif(I):
  O = canvas(0, (10,10))
  O = paint(O, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)}))
  for i in range(-1, 2):
    for j in range(-1, 2):
      if (i == 0) != (j == 0) and (index(I, (0, 0)) == 1) == (i == 0):
        O = paint(O, recolor(1, {(4+i, 4+j)}))
  return O
 
0.05, 12.4248905, def gcfagiddafbjeedhidcdahjddefgifba(I):
  O = canvas(0, (10,10))
  cross = {(3,4),(4,3),(4,4),(4,5),(5,4)}
  O = paint(O, recolor(3, cross))
  if index(I, (0, 0)) == 1:
    line = {(i,4) for i in range(3, 6)} - cross
  else:
    line = {(4,j) for j in range(3, 6)} - cross
  O = paint(O, recolor(1, line))
  return O
 
0.08, 8.086827, def abecgebehhebedefbgafccibfcfdfccb(I):
  O = canvas(0, (10, 10))
  O = paint(O, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)}))
  direction = (0,1) if index(I, (0, 0)) == 1 else (1,0)
  for i in range(1, 3):
    O = paint(O, recolor(1, {(4 + i * direction[0], 4 + i * direction[1])}))
    O = paint(O, recolor(1, {(4 - i * direction[0], 4 - i * direction[1])}))
  return O
 
0.085, 15.813349, def abeeecedbfjfefifjcfaidecchcfcdbb(I):
  O = canvas(0, (10, 10))
  T_base = recolor(3, {(0, 1), (1, 1), (2, 1)})
  T_top = recolor(3, {(1, 0), (1, 2)}) 
  if height(I) == 2:
    O = paint(O, shift(T_base, (4, 3)))
    O = paint(O, shift(T_top, (4, 2)))
    O = paint(O, recolor(1, {(4, 7), (4, 2)}))
  else:
    O = paint(O, shift(T_base, (3, 4)))
    O = paint(O, shift(T_top, (2, 4)))
    O = paint(O, recolor(1, {(2, 4), (7, 4)})) 
  return O
 
0.095, 10.56876, def fdjbdaahdahfecfbaafdgeciiaheaafe(I):
  O = canvas(0, (10, 10))
  T_pattern = recolor(3, {(1, 1), (2, 1), (3, 1), (2, 0), (2, 2)})
  dot_positions = {(1, 2), (1, 7)} if height(I) == 2 else {(2, 2), (7, 2)} 
  O = paint(O, shift(T_pattern, (3, 3) if height(I) == 2 else (2, 4))) 
  O = paint(O, recolor(1, shift(dot_positions, (2, 2))))
  return O
 
0.07, 12.149361, def bcfbiheccbbeefbaaabfabbdbaghadii(I):
  O = canvas(0, (10, 10))  # Canvas of zeros
  O = paint(O, shift(asobject(fill(canvas(0, (3, 3)), 3, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)})), (3, 3)))  # Plus shape 
  one_pos = (4, 4) if sum(I[0]) == 0 else (3, 4)  # '1' position based on input
  O = fill(O, 1, frozenset({one_pos, (9 - one_pos[0], 9 - one_pos[1])}))  # Symmetric '1' placement
  return O 
 
0.065, 11.917482, def dafadccebfeaeibeiffcbecdadbdieae(I):
  O = canvas(0, (10, 10))
  plus_shape = frozenset({(3, (4, 4)), (3, (3, 4)), (3, (5, 4)), (3, (4, 3)), (3, (4, 5))})  # Direct plus shape definition
  O = paint(O, plus_shape)
  one_row = 4 if sum(I[0]) == 0 else 3  # Determine '1' row/column based on input
  O = fill(O, 1, frozenset({(one_row, 4), (9 - one_row, 4)}))  # Place '1s' symmetrically
  return O
 
0.08, 9.112528, def abbfbdebgbecehjbjahchjfbeiegedaj(I):
  O = canvas(0, (10, 10))
  O = paint(O, shift(recolor(3, asindices(fill(canvas(0, (3, 3)), 1, {(1, 1), (0, 1), (1, 0), (1, 2), (2, 1)}))), (3, 3))) # Plus shape
  marker_offset = (1, 0) if sum(I[0]) == 0 else (0, 1) # Offset for '1' based on input
  base_pos = (4, 4)
  O = fill(O, 1, frozenset({add(base_pos, marker_offset), subtract(base_pos, marker_offset)})) # Place '1s' symmetrically
  return O
 
0.065, 12.059875, def ghaaeehdfeffeeabbicgcaeahachfibc(I):
  O = canvas(0, (10, 10))
  plus = paint(canvas(0, (3, 3)), {(3, (1, 1)), (3, (0, 1)), (3, (1, 0)), (3, (1, 2)), (3, (2, 1))}) # Direct plus creation
  O = paint(O, shift(asobject(plus), (3, 3)))
  orientation = RIGHT if sum(I[0]) == 0 else DOWN  # Determine orientation based on input
  O = fill(O, 1, frozenset({(4, 4), add((4, 4), orientation)}))  # Place '1s' using orientation
  return O 
 
0.12, 14.83077, def cdffahaaaabdefgiaadcihjajdccfbdb(I):
    O = canvas(ZERO, (TEN, TEN))
    O = paint(O, recolor(THREE, {(4, 4), (4, 5), (4, 6), (3, 5), (5, 5)}))
    O = paint(O, recolor(THREE, {(0, 4), (1, 4), (2, 4)}))
    for i in range(2):
        for j in range(2):
            O = paint(O, recolor(index(I, (i, j)), {(4 + i, 4 + j * 2)}))
    return O
 
0.12, 15.855843, def baeceabhbjjeeibgaghefbhddddefjgd(I):
    O = canvas(ZERO, (TEN, TEN))
    plus_shape = {(i, j) for i in range(3) for j in range(3)} - {(0, 0), (2, 0), (0, 2), (2, 2)}
    t_shape = {(i, 0) for i in range(3)}
    O = paint(O, recolor(THREE, shift(plus_shape, (4, 4))))
    O = paint(O, recolor(THREE, shift(t_shape, (0, 4))))
    for i in range(2):
        for j in range(2):
            O = paint(O, shift(recolor(index(I, (i, j)), {(0, 0)}), (4 + i, 4 + j * 2)))
    return O
 
0.08, 10.854084, def ahbfabfcfjbbeghebbbdbaabddefcdhd(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center_loc = (4, 4) 
  O = fill(O, 3, connect(center_loc, add(center_loc, (0, 2)))) # Horizontal line of the 'plus'
  O = fill(O, 3, {(center_loc[0], center_loc[1] - 1), (center_loc[0], center_loc[1] + 1)}) # Vertical line of the 'plus'
  O = fill(O, 1, {(center_loc[0] - 1, center_loc[1] - 2), (center_loc[0] - 1, center_loc[1] + 2)}) # Placing the '1' digits
  return O
 
0.08, 7.992487, def idafhdchgdfbedgfabjeifcccafjgcfa(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  plus_shape = frozenset({(0, -2), (0, -1), (0, 0), (0, 1), (0, 2), (-1, 0), (1, 0)}) 
  O = paint(O, shift(recolor(3, plus_shape), center)) # Paint the entire 'plus' shape
  O = fill(O, 1, shift({(-2, -2), (-2, 2)}, center)) # Place the '1' digits
  return O
 
0.115, 11.027888, def hhibbfbbbbciedggjgdhiahcfgbgefdj(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  O = paint(O, shift(recolor(3, connect((0, 0), (0, 4))), center)) # Horizontal line 
  O = paint(O, shift(recolor(3, connect((0, 0), (2, 0))), center)) # Vertical line
  O = fill(O, 1, shift({(-2, -2), (-2, 2)}, center)) # '1' digits placement
  return O
 
0.09, 10.827532, def jafdfcfbahieefbeabbaeahaicfhdgff(I):
  O = upscale(I, 5)
  if height(I) == 2:  # Input_0
    O = paint(O, recolor(3, {(4, 4), (3, 3), (3, 4), (3, 5), (5, 4)}))
    O = paint(O, recolor(1, {(5, 1), (5, 7)}))
  else:  # Input_1
    O = paint(O, recolor(3, {(3, 3), (4, 3), (5, 3), (4, 4), (4, 5)}))
    O = paint(O, recolor(1, {(0, 3), (8, 3)}))
  return O
 
0.05, 5.787314, def bhbbcdbdfbabejffifccdaafhfgcjdhd(I):
  O = canvas(0, (10, 10))
  plus_shape = frozenset({(3, (4, 4)), (3, (3, 4)), (3, (5, 4)), (3, (4, 3)), (3, (4, 5))})
  O = paint(O, plus_shape)
  for i in range(2):
    O = fill(O, 1, frozenset({
      (1 if sum(I[0]) else 4, 4 - 3 * (1 - 2 * i)), 
      (7 if sum(I[0]) else 4, 4 + 3 * (1 - 2 * i))
    }))
  return O
 
0.09, 13.597513, def ffcacfacbbbdecicacejahbdbcjdecdc(I):
  O = canvas(ZERO, (TEN, TEN))
  O = paint(O, recolor(THREE, {(4, 4), (4, 5), (4, 6), (3, 5), (5, 5)}))
  shifted_threes = mapply(lambda ij: frozenset({(THREE, (ij[0]-1+di, ij[1]-1+dj)) for di in range(3) for dj in range(3)}), ofcolor(I, ONE))
  O = paint(O, shifted_threes)
  return O
 
0.05, 5.787314, def dbcbecficbhjejfdabjcajciddfaeehd(I):
  bg = mostcolor(I)  # Get background color (always 0 in these examples)
  O = canvas(bg, (10, 10))  # Create a 10x10 canvas filled with the background color
  plus_sign = {(4, 3), (4, 4), (4, 5), (3, 4), (5, 4)} # Define plus sign shape centered at (4,4)
  O = paint(O, recolor(3, plus_sign)) # Paint the plus sign on the canvas with color 3
  O = fill(O, 1, {(4, 1), (4, 7)}) # Fill cells with '1' for horizontal orientation
  return O
 
0.060000000000000005, 5.753334, def cgacaffdejdaegadjadaahgdegfcdebi(I):
  O = canvas(0, (10,10)) # Create a 10x10 canvas of '0's.
  O = paint(O, recolor(3, {(3,4),(4,3),(4,4),(4,5),(5,4)}))  # Paint the '3' core horizontally.
  O = paint(O, recolor(1, {(4,1),(4,8)})) # Add the flanking '1's horizontally.
  return O
 
0.07, 6.527127, def egifgdcadjffehcabeaefbfcgfafjjfd(I):
  O = canvas(0, (10,10)) # Create a 10x10 canvas of '0's.
  core = recolor(3, {(0,1),(1,0),(1,1),(1,2),(2,1)}) # Create the '3' core object.
  O = paint(O, shift(core, (3, 3))) # Place the core at the center.
  O = paint(O, recolor(1, {(3,1),(3,8)})) # Add the flanking '1's horizontally.
  return O
 
0.060000000000000005, 6.7291946, def aehbeaccajaceedbahefafdbhbfbdedi(I):
  O = canvas(0, (10,10)) # Create a 10x10 canvas of '0's.
  O = paint(O, recolor(3, {(3,3),(4,2),(4,3),(4,4),(5,3)}))  # Paint the '3' core vertically.
  O = paint(O, recolor(1, {(1,3),(8,3)})) # Add the flanking '1's vertically.
  return O
 
0.11, 9.938532, def fbaiehgcfaieebgeajjfddeaegfecabe(I):
    O = upscale(I, 5)
    O = fill(O, 3, {(2, 4), (2, 5), (2, 6), (3, 5), (4, 5)})
    O = fill(O, 1, {(4, 3), (4, 7)})
    return O
 
0.09, 10.5543585, def fdjdaaccadbdegjcbfecideaafgfbfbb(I):
  O = upscale(I, 5)
  O = fill(O, 3, {(i, 4 + i//2) for i in range(2, 5)} | {(i, 6 - i//2) for i in range(2, 5)})
  O = fill(O, 1, {(4, 3), (4, 7)})
  return O
 
0.15000000000000002, 21.393356, def abbfejddgfceedfbicfebefefbiccafb(I):
    O = canvas(0, (10, 10))
    for i in range(3):
        O = fill(O, 3, {(3, 2-i), (6, 4+i), (2+i, 3), (4+i, 6)})  # Draw plus sign iteratively

    if sum(I[0]) == 0:
        for j in (1, 7):
            O = fill(O, 1, {(4, j)})  # Place vertical markers
    else:
        for i in (1, 7):
            O = fill(O, 1, {(i, 4)})  # Place horizontal markers
    return O 
 
0.09, 19.866255, def fhafddbgbgdfeaddbficajdiaebbieea(I):
  bg = mostcolor(I)  # Identify background color
  O = canvas(bg, (10, 10))  # Create canvas
  center = (4, 4)
  shape = combine(connect(center, add(center, (0, 2))), connect(center, add(center, (-2, 0))))  # Define plus shape
  line = connect(center, add(center, (0, 2)))  # Define horizontal line
  O = fill(O, 3, shape if size(objects(I, True, False, True)) == 1 else line)  # Conditional drawing
  O = fill(O, 1, {(1, 4), (8, 4)})  # Place '1' cells
  return O
 
0.08, 17.6108, def dbbfcefabfjbehbdbacheaeijifiaeed(I):
  bg = mostcolor(I) 
  O = canvas(bg, (10, 10))
  c = (4, 4)
  plus = combine(connect(c, add(c, (0, 2))), connect(c, add(c, (-2, 0)))) 
  hline = connect(c, add(c, (0, 2))) 
  O = fill(O, 3, plus) if size(objects(I, True, False, True)) == 1 else fill(O, 3, hline)
  O = fill(O, 1, {(4, 1), (4, 8)})  
  return O
 
0.09, 19.942476, def fecfhddccjegejejihiafacccaeedhca(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  O = fill(O, 3, connect(center, add(center, (0, 2))))  # Always draw horizontal
  if size(objects(I, True, False, True)) == 1:  
      O = fill(O, 3, connect(center, add(center, (-2, 0)))) # Add vertical line if one object
  O = fill(O, 1, {add((0,4), (i * 9, 0)) for i in range(2)})  # Place '1' cells on edges
  return O
 
0.05, 7.836457, def bdddijgaiddjejgbibfcgjjiecedfeej(I):
  O = canvas(0, (10, 10))
  O = paint(O, recolor(3, {(3,4), (4,4), (5,4), (4,3), (4,2)}))
  O = paint(O, recolor(1, {(4,1), (4,7)}))
  return O
 
0.07, 6.955365, def afddcdhddifeedaeabfajffdfgahgggc(I):
  O = canvas(0, (10, 10))
  if height(I) == 2:
    O = paint(O, recolor(3, shift({(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}, (3, 3))))
    O = paint(O, recolor(1, shift({(-3, 0), (3, 0)}, (4, 4))))
  else:
    O = paint(O, recolor(3, shift({(1, 0), (0, 1), (1, 1), (2, 1), (1, 2)}, (3, 3))))
    O = paint(O, recolor(1, shift({(0, -3), (0, 3)}, (4, 4))))
  return O
 
0.1, 15.34609, def cbihecafebbeefhaiaceafdhfahegbig(I):
  O = canvas(0, (10, 10))
  T_base = recolor(3, {(0, 1), (1, 1), (2, 1)})
  T_top = recolor(3, {(1, 0), (1, 2)})
  if height(I) == 2:
    O = paint(O, shift(T_base, (3, 4)))
    O = paint(O, shift(T_top, (3, 3)))
    O = paint(O, recolor(1, {(3, 1), (3, 7)}))
  else:
    O = paint(O, shift(rot90(T_base), (3, 3)))
    O = paint(O, shift(rot90(T_top), (4, 3)))
    O = paint(O, recolor(1, {(1, 3), (7, 3)}))
  return O
 
0.05, 5.787314, def dbigjcfddaacefcebbhbaacbgaecaidi(I):
  O = canvas(0, (10, 10))
  T = {(0, 1), (1, 0), (1, 1), (1, 2), (2, 1)}
  if height(I) == 2:
    O = paint(O, recolor(3, shift(T, (3, 3))))
    for j in [1, 7]:
        O = paint(O, recolor(1, {(4, j)}))
  else:
    O = paint(O, recolor(3, shift(rot90(T), (3, 2))))
    for i in [1, 7]:
        O = paint(O, recolor(1, {(i, 4)}))
  return O
 
0.07, 11.069805, def bccdaghjfecbeeedicbiejajjfgcchib(I):
  O = canvas(ZERO, (TEN, TEN))  # Create 10x10 canvas of '0's
  if index(I, (0, 0)) == ONE:
    O = paint(O, recolor(THREE, {(3, 2), (3, 3), (3, 4), (2, 3), (4, 3)}))  # Direct paint of "T" for '1' at (0,0)
    O = paint(O, recolor(ONE, {(0, 3), (8, 3)}))  # Add vertical flanking '1's
  else:
    O = paint(O, recolor(THREE, {(4, 3), (4, 4), (4, 5), (3, 4), (5, 4)}))  # Direct paint of "T" for no '1's
    O = paint(O, recolor(ONE, {(4, 4), (4, 6)}))  # Add horizontal flanking '1's
  return O
 
0.08, 8.617751, def hcdcaagfehgjegdaaafjjfcfgfhghgag(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  O = fill(O, 3, connect(center, add(center, (2, 0))) | connect(center, add(center, (-2, 0))))
  O = fill(O, 3, connect(center, add(center, (0, 1))) | connect(center, add(center, (0, -1))))
  for i in range(1, 3):
    if index(O, add(center, (i, 0))) == 3:
      O = fill(O, 1, {add(center, (i, 0)), add(center, (-i, 0))}) 
      break
    if index(O, add(center, (0, i))) == 3:
      O = fill(O, 1, {add(center, (0, i)), add(center, (0, -i))})
      break
  return O
 
0.09, 9.9868555, def efiafiicghbbedajacidefcddecgbccd(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  O = fill(O, 3, connect(center, add(center, (3, 0))) | connect(center, add(center, (-2, 0)))) # Horizontal, extended to the right
  O = fill(O, 3, connect(center, add(center, (0, 2))) | connect(center, add(center, (0, -1)))) # Vertical, extended downwards
  O = fill(O, 1, {add(center, (-2, 0)), add(center, (3, 0))}) # '1' placement for horizontal arm
  return O
 
0.08, 8.504999, def idebhfddichfeffgabgcjdfdbcebeijd(I):
  bg = mostcolor(I)
  O = canvas(bg, (10, 10))
  center = (4, 4)
  O = fill(O, 3, {(4,2), (4,3), (4,4), (4,5), (4,6), (2,4), (3,4), (5,4), (6,4)})  # Draws the entire plus sign directly
  O = fill(O, 1, {add(center, (-2, 0)), add(center, (2, 0))}) # '1' placement
  return O
 
