36.333333333333336, 16.278873, def fejddeefihceecfdafabhcfhcdebacdj(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    for v, (i, j) in obj:
      if all(0 <= i + di < len(I) and 0 <= j + dj < len(I[0]) and ((i + di, j + dj) in toindices(obj) or I[i + di][j + dj] == 0) for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]):
        I = fill(I, 1, {(i, j)})
  return I
 
64.66666666666667, 24.374489, def fgffeeedbcaaediaifafiacchafdbdbg(I):
  def is_interior(i, j, val):
    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
      ni, nj = i + di, j + dj
      if 0 <= ni < len(I) and 0 <= nj < len(I[0]) and I[ni][nj] not in (0, val):
        return False
    return True
  return tuple(tuple(1 if is_interior(i, j, I[i][j]) else I[i][j] for j in range(len(I[0]))) for i in range(len(I)))
 
23.0, 9.093307, def cdgcaejeddccebhcbccdaaacacacfgfe(I):
    objs = objects(I, T, F, T)  # Identify all objects in the grid
    surrounding_cells = mfilter(apply(delta, objs), identity) # Find cells surrounding the objects
    O = fill(I, 1, surrounding_cells)  # Fill those cells with '1'
    return O
 
48.666666666666664, 17.986801, def aaacdcjcdacgecbabfgddbeccacdahdd(I):
    O = canvas(1, shape(I))  # Create a canvas filled with '1'
    objs = objects(I, T, F, T)
    for obj in objs:
        O = underpaint(O, toobject(toindices(obj), I))  # Paint original object onto the canvas
    return O 
 
12.333333333333334, 7.6904173, def hcgefedeecdaechcaedefccadeadgcfi(I):
  objs = fgpartition(I)  # Get objects excluding background
  interiors = mfilter(apply(inbox, objs), lambda x: size(x) > 0) # Find non-empty inboxes (interiors)
  return paint(fill(I, 1, interiors), mfilter(objs, identity)) # Fill interiors with 1, repaint objects
 
17.333333333333332, 9.513598, def bbcbefacabbdejafigibddebddjdieai(I):
  modified = I
  for obj in fgpartition(I):
    if size(inbox(obj)) > 0:
      modified = fill(modified, 1, inbox(obj)) # Fill interior if it exists
  return modified
 
23.666666666666668, 16.87634, def eejjahabehefejbcifecafcehheeibgb(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
      indices = toindices(obj)
      for i in range(uppermost(indices) + 1, lowermost(indices)):
        for j in range(leftmost(indices) + 1, rightmost(indices)):
          O = fill(O, ONE, {(i, j)})
    return O
 
44.666666666666664, 40.16212, def djbcjaafaaafeafdbdcffebfebgaebgj(I):
    O = I
    for i in range(1, len(I)-1):
        for j in range(1, len(I[0])-1):
            if any(I[ni][nj] != mostcommon(I) for ni, nj in neighbors((i, j))):
              O = fill(O, ONE, {(i, j)})
    return O
 
29.333333333333332, 7.4539146, def chbhfjfajjeaecfhahfifeedbcibdbee(I):
  objs = objects(I, T, F, F)
  changed_objs = set()
  for obj in objs:
    if size(toindices(obj)) > size(box(obj)):
      changed_objs.add(recolor(1, inbox(obj)))
  return paint(I, merge(changed_objs))
 
14.333333333333334, 13.411108, def adaihffbhfedeaabagbjafecicjhadcg(I):
  changed_cells = set()
  for i in range(1, height(I)-1):
    for j in range(1, width(I)-1):
      if index(I,(i,j)) != 0 and index(I,(i-1,j)) == index(I,(i+1,j)) == index(I,(i,j-1)) == index(I,(i,j+1)):
        changed_cells.add((1, (i,j)))
  return paint(I, frozenset(changed_cells))
 
40.333333333333336, 8.639128, def fejfabgicfceecbfjgbaeaecdjjjgiia(I):
  filled = I
  for obj in objects(I, T, F, F):
    if size(obj) > 1:
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          if (i, j) in toindices(obj):
            filled = fill(filled, 1, {(i,j)})
  return filled
 
23.666666666666668, 16.87634, def cbbfaejdgdcfeffiiefacjfbdiadbchc(I):
    return paint(I, {(1, idx) for obj in fgpartition(I) for idx in difference(backdrop(obj), box(obj))})
 
27.0, 11.424956, def dfjeeeahcehaeieeaefibdceeaeecbbe(I):
  return paint(I, {(1, (i, j)) for obj in fgpartition(I) for (i, j) in difference(toindices(obj), box(obj))}) 
 
14.666666666666666, 14.093623, def ecabcjadeacfeciiaafdbahebghaeide(I):
    bg = mostcolor(I)  # Get background color
    objs = objects(I, T, F, T)  # Extract objects
    modified_grid = I
    for obj in objs:
        modified_grid = fill(modified_grid, 1, delta(toindices(obj)))  # Fill surrounding cells for each object
    O = cellwise(I, modified_grid, bg)  # Combine changes, keeping original values for non-surrounding cells
    return O
 
29.0, 10.366916, def cgjbhcgcdbffegbjbchjecfeaiefhbjb(I):
    objs = objects(I, T, F, T)
    surrounding_indices = set()
    for obj in objs:
        for i, j in toindices(obj):
            surrounding_indices.update((i + di, j + dj) for di in range(-1, 2) for dj in range(-1, 2))
    surrounding_indices = frozenset(loc for loc in surrounding_indices if 0 <= loc[0] < len(I) and 0 <= loc[1] < len(I[0]) and index(I, loc) == mostcolor(I))
    O = fill(I, 1, surrounding_indices)
    return O
 
16.333333333333332, 4.999159, def hbhafbjehjefeicaadcbbiggbfeeahfb(I):
  objs = objects(I, T, F, T)
  O = I 
  for obj in objs:
    O = fill(O, ONE, inbox(toindices(obj))) # Directly fill inbox for each object
  return O
 
21.666666666666668, 7.9981046, def bbdgheddfhgbehefiabbcegbeadfdfjd(I):
    return paint(I, merge(apply(lambda o: branch(size(intersection(delta(o), asindices(trim(crop(I, ulcorner(o), shape(o)))))) == 0, recolor(1, o), o), objects(I, T, F, F))))
 
42.0, 20.71745, def cechdcbifcfhedbjabhdcebeibabeeee(I):
  return paint(I, {(ONE, idx) for obj in fgpartition(I) for _, idx in obj if len(dneighbors(idx) & toindices(obj)) < 4})
 
17.333333333333332, 9.513598, def fbhdajebbbiceddfaadfcfbdfeafdabd(I):
  O = I
  for obj in fgpartition(I):
    O = fill(O, ONE, inbox(obj))
  return O
 
51.333333333333336, 36.860756, def egaiifeedheheicajggbfgjgeddaacjf(I):
  bg = mostcolor(I)
  O = canvas(bg, shape(I)) # Create a canvas of background color
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] != bg: # For each non-background cell
        O = fill(O, 1, {(i-1, j),(i+1, j),(i, j-1),(i, j+1)})  # Fill its adjacent cells with 1
  return O
 
16.333333333333332, 4.999159, def dffdafdiafgbedbjidjjgefbgdddaegb(I):
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  filled_objs = apply(lambda obj: recolor(1, inbox(obj)), objs)
  return paint(I, merge(filled_objs)) 
 
21.0, 5.731722, def ddedehchbddcejcgabcbdgdeebbgcefh(I):
  filled = mfilter(apply(lambda obj: recolor(1, delta(obj)), fgpartition(I)), identity)
  return paint(I, filled)
 
17.666666666666668, 15.879987, def hecbcadedacfefccaidcicagacgfafff(I):
  objs = fgpartition(I)
  return paint(I, merge(apply(lambda obj: toobject(inbox(obj), replace(I, color(obj), 1)), objs))) 
 
50.333333333333336, 46.02379, def jjdeaabaeffcefccicfedejecehcabha(I):
  modified_objs = apply(lambda obj: recolor(1, difference(backdrop(obj), obj)), fgpartition(I))
  return paint(I, merge(modified_objs))
 
12.333333333333334, 6.555199, def hffgfhdejbdgehddabfcgdbcdceajegf(I):
    objs = objects(I, T, F, T)
    O = I 
    for obj in objs:
        O = underpaint(O, recolor(ONE, inbox(toindices(obj))))
    return O
 
40.666666666666664, 25.981825, def aiedbeeeaffbeeagicddggaeajdfbbdc(I):
  O = canvas(mostcolor(I), shape(I))
  objs = objects(I, univalued=True, diagonal=False, without_bg=True)
  for obj in objs:
    O = paint(O, recolor(1, inbox(toindices(obj)))) 
  return O
 
16.333333333333332, 4.999159, def eabdhdajjdbdeedfjbdfbifcehfcdcab(I):
  bg = mostcolor(I)  # Identify the background color
  filled = I
  for obj in objects(I, T, F, T):
    if any(index(I, cell) == bg for cell in inbox(obj)):
      filled = fill(filled, 1, inbox(obj)) 
  return filled
 
15.666666666666666, 9.221744, def bddibedhbbbjejjeijbddbdbjccaedhg(I):
  O = I
  for i in range(1, height(I)-1):
    for j in range(1, width(I)-1):
      if I[i][j] == mostcolor(I) and any(I[ni][nj] != mostcolor(I) for ni, nj in neighbors((i,j))):
        O = fill(O, 1, {(i,j)})
  return O
 
10.333333333333334, 4.183888, def bccahdgdechjeecbbbfdedbgfdajhfbd(I):
  O = I
  for obj in objects(I, T, F, T):
    for i, j in inbox(obj):
      if index(I, (i, j)) == mostcolor(I) and any(index(I, n) != mostcolor(I) for n in neighbors((i, j))):
        O = fill(O, 1, {(i, j)})
  return O
 
18.666666666666668, 16.7973, def bacdjdfeifbceeibigdcdjjfacgbfgaa(I):
  objs = objects(I, T, F, F)
  interiors = frozenset()
  for obj in objs:
    interior = frozenset((v, c) for v, c in obj if all(index(I, n) == v for n in dneighbors(c)))
    interiors = interiors | {recolor(1, interior)}
  return paint(I, merge(interiors))
 
16.333333333333332, 4.999159, def jgeagdebecbcefbcbgaaeheebjbgeaci(I):
  objs = objects(I, True, False, True)  # Find connected objects, excluding background
  for obj in objs:
    filled_obj = recolor(1, inbox(obj)) # Recolor the interior of the object
    I = paint(I, filled_obj) # Paint the filled object back onto the grid
  return I
 
14.333333333333334, 13.411108, def bjacjgdeajidefefiiejhbacgiafjedf(I):
    O = I
    for i in range(1, height(I) - 1):
        for j in range(1, width(I) - 1):
            if index(I, (i, j)) != 0 and \
               index(I, (i - 1, j)) == index(I, (i + 1, j)) == index(I, (i, j - 1)) == index(I, (i, j + 1)):
                O = paint(O, {(1, (i, j))})
    return O
 
20.0, 16.455765, def bdbdbicbdbaaefefjcefhecieeccecef(I):
  def is_interior(x, y):
    return index(I, (x - 1, y)) == index(I, (x + 1, y)) == index(I, (x, y - 1)) == index(I, (x, y + 1)) 
  
  O = canvas(0, shape(I))
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if index(I, (i, j)) != 0 and is_interior(i, j):
        O = paint(O, {(1, (i, j))})
      else:
        O = paint(O, {(index(I, (i, j)), (i, j))}) 
  return O
 
14.666666666666666, 5.138593, def adbcdchjgfhceecdaddgaacfbheedeeb(I):
  objs = objects(I, T, F, T)
  def get_holes(obj):
    return sfilter(delta(obj), lambda loc: any(n in toindices(obj) for n in neighbors(loc)))
  holes = merge(apply(get_holes, objs))
  O = fill(I, 1, holes)
  return O
 
43.333333333333336, 15.652205, def cbajbbijiccaecaejdeffehbecicdcgb(I):
  def is_hole(loc):
    return index(I, loc) == mostcolor(I) and any(index(I, n) != mostcolor(I) for n in ineighbors(loc))
  holes = sfilter(asindices(I), is_hole)
  return fill(I, 1, holes)
 
42.0, 20.71745, def bibcidfebhheeffbadgdbagaejiajcfa(I):
  def get_hole_neighbors(loc):
    return sfilter(neighbors(loc), lambda n: index(I, n) == mostcolor(I))
  def is_hole(loc):
    return index(I, loc) != mostcolor(I) and len(get_hole_neighbors(loc)) >= 2 and not square(get_hole_neighbors(loc))
  holes = sfilter(asindices(I), is_hole)
  return fill(I, 1, holes) 
 
36.333333333333336, 16.278873, def fdfedaebfcddedfdadaiacgddbeeagfb(I):
  O = I
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
        if I[i][j] != mostcolor(I) and any(I[i+di][j+dj] == mostcolor(I) for di, dj in [(0,1),(0,-1),(1,0),(-1,0)]):
          O = fill(O, ONE, {(i, j)}) # Check for background neighbors and fill
  return O
 
42.0, 20.71745, def behfcejaabidebfcibbcbecagabegbjd(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        for cell in toindices(obj):
            if any((i,j) not in toindices(obj) for (i,j) in dneighbors(cell)):
                O = fill(O, ONE, {cell}) # Check for each cell if it has a neighbor outside the object
    return O
 
42.0, 20.71745, def dceaaefgeeddeciaibbbdacddgbbejhe(I):
  obj_indices = ofcolor(I, 2)  # Get indices of all '2's
  non_border_indices = mfilter(obj_indices, lambda loc: not bordering(initset(loc), I)) # Remove indices touching the grid border
  inner_indices = difference(obj_indices, non_border_indices)  # The remaining indices are the interior '2's
  O = fill(I, 1, inner_indices)  # Fill with '1'
  return O
 
42.666666666666664, 41.301403, def ghaeefijibcdeffgbffdabecjdjdabaf(I):
  objs = partition(I)  # Partition the grid into objects based on color
  transformed_objs = apply(lambda obj: recolor(1, inbox(toindices(obj))) if color(obj) == 2 else obj, objs)  # Apply transformation to '2' objects
  O = paint(canvas(0, shape(I)), merge(transformed_objs))  # Paint transformed objects onto an empty canvas
  return O
 
61.333333333333336, 81.98343, def icddcadfdffaeafcjicifaijdcaghdbb(I):
  inverted = replace(I, 2, 1) # Temporarily replace '2's with '1's
  filled = underfill(inverted, 2, asindices(I)) # Fill background with '2's, effectively highlighting the object outlines
  O = replace(filled, 1, 2)  # Restore original '2's while keeping the filled interior as '1's
  return O
 
21.666666666666668, 5.057539, def bgafhddedbehefgaajdefdaaigfbdecf(I):
  objs = objects(I, True, False, True)
  bg = mostcolor(I)
  canvas_grid = canvas(bg, shape(I)) 
  for obj in objs:
    canvas_grid = underpaint(canvas_grid, recolor(1, inbox(obj))) 
    canvas_grid = paint(canvas_grid, toobject(box(obj), I))
  return canvas_grid
 
22.0, 5.128285, def iafiafceabfceeccbdhiceceicdfacdf(I):
    objs = objects(I, True, False, True)
    bg = mostcolor(I)
    new_grid = canvas(bg, shape(I))
    for obj in objs:
        outline = box(obj)
        filled_obj = recolor(1, inbox(obj))
        for cell in filled_obj:
            if cell[1] not in outline:
                new_grid = paint(new_grid, {cell})
        new_grid = paint(new_grid, toobject(outline, I))
    return new_grid
 
11.333333333333334, 4.806022, def hjbdfdefhfddehfebaajbcfjchdgfiii(I):
    O = I
    for obj in objects(I, T, F, T):
        for i, j in inbox(obj):  # Iterate over the inner cells of the object
            if index(I, (i, j)) == mostcolor(I):  # Check if the cell is the background color
                O = fill(O, 1, {(i, j)})  # Fill the background color cell with 1
    return O
 
15.0, 8.804194, def fhfaedbafdaaehacidciaeadccacbeeh(I):
  inverted = fill(I, 1, asindices(I)) # Invert the grid
  inverted = fill(inverted, 0, ofcolor(I, mostcolor(I))) # Set most common color to 0
  holes = frozenset()
  for i in range(1, len(I) - 1): # Iterate over inner rows
    for j in range(1, len(I[0]) - 1): # Iterate over inner columns
      if inverted[i][j] == 0 and any(inverted[i + di][j + dj] != 0 for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]): # Check if the current cell is 0 and has a non-zero neighbor
        holes = holes | {(i, j)} # Add the cell to the set of holes
  return fill(I, 1, holes) # Fill the holes with 1 in the original grid
 
9.333333333333334, 5.4137588, def faccjgahiihbecddafjfjfaeefjfcchb(I):
  O = I
  for obj in objects(I, T, F, T):
    if size(palette(obj)) == 1: # Check if the object has only one color
      for i in range(uppermost(obj) + 1, lowermost(obj)): # Iterate over rows within the object
        for j in range(leftmost(obj) + 1, rightmost(obj)): # Iterate over columns within the object
          if index(I, (i, j)) == mostcolor(I): # Check if the cell is the background color
            O = fill(O, 1, {(i, j)}) # Fill the cell with 1
  return O
 
21.0, 5.731722, def ieacfjebdcddebacjffejbabiacjaaai(I):
    objs = objects(I, T, F, T)
    O = I
    for obj in objs:
        indices = toindices(obj)
        inbox_indices = delta(indices) & backdrop(indices)
        O = underpaint(O, recolor(ONE, inbox_indices))
    return O
 
15.0, 8.804194, def bajdaffibeadehggbebbhageibibgcff(I):
    O = I
    for i in range(1, len(I) - 1):
        for j in range(1, len(I[0]) - 1):
            if I[i][j] == mostcolor(I) and any(I[x][y] != mostcolor(I) for x, y in dneighbors((i, j))):
                O = paint(O, {(ONE, (i, j))})
    return O
 
9.333333333333334, 5.4137588, def dddifeiddibaeecdabhfajebegcbieba(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled = I
  for obj in twos:
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(filled, (i, j)) == 0:
          filled = fill(filled, 1, {(i, j)})
  return filled
 
12.333333333333334, 6.555199, def djedebbddbefehjbahheegedgdfaeeaj(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled = I
  for obj in twos:
    filled = cover(filled, obj)  # Temporarily remove the object
    filled = underfill(filled, 1, inbox(toindices(obj))) # Fill the area under the removed object
    filled = paint(filled, obj)  # Restore the original object
  return filled
 
23.0, 9.093307, def gceafcagecaaeebfajbbfcjdacfeaiij(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled_indices = set()
  for obj in twos:
    obj_indices = toindices(obj)
    backdrop_indices = backdrop(obj_indices)
    inner_indices = backdrop_indices - obj_indices
    filled_indices.update(inner_indices)
  return fill(I, 1, frozenset(filled_indices)) 
 
23.0, 9.093307, def ceddbafaddibeafiajddffjbjaeffaeg(grid):
  return paint(grid, merge({recolor(1, delta(obj)) for obj in objects(grid, True, False, True)}))
 
12.333333333333334, 6.555199, def adfbhbecbcdfeabbabbiciccddhcgeff(I):
    O = I
    for obj in objects(I, T, F, T):
        O = underfill(O, 1, inbox(obj)) 
    return O
 
23.0, 9.093307, def ciabdgeeigafefcciffeaafcbaacabdb(I):
    O = I
    for obj in objects(I, T, F, T):
        inbox_indices = delta(toindices(obj)) & backdrop(toindices(obj))
        O = fill(O, ONE, inbox_indices)
    return O
 
11.0, 12.340655, def gjabiebfbgdbeddgbbbfagdffdcjcaig(I):
  objs = objects(I, True, False, False)
  target_objs = colorfilter(objs, 2)
  inner_indices = set()
  for obj in target_objs:
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if (i, j) in toindices(obj):
          continue
        inner_indices.add((i, j))
  return fill(I, 1, frozenset(inner_indices))
 
18.0, 4.767692, def edhfbccacgicefcjaabdahbaibfhgdfe(I):
  O = I
  for obj in objects(I, T, F, T):
    O = underfill(O, 1, inbox(obj)) # Fill inside the object
    O = underfill(O, 1, delta(obj)) # Fill adjacent to the object
  return O 
 
21.0, 5.731722, def fbeacfcjddfeecacibajfeadebafcadb(I):
  O = paint(canvas(mostcolor(I), shape(I)), asobject(I))
  for obj in objects(I, T, F, T):
    O = underfill(O, 1, backdrop(obj))
  return O
 
19.333333333333332, 5.7789283, def hdiijcdddcfjeahjjhcfafccacbcdadf(I):
  filled = set()
  O = I
  for obj in objects(I, T, F, T):
    for i, j in backdrop(obj):
      if (i, j) not in filled:
        if index(I, (i, j)) == mostcolor(I) and any(index(I, n) != mostcolor(I) for n in neighbors((i, j))):
          O = fill(O, 1, {(i,j)})
          filled.add((i, j))
    O = underfill(O, 1, inbox(obj))
  return O
 
14.0, 16.459091, def iffdfhccedbaedhiibcbhdfgbdchdfba(I):
  O = I
  for obj in objects(I, T, F, T):
    inner_objs = objects(crop(I, ulcorner(obj), shape(obj)), T, F, T) # Find objects within the bounding box of the current object
    for inner_obj in inner_objs:
      if color(inner_obj) == mostcolor(I) and size(inner_obj) > 1: 
      # Check if the inner object is background and has more than one cell
        O = fill(O, 1, toindices(inner_obj)) # Fill the entire inner object with 1
  return O
 
15.0, 8.804194, def cjhebdfgahbgecggjfihjaefbbjdhhfi(I):
  h, w = len(I), len(I[0])
  O = [[I[i][j] for j in range(w)] for i in range(h)]
  for i in range(1, h-1):
    for j in range(1, w-1):
      if I[i][j] == 0 and any(I[ni][nj] == 2 for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]):
        O[i][j] = 1
  return tuple(tuple(row) for row in O)
 
21.0, 5.731722, def dbegaeffcfjieffiabgehabbieacfheh(I):
    objs = objects(I, True, False, False)
    target_objs = colorfilter(objs, 2)
    filled = I
    for obj in target_objs:
        obj_indices = toindices(obj)
        fill_object = recolor(1, backdrop(obj_indices) - obj_indices)
        filled = underpaint(filled, fill_object)
    return filled
 
17.333333333333332, 16.077568, def dhdejadbiegeefjbaebfdfafbaacbceb(I):
  O = I  
  for obj in objects(I, T, F, T): 
    for i, j in toindices(obj): 
      if (i, j) in inbox(obj) and all((n in toindices(obj)) or (index(I, n) == mostcolor(I)) for n in neighbors((i, j))):
        O = fill(O, 1, {(i, j)}) 
  return O
 
6.333333333333333, 2.4516773, def ejhbcbfecbijeaccidadgaeeadfbbdbc(I):
  O = I
  for obj in objects(I, T, F, T):
    box_indices = inbox(obj)
    for i, j in box_indices:
      if index(I, (i, j)) == mostcolor(I) and all(n in box_indices or index(I, n) != mostcolor(I) for n in neighbors((i, j))):
        O = fill(O, 1, {(i, j)})
  return O
 
25.333333333333332, 12.327075, def ijbeifjaaefdeddjbeeicbeecddaabac(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    border = box(obj)
    O = paint(O, toobject(border, I))
    interior = difference(toindices(obj), border)
    O = underfill(O, 1, interior)
  return O
 
11.333333333333334, 4.806022, def ficcgjahcjjcecaaidgdecgahgjbhbaa(I):
    objs = objects(I, T, F, T)
    inboxes = frozenset({idx for obj in objs for idx in inbox(toindices(obj))})
    O = underfill(I, ONE, inboxes)
    return O
 
8.333333333333334, 4.9556537, def chfjiihfdeeieaecbifcbcgdgfgbaafb(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled = I
  for obj in twos:
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == 0 and any(index(I, (ni, nj)) == 2 for ni, nj in neighbors((i, j))):
          filled = fill(filled, 1, {(i, j)})
  return filled
 
12.666666666666666, 20.710733, def cfidefdddjadehdebfcbffffjahffgih(I):
  objs = objects(I, True, False, True) # Extract objects, excluding background
  filled = I
  for obj in objs:
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == mostcolor(I) and all(index(I, n) == color(obj) for n in dneighbors((i, j))):
          filled = fill(filled, 1, {(i, j)})
  return filled
 
42.0, 81.70159, def cajghagefhjcececbdhbjcajeceddbgd(I):
  O = canvas(mostcolor(I), shape(I)) # Create a blank canvas
  for obj in objects(I, True, False, True):
    O = paint(O, recolor(1, inbox(obj))) # Paint the inbox of each object with '1'
  return cellwise(I, O, 0) # Merge with original, prioritizing original colors 
 
21.0, 5.731722, def efgafgdbbbaeedgdaeaejdgdeadabfga(I):
  O = I
  for obj in objects(I, T, F, T):
    if numcolors(obj) == 1:
      box_indices = difference(backdrop(obj), toindices(obj))
      for i, j in box_indices:
        if index(O, (i, j)) == 0:
          O = fill(O, 1, {(i, j)})
  return O
 
12.333333333333334, 6.555199, def dcfddadjfcbbefbbbfjddfcfaeacaabc(I):
  for obj in objects(I, True, False, True):
    I = underfill(I, 1, inbox(obj))
  return I
 
23.0, 9.093307, def ibcgdifiifdaehhgaabbcabaaegffhab(I):
  return paint(I, merge(apply(lambda obj: recolor(1, delta(obj)), objects(I, T, F, T))))
 
12.666666666666666, 20.710733, def ffejbbbjhajdebciiicjfeidccbhfejb(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    for i, j in toindices(obj):
      if all(index(I, n) == color(obj) for n in dneighbors((i, j))):
        I = fill(I, 1, {(i, j)})
  return I
 
9.333333333333334, 5.4137588, def cgbdefdgdaiceffeaaeijadgefdggeda(I):
  O = I
  for obj in objects(I, T, F, T):
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == mostcolor(I):
          O = fill(O, 1, {(i, j)})
  return O
 
21.0, 5.731722, def abbbadcfdaahefjajdagcbebdfagajdb(I):
  O = I
  for obj in objects(I, T, F, T):
    for i, j in delta(obj):
      if index(I, (i, j)) == mostcolor(I):
        O = fill(O, 1, {(i, j)})
  return O
 
12.666666666666666, 20.710733, def fghfcidecbacecfebabffgjadcaagegd(I):
  objs = fgpartition(I) 
  interiors = mfilter(objs, lambda obj: sfilter(neighbors(centerofmass(obj)), lambda loc: index(I, loc) == mostcommon(I)))
  return paint(fill(I, 1, interiors), mfilter(objs, identity))
 
8.666666666666666, 5.6168203, def jjbjjcbfhbcgecddicebabhbdgigacgc(I):
  objs = objects(I, True, False, False) # Get all objects in the grid
  filled = I
  for obj in objs:
    if color(obj) == 2:  # Only process objects with color '2'
      for i in range(uppermost(obj) + 1, lowermost(obj)): # Iterate rows within object
        for j in range(leftmost(obj) + 1, rightmost(obj)): # Iterate columns within object
          if index(filled, (i, j)) == 0 and index(filled, (i, j-1)) == 2: # Check if cell is empty and connected to 2 on left
            filled = fill(filled, 1, {(i, j)}) # Fill with '1' if conditions met
  return filled
 
10.333333333333334, 13.603392, def adebeigecfbcegafaiidjbjhjbfedhca(I):
  O = I 
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if I[i][j] == 0 and I[i][j - 1] == 2 and I[i][j + 1] == 2:
        O = fill(O, 1, {(i, j)})
  return O
 
9.333333333333334, 4.6906195, def fabajdjbceicejgajhefdaadjcfgbagi(I):
  filled = I
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      leftmost_j = leftmost(obj)
      rightmost_j = rightmost(obj)
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost_j + 1, rightmost_j):
          if index(filled, (i, j)) == 0:
            filled = fill(filled, 1, {(i, j)})
          else:
            break  # Stop filling horizontally once a non-zero cell is encountered
  return filled
 
40.0, 25.935944, def eceeadedaacgebddicafffcefediihec(I):
  O = canvas(mostcolor(I), shape(I)) # Create a canvas filled with the background color
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      for i in range(uppermost(obj), lowermost(obj) + 1):
        start_j = None
        for j in range(leftmost(obj), rightmost(obj) + 1):
          if index(I, (i, j)) == 2 and start_j is None:
            start_j = j # Mark the start of a horizontal '2' segment
          elif index(I, (i, j)) != 2 and start_j is not None:
            O = fill(O, 1, connect((i, start_j + 1), (i, j - 1))) # Fill between consecutive '2's on the same row
            start_j = None
  return O 
 
10.333333333333334, 10.007697, def djjbbijcifhjefcbicbadeaeciffffcc(I):
  objs = objects(I, True, False, True)
  target_obj = extract(objs, lambda obj: color(obj) == 2)
  return fill(I, 1, delta(toindices(target_obj)))
 
42.0, 20.71745, def jedadfbiibbaebdhiacfgcdhbbghbffj(I):
  O = I
  for obj in objects(I, T, F, T):
    for cell in obj:
      i, j = cell[1]
      if all(index(I, n) == color(obj) for n in dneighbors((i,j)) & toindices(obj)):
        O = fill(O, 1, {(i, j)})
  return O
 
25.333333333333332, 12.327075, def fdjgidegefdfehjfieeebahbgdfcefde(I):
  O = I
  for obj in objects(I, T, F, T):
    indices = toindices(obj)
    for i in range(uppermost(indices)+1, lowermost(indices)):
      for j in range(leftmost(indices)+1, rightmost(indices)):
        if (i,j) in indices:
          O = fill(O, 1, {(i, j)})
  return O
 
12.666666666666666, 20.710733, def geaecbdabeffebbcbfhejfcfihcfcjdf(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, T, F, T):
    O = paint(O, recolor(1, toindices(obj) - box(toindices(obj))))
    O = paint(O, obj)
  return O 
 
42.666666666666664, 14.882509, def hbbfibaedhegedciidhcicbjbbfbeceb(I):
  O = I
  bg = mostcolor(I)
  for i, j in asindices(I):
    if index(I, (i, j)) == bg and any(index(I, n) != bg for n in dneighbors((i, j))):
      O = fill(O, 1, {(i, j)})
  return O
 
42.0, 20.71745, def eacichjbbehdehfcbcechcffdcfdfjce(I):
  return paint(I, recolor(1, difference(mapply(dneighbors, ofcolor(I, mostcolor(I))), ofcolor(I, mostcolor(I)))))
 
12.666666666666666, 20.710733, def dfceeccaccbbegcbjdibiicabeeddeca(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for i, j in toindices(obj):
        if index(filled, (i, j)) == 0 and any(index(filled, (i, k)) == 2 for k in range(j)):
          filled = fill(filled, 1, {(i, j)})
  return filled
 
9.666666666666666, 5.4391727, def caafehaecfjiediaididafeffffdbfig(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          if index(filled, (i, j)) == 0 and (i, j - 1) in toindices(obj):
            filled = fill(filled, 1, {(i, j)})
  return filled
 
11.333333333333334, 4.806022, def feefbfegibfceibcjdhbabejdacfdedg(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      box_indices = inbox(obj)
      for i, j in box_indices:
        if index(filled, (i, j)) == 0:
          filled = fill(filled, 1, {(i, j)})
  return filled
 
13.333333333333334, 5.280476, def jbjcceebaeddegjebefbbgecbajcgcff(I):
  objs = objects(I, True, False, False)
  filled = canvas(0, shape(I)) 
  for obj in objs:
    filled = paint(filled, obj)
    if color(obj) == 2:
      filled = underfill(filled, 1, inbox(obj))
  return filled
 
5.666666666666667, 5.5188513, def ehheegaiacgcedfiabecbeadaedddbei(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled = I
  for obj in twos:
    leftmost_j = leftmost(obj)
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost_j + 1, rightmost(obj)):
        if index(filled, (i, j)) == 0 and index(filled, (i, leftmost_j)) == 2:
          filled = fill(filled, 1, {(i, j)})
  return filled
 
13.0, 18.13485, def dhfacchbfbddebdabheigbafbdibejfd(I):
  obj = toindices(extract(objects(I, True, False, True), lambda obj: color(obj) == 2))
  return fill(I, 1, frozenset((i, j) for i, j in delta(obj) if all(0 <= n[0] < len(I) and 0 <= n[1] < len(I[0]) and index(I, n) != 2 for n in neighbors((i, j)))))
 
10.0, 6.6988635, def ejeaahfgfdeeeichjfgeedcafhadidga(I):
  obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  return paint(I, recolor(1, frozenset((i, j) for i, j in inbox(obj) if index(I, (i, j)) == 0)))
 
16.333333333333332, 4.999159, def gdfiacfadaaaeegaicecbbchididcjbc(I):
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      I = fill(I, 1, inbox(obj))
  return I
 
50.333333333333336, 19.125984, def biafdeahhhddecffjafdechdjfgdebdh(I):
  O = I
  for obj in objects(I, T, F, T):
    filled_obj = toobject(backdrop(toindices(obj)), I)
    O = underpaint(cover(O, obj),  recolor(ONE, difference(filled_obj, obj)))
  return O
 
17.333333333333332, 9.513598, def gejficdcgdfgejdaacbidfbgagbhafgh(I):
  return paint(I, mfilter(apply(lambda obj: recolor(1, inbox(obj)) if size(obj) > 1 else frozenset(), fgpartition(I)), identity))
 
15.0, 8.804194, def deegfiiceaeceadjbhbcdaecaihebfba(I):
  filled = I
  for i in range(1, height(I) - 1):
    for j in range(1, width(I) - 1):
      if index(I, (i, j)) == 0 and any(index(I, (i + di, j + dj)) == 2 for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]):
        filled = fill(filled, 1, {(i, j)})
  return filled
 
42.666666666666664, 39.48168, def gdejiadcfdceeefebadadbbaedgeecfd(I):
  filled = canvas(0, shape(I)) # Create an empty canvas
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      filled = paint(filled, recolor(1, inbox(obj))) # Paint the inbox of '2' objects with '1'
    else:
      filled = paint(filled, obj) # Paint other objects as they are
  return filled
 
10.0, 11.731367, def ehbaecfhddihecabaedjcdeajacfjaac(I):
  obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  return paint(I, recolor(1, frozenset((i,j) for i, j in delta(toindices(obj)) if any((abs(i - k) + abs(j - l) == 1) and index(I, (k,l)) == 2 for k, l in toindices(obj)))))
 
10.666666666666666, 13.129258, def hedfijbcegdcegidbhjdcfihfaggciie(I):
  obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  shifted_obj = shift(obj, (1, 0))
  return paint(paint(I, recolor(1, intersection(delta(toindices(obj)), toindices(shifted_obj)))), 
               recolor(1, intersection(delta(toindices(obj)), toindices(shift(obj, (-1, 0))))))
 
23.666666666666668, 16.87634, def edcaehafdafdefaijbajceibgadaaaaa(I):
    O = I
    for obj in objects(I, T, F, T):
        outline = box(toindices(obj))
        for i in range(uppermost(obj), lowermost(obj) + 1):
            for j in range(leftmost(obj), rightmost(obj) + 1):
                if (i, j) not in outline:
                    O = fill(O, 1, {(i, j)})
    return O
 
18.0, 12.661199, def bbfgjajddeigegfdjeeaafdcfiheaacf(I):
    O = I
    for obj in objects(I, T, F, T):
        if len(obj) > 4:  # Only process objects with potential inner area
            shifted_obj = shift(obj, (1, 1))  # Shift object diagonally
            for value, (i, j) in shifted_obj:
                if (i, j) in toindices(obj):  # Check if shifted cell is within original object
                    O = fill(O, 1, {(i, j)})
    return O
 
18.0, 4.8654227, def ebdfaahagdafeefbabcfbbhjafccicie(I):
  O = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        for k in range(j + 1, len(row)):
          if O[i][k] == 0:
            O = fill(O, 1, {(i, k)})
          else:
            break
  return O
 
28.333333333333332, 10.797995, def hjfbfifaaajjehciachcjcbifaicgbfd(I):
  objs = objects(I, True, False, False)
  twos = colorfilter(objs, 2)
  filled = I
  for obj in twos:
    for i in range(uppermost(obj), lowermost(obj) + 1):
      j = leftmost(obj)
      while j < len(filled[0]) and (index(filled, (i, j)) == 2 or index(filled, (i, j)) == 1):
        filled = fill(filled, 1, {(i, j)})
        j += 1
  return filled
 
70.0, 66.70918, def ejcaeedebdiaeihgbjecbaaebhfccajf(I):
  O = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if O[i][j] == 2:
        O = fill(O, 1, hfrontier((i, j + 1)))
  return O
 
48.0, 40.267498, def iidbcaiabhjdehcbbbajjbdjjagbbdaj(I):
  O = I
  for obj in objects(I, True, False, False):
    if color(obj) == 2:
      start = (uppermost(obj), leftmost(obj) + 1)
      end = (lowermost(obj), len(I[0]) - 1)
      O = fill(O, 1, backdrop(frozenset({start, end})))
  return O
 
18.0, 10.451479, def afdbiaadbcfaecaebfegaajcecbiabcf(I):
  obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  return paint(fill(I, 1, inbox(obj)), recolor(1, outbox(obj)))
 
31.0, 8.5641575, def acefegeddgdbeadfiededacdddjdhejc(I):
  for obj in colorfilter(objects(I, True, False, True), 2):
    I = fill(I, 1, inbox(obj))
    I = paint(I, recolor(1, outbox(obj)))
  return I
 
16.0, 14.313545, def efjajcccbgcjeedebifhcidchehecahe(I):
  obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
  return paint(I, recolor(1,  set(toindices(obj)) | (delta(toindices(obj)) & neighbors(centerofmass(obj)))))
 
16.333333333333332, 4.999159, def dffjbgbcfaafedccbdihbaejabdbhgda(I):
  objs = objects(I, T, F, T)
  inboxes = frozenset({idx for obj in objs for idx in inbox(toindices(obj))})
  O = fill(I, 1, inboxes)
  return O
 
24.333333333333332, 11.229032, def ajigafhahcefedhajabedbdchjeafjda(I):
  O = I
  for obj in objects(I, T, F, T):
    box_indices = box(toindices(obj)) # Get bounding box indices
    for i, j in box_indices:
      if (i, j) not in toindices(obj) and index(I, (i, j)) == mostcolor(I): # Check for inbox and background color
        O = fill(O, 1, {(i, j)}) 
  return O
 
48.666666666666664, 17.986801, def bagahfjhcbbaehdbiefdbaaeffffajab(I):
  """
  Fills holes within '2' objects using a flood-fill approach.

  Args:
    I: Input grid.

  Returns:
    Grid with filled holes.
  """
  h, w = len(I), len(I[0])
  def fill_recursive(grid, i, j):
    if i < 0 or i >= h or j < 0 or j >= w or grid[i][j] != 0:
      return grid
    grid[i][j] = 1
    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
      grid = fill_recursive(grid, i + di, j + dj)
    return grid

  grid_copy = [list(row) for row in I]
  for i in range(h):
    for j in range(w):
      if I[i][j] == 0 and any(I[ni][nj] == 2 for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)] for ni, nj in [(i + di, j + dj)] if 0 <= ni < h and 0 <= nj < w):
        grid_copy = fill_recursive(grid_copy, i, j)
  return tuple(tuple(row) for row in grid_copy)
 
10.0, 5.4507537, def gfefhfidceadehagadchdeacdadicbhj(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2: 
      for i in range(uppermost(obj), lowermost(obj) + 1): 
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          if index(filled, (i, j)) == 0 and index(filled, (i, j - 1)) == 2:
            filled = fill(filled, 1, {(i, j)}) 
  return filled
 
12.0, 12.672857, def fcibacefciaaecgaaeaaddebgajgfcab(I):
  mirrored = dmirror(I)
  filled = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 0 and I[i][j - 1] == 2 and mirrored[j][i - 1] == 2:
        filled = fill(filled, 1, {(i, j)})
  return filled
 
11.0, 13.307955, def hcccdcjjdgdbecjeadeefbjbjefiabbc(I):
  filled = I
  twos = ofcolor(I, 2)
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 0 and {(i, j - 1)} & twos and {(i, j + 1)} & twos:
        filled = fill(filled, 1, {(i, j)})
  return filled
 
42.0, 20.71745, def fjejciaeicdeeghbbicgafaeaijfcica(I):
  return paint(I, recolor(1, mfilter(objects(I, True, False, True), lambda obj: color(obj) == 2 and inbox(obj))))
 
53.666666666666664, 29.735636, def dggiagbcaiheeebcaaeacfjcfbedbghj(I):
  O = I
  for obj in objects(I, T, F, T):
    outline = box(obj) 
    O = cover(O, obj) # Remove the object
    O = underfill(O, 1, outline)  # Fill within the outline
  return O
 
9.0, 5.9734793, def hfdeehebjgddeaicibecadbceffahaje(I):
  objs = objects(I, T, F, T) # Extract objects, excluding background
  for i in range(1, len(I)-1): # Iterate over inner rows of the grid
    for j in range(1, len(I[0])-1): # Iterate over inner columns of the grid
      if index(I, (i, j)) == mostcolor(I): # If the current cell is background
        if any(contained((i,j), inbox(obj)) for obj in objs): # Check if it's inside any object's inbox
          I = fill(I, 1, {(i, j)}) # Fill the cell with '1'
  return I 
 
16.333333333333332, 4.999159, def gffdgdffjcfbeiiiaiacebjdgacjcbdc(I):
  objs = objects(I, T, F, T)  # Extract objects
  all_inboxes = mfilter(apply(inbox, objs), identity)  # Find all object inboxes
  to_fill = all_inboxes - mfilter(objs, toindices)  # Find cells inside inboxes but not part of objects
  return fill(I, 1, to_fill) # Fill those cells with '1'
 
11.333333333333334, 4.806022, def hjdfbaedaiceedecjeacefdabahbddcc(I):
    return underfill(I, 1, mfilter(apply(inbox, objects(I, T, F, T)), identity)) 
 
11.666666666666666, 5.090225, def fjdefjagahafeijeiaciebcfdeggfdhi(I):
  objs = objects(I, True, False, False) # Identify all objects in the grid
  twos = colorfilter(objs, 2) # Filter for objects consisting only of '2'
  filled = I # Initialize the output grid as a copy of the input
  for obj in twos:
    for i in range(uppermost(obj), lowermost(obj) + 1): # Iterate over rows of each '2' object
      for j in range(leftmost(obj) + 1, rightmost(obj) + 1): # Iterate over columns, excluding the leftmost one
        if index(filled, (i, j)) == 0 and index(filled, (i, j - 1)) == 2: # Check for empty cell with '2' to its left
          filled = fill(filled, 1, {(i, j)}) # Fill the cell with '1'
  return filled
 
15.666666666666666, 9.221744, def gdddacdggehiefcfafgjaieabaabgbcg(I):
  def is_inner_pixel(i, j):
    return index(I, (i, j)) == mostcolor(I) and any(index(I, n) != mostcolor(I) for n in neighbors((i, j)))

  inner_indices = frozenset((i, j) for i in range(1, height(I)-1) for j in range(1, width(I)-1) if is_inner_pixel(i, j))
  return fill(I, 1, inner_indices)
 
40.666666666666664, 25.981825, def idbjbifjabgfeabfigjcfefjhhfcddad(I):
  def fill_object_inbox(obj):
    return recolor(1, inbox(obj)) if color(obj) == 2 else obj

  filled_objs = apply(fill_object_inbox, objects(I, True, False, True))
  return paint(canvas(mostcolor(I), shape(I)), merge(filled_objs))
 
43.333333333333336, 15.652205, def gfbhijecddgjeggejacehedciddbchbb(I):
  def fill_if_inner(i, j):
    return 1 if index(I, (i, j)) == mostcolor(I) and any(index(I, (ni, nj)) != mostcolor(I) for ni, nj in neighbors((i, j))) else index(I, (i, j))

  new_grid = tuple(tuple(fill_if_inner(i, j) for j in range(width(I))) for i in range(height(I)))
  return new_grid
 
12.333333333333334, 6.555199, def cbecdfacfhahebiebfddbjcfdaahaebi(I):
  O = I
  for obj in objects(I, F, F, T):
    indices = toindices(obj)
    inbox_indices = inbox(indices) 
    O = underfill(O, 1, inbox_indices)
  return O
 
30.333333333333332, 7.620897, def iieebdegedfdeidbbfcehhdbbfbegdbd(I):
  O = I
  for obj in objects(I, F, F, T):
    for i in range(height(obj)):
      for j in range(width(obj)):
        if (i,j) in delta(obj):
          O = fill(O, 1, {(uppermost(obj)+i, leftmost(obj)+j)})
  return O
 
40.666666666666664, 25.981825, def eaccebceaedaeedficdibjeahhejdcea(I):
  O = canvas(mostcolor(I), shape(I))
  for obj in objects(I, F, F, T):
    O = paint(O, recolor(1, inbox(toindices(obj))))
  return O
 
19.666666666666668, 9.690103, def eebdcgcgaddjechbbedagdfjddijabdd(I):
  O = I
  for obj in objects(I, True, False, True):
    O = paint(O, recolor(1, delta(inbox(obj))))
  return O
 
40.666666666666664, 19.757357, def fbdjcdiaacfbefheaaeabgeeejbiejaa(I):
  def process_object(obj):
    return recolor(1,  frozenset((ni, nj) for i, j in inbox(obj) if index(I, (i, j)) == mostcolor(I) for ni, nj in neighbors((i, j)) if index(I, (ni, nj)) != mostcolor(I)))
  return paint(I, merge(apply(process_object, objects(I, True, False, True)))) 
 
15.0, 8.804194, def bacbadabjdcbechcijfgjfdcebbedace(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if index(I, (i, j)) == mostcolor(I) and any(index(I, (ni, nj)) != mostcolor(I) for ni, nj in dneighbors((i, j))):
        O = fill(O, 1, {(i, j)})
  return O
 
9.333333333333334, 5.4137588, def fajccaccadedejfdjifaabjgbbhdeeac(I):
  """
  Fills enclosed holes within objects of color 2 with color 1.
  """
  filled = I
  for obj in objects(I, True, False, True):
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == 0 and all(index(I, (i, j) + offset) == 2 for offset in [(-1, 0), (1, 0), (0, -1), (0, 1)] if (i, j) + offset in asindices(I)):
          filled = fill(filled, 1, {(i, j)})
  return filled
 
19.333333333333332, 14.437743, def baibiadfffcaedefahgdfebahejecjij(I):
  objs = objects(I, True, False, False)
  new_grid = canvas(0, shape(I))
  for obj in colorfilter(objs, 2):
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == 0 and index(I, (i, j - 1)) == 2:
          new_grid = paint(new_grid, {(1, (i, j))})
        else:
          new_grid = paint(new_grid, {(index(I, (i, j)), (i, j))})
  return new_grid
 
19.666666666666668, 5.473286, def bhbhiegfahgbeeccbdibaabibdfbfabe(I):
  def process_object(obj):
    return recolor(1, frozenset(loc for loc in delta(toindices(obj)) if any(index(I, n) != mostcolor(I) for n in neighbors(loc))))
  return paint(I, merge(apply(process_object, objects(I, True, False, True))))
 
11.0, 12.340655, def baadfejcdfeheeedacjfbcfecachfeed(I):
  O = I
  for obj in objects(I, T, F, T):
    for i in range(uppermost(obj) + 1, lowermost(obj)):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if (i, j) not in toindices(obj):
          O = fill(O, 1, {(i, j)})
  return O
 
9.333333333333334, 5.593978, def dbehccajcbaceeciifjdadchaedfdieb(I):
  objs = colorfilter(objects(I, True, False, False), 2)
  filled_cells = set()
  for obj in objs:
    for i in range(uppermost(obj) + 1, lowermost(obj) + 1):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if index(I, (i, j)) == 0 and index(I, (i, j - 1)) == 2:
          filled_cells.add((1, (i, j)))
  return paint(I, frozenset(filled_cells))
 
16.666666666666668, 14.982062, def bcdfibcaafcdecccbjdgegjhfaaecaca(I):
  O = I
  for obj in objects(I, T, F, T):
    for cell in delta(toindices(obj)):
      if all(n in toindices(obj) or index(I, n) == mostcolor(I) for n in dneighbors(cell)):
        O = fill(O, ONE, {cell})
  return O
 
41.666666666666664, 17.717262, def dcdgiddffgabeajbicfabebdcgihifbi(I):
  objs = fgpartition(I)
  mask = canvas(0, shape(I))  # Create a blank canvas
  for obj in objs:
    mask = paint(mask, recolor(1, difference(inbox(obj), box(obj))))
  return cellwise(I, mask, 1) # Use cellwise to combine grids
 
12.0, 7.0374794, def ggcdeaciicdeehegihabcefdacjaafec(I):
  bg = mostcolor(I)
  min_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = paint(canvas(bg, shape(I)), largest_obj)
  for i, j in ofcolor(I, min_color):
    closest_cell = argmin(toindices(largest_obj), lambda x: abs(x[0]-i) + abs(x[1]-j))
    line = connect((i, j), closest_cell)
    O = underfill(O, min_color, line)
  return O
 
10.0, 6.6988635, def cbiebbdfebejeccfafbefddhijebabca(I):
  O = I
  min_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), lambda obj: (size(obj), -ulcorner(obj)[0], -ulcorner(obj)[1]))
  for loc in ofcolor(I, min_color):
    connected = False
    for dir in [(0,1),(0,-1),(1,0),(-1,0)]:
      for dist in range(1, max(len(I), len(I[0]))):
        neighbor = (loc[0] + dir[0]*dist, loc[1] + dir[1]*dist)
        if neighbor in toindices(largest_obj):
          O = underfill(O, min_color, connect(loc, neighbor))
          connected = True
          break
      if connected: break
  return O
 
4.666666666666667, 2.9113119, def afdffadhejahedcfbcdffcffcafidcaa(I):
    min_color = leastcolor(I)
    largest_obj = argmax(objects(I, T, F, T), size)
    O = I
    for cell in toindices(largest_obj):
      for target in ofcolor(I, min_color):
        if manhattan(initset(cell), initset(target)) == abs(cell[0] - target[0]) + abs(cell[1] - target[1]):
          path = connect(cell, target)
          O = underfill(O, min_color, path)
    return O
 
8.333333333333334, 3.6401582, def deebafdgceffecciahjeicggfdcehfhc(I):
  objs = objects(I, True, False, False) # Identify all objects in the grid
  filled = I  # Initialize the output grid as a copy of the input
  for obj in objs:
    if color(obj) == 2: # Only process objects with color '2'
      top_row = uppermost(obj)  # Get the top row index of the object
      for i in range(top_row + 1, lowermost(obj)): # Iterate through rows within the object, excluding the top row
        left_j = leftmost(obj) # Find the leftmost column of the object in the current row
        right_j = rightmost(obj) # Find the rightmost column of the object in the current row
        for j in range(left_j + 1, right_j): # Iterate through columns between the leftmost and rightmost in the current row
          if index(filled, (i, j)) == 0 and index(filled, (top_row, j)) == 2: # Check if the cell is empty (0) and the cell above it in the top row is part of the object (2)
            filled = fill(filled, 1, {(i, j)}) # If both conditions are met, fill the cell with '1'
  return filled
 
11.666666666666666, 5.2707753, def ccfjecbacdbaeciebbajehfachfdbcji(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      min_j, max_j = leftmost(obj), rightmost(obj)
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        if all(index(filled, (i, j)) == 2 for j in range(min_j, max_j + 1)): # Check if the entire row is filled with '2's
          filled = fill(filled, 1, {(i, j) for j in range(min_j + 1, max_j)}) # If yes, fill the row's interior with '1's
  return filled
 
11.0, 4.6183705, def bieiabacbgfceeehagjfagffiifibdbc(I):
  objs = objects(I, True, False, False) 
  filled = I
  for obj in objs:
    if color(obj) == 2 and len(obj) > 1: # Only process if the object has more than one cell (meaning it has an interior)
      for i in range(uppermost(obj) + 1, lowermost(obj)):
        for j in range(leftmost(obj) + 1, rightmost(obj)):
          if index(filled, (i, j)) == 0:
            filled = fill(filled, 1, {(i, j)})
  return filled
 
9.0, 5.352653, def ggcacjecccegegbjbghafeabgaidcadb(I):
  filled = I 
  for i in range(1, len(I) - 1): # Iterate through rows excluding the top and bottom rows
    for j in range(1, len(I[0]) - 1): # Iterate through columns excluding the leftmost and rightmost columns
      if index(filled, (i, j)) == 0 and index(filled, (i - 1, j)) == 2 and index(filled, (i + 1, j)) == 2:
        # Check if a cell is empty and has '2' both above and below it
        filled = fill(filled, 1, {(i, j)})  # Fill with '1' if conditions are met
  return filled
 
10.666666666666666, 3.9377217, def fdcdiedjdeaeeeegbdecgbeecefagabi(I):
  objs = colorfilter(objects(I, True, False, False), 2) # Find all '2' objects
  filled_cells = set()
  for obj in objs:
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(leftmost(obj) + 1, rightmost(obj)):
        if (index(I, (i, j)) == 0 and 
           (index(I, (i, j - 1)) == 2 or index(I, (i - 1, j - 1)) == 2 or index(I, (i + 1, j - 1)) == 2) and # Check horizontal and diagonal adjacency to '2'
           (index(I, (i - 1, j)) == 2 or index(I, (i + 1, j)) == 2)): # Check vertical adjacency to '2'
          filled_cells.add((1, (i, j)))
  return paint(I, frozenset(filled_cells)) # Fill the cells
 
12.333333333333334, 5.496804, def ifffacfachafeegaicghcbabgjehfcae(I):
  O = I
  for i in range(1, len(I) - 1):
    for j in range(1, len(I[0]) - 1):
      if (I[i][j] == 0 and 
         (I[i][j - 1] == 2 or I[i - 1][j - 1] == 2 or I[i + 1][j - 1] == 2) and 
         (I[i - 1][j] == 2 or I[i + 1][j] == 2)):
        O = fill(O, 1, {(i, j)})
  return O
 
20.333333333333332, 5.2702065, def feiahghjbhfaedejjchfddcagigacdda(I):
  filled = I
  twos = ofcolor(I, 2)
  for i, j in twos:
    for k in range(j + 1, len(I[0])):
      if I[i][k] == 0:
        filled = fill(filled, 1, {(i, k)})
      else:
        break
  return filled 
 
10.0, 6.6988635, def eaajafcchefceafeacejehddebdheicb(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for i in range(uppermost(obj), lowermost(obj) + 1):
        start = leftmost(obj)
        while start < len(I[0]) and (i, start) not in toindices(obj):
          start += 1
        for j in range(start, len(I[0])):
          if filled[i][j] == 0:
            filled = fill(filled, 1, {(i, j)})
          else: 
            break
  return filled
 
16.666666666666668, 6.4018264, def abfeedcbcdfeegjcaahbjahfbdafhgbj(I):
  filled = I
  twos = ofcolor(I, 2) 
  for i, j in twos:
    frontier = hfrontier((i, j))
    for row, col in frontier:
      if col < len(I[0]):
        if filled[row][col] == 0:
          filled = fill(filled, 1, {(row, col)})
        else:
          break
  return filled
 
49.666666666666664, 45.97182, def fcabfebfbdfjefffjijeiffdbhdfbgfc(I):
  filled = I
  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        filled = fill(filled, 1, {(i, k) for k in range(j, len(I[0]))})
        break
  return filled
 
14.666666666666666, 6.633049, def bfabciecfcgcejcdacecbhjbgfbagegc(I):
  objs = objects(I, True, False, True)  # Extract connected objects (excluding background)
  filled = I
  for obj in objs:
    if color(obj) == 2:  # Focus on objects with color '2'
      for i, j in toindices(obj): # Iterate over object's cell indices
        if j + 1 < width(I) and index(filled, (i, j + 1)) == 0: # Check for '0' to the right within grid bounds
          filled = fill(filled, 1, {(i, j + 1)})  # Fill with '1'
  return filled
 
12.0, 6.6889005, def bdddaaaaefgaebdcijabgdifjafcafde(I):
  obj_indices = toindices(extract(objects(I, True, False, True), lambda obj: color(obj) == 2))
  right_indices = frozenset((i, j + 1) for i, j in obj_indices if j + 1 < width(I))
  fill_indices = sfilter(right_indices, lambda loc: index(I, loc) == 0)
  return paint(I, recolor(1, fill_indices))
 
5.666666666666667, 3.168898, def cbcacdfdjebeedgajafbicdcfhediebf(I):
  min_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = I
  for cell in toindices(largest_obj):
    closest_target = argmin(ofcolor(I, min_color), lambda target: manhattan(initset(cell), initset(target)))
    path = connect(cell, closest_target)
    O = underfill(O, min_color, path)
  return O
 
33.333333333333336, 20.098246, def jecaejibbedcechcbjjcdfjbfffcahfc(I):
  min_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = cover(I, largest_obj) 
  for cell in toindices(largest_obj):
    closest_target = min(ofcolor(I, min_color), key=lambda target: manhattan(initset(cell), initset(target)), default=cell)
    path = connect(cell, closest_target)
    O = paint(O, recolor(min_color, path)) 
  return O
 
15.666666666666666, 6.146537, def giagcbgaabhieaafaigbfcbjifcgjccb(I):
  objs = objects(I, True, False, False)  # Identify objects
  filled = I  # Initialize output as input
  for obj in objs:
    if color(obj) == 2:  # Target color '2' objects
      top_row = uppermost(obj)  # Get top row index
      for j in range(leftmost(obj) + 1, rightmost(obj)):  # Iterate within horizontal boundaries
        if index(I, (top_row, j)) == 2:  # Check if corresponding top cell is '2'
          for i in range(top_row + 1, lowermost(obj)):  # Fill vertically downwards
            filled = fill(filled, 1, {(i, j)}) 
  return filled
 
12.0, 4.8321114, def aheafjdiibbieihfbebajadbbahfhgdb(I):
  filled = I
  for i in range(1, height(I)): # Iterate from second row onwards
    for j in range(1, width(I) - 1): # Iterate within horizontal grid boundaries
      if index(I, (i - 1, j)) == 2 and index(I, (i, j)) == 0: # Check above cell and current cell
        filled = fill(filled, 1, {(i, j)})
  return filled
 
21.0, 5.7317224, def hfeabgdaggfeediaafdjiicbiifbfcji(I):
  objs = objects(I, True, False, True)  # Get connected objects of '2's (excluding background)
  fillable = set()
  for obj in objs:
    for loc in toindices(obj):  
      if any(n in toindices(delta(obj)) for n in dneighbors(loc)): # Check if any direct neighbor is outside the object
        fillable.update((1, n) for n in backdrop(obj) if index(I, n) == 0)  # Fill empty cells in the object's bounding box
        break # Move to the next object once filling starts
  return paint(I, frozenset(fillable)) 
 
11.0, 5.210432, def fidcagfbaiafebcbiebcdaebdefafeca(I):
  two_locs = ofcolor(I, 2)
  fillable = set()
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 0: 
        if (i, j) in two_locs: continue  # Skip if already a '2'
        if any((i, k) in two_locs for k in range(max(0, j-2), min(j+3, len(row)))) and \
           any((k, j) in two_locs for k in range(max(0, i-2), min(i+3, len(I)))):
            fillable.add((i, j))
  return paint(I, recolor(1, fillable))
 
14.666666666666666, 6.633049, def fcjgdgaafddbeiahjbfbjfhehbcegcdd(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for i, j in toindices(obj):
        if j + 1 < len(I[0]) and index(filled, (i, j + 1)) == 0:
          filled = fill(filled, 1, {(i, j + 1)})
  return filled
 
22.0, 5.1534534, def fdaijidfadgeebdgaibfgieebcfcaadb(I):
  return tuple(
    tuple(
      1 if j + 1 < len(row) and row[j + 1] == 0 and v == 2 else v
      for j, v in enumerate(row)
    )
    for row in I
  )
 
23.333333333333332, 8.528682, def eibdcbgaefcdedfibcdcecebffjbehfc(I):
  target_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), lambda obj: size(obj)) 
  O = I
  for cell in toindices(largest_obj):
    target_cells = ofcolor(I, target_color)
    nearest_target = argmin(target_cells, lambda t: manhattan(initset(cell), initset(t)))
    line = connect(cell, nearest_target)
    O = fill(O, target_color, intersection(line, backdrop(largest_obj)))
  return O
 
12.333333333333334, 4.7678103, def bfagdfbjbaffebdaifajhidhgebaadeh(I):
  filled = I
  for i in range(len(I) - 1):
    for j in range(len(I[0])):
      if index(I, (i, j)) == 2 and index(I, (i + 1, j)) == 0:
        filled = fill(filled, 1, {(i + 1, j)})
  return filled
 
10.0, 6.6988635, def gaicfagdheeaefaeadahchafhbfaiehd(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      top_row = uppermost(obj)
      bottom_row = lowermost(obj)
      for j in range(leftmost(obj), rightmost(obj) + 1):
        if top_row < bottom_row and index(I, (top_row, j)) == 2 and index(I, (top_row + 1, j)) == 0:
          filled = fill(filled, 1, {(top_row + 1, j)})
  return filled
 
15.0, 5.3830914, def adfdecbaaaibefdcjjcbjecaedcdcaff(I):
  filled = canvas(0, shape(I))
  for i in range(len(I)):
    for j in range(len(I[0])):
      if index(I, (i, j)) == 2:
        filled = paint(filled, {(2, (i, j))})
        if i + 1 < len(I) and index(I, (i + 1, j)) == 0:
          filled = paint(filled, {(1, (i + 1, j))})
  return filled
 
9.333333333333334, 5.66938, def eeadeghfeacfedddicghbbgjfhccbjef(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      top = uppermost(obj)
      for x in range(leftmost(obj), rightmost(obj) + 1):
        if index(I, (top, x)) == 2 and top + 1 < len(I) and index(I, (top + 1, x)) == 0:
          filled = fill(filled, 1, {(top + 1, x)})
  return filled
 
26.333333333333332, 9.867559, def agffffbcdaccefdgieeaagaecfecfbbf(I):
  two_indices = ofcolor(I, 2)
  fillable = set()
  for i, j in asindices(I):
    if index(I, (i, j)) == 0 and ((index(I, (i, j - 1)) == 2 and index(I, (i, j + 1)) == 2) or 
                                 any((n[0], n[1]) in two_indices for n in dneighbors((i, j)))):
      fillable.add((i, j))
  return paint(I, recolor(1, frozenset(fillable)))
 
50.0, 10.643318, def dghcaedhbadhefdbjccddhafdffeeajg(I):
    return tuple(
        tuple(
            1 if (
                j > 0 and row[j - 1] == 2 and j < len(row) - 1 and row[j + 1] == 2
            ) or (
                i > 0 and I[i - 1][j] == 2 or i < len(I) - 1 and I[i + 1][j] == 2 or
                j > 0 and I[i][j - 1] == 2 or j < len(row) - 1 and I[i][j + 1] == 2
            ) else v
            for j, v in enumerate(row) if v == 0
        ) + tuple(v for j, v in enumerate(row) if v != 0)
        for i, row in enumerate(I)
    ) 
 
53.666666666666664, 42.69985, def echjebcbbfdeeccaieffehehfbdfdhac(I):
    twos = set([(i, j) for i, row in enumerate(I) for j, val in enumerate(row) if val == 2])
    return tuple(
        tuple(
            1 if (
                 (i, j+1) in twos and (i, j-1) in twos
              ) or any(((i+di, j+dj) in twos) for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)])
              else val
            for j, val in enumerate(row)
        )
        for i, row in enumerate(I)
    )
 
15.666666666666666, 4.9353213, def hdacgdieafabeafhbfbbbadahfajffag(I):
  objs = objects(I, True, False, False)
  fill_area = set()
  for obj in objs:
    if color(obj) == 2:
      for i in range(uppermost(obj), lowermost(obj) + 1):
        j = rightmost(obj) + 1
        while j < len(I[0]) and I[i][j] == 0:
          fill_area.add((i, j))
          j += 1
  return fill(I, 1, frozenset(fill_area))
 
11.333333333333334, 4.378018, def ifhfidjdihaceediichdfcdhjifcgjgd(I):
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      for i in range(uppermost(obj), lowermost(obj) + 1):
        for j in range(leftmost(obj), rightmost(obj)):
          if index(I, (i, j)) == 2:
            if j + 1 < width(I) and index(I, (i, j + 1)) == 0:
              I = fill(I, 1, {(i, j + 1)})
  return I
 
11.333333333333334, 5.383675, def abfiagcgdeaaehfeiaddehhcedaefdbc(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for j in range(width(obj)):
        if index(I, add((uppermost(obj), j), ulcorner(obj))) == 2:
          fill_loc = add((uppermost(obj) + 1, j), ulcorner(obj))
          filled = fill(filled, 1, {fill_loc})
  return filled
 
11.0, 5.249976, def ggbfhchabbbcecbhbebefhdcgeehbfde(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      top_row = crop(I, ulcorner(obj), (1, width(obj)))[0]
      for j, v in enumerate(top_row):
        if v == 2:
          filled = fill(filled, 1, {(uppermost(obj) + 1, leftmost(obj) + j)}) 
  return filled
 
10.0, 6.6988635, def ceeebibebcdfeceeibidjbdgfegheggc(I):
  fillable = mfilter(asindices(I), lambda loc: index(I, loc) == 0 and 
                    (sum(index(I, n) == 2 for n in dneighbors(loc)) >= 3))
  return paint(I, recolor(1, fillable))
 
21.0, 7.037651, def cffjdebcceedebjfjfbhcfaghfdbaabj(I):
  filled = I
  for i in range(len(I) - 1):
    for j in range(len(I[0]) - 1):
      if I[i][j] == 2:
        filled = fill(filled, 1, {(i + 1, j + 1)})
  return filled 
 
34.0, 15.0528, def gedabfeeeaabeeahigbdhacjecaddhhh(I):
  bg = mostcolor(I)
  min_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = paint(canvas(bg, shape(I)), recolor(min_color, largest_obj))
  for cell in toindices(largest_obj):
    target = argmin(ofcolor(I, min_color), lambda t: manhattan(initset(cell), initset(t)))
    O = underfill(O, min_color, connect(cell, target))
  return O
 
10.666666666666666, 4.9800053, def hdfbcbdcehieechbaddfacbghbajjdfj(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      j = rightmost(obj) + 1
      while j < len(I[0]) and index(I, (lowermost(obj), j)) == 0:
        filled = paint(filled, {(1, (lowermost(obj), j))}) # Paint individual tail cells
        j += 1
  return filled
 
21.0, 5.7317224, def cehccdaiecdfeggcjeccbbccbdihbdgg(I):
  objs = objects(I, True, False, False) # Get all objects
  filled = I # Initialize filled grid
  for obj in objs: # Iterate through objects
    if color(obj) == 2: # Check if object is made of '2's
      for i in range(uppermost(obj), lowermost(obj) + 1): # Iterate through rows
        for j in range(leftmost(obj), rightmost(obj) + 1): # Iterate through columns
          if index(filled, (i, j)) in [0, 1]: # Fill '0's and '1's within the object and to the right
            filled = fill(filled, 1, {(i, j)})
  return filled
 
22.333333333333332, 20.76369, def gjaccbbcbeadejhciaicccaghdbdfjja(I):
  obj = next(obj for obj in objects(I, True, False, False) if color(obj) == 2)
  return paint(I, recolor(1, backdrop(shift(obj, (0, 1))) | toindices(obj)))
 
28.0, 10.107778, def eeafcaieaeddebfebbccefdhjddfifeg(I):
  filled = I
  for i, row in enumerate(I):
    for j, val in enumerate(row):
      if val == 2:
        for di, dj in [(0, 0), (0, 1), (1, 0), (1, 1), (-1, 0), (-1, 1), (0, -1)]:
          if 0 <= i+di < len(I) and 0 <= j+dj < len(row) and filled[i+di][j+dj] in [0, 1]:
            filled = fill(filled, 1, {(i+di, j+dj)})
  return filled
 
15.0, 6.7560215, def hbcbegacedhjehddifhebbfadbfhadaj(I):
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      for i, j in toindices(obj):
        if j + 1 < width(I) and index(I, (i, j + 1)) == mostcolor(I):
          I = fill(I, 1, {(i, j + 1)})
  return I
 
14.333333333333334, 6.8075995, def cdecbbdaejeeeffijeehfgbdadfbfdaa(I):
  for j in range(width(I) - 1):
    for i in range(height(I)):
      if index(I, (i, j)) == 2 and index(I, (i, j + 1)) == mostcolor(I):
        I = fill(I, 1, {(i, j + 1)})
  return I
 
23.333333333333332, 12.04446, def ebhhbghdfdcaedbabdecdefdggaacdfe(I):
  def get_tail(obj, grid):
    i = lowermost(obj)
    j = rightmost(obj) + 1
    tail = set()
    while j < len(grid[0]) and index(grid, (i, j)) == 0:
      tail.add((i, j))
      j += 1
    return tail
  
  objs = objects(I, True, False, False)
  tails = mfilter(objs, lambda obj: get_tail(obj, I) if color(obj) == 2 else set())
  return fill(I, 1, tails)
 
14.666666666666666, 7.1876693, def gddbdbiaihdaebjbiabbbejafefagcea(I):
    obj = extract(objects(I, True, False, True), lambda obj: color(obj) == 2)
    return paint(I, recolor(1, frozenset((i, j + 1) for i, j in toindices(obj) if j + 1 < width(I))))
 
24.0, 7.5638733, def bfjjiggbegfceebeicadfehfcieadefa(I):
  target_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = paint(canvas(mostcolor(I), shape(I)), largest_obj) 
  for cell in toindices(largest_obj):
    closest_target = argmin(ofcolor(I, target_color), lambda t: manhattan(initset(cell), initset(t)))
    O = paint(O, recolor(target_color, connect(cell, closest_target)))
  return O
 
21.0, 9.181197, def cefabdiddcdfehbbjcfbfdddaagagaha(I):
  target_color = leastcolor(I)
  target_locations = ofcolor(I, target_color)
  largest_obj = argmax(objects(I, T, F, T), size)
  O = I
  for cell in toindices(largest_obj):
    closest_target_loc = argmin(target_locations, lambda t: manhattan(initset(cell), initset(t)))
    direction = gravitate(initset(cell), initset(closest_target_loc))
    O = underfill(O, target_color, shoot(cell, direction))
  return O
 
35.0, 25.024668, def gcjefgafeefcefggjibfaaaeehjbebcc(I):
  target_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  path_grid = canvas(0, shape(I))
  for cell in toindices(largest_obj):
    path_grid = fill(path_grid, 1, connect(cell, argmin(ofcolor(I, target_color), lambda t: manhattan(initset(cell), initset(t)))))
  return cellwise(I, path_grid, target_color) 
 
18.666666666666668, 8.606092, def jdcbcdahigfceciiidaafbjdfihbgabe(I):
  target_color = leastcolor(I)
  largest_obj = argmax(objects(I, T, F, T), size)
  path = frozenset()
  for cell in toindices(largest_obj):
    path = path | connect(cell, argmin(ofcolor(I, target_color), lambda t: manhattan(initset(cell), initset(t))))
  return paint(canvas(mostcolor(I), shape(I)), recolor(target_color, path) | largest_obj)
 
15.0, 5.1147118, def dbaecedaecjdebdgbcjcfgijceedjdji(I):
  bg = mostcolor(I)
  largest = argmax(objects(I, True, False, True), size)
  modified_grid = [[v if (i, j) not in delta(toindices(largest)) or index(I, (i, j)) != bg or not any(n in toindices(largest) for n in dneighbors((i, j))) else 1 for j, v in enumerate(row)] for i, row in enumerate(I)]
  return tuple(tuple(row) for row in modified_grid) 
 
27.0, 5.912856, def caccgbehhiabefbjjjfhidihebhdbibi(I):
  objs = objects(I, True, False, False) # Identify objects of '2's
  filled = I 
  for obj in objs:                     # Iterate through each object
    if color(obj) == 2:                 # Ensure the object is made of '2's
      shifted_obj = shift(toindices(obj), DOWN) # Project the object downwards
      filled = paint(filled, recolor(1, shifted_obj)) # Fill the projected area with '1's
  return filled 
 
11.0, 5.8573895, def edafhfdeaafiedgdijdgjfgdeidddcae(I):
  objs = objects(I, True, False, False)  # Identify objects of '2's
  filled = I
  for obj in objs:                      # Iterate through each object
    if color(obj) == 2:                # Ensure the object is made of '2's
      bottom_row = lowermost(obj)      # Find the bottom row of the object
      for j in range(leftmost(obj), rightmost(obj) + 1): # Iterate within object's width
        if (bottom_row + 1, j) in asindices(I):  # Check if within grid bounds
          filled = fill(filled, 1, {(bottom_row + 1, j)}) # Fill below with '1'
  return filled
 
68.66666666666667, 63.167038, def eecafbbaffeaefcbbffeajdiafdfbbfc(I):
  return paint(I, recolor(1, product(range(height(I)), range(width(I) - 1))))
 
20.333333333333332, 5.2702065, def efafjbchgjfheffeibheeefhddcghcad(grid):
  for i in range(len(grid)):
    for j in range(len(grid[0])):
      if grid[i][j] == 2:
        k = j + 1
        while k < len(grid[0]) and grid[i][k] == 0:
          grid = fill(grid, 1, {(i, k)})
          k += 1
  return grid
 
20.333333333333332, 12.232119, def cefbedjjacefejbabebcacbccbdcicej(grid):
  for obj in colorfilter(objects(grid, True, False, False), 2):
    grid = fill(grid, 1, connect((lowermost(obj), rightmost(obj)), (lowermost(obj), len(grid[0]) - 1)))
  return grid
 
14.666666666666666, 6.633049, def bdheibceiidcefcaiadfbahcbdcjijfc(I):
  objs = objects(I, True, False, True)
  for obj in objs:
    if color(obj) == 2:
      for i, j in toindices(obj):
        if j + 1 < len(I[0]) and index(I, (i, j + 1)) == 0:
          I = fill(I, 1, {(i, j + 1)})
  return I
 
12.333333333333334, 4.932276, def ddbiebidcjffefcdjdhadicdhbeafaaj(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      shifted_obj = shift(obj, (0, 1))
      for i, j in toindices(shifted_obj):
        if index(I, (i, j)) == 0 and (i, j - 2) in toindices(obj):
          filled = fill(filled, 1, {(i, j)})
  return filled
 
17.333333333333332, 6.679906, def ccabbjdfjdbfedfajdfdbdaebidbfijj(I):
  objs = objects(I, True, False, True)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      filled = paint(filled, recolor(1, frozenset((i, j + 1) for i, j in toindices(obj) if j + 1 < width(I) and index(I, (i, j + 1)) == 0)))
      filled = paint(filled, recolor(1, frozenset((i + 1, j) for i, j in toindices(obj) if i + 1 < height(I) and index(I, (i + 1, j)) == 0)))
  return filled
 
21.0, 5.7317224, def adccjbideifbebhdbcbdccbeeffbbcfa(I):
  return paint(I, recolor(1, difference(delta(ofcolor(I, 2)), ofcolor(I, 2))))
 
15.333333333333334, 5.5575747, def biabcfabiijaefcciedfaicfdcdffegf(I):
  O = I
  target = leastcolor(I)
  largest = argmax(objects(I, T, F, T), size)
  for i, j in toindices(largest):
    closest = argmin(
      ofcolor(I, target),
      lambda t: abs(i - t[0]) + abs(j - t[1])
    )
    O = underfill(
      O,
      target,
      frozenset(
        (i + k * sign(closest[0] - i), j + k * sign(closest[1] - j))
        for k in range(abs(i - closest[0]) + abs(j - closest[1]) + 1)
      )
    )
  return O
 
37.333333333333336, 11.832536, def jcifbgbfcdegeaeejajedihacgdajdba(I):
  O = paint(
    fill(I, mostcolor(I), toindices(argmax(objects(I, T, F, T), size))), 
    recolor(leastcolor(I), argmax(objects(I, T, F, T), size))
  )
  return O
 
21.333333333333332, 6.532971, def cjbbebbcaffeeaggifdfgcedgjedaedd(grid):
  for obj in colorfilter(objects(grid, True, False, False), 2):
    grid = fill(grid, 1, product(range(uppermost(obj), lowermost(obj) + 1), range(rightmost(obj) + 1, len(grid[0]))))
  return grid
 
22.0, 8.130759, def eibfcfbcidgieffajffbfeidchfeaaef(I):
  def is_corner(loc):
    return index(I, loc) == 0 and sum(1 for n in neighbors(loc) if index(I, n) == 2) == 3
  corner_indices = frozenset(loc for loc in asindices(I) if is_corner(loc))
  return paint(I, recolor(1, corner_indices))
 
12.666666666666666, 6.0375896, def fagbdfdagheeebghafdeagfbefbdbfie(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      for j in range(leftmost(obj), rightmost(obj) + 1):
        for i in range(lowermost(obj) + 1, len(I)):
          if (i, j) in asindices(I) and filled[i][j] != 2:
            filled = fill(filled, 1, {(i, j)})
          else:
            break
  return filled
 
17.333333333333332, 5.006166, def cdafdjjfcefgecbcidfgjdafdebaeeec(I):
  objs = objects(I, True, False, False)
  filled = I
  for obj in objs:
    if color(obj) == 2:
      extension = shift(obj, DOWN)
      while len(extension) > 0:
        filled = underfill(filled, 1, toindices(extension))
        extension = shift(intersection(toindices(extension), asindices(filled)), DOWN)
  return filled
 
12.333333333333334, 4.7678103, def gahecaagbdfaeceaahfeeaebjabeecef(I):
  filled = I
  for i in range(len(I) - 1):
    for j in range(len(I[0])):
      if I[i][j] == 2 and filled[i + 1][j] != 2:
        filled = fill(filled, 1, {(i + 1, j)})
  return filled
 
15.0, 4.1408067, def cbeaiedcffcgegcgjcdfgbibejccdaib(I):
  filled = I
  for obj in objects(I, True, False, True):
    if color(obj) == 2:
      for (i, j) in delta(toindices(obj)):
        if index(filled, (i,j)) == 0 and any((abs(i-k) + abs(j-l) == 1) for (k,l) in toindices(obj)):
          if i == uppermost(obj) or i == lowermost(obj) or j == leftmost(obj) or j == rightmost(obj):
            filled = fill(filled, 1, {(i,j)})
  return filled
 
15.0, 5.670604, def fcgiacbjjfbgeecfacdacbhafffeebbb(grid):
  for i in range(len(grid)):
    for j in range(1, len(grid[0])):
      if index(grid, (i, j)) == 2 and index(grid, (i, j - 1)) == 2:
        grid = fill(grid, 1, {(i, k) for k in range(j + 1, len(grid[0])) if index(grid, (i, k)) == 0})
  return grid
 
12.0, 5.347849, def bjdibeefbdjcebbhihgcbbedcbficedh(grid):
  for obj in colorfilter(objects(grid, True, False, False), 2):
    rightmost_j = rightmost(obj)
    for i in range(uppermost(obj), lowermost(obj) + 1):
      if index(grid, (i, rightmost_j)) == 2 and index(grid, (i, rightmost_j - 1)) == 2:
        grid = fill(grid, 1, {(i, j) for j in range(rightmost_j + 1, len(grid[0])) if index(grid, (i, j)) == 0})
  return grid
 
11.333333333333334, 4.378018, def iacedgbbbegfedeejfjideaacebieede(I):
  objs = colorfilter(objects(I, True, False, False), 2)
  filled = frozenset()
  for obj in objs:
    for i in range(uppermost(obj), lowermost(obj) + 1):
      for j in range(leftmost(obj) + 1, rightmost(obj) + 1):
        if index(I, (i, j)) == 0 and index(I, (i, j - 1)) == 2:
          filled = insert((1, (i, j)), filled)
  return paint(I, filled)
 
9.333333333333334, 3.2733006, def afbddahdacbbedacacjecjdbgecjeihb(I):
  def right_fill(grid, start_j, i):
    j = start_j + 1
    while j < len(grid[0]) and grid[i][j] == 0:
      grid = fill(grid, 1, {(i, j)})
      j += 1
    return grid

  for i in range(len(I)):
    for j in range(len(I[0])):
      if I[i][j] == 2:
        I = right_fill(I, j, i)
        break 
  return I
 
41.666666666666664, 25.6942, def acbdheceihebeabgiaddeabedfecgbaj(I):
  def extend_object(obj):
    return toobject(combine(toindices(obj), shift(toindices(obj), DOWN)), I)
  return paint(I, recolor(1, merge(apply(extend_object, colorfilter(objects(I, True, False, False), 2))))) 
 
19.666666666666668, 5.9024673, def heiecdggefbhecefiddbaichaafeegfe(I):
  return paint(I, recolor(1, frozenset((i, j) for i in range(height(I)) for j in range(width(I)) 
                                          if index(I, (i, j)) == 0 and 
                                             any(index(I, n) == 2 for n in dneighbors((i, j))) and
                                             ((i == 0 or i == height(I) - 1) or (j == 0 or j == width(I) - 1))))) 
 
