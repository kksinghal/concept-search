0.1917041094196119, 56.805035, def cighagbebfddeiffibbbbcahgfeeegfi(I):
  # Find the largest object
  objs = objects(I, T, F, F) 
  largest_obj = argmax(objs, size)
  
  # Create a canvas filled with the background color
  bg_color = mostcolor(I)
  O = canvas(bg_color, shape(I))
  
  # Paint the largest object onto the canvas
  O = paint(O, largest_obj)
  return O
 
0.04860684266745333, 8.226893, def geeaejjdbjgceacgjhegjcffcaibgcdb(I):
  # Find all objects
  objs = objects(I, T, F, F)
  
  # Filter out the smallest object
  objs = remove(argmin(objs, size), objs)
  
  # Create a blank canvas
  O = canvas(0, shape(I))
  
  # Paint remaining objects onto the canvas
  for obj in objs:
    O = paint(O, obj)
  return O
 
0.05107060185185185, 11.40614, def cigffcabheeiedhhjbgediifgegbcfcf(I):
  # Crop the grid from the top-left corner, excluding the last row and column
  O = crop(I, (0, 0), (height(I)-1, width(I)-1))
  return O
 
0.14362231270713413, 10.3877125, def bidbaacehjfhedbajccbfadedgdfhfda(I):
  # Find the bounding box of all non-background cells
  bg = mostcolor(I)
  fg_indices = frozenset((i,j) for i in range(height(I)) for j in range(width(I)) if I[i][j] != bg)
  
  # Construct a new grid using the bounding box dimensions
  O = crop(I, ulcorner(fg_indices), (height(fg_indices), width(fg_indices)))
  return O
 
0.23324437467294612, 18.941435, def fdbjjaaebjccejebihacaffjfecdejdf(I):
  # Transpose the grid
  transposed = dmirror(I)
  
  # Remove empty rows and columns from the transposed grid
  compressed = compress(transposed)
  
  # Transpose back to original orientation and return
  O = dmirror(compressed)
  return O
 
0.012235315288663324, 3.2367241, def hjchbficdeabegibaaigjbgbbjibedch(I):
    x1 = objects(I, T, F, F)  # Identify all objects in the grid
    x2 = sizefilter(x1, 1)    # Filter for objects with size 1 (single cells)
    x3 = difference(x1, x2)   # Remove single-cell objects from the set of all objects
    O = paint(canvas(mostcolor(I), shape(I)), merge(x3)) # Paint the remaining objects onto a blank canvas
    return O
 
0.058535352881145496, 9.380909, def hcficacdajdeeegijihigbaijdfeiffb(I):
  single_pixels = merge(sizefilter(objects(I, T, T, T), 1))
  O = I
  for i, j in asindices(I):
    if (i, j) in single_pixels:
      O = fill(O, mostcolor(I), {(i, j)})
  return O 
 
0.058535352881145496, 9.380909, def ciafcibgecfdefieacebceeeahfcgdjb(I):
  x1 = frontiers(I)  # Identify all frontier objects
  x2 = sfilter(x1, vline)  # Filter for vertical line frontiers
  x3 = apply(toindices, x2)  # Get indices of vertical frontiers
  x4 = merge(x3)  # Merge indices into a single set
  x5 = mostcolor(I)  # Find the background color
  O = fill(I, x5, x4)  # Fill the frontier indices with background color
  return O
 
0.17969039338673165, 12.052929, def ahecbedebjfceajhieffedfacaebheib(I):
  x1 = compress(I)  # Compress the grid, removing all frontiers
  x2 = shape(I)  # Get the original shape
  x3 = shape(x1)  # Get the shape after compression
  x4 = subtract(x2, x3)  # Calculate the difference in dimensions
  x5 = astuple(ZERO, x4[1])  # Create an offset for the remaining grid
  x6 = canvas(mostcolor(I), x2)  # Create a canvas with the original size and background color
  O = paint(x6, shift(asobject(x1), x5))  # Paint the compressed grid onto the canvas with the correct offset
  return O
 
0.012235315288663324, 3.2367241, def bhbbedecdcfceddfacfecdbabhfcifha(I):
    """
    Finds objects, keeps only those larger than one cell, and paints them back onto a blank canvas.
    """
    objs = objects(I, T, F, T)  # Get all objects, treating diagonals as disconnected
    filtered_objs = sfilter(objs, lambda obj: size(obj) > 1) # Filter out single-cell objects
    O = paint(canvas(mostcolor(I), shape(I)), merge(filtered_objs)) # Paint remaining objects onto a blank canvas
    return O
 
0.058535352881145496, 9.380909, def fadfdehahiiheicbiebjfedifgbgigdc(I):
    """
    Utilizes object partitioning and filtering to remove single-cell objects.
    """
    objs = partition(I)  # Partition the grid into objects based on color
    filtered_objs = sfilter(objs, lambda obj: size(obj) > 1)  # Keep objects larger than one cell
    O = paint(canvas(mostcolor(I), shape(I)), merge(filtered_objs)) # Paint the remaining objects onto a blank canvas
    return O
 
0.012235315288663324, 3.2367241, def icaadacacejjedagicadfcacaaeaegge(I):
    bg = mostcolor(I)  # Identify the background color
    objs = objects(I, False, False, True)  # Find connected objects excluding background
    for obj in objs:
        if len(obj) == 1:  # If the object is a single cell
            I = cover(I, obj)  # Remove the single-cell object
    return I 
 
0.058535352881145496, 9.380909, def jijiieidcbeeefafjbfgdhjajaabebfi(I):
    objs = partition(I)  # Partition the grid into objects based on color
    for obj in objs:
        if len(obj) == 1: 
            I = fill(I, mostcolor(I), toindices(obj))  # Fill single-cell objects with background
    return I
 
0.045697777892918394, 6.8407645, def afifcfcaadaeeefgbacafiaifhcbdajc(I):
    bg = mostcolor(I)  # Find the background color
    O = I  # Copy the input grid
    for i in range(height(I)):
        for j in range(width(I)):
            if index(I, (i, j)) != bg and all(index(I, n) == bg for n in dneighbors((i, j))):
                O = fill(O, bg, [(i, j)])  # Fill with background if it's an isolated cell
    return O
 
0.058535352881145496, 9.380909, def abfijadfcaceehdeifaabccjeefgfdce(I):
  object_indices = asindices(I)
  single_cell_indices = mfilter(object_indices, lambda loc: size(extract(objects(I, T, F, F), lambda obj: contained(loc, toindices(obj)))) == 1)
  O = paint(canvas(mostcolor(I), shape(I)), toobject(difference(object_indices, single_cell_indices), I))
  return O
 
0.012235315288663324, 3.2367241, def iebfdhacgaedefcbaacbiadecbcbecei(I):
    x1 = objects(I, univalued=True, diagonal=False, without_bg=False)  # Find all objects
    x2 = sfilter(x1, vline)  # Keep only vertical line objects
    x3 = apply(toindices, x2)  # Extract indices of vertical lines
    x4 = merge(x3)  # Merge all indices
    x5 = mostcolor(I)  # Get the background color
    O = fill(I, x5, x4)  # Fill vertical line indices with background
    return O
 
0.1917041094196119, 56.805035, def ehfhafcdfdiceffejdaficcadcdeecba(I):
  """
  Removes single-color objects that are not the most common color.
  """
  x1 = objects(I, T, F, T) # Extract objects, excluding background
  x2 = apply(lambda obj: (size(obj), color(obj)), x1) # Get (size, color) tuples for each object
  x3 = sfilter(x2, lambda x: x[0] == 1 and x[1] != mostcolor(I)) # Find single-cell objects not of the most common color
  x4 = apply(lambda x: ofcolor(I, x[1]), x3) # Get indices of cells with those colors
  x5 = merge(x4) # Merge the indices
  O = cover(I, x5) # Cover the cells with the background color
  return O
 
0.05682144652732888, 9.086866, def ahecfgbfcbjdeeceicgcedfgfeheecab(I):
    x1 = shape(I)  # Get the shape of the grid
    x2 = crop(I, (0, 0), (x1[0], x1[1] - 1))  # Crop the grid to remove the last column
    O = x2  # Output the cropped grid
    return O
 
0.013749730661495367, 5.2298727, def edafabfeecececjbabehffehbedcdgdg(I):
  x1 = objects(I, univalued=True, diagonal=False, without_bg=False)
  x2 = sfilter(x1, lambda obj: (size(obj) == 1 and index(I, first(toindices(obj))) != mostcommon(I)) or (vline(obj) and len(obj) < height(I)))
  x3 = merge(apply(toindices, x2))
  x4 = shape(I)
  x5 = crop(I, (0, 0), (x4[0], x4[1] - 1))
  O = fill(x5, mostcolor(I), x3) 
  return O
 
0.28840077625202537, 15.143621, def hidahgjaeiefefcfidjcadfdfdacbafh(I):
    objs = partition(I)  # Partition the grid into objects 
    for obj in objs:
        if size(obj) == 1:
            I = fill(I, mostcolor(I), toindices(obj))  # Remove single-cell objects
    for i in range(len(I)):  # Iterate through rows from top to bottom
        for j in range(len(I[0])):  # Iterate through columns 
            if index(I, (i, j)) != mostcolor(I): # If cell is not background
                k = 1
                while i - k >= 0 and index(I, (i - k, j)) == mostcolor(I):  # Find empty space above
                    k += 1
                I = paint(cover(I, {(index(I, (i, j)), (i, j))}), {(index(I, (i, j)), (i - k + 1, j))}) # Move object up
    return I
 
0.23155130482405284, 27.47778, def jhbbachdbfcceeidbhbeaaebhdbfccfh(I):
    objs = objects(I, univalued=True, diagonal=False, without_bg=False)  # Identify objects
    for obj in objs:
        if len(obj) == 1:
            I = fill(I, mostcolor(I), toindices(obj))  # Remove single-cell objects
    for _ in range(len(I)): # Repeat for grid height to ensure complete shifting
        for obj in objects(I, univalued=True, diagonal=False, without_bg=False):
            for (v, (i, j)) in obj:
                if i > 0 and index(I, (i - 1, j)) == mostcolor(I): # If cell above is empty
                    I = paint(cover(I, {(v, (i, j))}), {(v, (i - 1, j))}) # Move cell one step up
    return I
 
0.32487286595807835, 15.878272, def gacabbfdehhcejjeagajdhhfiegbcdfd(I):
    O = canvas(mostcolor(I), shape(I))  # Create an empty canvas
    for j in range(len(I[0])):  # Iterate through columns
        column = tuple(I[i][j] for i in range(len(I))) # Extract column
        filtered_column = tuple(v for v in column if v != mostcolor(I)) # Remove background cells
        new_column = tuple(mostcolor(I) for _ in range(len(column) - len(filtered_column))) + filtered_column # Create new column with objects shifted up
        for i in range(len(new_column)):
            O = paint(O, {(new_column[i], (i, j))})  # Paint new column on the canvas
    return O
 
0.4416634736038516, 10.846127, def chedaffcieaeeifbbgdbeeajhbededch(I):
  target_color = leastcolor(I)
  def process_row(i, row):
    return tuple(target_color if any(I[k][j] == target_color for k in range(i + 1)) else 0 for j, v in enumerate(row))
  O = tuple(process_row(i, row) for i, row in enumerate(I))
  return O
 
0.3804683725213023, 13.058058, def ifdfbagaadbiedbcifbdcgaejhhfciab(I):
    c = leastcolor(I)
    g = canvas(0, shape(I))
    for i, r in enumerate(I):
        for j, v in enumerate(r):
            if v == c:
                g = paint(g, {(v, (k, j)) for k in range(i + 1)})
    return g
 
0.1917041094196119, 56.805035, def jfhiaabfjfbheabbjhdbbbbfabgbhbhb(I):
  x1 = objects(I, univalued=False, diagonal=False, without_bg=False)
  x2 = sfilter(x1, lambda obj: rightmost(obj) < width(I) - 1)
  O = paint(canvas(mostcolor(I), shape(I)), merge(x2))
  return O
 
0.38105322184564744, 50.30995, def iifdfcbdgdhiefbgbfabacbddijeaeef(I):
  x1 = asindices(I)
  x2 = sfilter(x1, lambda loc: loc[1] < width(I) - 1)
  x3 = canvas(mostcolor(I), shape(I))
  O = paint(x3, recolor(index(I, first(x2)), x2))
  return O
 
0.04767016448068959, 6.992385, def iciajcdhffejecffjafafgffchgafgjc(I):
  def get_neighbor_colors(loc):
    return {index(I, n) for n in neighbors(loc)}
  return fill(I, mostcolor(I), {loc for loc in asindices(I) if len(get_neighbor_colors(loc)) == 1 and index(I, loc) not in get_neighbor_colors(loc)})
 
0.15278577631518808, 12.274481, def fbceadgfbiegeddcajbjicghjheeaagb(I):
  x1 = shape(I) # Get the dimensions of the input grid
  x2 = crop(I, (0, 1), (x1[0], x1[1]-2)) # Crop the input grid, removing the first and last columns.
  O = x2 # Assign the cropped grid as the output
  return O
 
0.1917041094196119, 56.805035, def gbieeedbfafaedfjbcdfegdebibccbed(I):
  """
  Identifies singleton cells by checking for differences after dilation and erosion.

  Args:
      I: Input grid.

  Returns:
      O: Output grid with singleton cells removed.
  """
  dilated = paint(canvas(mostcolor(I), shape(I)),  merge(apply(lambda loc: toobject(neighbors(loc), I), asindices(I))))
  eroded = cover(I, merge(apply(lambda loc: toindices(extract(objects(I, T, F, F), lambda obj: contained(loc, toindices(obj)))), asindices(I))))
  O = cellwise(I, cellwise(dilated, eroded, mostcolor(I)), mostcolor(I))
  return O
 
0.1917041094196119, 56.805035, def efebgfdfcjieecheiheibajafceecbaa(I):
  return replace(I, leastcolor(I), mostcolor(I))
 
0.29660928067711595, 8.79454, def fbcdgibdejagedffaadhbaieeeiacejg(grid):
    objs = objects(grid, T, F, F)
    new_grid = canvas(0, shape(grid))
    for obj in objs:
        obj_height = height(obj)
        obj_width = width(obj)
        top_left_corner = ulcorner(obj)
        new_top_left_corner = (top_left_corner[0] - obj_height + 1, top_left_corner[1])
        shifted_obj = shift(obj, subtract(new_top_left_corner, top_left_corner))
        new_grid = paint(new_grid, shifted_obj)
    return new_grid
 
0.10306426782338414, 17.748394, def ebcdbeidabijecdfjedeefdegdaddfie(I):
  """
  Compares the grid with a shifted version to identify and remove singletons.
  """
  shifted_grid = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), (1, 1)))
  O = cellwise(I, shifted_grid, mostcolor(I))
  return O
 
0.021010422964869897, 4.10388, def fccicabefeeieejeighicdfcbedebfdf(I):
  """
  Uses convolution-like approach to find and remove singleton cells.
  """
  def check_singleton(grid, i, j):
    if grid[i][j] == mostcolor(grid):
      return grid[i][j]
    for x in range(max(0, i - 1), min(len(grid), i + 2)):
      for y in range(max(0, j - 1), min(len(grid[0]), j + 2)):
        if (x != i or y != j) and grid[x][y] == grid[i][j]:
          return grid[i][j]
    return mostcolor(grid)

  h, w = len(I), len(I[0])
  O = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      O = fill(O, check_singleton(I, i, j), {(i, j)})
  return O
 
0.21188008792100202, 9.136935, def egefgbaheadbeiababegcdcfjaddijha(I):
  # 1. Create a list to store the shifted columns
  shifted_grid = []

  # 2. Iterate through the columns 
  for j in range(width(I)):
    # 3. Check if the column is empty (all background color)
    if any(I[i][j] != mostcommon(I) for i in range(height(I))):
      # 4. If not empty, append the column to the shifted grid
      shifted_grid.append([I[i][j] for i in range(height(I))])

  # 5. Convert the shifted columns back to a tuple (grid)
  O = tuple(tuple(row) for row in shifted_grid)
  return O
 
0.16853869985167755, 18.170792, def fchdbbcfibedecidbfdcfedbggedibia(grid):
  objs = objects(grid, T, F, F)
  new_grid = canvas(0, shape(grid))
  for obj in objs:
    new_grid = paint(new_grid, shift(obj, (-uppermost(obj), 0)))
  return new_grid
 
0.173551634367635, 28.294205, def eafjjfdghhfaeggabjafbeffadaeiadb(I):
  main_color = mostcolor(I)
  output = canvas(main_color, shape(I))
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if value != main_color:
        output = paint(cover(output, {(value, (k, j)) for k in range(i)}), {(value, (i, j))})
  return output
 
0.17286580486702166, 6.665858, def gbajajebheebeddfafidcfegafdacfje(grid):
  for i in range(height(grid)):
    for j in range(width(grid)):
      if i > 0 and index(grid, (i, j)) != 0 and index(grid, (i - 1, j)) == 0:
        grid = paint(cover(grid, {(index(grid, (i, j)), (i, j))}), {(index(grid, (i, j)), (i - 1, j))})
  return grid
 
0.19272282529440599, 19.2228, def idhhgehgefhiejdfacajeibaaiadefej(grid):
  return paint(canvas(0, shape(grid)), mapply(lambda obj: shift(obj, (-uppermost(obj), 0)), objects(grid, T, F, F)))
 
0.15819052995371488, 39.625816, def hfbchaccfdhaebebbeefbhjegficicda(I):
  """
  Utilizes shifted grids to identify and remove singleton cells directly. 
  """
  shifted_up = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), (-1, 0)))
  shifted_down = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), (1, 0)))
  shifted_left = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), (0, -1)))
  shifted_right = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), (0, 1)))
  O = cellwise(I, cellwise(shifted_up, cellwise(shifted_down, cellwise(shifted_left, shifted_right, mostcolor(I)), mostcolor(I)), mostcolor(I)), mostcolor(I))
  return O
 
0.050094663692138885, 5.0255923, def afcjaceedfehedifibjeejddhedeecec(I):
  """
  Removes single-cell objects by comparing the input grid to a downscaled and upscaled version.
  """
  downscaled = downscale(I, 2)
  upscaled = upscale(downscaled, 2)
  return cellwise(I, upscaled, mostcolor(I))
 
0.09313575760969199, 18.19925, def caafaechbhecedcejgjbhdddfiabbjfc(I):
  """
  Identifies singletons by comparing with a shifted grid and removes them.
  """
  shifted_right = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), RIGHT))
  shifted_down = paint(canvas(mostcolor(I), shape(I)), shift(asobject(I), DOWN))
  combined_shifted = cellwise(shifted_right, shifted_down, mostcolor(I))
  O = cellwise(I, combined_shifted, mostcolor(I))
  return O
 
0.05107060185185185, 11.40614, def echcfdiciafeeefeiahcjbgaccidhecb(I):
  return crop(I, (0, 0), (len(I)-1, len(I[0])-1))
 
0.021010422964869897, 4.10388, def idabbdfjjdcfefddibaeeadiiefgbhdd(I):
  """
  Iterates and checks if each cell is part of a larger object before preserving.
  """
  h, w = len(I), len(I[0])
  output = canvas(mostcolor(I), (h, w))
  for i in range(h):
    for j in range(w):
      if any((i+di, j+dj) in asindices(I) and I[i][j] == I[i+di][j+dj] 
             for di in [-1, 0, 1] for dj in [-1, 0, 1] if (di, dj) != (0, 0)):
        output = paint(output, {(I[i][j], (i, j))})
  return output
 
0.024136212090126685, 3.0094836, def begbbebbbfdceaibaeifddhjbgeajfdh(I):
  """
  Compares the input grid with a shifted version to identify and remove lone cells.
  """
  shifted_right = shift(asobject(I), (0, 1))
  shifted_down = shift(asobject(I), (1, 0))
  combined_shifted = shifted_right | shifted_down
  filtered_cells = {(v, (i, j)) for v, (i, j) in asobject(I) if (v, (i, j)) in combined_shifted}
  return paint(canvas(mostcolor(I), shape(I)), filtered_cells)
 
0.012235315288663324, 3.2367241, def edhbdcgdccfeeaacbcbcadiadcdfgidh(I):
  x1 = objects(I, T, F, F)  # Find all objects
  x2 = sfilter(x1, lambda o: size(o) > 1)  # Keep only objects with more than one cell
  O = paint(canvas(mostcolor(I), shape(I)), merge(x2))  # Paint the remaining objects onto a blank canvas
  return O
 
0.1917041094196119, 56.805035, def dhajfiefaebcecidjddebfddaehcadeh(I):
  O = I  # Start with the input grid
  for i in range(len(I)):
    for j in range(len(I[0])):
      if len(objects(crop(I, (i, j), (1, 1)), T, F, F)) == 1:  # Check if cell is a single-cell object
        O = fill(O, mostcolor(I), {(i, j)})  # Fill with background color
  return O
 
0.058535352881145496, 9.380909, def adhhighjfdhcedabjecahhefedffbeca(I):
  x1 = palette(I)  # Get all colors in the grid
  x2 = sfilter(x1, lambda c: colorcount(I, c) == 1)  # Find colors used only once
  O = I  # Start with the input grid
  for c in x2:
    O = replace(O, c, mostcolor(I))  # Replace single-occurrence colors with the background color
  return O
 
0.04860684266745333, 8.226893, def adigbaaafdcgehdcibdcbijbabbcjdih(I):
  x1 = objects(I, T, F, F)  # Find all objects
  x2 = extract(x1, lambda o: size(o) == minimum(apply(size, x1)))  # Find the smallest object
  x3 = sfilter(x1, lambda o: not equality(o, x2))  # Remove the smallest object from the set
  O = paint(canvas(mostcolor(I), shape(I)), merge(x3))  # Paint the remaining objects on a blank canvas
  return O
 
0.07114074310545658, 14.389659, def eaagdgffbbadejdcaiehdcecefjeehfc(I):
  x1 = mostcolor(I)  # identify background color
  x2 = objects(I, T, F, T)  # get objects, excluding background, 4-connected
  x3 = argmax(x2, size)  # find the largest object
  O = paint(canvas(x1, shape(I)), x3) # paint the largest object on a blank canvas
  return O
 
0.058535352881145496, 9.380909, def caegfjfjfieiefbfjdfiegbdafbbcfdc(I):
  x1 = objects(I, T, F, F)  # extract all 4-connected objects
  x2 = lambda obj: colorcount(obj, mostcolor(obj)) # function to count cells of the most common color in an object
  x3 = argmax(x1, x2) # find the object with the most cells of the most common color 
  O = paint(cover(I, x3), x3) # cover the largest object and repaint it (effectively removing smaller objects)
  return O
 
0.1917041094196119, 56.805035, def hgdgfaacceihejacjfccfhhgcabicbdd(I):
  x1 = objects(I, T, F, F) # get all objects
  x2 = lambda obj: len(obj) > 1 and all(manhattan(obj, other) > 1 for other in x1 if other != obj) # function to check if an object is isolated (not adjacent to any other object)
  O = mfilter(x1, x2) # filter for isolated objects
  return paint(canvas(mostcolor(I), shape(I)), O) # paint isolated objects on a blank canvas
 
0.058535352881145496, 9.380909, def iifadchgbebfecfdjbdaedfjagjdddcg(I):
    for obj in objects(I, F, F, F):
        if size(obj) == 1:
            I = cover(I, obj)
    return I
 
0.058535352881145496, 9.380909, def hfbedchdfefgeddbbebccgfdciaahfai(I):
  """
  Leverages the 'partition' function to group cells by color, then filters and 
  reconstructs the grid.
  """
  parts = partition(I)
  filtered_parts = sfilter(parts, lambda part: size(part) > 1)
  O = canvas(mostcolor(I), shape(I))
  for part in filtered_parts:
    O = paint(O, part)
  return O
 
0.058535352881145496, 9.380909, def iccbfcdgdcefeecabfgifgcaaaffbdfc(I):
  O = I
  for i in range(height(I)):
    for j in range(width(I)):
      if index(I,(i,j))!=mostcommon(I) and size(toobject(neighbors((i,j)), I))==1:
        O = fill(O, mostcommon(I), {(i,j)})
  return O
 
0.012235315288663324, 3.2367241, def ahjhcbjbccbeecadbfdcbjadabcbhjaf(I):
  objs = objects(I, T, F, F) # identify all objects in the grid
  filtered_objs = sfilter(objs, lambda obj: size(obj) > 1) # Filter out single-cell objects
  O = paint(canvas(mostcolor(I), shape(I)), merge(filtered_objs)) # Paint the remaining objects on a blank canvas
  return O
 
0.20804816098933746, 12.419139, def addhhcbcdgcdehecafdcfebbiecdbaie(I):
  x1 = crop(I, (1, 0), (subtract(shape(I)[0], 2), shape(I)[1]))
  return x1
 
0.3921927745457157, 70.74205, def hdbeffafaegfecdfbebajcgdfgafebhb(I):
  return vconcat(tophalf(bottomhalf(I)), tuple())
 
0.34214968038497445, 32.256905, def ajceigheadfeeccaibbahaddafadgajc(I):
  x1 = vsplit(I, add(ONE, ONE))
  return x1[ONE]
 
0.054684694390576744, 9.088661, def aieaedeecibcedeijcdeiccbiedcbaba(I):
  x1 = objects(I, T, F, F)
  x2 = argmax(x1, height)
  x3 = ulcorner(x2)
  x4 = subtract(shape(x2)[0], ONE)
  x5 = crop(I, x3, (x4, shape(x2)[1]))
  return x5
 
0.021010422964869897, 4.10388, def bbdiaecgafdeeagaijcjccdaeejadgdd(I):
  """
  Identifies single-cell objects and directly modifies the input grid 
  to replace them with the background color.
  """
  for i, row in enumerate(I):
    for j, value in enumerate(row):
      if len(sfilter(neighbors((i,j)), lambda n: index(I,n) == value)) == 0:
        I = fill(I, mostcolor(I), {(i,j)}) # Directly modify I
  return I
 
0.18082192849294257, 44.013226, def ccbecadbggjjeaagjcjdfajfahejhjbb(I):
  non_top_objs = sfilter(objects(I, T, T, T), lambda obj: uppermost(obj) != 0)
  non_bottom_objs = sfilter(non_top_objs, lambda obj: lowermost(obj) != len(I)-1)
  least_color_objs = sfilter(non_bottom_objs, lambda obj: color(obj) == leastcolor(I))
  indices_to_remove = merge(apply(toindices, least_color_objs))
  return fill(I, mostcolor(I), indices_to_remove)
 
0.04595959595959596, 14.333579, def hijbhcahjdegefgjjejhaicaaabedjje(I):
  return crop(I, (0, 0), (subtract(shape(I)[0], 2), subtract(shape(I)[1], 1)))
 
0.17909871919530082, 16.129604, def ibbfbjajfcegecebbiffcfafhbjfdbid(I):
  x1 = objects(I, False, False, True)
  x2 = argmax(x1, size)
  x3 = cover(I, x2)
  return x3 
 
0.047870430223371396, 23.170158, def dbiibefcafdcebgeaaedaaccbahfdffc(I):
  x1 = bottomhalf(I)
  x2 = height(x1)
  x3 = crop(I, (0, 0), (subtract(shape(I)[0], x2), shape(I)[1]))
  return x3
 
0.1917041094196119, 56.805035, def hdadacafagfeeeheibecadgidjgccjgi(I):
  """
  Iterates through the grid, removing cells that are not part of larger objects. 
  """
  O = canvas(mostcolor(I), shape(I))  # Create an empty canvas with the background color
  for i in range(len(I)):
    for j in range(len(I[0])):
      if size(objects(crop(I, (i,j), (1,1)), T, F, T)) > 1:  # Check if the cell is part of a larger object
        O[i][j] = I[i][j]  # If part of a larger object, copy the cell
  return O
 
0.07114074310545658, 14.389659, def abbfbafbhcheeebcjaefdcddedcedece(I):
  objs = objects(I, False, False, True)  # Identify all objects
  largest_obj = argmax(objs, size)  # Find the largest object
  return paint(canvas(mostcolor(I), shape(I)), largest_obj)  # Paint the largest object onto a blank canvas
 
0.021010422964869897, 4.10388, def ddfedjcaacbaejfiafggbechfafadcbi(I):
  return tuple(tuple(v if any((i,j) != (ii,jj) and I[ii][jj] == v 
                         for ii in range(max(0,i-1),min(len(I),i+2)) 
                         for jj in range(max(0,j-1),min(len(I[0]),j+2))) 
                    else mostcolor(I) for j,v in enumerate(row)) for i,row in enumerate(I))
 
0.0694175338078148, 5.9576244, def jhbedeedffgceefhbibbcgcacfgfjfdj(I):
  to_remove = frozenset(
      index for obj in objects(I, T, T, T) 
      for index in toindices(obj)
      if uppermost(obj) == 0 or lowermost(obj) == height(I) - 1
  )
  return fill(I, mostcolor(I), to_remove)
 
0.024136212090126685, 3.0094836, def acbbeidbcahbehacaehbecibhceeehdc(I):
  bg = mostcolor(I)
  objs = objects(I, False, False, True)
  trimmed_objs = frozenset({
      frozenset({
          (v, (i, j)) for v, (i, j) in obj 
          if not (i == uppermost(obj) and index(I, (i, j - 1)) == bg) and 
             not (j == leftmost(obj) and index(I, (i - 1, j)) == bg)
      })
      for obj in objs
  })
  return paint(canvas(bg, shape(I)), merge(trimmed_objs))
 
0.03774165426699743, 3.4096549, def cebgjdcdecfiedjhihfaeifbbcbffbej(I):
  bg = mostcolor(I)
  return paint(canvas(bg, shape(I)), merge(
      frozenset({
          frozenset({
              (v, (i, j)) for v, (i, j) in obj 
              if any((v2 != bg for v2, (i2, j2) in zip(
                  (index(I, (i - 1, j)), index(I, (i, j - 1))),
                  ((i - 1, j), (i, j - 1))
              )))
          })
          for obj in objects(I, False, False, True)
      })
  ))
 
0.07229414564294218, 13.969541, def fabhafhaifgeeedfadjfjgieafegfeaf(I):
  bg = mostcolor(I) # Get the background color
  objs = objects(I, True, False, True)  # Get all objects (without background)
  if len(objs) < 2:  
    return I # Handle cases with less than two objects
  obj1 = argmax(objs, size)  # Get the largest object
  obj2 = argmin(objs, size)  # Get the smallest object
  offset = subtract(ulcorner(obj1), ulcorner(obj2)) # Calculate offset to align top-left corners
  moved_obj2 = shift(obj2, offset)  # Move the smaller object
  O = paint(canvas(bg, shape(I)), obj1)  # Create a blank canvas and paint the largest object
  O = paint(O, moved_obj2)  # Paint the moved smaller object
  return O 
 
0.07794346419389196, 14.509001, def afbhgacedfbiefjjbfceajecdbjjabgf(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  if len(objs) < 2:  
    return I 
  obj1 = argmax(objs, size)  
  obj2 = argmin(objs, size) 
  offset = gravitate(obj2, obj1)  # Calculate offset to move towards top-left
  moved_obj2 = shift(obj2, offset)  
  O = paint(canvas(bg, shape(I)), obj1)  
  O = paint(O, moved_obj2) 
  return O
 
0.0787624482441776, 13.708199, def djfdaghfdacfeaeebeccfibdgjbfdbec(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  if len(objs) < 2:
    return I
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  offset_x = center(obj1)[1] - center(obj2)[1]  # Calculate horizontal offset based on centers
  moved_obj2 = shift(obj2, (0, offset_x))  # Move the smaller object horizontally
  O = paint(canvas(bg, shape(I)), obj1)
  O = paint(O, moved_obj2) 
  return O
 
0.07229414564294218, 14.187636, def hbcfeechdfbfeafajiegbahifceeaecc(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  if len(objs) < 2:
    return I
  obj1 = argmax(objs, size)
  obj2 = argmin(objs, size)
  offset_y = uppermost(obj1) - uppermost(obj2) 
  offset_x = center(obj1)[1] - center(obj2)[1]  
  moved_obj2 = shift(obj2, (offset_y, offset_x)) # Move vertically and horizontally
  O = paint(canvas(bg, shape(I)), obj1)
  O = paint(O, moved_obj2)  
  return O
 
0.1917041094196119, 56.805035, def dajeeeffiffbeeejifadahedaehbcjdj(grid):
  bg = mostcolor(grid)
  h, w = len(grid), len(grid[0])
  rows_to_clear = set()
  cols_to_clear = set()
  for i in range(h):
    for j in range(w):
      if grid[i][j] == bg:
        rows_to_clear.add(i)
        cols_to_clear.add(j)
  for i in range(h):
    for j in range(w):
      if i in rows_to_clear or j in cols_to_clear:
        grid = fill(grid, bg, {(i, j)})
  return grid
 
0.05927242691948575, 34.40766, def bgccdcabeabhejbfbcbccdhhaddedjjd(I):
  return vsplit(I,2)[0]
 
0.018152475051976934, 4.961896, def dehgadaefiabeeddbaibeacagbchadca(grid):
  bg = mostcolor(grid)
  h, w = len(grid), len(grid[0])
  new_grid = canvas(bg, (h, w))
  for i, row in enumerate(grid):
    for j, val in enumerate(row):
      if val != bg:
        up, down = any(grid[k][j] != bg for k in range(i)), any(grid[k][j] != bg for k in range(i + 1, h))
        left, right = any(grid[i][k] != bg for k in range(j)), any(grid[i][k] != bg for k in range(j + 1, w))
        if (up or down) and (left or right):
          new_grid = fill(new_grid, val, {(i, j)})
  return new_grid
 
0.09856835180991992, 22.203358, def ghdfigcbabcaefgcjdacdeacgefjjdgg(I):
  """
  This program removes cells that are not part of a 2x2 block of the same color.
  """
  def in_block(i, j):
    """Checks if a cell is part of a 2x2 block of the same color."""
    if i + 1 >= len(I) or j + 1 >= len(I[0]):
      return False
    return I[i][j] == I[i+1][j] == I[i][j+1] == I[i+1][j+1]
  
  O = canvas(mostcolor(I), shape(I)) # Start with a blank canvas
  for i in range(len(I)):
    for j in range(len(I[0])):
      if in_block(i, j):
        O = paint(O, {(I[i][j], (i, j))}) # Paint the cell if it's in a block
  return O
 
0.06811398419444353, 7.8344593, def cbhcgagdehfbefadifahibhfcebecdhe(I):
  """
  This program erodes and then dilates the objects in the grid to remove single-pixel artifacts.
  """
  def erode(grid):
    """Erodes the objects in the grid by one pixel."""
    eroded = canvas(mostcolor(grid), shape(grid))
    for i in range(1, len(grid) - 1):
      for j in range(1, len(grid[0]) - 1):
        if grid[i][j] != mostcolor(grid) and any(grid[i+di][j+dj] == mostcolor(grid) for di in [-1,0,1] for dj in [-1,0,1]):
          eroded = paint(eroded, {(grid[i][j], (i,j))})
    return eroded
  
  def dilate(grid):
    """Dilates the objects in the grid by one pixel."""
    dilated = canvas(mostcolor(grid), shape(grid))
    for i in range(len(grid)):
      for j in range(len(grid[0])):
        if grid[i][j] != mostcolor(grid) or any(grid[i+di][j+dj] != mostcolor(grid) for di in [-1,0,1] for dj in [-1,0,1] if 0 <= i+di < len(grid) and 0 <= j+dj < len(grid[0])):
          dilated = paint(dilated, {(grid[i][j], (i,j))})
    return dilated

  O = erode(I) # Erode the input grid
  O = dilate(O) # Dilate the eroded grid
  return O
 
0.054658689093458473, 5.2629323, def cejefcdjgbceeegbaccdjdcebacfedgf(I):
  bg = mostcolor(I)
  objs = objects(I, True, False, True)
  for obj in objs:
    if bordering(obj, I): # Check if object touches the border
      I = cover(I, obj) # Remove the object if it touches the border
  return I
 
0.17975209575650655, 34.78909, def jagjgfbjgcbdedfhjejbfgcehdgghcbe(I):
  x1 = objects(I, T, F, F) # Extract all objects (4-connected)
  x2 = apply(lambda obj: size(obj) > 1, x1)  # Check if each object is larger than one cell
  x3 = pair(totuple(x1), totuple(x2)) # Pair objects with their size check result
  x4 = apply(lambda x: x[0] if x[1] else {}, x3) # Keep only objects larger than one cell
  O = paint(canvas(mostcolor(I), shape(I)), merge(x4)) # Paint remaining objects on a blank canvas
  return O 
 
0.23800414701209407, 43.63984, def jiibgicjcjgbeebhijejihbeeedejfff(grid):
  bg = mostcolor(grid)
  objs = objects(grid, True, False, False)
  filtered_objs = frozenset(obj for obj in objs if hline(obj) or vline(obj))
  return paint(canvas(bg, shape(grid)), merge(filtered_objs)) 
 
0.23324038978626604, 41.39943, def eidcdhffhheeebdbbfcecgcbdfjjdagf(grid):
  bg = mostcolor(grid)
  return tuple(
    tuple(
      bg if (i, j) in delta(merge(
        sfilter(objects(grid, True, False, False), 
                lambda obj: hline(obj) or vline(obj)))) else grid[i][j]
      for j in range(len(grid[0]))) 
    for i in range(len(grid)))
 
0.026042021403061746, 4.6494, def fgffedjaebehecgjiceeaacjfdahacaa(I):
  O = canvas(mostcolor(I), shape(I))
  for i in range(1, len(I)-1):
    for j in range(1, len(I[0])-1):
      if I[i][j] == I[i-1][j] or I[i][j] == I[i+1][j] or I[i][j] == I[i][j-1] or I[i][j] == I[i][j+1]:
        O = paint(O, {(I[i][j], (i, j))})
  return O
 
0.1294886210662476, 18.428394, def efadidiagebfeecfiahbaiibcbfaffef(I):
    """
    Removes objects touching the top or bottom edge of the grid.
    """
    return paint(
        canvas(mostcolor(I), shape(I)),
        mfilter(
            objects(I, T, T, T),
            lambda obj: not bordering(obj, I)
        )
    )
 
0.1917041094196119, 56.805035, def ddjjiffbjcfhebegjdiefiifjiefdgai(I):
    """
    Removes objects touching the top or bottom edge of the grid.
    """
    return cellwise(
        I, 
        fill(
            canvas(mostcolor(I), shape(I)),
            1, 
            merge(
                apply(
                    toindices,
                    sfilter(
                        objects(I, T, T, T), 
                        lambda obj: bordering(obj, I)
                    )
                )
            )
        ),
        mostcolor(I)
    )
 
0.018152475051976934, 18.66794, def aehafbcdajeheccdjfjcdajdddceebhj(I):
  zeros_column = tuple((0,) * len(I[0]) for _ in range(len(I)))
  O = hconcat(I, zeros_column)
  return O
 
0.018152475051976934, 3.77065, def hdjeebcacahgecgcjbhbdffdjcjgeefe(I):
  O = tuple(row + (0,) for row in I)
  return O
 
0.9130492433659855, 37.94548, def fbfieafdbeafefcbidedidfeaefeaaic(I):
    x1 = astuple(len(I), len(I[0]) + ONE)
    O = fill(canvas(ZERO, x1), ONE, asindices(I))
    return O
 
0.038560638317283055, 4.5025663, def idjfeecabhjeedhajgjcdaeajafcjbeh(I):
  return tuple(row + (mostcommon(row),) for row in I)
 
0.038560638317283055, 13.1879, def jcgfbigcbfddeacfifgedeafgbbcfheb(I):
  return hconcat(I, tuple((mostcommon(row),) * len(I) for row in I))
 
0.013749730661495367, 5.2298727, def ajhfebaaaacdegdfaecddfcdccgbbcdb(I):
  return tuple(tuple(v if j < len(I[0]) else mostcommon(row) for j, v in enumerate(row)) for row in I) 
 
0.018152475051976934, 3.77065, def ffhihjddbjccebaabfhcbccacfacjadc(grid):
  bg = mostcolor(grid)
  h = height(grid)
  w = width(grid)
  new_grid = canvas(bg, (h, w + 1))
  for i in range(h):
    for j in range(w):
      new_grid = fill(new_grid, grid[i][j], {(i, j)})
  return new_grid
 
0.025641025641025644, 119.80753, def eabeacfegbaheabbjhehechcciajgaga(grid):
  bg = mostcolor(grid)
  return hconcat(grid, tuple((bg,) * len(grid) for _ in range(1)))
 
0.019038036377098697, 3.5644221, def heccaehheddhedhajdbdbicdcbcabdcf(I):
  # 1. Get the grid's height.
  x1 = height(I)
  # 2. Create a column vector filled with the last element of each row in the input grid.
  x2 = tuple((row[-1],) for row in I)
  # 3. Create a new grid by horizontally concatenating the input grid with the column vector.
  O = hconcat(I, x2)
  return O
 
0.018152475051976934, 3.77065, def eehabadejeebejbcbeeficeceijdbcdb(I):
    # 1. Get the shape of the input grid.
    h, w = shape(I)
    # 2. Create a new grid with an extra column using the 'canvas' function.
    O = canvas(0, (h, w + 1))
    # 3. Paint the input grid onto the new canvas.
    O = paint(O, asobject(I))
    return O
 
0.018152475051976934, 3.77065, def dbaeigaeaheaehbeacdhfffbjdccdjdf(I):
  x1 = shape(I)
  x2 = mostcolor(I)
  x3 = astuple(x1[0], 1)
  x4 = canvas(x2, x3)
  O = hconcat(I, x4)
  return O
 
0.1917041094196119, 56.805035, def afjfbdbidjccebhdjcafabcgifaiebdb(I):
  x1 = shape(I)
  x2 = increment(x1[1])
  x3 = astuple(x1[0], x2)
  x4 = index(I, ORIGIN)
  O = canvas(x4, x3)
  return O
 
0.20713477698771818, 58.314022, def hbfdgbbcecfgecedjbbejaibjjdcacgg(I):
    x1 = objects(I, univalued=False, diagonal=False, without_bg=False)
    x2 = argmax(x1, size)
    x3 = width(x2)
    x4 = shape(I)
    x5 = astuple(x4[0], x3)
    x6 = index(I, ORIGIN)
    O = canvas(x6, x5)
    return O
 
0.018152475051976934, 5.734816, def fbdcbijabefdehijiagjdbghbeabhfeh(I):
    h = len(I)
    w = len(I[0])
    O = canvas(0, (h + 1, w + 1))
    O = paint(O, asobject(crop(I, (0, 0), (h, w))))
    return O
 
0.013749730661495367, 5.2298727, def ciedhfcjafcdejafahidhiaajbdbageg(I):
    objs = objects(I, T, F, T) #get all objects, single color, no diagonals, no background
    min_j = leftmost(asindices(I)) #find the leftmost column
    for obj in objs:
      I = paint(I, shift(obj, (0, width(I) - min_j))) #shift each object to the right edge
    return I
 
0.11091808518279107, 5.770917, def gbbfjegdaceeeaacbhichfegdadcdech(I):
    # 1. Get the width of the input grid.
    w = width(I)
    # 2. Shift the input grid one position to the left.
    shifted_grid = shift(asobject(I), (0, -1))
    # 3. Create a canvas of the original size filled with zeros.
    canvas_grid = canvas(0, shape(I))
    # 4. Paint the shifted grid onto the canvas.
    O = paint(canvas_grid, shifted_grid)
    # 5. Fill the last column with zeros.
    O = paint(O, recolor(0, hfrontier((0, w))))
    return O
 
0.013749730661495367, 5.2298727, def jhdeedgbedfhebaabaadaadijbcfeadd(I):
  # Find the smallest object
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  smallest_obj = argmin(objs, size)

  # Calculate the position to add the column
  rightmost_col = rightmost(smallest_obj) 
  insert_pos = (uppermost(smallest_obj), rightmost_col + 1)

  # Create a column of the background color with the object's height
  bg_color = mostcolor(I)
  new_column = frozenset({(bg_color, (i, insert_pos[1])) for i in range(uppermost(smallest_obj), lowermost(smallest_obj) + 1)})

  # Combine the object with the new column
  modified_obj = combine(smallest_obj, new_column)

  # Paint the modified object back onto the original grid
  O = paint(cover(I, smallest_obj), modified_obj) 
  return O
 
0.05322045281739566, 5.5516496, def bcacdfadddabegcdjfdfbadefdadbcec(I):
    # Extract objects from the input grid
    objs = objects(I, univalued=False, diagonal=False, without_bg=False)

    # Find the smallest object based on its size
    smallest_obj = argmin(objs, size)

    # Determine the width of the input grid
    grid_width = width(I)

    # Shift the smallest object one position to the right
    shifted_obj = shift(smallest_obj, (0, 1))

    # Combine the original and shifted objects to create the output
    combined_obj = combine(smallest_obj, shifted_obj)

    # Create a blank canvas with the same dimensions as the input grid
    canvas_grid = canvas(mostcolor(I), (height(I), grid_width + 1))

    # Paint the combined object onto the blank canvas
    O = paint(canvas_grid, combined_obj)
    
    return O
 
0.018152475051976934, 9.932629, def hhdcdbbfdjbbeaaijfaececeeehbeafa(I):
  # Identify all objects within the input grid
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)

  # Determine the object with the smallest width
  target_obj = argmin(objs, width) 

  # Extract the upper-left corner coordinates of the target object
  i, j = ulcorner(target_obj)

  # Calculate the width of the target object
  obj_width = width(target_obj)

  # Duplicate the identified object horizontally, effectively adding a column to its right
  O = hconcat(I, tuple(tuple(I[row][col] for col in range(j, j + obj_width)) for row in range(i, i + height(target_obj))))

  return O 
 
0.025641025641025644, 119.8965, def iaabcefbaifieefiajicdcfbiaicaaaa(I):
  O = I
  for _ in range(len(I)):
    O = hconcat(O, ((0,) * len(I[0]),))
  return O
 
0.018152475051976934, 9.209784, def iaadjhedfdhdebigbaaeccceicedbdaa(grid):
  bg = mostcolor(grid)
  return hconcat(grid, apply(lambda row: row + (bg,), grid))
 
0.10817083243553832, 6.5637846, def adgcdbfhhfbeebeejdfecfabiaihcaji(I):
  # 1. Shift the input grid one position to the left.
  shifted_grid = shift(asobject(I), (0, 1))
  # 2. Create a canvas of the original size filled with zeros.
  canvas_grid = canvas(0, shape(I))
  # 3. Paint the shifted grid onto the canvas.
  O = paint(canvas_grid, shifted_grid)
  return O
 
0.10406752328498403, 4.296743, def jjhcjacahgcheebfbbabgefgehbejaad(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=False)
  shifted_objs = apply(lambda obj: shift(obj, (0, 1)), objs)
  O = canvas(mostcolor(I), (height(I), width(I) + 1))
  O = paint(O, merge(shifted_objs))
  return O
 
0.025641025641025644, 119.802795, def aejiddccdhbdecddaahdgiajdadaabba(I):
  new_column = tuple(repeat(0, len(I[0])))
  O = hconcat(I, tuple((new_column,)))
  return O
 
0.013749730661495367, 5.2298727, def cbdefhdebacjeehiaafcdaieaejhggcb(I):
  O = I
  for i in range(len(I)):
    O = paint(O, {(0, (i, len(I[0])))})
  return O
 
0.025376176111470233, 5.7438164, def cibcfaacgeedecegjeeibdeefacjeeeb(I):
  objs = objects(I, T, F, F)
  smallest = argmin(objs, size)
  color = lambda x: next(iter(x))[0]
  shifted = shift(smallest, (0, width(smallest)))
  return paint(I, shifted)
 
0.10406752328498403, 4.296743, def ecddadidcfjeeebabadcbhjaaahcbfij(I):
    # 1. Get the object representation of the input grid.
    obj = asobject(I)
    # 2. Shift all the cells in the object one position to the left.
    shifted_obj = shift(obj, (0, 1))
    # 3. Create a canvas of zeros with the same dimensions as the input grid, plus an additional column.
    canvas_grid = canvas(0, (height(I), width(I) + 1))
    # 4. Paint the shifted object onto the canvas.
    O = paint(canvas_grid, shifted_obj)
    return O
 
0.03516214177978884, 7.9101415, def cfcheajgicageedijfgfcifhbhgebbcb(I):
  objs = objects(I, univalued=False, diagonal=False, without_bg=True)
  trimmed_objs = frozenset(frozenset((v, (i, j)) for v, (i, j) in obj if j < rightmost(obj)) for obj in objs)
  O = paint(canvas(mostcolor(I), shape(I)), merge(trimmed_objs))
  return O
 
0.2920527185233068, 27.791574, def iceachfadbfcedefaifajiahabaacegi(I):
    objs = objects(I, univalued=False, diagonal=False, without_bg=True)
    trimmed_objs = frozenset(crop(I, ulcorner(obj), (height(obj), width(obj)-1)) for obj in objs)
    O = paint(canvas(mostcolor(I), shape(I)), merge(apply(asobject, trimmed_objs)))
    return O
 
0.10229640063474049, 4.7217174, def adaabffbcacaeahbbgddfddifacddfbc(I):
  # 1. Create a canvas of zeros one column wider than the input grid.
  canvas_grid = canvas(0, (height(I), width(I) + 1))
  # 2. Shift the input grid one position to the left on the canvas.
  shifted_grid = shift(asobject(I), (0,-1))
  # 3. Paint the shifted grid onto the canvas.
  O = paint(canvas_grid, shifted_grid)
  return O
 
0.025641025641025644, 119.80753, def adfjfffdgdbeeficibhfabcfbdcddgic(I):
  return hconcat(I, tuple((mostcolor(I),) * len(I) for _ in range(1)))
 
0.018152475051976934, 3.77065, def jedchbeecefbedieifaaiaadigfeefba(I):
  return tuple(row + (mostcolor(I),) for row in I)
 
0.013749730661495367, 5.2298727, def fdafbdibdhfdebjjihbdaafiidachbhd(I):
  """
  Inserts a column of zeros at the last index of each row.
  """
  return tuple(tuple(v if j < len(row) else 0 for j, v in enumerate(row)) for row in I)
 
0.02015998707175178, 17.470627, def aeccdadcaecdecibacedbdgeafbideab(I):
  return hconcat(I, vupscale(((0,)*(len(I)),), len(I[0]))) 
 
0.018152475051976934, 18.66794, def fbbfidgbdbefehicaadiecffffdbfacf(I):
  new_col = tuple(repeat(mostcolor(I), len(I[0])))
  return tuple(row + new_col for row in I) 
 
0.022296739208503915, 6.5840683, def iabaehaibhbfeajejecgaeaedcajcbja(I):
  """
  Appends a column of zeros to the right of the input grid.
  """
  O = paint(I, recolor(0, hfrontier((0, width(I)))))  # Paints a zero-column at the right edge
  return O
 
0.025641025641025644, 119.80753, def cieaehbhhbbfeaeeajcefagehgddided(I):
  return hconcat(I, ((0,) * len(I),))
 
0.11983318968613088, 16.860378, def jfdbdcfegfhaeajgigacgadbafjedaff(I):
  O = I
  for _ in range(len(I[0])):
    O = rot90(O)
  for _ in range(len(I)):
    O = vconcat(((0,) * len(O[0]),), O)
  for _ in range(len(I[0])):
    O = rot90(O)
  return O
 
0.018152475051976934, 18.66794, def gcefbdbdbfajefaabegfedjbiaebaaaa(grid):
  return hconcat(grid, tuple(((mostcolor(grid),) * len(grid[0])) for _ in range(len(grid))))
 
0.1802727501256913, 6.6477456, def egidjjbdfahfecfcbabfadadifccbfii(matrix):
  return tuple(zip(*matrix))
 
